{"Question": "How to understand the knapsack problem is NP-complete?\r\n                \r\nWe know that the knapsack problem can be solved in O(nW) complexity by dynamic programming. But we say this is a NP-complete problem. I feel it is hard to understand here.\n\n(n is the number of items. W is the maximum volume.)\n    ", "Answer": "\r\n```\nO(n*W)```\n looks like a polynomial time, but it is not, it is pseudo-polynomial.\n\nTime complexity measures the time that an algorithm takes as a function of the length in bits of its input. The dynamic programming solution is indeed linear in the value of ```\nW```\n, but exponential in the length of ```\nW```\n — and that's what matters!\n\nMore precisely, the time complexity of the dynamic solution for the knapsack problem is basically given by a nested loop:\n\n```\n// here goes other stuff we don't care about\nfor (i = 1 to n)\n    for (j = 0 to W)\n        // here goes other stuff\n```\n\n\nThus, the time complexity is clearly ```\nO(n*W)```\n. \n\nWhat does it mean to increase linearly the size of the input of the algorithm? It means using progressively longer item arrays (so ```\nn```\n, ```\nn+1```\n, ```\nn+2```\n, ...) and progressively longer ```\nW```\n (so, if ```\nW```\n is ```\nx```\n bits long, after one step we use ```\nx+1```\n bits, then ```\nx+2```\n bits, ...). But the value of ```\nW```\n grows exponentially with ```\nx```\n, thus the algorithm is not really polynomial, it's exponential (but it looks like it is polynomial, hence the name: \"pseudo-polynomial\").\n\n\n\nFurther References\n\n\nhttp://www.cs.ship.edu/~tbriggs/dynamic/index.html\nhttp://websrv.cs.umt.edu/classes/cs531/index.php/Complexity_of_dynamic_programming_algorithm_for_the_0-1_knapsack_problem_3/27\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple Constraint Knapsack Problem\r\n                \r\nIf there is more than one constraint (for example, both a volume limit and a weight limit, where the volume and weight of each item are not related), we get the multiply-constrained knapsack problem, multi-dimensional knapsack problem, or m-dimensional knapsack problem.\n\nHow do I code this in the most optimized fashion? Well, one can develop a brute force recursive solution. May be branch and bound.. but essentially its exponential most of the time until you do some sort of memoization or use dynamic programming which again takes a huge amount of memory if not done well.\n\nThe problem I am facing is this\n\nI have my knapsack function \nKnapSack( Capacity, Value, i) instead of the common\nKnapSack ( Capacity , i ) since I have upper limits on both of those. can anyone guide me with this? or provide suitable resources for solving these problems for reasonably large n\n\nor is this NP complete ?\n\nThanks\n    ", "Answer": "\r\nMerge the constraints. Look at  http://www.diku.dk/~pisinger/95-1.pdf\nchapter 1.3.1 called Merging the Constraints. \n\nAn example is say you have\nvariable , constraint1 , constraint2\n1 , 43 , 66\n2 , 65 , 54\n3 , 34 , 49\n4 , 99 , 32\n5 , 2  , 88  \n\nMultiply the first constraint by some big number then add it to the second constraint.\n\nSo you have\nvariable , merged constraint\n1 , 430066\n2 , 650054\n3 , 340049\n4 , 990032\n5 , 20088  \n\nFrom there do whatever algorithm you wanted to do with one constraint. The main limiter that comes to mind with this how many digits your variable can hold.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "large test data for knapsack problem\r\n                \r\ni am researcher student. I am searching large data for knapsack problem. I wanted test my algorithm for knapsack problem. But i couldn't find large data. I need data has 1000 item and capacity is no matter. The point is item as much as huge it's good for my algorithm. Is there any huge data available in internet. Does anybody know please guys i need urgent.\n    ", "Answer": "\r\nYou can quite easily generate your own data. Just use a random number generator and generate lots and lots of values. To test that your algorithm gives the correct results, compare it to the results from another known working algorithm.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Reducing knapsack problem to an inverse knapsack problem\r\n                \r\n1)Suppose we have a common 0-1 knapsack problem. Given a set of n items numbered from 1 up to n, each with a weight w_i and a value v_i, along with a maximum weight capacity W. Here we need to select some of the objects, so that maximize sum of v_i, such that sum of w_i of selected objects will not exceed the given W number.\n\n```\n       maximize∑(v_i*x_i), such that ∑(w_i*x_i)≤ W\n```\n\n\n2)Now suppose we have just the same problem, but we need to select objects so that  sum of their values will be minimal, and sum of their weights can't be less than the given number.\n\n```\n      minimize∑(v_i*x_i), such that ∑(w_i*x_i)≥ W.\n```\n\n\nKnowing that first problem is NP complete, how can I prove that second one has the same complexity, in other words is NP complete too?\n    ", "Answer": "\r\n\n  Knowing that first problem is NP complete, how can I prove that second one has the same complexity, in other words is NP complete too?\n\n\nIf you want to prove that problem ```\nB```\n is NP-complete, you have to prove that there exists a polynomial time reduction from ```\nA```\n to ```\nB```\n, where ```\nA```\n is known to be a NP-complete problem.\nA polynomial-time reduction from a problem ```\nA```\n to a problem ```\nB```\n is an algorithm that solves problem ```\nA```\n using a polynomial number of calls to a subroutine for problem ```\nB```\n, and polynomial time outside of those subroutine calls.(source).\n\nSo in your case, your can easily make a polynomial time reduction from the knapsack problem to the inversed knapsack problem.\nThese two problems are equivalent (finding an optimal solution to one immediately solves the other).\nLet ```\nS```\n be the set of objects, ```\nM```\n be the sum of the weights of the objects of ```\nS```\n, and ```\nW```\n the capacity of the knapsack.\nThen, we have:  \n\n\n```\n(i)```\n finding a subset of objects such that the sum of their weight does not exceed ```\nW```\n and the sum of their value is maximal  \n\n\nis equivalent to  \n\n\n```\n(ii)```\n finding a subset of objects such that the sum of their weight is of at least ```\nM-W```\n and the sum of their value is minimal.  \n\n\nThat is because if ```\nS'```\n is an optimal solution of ```\n(i)```\n, then ```\nS\\S'```\n is an optimal solution of ```\n(ii)```\n (and vice-versa).\n\nThis is a polynomial time reduction (```\nO(1)```\n calls to the subroutine, polynomial number of operations), so the inversed knapsack is indeed NP-complete.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why solving Knapsack problem is not considered as linear programming?\r\n                \r\nWhy isn't the knapsack problem included under the category of linear programming algorithms in spite of the fact that the Knapsack problem statement seems similar to the problems in linear programming?\n    ", "Answer": "\r\nKnapsack can be written as an integer linear programming program. Unlike normal linear programming, this problem requires that variables in the solution are integers. Linear programming is known to be solvable in polynomial time, while integer linear programming is NP-complete.\n\nExercise for the reader: show that 3SAT can be reduced to integer linear programming.\n\nTrivia: there are approximation algorithms for problems such as MAX-3SAT (a variant of 3SAT where we want to maximize the number of satisfied clauses). First you write MAX-3SAT as an integer linear program. Then, you relax it to linear program, by removing the integer restriction. Then, you solve the linear program in polynomial time. Finally, given real xi ∈ [0,1], you round them to integers, or generate random integer solution yi where probability of yi = 1 is xi.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is this an instance of the knapsack problem?\r\n                \r\nI have what seems like a simple problem, but I'm struggling to solve it. Turning to Google it appears this may be a variation of the Knapsack problem, but I'm having trouble mapping those solutions to this particular problem.\n\nLet's say I have two lists of positive integers, A and B. I want to find the value that represents the largest common sum between these two lists.\n\n```\nA: [6, 1]\nB: [5, 3, 1]\n```\n\n\nHere, the answer is 6, because that's the largest sum that can be created commonly in both lists (by removing the 1 in list A and removing the 3 in list B).\n\nI can naively solve this in O(2^n) but I'm assuming there's a much more efficient approach via dynamic programming, though dp is not my strength.\n\nIs this the knapsack problem? Any pointers as to how I should map the classic knapsack problem to this two-list problem? \n    ", "Answer": "\r\nThis can be solved in ```\nO(nW)```\n, where ```\nn```\n is count of all elements and ```\nW```\n is a sum of all elements in lists.\n\nProcess each list separately. Let ```\ndp1[i][j]```\n be true if there is a subset of the first ```\ni```\n elements of the first list, which sum is equal to ```\nj```\n (```\n0 <= i <= n1```\n, ```\n0 <= j <= W1```\n). ```\ndp1```\n can be filled using recurrent formula:\n\n\n```\ndp1[0][0]```\n is ```\ntrue```\n\n```\ndp1[0][j]```\n is ```\nfalse```\n (```\nj != 0```\n)\nEDIT: ```\ndp1[i][0]```\n is ```\ntrue```\n (```\ni != 0```\n)\n```\ndp1[i][j]```\n is ```\ntrue```\n if:\n\n\n(```\nj >= list.get(i)```\n AND ```\ndp[i - 1][j - list.get(i)]```\n is ```\ntrue```\n)\nOR ```\ndp[i - 1][j]```\n is ```\ntrue```\n\n\n\n\nThen fill ```\ndp2[i][j]```\n for the second list. Then just find the maximum number ```\nS```\n for which both ```\ndp1[n1][S]```\n and ```\ndp2[n2][S]```\n are ```\ntrue```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why is the knapsack problem pseudo-polynomial?\r\n                \r\nI know that ```\nKnapsack```\n is NP-complete while it can be solved by DP. They say that the DP solution is ```\npseudo-polynomial```\n, since it is exponential in the \"length of input\" (i.e. the numbers of bits required to encode the input). Unfortunately I did not get it. Can anybody explain that ```\npseudo-polynomial```\n thing to me slowly ?\n    ", "Answer": "\r\nThe running time is O(NW) for an unbounded knapsack problem with N items and knapsack of size W. W is not polynomial in the length of the input though, which is what makes it pseudo-polynomial.\n\nConsider W = 1,000,000,000,000. It only takes 40 bits to represent this number, so input size = 40, but the computational runtime uses the factor 1,000,000,000,000 which is O(240).\n\nSo the runtime is more accurately said to be O(N.2bits in W), which is exponential.\n\nAlso see:\n\n\nHow to understand the knapsack problem is NP-complete?\nThe NP-Completeness of Knapsack\nComplexity of dynamic programming algorithm for the 0-1 knapsack problem\nPseudo-polynomial time\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Variation of Knapsack Problem: adding Low bounder\r\n                \r\nClassic variation of 0/1 Knapsack Problem: Only I have to specify low bounder. It means I have to find maximum value and make sure that total weight is equal or higher than some given value but not higher than capacity of a Knapsack. Basically, determine that the solution is between 2 boundries.  \n\nI have already code 0/1 Knapsack problem with dynamic programming. And I could test it for low bounder. Something like if the solution is lower than low bounder find second best solution for knapsack and so on. But I believe there is a better way.\n\nThank you \n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack problem (classic)\r\n                \r\nSo I have to solve the knapsack problem for class.  So far, I've come up with the following.  My comparators are functions that determine which of two subjects will be the better option (by looking at the corresponding (value,work) tuples).\n\nI decided to iterate over the possible subjects with work less than maxWork, and in order to find which subject is the best option at any given turn, I compared my most recent subject to all the other subjects that we have not used yet.\n\n```\ndef greedyAdvisor(subjects, maxWork, comparator):\n    \"\"\"\n    Returns a dictionary mapping subject name to (value, work) which includes\n    subjects selected by the algorithm, such that the total work of subjects in\n    the dictionary is not greater than maxWork.  The subjects are chosen using\n    a greedy algorithm.  The subjects dictionary should not be mutated.\n\n    subjects: dictionary mapping subject name to (value, work)\n    maxWork: int >= 0\n    comparator: function taking two tuples and returning a bool\n    returns: dictionary mapping subject name to (value, work)\n    \"\"\"\n\n    optimal = {}\n    while maxWork > 0:\n        new_subjects = dict((k,v) for k,v in subjects.items() if v[1] < maxWork)\n        key_list = new_subjects.keys()\n        for name in new_subjects:\n            #create a truncated dictionary\n            new_subjects = dict((name, new_subjects.get(name)) for name in key_list)\n            key_list.remove(name)\n            #compare over the entire dictionary\n            if reduce(comparator,new_subjects.values())==True:\n                #insert this name into the optimal dictionary\n                optimal[name] = new_subjects[name]\n                #update maxWork\n                maxWork = maxWork - subjects[name][1]\n                #and restart the while loop with maxWork updated\n                break\n    return optimal  \n```\n\n\nThe problem is I don't know why this is wrong.  I'm getting errors and I have no idea where my code is wrong (even after throwing in print statements).  Help would be much appreciated, thanks!\n    ", "Answer": "\r\nUsing a simple greedy algorithm will not provide any bounds on the quality of the solution in comparison to OPT.\n\nHere is a fully polynomial time (1 - epsilon) * OPT approximation psuedocode for knapsack:\n\n```\nitems = [...]  # items\nprofit = {...} # this needs to be the profit for each item\nsizes = {...}  # this needs to be the sizes of each item\nepsilon = 0.1  # you can adjust this to be arbitrarily small\nP = max(items) # maximum profit of the list of items\nK = (epsilon * P) / float(len(items))\nfor item in items:\n    profit[item] = math.floor(profit[item] / K)\nreturn _most_prof_set(items, sizes, profit, P)\n```\n\n\nWe need to define the most profitable set algorithm now. We can do this with some dynamic programming. But first lets go over some definitions.\n\nIf P is the most profitable item in the set, and n is the amount of items we have, then nP is clearly a trivial upper bound on the profit allowed. For each i in {1,...,n} and p in {1,...,nP} we let Sip denote a subset of items whose total profit is exactly p and whose total size is minimized. We then let A(i,p) denote the size of set Sip (infinity if it doesn't exist). We can easily show that A(1,p) is known for all values of p in {1,...,nP}. We will define a recurrance to compute A(i,p) which we will use as a dynamic programming problem, to return the approximate solution.\n\n```\nA(i + 1, p) = min {A(i,p), size(item at i + 1 position) + A(i, p - profit(item at i + 1 position))} if profit(item at i + 1) < p otherwise A(i,p)\n```\n\n\nFinally we give _most_prof_set\n\n```\ndef _most_prof_set(items, sizes, profit, P):\n    A = {...}\n    for i in range(len(items) - 1):\n        item = items[i+1]\n        oitem = items[i]\n        for p in [P * k for k in range(1,i+1)]:\n            if profit[item] < p:\n                A[(item,p)] = min([A[(oitem,p)], \\\n                                     sizes[item] + A[(item, p - profit[item])]])\n            else:\n                A[(item,p)] = A[(oitem,p)] if (oitem,p) in A else sys.maxint\n    return max(A) \n```\n\n\nSource\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "python program give error(fraction knapsack problem)\r\n                \r\nfraction knapsack problem with python it gives an error when i'm running the code, is the split function is not working for the integer values.\n\n```\nTraceback (most recent call last):\n  File \"C:/Users/Akshay/Desktop/python/kapsack_problem.py\", line 49, in <module>\n    .format(n)).split()\n  File \"<string>\", line 1\n    60 100 120\n         ^\nSyntaxError: invalid syntax \n```\n\n\nHere is the source code of a Python program to solve the fractional knapsack problem using greedy algorithm. what i'm doing wrong please tell me.\nthanks in advance.\n\n```\ndef fractional_knapsack(value, weight, capacity):\n\n    index = list(range(len(value)))\n    # contains ratios of values to weight\n    ratio = [v/w for v, w in zip(value, weight)]\n    # index is sorted according to value-to-weight ratio in decreasing order\n    index.sort(key=lambda i: ratio[i], reverse=True)\n\n    max_value = 0\n    fractions = [0]*len(value)\n    for i in index:\n        if weight[i] <= capacity:\n            fractions[i] = 1\n            max_value += value[i]\n            capacity -= weight[i]\n        else:\n            fractions[i] = capacity/weight[i]\n            max_value += value[i]*capacity/weight[i]\n            break\n\n    return max_value, fractions\n\n\nn = int(input('Enter number of items: '))\nvalue = input('Enter the values of the {} item(s) in order: '\n              .format(n)).split()\nvalue = [int(v) for v in value]\nweight = input('Enter the positive weights of the {} item(s) in order: '\n               .format(n)).split()\nweight = [int(w) for w in weight]\ncapacity = int(input('Enter maximum weight: '))\n\nmax_value, fractions = fractional_knapsack(value, weight, capacity)\nprint('The maximum value of items that can be carried:', max_value)\nprint('The fractions in which the items should be taken:', fractions)\n```\n\n    ", "Answer": "\r\nIt seems that you try to run this code with a ```\nPython 2.x```\n interpreter, while your code is written in ```\nPython 3```\n. In order to be able to run it, you need to check that ```\nPython 3```\n is installed on your machine (see here for installations instructions).\nTo run it, run \n\n```\npython3 my_script.py\n```\n\n\nin a terminal.\nAnother possiblity is to paste\n\n```\n#!/usr/bin/env python3\n```\n\n\nat the top of your python script. Then if you make the file executable (by running ```\nchmod +x myscript.py```\n on ubuntu for instance), you can then run it simply with\n\n```\n./my_script.py\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack p‌r‌o‌b‌l‌e‌m modified to unlimited elements\r\n                \r\nIn the Knapsack problem, there is a list of elements, that each one of them contain weight and cost.\nI would like to do a dynamic algorithm that will deal with the knapsack problem, but any element can be chosen more than once.\n    ", "Answer": "\r\nI think following solution from GeeksForGeeks demonstrates what you want to do with help of Algorithm, examples and implementation. \n\nIt is Min-cost Knapsack , you can add an item more than once.\n\nNOTE: here object weights are the indices in array, starting at 1. i.e. ```\nw[] = {1,2,3,4,5}```\n\n\n```\ncost[]```\n is cost required when you add particular object.\n\nIf you add cost[1 ]=20 then w[1 ]=1 kg, cost2=10 then w2=2 kg and so on.\n\n\n\nhope this helps.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "C- adding names of items in knapsack problem\r\n                \r\nI tried to solve the knapsack problem in C language, and the algorithm itself was successful, but I want to print out the names of items in the knapsack(not all the items in input). Please help me.\n```\n#include <stdio.h>\n#include <string.h>\n\n#define MAX(a, b) (((a) > (b)) ? (a) : (b))\n\nint DP[103][100003];\nint w[103]; //weight of items\nint v[103]; //value\n\nint main() {\n    char s1[11][11]; //saved names of all items here\n\n    int n, k; //n = number of items, k = size of knapsack\n    printf(\"input number of items and size of knapsack\");\n    scanf(\"%d %d\", &n, &k); \n\n    printf(\"\\n input name, weight, value of items\");\n    for (int i = 1; i <= n; i++)\n        scanf(\"%s %d %d\", s1[i-1], & w[i], &v[i]);\n\n    for (int i = 1; i <= n; i++) { //knapsack algorithm\n        for (int j = 1; j <= k; j++) {\n            if (j >= w[i])\n            {\n                DP[i][j] = MAX(DP[i - 1][j], DP[i - 1][j - w[i]] + v[i]);\n            }\n            else\n            {\n                DP[i][j] = DP[i - 1][j];\n            }\n        }\n    }\n    printf(\"\\n maximun value: %d)\",DP[n][k]);\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\n\n\"...but I want to print out the names of items in the knapsack.\"\n\nSince you have already scanned in the names, the most common way output them would be to place ```\nprintf(...)```\n statements in your ```\nfor(...)```\n loop, eg:\n```\nif (j >= w[i])\n{\n    DP[i][j] = MAX(DP[i][j], DP[i][j - w[i]] + v[i]);\n    printf(\"Name: %s Weight %d Value: %d\\n\", s1[i], w[i], v[i]);\n}\n```\n\nSome other items:\n```\nint DP[103][100003];\n```\n\na 10 megabyte array could cause problems if you do not have a large stack-size defined.  There may be more efficient ways to do this if you size your arrays at run-time according to user input.\nNote also that in C, indexing begins at zero  Typically then your ```\nscanf```\n and loops would be change as follows:\nFROM:\n```\n    scanf(\"%s %d %d\", s1[i-1], & w[i], &v[i]);\n\nfor (int i = 1; i <= n; i++) { //knapsack algorithm\n    for (int j = 1; j <= k; j++) {\n```\n\nTO:\n```\n    i = 0;\n    scanf(\"%s %d %d\", s1[i], & w[i], &v[i]);\n\nfor (int i; i < n; i++) { //knapsack algorithm\n    for (int j = 0; j < k; j++) {\n```\n\nAlso it is always a good idea to initialize all variables:\n```\nint DP[103][100003] = {{0}};\nint w[103] ={0}; //weight of items\nint v[103] = {0}; //value\n//etc.\n```\n\nNote on using ```\nscanf(...)```\n:  It is always recommended that you verify the items intended to be parsed from ```\nstdin```\n (or whatever source you are using) are actually parsed before assuming wrongly and attempting to use them if they did not parse correctly. Something like this will do that:\n```\nif(scanf(\"%d %d\", &n, &k) 1= 2)\n{\n    printf(\"Error in count of arguments parsed.  Exiting\");\n    return 0;\n}\n```\n\nNote that there are logic errors in your code that I have not addressed.  For example testing equality of an index value against a user provided weight does not make sense:\n```\n if (j >= w[i])  \n```\n\nI suggest that you use the features of a good debugger to help you finish verifying that the code actually does what you intended it to.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "variant of knapsack problem\r\n                \r\nI have 'n' number of amounts (non-negative integers). My requirement is to determine an optimal set of amounts so that the sum of the combination is less than or equal to a given fixed limit and the total is as large as possible. There is no limit to the number of amounts that can be included in the optimal set.\n\nfor sake of example: amounts are 143,2054,546,3564,1402 and the given limit is 5000.\n\nAs per my understanding the knapsack problem has 2 attributes for each item (weight and value). But the problem stated above has only one attribute (amount). I hope that would make things simpler? :)\n\nCan someone please help me with the algorithm or source code for solving this?\n    ", "Answer": "\r\nthis is still an NP-hard problem, but if you want to (or have to) to do something like that, maybe this topic helps you out a bit:\n\nfind two or more numbers from a list of numbers that add up towards a given amount\n\nwhere i solved it like this and NikiC modified it to be faster. only difference: that one was about getting the exact amount, not \"as close as possible\", but that would be only some small changes in code (and you'll have to translate it into the language you're using).\n\ntake  a look at the comments in my code to understand what i'm trying to do, wich is, in short form:\n\n\ncalculating all possible combinations of the given parts and sum them up\nif the result is the amount i'm looking for, save the solution to an array\nat least, sort all possible solutions to get the one using the least parts\n\n\nso you'll have to change:\n\n\nsave a solution if it's lower than the amount you're looking for\nsort solutions by total amount instead of number of used parts\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem in F# with recursive function\r\n                \r\nWe have to program the knapsack problem in for a school project in different programming types. One is functional programming and I am trying it in F#.\n\nI am using a recursive function to always get the items with the highest value to put into my knapsack. At the end I want to have the highest total value of all elements combined. Here is the solution in Python and I just hoped I could transfer it to F#.\n\n```\n    let names = [\"Zahnbürste\",\"Zahnpasta\", \"Teller\", \"Duschgel\", \"Shampoo\", \"Handtuch\", \"Besteck\", \"Trinkflasche\", \"Becher\", \"Taschenlampe\", \"Sonnenschutz\", \"Medikamente\"]\nlet volumes = [2,4,5,2,2.5,10,5,3,3,9,2,1]\nlet values = [3,19,17,15,13,3,2,8,5,6,17,15]\n    maxVol = 20;\n\ndef rucksackProblem(restVol, i) :\nif (i < (len(volumes))) :\n    dontPack = rucksackProblem(restVol, i + 1)\n\n    pack = 0\n    if (restVol - volumes[i] >= 0) :\n        pack = values[i] + rucksackProblem(restVol - volumes[i], i + 1)\n    if (dontPack > pack) :\n        return dontPack\n    else :\n        return pack\nelse :\n    return 0\n\n\nresult = rucksackProblem(maxVol, 0)\nprint(result)\n```\n\n\nThis is what I tried in F#. Please help me figuring out my problems. I am new to F# and functional programming and other solutions to the knapsack problem with hundreds of code lines seem overcomplicated. This doesn´t really print the end result I want to get from this function. It just returns 0:\n\n```\n\n   open System\n\nlet names_list = [\"Zahnbürste\";\"Zahnpasta\"; \"Teller\"; \"Duschgel\";\"Shampoo\"; \"Handtuch\"; \"Besteck\"; \"Trinkflasche\"; \"Becher\";\"Taschenlampe\";\"Sonnenschutz\";\"Medikamente\"]\nlet volumes_list = [2;4;5;2;3;10;5;3;3;9;2;1]\nlet values_list = [3;19;17;15;13;3;2;8;5;6;17;15]\nlet maxVolume = 20\nlet rec rucksackProblem (restVol : int, i : int) =\n    if i < volumes_list.Length then\n       let dontPack = rucksackProblem(restVol, i + 1) \n       let pack = 0\n       let currentVolumeItem = volumes_list.Item(i)\n       if restVol - volumes_list.Item(i) >= 0 then\n        let mutable pack = values_list.Item(i) + rucksackProblem(restVol - volumes_list.Item(i), i + 1)\n        printf \"%i\" (volumes_list.Item(i))\n        else()\n       if dontPack > pack then\n        dontPack\n        else \n            pack\n\n    else\n        0\n\nlet result = rucksackProblem(maxVolume, 0)\nprintfn \"%i\" result\n\n\nConsole.ReadKey() |> ignore\n```\n\n    ", "Answer": "\r\nI took the liberty to rewrite your code and I ended up with this.\n\n\n```\n\n    let names = [\"Zahnbürste\"; \"Zahnpasta\"; \"Teller\"; \"Duschgel\"; \"Shampoo\"; \"Handtuch\"; \"Besteck\"; \"Trinkflasche\"; \"Becher\"; \"Taschenlampe\"; \"Sonnenschutz\"; \"Medikamente\"]\n    let weights = [2; 4; 5; 2; 3; 10; 5; 3; 3; 9; 2; 1]\n    let profits = [3; 19; 17; 15; 13; 3; 2; 8; 5; 6; 17; 15]\n    let cap = 20\n\n    type Product = { Name: string; Profit: int; Weight: int }\n\n    let knappsack names profits weights cap =\n        let sortItemsInDecreasingOrder =\n            List.zip3 names profits weights\n            |> List.map (fun x -> { Name=x.Item1; Profit=x.Item2; Weight=x.Item3 })\n            |> List.sortBy (fun p -> p.Profit / p.Weight)\n            |> List.rev\n        let products = sortItemsInDecreasingOrder\n        let rec pack bag totalWeight idx =\n            if idx > List.length names - 1 then bag\n            else\n                let p = products.[idx]\n                if (totalWeight + p.Weight) > cap then bag\n                else\n                    pack (bag @ [p]) (totalWeight + p.Weight) (idx + 1)\n        pack List.empty 0 1\n\n    knappsack names profits weights cap\n    |> Dump\n    |> ignore\n```\n\n\n\nThe result I get is\n\n\n    Name            Profit  Weight\n    Sonnenschutz    17      2 \n    Duschgel        15      2 \n    Shampoo         13      3 \n    Zahnpasta       19      4 \n    Teller          17      5 \n    Trinkflasche    8       3 \n                    89      19\n\n\nBtw. if you are interested in learning functional programming using f# I can highly recommend https://fsharpforfunandprofit.com/.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Theoretical basis of the Knapsack problem\r\n                \r\nI cannot imagine how to develop the ideas about the theoretical basis of the Knapsack problem and also do not know any useful documents about it. I hope someone can help me.\nI would like to know how these sections will develop the ideas. This is my first time doing this, so I am still unsure and inexperienced.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "JaCoP: Solving an 0/1 knapsack problem\r\n                \r\nI've been trying to teach myself how to use the JaCoP constraint programming library but I'm having a bit of difficulty implementing an 0/1 knapsack problem. I've tried a problem size of 4 and defined the items and variables as follows:\n\n```\nknapsack[0] = new KnapsackItem(quantity[0], 5, 7);\nknapsack[1] = new KnapsackItem(quantity[1], 7, 9);\nknapsack[2] = new KnapsackItem(quantity[2], 2, 3);\nknapsack[3] = new KnapsackItem(quantity[3], 3, 3);\n\n\n\n  IntVar knapsackCapacity = new IntVar(store, \"capacity\", 0, 10);\n    IntVar knapsackProfit = new IntVar(store, \"profit\", 0, 22);\n```\n\n\nI've then added a Knapsack constraint using the knapsack list:\n\nConstraint con = new Knapsack(knapsack, knapsackCapacity, knapsackProfit);\nstore.impose(con);\n\nAnd I have then searched for a solution in the way given in the tutorial:\n\n```\n//search for a solution and print results\nSearch<IntVar> search = new DepthFirstSearch<IntVar>();\nSelectChoicePoint<IntVar> select = new InputOrderSelect<IntVar>(store, quantity,\n           new IndomainMin<IntVar>());\nboolean result = search.labeling(store, select);\n\nif (result) {\n System.out.println(\"Solution: \"+quantity[0]+\", \"+quantity[1]+\", \"+quantity[2]+\",     \"+quantity[3]);\n} else {\n System.out.println(\"*** No\");\n}\n```\n\n\nThe result I get is simply that all the quantities are zero, which satisfies the constraints but doesn't optimise anything. Is there another constraint or something I should add to try and maximise profit * quantity for each item?\n\nThank you\n\nBen\n    ", "Answer": "\r\nI have not used the ```\nKnapsack```\n constraint, but in general to optimize (minimize) you use the following (the cost as third argument):\n\n```\nsearch.labeling(store, select, cost);\n```\n\n\nNote that this minimizes the cost, so you must convert the profit to a \"negative cost\". The example ```\nExamplesJaCoP/KnapsackExample.java```\n (combined with ```\nExamplesJaCoP/Example.java```\n) show the principle. However, the example don't use```\nKnapsackItem```\n, just plain ```\nIntVar```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do i get the name of items in knapsack in knapsack-problem\r\n                \r\nHere is my javascript code that solves knapsack problem without dynamic programming. I wanted to get the names of items that are in the sack. How do I get it ? W = total weight of knapsack, wt = weight of items, val = value of items, n = number of items\n```\nfunction knapSack(W, wt, val, n) {\n    if (n == 0 || W == 0) {\n        return 0;\n    }\n    \n    if (wt[n-1] > W) {\n        return knapSack(W, wt, val, n-1);\n    }\n    \n    else {\n        return Math.max(val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\n                        knapSack(W, wt, val, n-1))\n    }\n}\n\n\nitem = {\nname: ['egg', 'jam', 'bread', 'banana', 'cola', 'chewing gum'],\nvalue: [3,2,5,4,3,1]\n}\nwt = [8, 8, 10, 5, 8, 1] \nW = 20\nn = item.priority.length\nconsole.log(knapSack(W, wt, item.value, n)) \n```\n\n    ", "Answer": "\r\nNot being a javascript programmer this is guaranteed to be wrong\n```\n    incl = knapSack(W-wt[n-1], wt, val, n-1)\n    excl = knapSack(W, wt, val, n-1)\n    cur = val[n-1] + incl[0]\n    if (cur > excl[0]) {\n      incl[0] = cur\n      return [ ...incl, items.name[n-1]]\n    } else {\n      return excl;\n    }\n```\n\nStoring the weight in index 0 and the names starting a index 1.\nThe ... is descript here which I was coincidently watching as I saw this question.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Adding a minimum number of items to the Knapsack problem\r\n                \r\nLong term reader, first time poster. I've been banging my head against this problem for a few months now and I'm starting to wave the white flag here.\nProblem: Set a lower bound on the number of items stuffed into a knapsack in the knapsack problem.\nThe Knapsack Problem is a well known problem of combinatorial optimization. Given a set of items, each with a weight and a value, we must determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value must be maximized.\n(https://ssaurel.medium.com/solving-the-knapsack-problem-in-java-c985c71a7e64)\nThe algorithm I'm utilizing is the DP dynamic programming flavor, and current guidance says in order to set a bound on the number of items selected, you add another dimension to the dp[] array. I successfully implemented this for an upper bound (ie maximum number of items that can be selected), but darned if I can get the lower bound to work. I also tried tinkering with the integer range in the for loop used to control the upper bound with no success.\nIn my data input, I have 4 items: RUBY, DIAMOND, EMERALD, SAPPHIRE. In the program below I overweight the RUBY's value so the knapsack can only store the 1 item; however, the desired behavior is to accept the minItems constraint so the RUBY would be discounted and the other gems selected as part of the solution. (Desired output below). Lil help? Thanks in advance.\nKL\n```\npublic class Knapsack { \n    static class Item {\n        private int weight;\n        private int value;\n        private String name;\n        public int getWeight() {\n            return weight;\n        }\n        public void setWeight(int weight) {\n            this.weight = weight;\n        }\n        public int getValue() {\n            return value;\n        }\n        public void setValue(int value) {\n            this.value = value;\n        }\n        public String getName() {\n            return name;\n        }\n        public void setName(String name) {\n            this.name = name;\n        }\n        \n        \n    }\n\n    public static void main(String[] args) {        \n        int[][][] dp = null;\n        int weightLimit = 100; \n        int maxItems = 3; //Works by adding a 3rd dimension to the dp array\n        int minItems = 3;  //  ------------> Can't get working. Bah!\n        \n\n        //The list of items from which you select to pack into your knapsack\n        ArrayList<Item> itemList = new ArrayList<Item>();  \n    \n        //Create some items and add them to a list\n        \n        //The RUBY is given the highest value and also highest weight, which nearly stuffs the whole knapsack. It is selected\n        //by the algorithm as providing the best value, however, if a minimumNumber of items is specified, I want it to discount\n        //that solution and select the DIAMOND, EMERALD, AND SAPPHIRE instead. The max uppper bound seems to work just fine....\n        Item item1 = new Item();\n        item1.setName(\"RUBY\");\n        item1.setValue(90);\n        item1.setWeight(110);\n        itemList.add(item1);\n\n        Item item2 = new Item();\n        item2.setName(\"DIAMOND\");\n        item2.setValue(15);\n        item2.setWeight(15);\n        itemList.add(item2);\n\n        Item item3 = new Item();\n        item3.setName(\"EMERALD\");\n        item3.setValue(10);\n        item3.setWeight(15);\n        itemList.add(item3);\n        \n        Item item4 = new Item();\n        item4.setName(\"SAPPHIRE\");\n        item4.setValue(10);\n        item4.setWeight(15);\n        itemList.add(item4);\n        \n        \n        \n        //Dynamic Programming Knapsack solution as per everywhere on the internet (https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/)   \n        Item[] items = itemList.toArray(new Item[itemList.size()]);\n        ArrayList<Item> selectedList = new ArrayList<Item>();\n        int numItems = itemList.size();\n        dp = new int[numItems + 1][weightLimit + 1][maxItems + 1];\n        \n        // for each item\n        for (int i = 1; i <= numItems; i++) {\n            // For each possible weight\n            for (int j = 1; j <= weightLimit; j++) {\n                // For each case where the total items are less than the maximum allowed    ----------------------------> Adding this 3rd dimension to the dp array ensures we can set a maximum number of items to select\n                for (int k = 1; k <= maxItems; k++) {\n                    // To ensure that we dont go out of the array\n                        if (j >= items[i - 1].getWeight()) {\n                            dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - items[i - 1].getWeight()][k - 1] + items[i - 1].getValue());\n                        } else {\n                            dp[i][j][k] = dp[i - 1][j][k];\n                        }\n                }\n            }\n        }\n\n        int res = dp[numItems][weightLimit][maxItems];\n        int j = weightLimit;\n        int k = maxItems;\n\n        for (int i = numItems; i > 0 && res > 0; i--) {\n            // either the result comes from the top\n            // (K[i-1][w]) or from (val[i-1] + K[i-1]\n            // [w-wt[i-1]]) as in Knapsack table. If\n            // it comes from the latter one/ it means\n            // the item is included.\n            if (res == dp[i - 1][j][k])\n                continue;\n            else {\n                // This item is included.\n                selectedList.add(items[i-1]);\n\n                // Since this weight is included its value is deducted\n                res = res - items[i - 1].getValue();\n                j = j - items[i - 1].getWeight();\n                k = k - 1;\n            }\n        }\n    \n        //print out the list of selected items\n        System.out.println(\"Knapsack contents:\");\n        for (Item item : selectedList) {\n            System.out.println(\"Item: \" + item.getName() + \" Value:\" + item.getValue()  + \" Weight: \" + item.getWeight());\n        }\n        \n    }\n\n}\n```\n\n```\nCurrent Output:\nItem: RUBY Value:90 Weight90\n\n\nDesired Output:\nItem: SAPPHIRE Value:10 Weight15\nItem: EMERALD Value:10 Weight15\nItem: DIAMOND Value:15 Weight15\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving the knapsack problem with special constraint\r\n                \r\nI'm trying to understand how to solve the knapsack problem, with the normal weight and value parameters, but also when each item has a special value of either 0 or 1 and we need to fill the knapsack with at least n special items. I was thinking of treating the special constraint like a weight, but I feel like we can't do this because we only need at least n special items and not at most n special items.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "A programming problem similar to the knapsack problem\r\n                \r\nI have asked about this on some stackexchange sites and they told me I should ask here with code provided, so here it is:\n\nThe whole problem is like knapsack problem but extended.\n\nThere is a knapsack with:\n\n\nweight,\ndurability,\nmax progress,\nmax quality.\n\n\nThere are items. Each item has:\nweight,\ndurability loss or gain,\nvalue that contributes to progress, \nvalue that contributes to quality.\n\nThere are also items that sort of add 'buffs' which:\n\n\nincrease value that contributes to knapsack's progress and/or quality\nfor next n items,\nreduce durability loss for next n items,\nadd durability after picking next n items.\nn depends on buff.\n\n\nKnapsack starts with weight, durability, 0 progress, 0 quality. Same items can be picked any number of times.\n\nWhile picking items:\n\n\nknapsack gains weight,\nKnapsack gains progress,\nKnapsack gains quality,\nKnapsack loses or gains durability.\n\n\nSame items can be picked any number of times.\n\nYou stop picking items if:\nKnapsack durability reaches 0,\nKnapsack progress reaches maximum progress,\nKnapsack cannot hold any item due to its weight.\n\nGoal is to reach max quality and max progress with least amount of items and weight (if you reach max quality and max progress, it means you have solved the problem).\n\nThere are about 20 items so brute force will not work.\n\nCode provided:\n\n```\nint maxWeight = 10;\nint durability = 60;\nint maxProgress = 100;\nint maxQuality = 100;\n\nint[] itemWeights =     new[] { 1,  1, 2,  3,   1,  1  };\nint[] itemDurability =  new[] { 10, 0, 20, -15, 10, 10 };\nint[] itemProgress =    new[] { 20, 0, 40, 0,   0,  0  };\nint[] itemQuality =     new[] { 0,  0, 25, 0,   0,  0  };\nint[] buffs =           new[] { 0,  1, 0,  0,   2,  3  };\n\n//buff 1: for 4 next items after picking increase knapsack durability by 5\n//buff 2: for 2 next items after picking increase progress gain by 50%\n//buff 2: for 2 next items after picking increase quality gain by 50%\n```\n\n\nThis is just an example code to make things simple. Real program includes over 20 actions, progress and quality depends on other variables and whole project is quite large and would probably make things complicated. However, if you need the whole source code it can be provided.\n\nWhat I have tried:\nUsing Genetic Algorithm to find most optimal solution and it worked but I want a mathematical solution.\nUsing Dynamic Programming, solving quality actions first then continuing on progress. Things get complicated with items that add 'buff', since they do not have actual value.\n\nBrute force attempt from actual project:\n\n```\nprivate void SolveForCurrentItems(Items[] availableItems, Items[] items)\n        {\n            Knapsack.RemoveItems();\n            Knapsack.AddItems(items);\n            var currentItems = Knapsack.GetItems();\n            //Knapsack.GetItems() returns items that are used\n            //if picking is no longer possible, last item is not included\n            if (currentItems.Length == items.Length)\n            {\n                for (int i = 0; i < availableItems.Length; i++)\n                {\n                    var newItems = new Item[currentItems.Length + 1];\n                    currentItems .CopyTo(newItems , 0);\n                    newItems [newItems .Length - 1] = availableItems[i];\n                    SolveForCurrentItems(availableItems, newItems);\n                }\n            }\n        }\n```\n\n\nThis loops through all possible solutions but it takes a lot of time.\nNote: Knapsack.AddItems(items) adds items and calculates all variables (weight, progress, quality, durability) and if some action fails, it is removed.\n\nI minimized project:\n\nKnapsack class:\n\n```\n public class Knapsack\n{\n    public int MaxWeight { get; set; }\n    public int Durability { get; set; }\n    public int MaxProgress { get; set; }\n    public int MaxQuality { get; set; }\n\n    public int CurrentWeight { get; set; }\n    public int CurrentDurability { get; set; }\n    public int CurrentProgress { get; set; }\n    public int CurrentQuality { get; set; }\n\n    public double ProgressModifier { get; set; }\n    public double QualityModifier { get; set; }\n    public double DurabilityModifier { get; set; }\n    public bool RestoreDurability { get; set; }\n\n\n    public List<Item> CurrentItems { get; private set; }\n    public List<Buff> CurrentBuffs { get; private set; }\n\n\n    public Knapsack()\n    {\n        CurrentItems = new List<Item>();\n        CurrentBuffs = new List<Buff>();\n    }\n\n    public void ExecuteItems()\n    {\n        CurrentWeight = 0;\n        CurrentProgress = 0;\n        CurrentQuality = 0;\n        CurrentDurability = Durability;\n        CurrentBuffs.Clear();\n        ProgressModifier = 1;\n        QualityModifier = 1;\n        DurabilityModifier = 1;\n        RestoreDurability = false;\n\n        for (int i = 0; i < CurrentItems.Count; i++)\n        {\n            Item item = CurrentItems[i];\n\n            // check if adding item is possible\n            bool canAddItem = true;\n\n            if (item.Weight + CurrentWeight > MaxWeight)\n                canAddItem = false;\n\n            if (CurrentProgress >= MaxProgress)\n                canAddItem = false;\n\n            if (CurrentDurability <= 0)\n                canAddItem = false;\n\n            if (!canAddItem)\n            {\n                //this item and the next ones are redundant\n                CurrentItems.RemoveRange(i, CurrentItems.Count - i);\n                return;\n            }\n            CurrentWeight += item.Weight;\n            CurrentProgress += (int)(item.Progress * ProgressModifier);\n            CurrentQuality += (int)(item.Quality * QualityModifier);\n            if (item.Durability < 0)\n                CurrentDurability -= item.Durability; //durability restoration\n            else\n                CurrentDurability -= (int)(item.Durability * DurabilityModifier); //durability loss\n\n            if (CurrentDurability > 0 && RestoreDurability)\n                CurrentDurability += 5; //if durability doesnt reach 0, you can add durability with restoration\n\n\n            if (CurrentDurability > Durability)\n                CurrentDurability = Durability; //current durability cannot exceed knapsacks durability\n\n\n            foreach (var buff in CurrentBuffs)\n                buff.Step(this);\n\n            for (int j = 0; j < CurrentBuffs.Count; j++)\n            {\n                var buff = CurrentBuffs[j];\n                if (buff.NeedsRemove)\n                {\n                    switch (buff.BuffType)\n                    {\n                        case BuffType.DurabilityRestoration:\n                            RestoreDurability = false;\n                            break;\n\n                        case BuffType.DurabilityModifier:\n                            DurabilityModifier = 1;\n                            break;\n\n                        case BuffType.Progress:\n                            ProgressModifier = 1;\n                            break;\n\n                        case BuffType.Quality:\n                            QualityModifier = 1;\n                            break;\n                    }\n                    CurrentBuffs.Remove(buff);\n                    j--;\n                }\n            }\n\n            if (item.HasBuff)\n            {\n                //check if such buff exists\n                var buff = CurrentBuffs.FirstOrDefault(x => x.BuffType == item.Buff.BuffType);\n                if (buff == null) {\n                    buff = item.Buff;\n                    CurrentBuffs.Add(buff);\n                }\n                // reset stack of buff\n                switch (buff.BuffType)\n                {\n                    case BuffType.DurabilityRestoration:\n                        buff.CurrentStack = 4;\n                        RestoreDurability = true;\n                        break;\n\n                    case BuffType.DurabilityModifier:\n                        buff.CurrentStack = 2;\n                        DurabilityModifier = 0.5;\n                        break;\n\n                    case BuffType.Progress:\n                        buff.CurrentStack = 2;\n                        ProgressModifier = 1.5;\n                        break;\n\n                    case BuffType.Quality:\n                        buff.CurrentStack = 2;\n                        QualityModifier = 1.5;\n                        break;\n                }\n            }\n        }\n    }\n}\n```\n\n\nItem class:\n\n```\n public class Item\n{\n    public bool HasBuff { get; set; } = false;\n    public int Weight { get; set; }\n    public int Durability { get; set; }\n    public int Progress { get; set; }\n    public int Quality { get; set; }\n\n    public Buff Buff = null;\n}\n```\n\n\nBuff class:\n\n```\npublic enum BuffType\n{\n    DurabilityRestoration,\n    DurabilityModifier,\n    Progress,\n    Quality\n}\n\npublic class Buff\n{\n    public int CurrentStack;\n    public bool NeedsRemove { get; set; }\n\n    public BuffType BuffType { get; private set; }\n    public Buff(BuffType buffType)\n    {\n        BuffType = buffType;\n    }\n\n    public void Step(Knapsack knapsack)\n    {\n        CurrentStack--;\n        if (CurrentStack == 0)\n            NeedsRemove = true;\n    }\n\n}\n```\n\n\nExample of how to use it:\n\n```\nKnapsack knapsack = new Knapsack { MaxWeight = 100, Durability = 60, MaxProgress = 100, MaxQuality = 100 };\n\n        Item[] items = new Item[]\n        {\n            new Item {Weight = 1, Durability = 10, Progress = 20, Quality = 0, HasBuff = false },\n            new Item {Weight = 1, Durability = 0, Progress = 0, Quality = 0, HasBuff = true, Buff = new Buff(BuffType.DurabilityRestoration) },\n            new Item {Weight = 4, Durability = 15, Progress = 5, Quality = 25, HasBuff = false },\n            new Item {Weight = 3, Durability = -15, Progress = 0, Quality = 0, HasBuff = false },\n            new Item {Weight = 1, Durability = 10, Progress = 0, Quality = 0, HasBuff = true, Buff = new Buff(BuffType.Progress) },\n            new Item {Weight = 1, Durability = 10, Progress = 0, Quality = 0, HasBuff = true, Buff = new Buff(BuffType.Quality) },\n        };\n\n        knapsack.CurrentItems.Add(items[4]);\n        knapsack.CurrentItems.Add(items[1]);\n        knapsack.CurrentItems.Add(items[5]);\n        knapsack.CurrentItems.Add(items[2]);\n        knapsack.CurrentItems.Add(items[2]);\n        knapsack.CurrentItems.Add(items[3]);\n        knapsack.CurrentItems.Add(items[2]);\n        knapsack.CurrentItems.Add(items[2]);\n        knapsack.CurrentItems.Add(items[1]);\n        knapsack.CurrentItems.Add(items[3]);\n        knapsack.CurrentItems.Add(items[3]);\n        knapsack.CurrentItems.Add(items[4]);\n        knapsack.CurrentItems.Add(items[0]);\n        knapsack.CurrentItems.Add(items[0]);\n        knapsack.CurrentItems.Add(items[4]);\n        knapsack.CurrentItems.Add(items[0]);\n        knapsack.ExecuteItems();\n```\n\n\nWhat I want is an algorithm that solves the problem in most optimal way.\n    ", "Answer": "\r\nYou've flagged the question as being C# and so I'd recommend that you use the power of it.\nSo instead of using separate lists of Item properties, instead have an Item class that has those properties e.g.\n\n```\ninterface IItem\n{\n  int Weight{get;set;}\n  int Durability {get;set;}\n  int Progress {get;set;}\n  int Quality {get;set;}\n  int Buff {get;set;}\n}\n\nclass Item1 : IItem\n{\n  ...\n}\n\nclass Item2 : IItem\n{\n  ...\n}\n\n…\n```\n\n\nthen you ```\nKnapSack```\n class can have a collection of ```\nIItem```\n class which is the Contents.\n\nThen if you have a full list of all unique ```\nIItem```\n based classes you can order them by the property that you are interested in and select which one you may be able to fit in your ```\nKnapSack```\n based on its criteria e.g. Weight might be too high and so you select an ```\nIItem```\n that has a low weight.\n\n\n\nedited\n\nOkay your recent post has made my original post obsolete, hence why someone down voted it.\n\nAll the same I think that what you want is to perform some sort of Venn Diagram logic in code on the criteria that you have.\n\nLet me explain.\n\nYour goal is to reach the maximum quality and progress with the fewest number of items, so order all of your items by Quality (highest first) and keep adding instances from this ordered list to a Quality List until you have reached as close a possible to the maximum. If the current instance wont fit then step to the next in the list and check that.\n\nPerform the same process on each of your Item properties. \n\nThen you can determine where the Lists Intersect the resulting output will be close to your optimum selection of Items.\n\nI have a distinct impression that you may want each of your Item types to be a unique class and that they each implement the same Interface or they have a property that indicates their type, if only so that you can determine which ones you have selected at the end.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "User defined input for 0-1 Knapsack problem\r\n                \r\nSo I am trying to solve a 0-1 KnapSack problem. I would like to have an empty vector or array that gets filled after the user gets prompted to select items. While I can get it running with set values I'm having trouble actually pushing the users input into the vector and then passing it into my KnapSack function.\n\n```\n#include <vector>\n#include <bits/stdc++.h>\n#include <queue>\n\nusing namespace std;\n\n// Structure for an item which stores weight and corresponding\n// value of Item\n\nstruct TarkovItems {\n\n    int value, size;\n\n    // Constructor\n\n    TarkovItems(int value, int size) : value(value), size(size) {}\n\n};\n\n// Comparison function to sort Item according to val/weight ratio\n\nbool cmp(struct TarkovItems a, TarkovItems b) {\n\n    int r1 = (int) a.value / a.size;\n\n    int r2 = (int) b.value / b.size;\n\n    return r1 > r2;\n\n}\n\n// Main function to solve problem\n\nint TarkovAlgorithm(int W, TarkovItems ItemArray[], int n) {\n\n    //    sorting Item on basis of ratio\n\n    sort(ItemArray, ItemArray + n, cmp);\n\n    int curWeight = 0; // Current weight in knapsack\n\n    int finalvalue = 0; // Result (value in Knapsack)\n\n\n    // Looping through all Items\n\n    for (int i = 0; i < n; i++) {\n\n        // If adding Item won't overflow, add it completely\n\n        if (curWeight + ItemArray[i].size <= W) {\n\n            curWeight += ItemArray[i].size;\n\n            finalvalue += ItemArray[i].value;\n\n        }\n\n\n    }\n\n    // Returning final value\n\n    return finalvalue;\n\n}\n\n// driver program to test above function\n\nint main() {\n\n    int userInputForBackpack;\n    int userInputForItems;\n\n    TarkovItems ItemArray[] = {{10, 20},{5,  30}};  //I would like to not hard code these values\n\n\n    cout << \"Are you using 1. A Raid Backpack, 2. A Berkut Backpack or 3. A Tactical Sling? \"\n         << \"Please enter 1, 2, or 3.\" << endl;\n    cin >> userInputForBackpack;\n    switch (userInputForBackpack) {\n\n        case 1:\n\n            userInputForBackpack = 48;\n            cout << \"You selected Raid Backpack of size 48\" << endl;\n            break;\n\n        case 2:\n\n            userInputForBackpack = 20;\n            cout << \"You selected Berkut Backpack of size 20\" << endl;\n            break;\n\n\n        case 3:\n\n            userInputForBackpack = 6;\n            cout << \"You have selected a Tactical Sling of size 6\" << endl;\n            break;\n\n    }\n\n    cout << \"Enter the number for each item you found. Type 0 to quit adding items.\" << endl;\n    cout << \"1. Mdr Assault rifle, 2. AS VAL. 3. VSS Vintorez \" << endl;\n\n    cin >> userInputForItems;\n\n    //This is where I am having trouble allowing the user to select items and then\n    //pushing them into the array.\n\n    int n = sizeof(ItemArray) / sizeof(ItemArray[0]);\n\n    cout << \"Maximum value we can obtain = \"\n\n         << TarkovAlgorithm(userInputForBackpack, ItemArray, n);\n\n    return 0;\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is this a correct way of solving knapsack problem?\r\n                \r\nI am trying to practice interview problems and came across the knapsack problem. Is this a correct way to solve the problem ?\n\nI am yet to do the recursive approach. Is the complexity O(n2) here ?\n\n```\nprivate void kpsolve()\n{           \n        int[] items = new int[] { 1, 2, 3, 4 , 5, 6};\n        int[] weights = new int[] { 1, 2, 3, 8 ,7 ,4};\n        int[] profits = new int[] { 20, 5 ,10, 40, 15,25 };\n\n        int capacity = 10;\n\n        //number of items in a set that can yield max profits\n        Dictionary<List<int>, int> weightmap = new Dictionary<List<int>, int>();\n        for(int i=0;i< weights.Length;i++)\n        {\n            List<int> currList = new List<int>();\n            int runprofit = 0;\n            int runweight = 0;\n            var w = weights[i];\n            var p = profits[i];\n            int cw = w;\n\n            if (w > capacity)\n                continue;\n\n            currList.Add(i);\n            runprofit = p;\n            runweight = w;\n\n            for (int j = 0; j < weights.Length; j++)\n            {\n                if (j == i)\n                    continue;\n\n                var iw = weights[j];\n                var ip = profits[j];\n\n                if ((runweight + iw) <= capacity)\n                {\n                    currList.Add(j);\n                    runprofit += ip;\n                    runweight += iw;\n                }\n\n            }\n\n            weightmap.Add(currList, runprofit);\n        }\n        var lvalues = weightmap.Max(w => w.Value);\n\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem with number of item constraints\r\n                \r\nI'm working on a small fantasy football data science project which involves calculating \"expected points\" of players. I was interested in writing an optimization algorithm to take these values and create the optimal fantasy team. This ends up being a knapsack problem however it has certain constraints which I am not quite sure how to implement. The constraints are that each team must have 2 keepers, 5 defenders, 5 midfielders, and 3 forwards. In addition to this the collection of players must have a price under 100M pounds.\nIn more general terms, I have a knapsack problem where there are 4 groups of items, where I need exactly 2, 5, 5, and 3 items from each group respectively. How can I write an optimization algorithm to fulfill these constraints?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Unbounded knapsack problem with extra reward for certain combinations\r\n                \r\nI am thinking about a variant of the unbounded knapsack problem, where extra value is added for certain combination of items.\nSuppose we have ```\nN```\n items and the ```\ni```\n-th item has value ```\nv_i```\n and weight ```\nw_i```\n. Suppose we are given a weight limit ```\nW```\n. For the regular unbounded knapsack problem, each item is allowed to be repeated any number of times and we maximize the total value under the constraint that the total weight does not exceed ```\nW```\n.\nNow let us add a twist. Suppose we are given a list ```\nS_1, S_2, ... , S_K```\n of subsets of ```\n{1, 2, ..., N}```\n and positive numbers ```\na1, a2, ... a_K```\n. If all the items in ```\nS_j```\n are present in the items we packed into the knapsack, an extra ```\na_j```\n is added to the total value. How do we maximize the total value?\nDoes this variant problem have a name?\nHere is my impractical solution. Suppose we just focus on the subset ```\n{2, 4, 5}```\n of ```\n{1, 2, ..., N}```\n . We require that (repetitions of) items 2, 4, 5 must be and only they can be packed into the knapsack, then we know which extra values are added, and it reduces to a normal unbounded knapsack problem on the set ```\n{2, 4, 5}```\n. Now do this for all subsets of ```\n{1, 2, ..., N}```\n. Now we have ```\n2^N```\n problems to solve, which is not practical.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Improvisations in the 0/1 Knapsack Problem\r\n                \r\nI am implementing the 0/1 Knapsack problem using Dynamic Programming. However, when the number of items or the sack capacity is too large, my algorithm fails to complete, giving rise to an exception. It is a simple DP algorithm which creates a 2D-matrix for item no. vs capacity. Here is my code snippet:\n```\ndef solve_it(input_data):\n    # Modify this code to run your optimization algorithm\n    \n    # parse the input\n    lines = input_data.split('\\n')\n\n    firstLine = lines[0].split()\n    item_count = int(firstLine[0])\n    capacity = int(firstLine[1])\n\n    \n    vals=[]\n    weights=[]\n\n    for i in range(1, item_count+1):\n        line = lines[i] \n        parts = line.split() \n        #items.append(Item(i-1, int(parts[0]), int(parts[1]))) \n        vals.append(int(parts[0])) \n        weights.append(int(parts[1])) \n    taken=[0 for i in range(len(weights))]    \n    list=[[0 for j in range(capacity + 1)] for i in range(len(weights) + 1)]\n    for item in range(len(weights)+1):             \n        for wt in range(capacity + 1): \n            if item==0 or wt==0:\n                list[item][wt]=0  \n            elif weights[item-1]<=wt: \n                if (vals[item-1]+list[item-1][wt-weights[item-1]])>=list[item-1][wt]:  \n                    list[item][wt]=vals[item-1]+list[item-1][wt-weights[item-1]] \n                else:  \n                    list[item][wt]=list[item-1][wt] \n            else: \n                list[item][wt]=list[item-1][wt] \n    n=item_count\n    w=capacity \n    while n>0: \n          if list[n][w]!=list[n-1][w]:\n              taken[n-1]=1\n              w=w-weights[n-1]\n          n-=1    \n                \n    value=list[item_count][capacity]\n    if capacity> sum(weights[:]):\n        opt=0\n    else:\n        opt=1\n        \n    \n    # prepare the solution in the specified output format\n    output_data = str(value) + ' ' + str(opt) + '\\n'\n    output_data += ' '.join(map(str, taken))\n    return output_data \n\n```\n\nAny ideas to improve the execution time ?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recurrence relation for a variant of knapsack problem?\r\n                \r\nI am finding it difficult to understand two specific implementations which solve this problem on codeforces link.\n\nI understand this is similar to the knapsack problem. However when i solved it myself, i was not aware of the algorithm. I solved it from my own understanding of dynamic programming. My idea is to regard the remaining length of the ribbon as the next state. Here's my code\n\n```\n#include<iostream>\n\nusing namespace std;\n\n\nint main(){\n     int n,res1=0,res2,x=0;\n     int a,b,c;\n     cin >> n >> a >> b >> c;\n     for(int i=0;i <= n/a; i++){\n        res2 = -20000;\n        for(int j=0; j <= (n-(a*i))/b; j++){\n             x = (n - (a*i) - (b*j));\n            res2=max(res2,(j + ((x % c) ? -10000 : x/c)));\n        }\n            res1=max(res1,i+res2);\n     }\n    cout << res1 << endl;\n    return 0;\n```\n\n\nImplementation 1:\n\n```\n  1 #include <bits/stdc++.h>\n  2 using namespace std;\n  3 int main()\n  4 {\n  5         int f[4005],n,a,i,j;\n  6         fill(f+1,f+4005,-1e9);\n  7         cin>>n;\n  8         for(;cin>>a;)\n  9                 for(i=a;i<=n;i++)\n 10                         f[i]=max(f[i],f[i-a]+1);\n 11         cout<<f[n];\n 12 }\n```\n\n\nImplementation 2:\n\n```\n  1 #include <bits/stdc++.h>\n  2 int n, a, b, c, ost;\n  3 std::bitset<4007> mog;\n  4 main()\n  5 {\n  6         std::cin>>n>>a>>b>>c;\n  7         mog[0]=1;\n  8         for (int i=1; i<=n; i++)\n  9                 if ((mog=((mog<<a)|(mog<<b)|(mog<<c)))[n])\n 10                         ost=i;\n 11         std::cout << ost;\n 12 }\n```\n\n\nThough i understand the general idea of solving the knapsack problem. I do not have a clear understanding of how lines 8,9,10 in Implementation 1 achieve this. Specifically irrespective of the input values of a,b,c the inner for loop is a single pass over the array for the corresponding value a received.\n\nSimilarly, I can see that lines 8,9,10 in implementation 2 does the same thing. But i have no clue at all how this piece of code works.\n\nPlease help me understand this. I feel there is some hidden structure to these two solutions which i am not seeing. Thanks in advance.\n    ", "Answer": "\r\nImplementation 1\n\nThis is quite straightforward implementation of dynamic programming.\n\nOuter loop just goes through three values: ```\na```\n, ```\nb```\n, and ```\nc```\n\n\n```\n  8         for(;cin>>a;)\n```\n\n\nInner loop visits every element of an array and updates current best known number of cuts for given ribbon length.\n\n```\n  9                 for(i=a;i<=n;i++)\n 10                         f[i]=max(f[i],f[i-a]+1);\n```\n\n\n\n\nImplementation 2\n\nI don't think that it can be called dynamic programming, but the trick is quite neat.\n\nIt allocates array of bits with length equal to max ```\nn```\n. Then sets one bit on the left. It means, that ribbon with length of 0 is a valid solution.\nOn each iteration algorithm shifts given array to the left by ```\na```\n, ```\nb```\n, and ```\nc```\n. Result of each such shift can be viewed as the new valid sizes of ribbon. By ```\nor```\ning result of all 3 shifts, we get all valid sizes after ```\ni```\n'th cut. If ```\nn```\n'th bit set we know ribbon of size ```\nn```\n can be cut ```\ni```\n times without remainder.\n\n```\nn = 10\na = 2\nb = 3\nc = 5\n\ni=1:\n0|0000000001 // mog\n0|0000000100 // mog<<a\n0|0000001000 // mog<<b\n0|0000100000 // mog<<c\n0|0000101100 // mog=(mog<<a)|(mog<<b)|(mog<<c)\n^ here is a bit checked in 'if' statement '(mog=(...))[n]'\n```\n\n\n```\ni=2:\n0|0000101100 // mog\n0|0010110000 // mog<<a\n0|0101100000 // mog<<b\n1|0110000000 // mog<<c // here we have solution with two pieces of size 5\n1|0111110000 // (mog<<a)|(mog<<b)|(mog<<c)\n^ now bit set, so we have a solution\n```\n\n\nWe know that there is exactly ```\ni```\n cuts at that point, so we set ```\nost=i```\n. But we found the worst solution, we have to keep going until we are sure that there is no more solutions.\n\nEventually we will reach this state:\n\n```\ni=5:\n1|1100000000 // mog\n1|0000000000 // mog<<a // 5 pieces of size 2\n0|0000000000 // mog<<b\n0|0000000000 // mog<<c\n1|0000000000 // (mog<<a)|(mog<<b)|(mog<<c)\n```\n\n\nHere it is the last time when bit at position ```\nn```\n will be set. So we will set ```\nost=5```\n and will do some more iterations.\n\nAlgorithm uses ```\nn```\n as upper bound of possible cuts, but it's obvious that this bound can be improved. For example ```\nn / min({a,b,c})```\n should be sufficient.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem: Replaces all items with value\r\n                \r\nI am trying to solve the knapsack problem by applying my own algorithm. I give each item a score (values[i] - weights[i]) and add high score items to my knapsack. But this code replaces each item with the first item of values (5).\n```\ndef knapsack(weights, values, capacity):\n  knapsack = []\n  scores = []\n  for i in range(len(values)):\n    score = values[i] - weights[i]\n    scores.append(score)\n  weight = 0\n  while weight < capacity:\n    if len(scores) != 0:\n      valuable = max(scores)\n      knapsack.append(values[scores.index(valuable)])\n      weight += weights[scores.index(valuable)]\n      scores.pop(scores.index(valuable))\n    else:\n      break\n  return knapsack\n\nweights = [1, 2, 4, 2, 5]\nvalues  = [5, 3, 5, 3, 2]\ncapacity = 10\n\nprint(knapsack(weights, values, capacity))\n```\n\nWhat is wrong with this code?\nEdit: I fixed it but there seems to be a logical error. If:\n```\nweights = [8, 2,  6,  7, 9]\nvalues  = [3, 11, 13, 7, 4]\ncapacity = 24\n```\n\nThen there are two items with the same score (8, 3 and 9, 4), but 9, 4 is better since it fits exactly into the knapsack and it has higher value. Even changing line 8 to <= does not help.\n    ", "Answer": "\r\nYou are not removing the appended values from the list as well. Try adding\n\n```\nvalues.pop(scores.index(valuable))\nweights.pop(scores.index(valuable))\n```\n\n\nto the line before ```\nscores.pop(...)```\n.\n\nAdditionally, you need to break out of the loop if the added item would make you over capacity, e.g:\n\n```\nif (weight + weights[scores.index(valuable)]) > capacity:\n    break\n```\n\n\nYou need code to deal with tie-breakers, which reassigns the score index to the highest-valued item which fits under the capacity, e.g.:\n\n```\nties = [i for i, x in enumerate(scores) if x == valuable]\nif len(ties) > 1:\n    most_valuable = -1\n    for idx in ties:\n        if values[idx] > most_valuable and (weight + weights[idx]) <= capacity:\n            most_valuable = values[idx]\n            scores_idx = idx\n```\n\n\nFull code:\n\n```\ndef knapsack(weights, values, capacity):\n    knapsack = []\n    scores = []\n    for i in range(len(values)):\n        score = values[i] - weights[i]\n        scores.append(score)\n    weight = 0\n    while weight < capacity:\n        if len(scores) != 0:\n            valuable = max(scores)\n            scores_idx = scores.index(valuable)\n            ties = [i for i, x in enumerate(scores) if x == valuable]\n            if len(ties) > 1:\n                most_valuable = -1\n                for idx in ties:\n                    if values[idx] > most_valuable and (weight + weights[idx]) <= capacity:\n                        most_valuable = values[idx]\n                        scores_idx = idx\n            if (weight + weights[scores_idx]) > capacity:\n                break\n            knapsack.append(values[scores_idx])\n            weight += weights[scores_idx]\n            values.pop(scores_idx)\n            weights.pop(scores_idx)\n            scores.pop(scores_idx)\n        else:\n            break\n    return knapsack\n\n#  weights = [1, 2, 4, 2, 5]\n#  values  = [5, 3, 5, 3, 2]\n#  capacity = 10\nweights = [8, 2, 6, 7, 9]\nvalues = [3, 11, 13, 7, 4]\ncapacity = 24\n\nprint(knapsack(weights, values, capacity))\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Difference in Outputs of classical knapsack problem [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        List of lists changes reflected across sublists unexpectedly\r\n                            \r\n                                (17 answers)\r\n                            \r\n                    \r\n                Closed last year.\r\n        \r\n\r\n\r\n    \r\n\r\nI wrote a program for a classical knapsack problem and it is working good.\nBelow is the code:\n```\nclass Solution:\n\n    def knapsack(self, wt, val, crr_cap, n):\n        if crr_cap == 0 or n == 0:\n            return 0\n\n        b = self.knapsack(wt, val, crr_cap, n - 1)\n\n        if wt[n - 1] <= crr_cap:\n            a = val[n - 1] + self.knapsack(wt, val, crr_cap - wt[n - 1], n - 1)\n            return max(a, b)\n\n        else:\n            return b\n\n    def getMaximumvalue(self, weight, value, capacity) -> int:\n\n        ret = self.knapsack(weight, value, capacity, len(weight))\n        return ret\n\n\na = Solution()\nweight = [1, 2, 3, 4, 5, 6]\nvalue = [4, 5, 6, 7, 8, 9]\n```\n\nThen I added ```\nmemoization```\n to it, basically by adding 4 new lines.\nBelow is the updated code:\n```\nclass Solution:\n    def __init__(self):\n        self.dp = None\n\n    def knapsack(self, wt, val, crr_cap, n):\n        if crr_cap == 0 or n == 0:\n            return 0\n\n        \"\"\"\n        Below is the new added condition\n        Checking if the value is present in the cache\n        \"\"\"\n        if self.dp[n][crr_cap] != -1:\n            return self.dp[n][crr_cap]\n\n        b = self.knapsack(wt, val, crr_cap, n - 1)\n\n        if wt[n - 1] <= crr_cap:\n            a = val[n - 1] + self.knapsack(wt, val, crr_cap - wt[n - 1], n - 1)\n            \"\"\"\n            Added new line\n            Adding the value to the cache\n            \"\"\"\n            self.dp[n][crr_cap] = max(a, b)\n            return max(a,b)\n        \n        else:\n            \"\"\"\n            Added new line\n            Adding the value to the cache\n            \"\"\"\n            self.dp[n][crr_cap] = b\n            return b\n        \n    def getMaximumvalue(self, weight, value, capacity) -> int:\n\n        ret = self.knapsack(weight, value, capacity, len(weight))\n        return ret\n\n\na = Solution()\n\"\"\"\nConstraints:\nlen(weight) <= 10 (n)\ncapacity <= 20 (crr_cap)\n\nNote:\na.dp is a matrix with [capacity + 1][len(weight) + 1]\n\"\"\"\nweight = [1, 2, 3, 4, 5, 6]\nvalue = [4, 5, 6, 7, 8, 9]\na.dp = [[-1] * (20 + 2)] * (len(weight) + 2)\n```\n\nInputs of both the programs:\n```\noutput = a.getMaximumvalue(weight, value, 0)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 2)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 4)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 6)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 8)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 10)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 12)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 14)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 16)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 18)\nprint(output)\n\noutput = a.getMaximumvalue(weight, value, 20)\nprint(output)\n```\n\nOutput of 1st program\n```\n0\n5\n10\n15\n17\n22\n24\n26\n31\n33\n35\n```\n\nOutput of 2nd program\n```\n0\n5\n10\n15\n20\n25\n30\n35\n40\n45\n50\n```\n\nBut the code is giving different outputs for certain inputs. What is the mistake in the 2nd program?\n    ", "Answer": "\r\nThe issues is in the way ```\na.dp```\n is created.\n```\na.dp = [[-1] * (20 + 2)] * (len(weight) + 2)\n```\n\nThis causes problems as mentioned here: list-of-lists-changes-reflected-across-sublists-unexpectedly\nTo resolve this issue use the following code to declare and initialize the lists.\n```\na.dp = []\n\nfor i in range(b):\n    tmp = []\n    for j in range(cap):\n        tmp.append(-1)\n    a.dp.append(tmp)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Forming Dynamic Programming algorithm for a variation of Knapsack Problem\r\n                \r\nI was thinking,\n\nI wanted to do a variation on the Knapsack Problem.\n\nImagine the original problem, with items with various weights/value.\n\nMy version will, along with having the normal weights/values, contain a \"group\" value.\n\neg.\nItem1[5kg, $600, electronic]\nItem2[1kg, $50, food]\n\nNow, having a set of items like this, how would I code up the knapsack problem to make sure that a maximum of 1 item from each \"group\" is selected.\n\nNotes:\n\n\nYou don't need to choose an item from that group\nThere are multiple items in each group\nYou're still minimizing weight, maximizing value\nThe amount of groups are predefined, along with their values.\n\n\nI'm just writing a draft of the code out at this stage, and I've chosen to use a dynamic approach. I understand the idea behind the dynamic solution for the regular knapsack problem, how do I alter this solution to incorporate these \"groups\"?\n\n```\nKnapSackVariation(v,w,g,n,W)\n{\n  for (w = 0 to W)\n     V[0,w] = 0;\n  for(i = 1 to n)\n     for(w = 0 to W)\n        if(w[i] <= w)\n           V[i,w] = max{V[i-1, w], v[i] + V[i-1, w-w[i]]};\n        else\n           V[i,w] = V[i-1, w];\n     return V[n,W];\n}\n```\n\n\nThat's what I have so far, need to add it so that it will remove all corresponding items from the group it is in each time it solves this.\n    ", "Answer": "\r\njust noticed your question trying to find an answer to a question of my own.  The problem you've stated is a well-known and well-studied problem called the Multiple Choice Knapsack Problem.  If you google that you'll find all sorts of information, and I can also recommend this book: http://www.amazon.co.uk/Knapsack-Problems-Hans-Kellerer/dp/3642073115/ref=sr_1_1?ie=UTF8&qid=1318767496&sr=8-1, which dedicates a whole chapter to the problem.  In the classic formulation of MCKP, you have to choose one item from each group.  However, you can easily convert that version of the problem to your version by adding a dummy item to each group with profit and weight = 0, and the same algorithms will work.  I would caution you against trying to adapt code for the binary knapsack problem to the MCKP with a few tweaks--this approach is likely to lead you to a solution whose performance degrades unacceptably as the number of items in each group increases.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Counter examples for 0-1 knapsack problem with two knapsacks\r\n                \r\nI came across the following question in this course:\n\n\n  Consider a variation of the Knapsack problem where we have two\n  knapsacks, with integer capacities 𝑊1 and 𝑊2. As usual, we are given\n  𝑛 items with positive values and positive integer weights. We want to\n  pick subsets 𝑆1,𝑆2 with maximum total value such that the total weights of 𝑆1 and 𝑆1 are at most 𝑊1 and 𝑊2, respectively. Assume that every item fits in either knapsack. Consider the following two algorithmic approaches.\n  \n  (1) Use the algorithm from lecture to pick a max-value feasible solution 𝑆1 for the first knapsack, and then run it again on the remaining items to pick a max-value feasible solution 𝑆2 for the second knapsack.\n  \n  (2) Use the algorithm from lecture to pick a max-value feasible solution for a knapsack with capacity 𝑊1+𝑊2, and then split the chosen items into\n  two sets 𝑆1+𝑆2 that have size at most 𝑊1 and 𝑊2, respectively.\n  \n  Which of the following statements is true?\n  \n  \n  Algorithm (1) is guaranteed to produce an optimal feasible solution to the original problem provided 𝑊1=𝑊2.\n  Algorithm (1) is guaranteed to\n  produce an optimal feasible solution to the original problem but\n  algorithm (2) is not. \n  Algorithm (2) is guaranteed to produce an\n  optimal feasible solution to the original problem but algorithm (1) is\n  not. \n  Neither algorithm is guaranteed to produce an optimal feasible\n  solution to the original problem.\n  \n\n\nThe \"algorithm from lecture\" is on YouTube. https://www.youtube.com/watch?v=KX_6OF8X6HQ, which is 0-1 knapsack problem for one bag.\n\nThe correct answer to this question is option 4. This, this and this post present solutions to the problem. However, I'm having a hard time finding counterexamples showing that options 1 through 3 are incorrect. Can you cite any?\n\nEdit:\nThe accepted answer doesn't provide a counterexample for option 1; see 2 knapsacks with same capacity - Why can't we just find the max-value twice for that.\n    ", "Answer": "\r\n```\n(Weight; Value): (3;10), (3;10), (4;2)```\n\ncapacities 7, 3\n\nThe first method chooses 3+3 into the first sack, remaining items does not fit into the second one\n\n```\n(Weight; Value): (4;10), (4;10), (4;10), (2:1)```\n\ncapacities 6, 6\n\nThe second method chooses (4+4+4) but this set cannot fit into two sacks without loss, while (4+2) and (4) is better\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to parallel Knapsack problems?\r\n                \r\nKnapsack problems is a very famous problem. Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. \n\nThis problem can be solved with dynamic programming and can be found on every tutorial book of algorithm. But how can I write a parallel version?\n    ", "Answer": "\r\nThat is a very interesting question, the best way to obtain a (good) answer is to use google scholar on such a question. The following link is probably the most recent paper on the subject.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Value Independent Knapsack Problems using Dynamic Programming\r\n                \r\nI have searched all the sites. But knapsack problem is always with weights and values.\n\nI have to write algorithm and C++ implementation for the following problem..\n\nProblem: \n\nThe knapsack problem is that given a set of positive integers (a1,.....,an) and a knapsack of size s, find a subset A of (a1,.....,an) such that sum of elements in A is largest but at most s.\n\nHave to use dynamic programming to design algorithm for this. Also have to prove correctness and have to calculate the computational time for this.\n\nCan you provide any useful resource for this. Can anyone explain how to do this? Because throughout the web i can find only the knapsack problems with weights and values.\n\nThis problem is somewhat special case..\n\nPlease post soon....\n    ", "Answer": "\r\nThis is the subset sum problem, which is a private instance of knapsack where ```\ncost[i] = weight[i]```\n for each item ```\ni```\n.\n\nThe DP solution follows the following recursive formula:\n\n```\nD(0,i) = true\nD(x,i) = false        x < 0\nD(x,0) = false        x > 0\nD(x,i) = D(x-arr[i],i-1) OR D(x,i-1)\n```\n\n\nAt the end, the highest value of ```\nx<=S```\n such that ```\nD(x,n) = true```\n, is the highest possible value that is at most S.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to implement knapsack problem with recursion in java\r\n                \r\nSo if you arent aware of what the knapsack problem is, it is a way of fitting different weights from a knapsack so that they add up to equal a specified total weight. Here is an example from my book on how to go about solving the problem if the specified total weight was 20.\n\n    \n\nIf anybody knows how to implement this problem in java using recursion PLEASE help, im so confused. Here is what I started but I'm pretty sure this is wrong and I have no clue where to go now.\n\n```\nimport java.util.*;\n\npublic class n01044854 {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Please first enter a weight capacity up to a value of \n100, followed by a series of individual weight values with 25 weights being the max.)\n\");\n        String values = input.nextLine();\n        String[] tokens = values.split(\" +\");\n\n        int capacity = Integer.parseInt(tokens[0]);\n        int[] weightValues = new int[tokens.length - 1];\n        for (int i = 0; i < tokens.length - 1; i++)\n            weightValues[i] = Integer.parseInt(tokens[i+1]);\n        optimizeWeights(capacity, weightValues, 0);\n    }\n\n    public static void optimizeWeights(int target, int[] weights, int currentIndex) {\n        if (weights[currentIndex] == target)\n            System.out.println(\"Success! Knapsack optimally filled.\");\n        else if (weights[currentIndex] < target) {\n            int newTarget = target - weights[currentIndex];\n            optimizeWeights(newTarget, weights, currentIndex + 1);\n        } else if (weights[currentIndex] > target) {\n            if (currentIndex < weights.length - 1)\n                optimizeWeights(target, weights, currentIndex + 1);\n            else\n            //confused on what to do \n        }\n    }\n}\n```\n\n    ", "Answer": "\r\nLook at the example\n\nI've implemented it some time ago while I was preparing for technical interviews.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Confusing Output for 0/1 Knapsack Problem\r\n                \r\nI'm learning Dynamic Programming, and have the book Grokking Algorithms\nThe example given there uses these images/values:\n\n\nWhen I run the code below, which is supposed to implement the 0/1 Knapsack Problem in Python, I get the following output:\n```\n+---+------+------+------+------+\n| 0 |  0   |  0   |  0   |  0   |\n| 0 | 1500 | 1500 | 1500 | 1500 |\n| 0 | 1500 | 1500 | 2000 | 3500 |\n| 0 | 1500 | 1500 | 2000 | 3500 |\n+---+------+------+------+------+\n3500\n```\n\nThe solution is correct, but it looks like this is a coincidence, as the table generated by the code is different from that given in the image from the book.\nCould someone please explain why the table generated by the code is different from the one in the book?\nCould it be that the formula used to generate the table is different (as in different in effect - I can see that they are not identical)? The one in the book is:\n\n```\n# A Dynamic Programming based Python\n# Program for 0-1 Knapsack problem\n# Returns the maximum value that can\n# be put in a knapsack of capacity W\nfrom tabulate import tabulate\n\n\ndef knapSack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n\n    # Build table K[][] in bottom up manner\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1]\n                              + K[i - 1][w - wt[i - 1]],\n                              K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    print(tabulate(K, tablefmt=\"pretty\"))\n\n    return K[n][W]\n\n\n# Driver code\nval = [1500, 2000, 3000]\nwt = [1, 3, 4]\nW = 4\nn = len(val)\nprint(knapSack(W, wt, val, n))\n\n```\n\n    ", "Answer": "\r\n```\n+---+------+------+------+------+\n| 0 |  0   |  0   |  0   |  0   |\n| 0 | 1500 | 1500 | 1500 | 1500 |  guitar\n| 0 | 1500 | 1500 | 2000 | 3500 |  laptop\n| 0 | 1500 | 1500 | 2000 | 3500 |  stereo\n+---+------+------+------+------+\n3500\n```\n\nYour listing is ```\n[guitar, laptop, stereo]```\n, however in the solution of the author, listing is ```\n[guitar, stereo, laptop]```\n. That's why your tables are different and that's all. Your solution is indeed correct. Try to run your solution with the listing of the author:\n```\nfrom tabulate import tabulate\n\ndef knapSack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n\n    # Build table K[][] in bottom up manner\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1]\n                              + K[i - 1][w - wt[i - 1]],\n                              K[i - 1][w])\n            else:\n                K[i][w] = K[i - 1][w]\n    print(tabulate(K, tablefmt=\"pretty\"))\n\n    return K[n][W]\n\n\n# Driver code\nval = [1500, 3000, 2000]\nwt = [1, 4, 3]\nW = 4\nn = len(val)\nprint(knapSack(W, wt, val, n))\n```\n\nOutput:\n```\n+---+------+------+------+------+\n| 0 |  0   |  0   |  0   |  0   |\n| 0 | 1500 | 1500 | 1500 | 1500 |   guitar\n| 0 | 1500 | 1500 | 1500 | 3000 |   stereo\n| 0 | 1500 | 1500 | 2000 | 3500 |   laptop\n+---+------+------+------+------+\n3500\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving Knapsack 0/1 problem using Substitution method\r\n                \r\nI want to solve knapsack problem with Substitution method, I can't find the therom of knapsack problem through its algorithm so I need help for finding the therom of knapsack problem.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Maximum value of the loot, Knapsack problem\r\n                \r\nProblem Introduction\nA thief finds much more loot than his bag can fit. Help him to find the most valuable combination of items assuming that any fraction of a loot item can be put into his bag.\nProblem Description\nTask. The goal of this code problem is to implement an algorithm for the fractional knapsack problem.\nInput Format. The first line of the input contains the number 𝑛 of items and the capacity 𝑊 of a knapsack. The next 𝑛 lines define the values and weights of the items. The 𝑖-th line contains integers 𝑣𝑖 and 𝑤𝑖—the value and the weight of 𝑖-th item, respectively.\nConstraints. 1 ≤ 𝑛 ≤ 10^3, 0 ≤ 𝑊 ≤ 2 · 10^6; 0 ≤ 𝑣𝑖 ≤ 2 · 10^6, 0 < 𝑤𝑖 ≤ 2 · 10^6 for all 1 ≤ 𝑖 ≤ 𝑛. All the numbers are integers.\nMY CODE:\n```\nimport sys\nimport unittest\n\ndef get_optimal_value( tot_capacity, weights_kg, values_money):\n    amount = 0.\n    value_per_item = [float(v) / float(w) for v, w in zip(values_money, weights_kg)]\n    value_per_item.sort(reverse = True)\n    print(value_per_item)\n    for i in range(len(values_money)):\n        if tot_capacity == 0:\n            return amount\n            break\n        add_capacity = min(tot_capacity, weights_kg[i])\n        amount = amount + add_capacity * value_per_item\n        weights_kg[i] = weights_kg[i] - add_capacity\n        tot_capacity = tot_capacity - add_capacity\n    return amount\n\nif __name__ == \"__main__\":\n    data = list(map(int, sys.stdin.read().split()))\n    item, tot_capacity = data[0:2]\n    values_money = data[2:(2 * item + 2):2]\n    weights_kg = data[3:(2 * item + 2):2]\n    opt_value = get_optimal_value(tot_capacity, weights_kg, values_money)\n    print(\"{:.10f}\".format(opt_value))\n```\n\nI am getting \"Process finished with exit code -1\" as an error. please help me in correcting this code\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "The knapsack problem, visual studio issues\r\n                \r\nI implemented a dynamic programming solution to the famous knapsack problem. Now the funny part of this is that visual studio will not allow my code to compile yet when I copy and paste my code in cpp.sh it runs fine with no errors.\n\nAt the moment this is what I am getting in visuial studio for errors: \n\n```\n    Unhandled exception at 0x0FADED76 (ucrtbased.dll) in Practice.exe: An invalid \nparameter was passed to a function that considers invalid parameters fatal.\n```\n\n\nThis occurs at line 10, i.e. ```\ndp[i][j] = 0```\n. I am not sure how to fix this issue, and in general I have noticed that visual studio can be particularly  whiny.\n\nHere is my code:\n\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxKnapSack(std::vector<int>& v, std::vector<int>& w, int capacity) {\n    std::vector<std::vector<int>> dp(capacity + 1, std::vector<int>(v.size() + 1));\n    for (int i = 0; i <= v.size(); i++) {\n        for (int j = 0; j <= capacity; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 0;\n            }\n            else if (j - w[i - 1] >= 0) {\n                dp[i][j] = std::max(v[i-1] + dp[i - 1][j - w[i-1]], dp[i - 1][j]);\n            }\n            else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[v.size()][capacity];\n}\n\n\nint main() {\n\n    std::vector<int> v = { 10, 4, 7 };\n    std::vector<int> w = { 4, 2, 3 };\n    int capacity = 5;\n\n    std::cout << \"The maximum I can get is \" << maxKnapSack(v, w, capacity) << \"\\n\";\n\n    std::cin.get();\n}\n```\n\n    ", "Answer": "\r\nYour vector ```\ndp```\n contains ```\n6```\n elements, each element being a vector of ```\n4```\n elements. It's equivalent to the array definition ```\nint dp[6][4]```\n.\n\nYour outer loop loop from ```\n0```\n to ```\n4```\n (inclusive) and the inner loop loops from ```\n0```\n to ```\n6```\n (inclusive). That means you will use index out of bounds in the nested (inner) vector.\n\nYour loops should be the other way around with their limits. Or your vector ```\ndp```\n should be defined with the sizes switched.\n\n\n\nYour conditions inside the inner loop are also wrong. The condition ```\ni == 0 || j == 0```\n will be false if e.g. ```\ni == 0```\n and ```\nj != 0```\n. That will then lead to you using negative indexes because of ```\ni - 1```\n. That is also out of bounds and again lead to undefined behavior.\n\nYou need to make sure that the ```\nelse if```\n only happens when ```\ni > 0```\n and ```\nj - w[i-1] > 0```\n as well. And the ```\nelse```\n only when ```\ni > 0```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem with dynamic programming for investment portfolio and traceback\r\n                \r\nI am working on a python project utilizing the knapsack problem with dynamic programming to find the best investments based on how much money can be invested. So far I am able to come up with the best investment by name, but I am having trouble with formatting and getting the rest of the information as well as implementing a traceback table. Here is what I have so far and the output:\n```\nimport pandas as pd\nfrom itertools import chain\n\ndef investmentFilename(file):\n    df = pd.read_csv(file)\n    frame = pd.DataFrame(df)\n    frame = frame.drop(0) # dropping the United States\n    # print(frame)\n    return frame\n\ndef loadInvestments(frame):\n    portfolio = []\n    state = frame['RegionName'].tolist()\n    avg = frame['Zhvi'].tolist()\n    dfAvg = pd.DataFrame(avg)\n    # print(dfAvg)\n    tenyr = (frame['10Year'].tolist())\n    tenyr = pd.DataFrame(tenyr)\n    roi = tenyr.multiply(dfAvg, axis='columns', level=None, fill_value=None)\n    # print(roi)\n    # roi = pd.DataFrame(roi)\n    ROI = roi.values.tolist()\n    ROI = list(chain.from_iterable(ROI))\n    print(\"InvestmentName InvestmentCost EstimatedReturnOnInvestment\")\n    for i in range(len(state)):\n        portfolio.append([state[i], int(avg[i]), int(ROI[i])])\n        print(state[i], '\\t', avg[i], '\\t', ROI[i])\n\n    # print(portfolio)\n    # portfolio = list(chain.from_iterable(portfolio))\n    # print(portfolio)\n\n    # printing list data\n    # print(\"Investment Name:\",state)\n    # print(\"Investment Cost:\", avg)\n    # print(\"Estimated Return on Investment:\", ROI)\n    return portfolio\n\ndef optimizeInvestments(invstmt, money):\n    \"\"\" knapsack problem \"\"\"\n    n = len(invstmt)\n    val = []\n    name = []\n    roi = []\n\n    for i in invstmt:\n        name.append(i[0])\n        val.append(i[1])\n        roi.append(i[2])\n\n    K = [[0 for x in range(money + 1)] for x in range(n + 1)]\n    I = [[0 for x in range(money + 1)] for x in range(n + 1)]\n\n    for i in range(n + 1):\n        for w in range(money + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n                I[i][w] = \"\"\n\n            elif roi[i - 1] <= w:\n\n                if (val[i - 1] + K[i - 1][w - roi[i - 1]] > K[i - 1][w]):\n                    K[i][w] = val[i - 1] + K[i - 1][w - roi[i - 1]]\n                    I[i][w] = name[i - 1] + I[i - 1][w - roi[i - 1]]\n                else:\n                    K[i][w] = K[i - 1][w]\n                    I[i][w] = I[i - 1][w]\n\n            else:\n                K[i][w] = K[i - 1][w]\n                I[i][w] = I[i - 1][w]\n\n    return (I[n][money])\n\ndataFrame = investmentFilename('zhvi-short.csv')\nitems = loadInvestments(dataFrame)\nprint(items)\nmoney = 15000 # change the amount of money you want to invest here\n# items = [[\"A\", 60, 120], [\"B\", 100, 20],[\"C\", 120, 30]] # test\n# print(items)\nval = []\nroi = []\nfor i in items:\n    val.append(i[1])\n    roi.append(i[2])\nprint(optimizeInvestments(items, money))\n```\n\nThis gives the output:\nFloridaNew York\nWhich I would want to be separated with an \"and\" or a comma. And then I would like the specific ROI for each of these names to be output as well.\nI also need to implement a traceback table for the optimal investments as well. I know how to implement traceback tables in theory but I am not sure how to implement in regards to the knapsack problem.\n    ", "Answer": "\r\nThis is what I ended up coming up with for solving this problem.\n```\ndef optimizeInvestments(invstmt, money):\n\"\"\" knapsack problem \"\"\"\nn = len(invstmt)\nval = []\nname = []\nroi = []\ntraceback = [[0 for i in range(n)] for i in range(n)]\n\nfor i in invstmt:\n    name.append(i[0])\n    val.append(i[-1])\n    roi.append(i[1])\n\nK = [[0 for x in range(money + 1)] for x in range(n + 1)]\nI = [[0 for x in range(money + 1)] for x in range(n + 1)]\n\nfor i in range(n + 1):\n    for w in range(money + 1):\n        if i == 0 or w == 0:\n            K[i][w] = 0\n            I[i][w] = \"\"\n\n        elif roi[i - 1] <= w:\n\n            if (val[i - 1] + K[i - 1][w - roi[i - 1]] > K[i - 1][w]):\n                K[i][w] = val[i - 1] + K[i - 1][w - roi[i - 1]]\n                if len(I[i - 1][w - roi[i - 1]]) > 0:\n                    I[i][w] = name[i - 1] + \" & \" + I[i - 1][w - roi[i - 1]]\n                else:\n                    I[i][w] = name[i - 1]\n\n            else:\n                K[i][w] = K[i - 1][w]\n                I[i][w] = I[i - 1][w]\n\n        else:\n            K[i][w] = K[i - 1][w]\n            I[i][w] = I[i - 1][w]\n\nportfolio = 'With $'+ str(money) + \", invest in \" + str(I[n][money]) + \" for a ROI of $\" + str(K[n][money])\nreturn portfolio\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem on java - Output always Objective Function\r\n                \r\nHello, i'm trying to create and solve a simple knapsack problem with only 1 bin using java and cplex 12.8. I don't understand why it always gives in output the value of objective function.\nHere is my full code:                \n\n```\n    public static void solveModel(){       \n\n        try {\n\n            n_obj = 5;\n            int capacity = 4\n\n            int[] profits = new int[n_obj];\n            for(int i = 0; i < n_obj; i++ ){\n                weight[i] = ThreadLocalRandom.current().nextInt(1, n_obj/2 + 1);\n                profits[i] = ThreadLocalRandom.current().nextInt(1, 12);\n            }\n\n\n            for(int i = 0; i < weight.length; i++){\n                System.out.println(\"Weight \" + i + \":\\t\" + weight[i]);\n                System.out.println(\"Profit \" + i + \":\\t\" + profits[i]);\n\n            }\n\n            IloCplex model = new IloCplex();\n            IloNumVar x = model.boolVar();\n\n\n\n            IloLinearNumExpr obj = model.linearNumExpr();\n            for(int i = 0; i < n_obj; i++){\n                obj.addTerm(profits[i], x);\n            }\n\n            //obj function\n            model.addMaximize(obj);\n\n            //constraints\n\n            for(int i = 0; i < n_obj; i++){\n                model.addLe(model.prod(weight[i], x), capacity) ;\n                model.addEq(x, 1);\n\n            }\n\n            if (model.solve()) {\n\n                System.out.println(\"Obj = \" + model.getObjValue());\n            }\n            else {\n                System.out.println(\"Problem not solved\");\n            }\n\n            model.end();\n\n\n\n        } catch (IloException e) {\n            e.printStackTrace();\n        }\n\n    }\n```\n\n\nI set n_obj and capacity to fixed values to make it as simple as possible.\nThe output is everytime this:\n\n```\nWeight 0:   1\nProfit 0:   2\nWeight 1:   1\nProfit 1:   11\nWeight 2:   2\nProfit 2:   2\nWeight 3:   1\nProfit 3:   7\nWeight 4:   2\nProfit 4:   6\nFound incumbent of value 28.000000 after 0.00 sec. (0.00 ticks)\n\nRoot node processing (before b&c):\nReal time             =    0.00 sec. (0.00 ticks)\nParallel b&c, 8 threads:\n  Real time             =    0.00 sec. (0.00 ticks)\n  Sync time (average)   =    0.00 sec.\n  Wait time (average)   =    0.00 sec.\n                      ------------\nTotal (root+branch&cut) =    0.00 sec. (0.00 ticks)\nObj = 28.0\n```\n\n    ", "Answer": "\r\nOk, for those who are, or will be, interested... i solved by myself.\nThe declaration of the boolean variable has been done in this way:\n\n```\nIloNumVar[] x = new IloNumVar[n_obj];\nfor (int i = 0; i < n_obj; i++) {\n//x[i] = model.numVar(0, Double.POSITIVE_INFINITY, IloNumVarType.Bool, \"x[\" + i + \n//\"]\");\n    x[i] = model.boolVar();\n}\n```\n\n\nAnd i modified the constraints:\n\n```\n IloLinearNumExpr lin = model.linearNumExpr();\n        for (int i = 0; i < n_obj; i++) {\n            //model.addLe(model.prod(weight[i], x[i]), capacity);\n            lin.addTerm(x[i], weight[i]);\n        }\n\n        model.addLe(lin, capacity, \"Constraints\");\n```\n\n\nI know it was a simple Knapsack problem, but i'm a cplex beginner and i hope it will be useful to other people.\n\nHave fun\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Unexpected result from Knapsack problem recursive function\r\n                \r\nI have to write a simple program to solve the Knapsack problem.\nI wrote this code for now and I think this is all I need, but I keep having different results everytime I execute it. All I can think is that there is a problem of memory deallocation, but I don't know how to solve it. Any ideas?\n\nP.S. Maybe it's a stupid question but I never worked in C.\n\n```\n#include <stdio.h>\n\nint max(int a, int b){\n  if(a > b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\nint knapsack(int prices[], int weight[], int n, int max_weight){\n  if(n < 0)\n    return 0;\n  if (weight[n] > max_weight)\n    return knapsack(prices, weight, n-1, max_weight);\n  else\n    return max(knapsack(prices, weight, n-1, max_weight), (knapsack(prices, weight, n-1, max_weight - weight[n]) + prices[n]));\n}\n\nint main(int argc, char const *argv[]) {\n  int i, weight[] = {2,3,3,4}, prices[] = {1,5,2,9}, max_weight = 7, n, result;\n  for (i=0; i<argc; i++) {\n    printf(\"%d: \\\"%s\\\"\\n\", i, argv[i]);\n  }\n  n = (sizeof(weight))/(sizeof(weight[0]));\n  result = knapsack(prices, weight, n, max_weight);\n  printf(\"%d\\n\", result);\n  return 0;\n}\n```\n\n\nRESULTS\n\n    ", "Answer": "\r\nIt looks like you are indexing the arrays with an number that is too large.\nYou get the size of the array doing\n\n```\nn = (sizeof(weight))/(sizeof(weight[0]));\n```\n\n\nYou cannot index weight at ```\nn```\n because it only has indices ```\n0```\n to ```\nn-1```\n\n\nTry calling \n\n```\nresult = knapsack(prices, weight, n-1, max_weight);\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack problem with dp getting my answer wrong\r\n                \r\n```\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        \n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int [] val = new int[n];\n        int [] weight = new int[n];\n        for(int i =0;i<n;i++){\n            val[i] = sc.nextInt();\n        }\n        \n         for(int i =0;i<n;i++){\n            weight[i] = sc.nextInt();\n        }\n        \n        int cap = sc.nextInt();\n        int [][]dp = new int[n+1][cap+1];\n        System.out.println(getMaxVal(val, weight, cap, 0, 0, dp));\n      \n        \n    }\n    \n    public static int getMaxVal(int []val, int []wt, int cap, int index, int valStored, int [][]dp){\n        \n        if(cap == 0 || index >= val.length){\n            return valStored;\n        } \n        if(dp[index][cap] != 0) {\n            return dp[index][cap];\n        }\n        \n        int n = val.length;\n        int withCurrentItem = 0;\n        int inittalMaxValue = 0;\n        if(cap - wt[index] >=0){\n            withCurrentItem = getMaxVal(val, wt, cap - wt[index], index+1, valStored+val[index], dp);\n        }\n        int withoutCurrentItem = getMaxVal(val, wt, cap, index+1, valStored, dp);\n      \n\n        dp[index][cap] = Math.max(withoutCurrentItem, withCurrentItem);\n        \n        return  Math.max(withoutCurrentItem, withCurrentItem);\n        \n        \n        \n        \n        \n        \n    }\n}\n```\n\nIn this 0 / 1 knapsack problem if i use the same code without dp then it works perfectly and all of my test cases pass. but if i do like this way i am getting my some of the test cases failed. What i am doing wrong here please help me out in it.\n    ", "Answer": "\r\nThe idea of ```\nDynamic Programming```\n is as follows: You have a function that takes some parameters, but its output depends on only particular parameters (if those parameters are the same, the output is always the same) so we don't compute the answer more than once because those parameters are the same and we know the output.\nThe issue with your dynamic programming is that you assumed that the output of ```\ngetMaxVal```\n depends only on ```\ncap```\n and ```\nindex```\n, but in fact, it depends on ```\nvalStored```\n as well. But you check ```\ncap```\n and ```\nindex```\n and assume that the output is the same which is wrong.\nOne possible solution is that you can extend your memo and include ```\nvalStored```\n as well, but this increases complexity.\nAnother possible solution (which I recommend) is that you can change the function so that it does not depend on ```\nvalStored```\n.\nHow to find such errors in the future\nHow I approached your problem is as follows: I implemented both ```\nwithDP```\n and ```\nwithoutDP```\n functions, created random inputs and tested these two over and over again, and compared their outputs. When there is some issue, I printed the input and continued further investigation. I'm telling this because you can always follow these steps and try to debug the code yourself.\nHere is the code (note that some inputs, ```\ncap```\n and ```\nindex```\n is the same but output is different)\n```\nimport java.util.*;\n\npublic class Main {\n\n    static ArrayList<String> parameters;\n\n    public static void main(String[] args) {\n\n        parameters = new ArrayList<>();\n        Random r = new Random(0);\n        int[] val;\n        int[] weight;\n        int n;\n        int[][] dp;\n\n        for (int counter = 0; counter < 1000; counter++) {\n            System.out.println(\"Test Case: \" + counter);\n            parameters.clear();\n            n = r.nextInt(5) + 5;\n            val = new int[n];\n            weight = new int[n];\n            for (int i = 0; i < n; i++) {\n                val[i] = r.nextInt(9) + 1;\n            }\n\n            for (int i = 0; i < n; i++) {\n                weight[i] = r.nextInt(9) + 1;\n            }\n\n            int cap = r.nextInt(90) + 10;\n            dp = new int[n + 1][cap + 1];\n            int withDP = getMaxValDP(val, weight, cap, 0, 0, dp);\n            int withoutDP = getMaxVal(val, weight, cap, 0, 0);\n            if (withDP != withoutDP) {\n                System.out.println(\"With DP: \" + withDP);\n                System.out.println(\"Without DP: \" + withoutDP);\n                System.out.println(\"input:\");\n                System.out.println(\"n = \" + n);\n                System.out.println(\"cap = \" + cap);\n\n                System.out.print(\"val:    \");\n                for (int i: val) {\n                    System.out.print(i + \", \");\n                }\n                System.out.println();\n\n                System.out.print(\"weight: \");\n                for (int i: weight) {\n                    System.out.print(i + \", \");\n                }\n                System.out.println();\n\n                Collections.sort(parameters);\n                for (String s: parameters){\n                    System.out.println(s);\n                }\n\n                break;\n            }\n        }\n\n    }\n\n    public static int getMaxVal(int []val, int []wt, int cap, int index, int valStored){\n\n        if(cap == 0 || index >= val.length){\n            parameters.add(\"cap:  \" + cap + \",\\tindex: \" + index + \",\\tvalStored: \" + valStored + \",\\treturn value: \" + valStored);\n            return valStored;\n        }\n\n        int withCurrentItem = 0;\n        if(cap - wt[index] >=0){\n            withCurrentItem = getMaxVal(val, wt, cap - wt[index], index+1, valStored+val[index]);\n        }\n        int withoutCurrentItem = getMaxVal(val, wt, cap, index+1, valStored);\n\n        parameters.add(\"cap:  \" + cap + \",\\tindex: \" + index + \",\\tvalStored: \" + valStored + \",\\treturn value: \" + Math.max(withoutCurrentItem, withCurrentItem));\n        return Math.max(withoutCurrentItem, withCurrentItem);\n\n    }\n\n    public static int getMaxValDP(int []val, int []wt, int cap, int index, int valStored, int [][]dp){\n\n        if(cap == 0 || index >= val.length){\n            return valStored;\n        }\n        if(dp[index][cap] != 0) {\n            return dp[index][cap];\n        }\n\n        int withCurrentItem = 0;\n        if(cap - wt[index] >=0){\n            withCurrentItem = getMaxValDP(val, wt, cap - wt[index], index+1, valStored+val[index], dp);\n        }\n        int withoutCurrentItem = getMaxValDP(val, wt, cap, index+1, valStored, dp);\n\n        dp[index][cap] = Math.max(withoutCurrentItem, withCurrentItem);\n\n        return  Math.max(withoutCurrentItem, withCurrentItem);\n\n    }\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Pseudo code Algorithm for Knapsack Problem with Two Constrains\r\n                \r\nI'm trying to solve following knapsack problem with two constrains.\n\nWhat we know:\n\n\nList item Total number of items\nList item Weight\nList item Value\nList item If item is fragile or not (true/false)\n\n\nConstrains:\n\n\nList item Maximal weight of knapsack\nList item Maximum number of fragile items knapsack can contain.\n\n\nCan anyone give me some advice about algorithm i should use, pseudo code or good article?\n\nUPDATE:\n\nImportant thing I forgot to mention is that I also need to know which items I putted in the bag.\n    ", "Answer": "\r\nIt looks like a modification to knapsack would solve it.\n\nLet's say we have N items, maximum knapscak weight is W, and max amount of fragile items is F\n\nlet's define our dp table as 3-dimensional array dp[N+1][W+1][F+1]\n\nNow dp[n][w][f] stores maximum value we can get if we fill knapsack with some subset of items from first\nn items, having weight of exacly w and having exacly f fragile items.\n\nfrop dp[n][w][f] we can move to states:\n\n\ndp[n+1][w][f] if we skip n+1 th item\ndp[n+1][w + weight(n+1)][f + isFragile(n+1)] if we take n+1 th item\n\n\nso pseudocde:\n\n```\ndp[N+1][W+1][F+1] // memo table, initially filled with -1\n\n int solve(n,w,f)\n{\n    if(n > N)return 0;\n    if(dp[n][w][f] != -1) return dp[n][w][f];\n\n    dp[n][w][f] = solve(n+1,w,f); //skip item\n    if(w + weight(n) <= W && f + isFragile(n) <=F)\n    dp[n][w][f] = max(dp[n][w][f], value(n) + solve(n+1, w + weight(n), f + isFragile(n)));\n\n    return dp[n][w][f]\n}\n\nprint(solve(1,0,0))\n```\n\n\nGetting the actual subset is also not difficult:\n\n```\nvector<int> getSolution(n,w,f)\n{   \n    int optimalValue = solve(n,w,f);\n    vector<int>answer; //just some dynamic array / arrayList\n\n    while(n <= N)\n    {\n        if(solve(n+1,w,f) == optimalValue)n++; //if after skipping item we can still get optimal answer we just skip it\n        else //otherwise we cant so current item must be taken\n        {\n            int new_w = w + weight(n);\n            int new_f = f + isFragile(n);\n            answer.push_back(n); //so we just save its index, and update all values\n            optimalValue -= value(n);\n            n++;\n            w = new_w;\n            f = new_f;\n        }\n    }\n    return answer;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem with specified number of weights can be used\r\n                \r\nI have a knapsack problem with specified knapsack capacity for weight and weights count.\n\nI need an algorithm that packs weights to knapsack when knapsack capacity is C, needed weights count is N and there is a list of weights. Sorting of weights doesn't matter. It would be best if algorithm is recursive.\n\nFor example:\nI have knapsack witch can hold only 3 weights and they have to weight 10 and I have these weights: 9, 8, 7, 2, 1. The correct (and only) answer is 7, 2, 1. \n\nIt would be best if someone write pseudocode, but its ok if its any of the common programing languages.\n\nP.S. Any tips its appreciated as well :)\n\n[EDIT]I need algorithm that gives answer with exactly the N weights count which weights exactly C.\n    ", "Answer": "\r\nThis is the 0-1 knapsack problem, which can be solved using dynamic programming in pseudo-plynomial time.\n\nSee Wikipedia's knapsack problem article for instructions on how to solve the problem using dynamic programming.\n\nSee these CS lecture slides for a walk-through and pseudocode.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem - how to get the remaining capacity\r\n                \r\nI am trying to practice my python skills, so I tried to \"play\" with Knapsack problem.\nI used this algorithm\n\r\n\r\n```\ndef knapSack(W, wt, val, n): \n  \n    if n == 0 or W == 0: \n        return 0\n    if (wt[n-1] > W): \n        return knapSack(W, wt, val, n-1) \n\n    else: \n        return max( \n            val[n-1] + knapSack( \n                W-wt[n-1], wt, val, n-1), \n            knapSack(W, wt, val, n-1)) \n  ```\n\r\n\r\n\r\n\nI cant figure out how to count the remaining capacity at the end,\nfor example, if my val list is [4,2,1,5,3] and the weights are [3,5,1,2,4] and my capacity(W) is 4, so it will return 6 and the remaining capacity will be 1\nhow can I get this 1?\nthanks!\n    ", "Answer": "\r\nMemorization Technique (an extension of recursive approach).\nThis method is basically an extension to the recursive approach so that we can overcome the problem of calculating redundant cases and thus increased complexity. We can solve this problem by simply creating a 2-D array that can store a particular state (n, w) if we get it the first time. Now if we come across the same state (n, w) again instead of calculating it in exponential complexity we can directly return its result stored in the table in constant time. This method gives an edge over the recursive approach in this aspect.\n```\nval = [4,2,1,5,3] \nwt = [3,5,1,2,4]] \nW = 4\nn = len(val) \n\n\nt = [[-1 for i in range(W + 1)] for j in range(n + 1)] \n\ndef knapsack(wt, val, W, n): \n\n    if n == 0 or W == 0: \n        return 0\n    if t[n][W] != -1: \n        return t[n][W] \n\n    if wt[n-1] <= W: \n        t[n][W] = max( \n            val[n-1] + knapsack( \n                wt, val, W-wt[n-1], n-1), \n              knapsack(wt, val, W, n-1)) \n        return t[n][W] \n    elif wt[n-1] > W: \n        t[n][W] = knapsack(wt, val, W, n-1) \n        return t[n][W]\n```\n\nPlease try this!\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsacks problem 1/0 dynamic\r\n                \r\nI want to solve the knapsack problem with dynamic programming! The item should be in the knapsack or not, I do not want to put the same item in the knapsack more then one time!\n\nI've looked at this code but with this one you can add the same object more then just one time\n\n```\n#include <stdio.h>\n\n#define MAXWEIGHT 100\n\nint n = 3; /* The number of objects */\nint c[10] = {8, 6, 4}; /* c[i] is the *COST* of the ith object; i.e. what\n                YOU PAY to take the object */\nint v[10] = {16, 10, 7}; /* v[i] is the *VALUE* of the ith object; i.e.\n                what YOU GET for taking the object */\nint W = 10; /* The maximum weight you can take */ \n\nvoid fill_sack() {\n    int a[MAXWEIGHT]; /* a[i] holds the maximum value that can be obtained\n                using at most i weight */\n    int last_added[MAXWEIGHT]; /* I use this to calculate which object were\n                    added */\n    int i, j;\n    int aux;\n\n    for (i = 0; i <= W; ++i) {\n        a[i] = 0;\n        last_added[i] = -1;\n    }\n\n    a[0] = 0;\n    for (i = 1; i <= W; ++i)\n        for (j = 0; j < n; ++j)\n            if ((c[j] <= i) && (a[i] < a[i - c[j]] + v[j])) {\n                a[i] = a[i - c[j]] + v[j];\n                last_added[i] = j;\n            }\n\n    for (i = 0; i <= W; ++i)\n        if (last_added[i] != -1)\n            printf(\"Weight %d; Benefit: %d; To reach this weight I added object %d (%d$ %dKg) to weight %d.\\n\", \n                         i, a[i], last_added[i] + 1, v[last_added[i]], \n                         c[last_added[i]], i - c[last_added[i]]);\n        else\n            printf(\"Weight %d; Benefit: 0; Can't reach this exact weight.\\n\", i);\n\n    printf(\"---\\n\");\n\n    aux = W;\n    while ((aux > 0) && (last_added[aux] != -1)) {\n        printf(\"Added object %d (%d$ %dKg). Space left: %d\\n\", \n               last_added[aux] + 1, v[last_added[aux]], \n               c[last_added[aux]], aux - c[last_added[aux]]);\n        aux -= c[last_added[aux]];\n    }\n\n    printf(\"Total value added: %d$\\n\", a[W]);\n}\n\nint main(int argc, char *argv[]) {\n    fill_sack();\n\n    return 0;\n}\n```\n\n\nand then i tried to make a array to see if the object is in the knapsack or not, but then this program did not work as it should! \n\n```\n#define MAXWEIGHT 101\n#define MAX_ITEMS 100000\n\nint items = 2;\nint c[10] = {1, 2};\nint v[10] = {1000, 2001};\nint W = 100;\nint taken[MAX_ITEMS];\n\nvoid takenOrNot(){\n  int i;\n\n  for(i = 0; i < items; i++){\n    taken[i] = 0;\n  }\n}\nvoid fill_sack() {\n  int a[MAXWEIGHT];\n  int last_added[MAXWEIGHT];\n  int i, j;\n  int aux;\n\n  for (i = 0; i <= W; ++i) {\n    a[i] = 0;\n    last_added[i] = -1;\n  }\n\n  a[0] = 0;\n  for (i = 1; i <= W; ++i)\n    for (j = 0; j < items; ++j)\n        if ((c[j] <= i) && (a[i] < a[i - c[j]] + v[j]) && taken[j] == 0) {\n            a[i] = a[i - c[j]] + v[j];\n            last_added[i] = j;\n            taken[j] = 1;\n        }\n\n  for (i = 0; i <= W; ++i)\n    if (last_added[i] != -1)\n      printf(\"Weight %d; Benefit: %d; To reach this weight I added object %d (%d$ %dKg) to weight %d.\\n\", \n           i, a[i], last_added[i] + 1, v[last_added[i]], \n           c[last_added[i]], i - c[last_added[i]]);\n    else\n      printf(\"Weight %d; Benefit: 0; Can't reach this exact weight.\\n\", i);\n\n  printf(\"---\\n\");\n\n  aux = W;\n  while ((aux > 0) && (last_added[aux] != -1)) {\n    printf(\"Added object %d (%d$ %dKg). Space left: %d\\n\", \n        last_added[aux] + 1, v[last_added[aux]], \n        c[last_added[aux]], aux - c[last_added[aux]]);\n    aux -= c[last_added[aux]];\n  }\n\n  printf(\"Total value added: %d$\\n\", a[W]);\n}\n\nint main(int argc, char *argv[]) {\n\n  takenOrNot();\n  fill_sack();\n\n  return 0;\n}\n```\n\n\nCould you guys help me please? :) \n    ", "Answer": "\r\nThis might help...!\n```\npublic class Knapsack\n{\n    int knapsackSize;\n    int[] _weights;\n    int[] _values;\n    int[,] results;\n\n\n    public Knapsack(int[] weights, int[] values, int size)\n    {\n        _weights = weights;\n        _values = values;\n        knapsackSize = size;\n    }\n\n    public int CreateSolution()\n    {\n        results = new int[_weights.Length + 1, knapsackSize + 1];\n\n        for (int i = 0; i < _weights.Length; i++)   // item 1 to n\n        {\n            for (int j = 1; j <= knapsackSize; j++) //weight 1 to m\n            {\n                if (_weights[i] > j)\n                {\n                    //if item weight is grater than knapsack capacity\n                    results[i + 1, j] = results[i, j];\n                }\n\n                else\n                {\n                    if (results[i, j] > (_values[i] + results[i, j - _weights[i]]))\n                    {\n                        //if previously calculated value only is grater\n                        results[i + 1, j] = results[i, j];\n                    }\n                    else\n                    {\n                        //if including current item gives more value\n                        results[i + 1, j] = _values[i] + results[i, j - _weights[i]];\n                    }\n                }\n            }\n        }\n        return results[_weights.Length, knapsackSize]; // index (n, m) will be max value\n    }\n\n    static void Main(string[] args)\n    {\n        Knapsack demo = new Knapsack(new int[] { 23, 26, 20, 18, 32, 27, 29, 26, 30, 27 }, new int[] { 505, 352, 458, 220, 354, 414, 498, 545, 473, 543 }, 67);\n        Console.WriteLine(\"Solution is: \" + demo.CreateSolution());\n        Console.ReadLine();\n    }\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why this Knapsack problem's solution is not working?\r\n                \r\nI was recently solving a knapsack problem. In this version of knapsack, instead of weight, value is taken into the state.\nThe problem is the same as general Knapsack: There are n items, Item i has a weight of wi and a value of vi. The capacity of the knapsack is W. Find the maximum possible sum of the values of items that can be filled in the knapsack.\nConstraints:   1<= n <=100    1<= W <=10^9  1<= wi <=W     1<= vi <=1000\nInput: n W\nw1 v1    w2 v2     w3 v3   ..... wn vn\nDue to large value of weight, We have to take value in the state and the result will be the minimum weight. Although I have explained the problem but in case you need more details this is the problem link.\nThe below code is my attempt to solve the problem. I have used 1-based indexing. I'm not able to find out the error. I have tried debugging the code but that didn't help. I'm stuck on this from 2 days. Please help.\n```\n  #include <iostream>\n  #include <limits.h>\n  using namespace std;\n\n  int main()\n  {\n    int n,W;\n\n    cin>>n>>W;    // no. of elements and maxm. Weight\n    int v[n+1],w[n+1];   // array for value and weight \n    int dp[n+1][100001];  // dp array with size n+1 and 10^5+1 (for v max value 1000, and for n 100)\n\n    // Initializing arrays\n\n    v[0]=INT_MAX; w[0]=INT_MAX;\n\n    for (int i = 0; i < n+1; ++i)\n    {\n      for (int j = 0; j < 100001; ++j)\n      {\n        dp[i][j]=INT_MAX;      \n      }\n    }\n\n    for (int i = 1; i < n+1; ++i){\n      cin>>w[i]>>v[i];\n    }\n    \n    dp[1][0]=0; // for 0 value, no value for weight\n    dp[1][v[1]]=w[1]; \n\n    \n    for (int i = 2; i < n+1; ++i) \n    {\n      dp[i][0]=0;\n      \n      for (int j = 1; j < 100001; ++j)\n      {\n        dp[i][j]=dp[i-1][j]; // excluding the element\n\n        if(j-v[i]>=1){ \n          dp[i][j]=min(dp[i][j],w[i]+dp[i-1][j-v[i]]); // min of including and excluding element\n        }\n      }\n    }\n\n    // to find the max value for which weight is <=W\n    for(int i=100000; i>=1; i--){\n      if(dp[n][i]<=W){\n        cout<<i; break;\n      }\n    }\n\n    return 0;\n  }\n```\n\n    ", "Answer": "\r\nThere's a few problems with your code:\n\nMax value can be 0\nweight needed to reach some value can be > ```\nINT_MAX```\n\n```\ndp[1][v[1]]=w[1];```\n uneeded line\n```\nfor (int j = 1; j < 100001; ++j)```\n ```\nj```\n of 0 is valid weight though\n```\nif(j-v[i]>=1){ ```\n same as above\n\nHere's a fixed version:\n```\n #include <iostream>\n  #include <limits.h>\n#define ll long long\n  using namespace std;\n\n  int main()\n  {\n    int n,W;\n\n    cin>>n>>W;    // no. of elements and maxm. Weight\n    ll v[n+1],w[n+1];   // array for value and weight \n    ll dp[n+1][100001];  // dp array with size n+1 and 10^5+1 (for v max value 1000, and for n 100)\n\n    // Initializing arrays\n\n    v[0]=1e17; w[0]=1e17;\n\n    for (int i = 0; i < n+1; ++i)\n    {\n      for (int j = 0; j < 100001; ++j)\n      {\n        dp[i][j]=INT_MAX;      \n      }\n    }\n\n    for (int i = 1; i < n+1; ++i){\n      cin>>w[i]>>v[i];\n    }\n    \n    dp[0][0]=0; // for 0 value, no value for weight\n\n    for (int i = 1; i < n+1; ++i) \n    {\n      dp[i][0]=0;\n      \n      for (int j = 0; j < 100001; ++j)\n      {\n        dp[i][j]=dp[i-1][j]; // excluding the element\n\n        if(j-v[i]>=0){ \n          dp[i][j]=min(dp[i][j],w[i]+dp[i-1][j-v[i]]); // min of including and excluding element\n        }\n      }\n    }\n\n    // to find the max value for which weight is <=W\n    for(int i=100000; i>=0; i--){\n      if(dp[n][i]<=W){\n        cout<<i; break;\n      }\n    }\n\n    return 0;\n  }\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem(optimized doesn't work correctly)\r\n                \r\nI am working on the Python code in order to solve Knapsack problem.\n\nHere is my code:\n\n```\nimport time\nstart_time = time.time()\n#reading the data:\nvalues = []\nweights = []\ntest = []\nwith open(\"test.txt\") as file:\n\n  W, size = map(int, next(file).strip().split())\n  for line in file:\n    value, weight = map(int, line.strip().split())\n    values.append(int(value))\n    weights.append(int(weight))\n\nweights = [0] + weights\nvalues = [0] + values\n\n#Knapsack Algorithm:\n\n\nhash_table = {}\nfor x in range(0,W +1):\n  hash_table[(0,x)] = 0\n\nfor i in range(1,size + 1):\n  for x in range(0,W +1):\n    if weights[i] > x:\n      hash_table[(i,x)] = hash_table[i - 1,x]\n    else:\n      hash_table[(i,x)] = max(hash_table[i - 1,x],hash_table[i - 1,x - weights[i]] + values[i])\n\nprint(\"--- %s seconds ---\" % (time.time() - start_time))\n```\n\n\nThis code works correctly, but on a big files my programm crashes due to RAM issues.\n\nSo I have decided to change the followng part:\n\n```\nfor i in range(1,size + 1):\n  for x in range(0,W +1):\n    if weights[i] > x:\n      hash_table[(1,x)] = hash_table[0,x]\n      #hash_table[(0,x)] = hash_table[1,x]\n    else:\n      hash_table[(1,x)] = max(hash_table[0,x],hash_table[0,x - weights[i]] + values[i])\n      hash_table[(0,x)] = hash_table[(1,x)]\n```\n\n\nAs you can see instead of using n rows i am using only two(copying the second row into the first one in order to recreate the following line of code ```\nhash_table[(i,x)] = hash_table[i - 1,x]```\n), which should solve issues with RAM.\n\nBut unfortunately it gives me a wrong result. \n\nI have used the following test case:\n\n```\n190 6\n\n50 56\n\n50 59\n\n64 80\n\n46 64\n\n50 75\n\n5 17\n\nShould get a total value of 150 and total weight of 190 using 3 items:\n\nitem with value 50 and weight 75,\n\nitem with value 50 and weight 59,\n\nitem with value 50 and weight 56,\n```\n\n\nMore test cases: https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html\n    ", "Answer": "\r\nThe problem here is that you need to reset all the values in the iteration over i, but also need the x index, so to do so, you could use another loop:\n\n```\nfor i in range(1,size + 1):\n  for x in range(0,W +1):\n    if weights[i] > x:\n      hash_table[(1,x)] = hash_table[0,x]\n    else:\n      hash_table[(1,x)] = max(hash_table[0,x],hash_table[0,x - weights[i]] + values[i])\n  for x in range(0, W+1): # Make sure to reset after working on item i\n    hash_table[(0,x)] = hash_table[(1,x)]\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem: Why do I need a 2 dimensional DP Matrix\r\n                \r\nI came across some classical Knapsack solutions and they always build a 2-dimensional DP array.\nIn my opinion, my code below solves the classical knapsack problem but with only a 1-dim DP array.\nCan someone tell me where my solution does not work or why it is computationally inefficient compared to the 2D-DP version?\nA 2D-DP version can be found here\nhttps://www.geeksforgeeks.org/python-program-for-dynamic-programming-set-10-0-1-knapsack-problem/\nexample input:\n```\nweights = [(3,30),(2,20),(1,50),(4,30)]\nconstraint = 5\n```\n\nAnd my solution:\n```\ndef knapsack(weights,constraint):\n    n = len(weights)\n\n    #define dp array\n    dp = [0]*(constraint+1) \n\n    #start filling in the array\n    for k in weights:\n        for i in range(constraint,k[0]-1,-1):\n            dp[i] = max(dp[i],dp[i-k[0]]+k[1])\n    return dp[constraint]\n```\n\n    ", "Answer": "\r\nThe version using O(nW) memory is more intuitive and makes it possible to easily retrieve the subset of items that produce the optimal answer value.\nBut, using O(n + W) of memory, we cannot retrieve this subset directly. While it is possible to do this, using the divide-and-conquer technique as explained in https://codeforces.com/blog/entry/47247?#comment-316200.\nSample code\n```\n#include <bits/stdc++.h>\n \nusing namespace std;\nusing vi = vector<int>;\n#define FOR(i, b) for(int i = 0; i < (b); i++)\n \ntemplate<class T>\nstruct Knapsack{\n  int n, W;\n  vector<T> dp, vl;\n  vi ans, opt, wg;\n \n  Knapsack(int n_, int W): n(0), W(W),\n    dp(W + 1), vl(n_), opt(W + 1), wg(n_){}\n  \n  void Add(T v, int w){\n    vl[n] = v;\n    wg[n++] = w;\n  }\n \n  T conquer(int l, int r, int W){\n    if(l == r){\n      if(W >= wg[l])\n        return ans.push_back(l), vl[l];\n      return 0;\n    }\n \n    FOR(i, W + 1)\n      opt[i] = dp[i] = 0;\n    int m = (l + r) >> 1;\n    \n    for(int i = l; i <= r; i++)\n      for(int sz = W; sz >= wg[i]; sz--){\n        T dpCur = dp[sz - wg[i]] + vl[i];\n        if(dpCur > dp[sz]){\n          dp[sz] = dpCur;\n          opt[sz] = i <= m ? sz : opt[sz - wg[i]];\n        }\n      }\n    \n    T ret = dp[W];\n    int K = opt[W];\n    T ret2 = conquer(l, m, K) + conquer(m + 1, r, W - K);\n    assert(ret2 == ret);\n    return ret;\n  }\n \n  T Solve(){\n    return conquer(0, n - 1, W);\n  }\n};\n \n \nint main(){\n  cin.tie(0)->sync_with_stdio(0);\n \n  int n, W, vl, wg;\n  cin >> n >> W;\n  Knapsack<int> ks(n, W);\n \n  FOR(i, n){\n    cin >> vl >> wg;\n    ks.Add(vl, wg);\n  }\n  \n  cout << ks.Solve() << endl;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Can this problem be solved using knapsack problem-solving approach (varying-size knapsack?)\r\n                \r\nTo comply with regulation a bank needs to make sure that at least 90% (or some other fixed proportion) of the money it holds is “clean”.\n\nMoney is considered clean if it is in a “clean” account. An account is considered “clean” if all the money in it comes from a verifiable source. \n\nThe bank can forcefully return money to the clients coming from a non-verifiable source in order to increment the proportion of \"clean\" money to comply with the regulation. The problem is to determine the minimum amount that the bank needs to return to comply with the regulation.\n\n```\nAccount Verif   NonVerif    Divi    Clean   NotClean\n1   889.77  157.01  5.67    0   1046.78\n2   907.88  160.21  5.67    0   1068.09\n3   1187.18 209.5   5.67    0   1396.68\n4   918.12  162.02  5.67    0   1080.14\n5   1721.88 303.86  5.67    0   2025.74\n6   828.17  276.05  3.00    0   1104.22\n7   1127.6  375.86  3.00    0   1503.46\n8   1177.13 392.37  3.00    0   1569.5\n9   801.81  267.27  3.00    0   1069.08\n10  741.9   247.3   3.00    0   989.2\n11  0   1468.11 0.00    0   1468.11\n12  0   853.66  0.00    0   853.66\n13  2354.81 0   -1.00   2354.81 0\n14  2267.1  0   -1.00   2267.1  0\n15  2238.3  0   -1.00   2238.3  0\n16  2188.66 0   -1.00   2188.66 0\n17  2167.85 0   -1.00   2167.85 0\n18  2166.1  0   -1.00   2166.1  0\n19  2165.59 0   -1.00   2165.59 0\n20  2163.84 0   -1.00   2163.84 0\n21  2145.43 0   -1.00   2145.43 0\n22  2117.76 0   -1.00   2117.76 0\n23  1320.26 0   -1.00   1320.26 0\n24  1299.99 0   -1.00   1299.99 0\n25  1241.02 0   -1.00   1241.02 0\n26  1237.36 0   -1.00   1237.36 0\n27  1208.74 0   -1.00   1208.74 0\n28  1114.58 0   -1.00   1114.58 0\n29  1048.63 0   -1.00   1048.63 0\n30  1010.92 0   -1.00   1010.92 0\n31  971.1   0   -1.00   971.1   0\n32  874.95  0   -1.00   874.95  0\n33  832.01  0   -1.00   832.01  0\n34  825.72  0   -1.00   825.72  0\nTOTAL   45262.16    4873.22     34960.72    15174.66\n```\n\n\nIn the example above, total money held by the bank is 34960.72 + 15174.66 = 50135.38; without doing any cleansing, only the 69.7% (34960.72 / 50135.38 = 0.697...) can be considered clean so the bank needs to cleanse to comply with the regulation. \n\nIf the bank cleansed the first two accounts then the total money held by the bank would be 50135.38 - 157.01 - 160.21 = 49818.16 and clean money would be 34960.72 + 889.77 + 907.88 = 36758.37; the proportion of clean money would be 36758.37 / 49818.16 = 73.7%.\n\nIn the example above, Div=Verif/NonVerif (Verif would be value and NonVerif would be Weight, as to see the items that provide the best ratio to select those); the list in example is sorted by descending Div. Naive approach is to pick which accounts to cleanse in that order until the bank complies with the regulation.\n\nI was thinking of using approach suggested by Avikalp Srivastava here: so Verif (value) would be treated as weight and NonVerif (cost) would be treated as value; the regular knapsack problem-solving approach would then be used to find the maximum cost that can be removed while Verif remains >= 90% * (total money held by the bank); the thing is the total money held by the bank decreases when you add not-clean items to the knapsack because the bank is returning that money to the customer (so the knapsack would become smaller as more items get added to it?). Brute force caused memory overflow for the data shown. I actually tried to solve this for hours without getting any closer to the answer. Maybe knapsack problem-solving is not the correct approach for this (?)\n\nThe naive approach will suffice for my purposes, but I still want to find out how to solve it properly.\n    ", "Answer": "\r\nNote: This approach is based on my understanding in the comment above. If my understanding is wrong, I'll edit.\n\nHere is an approach based on integer linear programming (ILP). \n\n\nLet ```\nI```\n be the set of all accounts and let ```\nI_c```\n and ```\nI_n```\n be the set of clean and non-clean accounts, respectively. \nLet ```\nV[i]```\n and ```\nNV[i]```\n be the amount of verifiable and non-verifiable funds for account ```\ni```\n. \nLet ```\nr```\n be the proportion of funds that must be clean (e.g., 90%). \n\n\n(These are parameters -- inputs to the model.)\n\n\nLet ```\nx[i] = 1```\n if we cleanse account ```\ni```\n, for ```\ni```\n in ```\nI_n```\n, and ```\n0```\n otherwise. (We won't cleanse accounts in ```\nI_c```\n.)\n\n\n(This is a binary decision variable -- a variable that the model will set the value of.)\n\nThen the ILP is:\n\n```\nminimize sum {i in I_n} NV[i] * x[i]\nsubject to sum {i in I_c} V[i] + sum {i in I_n} V[i] * x[i] >= \n               r * (sum {i in I} (NV[i] + V[i]) - sum {i in I_n} NV[i] * x[i]))\n           x[i] in {0,1} for all i in I_n\n```\n\n\nThe objective function minimizes the total funds cleansed. (For each ```\ni```\n in ```\nI_n```\n, if we cleanse the account, then we get rid of ```\nNV[i]```\n amount of money.) The first constraint says that the total clean money must be at least 0.9 of the total money: the total clean money is the original clean money (```\nsum {i in I_c} V[i]```\n) plus the newly cleansed money (```\nsum {i in I_n} V[i] * x[i]```\n); and the total money equals the original total (verified plus not verified) minus the funds cleansed. The second constraint just says all the ```\nx[i]```\n variables have to be binary.\n\nIn terms of implementation, you can certainly solve this in Excel/Solver. (I suspect the nonlinearity you were getting was because you were writing the constraint more like\n\n```\nsum {i in I_c} V[i] + sum {i in I_n} V[i] * x[i] / (sum {i in I} (NV[i] + V[i]) - sum {i in I_n} NV[i] * x[i])) >= r\n```\n\n\nwhich is nonlinear.) You can also use Python/```\nPuLP```\n, or any number of other linear programming packages.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack Problem Simplified in Python\r\n                \r\nI have the following code that is performing too slowly. The idea is similar to the 0/1 knapsack problem, you have a given integer n and you have to find numbers in range 1 to n - 1 that when squared add up to n squared. \n\nFor example if n is 5, then it should output 3 , 4 because 3 ** 2 and 4 ** 2 = (25 or 5 ** 2). I have been struggling to understand how to make this more efficient and would like to know the concepts used to improve the efficiency of this type of program.\n\nSome other examples: n = 8 [None] n = 30 [1, 3, 7, 29] n = 16 [2, 3, 5, 7, 13]\n\nI found some posts regarding this but they seemed limited to two numbers where as my program needs to use as many as it needs to add up to the original number. \n\nI watched some videos on the 0/1 knapsack problem. I struggled to apply the same concepts to  my own program as the issue was quite different. They had things they could put in their bag that had a weight and profit.\n\nThis has all been hurting my brain for a few hours and if anyone could even point me in the right direction I would appreciate it highly, thankyou :)\n\n```\nfrom math import sqrt\ndef decompose(n):\n\n    lst = []\n\n    sets = []\n\n    temp = []\n\n    perm = {}\n\n    out = []\n\n    for i in range (n):\n        lst.append(i**2)\n\n\n    for i in lst:\n        for x in sets:\n            temp.append(i + x)\n            perm[i + x] = (i, x)\n        for x in temp:\n            if x not in sets:\n                sets.append(x)\n        if i not in sets:\n            sets.append(i)\n        temp = []\n\n    if n**2 not in perm.keys():\n        return None\n\n    for i in perm[n**2]:\n        if str(i).isdigit():\n            out.append(i)\n        if i == ' ':\n            out.append(i)\n\n\n    for i in out:\n        if i not in lst:\n            out.remove(i)\n            for i in perm[i]:\n                if str(i).isdigit():\n                    out.append(i)\n                if i == ' ':\n                    out.append(i)\n\n    out.sort()\n\n    return [sqrt(i) for i in out]\n```\n\n    ", "Answer": "\r\nThis got too big for a comment, so I'm putting it here as an answer:\nit's exactly 0/1 knapsack or a \"coin change problem\" (en.wikipedia.org/wiki/Change-making_problem). Your goal is to make 25 cents (if n = 5). Your \"coins\" are 1 cent, 4 cents, 9 cents, 16 cents, etc.  I'm assuming that since you were looking at 0/1 knapsack, that you cannot re-use the same coin (if you can reuse the same coin, the problem is much simpler).\nThere are two approaches to dynamic programming problems like this.  They are both intuitive in their own ways, but one may be more intuitive to you at the moment.\n1.\nThe first is memoization (known as top-down).  This is where you write a recursive function for ```\ndecompose```\n, but you cache the results of every call to ```\ndecompose```\n. the recursive formula here would be something like\n```\ndecompose_cache = dictionary that stores results of calls to decompose\ndef decompose(n = 25, coins_to_use={1,4,9,16}):\n  if (n, coins_to_use) in decompose_cache:\n    return decompose_cache[(n, coins_to_use)]\n  biggest_coin = max(coins_to_use)\n  other_coins = coins_to_use - {biggest_coin}\n  decomposition_with_biggest_coin = decompose(n-biggest_coin, other_coins)\n  decomposition_without_biggest_coin = decompose(n, other_coins)\n  ans = decomposition_with_biggest_coin or decomposition_without_biggest_coin\n  decompose_cache[(n, coins_to_use)] = ans\n  return ans\nprint(decompose(25, {1,4,9,16}))\n```\n\nThat is, to determine if we can make 25 cents using {1,4,9,16}, we merely need to check if we can make 25 cents using {1,4,9} OR if we can make 9 cents (25 - 16) using {1,4,9}.  This recursive definition, if we didn't cache results from each call, would result in something like ```\nO(n^n)```\n function calls, but since we cache the results, we only ever do the computation for some (goal, coins) pair at most once.  There are n^2 possible goals, and n possible sets of coins, so there are n^2 * n pairs, and so there are ```\nO(n^2 * n = n^3)```\n function calls.\n2.\nThe second approach is dynamic programming (known as bottom-up).  (I personally think this is simpler to think about, and you won't run into maximum recursion depth issues in python)\nThis is where you fill up a table, starting from the empty base case, where the value of an entry in the table can be calculated by looking at the values of the entries already filled-in.  We can call the table \"DP\".\nHere, we can build a table where DP[n][k] is true if you can sum to a value of n by using only the first k \"coins\" (where the 1st coin is 1, the 2nd coin is 4, etc).\nThe way we can calculate the value of a cell in the table is:\n```\nDP[n][k] = DP[n - kth coin][k-1] OR DP[n][k-1]```\n\nThe logic is the same as above: we can make change for 5 cents, with the coins {1,4} (the first two coins) if and only if we can make change for 1 cent (5-4) using {1} (the first coin) or if we can make change for 5 cents using {1}.  So, DP[5][2] = DP[1][1] or DP[5][1].\nAgain, there are n^3 entries to this table.  You can fill it up row-by-row from [0][0] to [0][5] and then each row from [0][...] to [25][...] and the answer will be in [25][5].\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "The algorithm for the knapsack problem does not pass all tests\r\n                \r\nGood afternoon! I am starting to learn dynamic programming and trying to \"I\" problem on CodeForces. codeforces.com/gym/100135 Problem link: LINK\nHere is my code:\n```\ndef read_ints():\nreturn list(map(int, input().split()))\n\ns, n = read_ints()\nc = read_ints()\n\nd = [[False for i in range(s + 1)] for j in range(n + 1)]\nd[0][0] = True\n\nfor i in range(1, n + 1):\n    for j in range(s + 1):\n        d[i][j] = d[i - 1][j] or d[i - 1][j - c[i - 1]]\n\ni = s\nwhile not d[n][i]:\n    i -= 1\n\nprint(i)\n```\n\nI use the typical way of solving knapsack problems.\nBut this algorithm fails the fifth test. What could be the problem?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Time Complexity of a Bounded Knapsack problem\r\n                \r\nFor the bounded knapsack with repetition problem, I am given a knapsack with capacity, W. I must fill the knapsack such that I maximize the total value of items inside the knapsack, where each item has an associated weight and value, w and v. However, I can only have a maximum of K of each items. I found an algorithm that does this and I believe it runs with a time complexity of O(Wn). But, I've found a lot of sources that says it could be O(WKn). Why would it be O(WKn) if that is the correct time complexity?\n\nFor transparency, this is indeed a homework problem. I just need assistance on why the time complexity is O(WKn), unless the sources I read were completely wrong.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem with item's weight depending on items selected\r\n                \r\nSuppose there are ```\nstudents[]```\n with ```\nages[]```\n, ```\nsubjectsFailed[]```\n and ```\nsubjectsTaken[]```\n. Suppose Quality Index for each student is ```\nsubjectsFailed[i]/subjectsTaken[i]```\n. I need to select students so that sum of their ages is maxed given that ```\naverageQualityIndex <= x```\n where\n\n```\naverageQualityIndex = ∑subjectsFailed[k]/∑subjectsTaken[k]```\n where k are the students selected.\n\nIn normal knapsack problems, the weights are independent. But, in this case, the average weight will depend on the number of students selected till now and their respective weights. Is there a way I can solve this (best possible solution) using knapsack or there is some other way in which we solve this problem (if yes, then what method?).\n    ", "Answer": "\r\nYou want to satisfy the constraint ```\n∑subjectsFailed[k]/∑subjectsTaken[k] <= x```\n.\n\nMultiplying both sides by ```\n∑subjectsTaken[k]```\n, this becomes ```\n∑subjectsFailed[k] <= x.∑subjectsTaken[k]```\n.\n\nRearranging we find ```\n∑(subjectsFailed[k]-x.subjectsTaken[k]) <= 0```\n or ```\n∑weights[k] <= 0```\n where ```\nweights[k] = subjectsFailed[k]-x.subjectsTaken[k]```\n.\n\nSo with this definition of weights it becomes a knapsack problem again.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "The best and the worst case scenarios for the knapsack problem [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI wonder the best and the worst case scenarios for the knapsack problem. I guess the best case should be the values and the weights for all of the objects have the same values. For example:\n\n```\nint[] values = new int[] { 5, 5, 5};\nint[] weights = new int[] { 9, 9, 9}; \n```\n\n\nBut I don't have any idea about the worst case. \n\nThank you so much!\n    ", "Answer": "\r\nSince best and worst case scenarios are defined relative to algorithms or solutions to problems, I assume that you are referring to the well-known dynamic programming solution to the knapsack problem.\n\nThe dynamic programming solution to the knapsack algorithm is a pseudo-polynomial algorithm that runs in ```\nO(nW)```\n time, where ```\nn```\n denotes the number of items and ```\nW```\n denotes the maximum weight. Thus, you can make this algorithm run very poorly by simply setting the maximum weight to an arbitrarily high value. In particular, setting each weight to ```\n2^n```\n would make this algorithm run in ```\nO(2^n)```\n time. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem - Find which items are taken\r\n                \r\nI need to find every optimal solution for knapsack problem.\nHere is my code \n\n```\nvoid knapSack(int W, int wt[], int val[], int n)\n{\n   int i, w;\n   int K[W+1][n+1];\n   for (w = 0; w <= W; w++)\n   {\n    for(i=0;i<=n;i++){\n        if(i==0)\n            K[w][i]=0;\n\n        if(w<wt[i-1] && i!=0)\n            K[w][i]=K[w][i-1];\n\n        if(w>=wt[i-1] && i!=0)\n            K[w][i]=max(K[w][i-1],K[w-wt[i-1]][i-1]+val[i-1]);\n\n       }\n   }\n\n   i=n;\n  int j=W;\n   while(i,j>0){\n    if(K[j][i]!=K[j][i-1]){\n        cout<<\"Item \"<<i<<\" is in the bag\"<<endl;\n        i=i-1;\n        j=j-wt[i-1];\n    }\n    else\n        i=i-1;\n   }\n}\n```\n\n\nInput data is:\n\n```\n4 6 //n W\n2 1 //p1 w1\n3 2 //p2 w2\n3 4 //p3 w3\n4 5 //p4 w4\n```\n\n\nAnd output should be like this:\n\n```\n1 4\n2 3\n```\n\n\nThe first part of my code which is packing the bag is working great, but the secound part where I try to find which items were taken is giving me answer: item 3, item 2, item 1 which is wrong because there is 2 solutions: you take item 1 and 4 or item 2 or 3. How can I fix this?\n\nIn the picture below there is table with table solution of packing\n\n\n    ", "Answer": "\r\nI would use the same formula that you use to maximize the value to see which items picked i.e. \n\n```\nif (K[w][i] == K[w-wt[i-1]][i-1] + val[i-1])```\n\nthen item ```\ni```\n is picked else this is not picked and go to previous item ```\ni-1```\n.\n\nAlso there could be more than 1 set of items which when picked can yield the maximum value.\n\nIn that case look for each such value in the array ```\nK[W][..]```\n for the maximum value ```\nK[W][n]```\n and traverse the array from that point to get the picked items.\n\nCode is :\n\n```\nvoid knapSack(int W, int wt[], int val[], int n)\n{\n   int i, w;\n   int K[W+1][n+1];\n   for (w = 0; w <= W; w++)\n   {\n    for(i=0;i<=n;i++){\n        if(i==0)\n            K[w][i]=0;\n\n        if(w<wt[i-1] && i!=0)\n            K[w][i]=K[w][i-1];\n\n        if(w>=wt[i-1] && i!=0)\n            K[w][i]=max(K[w][i-1],K[w-wt[i-1]][i-1]+val[i-1]);\n\n       }\n   }\n\n   cout << \"\\n\" << \"Maximum value obtained is : \" << K[W][n] << \"\\n\";\n   int j;\n   for ( j=1; j<=n; j++ ) {\n     if (K[W][j] == K[W][n]) {\n       int w = W;\n       int i = j;\n       while(i>0 && w>0){\n          if (K[w][i] == K[w-wt[i-1]][i-1] + val[i-1]) {\n            cout << \"Item \" << i << \" is in the bag\" << \"\\n\";\n            w = w - wt[i-1];\n            i--;\n          } else {\n            i--;\n          }\n        }\n      cout<< \"\\n\";\n     }\n   }\n\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Possible Combination of Knapsack problem and?\r\n                \r\nAlright quick overview\n\nI have looked into the knapsack problem\n\nhttp://en.wikipedia.org/wiki/Knapsack_problem\n\nand i know it is what i need for my project, but the complicated part of my project would be that i need multiple sacks inside a main sack.\n\nThe large knapsack that holds all the \"bags\" can only carry x amount of \"bags\" (lets say 9 for sake of example). Each bag has different values;\n\n\nWeight \nCost\nSize\nCapacity\n\n\nand so on, all of those values are integer numbers. Lets assume from 0-100.\n\nThe inner bag will also be assigned a type, and there can only be one of that type within the outer bag, although the program input will be given multiple of the same type.\n\nI need to assign a maximum weight that the main bag can hold, and all other properties of the smaller bags need to be grouped by weighted values.\n\n\n\nExample\n\nOuter Bag:\n\n\nCan hold 9 smaller bags\nWeight no more than 98 [Give or take 5 either side]\nMust hold one of each type, Can only hold one of each type at a time.\n\n\nInner Bags:\n\n\nCost, Weighted at 100%\nSize, Weighted at 67%\nCapacity, Weighted at 44%\n\n\n\n\nThe program will be given an input of multiple bags, and then must work out combinations of Smaller Bags to go into the larger bag, there will be multiple solutions depending on the input, and the program would output the best solutions for me.\n\nI am wondering what you guys think the best way for me to approach this would be.\n\nI will be programming it in either Java, or C#. I would love to program it in PHP but i'm afraid the algorithm would be very inefficient for web servers.\n\nThanks for any help you can give\n\n-Zack\n    ", "Answer": "\r\nOkay, well, knapsack is NP-hard so I'm pretty certain this will be NP-hard as well (if it weren't you could solve knapsack by doing this with only one outer bag.)  So for an exactly optimal solution, you're probably going to be able to do no beter than searching all combinations.  So the outline of the program you want will be like\n\n```\n for each possible combination\n do\n   if current combination is better than best previous\n      save current combination as best so far\n   fi\n od\n```\n\n\nand the run time will be exponential.  It sounds, though, like you might be able to get a near solution with dynamic programming.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "I get different value in recursion for knapsack problem\r\n                \r\nI wrote two pieces of code for knapsack problem. The first code gives me the correct answer (which is 16) and the second one doesn't. Is it something wrong with my recursive function?\n\nFirst code (correct answer):\n\n```\npublic class knapsackProblem {\n\n    static int[] weight = {1,2,4,2,5};\n    static int[] value = {5,3,5,3,2};\n    int result = 0;\n\n    // recursive function\n    public int sack(int i, int cap) \n    {\n        //base case\n        if(i<0 || cap == 0)\n        {\n            return 0;\n        } else if(weight[i] > cap)\n        {\n            return sack(i-1, cap);\n        } else\n        {\n            //get maximum value\n            return Math.max(sack(i-1, cap), value[i] + sack(i-1, cap - weight[i]));\n        }\n    }\n\n    public static void main(String[] args) \n    {\n        int capacity = 10;\n        int len = weight.length;\n        knapsackProblem kp = new knapsackProblem();\n        int total = kp.sack(len - 1, capacity);\n        System.out.println(\"sacked array is \" + total);\n    }\n\n}\n```\n\n\nSecond code (incorrect answer):\n\n```\npublic class knapsackProblem {\n\n    static int[] weight = {1,2,4,2,5};\n    static int[] value = {5,3,5,3,2};\n    int result = 0;\n    int tempNO = 0;\n    int tempYES = 0;\n\n    // recursive function\n    public int sack(int i, int cap) \n    {\n        //base case\n        if(i<0 || cap == 0)\n        {\n            return 0;\n        } else if(weight[i] > cap)\n        {\n            return sack(i-1, cap);\n        } else\n        {\n            //no case, move on to next value\n            tempNO = sack(i-1, cap);\n\n            //yes case, add the current value and move on to next value with decreased capacity\n            tempYES = value[i] + sack(i-1, cap - weight[i]);\n\n            //get maximum value\n            return Math.max(tempNO, tempYES);\n        }\n    }\n\n    public static void main(String[] args) \n    {\n        int capacity = 10;\n        int len = weight.length;\n        knapsackProblem kp = new knapsackProblem();\n        int total = kp.sack(len - 1, capacity);\n        System.out.println(\"sacked array is \" + total);\n    }\n\n}\n```\n\n\nThe only difference is that in second code I put the results from recursion into variables before comparing for maximum value.\n\nThanks\n    ", "Answer": "\r\nYour variables are attributes of the class. The recursive calls are modifying those attributes every time, because you're using one single instance of the class to make the calls to the function. Declare the variables inside the method and remove them from the class to make it work. :) \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "create constraint for minimum number of objects selected in knapsack problem\r\n                \r\nI have the optimization problem below.  It's a version of the knapsack problem.  I've adapted the solution for a bounded knapsack problem to a version that allows a range of quantities for the objects.  the quantities are contained in the \"quantities\" array.  when the selection variable takes an inner product with the quantities array it gets the quantities of each object.  I'm able to construct a \"weight_constraint\" for the maximum total quantity I can have in the knapsack.  I would like to also construct a \"min_qty\" which sets a constraint on the minimum quantity of each object that must be selected.  I've tried constructing that constraint with the min_qty as shown below, but I get the \"-inf\" error when I try to run the code.  Does anyone see what the issue is and can you suggest how to solve it?  I've included the arrays used in the problem.\n\ncode:\n\n```\nimport numpy as np\nimport pandas as pd\nfrom time import time\nimport scipy.stats as stats\n\nfrom IPython.display import display # Allows the use of display() for DataFrames\n\n# Pretty display for notebooks\n%matplotlib inline\n\n###########################################\n# Suppress matplotlib user warnings\n# Necessary for newer version of matplotlib\nimport warnings\nwarnings.filterwarnings(\"ignore\", category = UserWarning, module = \"matplotlib\")\n#\n# Display inline matplotlib plots with IPython\nfrom IPython import get_ipython\nget_ipython().run_line_magic('matplotlib', 'inline')\n###########################################\n\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\nimport seaborn as sns\n\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_score\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.decomposition import PCA\n\n\n\nfrom sklearn.datasets import make_classification\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nimport numpy as np\nimport cvxpy\n\nfrom collections import namedtuple    \n\nselection = cvxpy.Variable(len(weights), boolean=True)\n\n\n    min_qty= quantities * selection >= 1\n\n\n    weight_constraint = cvxpy.sum(selection * quantities.T, axis=0) <= P\n\n    # Our total utility is the sum of the item utilities\n    total_utility = utilities * selection\n\n    # We tell cvxpy that we want to maximize total utility \n\n    knapsack_problem = cvxpy.Problem(cvxpy.Maximize(total_utility), [weight_constraint,min_qty])\n\n    # Solving the problem\n    # maximum netsales\n    knapsack_problem.solve(solver=cvxpy.GLPK_MI)\n```\n\n\nerror:\n\n```\n-inf\n```\n\n\ninput data:\n\n```\nprint(weights)\n\n[ 122.76        133.92        145.08        156.24        167.4\n  178.56        189.72        200.88        212.04        223.2\n  234.36        245.52        256.68        267.84        279.\n  290.16        301.32        312.48        323.64        334.8\n  345.96        357.12        368.28        379.44        390.6\n  401.76        412.92        424.08        435.24        446.4\n  457.56        468.72        479.88        491.04        502.2\n  513.36        524.52        341.          354.64        368.28\n  381.92        395.56        409.2         422.84        436.48\n  450.12        463.76        477.4         491.04        504.68\n  518.32        531.96        545.6         559.24        572.88\n  586.52        600.16        613.8         627.44        641.08\n   19.06918919   38.13837838   57.20756757   76.27675676   95.34594595\n  114.41513514  133.48432432  152.55351351  171.6227027   190.69189189\n  209.76108108  228.83027027  247.89945946  266.96864865  286.03783784\n  305.10702703  324.17621622  343.24540541  362.31459459  381.38378378\n  400.45297297  419.52216216  438.59135135  457.66054054  476.72972973\n  495.79891892  514.86810811  533.9372973   553.00648649  572.07567568\n  591.14486486  610.21405405  629.28324324  648.35243243  667.42162162\n  686.49081081  705.56        724.62918919  743.69837838  762.76756757\n  781.83675676  800.90594595  819.97513514  839.04432432  858.11351351\n  877.1827027   896.25189189  617.22        640.08        662.94\n  685.8         708.66        731.52        754.38        777.24\n  800.1         822.96        845.82        868.68        891.54\n  914.4         937.26        960.12        982.98       1005.84\n 1028.7        1051.56       1074.42        845.82        868.68\n  891.54        914.4         937.26        960.12        982.98\n 1005.84       1028.7        1051.56       1074.42        136.4\n  150.04        163.68        177.32        190.96        204.6\n  218.24        231.88        245.52        259.16        272.8\n  286.44        300.08        313.72        327.36        341.\n  354.64        368.28        381.92        395.56        409.2\n  422.84        436.48        450.12        463.76        477.4\n  491.04        504.68        518.32        531.96        545.6\n  559.24        572.88        586.52        600.16        613.8\n  627.44        641.08      ]\n\n\n\nprint(utilities)\n\n[ 185.56723112  202.43697941  219.30672769  236.17647597  253.04622426\n  269.91597254  286.78572082  303.65546911  320.52521739  337.39496568\n  354.26471396  371.13446224  388.00421053  404.87395881  421.74370709\n  438.61345538  455.48320366  472.35295195  489.22270023  506.09244851\n  522.9621968   539.83194508  556.70169336  573.57144165  590.44118993\n  607.31093822  624.1806865   641.05043478  657.92018307  674.78993135\n  691.65967963  708.52942792  725.3991762   742.26892449  759.13867277\n  776.00842105  792.87816934  584.24141876  607.61107551  630.98073227\n  654.35038902  677.72004577  701.08970252  724.45935927  747.82901602\n  771.19867277  794.56832952  817.93798627  841.30764302  864.67729977\n  888.04695652  911.41661327  934.78627002  958.15592677  981.52558352\n 1004.89524027 1028.26489703 1051.63455378 1075.00421053 1098.37386728\n   43.32095244   86.64190488  129.96285732  173.28380976  216.6047622\n  259.92571464  303.24666708  346.56761952  389.88857196  433.2095244\n  476.53047684  519.85142928  563.17238172  606.49333416  649.8142866\n  693.13523904  736.45619148  779.77714392  823.09809636  866.4190488\n  909.74000124  953.06095368  996.38190612 1039.70285856 1083.023811\n 1126.34476344 1169.66571588 1212.98666832 1256.30762076 1299.6285732\n 1342.94952564 1386.27047808 1429.59143052 1472.91238296 1516.23333539\n 1559.55428783 1602.87524027 1646.19619271 1689.51714515 1732.83809759\n 1776.15905003 1819.48000247 1862.80095491 1906.12190735 1949.44285979\n 1992.76381223 2036.08476467  898.51767735  931.79610984  965.07454233\n  998.35297483 1031.63140732 1064.90983982 1098.18827231 1131.46670481\n 1164.7451373  1198.02356979 1231.30200229 1264.58043478 1297.85886728\n 1331.13729977 1364.41573227 1397.69416476 1430.97259725 1464.25102975\n 1497.52946224 1530.80789474 1564.08632723 1171.06369416 1202.71406427\n 1234.36443438 1266.0148045  1297.66517461 1329.31554472 1360.96591483\n 1392.61628495 1424.26665506 1455.91702517 1487.56739528  224.85858124\n  247.34443936  269.83029748  292.31615561  314.80201373  337.28787185\n  359.77372998  382.2595881   404.74544622  427.23130435  449.71716247\n  472.20302059  494.68887872  517.17473684  539.66059497  562.14645309\n  584.63231121  607.11816934  629.60402746  652.08988558  674.57574371\n  697.06160183  719.54745995  742.03331808  764.5191762   787.00503432\n  809.49089245  831.97675057  854.4626087   876.94846682  899.43432494\n  921.92018307  944.40604119  966.89189931  989.37775744 1011.86361556\n 1034.34947368 1056.83533181]\n\n\n\nprint(quantities)\n\n\n\n[[ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34\n  35 36 37 38 39 40 41 42 43 44 45 46 47  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0 25 26 27 28 29 30 31 32 33 34 35\n  36 37 38 39 40 41 42 43 44 45 46 47  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  1  2  3  4  5  6  7  8  9 10 11 12\n  13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\n  37 38 39 40 41 42 43 44 45 46 47  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0 27 28 29 30 31 32 33 34 35 36 37 38 39\n  40 41 42 43 44 45 46 47  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0 37 38 39 40 41 42 43 44 45 46 47  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0]\n [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 10 11 12 13 14\n  15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38\n  39 40 41 42 43 44 45 46 47]]\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "function for solving 0/1 knapsack problem using Brute-force recursive solution [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 1 year ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying this code for solving 0/1 knapsack problem using Brute-force recursive solution, but it keeps running with no output at all when I make the size of the problem(profit and weight arrays) 100. if any one can tell me why? and how to solve it.\nPlease if any one can tell me when to find trusted pseudocodes and codes for 0/1 knapsack problem.\n```\n#include <iostream>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n//Return the maximum value that can be put in a knapsack of capacity W\nint knapsackRecursive(int profits[], int profitsLength, int weights[], int capacity, int currentIndex) {\n    // Base Case \n    if (capacity <= 0 || currentIndex >= profitsLength || currentIndex < 0)\n        return 0;\n\n    //If weight of the nth item is more than knapsack capacity W, then \n    // this item cannot be included in the optimal solgurion\n    int profit1 = 0;\n    if (weights[currentIndex] <= capacity)\n        profit1 = profits[currentIndex] + knapsackRecursive(profits, profitsLength, weights, capacity - weights[currentIndex], currentIndex + 1);\n\n    int profit2 = knapsackRecursive(profits, profitsLength, weights, capacity, currentIndex + 1);\n\n    //Return the maximum of two cases:\n    //(1) nth item included\n    //(2) not included\n\n    return max(profit1, profit2);\n}\n\nint knapSack(int profits[], int profitsLength, int weights[], int capacity) {\n    return knapsackRecursive(profits, profitsLength, weights, capacity, 0);\n\n}\n\n\nint main() {\n    int profits[100];\n    int weights[100];\n    int capacity = 300;\n    srand(time(0));\n\n\n    clock_t startTime;\n    clock_t endTime;\n    clock_t timeTaken = 0;\n\n    for (int i = 0; i < 20; i++) {      //repeat the knapSack 20 times\n\n        for (int j = 0; j < 100; j++) {\n            profits[j] = 1 + (rand() % 100);\n            weights[j] = 1 + (rand() % 100);\n        }\n        startTime = clock();\n        knapSack(profits, 100, weights, capacity);\n        endTime = clock();\n        timeTaken = timeTaken + (endTime - startTime);      //compute the total cpu time \n    }\n\n    cout << \"The avearage of the time taken is\" << ((float)timeTaken / CLOCKS_PER_SEC) / 20 << \" seconds\";\n\n\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nSetting the size to 100 just makes it take too long. Exponential running times are no joke.\nI have no idea if your code is correct but just looking at it I can see that the only arguments to the recursive call that ever change are ```\ncapacity```\n and ```\ncurrentIndex```\n so it is easy to apply memoization in your code, which will be a huge speed-up. Basically memoization just means re-using previously computed results by storing them in a table rather than re-computing every time.\nCode below:\n\n```\n#include <iostream>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <functional>\n\nusing key_t = std::tuple<int, int>;\n\nstruct tuple_hash_t  {\n    std::size_t operator()(const key_t& k) const {\n        return std::hash<int>{}(std::get<0>(k) ^ std::get<1>(k)); // or use boost::hash_combine\n    }\n};\n\nusing memoization_tbl = std::unordered_map<std::tuple<int, int>, int, tuple_hash_t>;\n\n//Return the maximum value that can be put in a knapsack of capacity W\nint knapsackRecursive(memoization_tbl& tbl, int profits[], int profitsLength, int weights[], int capacity, int currentIndex) {\n\n    // Base Case \n    if (capacity <= 0 || currentIndex >= profitsLength || currentIndex < 0)\n        return 0;\n\n    // just return the memoized call if we already have a result...\n    auto iter = tbl.find(key_t(capacity, currentIndex));\n    if (iter != tbl.end()) {\n        return iter->second;\n    }\n\n    //If weight of the nth item is more than knapsack capacity W, then \n    // this item cannot be included in the optimal solgurion\n    int profit1 = 0;\n    if (weights[currentIndex] <= capacity)\n        profit1 = profits[currentIndex] + knapsackRecursive(tbl, profits, profitsLength, weights, capacity - weights[currentIndex], currentIndex + 1);\n\n    int profit2 = knapsackRecursive(tbl, profits, profitsLength, weights, capacity, currentIndex + 1);\n\n    //Return the maximum of two cases:\n    //(1) nth item included\n    //(2) not included\n\n    auto result = std::max(profit1, profit2);\n    tbl[key_t(capacity, currentIndex)] = result;\n\n    return result;\n}\n\nint knapSack(int profits[], int profitsLength, int weights[], int capacity) {\n    memoization_tbl tbl;\n    return knapsackRecursive(tbl, profits, profitsLength, weights, capacity, 0);\n}\n\nint main() {\n    int profits[100];\n    int weights[100];\n    int capacity = 300;\n    srand(time(0));\n\n    for (int j = 0; j < 100; j++) {\n        profits[j] = 1 + (rand() % 100);\n        weights[j] = 1 + (rand() % 100);\n    }\n\n    std::cout << knapSack(profits, 100, weights, capacity) << \"\\n\";\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple optimal solutions for 0/1 Knapsack problem\r\n                \r\nA 0/1 knapsack problem with a maximum capacity constraint can have more than one optimal solution yielding the same profit but with/without the same capacity. How can we generate the set of all optimal soultions from the dp matrix.\nFor example;\n```\nCapacity [4, 2, 5, 2]\nValue [10, 4, 10, 4]\nMaximum capacity: 7\nSelected: 1,2 \nTotal Value: 14\nDP matrix:\n[[0, 0, 0, 0, 10, 10, 10, 10],\n [0, 0, 4, 4, 10, 10, 14, 14],\n [0, 0, 4, 4, 10, 10, 14, 14],\n [0, 0, 4, 4, 10, 10, 14, 14]]\n```\n\nHere (1,2),(1,4),(2,3) and (3,4) gives the same profit, but usual backtracking from bottom right element in dp matrix will give (1,2) as the solution. How can we find all such combinations?\n    ", "Answer": "\r\nYou can find all solution, but it could become very inefficient (since there could be exponential number of optimal solutions)\nYou need to go back on the DP matrix from end, and \"spawn\" a new branch everytime you encounter a valid route (basically, do a DFS on the matrix, where nodes are cells, and edges are valid transitions between them, while allowing repeating already visited nodes to discover all paths).\nPseudo code:\n```\n// i, j are indices of current element\n// so_far is the list holding the current valid solution\nFindSolutions(i, j, so_far):\n  // Stop clause: Check if this is the last element added as a valid solution\n  if j == 0:\n    so_far.append(i)\n    yield_copy_of(so_far)\n    so_far.remove_last()\n  for next_item in range(0, i):\n    // This checks if you could move from next_item to current state using i\n    // no boundary condition here, you should probably check it\n    if DP[next_item][j-weights[i]] + value[i] == DP[i][j]:\n      so_far.append(i)\n      FindSolutions(next_item, j-weights[i], so_far)\n      so_far.remove_last()\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "VB.NET - Genetic Algotithm - Knapsack Problem\r\n                \r\nI have been working on the Knapsack problem using genetic algorithms. But I have run into a few difficulties...\n\nFirst off the user generates a data set which is stored in a text document. From there I read the data in to the program. \n\nI do fine getting the program to calculate fitness values, select parents, produce children, then mutate the children. But it for some reason only works when I have a low population. My program will consistently evolve when I have a low population, but is very inconsistent when I have a higher population.\n\nFor Example: When I have a population of around 10-200 the genetic algorithm runs flawlessly. But when I get to higher populations (around 300+), I will click run and nothing happens. Then I restart the program and use the same exact dataset and the program executes successfully.\n\nI am not sure which part of my code is causing the problem, so If you need a piece of example code please tell me which part of code you would like (Parent Selection, Loading Data Set, etc).\n\nThanks Alot!\n    ", "Answer": "\r\nI guess there might be three reasons for that. \n\n1) a bug in your code\n\nThis should be relatively straightforward to eliminate. Try writing some tests that check if particular parts of your program run correctly (e.g. Parent Selection, etc.). Try testing them against some small examples you can figure out on a piece of paper yourself. \n\n2) out of memory problem - a mentioned by btreat\n\n3) some algorithmic quirk \n\nThis will be more difficult to fight. I am just guessing, so I might be wrong, but I've seen algorithms that drastically change their behaviour when problem size exceeds some threshold. Not likely, but not impossible either. Here you could just see if slowly increasing the population size you can see a sudden shift in running times.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Ordered Knapsack Problem Correctness/Proof\r\n                \r\nA thief is given the choice of ```\nn```\n objects to steal, but only has one knapsack with a capacity of\ntaking ```\nM```\n weight. Each object i has weight ```\nw_i```\n, and profit ```\np_i```\n. Suppose he also knows the following:\nthe order of these items when sorted by increasing weight is the same as their order when sorted\nby decreasing value. Give a greedy algorithm to find an optimal solution to this variant of the\nknapsack problem. Prove the correctness and running time.\nSo the greedy algorithm I came up with was to sort the items based off of increasing weight which is also decreasing value. This means that the price per weight is in decreasing order. So the thief can take the highest valued item until the weight ```\n>= M```\n. The running time would be ```\nO(n log n)```\n since sorting takes ```\nO(n log n)```\n and iterating through the list takes ```\nO(n)```\n. The part I am stuck on is the proof for correctness. Here is my proof so far:\nSuppose there is an instance such that the solution stated above (referred to as GA) is not optimal. Let the optimal solution be referred to as OS, and the items taken by OS be sorted in increasing value. Since OS is more optimal than GA, then the profit earned from GA is less than or equal to the profit earned from OS. Since GA takes the item with the highest profit/weight ratio, then the first element, ```\ni```\n, must be greater than or equal to the first element of OS. Because OS is more optimal, then there must exist a ```\ni```\n that is greater than or equal to an item j in the set of GA. But because GA and OS are done on the same set, and GA is always taking the item with the highest profit/weight, there cannot be a ```\ni```\n in OS that is greater than a ```\nj```\n in GA.\nCan anyone help with the proof? Thanks\n    ", "Answer": "\r\nYour approach to the solution is valid and the reasoning on the running time is correct. In the sequel, suppose that the input is \"de-trivialized\" in the sense that every occurring obejct actually fits into the knapsack and that it is impossible to select the entire input.\nThe sorting of the items that is generated by the sorting is both\n\ndecreasing in value\nincreasing weight\n\nwhich makes it a special case of the general knapsack problem. The argumentation for the proof of correctnes is as follows. Let ```\ni'```\n denote the breaking index which is the index of the first item in the sorted sequence which is rejected by the greedy algorithm. For clarity, call the corresponding object the breaking object. Note that\n```\nw_j > w_i' for each j > i'\n```\n\nholds, which means that that the greedy algorithm also rejects every object succeeding the breaking object (as it does not fit into the knapsack, just like the breaking object).\nIn total, the greedy algorithm selects a prefix of the sorted sequence; we aim at showing that any optimal solution (which we consider fixed in the sequel) is the same prefix.\nNote that the optimal solution, as it it optimal, does not leave space for an additional object.\nAiming at a contradiction, let ```\nk```\n be the minimal index which occurs in the greedy solution but not in the optimal solution. As it is impossible to select object ```\nk```\n additionally into the optimal solution, there must (via minimality of ```\nk```\n) be some item in the optimal solution with an index\n```\nk' > k\n```\n\nwhich permits an exchange of items in the optimal solution. As\n```\nw_k < w_k' and p_k > p_k'\n```\n\nhold, object ```\nk'```\n can be replaced by object ```\nk```\n in the optimal solution, which yields a solution with profit larger than the one of the optimal solution, which is a contradiction to its optimality.\nHence, there is no item in the greedy solution which is missing in the optimal solution, which means that the greedy solution is a subset of the optimal solution. On the other hand, the greedy solution is maximal with respect to inclusion, which means that the optimal solution cannot contain an item which is missing in the greedy solution.\nNote that the greedy algorithm als is useful for the general knapsack problem; taking the better one of the greedy solution and an item with maximum profit yields an approximation algorithm with ratio 2.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why does the Knapsack Problem DP using tabular method discretize the capacity?\r\n                \r\nI am trying to learn different aspect of DP and the first thing that pops on google search for \"Knapsack 0-1\" is this\nhttps://www.geeksforgeeks.org/python-program-for-dynamic-programming-set-10-0-1-knapsack-problem/\n```\n# A Dynamic Programming based Python \n# Program for 0-1 Knapsack problem\n# Returns the maximum value that can \n# be put in a knapsack of capacity W\ndef knapSack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n  \n    # Build table K[][] in bottom up manner\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i-1] <= w:\n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w])\n            else:\n                K[i][w] = K[i-1][w]\n  \n    return K[n][W]\n  \n# Driver program to test above function\nval = [60, 100, 120]\nwt = [10, 20, 30]\nW = 50\nn = len(val)\nprint(knapSack(W, wt, val, n))\n  \n# This code is contributed by Bhavya Jain\n```\n\nI stopped at the first line. Why does the code create a matrix of n by W discretizing W with one unit? Why one was chosen? What if W is very big (example W=10000000000) ? Wouldn't the matrix overflow the memory ? What if the capacity W is a decimal number for example 50.6?\nStrangely, the first video tutorial that pops on youtube shows the same approach https://www.youtube.com/watch?v=nLmhmB6NzcM\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack problem - Need solution for float/double values\r\n                \r\nLooking for solution/code for 0/1 Knapsack problem where the input weights and values are float/double instead of int.\nEg: \ndouble val[] = { 8.2, 6.8, 6.5, 6.2, 5.9, 5.5, 5.4, 5.2, 5.1, 5 };\ndouble wt[] = { 13, 7.3, 6.7, 10.7, 7, 8.5, 12.1, 8, 10.7, 7.5 };\n    ", "Answer": "\r\nFirst of all, if only values (but not weights) are doubles then it should be no problem (assuming you are using the typical 2D table method).\nIf we have weights as doubles then one workaround is to treat these doubles as integers, by multiplying all weights by 10 to the power of (the min number of digits  needed to make all weights integers), which is 1 in your example because all numbers use at most one digit for precision.\nThe overall time complexity of this solution becomes O(N.C.10^(D)) where N is the number of items, C is the max possible capacity, and D is the max number of digits needed as precision.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is it better to use genetic algorithm to solve the 0-1 Knapsack problem?\r\n                \r\nThe Knapsack problem is a combinatorial optimization problem where one has to maximize the bene t of objects in a knapsack without exceeding its capacity. We know that there are many ways to solve this problem, genetic algorithm, dynamic programmming, and greedy method. I want to know what is the advantage and disadvantage to use the genetic algorithm comparing with dynamic programming? Space complexity, time complexity, and optimality?\n    ", "Answer": "\r\nSo in order to answer this, it is important to consider what you think is the most important: Speed or Accuracy\n\nGenetic algorithms do not guarantee finding the most optimal solution, however, they typically run very quickly. \n\nSome quick descriptions of a Genetic Algorithm might yield:\n\n\nIt is an estimation function and does not guarantee finding the globally optimal solution\nIt typically runs very fast (both in memory usage and complexity)\nActual calculations are hard, since genetic algorithms are typically problem specific and chaotic in nature. A good base for what its complexity might look like: \n```\nO( O(Fitness) * (O(mutation) + O(crossover)))```\n\n\n\n\nHowever, Dynamic Programming does guarantee to find the most optimal solution, granted with a much longer run time. Some quick descriptions of Dynamic Programming might yield:\n\n\nIt is an exact function -- guarantees convergence on the most globally optimal solution\nHigh memory usage and a very long run time\nComplexity for knapsack 01 problem is something like: ```\nO(numItems * knapsackCapacity)```\n, and memory complexity like ```\nO(knapsackCapacity)```\n (credits to this post for that)\n\n\nIf you are asking what is preferred, that is subject specific. If you want a good enough guess quickly, GA is probably the way to go. But if you need a guaranteed and verifiable solution, DP is the way to go.\n\nThis should satisfy a basic comparison.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What temporal formula to use for knapsack problem?\r\n                \r\nIn \"Practical TLA+\" by Hillel Wayne, Chapter 3 goes over an implementation of the Knapsack Problem in PlusCal.\nAlthough I understand the implementation, I don't understand how to run it. He mentions:\n\nSince we’re adding a PlusCal spec, remember to remove “evaluate constant\nexpression” and set “What is the behavior spec?” to “Temporal formula.” When you run\nthis, you should get something like what is shown in Figure 3-3.\n\n\nWhat's the \"Temporal Formula\"? Where is it in the Model menu? Alternatively, how would I run this using the VSCode TLA+ plugin? I feel like I missed some details I need to actually run/verify this specification.\n    ", "Answer": "\r\nIt's under \"model overview > what is the behavior spec\".\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Algorithm analysis for knapsack problem vs sorting algorithm\r\n                \r\nI am learning anaysis of algorithms and design techniques in algorithms. While studying knapsack problem it is mentioned that though knapsack is O(nW) where n is number of items and W is weight. It is non polynomial as explained below.\n\n\n  The size of input is log(W) bits for the weight (and O(n) for \"value\"\n  and \"weight\" arrays).\n  \n  So, the input size of weight is j = log(W) (and not mere W). So, W =\n  2ʲ (as binary is used).\n  \n  The final complexity is O(n * W)\n  \n  This O(n * W) can be rewritten as O(n * 2^j), which exponential in the\n  size of the input.\n\n\nWith above argument, all algorithms for example sorting algorithm is O(nlogn) which also becomes exponential as\n\"n\" is expressed as 2^j.\n\nI am getting confused.\n    ", "Answer": "\r\nDetermining whether or not an algorithm runs in \"polynomial time\" requires a stricter definition of \"input size\" than is required for describing the running time of an algorithm. For example, the following algorithm runs in O(n) time, but not in polynomial time:\n\n```\ncount_down(n)\n    i = n\n    while i > 0 do\n        i--\n```\n\n\nThe loop iterates n times and does O(1) work* per iteration, where n is the input number, so its time complexity is O(n). In most situations there is no problem with saying that this algorithm takes O(n) time.\n\nHowever, for the purposes of whether or not an algorithm runs in polynomial time, what we mean is whether its running time is bounded by a polynomial function of the input size, usually measured in bits. The number of bits required to represent the number n is about log₂ n, so that's the input size, and O(n) is not bounded by a polynomial in log₂ n.\n\nThis doesn't apply for sorting algorithms, since for those n means the length of an array rather than the magnitude of a number. It is not possible to represent an array of length n using only O(log n) bits; it takes O(n) bits. So the running time O(n log n) or O(n²) is bounded by a polynomial function of the input size in this case, because the input size is n instead of log₂ n. This implies that such sorting algorithms do run in polynomial time.\n\n*Caveat: decrementing an integer takes O(1) amortized time if the integer is modified in place. In a language like Python where integers are immutable objects, this takes O(log n) time because of the need to copy that many bits to a new object.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving 0-1 knapsack problem using memoization\r\n                \r\nAlthough I managed to get the correct output for a 0-1 knapsack problem, I'm still partially confused about how the code functions.\nThis is my code:\n```\nmemo = {} \ndef knapsack(weights, prices, capacity, i, memo):\n  if capacity <= 0 or i >= len(weights): \n    return 0\n  \n  if (capacity, i) in memo: \n    return memo[(capacity, i)]\n  \n  if weights[i] > capacity: \n    memo[(capacity, i)] = knapsack(weights, prices, capacity, i + 1, memo) \n    return memo[(capacity, i)]\n  \n  memo[(capacity, i)] = max(prices[i] + knapsack(weights, prices, capacity - weights[i], i + 1, memo), knapsack(weights, prices, capacity, i + 1, memo)) \n  return memo[(capacity, i)]\n\nprint(knapsack([1,2,4,6], [4,2,4,7], 7, 0, memo))\n```\n\nWhen using memoization, the data for previously solved cases are stored in memo, however, there are multiple cases with the same key-(capacity, i)  but different outputs\nTake for example ```\nc=1```\n, ```\ni=3```\n (the 2 yellow circles)\n\nHence my question, won't the data with the same key in memo overwrite each other and thus affecting the optimal output?\nI tried to print out the memo dict but still couldn't understand what's going on.\n```\nmemo = {\n    (4, 3): 0,\n    (4, 2): 4,\n    (2, 3): 0,\n    (6, 3): 7,\n    (6, 2): 7,\n    (6, 1): 7,\n    (1, 3): 0,\n    (5, 3): 0,\n    (5, 2): 4,\n    (3, 3): 0,\n    (7, 3): 7,\n    (7, 2): 7,\n    (7, 1): 7,\n    (7, 0): 11,\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem with a total item limit in Python\r\n                \r\nI'm trying to solve a knapsack problem with Python with extra requirements.  I've found lots of knapsack code and math explanations but I can't find anything that quite fits what I'm trying to do.  To be honest, the math information is way over my head, so that's why I'm asking here.  I would be happy to learn to use any available library, as long as its free.  Numpy, pandas, ortools, etc.\nLet's say I have $20 and I want to buy 6 individual beers for a mix-and-match six pack container.  Each beer has a name, a type, a price (knapsack-like \"weight\"), and a review score (knapsack-like \"value\").\nI want to buy the highest combination of review scores while also following these rules:\n\nSpend less than $20 total\nBuy 6 beers exactly\nI also want to be sure I always get 2 Lager, 1 Stout, and 1 Amber.  The other 2 beers can be anything but all 6 beers have to be unique.\n\nThis is just a small list of data as an example. I know brute force might work here but my real data is much larger and my first attempts (before discovering this is a common problem) with brute force never finished, and would take way too long to find a solution.  So I'm looking for something better than brute force.\n```\ncapacity = 6\nmoney = 20\n\nbeers = [ \n  {\"name\":\"Beer1\",  \"type\":\"Lager\",   \"price\":3.50, \"score\":4.1},\n  {\"name\":\"Beer2\",  \"type\":\"Porter\",  \"price\":4.90, \"score\":4.5},\n  {\"name\":\"Beer3\",  \"type\":\"IPA\",     \"price\":3.70, \"score\":4.0},\n  {\"name\":\"Beer4\",  \"type\":\"Stout\",   \"price\":3.20, \"score\":4.2},\n  {\"name\":\"Beer5\",  \"type\":\"Amber\",   \"price\":3.80, \"score\":3.9},\n  {\"name\":\"Beer6\",  \"type\":\"Stout\",   \"price\":2.70, \"score\":2.9},\n  {\"name\":\"Beer7\",  \"type\":\"IPA\",     \"price\":2.50, \"score\":3.2},\n  {\"name\":\"Beer8\",  \"type\":\"Pilsner\", \"price\":3.10, \"score\":4.0},\n  {\"name\":\"Beer9\",  \"type\":\"Amber\",   \"price\":3.00, \"score\":4.1},\n  {\"name\":\"Beer10\", \"type\":\"Porter\",  \"price\":2.80, \"score\":3.3},\n  {\"name\":\"Beer11\", \"type\":\"IPA\",     \"price\":3.70, \"score\":4.0},\n  {\"name\":\"Beer12\", \"type\":\"Lager\",   \"price\":3.20, \"score\":4.2},\n  {\"name\":\"Beer13\", \"type\":\"Amber\",   \"price\":3.30, \"score\":3.5},\n  {\"name\":\"Beer14\", \"type\":\"Stout\",   \"price\":2.90, \"score\":2.8},\n  {\"name\":\"Beer15\", \"type\":\"Lager\",   \"price\":3.20, \"score\":4.2},\n]\n```\n\nThe desired output would be a list of the names that were selected for the solution, like this: ```\n[\"Beer12\",\"Beer14\",\"Beer13\",\"Beer1\",\"Beer7\",\"Beer6\"]```\n\nThanks for looking.  I hope we can find a solution, for me and for anyone else trying to solve a similar problem in the future.\n    ", "Answer": "\r\nIt could look like the following example.\nWe:\n\nuse cp-sat as solver\nscale prices and scores to be able to use integral domains\n\ncp-sat needs this\n\n\n\nMight contain a bug as i didn't check it much, but it's more about the general concepts anyway. It also indicates the modelling-power of the solver.\nCode\n```\nfrom ortools.sat.python import cp_model\n\n# DATA\ncapacity = 6\nmoney = 20\nbeers = [ \n  {\"name\":\"Beer1\",  \"type\":\"Lager\",   \"price\":3.50, \"score\":4.1},\n  {\"name\":\"Beer2\",  \"type\":\"Porter\",  \"price\":4.90, \"score\":4.5},\n  {\"name\":\"Beer3\",  \"type\":\"IPA\",     \"price\":3.70, \"score\":4.0},\n  {\"name\":\"Beer4\",  \"type\":\"Stout\",   \"price\":3.20, \"score\":4.2},\n  {\"name\":\"Beer5\",  \"type\":\"Amber\",   \"price\":3.80, \"score\":3.9},\n  {\"name\":\"Beer6\",  \"type\":\"Stout\",   \"price\":2.70, \"score\":2.9},\n  {\"name\":\"Beer7\",  \"type\":\"IPA\",     \"price\":2.50, \"score\":3.2},\n  {\"name\":\"Beer8\",  \"type\":\"Pilsner\", \"price\":3.10, \"score\":4.0},\n  {\"name\":\"Beer9\",  \"type\":\"Amber\",   \"price\":3.00, \"score\":4.1},\n  {\"name\":\"Beer10\", \"type\":\"Porter\",  \"price\":2.80, \"score\":3.3},\n  {\"name\":\"Beer11\", \"type\":\"IPA\",     \"price\":3.70, \"score\":4.0},\n  {\"name\":\"Beer12\", \"type\":\"Lager\",   \"price\":3.20, \"score\":4.2},\n  {\"name\":\"Beer13\", \"type\":\"Amber\",   \"price\":3.30, \"score\":3.5},\n  {\"name\":\"Beer14\", \"type\":\"Stout\",   \"price\":2.90, \"score\":2.8},\n  {\"name\":\"Beer15\", \"type\":\"Lager\",   \"price\":3.20, \"score\":4.2},]\n\n# PREPROCESSING\nn_beers = len(set([entry['name'] for entry in beers]))\n\n# MODEL\nmodel = cp_model.CpModel()\nx_select = [model.NewBoolVar('') for i in range(n_beers)]\n\n# select exactly \"capacity\"\nmodel.Add(sum(x_select) == capacity)\n\n# spend not too much -> # ASSUMPTION: * 100 makes all the values integral\nmodel.Add(sum([x_select[i] * int(round(beers[i]['price']*100)) for i in range(n_beers)]) <= money * 100)\n\n# >= 2 lagers needed\nmodel.Add(sum([x_select[i] for i in range(n_beers) if beers[i]['type'] == 'Lager']) >= 2)\n\n# >= 1 Stout needed\nmodel.Add(sum([x_select[i] for i in range(n_beers) if beers[i]['type'] == 'Stout']) >= 1)\n\n# >= 1 Amber needed\nmodel.Add(sum([x_select[i] for i in range(n_beers) if beers[i]['type'] == 'Amber']) >= 1)\n\n# maximize sum of scores selected -> # ASSUMPTION: * 10 makes all the values integral\nmodel.Maximize(sum([x_select[i] * int(round(beers[i]['score']*10)) for i in range(n_beers)]))\n\n# SOLVE\nsolver = cp_model.CpSolver()\nsolver.parameters.log_search_progress = True\nmodel.Proto().objective.scaling_factor = -1./10         # inverse scaling for solver logging output\nstatus = solver.Solve(model)\n\nif status == cp_model.OPTIMAL:\n  selected = [i for i in range(n_beers) if solver.Value(x_select[i]) == 1]\n  print(\"\\n\".join([str(beers[i]) for i in selected]))\n```\n\nTrimmed Output\n```\nstatus: OPTIMAL\nobjective: 24.8\nbest_bound: 24.8\nbooleans: 8\nconflicts: 0\nbranches: 19\npropagations: 20\ninteger_propagations: 42\nrestarts: 17\nlp_iterations: 4\nwalltime: 0.0689822\nusertime: 0.0689823\ndeterministic_time: 2.03413e-05\nprimal_integral: 1.69201e-05\nTotal cuts added: 3 (out of 4 calls) worker: ''\n  - num simplifications: 0\n  - added 1 cut of type 'CG'.\n  - added 1 cut of type 'MIR_1'.\n  - added 1 cut of type 'MIR_2'.\n{'name': 'Beer1', 'type': 'Lager', 'price': 3.5, 'score': 4.1}\n{'name': 'Beer4', 'type': 'Stout', 'price': 3.2, 'score': 4.2}\n{'name': 'Beer8', 'type': 'Pilsner', 'price': 3.1, 'score': 4.0}\n{'name': 'Beer9', 'type': 'Amber', 'price': 3.0, 'score': 4.1}\n{'name': 'Beer12', 'type': 'Lager', 'price': 3.2, 'score': 4.2}\n{'name': 'Beer15', 'type': 'Lager', 'price': 3.2, 'score': 4.2}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is the difference between multidimensional knapsack problem and 0/1 multidimensional knapsack problem?\r\n                \r\nWhat is different between multidimensional knapsack algorithm (MKP) and 0/1 multidimensional knapsack (0/1 KP) algorithm? And what is goal in MKP? And how can I solve it?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem sorting the array based on profit per unit weight\r\n                \r\nSo i have written a code for knapsack problem but i don't know how am i supposed to sort the profit(p) and weight(p) arrays based on the profit per unit weight (arrange array)?Also any other way of approaching the problem i appreciated please post below\n\n```\n#include<iostream>\nusing namespace std;\n\nvoid knapsack(float w[],int m,int n){\n    float result[n];//this array holds the final result\n    int i;\n    for(i=0;i<n;i++){\n        result[i]=0.0;\n    }\n    int rem=m;\n    int j;\n    for(j=0;j<n;j++){\n        if(w[j]>rem){\n            break;\n        }\n        else{\n            result[j]=1;\n            rem=rem-w[j];\n        }\n    }\n    if(j<n){\n        result[j]=rem/w[j];\n    }\n    for(int k=0;k<n;k++){\n        cout<<result[k]<<\" \";\n    }\n}\n\nint main(){\n    int n,m;\n    cout<<\"Enter the number of items\"<<endl;\n    cin>>n;\n    cout<<\"Enter capacity of bag\"<<endl;\n    cin>>m;\n    cout<<\"Enter the profits\"<<endl;\n    float p[n],w[n];\n    for(int i=0;i<n;i++){\n        cin>>p[i];//this array holds the profit of each item\n    }\n    cout<<\"Enter the respective weights\"<<endl;\n    for(int i=0;i<n;i++){\n        cin>>w[i];//this array holds the respective weights of items\n    }\n    float arrange[n];//This array contains profit per unit weight ratio\n    for(int i=0;i<n;i++){\n        arrange[i]=p[i]/w[i];\n        cout<<arrange[i]<<\" \";\n    }\n    cout<<endl;\n    knapsack(w,m,n);\n\n}\n```\n\n    ", "Answer": "\r\nAs @Cool Dudde suggested switching from (struct of arrays) to array of structs could make the code easier to understand.\n\nBut then you can go further and adapt knapsack to the new array of struct:\n\n\nchange ```\nknapsack```\n to work with iterators instead of arrays (pointers are randome-access iterators, so you could test your changes with little change to the rest of the code). The signatur of ```\nknapsack```\n will look somethink like this:\n\n```\ntemplate<class It>\nvoid knapsack(It begin, It end, int m);\n```\n\nuse an ```\nstruct```\n/```\nclass```\n Item with the properties ```\nweight```\n and ```\nprice```\n and maybe some identifier (could be an int or string). I think this much cleaner then using an ```\nint[2]```\n.\nthen use ```\nstd::vector<Item> items```\n and the solution from @Cool Dudde:\n\n```\nstd::sort(items.begin(), items.end(), [](const Item& a, const Item& b) {return (a.price/a.weight) < (b.price/b.weight);});\n```\n\n```\nitems.begin()```\n will give you not a suitable iterator for ```\nknapsack```\n, but you could use an transform-iterator to access the weight in items. (/or you make a new array, copy the results of the sort into it, and then use this as input for ```\nknapsack```\n)\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to solve a knapsack problem in CLP(B)\r\n                \r\nI wonder if there is a way to solve a knapsack problem in CLP(B). \nCLP(B) seems to be suitable, since packing an item can be modelled as a Boolean variable. \n\n\n  Example:\n  x1,x2,x3,x4,x5 e {0,1}\n  x1*12+x2*2+x3*1+x4*1+x5*4 =< 15\n  maximize x1*4+x2*2+x3*2+x4*1+x5*10\n\n\nI am little bit at loss how to formulate the side condition of the limited capacity of the knappsack. It seems that SWI-Prolog has weighted_maximum/3 which would allow the optimization.\n\n\nPicture from https://en.wikipedia.org/wiki/Knapsack_problem\n    ", "Answer": "\r\nYou can model size(weight) constraints by issuing new variables to account for the weight, then use ```\ncard```\n constraint to model capacity of the backpack and finally using ```\nweighted_maximum/2```\n to maximize objective:\n\n```\n:- use_module(library(clpb)).\n\nknapsack_sample([X1,X2,X3,X4,X5], Maximum):-\n  knapsack([X1-12/4,X2-2/2,X3-1/2,X4-1/1,X5-4/10], 15, Maximum).\n\n% Data is a list of BucketVar-Value/Weight\nknapsack(Data, Capacity, Maximum):-\n  buckets(Data, [], [], Buckets, AndEqAll, Weights, Xs),\n  sat(card([0-Capacity], Buckets)),\n  sat(AndEqAll),\n  weighted_maximum(Weights, Xs, Maximum).\n\nbuckets([], [EqAll|LEqAll], LBuckets, Buckets, AndEqAll, [], []):-\n  foldl(andall, LEqAll, EqAll, AndEqAll),\n  append(LBuckets, Buckets).\nbuckets([X-Count/Weight|Counts], LEqAll, LBuckets, Buckets, AndEqAll, [Weight|Weights], [X|Xs]):-\n  length([B|Bs], Count),\n  foldl(eqall(X), Bs, (X=:=B), EqAll),\n  buckets(Counts, [EqAll|LEqAll], [[B|Bs]|LBuckets], Buckets, AndEqAll, Weights, Xs).\n\neqall(B, X, Y, (B=:=X)*Y).\n\nandall(X, Y, X*Y).\n```\n\n\nSo in your example you would call knapsack with ```\nData=[X1-12/4,X2-2/2,X3-1/2,X4-1/1,X5-4/10]```\n and ```\n15```\n as capacity:\n\n```\n?- knapsack([X1-12/4,X2-2/2,X3-1/2,X4-1/1,X5-4/10], 15, Maximum).\nX1 = 0,\nX2 = X3, X3 = X4, X4 = X5, X5 = 1,\nMaximum = 15.\n```\n\n\n\n\nUPDATE:\n\nActually ```\ncard```\n constraints handle repetitions fine so there's no need to add new variables, and the solution gets simpler:\n\n```\nknapsack2(Data, Capacity, Maximum):-\n  maplist(knap, Data, LBuckets, Weights, Xs),\n  append(LBuckets, Buckets),\n  sat(card([0-Capacity], Buckets)),\n  weighted_maximum(Weights, Xs, Maximum).\n\nknap(X-Value/Weight, Ws, Weight, X):-\n  length(Ws, Value),\n  maplist(=(X), Ws).\n```\n\n\nSample run:\n\n```\n?- knapsack2([X1-12/4,X2-2/2,X3-1/2,X4-1/1,X5-4/10], 15, Maximum).\nX1 = 0,\nX2 = X3, X3 = X4, X4 = X5, X5 = 1,\nMaximum = 15.\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "GenSA and SA giving nonsense output for Knapsack problem\r\n                \r\nI have the following CSV:\n\nKnapsack.CSV\n\n```\n,gewichten(gr),waarde\nVoorwerp 1,70,135\nVoorwerp 2,73,139\nVoorwerp 3,77,149\nVoorwerp 4,80,150\nVoorwerp 5,82,156\nVoorwerp 6,87,163\nVoorwerp 7,90,173\nVoorwerp 8,94,184\nVoorwerp 9,98,192\nVoorwerp 10,106,201\nVoorwerp 11,110,210\nVoorwerp 12,113,214\nVoorwerp 13,115,221\nVoorwerp 14,118,229\nVoorwerp 15,120,240\n```\n\n\nI am trying to solve the Knapsack problem by using GenSA and GA. The solution for this set of data should be around 1458.\n\nHowever, with this code:\n\n```\ninstall.packages(\"GenSA\")\ninstall.packages(\"GA\")\nrequire(GenSA)\nlibrary(GenSA)\nrequire(GA)\nlibrary(GA)\n\n#Loading data\ndf <- read.csv(\"knapsack.csv\", header=TRUE, sep=\",\")\n\n\n#Define function\nknapsack <- function(x) {\n  f <- sum(x * df[3])\n  penalty <- sum(df[2]) * abs(sum(x*df[2]) - 750)\n  f - penalty\n}\n\ninit <- runif(1, -5000, 5000)\n\nonder <- rep(-5000, length(init))\nboven <- rep(5000, length(init)) \n\n\n\ncontrolelijst <- list(max.time=25, nb.stop.improvement = 100)\n\nresultaatSA <- GenSA(par=init, lower = onder, upper = boven, fn=knapsack, control=controlelijst)\n\nresultaatSA$par\n\n\n\n\n# Solution num 2\nSGA <- ga(type=\"binary\", fitness=knapsack, nBits=length(df[1]), maxiter=150, run=250, popSize=100, seed=101)\n\nSGA\nSGA@solution\n```\n\n\nI get a lot of nonsense output. GenSA for example says the solution is -5000, or sometimes 5000. Which are boundaries/constraints I have set.\n\nSA gives 1 as solution.\n\nWhat exactly am I doing wrong, and how do I need to use those two functions correctly?\n    ", "Answer": "\r\nI think John Coleman is correct, and that you have to simply change the sign of your cost function so that it is minimized. Below is a (slightly overkill) example of how this small addition of a minus to your function will result in a very different solution (hopefully the correct one). I have plotted the results in a similar way as ```\nGA```\n does, as I saw from your code that you were also looking into that as an option (quite a good one in fact). For ```\nGA```\n, the cost function is maximized, so you would need to remove the minus.\n\n```\nlibrary(GenSA)\nlibrary(GA)\n\ndf <- read.table(text = \",gewichten(gr),waarde\nVoorwerp 1,70,135\nVoorwerp 2,73,139\nVoorwerp 3,77,149\nVoorwerp 4,80,150\nVoorwerp 5,82,156\nVoorwerp 6,87,163\nVoorwerp 7,90,173\nVoorwerp 8,94,184\nVoorwerp 9,98,192\nVoorwerp 10,106,201\nVoorwerp 11,110,210\nVoorwerp 12,113,214\nVoorwerp 13,115,221\nVoorwerp 14,118,229\nVoorwerp 15,120,240\", sep = \",\", header = T\n)\n\n\n#Define function\nknapsack <- function(x) {\n  f <- sum(x * df[3])\n  penalty <- sum(df[2]) * abs(sum(x*df[2]) - 750)\n  -(f - penalty) # SIMPLY ADDED A MINUS SIGN\n}\n\ninit <- runif(1, -5000, 5000)\n\nonder <- rep(-5000, length(init))\nboven <- rep(5000, length(init)) \n\n\ncontrolelijst <- list(max.time=25, nb.stop.improvement = 100)\n\nresultaatSA <- GenSA(par=init, lower = onder, upper = boven, fn=knapsack, control=controlelijst)\n\nresultaatSA$par # 0.5233775\nhead(resultaatSA$trace.mat)\n\n\n# summarize results\ntmp <- as.data.frame(resultaatSA$trace.mat)\nmeani <- aggregate(tmp$function.value, list(step = tmp$nb.steps),mean, na.rm = TRUE)\nexe <- aggregate(tmp$current.minimum, list(step = tmp$nb.steps),mean, na.rm = TRUE)\nmedi <- aggregate(tmp$function.value, list(step = tmp$nb.steps),median, na.rm = TRUE)\nylim <- c(min(range(exe$x,na.rm = TRUE, finite = TRUE)),\n          max(range(meani$x, na.rm = TRUE, finite = TRUE)))\n\n# plot\nop <- par(mar=c(5.1, 4.1, 1, 4.1))\nplot(tmp$nb.steps, tmp$function.value, type = \"n\", ylim = ylim, xlab = \"Iteration\",\n     ylab = \"Cost value\")\ngraphics::grid(equilogs = FALSE)\npoints(tmp$nb.steps, tmp$current.minimum, type = \"o\", pch = 16, lty = 1,\n       col = \"green3\", cex = 0.7)\npoints(meani$step, meani$x, type = \"o\", pch = 1, lty = 2,\n       col = \"dodgerblue3\", cex = 0.7)\npolygon(c(meani$step, rev(meani$step)),\n        c(exe$x, rev(medi$x)),\n        border = FALSE, col = adjustcolor(\"green3\", alpha.f = 0.1))\npar(new=TRUE)\nplot(tmp$nb.steps, tmp$temperature, t=\"l\", col=2, lty=2, log=\"y\", axes = FALSE, xlab = \"\", ylab = \"\")\naxis(4, col=2, col.axis=2); mtext(text = \"Temperature\", side = 4, line = par()$mgp[1], col=2)\nlegend(\"topright\", legend = c(\"Best\", \"Mean\", \"Median\", \"Temperature\"),\n       col = c(\"green3\", \"dodgerblue3\", adjustcolor(\"green3\", alpha.f = 0.1), 2),\n       pch = c(16, 1, NA, NA), lty = c(1,2,1,2),\n       lwd = c(1, 1, 10, 1), pt.cex = c(rep(0.7,2), 2, NA),\n       inset = 0.02)\npar(op)\n```\n\n\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is there an algorithm that can solve this variation of the Knapsack Problem?\r\n                \r\nI want to do a variation on the 0-1 knapsack problem. Just like the original problem each item would have a weight and value, and you are minimizing weight and maximizing value. However each item would be part of a set e.g. ```\nBook1(value, weight, set).```\n\n\nI need an algorithm that can sort these, given an upper limit on each individual set. So for instance Set A would be ```\n(Book1, Book2, Book3)```\n and I could only have \n3 items from set A in the entire knapsack.\n\nThere would be no limits on individual items, so I could take as many ```\nBook1's```\n as I wished, but I couldn't take more than Set A would allow me to take. The entire knapsack would have multiple sets each with multiple items. \n\nI've tried individually solving each set before solving the problem as a whole using the solutions from each set, but it gives me obviously suboptimal solutions. \n\nHow should I design my code so that it produces the best result?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What it means that we can verify solution of knapsack problem in polynomial time?\r\n                \r\nknapsack problem is NP means that there is polynomial algorithm that can verify solution. Can you tell me what means \"verify\". what is that algorithm? How we can verify given solution?\n    ", "Answer": "\r\nYou seem to be a victim of sloppy language.\nThe classes P and NP apply to decision problems only.  Those are questions with a yes/no answer.\nNP does not mean that we verify an answer in polynomial time, because that answer is just 'yes' or 'no'.\nNP means that every 'yes' answer has a proof that we can verify in polynomial time.\nFor knapsack, the NP decision problem is \"is there a subset of weights that exactly fills the knapsack\"?   When the answer is 'yes', a list of those weights would be the proof, and you can verify it just by adding them up.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem with values per item and limited items\r\n                \r\nI'm trying to solve a variant of knapsack problem that i haven't seen before.\nin this variant we have a vector v consist of values per gram for each item and we also have a limited weight of each item and our goal is to find the maximum value that can be gain if we have a pack of size M.\nI tried greedy approached but haven't found any solution. i think the most difficult part is to do it in O(n) because we shouldn't sort anything.\nanyone has any idea?\n    ", "Answer": "\r\nIf the value per gram has reasonably narrow bounds, you can counting-sort or radix-sort or bucket-sort it in linear time by the value per gram, and then just fill up the bucket in order of most valuable substances. What do I mean by reasonable limits? Specifically, I mean that there are asymptotically fewer meaningful \"values per gram\" than there are kinds of substances. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Haskell - using Vector in a knapsack problem (optimization)\r\n                \r\nI was playing with a generalized knapsack problem (the size of the packs are random) and coded up :\n\n```\nimport Data.Vector (generate, (!)) \n\npacked :: Int -> Int -> Int -> Int -> Bool\npacked a b c n \n  | n `mod` a == 0 || n `mod` b == 0 || n `mod` c == 0  = True\n  | otherwise = packs!n where\n    packs = generate' (n+1) go \n    go i =  (i == 0) || (i == a) || (i == b) || (i == c) || \n            (i > a && packs!(i `rem` a ) )  ||\n            (i > b && packs!(i `rem` b ) )  ||\n            (i > c && packs!(i `rem` c ) )  ||\n            (i - a > 0 && packs!(i-a) ) || \n            (i - b > 0 && packs!(i-b) ) || \n            (i - c > 0 && packs!(i-c) ) \n\ngenerate' = Data.Vector.generate\n```\n\n\nBut I was surprised that using Vector for access did little to nothing to speed up the code as I have seen it make significant changes in past code especially on large lists. Is there something wrong with the way it is being used in the above?\n\nAs a general question, if I call that twice, the second time doesn't remember the first time so it has to run through everything again, correct? I think since  a and b and c change, then it can't be memoized as well so are the better approaches than the above to deal with the calculation?\n\nRef :\nhttps://en.wikipedia.org/wiki/Knapsack_problem\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack problem using Dynamic Programming, Top-Down Approach [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 1 year ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nGreeting everyone, I'm trying to solve 0/1 Knapsack problem using the Dynamic Programming Top-Down Approach. I'm pretty sure that most of my logic is correct, my code is compiling successfully. But, it's not giving the proper/correct output that is needed.\nFor Instance, suppose weight[] has inputs as 10,20,30 and it's corresponding value[] has 60,100,120. The max weight that the Knapsack can hold onto is 50. The max profit should be 220, but my code is giving me the answer 280 instead. Please help me, here's my piece of code:-\n```\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid knapsack(vector<int>& weight, vector<int>& value, int w, int n){\n    \n    vector<vector<int>> t;\n    for(int i=0;i<n+1;++i){\n        vector<int> temp;\n        for(int j=0;j<w+1;++j){\n                int x =0;\n                temp.push_back(x);\n        }\n        t.push_back(temp);\n        temp.clear();\n    }\n    \n    for(int i=1;i<n+1;++i){\n        for(int j=1;j<w+1;++j){\n            if(weight[i-1]<=w){\n                t[i][j] = max(value[i-1]+t[i-1][w-weight[i-1]], t[i-1][j]);\n                \n            }\n            else{\n               t[i][j] = t[i-1][j];\n               \n            }\n        }\n    }\n    cout<<\"Max Profit: \"<<t[n][w];\n   // return final;\n   \n//   vector<int> oneDimVector;\n//  for(int i = 0; i < n+1; i++){\n//      for(int j = 0; j < w+1; j++){\n//         oneDimVector.push_back(t[i][j]);\n//     }\n//  }\n//  vector<int>::iterator maxElement;\n//  maxElement = max_element(oneDimVector.begin(), oneDimVector.end());\n// cout<<\"Max Profit: \"<<*maxElement;\n    \n}\n\nint main(){\n    \n    int n;\n    int w;//Total weight of knapsack\n    cin>>n;\n    cin>>w;\n    \n    vector<int> weight;\n    vector<int> value;\n    \n    for(int i=0;i<n;++i){\n        int x;\n        cin>>x;\n        weight.push_back(x);\n    }\n    for(int i=0;i<n;++i){\n        int x;\n        cin>>x;\n        value.push_back(x);\n    }\n    \n  knapsack(weight,value,w,n);\n}\n```\n\n    ", "Answer": "\r\nI again debugged my code, I had to change one variable which I had written wrong in the following line of code:-\n```\nt[i][j] = max(value[i-1]+t[i-1][w-weight[i-1]], t[i-1][j]);\n```\n\nhere, it should be:-\n```\nt[i][j] = max(value[i-1] + t[i-1][ j - weight[i-1]], t[i-1][j]);\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Dynamic Programming solution for Knapsack Problem with a constraint\r\n                \r\nHow do I modify the DP algorithm for a knapsack problem with the constraint, that the next item to be taken has to have more profit than the previous one.\n\nTo elaborate:\n\nWe have a lot of sushi on a table.\n•They are arranged into a line.\nEach sushi has a quality value (higher if it tastes better)\nThe quality values of sushi are distinct.\nmany kinds of sushi\n\n•Find a way to take sushi such that\n(1) total quality value is maximized, and\n(2) the quality value of sushi taken is increasing\ni.e. when you take a sushi A, you must next take a\nsushi B better than A.\n•Your algorithm should run in O(n2) time\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Try to fit tasks to machines, Is this a knapsack problem?\r\n                \r\nI have the following problem which I am not sure what type of algorithm I should use. It seems to be a knapsack problem but I've been struggling to get an answer.  Below is the problem description: \n\nConsider a list of n tasks that need to be calculated, each task has requirements on memory, # of cpu cores and network bandwidth:\n\n```\njob_num   memory GB   cpu cores,   network GBit  \n1            15           1            0.1  \n2            1            1            0.1\n3            1            2            0.5\n4            12           1           0.3\n5            1            3            0.1\n...\n```\n\n\nNow lets assume we have a large pool of 16GB, 4 core, 1 GB networking machines that we can run these on, but we want to run use as few as possible, how can we do that?\n\nWhat type of problem is this and any suggestions for solution? \n\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple knapsack problem with equal profit and different weight\r\n                \r\nI am researching the load balancing problem in 5G system, but I am not sure if my problem is a NP-complete problem. \n\nThe problem is: \ngiven a set of n items and a set of m knapsacks\ncapacity of knapsacks are equal.\n3. the weight of item j in knapsack i is  w[i][j],that means weight of a item in each knapsack are different.\n4. each profit of items are equal.\n\nI am not trying to put all item in least knapsack like bin packing problem.\nI saw some similar question answered, but no one is identical to this case.\nIn this case, the goal is to put as more as possible item with m knapsacks.\nIs the problem a NP-complete problem?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack problem with bound in the number of items\r\n                \r\nI have a list with the weight, value and number of copies available of the items in a shop in the form [w_i, v_i, c_i]. I can not carry more than W weight with me, that is why I need to optimize my decision. How many copies of what item I should take? And, what is the max value I can generate with this selection?\nThis is a variant of 0-1 Knapsack problem. I have the solution for traditional problem here. But How can I modify this code for my desired solution?\n```\n    n=len(val)\n    table = [[0 for x in range(W + 1)] for x in range(n + 1)] \n \n    for i in range(n + 1): \n        for j in range(W + 1): \n            if i == 0 or j == 0: \n                table[i][j] = 0\n            elif wt[i-1] <= j: \n                table[i][j] = max(val[i-1] + table[i-1][j-wt[i-1]], table[i-1][j]) \n            else: \n                table[i][j] = table[i-1][j] \n   \n    return table[n][W]  \n```\n\n    ", "Answer": "\r\nWith nb being the number of copies available for each item:\n```\nocc_max = max(nb)\nn= len(val)\ntable = [[[0]*(occ_max+1) for x in range(W + 1)] for x in range(n + 1)]\nfor i in range(n + 1): \n    for j in range(W + 1):\n        if i == 0:\n            table[i][j][0] = 0\n        else:\n            for k in range(nb[i-1], -1, -1):\n                if k == nb[i-1] or wt[i-1] > j:\n                    table[i][j][k] = table[i-1][j][0]\n                else:\n                    table[i][j][k] = max(val[i-1] + table[i][j-wt[i-1]][k+1], table[i-1][j][0])\ntable[n][W][0]\n```\n\nBasically, k is the number of elements of type i-1 you have taken. On a given (i,j,k), you choose whether the best answer is to take one more element of type i-1, which is table[i][j][k+1] or to stop taking elements of type index-1 and start looking at elements of type i-2, which is table[i-1][j][0].\nAlso, I removed the ```\nif j == 0```\n in case of elements without weight.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Try to fit tasks to machines, Is this a knapsack problem?\r\n                \r\nI have the following problem which I am not sure what type of algorithm I should use. It seems to be a knapsack problem but I've been struggling to get an answer.  Below is the problem description: \n\nConsider a list of n tasks that need to be calculated, each task has requirements on memory, # of cpu cores and network bandwidth:\n\n```\njob_num   memory GB   cpu cores,   network GBit  \n1            15           1            0.1  \n2            1            1            0.1\n3            1            2            0.5\n4            12           1           0.3\n5            1            3            0.1\n...\n```\n\n\nNow lets assume we have a large pool of 16GB, 4 core, 1 GB networking machines that we can run these on, but we want to run use as few as possible, how can we do that?\n\nWhat type of problem is this and any suggestions for solution? \n\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Problem with implementation of the knapsack problem using DEAP library in python and metaheuristics\r\n                \r\nI am currently working in an implementation of the knapsack problem in python using the libray DEAP. I have to maximize the benefit and minimize the preference. The problem cannot have more elements inside the knapsak than a selected number.\nI have generated the following function:\n```\ndef evaluate(individual):\n    weight = sum(individual[i] * weights[i] for i in range(len(individual)))\n    benefit = sum(individual[i] * benefits[i] for i in range(len(individual)))\n    preference = sum(individual[i] * preferences[i] for i in range(len(individual)))\n    nTotal=sum(individual)\n\n    if weight > max_weight:\n        return -benefit + (weight - max_weight)*10000, preference+10 \n    elif nTotal > nMax:\n        return -benefit + (nTotal - nMax)*10000, preference+10 \n    else:\n        return -benefit, preference  \n```\n\nalongside\n```\ncreator.create(\"FitnessMulti\", base.Fitness, weights=(1.0, 1.0))\ncreator.create(\"Individual\", list, fitness=creator.FitnessMulti)\n\ntoolbox = base.Toolbox()\n\ntoolbox.register(\"attr_bool\", random.randint, 0, 1)\n\ntoolbox.register(\"individual\", generate_individual)\ntoolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n\ntoolbox.register(\"evaluate\", evaluate)\n\ntoolbox.register(\"mate\", tools.cxTwoPoint)\ntoolbox.register(\"mutate\", tools.mutFlipBit, indpb=0.05)\ntoolbox.register(\"select\", tools.selNSGA2)\n```\n\nMy solutions do not respect the restriction in weight nor the restriction in the number of elements.\nCan someone please help me to define a better version of evaluate so that I can enforce the restrictions?\nIf someone is interested, I can post the whole code\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Continuous Resource Allocation / Knapsack Problem\r\n                \r\nI'm trying to create an algorithm to solve the following optimization problem with each x_i and B as integers and all f_i's are monotonic, non-linear functions. This looks like a knapsack or continuous resource allocation problem to me. EDIT: The constant C is an integer\n\nI initially tried solving it by comparing the marginal cost for all of the g_i(x), this did not work since the Cs cancel. The comparison I was doing was looking for the i that would minimize g_i(x) - g_i(x - j), where j is a small value. In this case:\ng_i(x) - g_i(x - j) = f_i(x) + c - (g_i(x - j) + c), so the cs would cancel out.\nDoes anyone know of a solution for this, or have any clue on how to attempt this? I'd appreciate if anyone had any literature on this topic.\nThank you.\n    ", "Answer": "\r\nSo we have some facilities that can be open with some cost C or closed with cost 0, and the marginal cost for an open facility to serve each additional unit never goes down (```\nf_i```\n is convex).\nIf we knew which facilities were open, then we'd know we have an optimal assignment when all of the marginal costs for the next unit at each facility are greater than or equal to all of the marginal costs of the last unit at each facility (as you observed). If the functions have some special form, there's probably a better way to do this, but in general we can use binary search to find the minimum marginal cost that lets us serve the demand (where each iteration also uses binary search to determine how much each open facility can serve).\nIf instead we only knew that exactly k facilities should be open, we can still do binary search for the minimum marginal cost. We just have to figure out how many units each facility can serve without exceeding the proposed marginal cost, and then select the top k.\nFinally, observe that we can just try all k from 0 to n and take the best solution we find.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to get the number of items used in an unbounded knapsack problem?\r\n                \r\nI'm trying to solve an unbounded knapsack problem but I am stuck. I've already solved the main part of the problem which is getting the max value, but I'm also supposed to figure out how many of each item I used in order to get my maximum answer.\nThe bounds are less than 100 items and less than 100 capacity of the knapsack.\nThe example input is\n3 (number of items)\n8 (knapsack capacity)\n5 21 (weight and value respectively)\n3 1\n4 15\nand the output would be\n30 (the maximum value the bag can hold, which is 2 of the 4 weight item)\n0 0 2 (how many of each items is in the knapsack)\nI have no idea how to print that last line of output, and I've been stuck on this problem for a week. I asked elsewhere, and they said to store the previous state I came from, but I'm not sure how to do that. Here is my code so far. Any help is appreciated.\n```\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint wt[101];\nint val[101];\nint ans[101];\nint cnt[101];\n\nint knapsack(int s, int N, int val[], int wt[]){\n    \n    for(int i=0;i<=s;i++){\n        for(int j=0;j<N;j++){\n            if(wt[j]<=i){\n                int tmp = ans[i];\n                ans[i] = max(ans[i], ans[i-wt[j]] + val[j]);\n                \n            }\n        }\n    }\n    return ans[s];\n}\nint main() {\n    \n    int N, s, i, j, k, w, p;\n    \n    \n    scanf(\"%d\", &N);\n    scanf(\"%d\", &s);\n    for(i=0;i<N;i++){\n        scanf(\"%d %d\", &wt[i], &val[i]);\n    }\n    \n    printf(\"%d\\n\", knapsack(s, N, val, wt));\n    \n    \n    \n    \n    return 0;\n} \n```\n\n    ", "Answer": "\r\nI think you need to think about your basic organization. I'm not going to do your homework for you, but I'll try to give some hints.\nYour explanation of the knapsack problem seems flawed. Let me make sure we have the same problem.\nYou have a knapsack (a backpack). It can hold up to N \"pounds\".\nYou have several piles of things you can put into the knapsack. Each have a weight and a value.\nThe idea is to figure out how to stuff the knapsack with the highest amount of value.\nIt's interesting if you think of it differently. Imagine you won a shopping spree in a store. You get to fill the shopping cart, and you want to make away with the greatest value possible. So you head to the most expensive items and fill the cart as full as you can, but when you're almost done, you then head to the small items and stuff the corners.\nIn the end, you need to know:\n-What's the total dollar value of the things in the cart\n-And what's actually in it\n\nThis is actually kind of a tricky problem. I'd start with this: the structure of my data. I'd use a class to hold the possible items:\n```\nclass Item {\npublic:\n     int weight;\n     int value;\n};\n```\n\nIt doesn't sound like you have to worry about container classes (std::vector), so let's make an array:\n```\nItem items[100];\n```\n\nThe code you have for reading the input is mostly good, but instead of reading into your individual arrays, you would do something like this:\n```\nfor(index = 0; i < N; index++){\n    Item & item = items[index];\n    scanf(\"%d %d\", &item.weight, &item.value);\n}\n```\n\nNow the data for your items is stored together, which helps in thinking about your items.\nI'm going to talk about some stylistic things for a moment. First, I don't like your variable names. It's good to avoid abbreviations. You'll see I spell them out. Also, variable names of a single letter are hard to search for. You'll see I used index instead of i. You'll have a million instances of i in your code, but not so many instances of index.\nAnother stylistic thing to make the code easier to read: whitespace. We can afford it. I don't like to see stuff shoved all together, because I think that makes it a lot harder to read. Don't be afraid of spaces.\nClearly, those two paragraphs are an opinion, so take it for what it's worth.\n\nAt this point, you have to solve the problem. How do you fill the knapsack / cart / backpack the most optimally.\nHave you learned about recursion yet? Think of this code.\nImagine a method called findSolution. You're going to call it recursively, although you can do this in a double-nested loop, too.\nThe method decides \"we're best if we don't use any of the first item. What's the best solution using the remaining items?\" It calls itself, but says to skip the first item.\nThen it says, \"What if I put ONE of the first item in?\" And then calls itself on the remaining list.\nWhen that gets back, is sees, \"Oh, putting 1 in gives me a better total value than if I don't use any, so that's my tentative best solution.\"\nYou loop checking until you've use all 8 slots with just the first item, figuring out what is best.\nIt's tricky to code, might take a little time, but it's one way to solve this. Store the results in another class, then printing it is easy.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "why in 0-1 Knapsack problem we use INT_MIN and why the 0 is not working\r\n                \r\nwhy in the 0-1 Knapsack problem INT_min is used in the return statement of (max<0)  i have tried putting 0 in place of INT_MIN but I am getting 65 rather than correct answer 60 why this is happening can please any one explain me here is recursive code of knapsack problem\n```\n#include<iostream>\nusing namespace std;\nint solve(int v[],  int w[] , int n ,int max){\n    if (max < 0) {\n        return INT_MIN;      // here this is giving me problem if I use 0 in place of \n                            // INT_min I get wrong ansewrs\n    }\n \n    if (n < 0 || max == 0) {\n        return 0;\n    }\n    \n    int include = 0 ; \n    int exclude = 0 ;\n    include = v[n]+solve(v,w, n-1,max - w[n]); \n    exclude = solve(v,w, n-1,max); \n    \n    if(include<exclude){\n        return exclude;\n    }else{\n        return include;\n    }\n}\nint main(){\n    int v[] = { 20, 5, 10, 40, 15, 25 };\n    int w[] = { 1, 2, 3, 8, 7, 4 };\n    int W = 10;\n \n    int n = sizeof(v) / sizeof(v[0]);\n\n    cout<< solve(v,w,n-1,W)<<endl;\n    return 0;\n}\n```\n\nfor this array I am getting answer 60 if I am using the INT_MIN in return statment and getting 65 if I use 0 in return statment.\n    ", "Answer": "\r\nLet's imagine we are simulating the recursion procedure manually.\nAt first, we pick the last object (```\nv=25, w=4```\n) and drops the last-second object (```\n15v, 7w```\n). Now we have 25 value and 4 weight. Afterward, at the next step ```\nN-3```\n where N is the number of objects, we are going to determine whether to include the last-third object (```\n40v, 8w```\n) or not.\nThen here are the two subsequent recursive calls in the current step:\n```\ninclude = 40+solve(v,w, N-4,(10 - 4) - 8);\nexclude = solve(v,w, N-4,(10-4)); \n```\n\nIf ```\nINT_MIN```\n is returned when ```\nmax < 0```\n, ```\ninclude = 40 + INT_MIN = SOME_EXTREMELY_SMALL_VALUE```\n. And ```\nexclude = SOME_NON_ZERO_VALUE > include```\n. It implies that the last-third object cannot be picked as it will overfills the knapsack, considering the current left capacity is just ```\n10-4=6```\n.\nIf ```\n0```\n is returned instead, ```\ninclude = 40+0=40```\n. And ```\nexclude = SOME_VALUE < 40```\n. It implies that the last-third object is actually picked in addition to the last object even though it just overfills the knapsack, resulting in a total weight of ```\n4+8=12>10```\n and the invalid answer ```\n40+25=65```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "I got wrong output for 0/1 knapsack problem in python using backtracking\r\n                \r\nI implemented the 0/1 knapsack problem with the backtracking technique, but I didn't get the expected result.\n\ncapacity : total knapsack capacity\ncargo_number : the number of items\nsize : the weight of each items\nprofit : the profit of each items\n\ntest case1:\ninput\n```\n16\n\n4\n\n2 5 10 5\n\n40 30 50 10 \n```\n\noutput\n```\n90 (correct result)\n```\n\ntest case2:\ninput\n```\n10\n\n5\n\n7 2 10 2 4\n\n46 19 30 49 11\n```\n\nouput\n```\n98 (wrong result, expected result is 95.)\n```\n\n```\nfrom typing import List\n\n\nclass Solution:\n    def fractional_knapsack(self, n: int, size: List[int], profit: List[int], left_capacity: int):\n        if left_capacity <= 0:\n            return 0\n        # sort profit and size in descending order\n        sorted_index = sorted(range(n), key=lambda i: profit[i] / size[i], reverse=True)\n        sorted_size = [size[i] for i in sorted_index]\n        sorted_profit = [profit[i] for i in sorted_index]\n\n        estimated_profit = 0\n        for i in range(n):\n            if sorted_size[i] <= left_capacity:\n                estimated_profit += sorted_profit[i]\n                left_capacity -= sorted_size[i]\n            else:\n                estimated_profit += sorted_profit[i] * (left_capacity / sorted_size[i])\n                break\n        return estimated_profit\n\n    def knapsack(self, i, left_capacity):\n        global max_profit\n        if i >= cargo_number or left_capacity <= 0:\n            return\n\n        current_s = sum(size[i] for i in range(cargo_number) if x[i] == 1)  # sum of current size\n        current_p = sum(profit[i] for i in range(cargo_number) if x[i] == 1)  # sum of current profit\n\n        if current_s + size[i] <= left_capacity:\n            estimated_profit = self.fractional_knapsack(\n                cargo_number - (i + 1),\n                size[i + 1:],\n                profit[i + 1:],\n                left_capacity - size[i],\n            )\n            if current_p + profit[i] > max_profit:  # renew max_profit\n                max_profit = current_p + profit[i]\n            x[i] = 1  # if item is selected\n            self.knapsack(i + 1, left_capacity - size[i])  #\n\n        estimated_profit = fractional_knapsack(\n        cargo_number - (i + 1), size[i + 1:], profit[i + 1:], left_capacity\n    )\n        if current_p + estimated_profit > max_profit:\n            x[i] = 0  # if item is not selected\n            self.knapsack(i + 1, left_capacity)\n\n\ncapacity = int(input())\ncargo_number = int(input())\nsize = list(map(int, input().split()))\nprofit = list(map(int, input().split()))\n\nx = [0] * cargo_number  # if x[i] == 1, then i-th item is selected, otherwise not\nmax_profit = 0\n\nsolution = Solution()\nsolution.knapsack(0, capacity)\nprint(max_profit)\n\n```\n\nI used the state space tree to solve it.\nHow do I modify the code to pass test case2?\n    ", "Answer": "\r\nThere might be other issues, but I spotted one error:\n```\nif current_s + size[i] <= left_capacity:\n```\n\nshould be:\n```\nif size[i] <= left_capacity:\n```\n\nThe ```\ncapacity_left```\n is computed for new items, but ```\ncurrent_s```\n is computed for already existing items.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "If we can prove that knapsack problem with limited capacity are solved in a polynomial time then all knapsack belongs to P\r\n                \r\nI found this question in my Optimization Algorithm course, the full question is this:\nIf we can prove all Knapsack problems with capacity limited to 100 can be solved in polynomial time, then all Knapsack problems belong to P. Is this sentence true or false? Justify.\n\nWith my book and some research I came out with something like this:\nFirst of all KP is an NP-complete problem. With Dynamic programming it can reach a pseudopolynomial time, but it's not enough.\nIf, absurdly, we can prove that KP with capacity limited to 100 can be solved in polynomial time then we can assume that KP belongs to P.\n\nWhat do you think about my answer? I think the absurd is not so right in the last sentence.\n    ", "Answer": "\r\nProving that all knapsack problems with a limited capacity can be solved in polynomial time does not prove that all knapsack problems are in P. If a problem is in P, that means that it can be solved in polynomial time. This means that it can be solved in O(n^k) where k is some integer. Big O is an upper bound, meaning that, if an algorithm is O(n), as n approaches infinity, the time it takes to do the algorithms will never be longer than n. By proving that all problems with n<100 can be solved in polynomial time, this makes no guarantee for much larger n. Therefore we cannot say that there is an algorithm that runs in O(n^k) and is therefore in P.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Fast Knapsack Solver For big problems\r\n                \r\nI want to approximately solve the knapsack problem for big data sets using Python.\n\nRight now, I am using this implementation, which works well for small examples like:\n\n```\nimport knapsack\nweight = np.random.randint(10, size = 10)\nvalue = np.random.randint(10, size = 10)\ncapacity = 5\nknapsack.knapsack(weight, value).solve(capacity)\n```\n\n\nbut when we scale it up to:\n\n```\nimport knapsack\nweight = np.random.randint(10, size = 1000)\nvalue = np.random.randint(10, size = 1000)\ncapacity = 500\nknapsack.knapsack(weight, value).solve(capacity)\n```\n\n\nthe program just gets stuck and gives an error. I was wondering if there is some implementation of the knapsack problem where we can state something like compute for 10 seconds and return me the best solution found so far, is this possible?\n    ", "Answer": "\r\nHere a small prototype 0-1-integer programming approach for the 0-1 knapsack! \n\nThis code:\n\n\nis not doing everything perfectly!\n\n\ne.g. constraints vs. bounds (latter more efficient; but too lazy to check cylp again for that; problems in the past)\n\nnot much support for windows!\n\n\nwindows users: go for pulp which brings the same solver (imho the best free open-source MIP-solver); although modelling looks quite different there!\n\nno tuning!\n\n\nobserve: CoinOR's Cgl, which is used in the solver Cbc, supports extra knapsack-cuts!\nas the logs show: example is too simple to effect in their usage!\n\nbounded / unbounded knapsack-versions are easily handled by just modifying the bounds\n\n\nThe example here just solves one problem as defined by OP using a PRNG-seed of 1, where it takes 0.02 seconds, but that's not a scientific test! NP-hard problems are all about easy vs. hard instances (huge variance!) and because of that, data to check against is important! One can observe, that there is no real integrality-gap for this example.\n\nCode\n\n```\nimport numpy as np\nimport scipy.sparse as sp\nfrom cylp.cy import CyClpSimplex\nnp.random.seed(1)\n\n\"\"\" INSTANCE \"\"\"\nweight = np.random.randint(10, size = 1000)\nvalue = np.random.randint(10, size = 1000)\ncapacity = 500\n\n\"\"\" SOLVE \"\"\"\nn = weight.shape[0]\nmodel = CyClpSimplex()\nx = model.addVariable('x', n, isInt=True)\nmodel.objective = -value\nmodel += sp.eye(n) * x >= np.zeros(n)  # could be improved\nmodel += sp.eye(n) * x <= np.ones(n)   # \"\"\"\nmodel += np.matrix(weight) * x <= capacity  # cylp somewhat outdated in terms of np-usage!\ncbcModel = model.getCbcModel()  # Clp -> Cbc model / LP -> MIP\ncbcModel.logLevel = True\nstatus = cbcModel.solve()\nx_sol = np.array(cbcModel.primalVariableSolution['x'].round()).astype(int)  # assumes there is one\n\nprint(x_sol)\nprint(x_sol.dot(weight))\nprint(x_sol.dot(value))\n```\n\n\nOutput\n\n```\nWelcome to the CBC MILP Solver \nVersion: 2.9.9 \nBuild Date: Jan 15 2018 \n\ncommand line - ICbcModel -solve -quit (default strategy 1)\nContinuous objective value is -1965.33 - 0.00 seconds\nCgl0004I processed model has 1 rows, 542 columns (542 integer (366 of which binary)) and 542 elements\nCutoff increment increased from 1e-05 to 0.9999\nCbc0038I Initial state - 1 integers unsatisfied sum - 0.333333\nCbc0038I Pass   1: suminf.    0.25000 (1) obj. -1965 iterations 1\nCbc0038I Solution found of -1965\nCbc0038I Branch and bound needed to clear up 1 general integers\nCbc0038I Full problem 1 rows 542 columns, reduced to 1 rows 128 columns\nCbc0038I Cleaned solution of -1965\nCbc0038I Before mini branch and bound, 540 integers at bound fixed and 0 continuous\nCbc0038I Mini branch and bound did not improve solution (0.02 seconds)\nCbc0038I After 0.02 seconds - Feasibility pump exiting with objective of -1965 - took 0.01 seconds\nCbc0012I Integer solution of -1965 found by feasibility pump after 0 iterations and 0 nodes (0.02 seconds)\nCbc0038I Full problem 1 rows 542 columns, reduced to 1 rows 2 columns\nCbc0001I Search completed - best objective -1965, took 0 iterations and 0 nodes (0.02 seconds)\nCbc0035I Maximum depth 0, 362 variables fixed on reduced cost\nCuts at root node changed objective from -1965.33 to -1965.33\nProbing was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nGomory was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nKnapsack was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nClique was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nMixedIntegerRounding2 was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nFlowCover was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nTwoMirCuts was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n\nResult - Optimal solution found\n\nObjective value:                -1965.00000000\nEnumerated nodes:               0\nTotal iterations:               0\nTime (CPU seconds):             0.02\nTime (Wallclock seconds):       0.02\n\nTotal time (CPU seconds):       0.02   (Wallclock seconds):       0.02\n\n[0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 1 0 0 1 0 0\n 0 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 1 0\n 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 1 1 0 0 1 0 0 0 1 1\n 1 0 0 1 1 1 0 0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 1 1 1 0 0 1 0 0 0 0\n 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 1 1 1 0 0 0 1 1 1 1\n 0 1 0 0 0 0 0 0 0 1 0 1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 1 0\n 1 1 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0\n 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 1 1 1 0 1 0 1 1 0\n 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 1 1 1 0 1 0 1 0 1 1 0 0 1 0 1 0 0\n 0 0 0 0 1 1 0 0 0 0 0 1 1 0 1 0 1 1 0 0 0 0 0 1 0 0 0 1 1 0 1 0 0 0 0 1 1\n 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1\n 0 0 0 0 0 1 1 1 1 1 1 1 1 1 0 0 0 1 1 0 0 1 0 1 0 0 0 1 1 0 0 0 0 0 1 0 0\n 0 0 0 1 0 0 1 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 1\n 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 1 0 1 1 0 0\n 1 1 1 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 0 0\n 0 1 1 0 0 0 0 0 0 1 0 1 0 0 0 1 1 1 1 0 0 0 0 0 0 1 0 1 1 0 0 1 0 0 0 1 1\n 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 1 1 0 0 0 1 1 0 0 1 0 0\n 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 0 1 1\n 0 0 1 1 0 0 0 1 1 0 1 1 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 0 0 0 0 1 1\n 0 0 0 1 1 0 1 1 0 0 1 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 0 1 1 1 0 0 1 0 0 0 1\n 1 1 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0\n 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0 1 0 0 0\n 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 0 1 1 0 1 1 0 1 1 0 1 0 0 0 0 1 0 0 0 1 1\n 0 1 0 0 0 0 0 1 0 1 1 0 1 0 1 0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0\n 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 0 0 1 0 0 1 0 1 1 0\n 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 1 1 0 1 0 0 0 1 1 1 0 0\n 0 0 1 1 1 0 0 1 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 1\n 0]\n500\n1965\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "in knapsack problem, how do i know which items are taken?\r\n                \r\ni used dynamic programming to solve knapsack problem.\n```\n#include <iostream>\nusing namespace std;\n#define number 4 // number of item type\n\ntypedef struct iteml\n{\n    int itemw; // [weight of item]\n    int itemv; // [value of item]\n    char name[30]; // [name of item]\n}iteml;\n\nint main()\n{\n    int item_number = number; // number of item type\n    int backpack_weight; //maximum weigth of backpack\n\n    iteml item[number+1]; // [number of item type +1]\n    item[1] = { 10, 6, \"platinum\" };\n    item[2] = { 15, 5, \"gold\" };\n    item[3] = { 25, 4, \"silver\" };\n    item[4] = { 50, 1, \"steel\" };\n\n    int dp[number+1][61] = { 0, }; // [number of item type +1] [maximum weigth of backpack]\n    int i, w = 1;\n\n    cout << \"type maximum weigth of backpack. : \";\n    cin >> backpack_weight;\n\n    for (i = 1; i <= item_number; i++)\n    {\n        for (w = 1; w <= backpack_weight; w++)\n        {\n            if (item[i].itemw<= w)\n            { \n                if ((item[i].itemv + dp[i - 1][w - item[i].itemw]) > dp[i - 1][w])\n                {\n                    dp[i][w] = item[i].itemv + dp[i - 1][w - item[i].itemw];\n                }\n                else\n                {\n                    dp[i][w] = dp[i - 1][w];\n                }\n            }\n            else\n            {\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n\n    printf(\"%d\", dp[item_number][backpack_weight]);\n    return 0;\n}\n```\n\ninput data\n```\n60\n```\n\noutput data\n```\n15\n\n```\n\nbut i also want to print which items are selected\nfor ex)\n```\n15\nplatinum\ngold\nsilver\n```\n\nfirst, i added new int called calltime in struct\n```\ntypedef struct iteml\n{\n    int itemw; // [weight of item]\n    int itemv; // [value of item]\n    int calltime; \n    char name[30]; // [name of item]\n}iteml;\n```\n\nand i thought if i add some item[n].calltime-- or item[n].calltime++ i was able to know which items were selected, but it was totally impossible\n    ", "Answer": "\r\ni solved by adding this code\n```\nint num = item_number;\n    int weight = backpack_weight;\n    while (num > 0) {\n        if (dp[num][weight] != dp[num - 1][weight]) {\n            printf(\"%s \", item[num].name);\n            weight -= item[num - 1].itemw;\n        }\n        num -= 1;\n    }\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Unbounded knapsack problem - max value per weight approach\r\n                \r\nProblem:\nGiven a knapsack with weight W and a set of items where each item has a value and weight, find the max value you can pack in the knapsack.\nSo I have been reading online and all the solutions I saw include DP but I cant understand why.\nWhat I thought of is:\n\nfor each item find its value per weight\npack as much of the item with the highest value per weight as you can in the knapsack\nIf the knapsack is full return the value\nOtherwise do the same for the next highest value per weight item (assuming there is space for it)\nRepeat until knapsack is full or we been through all items\n\nThis sounds much simpler than DP to me (but maybe its just me).\nIs this approach correct? Am I missing something?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "algorithm about unbound knapsack problem with possible negative weights?\r\n                \r\nI meet an unbounded knapsack problem with possible negative weights: There are ```\nk```\n items, with weights ```\nx1, x2, ..., xk```\n (```\nxi```\n can be positive or negative). Every item can have infinite number. The bag can store weight ```\nW > 0```\n. How to store as little number as possible with exact ```\nW```\n weight, if there is no solution just return ```\n-1```\n.\nThat is\n\nWhat's the algorithm to solve this problem?\nFirstly, we cannot drop negative one. For example, ```\nx_1 = 3, x_2 = -1, W = 2```\n. If we drop negative one, there can be no solution. However, there can be solution ```\nn_1=1, n_2=1```\n.\nThe naive idea of dynamic programming/recursion with memorization cannot handle negative weight with infinite number.\n```\ndp[i][w] = minimum number of items to fill weight w by using item 1, 2, ..., i```\n\n```\ndp[i][w] = min(dp[i-1][w], dp[i][w - xi] + 1)```\n\nSince ```\nxi```\n can be negative and infinite number, there can be infinite state ```\ndp[i][w]```\n.\n    ", "Answer": "\r\nYou can do a breadth-first search on the graph of achievable total weights, where there exists an edge from weight w to weight v if there is an item with weight v-w.  Start at 0 and find the shortest path to W.\nThe trick is that you don't need to consider achievable weights less then -max(|xi|) or greater than W+max(|xi|).  You don't need to consider anything else, because for every sequence of item weights that adds up to W, there is an order in which you can perform the additions so that the intermediate sum never goes outside those bounds.\nAssuming that the weights are integers, this makes the graph finite.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to solve this variant of the Knapsack problem?\r\n                \r\nI am trying to solve this problem: There are ```\nn customers```\n queuing at post office to wait to send parcels. ```\na[0], a[1], ..., a[n-1]```\n is the list of shipping costs of n customers from the 1st to the nth person. It takes exactly a minute for the postal worker to complete the information needed for a customer to send a parcel. However, all customers are too busy to wait for more than a certain period of time. ```\nt[0], t[1], ..., t[n-1]```\n is the list of minutes each of n customers can spend at the post office. Help the postal worker to find a way to serve customers so that the post office can get the largest amount of money, knowing that the staff is allowed to refuse to serve some customers for the profitable reason.)\nExample:\n\nFor ```\na = [10, 20, 5, 12], t = [2, 3, 3, 1]```\n, the output should be ```\n42```\n.\nExplanation: The order of the customers is: the 4th person -> the 1st person -> the 2nd person (1-based indexing)\nFor ```\na = [5, 1, 3, 2], t = [3, 1, 2, 2]```\n, the output should be ```\n10```\n.\nExplanation: Although the 2nd person can wait only 1 minute, this person has to pay the smallest cost. Therefore, the postal worker will not serve this customer. The order of the customers is: the 3rd person -> the 4th person -> the 1st person.\n\nI think it is a variant of the knapsack problem, I can solve it by using brute force but only for small input. Can someone help me to solve this problem? Thanks.\n    ", "Answer": "\r\nIf there are no overlapping times, the problem is straightforward just sum up all the shipping costs. The problem becomes non-trivial if there is overlap.\nSo lets form a tuple of the (time, cost) and sort them first by time and then by cost(descending).\nFor example for the input:\n```\na = [10, 20, 5, 12]\nt = [2, 3, 3, 1]\n```\n\nthe sorted list of tuples will be:\n```\n[(1, 12), (2, 10), (3, 20), (3, 5)]\n```\n\nNow lets have a running list of costs.\nFor (1,12) our list will be [12]\nFor (2,10) because 2 is not equal to 1, you can just add the cost (10) to your list [12,10]\nFor (3,20) because 3 is not equal to 2, you just add 20 to the list to make it [12,10,20]\nFor (3,5) we have an overlap there are two options:\n\nget rid of one of the items - the minimum of the list i.e. 10 and add 5\n\nskip 5\nThe second option will be better.\nThe final list will be [12,10,20] whose sum = 42 is the answer.\n\n\nNote here the length of the list is always equal to the time t at each time. This is logical because you can only process t customers up to time t and the problem is to fit the best costs with in that list.\nLets take another example:\n```\na = [10, 5, 7, 20, 15, 1]\nt = [2, 2, 2, 3, 3, 1]\n\n[(1, 1), (2, 10), (2, 7), (2, 5), (3, 20), (3, 15)]\n```\n\nFor this one the running list will look like:\nt = 1 : [1] # Beginning just push\nt = 2 : [1, 10] # 2 > 1 so push\nt = 2 : [7, 10] # overlap of 2, see if 1 can be removed and 7 can be added yes so push\nt = 2 : [7, 10] # overlap of 2, see if 7 can be removed and 5 can be added, no because it will reduce the profit. So keep the list.\nt = 3 : [7, 10, 20] # 3 > 2, just push\nt = 3 : [10, 20, 15] # overlap of 3, see if the min can be removed and 15 can be added, yes then remove 7 and add 15.\nThe answer will be 45 for this.\nCode in python looks like:\n```\nimport heapq\ndef get_max_shipping_cost(a, t):\n    if len(a) == 0:\n        return 0\n    items = sorted(zip(t,a), key = lambda tup: (tup[0], -tup[1]))\n    l = []\n    heapq.heappush(l, items[0][1])\n    s = items[0][1]\n    i = 1\n    prev = items[0]\n    while i < len(items):\n        if items[i][0] == prev[0]:\n            prev = items[i]\n            if s - l[0] + items[i][1] > s:\n                s = s - l[0] + items[i][1]\n                heapq.heappop(l)\n                heapq.heappush(l,items[i][1])\n            i += 1\n        elif items[i][0] == prev[0] + 1:\n            prev = items[i]\n            heapq.heappush(l,items[i][1])\n            s += items[i][1]\n            i += 1\n        else:\n            prev = (prev[0] + 1, 0)\n            heapq.heappush(l,0)\n    return s\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How can I solve a Knapsack problem with CPLEX?\r\n                \r\nCan someone please help me with a code to this problem.\nThe problem wants me to maximize total benefit by filling a 10-lb knapsack with the following data pic:\n    ", "Answer": "\r\nin OPL CPLEX you can write\n```\ntuple t\n{\n  key int itemNbr;\n  float weight;\n  float benefit;\n}\n\n{t} items=\n{\n  <1,4,11>,<2,3,7>,<3,5,12>\n};\n\nint knapsacksize=10;\n\ndvar boolean take[items];\n\nmaximize sum(i in items) i.benefit*take[i];\n\nsubject to\n{\n  sum(i in items) i.weight*take[i]<=knapsacksize;\n}\n```\n\nwhich gives\n```\ntake = [1 0 1];\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem: Optimal fair division of items in limited quantity, between Knapsacks with unlimited capacity\r\n                \r\nI am looking for a solution to the following Knapsack problem:\n\nDynamic programming and not naive programming, in C++\nFor each item, weight and value are equal, meaning no two arrays are needed, but only one. Therefore we will refer to weights only.\nThere are three knapsack. All of them have no capacity weight limit, which means that all the items must be taken, but also the distribution between the bags must be as fair as possible (optimal).\n\nAttached is a solution I wrote for the above problem with two knapsacks. It works properly, but long and complicated. For three knapsack I got completely entangled.\nI would be happy, but not necessary:\n\nA simpler solution than what I wrote\nIf there is a solution for the unlimited amount of knapsack (of course must meet all the above conditions\n)\nAs in my solution, print which items will be in each bag (In addition to the weight difference between the knapsacks)\n\nI know and apologize. The explanation for the solution I wrote is long. I will explain it, but there is no need for the solution I am asking for to be necessarily similar to what I wrote.\nExplanation of the solution I wrote:\nEach cell of the table has a pair of numbers - the first knapsack and the second knapsack.\nThe columns represent all possible weights from 0 to the total weight of all the items. The rows represent the weight of each item.\nIn each cell we want to fill in the table, we will see if there are two options:\n\nIf there a cell above it\nIf it is possible to step back from it (left) the amount of cells as the amount of weight represented in the current row and then go up one cell up\n\nFrom the above existing options, we will select the maximum weight of the first knapsack and place it in the current cell in the first knapsack. In the second knapsack of the current cell we will set the difference.\nThen, if the weight in the current cell can be added to the first knapsack, without the addition exceeding the weight represented by the current column we will add, otherwise we will add the weight to the second knapsack.\nIn the last line we will find the optimal solution, according to the pair of numbers with the lowest difference between them. From that cell we can step back and find out how the optimal solution was obtained.\nMy C++ code solution for two knapsacks\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\n// 2 knapsacks\nint *items_arr,\n    items_num,\n    ***knapsacks_arr, // [row][col][knapsack]\n    rows,\n    cols;\n\nvoid allocate_knapsacks_arr()\n{\n    knapsacks_arr = new int **[rows];\n    for (int r = 0; r < rows; r++)\n    {\n        knapsacks_arr[r] = new int *[cols];\n        for (int c = 0; c < cols; c++)\n            knapsacks_arr[r][c] = new int[2]; // 2 knapsacks\n    }\n}\n\nvoid delete_knapsacks_arr()\n{\n    for (int r = 0; r < rows; r++)\n    {\n        for (int c = 0; c < cols; c++)\n            delete[] knapsacks_arr[r][c];\n        delete[] knapsacks_arr[r];\n    }\n    delete[] knapsacks_arr;\n}\n\nvoid initialize_knapsacks_arr()\n{\n    knapsacks_arr[0][0][0] = 0;\n    knapsacks_arr[0][0][1] = 0;\n    for (int c = 1; c < cols; c++)\n    {\n        knapsacks_arr[0][c][0] = INT_MAX;\n        knapsacks_arr[0][c][1] = INT_MAX;\n    }\n\n    int sum_items = 0,\n        index_items = 0;\n    for (int c, r = 1; r < rows; r++)\n    {\n        for (c = 0; c <= sum_items + items_arr[index_items]; c++)\n        {\n            // set knapsacks1\n            int k1_up = knapsacks_arr[r - 1][c][0];\n            int k1_left = INT_MAX;\n            if (c >= items_arr[index_items])\n                k1_left = knapsacks_arr[r - 1][c - items_arr[index_items]][0];\n\n            // if no up and no left\n            if (k1_up == INT_MAX && k1_left == INT_MAX)\n                knapsacks_arr[r][c][0] = 0;\n\n            // if only up\n            if (k1_up != INT_MAX && k1_left == INT_MAX)\n                knapsacks_arr[r][c][0] = k1_up;\n\n            // if only left\n            if (k1_up == INT_MAX && k1_left != INT_MAX)\n                knapsacks_arr[r][c][0] = k1_left;\n\n            // if up and left\n            if (k1_up != INT_MAX && k1_left != INT_MAX)\n            {\n                if (k1_up > k1_left)\n                    knapsacks_arr[r][c][0] = k1_up;\n                else\n                    knapsacks_arr[r][c][0] = k1_left;\n            }\n\n            // set knapsacks2\n            knapsacks_arr[r][c][1] = sum_items - knapsacks_arr[r][c][0];\n\n            // add item\n            if (c >= knapsacks_arr[r][c][0] + items_arr[index_items])\n                knapsacks_arr[r][c][0] += items_arr[index_items];\n            else\n                knapsacks_arr[r][c][1] += items_arr[index_items];\n        }\n        for (; c < cols; c++)\n        {\n            knapsacks_arr[r][c][0] = INT_MAX;\n            knapsacks_arr[r][c][1] = INT_MAX;\n        }\n        sum_items += items_arr[index_items];\n        index_items++;\n    }\n}\n\nvoid show_knapsacks_arr()\n{\n    cout << \"\\t\";\n    for (int c = 0; c < cols; c++)\n        cout << c << \"\\t\";\n    cout << endl;\n\n    for (int r = 0; r < rows; r++)\n    {\n        if (r > 0)\n            cout << items_arr[r - 1];\n        cout << \"\\t\";\n\n        for (int c = 0; c < cols; c++)\n        {\n            cout << \"(\";\n            if (knapsacks_arr[r][c][0] == INT_MAX) // == numeric_limits<int>::max()\n                cout << \"-\";                       // static_cast<unsigned char>(236);\n            else\n                cout << knapsacks_arr[r][c][0];\n            cout << \", \";\n            if (knapsacks_arr[r][c][1] == INT_MAX)\n                cout << \"-\"; // static_cast<unsigned char>(236);\n            else\n                cout << knapsacks_arr[r][c][1];\n            cout << \")\\t\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint items_sum()\n{\n    int sum = 0;\n    for (int i = 0; i < items_num; i++)\n        sum += items_arr[i];\n    return sum;\n}\n\nvoid show_optimal_solution(int r, int c)\n{\n    int index_items = items_num;\n\n    cout << \"Dynamic (2D array)\" << endl\n         << \"optimal difference = \" << abs(knapsacks_arr[r][c][0] - knapsacks_arr[r][c][1]) << endl\n         << \"knapsack 1 total weight of all items = \" << knapsacks_arr[r][c][0] << endl\n         << \"knapsack 2 total weight of all items = \" << knapsacks_arr[r][c][1] << endl;\n\n    while (true)\n    {\n        cout << endl\n             << \"item number \" << index_items << \", weight = \" << items_arr[index_items - 1] << \", indexes = (\" << r << \", \" << c << \") >> \";\n        if (r == 1)\n        {\n            if (c < items_arr[0])\n                cout << \"knapsack 2\";\n            else\n                cout << \"knapsack 1\";\n            cout << endl\n                 << endl;\n            return;\n        }\n        if (knapsacks_arr[r][c][0] == knapsacks_arr[r - 1][c][0])\n        {\n            cout << \"knapsack 2\";\n            r--;\n            index_items--;\n        }\n        else\n        {\n            cout << \"knapsack 1\";\n            r--;\n            c -= items_arr[index_items - 1];\n            index_items--;\n        }\n    }\n}\n\nvoid find_optimal_solutions()\n{\n    // find minimum difference between each pair knapsacks in last row\n    int optimal = INT_MAX,\n        index = 0;\n    for (int c = 0; c < cols; c++)\n    {\n        int tmp = abs(knapsacks_arr[rows - 1][c][0] - knapsacks_arr[rows - 1][c][1]);\n        if (optimal > tmp)\n        {\n            optimal = tmp;\n            index = c;\n        }\n    }\n    show_optimal_solution(rows - 1, index); // only first solution\n\n    // find all same differences in last row = additional solutions\n    // for (int c = 0; c < cols; c++)\n    //  if (optimal == abs(knapsacks_arr[rows - 1][c][0] - knapsacks_arr[rows - 1][c][1]))\n    //      show_optimal_solution(rows - 1, c);\n}\n\nint main()\n{\n    items_arr = new int[]{7, 3, 1, 6};\n    items_num = 4;\n\n    rows = items_num + 1;\n    cols = items_sum() + 1;\n\n    allocate_knapsacks_arr();\n    initialize_knapsacks_arr();\n    show_knapsacks_arr();\n    find_optimal_solutions();\n    delete_knapsacks_arr();\n    delete[] items_arr;\n\n    return 0;\n}\n```\n\nInput\n\nweights 7, 3, 1, 6\nOutput\n\nfirst knapsack: 1, 7\n\nsecond knapsack: 6, 4\n```\n        0       1       2       3       4       5       6       7       8       9       10      11      12      13      14      15      16      17    \n        (0, 0)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)\n7       (0, 7)  (0, 7)  (0, 7)  (0, 7)  (0, 7)  (0, 7)  (0, 7)  (7, 0)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)\n3       (0, 10) (0, 10) (0, 10) (3, 7)  (3, 7)  (3, 7)  (3, 7)  (7, 3)  (3, 7)  (3, 7)  (10, 0) (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)\n1       (0, 11) (1, 10) (1, 10) (3, 8)  (4, 7)  (4, 7)  (4, 7)  (7, 4)  (8, 3)  (4, 7)  (10, 1) (11, 0) (-, -)  (-, -)  (-, -)  (-, -)  (-, -)  (-, -)\n6       (0, 17) (1, 16) (1, 16) (3, 14) (4, 13) (4, 13) (4, 13) (7, 10) (8, 9)  (4, 13) (10, 7) (11, 6) (10, 7) (13, 4) (14, 3) (10, 7) (16, 1) (17, 0)\n\nDynamic (2D array)\noptimal difference = 1\nknapsack 1 total weight of all items = 8\nknapsack 2 total weight of all items = 9\n\nitem number 4, weight = 6, indexes = (4, 8) >> knapsack 2\nitem number 3, weight = 1, indexes = (3, 8) >> knapsack 1\nitem number 2, weight = 3, indexes = (2, 7) >> knapsack 2\nitem number 1, weight = 7, indexes = (1, 7) >> knapsack 1\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Twisted Knapsack Problem(unbounded with Fibonacci constraint)\r\n                \r\nI've encountered the following problem during two of my hiring challenges(on HackerEarth).The question is not available online, so here is the problem statement to the best of my memory:\n\nGiven a knapsack with ```\nM```\n weight and ```\nn```\n items, each with a positive weight ```\nw```\n and positive value ```\nv```\n(given as array ```\nweight[]```\n and ```\nval[]```\n ).Every item is available infinite times to be taken.But if you take a item ```\nx```\n number of times, then all the other items(if taken) have to be taken ```\nx```\n number of times.\nHere ```\nx```\n is a Fibonacci number less than 100.\nFind the maximum value you can have while total weight of the knapsack is ```\n<= M```\n.\n\nconstraints:\nn <= 20\n(M, weights, vals)<=1e9\n\n\nSample Test case:\nn=2, M = 125\nweight=[50, 25]\nval   =[100, 51]\n\nfor x=1: max val is 100+51 = 151\n\nfor x=2: max val is 2*100 = 200\n\nfor x=3: max val is 3*51 = 153\n\nfor x=5: max val is 5*51 = 255\n\nfor rest of the x: max val will be 0\n\nCould anyone suggest how to approach it.\nHere is what I did:\n\nGenerated all the possible subsets of items(using bitmasking) and for each subset, I kept on multiplying its weight with ```\nx = 1,2,3,5...```\n until the weight exceeds ```\nM```\n while keeping the count of max val obtained so far.After ```\n2^n```\n iterations, even though I had my answer, but it passed just the 3 out of 15 test cases and got TLEd for the rest.\n    ", "Answer": "\r\nI think one small optimization would pass all test cases. Precalculate the nearest smaller Fibonacci number for x. Now after generating all subset sum , divide m by the sum . Find the nearest smaller Fibonacci number of ( m / sum). Multiply it by sum. So the overall time complexity is O(2^n).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Calculating fitness in Knapsack problem in Jenetics\r\n                \r\nI am trying to understand how evolution and fitness function work. I implemented my own Knapsack problem, which tries to find 3 most valuable items from a given set. It is my own cost function:\n```\n  static int counter=1;\n    static double MyCostFunction(boolean[] chromosome, double[] data){\n        System.out.println(\"COST FUNCTION: \"+counter++);\n        double sum = 0;\n        int count = 0;\n        for (int i =0; i<chromosome.length; i++){\n            if (chromosome[i]){\n                sum += data[i];\n                count ++;\n            }\n        }\n        return  count<=3 ? sum : 0;\n    }\n```\n\nI’m printing out just to see how many times MyCostFunction is performed.\nRight now I am working with a small set of 8 items. Here it is:\n```\npublic static void main(String[] args) {\n        double[] data = {-15,-7, -1, -1,7,100,200,300};\n        Integer[] items = new Integer[data.length];\n        int i = 0;\n        for (double d : data){\n            items[i] = i;\n            i++;\n        }\n\n        ISeq<Integer> zbiorDlaGA = ISeq.of(items);\n\n\n        final ISProblem knapsack= new ISProblem(zbiorDlaGA,\n                chromosome -> ISProblem.MyCostFunction(  chromosome,  data)\n        );\n```\n\nThis is the Engine that I’m using:\n```\nfinal Engine<BitGene,Double> engine= Engine.builder(knapsack)\n                .executor( Runnable::run)\n                .populationSize(5)\n                .survivorsSelector(new TournamentSelector<>(3))\n                .offspringSelector(new RouletteWheelSelector<>())\n                .alterers(\n                        new Mutator<>(1.0),\n                        new SinglePointCrossover<>(0.0)\n                ).build();\n```\n\nAnd that’s how I’m obtaining statistics:\n```\n final EvolutionStatistics<Double,?> statistics=EvolutionStatistics.ofNumber();\n\n        final  Phenotype<BitGene,Double> best=engine.stream()\n               // .limit(bySteadyFitness(15))\n                .limit(5)\n                .peek(r-> System.out.println(\"########CURRENT GEN: \"\n                        +r.generation()+\n                        \": \"+ r.totalGenerations()+\n                        \": \"+r.bestPhenotype()+\n                        \" ALTERED: \"+r.alterCount()+\n                        \" INVALID: \"+r.invalidCount()+\n                        \" GENOTYPE: \"+r.genotypes()))\n                .peek(statistics)\n                .collect(toBestPhenotype());\n\n\n        \n        System.out.println(statistics);\n        System.out.println(best);\n```\n\nI've got a few questions concerning some behaviours of your library that I don't really understand:\nEven when I set mutation probability to 1.0 (it should change every bit, I think so) it gives me this result:\n```\nCOST FUNCTION: 1\nCOST FUNCTION: 2\nCOST FUNCTION: 3\nCOST FUNCTION: 4\nCOST FUNCTION: 5\nCOST FUNCTION: 6\nCOST FUNCTION: 7\nCOST FUNCTION: 8\n########CURRENT GEN: 1: 1: [01100000] -> 300.0 ALTERED: 24 INVALID: 0 GENOTYPE: [[10110100],[00011011],[01011101],[00111001],[01100000]]\nCOST FUNCTION: 9\nCOST FUNCTION: 10\nCOST FUNCTION: 11\n########CURRENT GEN: 2: 2: [00011011] -> 0.0 ALTERED: 24 INVALID: 0 GENOTYPE: [[00011011],[01011101],[10100101],[01111010],[00001011]]\nCOST FUNCTION: 12\nCOST FUNCTION: 13\nCOST FUNCTION: 14\n########CURRENT GEN: 3: 3: [10100101] -> 0.0 ALTERED: 24 INVALID: 0 GENOTYPE: [[10100101],[01011101],[01111011],[01010011],[10010101]]\nCOST FUNCTION: 15\nCOST FUNCTION: 16\nCOST FUNCTION: 17\n########CURRENT GEN: 4: 4: [10000010] -> 293.0 ALTERED: 24 INVALID: 0 GENOTYPE: [[01011101],[01010011],[01111011],[10000010],[00001001]]\nCOST FUNCTION: 18\nCOST FUNCTION: 19\nCOST FUNCTION: 20\n########CURRENT GEN: 5: 5: [10000010] -> 293.0 ALTERED: 24 INVALID: 0 GENOTYPE: [[10000010],[01011101],[01000100],[10111100],[10011001]]\n+---------------------------------------------------------------------------+\n|  Time statistics                                                          |\n+---------------------------------------------------------------------------+\n|             Selection: sum=0,003352000000 s; mean=0,000670400000 s        |\n|              Altering: sum=0,010647600000 s; mean=0,002129520000 s        |\n|   Fitness calculation: sum=0,011403300000 s; mean=0,002280660000 s        |\n|     Overall execution: sum=0,033579600000 s; mean=0,006715920000 s        |\n+---------------------------------------------------------------------------+\n|  Evolution statistics                                                     |\n+---------------------------------------------------------------------------+\n|           Generations: 5                                                  |\n|               Altered: sum=120; mean=24,000000000                         |\n|                Killed: sum=0; mean=0,000000000                            |\n|              Invalids: sum=0; mean=0,000000000                            |\n+---------------------------------------------------------------------------+\n|  Population statistics                                                    |\n+---------------------------------------------------------------------------+\n|                   Age: max=4; mean=0,560000; var=1,090000                 |\n|               Fitness:                                                    |\n|                      min  = -23,000000000000                              |\n|                      max  = 300,000000000000                              |\n|                      mean = 41,840000000000                               |\n|                      var  = 10763,306666666665                            |\n|                      std  = 103,746357365773                              |\n+---------------------------------------------------------------------------+\n[01100000] -> 300.0\n```\n\nWhy does it calculate fitness for three individuals only? Is it somehow caching the values already calculated for the same chromosome?\nAnd why in the first generation it is calculated 8 times?\nThe number of altered individuals is always 3*8, what implies that only 3 chromosomes were modified during the evolution. Why? I thought it has something to do with TournamentSelector sampleSize, but it doesn’t change number of changed chromosomes.\nWith the probability of mutation equal to 100% and crossover prob.=100% it should change every bit in chromosome, so there will only be 2 versions of chromosome in each generation, but it doesn’t work like that. Why? Does it randomly select value of bit or sets the opposite?\nDoes the number of bits set to true have to be a constant one(or approximately constant) in population/generation?\nI am using these strange values for crossover and mutation probabilities, because I was wondering earlier why it didn’t give the number of fitness calculations performed equal to populationSize*NumberOfGenerations. So I started to experiment.\n    ", "Answer": "\r\nThe described behavior is as expected :)\nThe following facts leads to the observed outcome:\n\nDuring the evolution process, the population is divided into offspring and survivors.\nOnly the offspring is target for the alterers (mutation operation).\nThe default offspring fraction is set to 0.6, which makes an offspring count of 3 for your example.\nThe fitness values of unchanged individuals is cached.\n\nThe outcome:\n\nThe reason for the first five fitness evaluations is induced by the fresh, initial population of 5.\nThe next three evaluations are due to the three offspring individuals, which has been mutated with 100% certainty.\nThe subsequent evaluation blocks of three evaluations have the same reason.\n\nI think this explains the output, doesn't it?\nControl the number of initially set bits\nIf you want to control the number of initial bits of the ```\nBitChromosome```\n, you can use the original ```\nCodec```\n to create your own variation.\n```\npublic static <T> InvertibleCodec<ISeq<T>, BitGene>\nofSubSet(final ISeq<? extends T> basicSet, final double onesProbability) {\n    final InvertibleCodec<ISeq<T>, BitGene> codec = Codecs.ofSubSet(basicSet);\n    return InvertibleCodec.of(\n        Genotype.of(BitChromosome.of(basicSet.length(), onesProbability)),\n        codec.decoder(),\n        codec.encoder()\n    );\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Non-existence of approximation algorithm for the knapsack problem\r\n                \r\nI am working on the following exercise: Prove that if $P \\neq NP$, there cannot exist an approximation algorithm $A$ for the knapsack problem (KP) such that $\\exists k \\in \\mathhbb{N}, \\forall I \\in S: OPT(I) - P_A(I) \\leq k$ where $OPT(I)$ is the optimal profit on instance $I$ and $P_A(I)$ is the profit calculated by $A$.\n\nI know that there is a FPTAS $A'$ for the KP which guarantees a solution with profit $P_{A'}(I) \\geq (1 - \\varepsilon)OPT(I)$ on any instance $I$ and $\\varepsilon > 0$. \n\nMy approach is to create a contradiction. For this I consider $A = A'$ and aim to show that $P_A(I) \\geq (1 - \\varepsilon)OPT(I) \\geq ... \\geq OPT(I) - c$ where $c \\in (0,1)$ is a constant. This way, for an adequate choice of $\\varepsilon$ I would show that we obtain an optimal solution within polynomial time. However, I struggle how to choose $\\varepsilon$.\n\nI need some advice on how to proceed. Many thanks in advance!\n    ", "Answer": "\r\nThe contradiction is a bit more subtle.\n\nConsider an instance ```\nI'```\n derived from ```\nI```\n by increasing all the values of the items in ```\nI```\n ```\nn```\n-fold. An optimal profit ```\nOpt(I')```\n is ```\nn```\n-times the optimal profit of ```\nOpt(I)```\n, and the solution to both problems is comprised by the same set of items (prove it!). \n\nSo, if ```\nA```\n finds the ```\nOpt(I') - k```\n solution, it also finds an ```\nOpt(I) - k/n```\n one. Making ```\nn```\n large enough, conclude ```\nA```\n would solve any instance ```\nI```\n better than ```\nOpt(I) * (1 - eps)```\n for any given ```\neps```\n.\n\nFor the integer values it is enough to take any ```\nn > k```\n. For the real values you need some more work, namely to prove that ```\nA'```\n is not universal, but must depend on ```\neps```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to know which item was selected in the knapsack problem(DP implementation)?\r\n                \r\nI am implementing the knapsack problem based on this code and I want to know which items were finally selected.\n\nthe code:\n\n```\nKnapsack { \n\n\nstatic int max(int a, int b)  { return (a > b) ? a : b; } \n\n\nstatic int knapSack(int W, int wt[], int val[], int n) \n{ \n    int i, w; \n    int K[][] = new int[n + 1][W + 1]; \n\n    // Build table K[][] in bottom up manner \n    for (i = 0; i<= n; i++) { \n        for (w = 0; w<= W; w++) { \n            if (i == 0 || w == 0) \n                K[i][w] = 0; \n            else if (wt[i - 1]<= w) \n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]); \n            else\n                K[i][w] = K[i - 1][w]; \n        } \n    } \n\n    return K[n][W]; \n} \n\n\npublic static void main(String args[]) \n{ \n    int val[] = new int[] { 60, 100, 120 }; \n    int wt[] = new int[] { 10, 20, 30 }; \n    int W = 50; \n    int n = val.length; \n    System.out.println(knapSack(W, wt, val, n)); \n\n     } \n\n  } \n```\n\n\nWhat I want to do though is to find which items were finally inserted in to the knapsack based on how they were originally stored in the array and store those results on a file in binary format.\n\nWhat I mean is, here we have 3 items in this piece of code and if for example item number 1 (the one that has a value of 60) and item number 3(the one that has a value of 120) were finally selected ,I would like to get a string that would look like that 1,0,1 \n    ", "Answer": "\r\nYou can add the following to your code just before the return statement:\n\n```\n        int ind = n;\n        int weight = W;\n        String s = \"\";\n        while (ind > 0) {\n            if (K[ind][weight] != K[ind - 1][weight]) {\n                s = \"1,\" + s;\n                weight -= wt[ind - 1];\n            }\n            else {\n                s = \"0,\" + s;\n            }\n            ind -= 1;\n        }\n        s = s.substring(0, s.length() - 1);\n        System.out.println(s);\n```\n\n\nThis code essentially backtracks from the final solution to see whether the maximum with i items is equivalent to the maximum with i - 1 items (which indicates whether the ith item was used).\n\nAfter adding this to your code, I get the following output, which appears to be correct:\n\n```\n0,1,1\n220\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do I solve a Knapsack Problem with minimizing value?\r\n                \r\nI am given a file of meals containing their calories and fat value information in that form --> \n\n330 350 100 230 //This is Calories\n30 27 10 10 //This is fat\n\nThe user can also input a \"wanted calories\" amount. \n\nMy task is to use dynamic programming in order to create an algorithm that outputs the amount of calories and a list of the meals used to reach it. Each meal can only be used once, the fat needs to be minimized, and my output of calories needs to be as close as possible to the \"wanted calories\" amount that I got as input...\n\nI figured that this is quite similar to the knapsack problem with my \"wanted calories\" being the capacity of my bag, the calories being the weight of each item and the fat being the value of each item. \n\nThe problem as far as i can tell is that unlike the normal knapsack problem where the value needs to be maximized, in this case it needs to be minimized. \n\nprivate int minimumFat(int wantedCalories, int[] calories, int[] fat) {     \n\n```\n    int n = fat.length;\n\n    int min_fat[][] = new int[n+1][wantedCalories+1];\n\n    // Fill 0th Row with infinity\n    for (int i=0; i <= wantedCalories; i++) {\n        min_fat[0][i] = Integer.MAX_VALUE;\n    }\n\n    // Fill 0th Column with 0\n    for (int i=1; i<=n; i++) {\n        min_fat[i][0] = 0;\n    }\n\n    // Check each weight one by one\n    for (int i=1; i<=n; i++) {\n        System.out.println(i + \")\");\n        for (int j=1; j<=wantedCalories; j++) {\n            if (calories[i-1] > j) {\n                min_fat[i][j] = min_fat[i-1][j];\n            } else {\n                min_fat[i][j] = Math.min(min_fat[i-1][j], min_fat[i][j-calories[i-1]] + fat[i-1]);\n            }\n            System.out.print(min_fat[i-1][j-1] + \" \");\n        }\n    }\n\n    return min_fat[n][wantedCalories];\n}\n```\n\n\nWhen running the above code my results are negative which as far as I can tell happens because Integer.MAX_VALUE overflows. I am not sure how I am supposed to continue from here since no matter what I put inside the Math.min it will always favor min_fat[i-1][j]. I expected the output to be the amount of fat used by the meal plan so that I could then trace back and find the total amount of calories used as well as the items that made the meal plan but that's clearly not what happened.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "To which Knapsack-problem variation does this problem correspond?\r\n                \r\nLet us imagine that I have to fill my knapsack with items under constraints:\n\nEach item has an associated weight wi and profit pi\nWith a maximum total weight Wmax\n\nKnowing that:\n\nThere are categories of items and I have to choose exactly one item from each category\nOf course, the aim is to choose items to maximise the sum of the profits\n\nExample : Wmax=400\n\n\n\n\nBooks\nBooks weights\nBooks profits\nFood\nFood weights\nFood profits\n\n\n\n\nThe Bible\n500\n25\nCheese\n80\n120\n\n\nThe little prince\n150\n5\nBanana\n250\n200\n\n\n\n\nHere, the best solution  is (The little prince, Banana)\nI have a similar problem and I'd like to find out the best way to code it but I can't figure out what version/ variation of the probleme this is, is it a known variation ?\n    ", "Answer": "\r\nI’m not sure if there’s an existing variation that matches yours, but it’s easy to draw inference from the classical variant and solve this.\nClassic variant has 2D dynamic programming (```\nDP[N][W]```\n, where ```\nN```\n and ```\nW```\n are number of items and max weight).\nIn this variant, since we can only pick one of each category, you can use 3D DP like ```\ndp[i][w][j]```\n, which denotes the maximum value you can get from the first ```\ni```\n items with weight ```\nw```\n and ```\nj```\n is a 0/1 int denoting whether an item from category number ```\nj```\n has been selected or not.\nI’ll leave the implementation, since the recursive relation is relatively simple and quite similar to the classic variant.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why is cvxpy (solver=GLPK_MI) so slow on this knapsack problem?\r\n                \r\nI'm trying to use cvxpy to solve a knapsack problem with varying available quantities of items, and seeing it run much slower with some quantities than others.\n(My objective here is to minimize wasted capacity, so values=weights.)\n```\nimport cvxpy as cp\nfrom cvxpy.atoms.affine.binary_operators import multiply as element_multiply\nimport time\n\nweights = [1190, 1380, 715, 1372, 735, 1360, 775, 930, 1352, 870, 1225, 1185, 1180, 1100, 1220, 890, 840, 935, 1215, 1060, \n          1202, 1095, 1200, 1105, 1164, 1140, 900, 650, 1080, 725, 660, 1070, 905, 1044, 910, 1000, 977, 950, 750, 945, \n          920, 770, 940, 810, 795, 860, 855, 845, 836, 865, 625, 915, 680, 885, 880, 825, 850, 830, 730, 700, 790, 740, \n          675, 690, 655, 695, 1370, 1210, 720, 975, 745, 685, 1135, 1160, 1010, 1150, 1090, 1020, 635, 1015, 995, 765, \n          990, 665, 960, 800, 710, 895, 612, 645, 815, 844, 670, 640, 820, 780, 842]\n\nlimits1 = [2, 1, 2, 0, 1, 0, 2, 2, 0, 0, 0, 0, 1, 1, 1, 2, 1, 5, 0, 1, 1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 3, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 2, 3, 1, 3, 0, 2, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]\n\nlimits2 =  [2, 1, 2, 0, 1, 0, 3, 2, 0, 1, 0, 1, 1, 2, 1, 2, 2, 6, 0, 1, 1, 0, 1, 0, 0, 0, 2, 0, 0, 1, 2, 0, 1, 0, 0, 0, 0, 0, 0, 1, 2, 1, 3, 3, 1, 0, 1, 1, 0, 1, 0, 0, 2, 0, 2, 3, 1, 3, 0, 2, 1, 1, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]\n\nlimits3 = [3, 1, 2, 0, 1, 0, 3, 2, 0, 1, 1, 1, 2, 2, 1, 2, 2, 7, 0, 1, 1, 0, 1, 0, 0, 0, 3, 0, 0, 2, 2, 1, 1, 1, 1, 0, 1, 1, 0, 1, 3, 1, 3, 3, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 3, 2, 3, 0, 2, 1, 1, 0, 1, 0, 2, 0, 0, 1, 0, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]\n\nlimits4 = [3, 2, 2, 0, 1, 1, 4, 3, 0, 1, 1, 1, 2, 2, 2, 3, 2, 8, 0, 1, 1, 0, 1, 0, 0, 0, 3, 0, 0, 2, 2, 1, 2, 1, 1, 0, 1, 1, 0, 1, 3, 1, 4, 4, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 4, 2, 4, 1, 3, 1, 1, 0, 1, 0, 2, 0, 0, 1, 0, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 2, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]\n\nw = cp.Constant(weights)\nx = cp.Variable(len(weights),integer=True)\nv = cp.Parameter(shape=(len(weights),))\n\nkstart = time.time()\nprob = cp.Problem(cp.Maximize(sum(element_multiply(w,x))),[sum(element_multiply(w,x)) <= 8350,\n                                                                    x >= 0, \n                                                                    x <= v])\nkend = time.time()\nprint(\"Setup time:\", kend-kstart)\n\nkstart = time.time()\nv.value = limits1 \nprob.solve(solver = 'GLPK_MI',warm_start=True)\nkend = time.time()\nprint(\"First set time:\", kend-kstart)\n\nkstart = time.time()\nv.value = limits2\nprob.solve(solver = 'GLPK_MI',warm_start=True)\nkend = time.time()\nprint(\"Second set time:\", kend-kstart)\n\nkstart = time.time()\nv.value = limits3\nprob.solve(solver = 'GLPK_MI',warm_start=True)\nkend = time.time()\nprint(\"Third set time:\", kend-kstart)\n\nkstart = time.time()\nv.value = limits4\nprob.solve(solver = 'GLPK_MI',warm_start=True)\nkend = time.time()\nprint(\"Fourth set time:\", kend-kstart)\n\n```\n\nOut:\n```\nSetup time: 0.00698089599609375\nFirst set time: 0.06086540222167969\nSecond set time: 4.375271320343018\nThird set time: 2.5631792545318604\nFourth set time: 0.003981351852416992\n```\n\nThese are 4 iterations out of about 20 I'm running with increasing item limits. Most of the other iterations, like the first and fourth here, are < 0.1s. I've tried running each variation as a model with only the non-zero items available, and it gives me the same result.\nI don't understand what's happening here. What can I do to get these ones in line?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem with multiple availabe packages using dynamic programming\r\n                \r\nHello and thanks for helping! \nSo we've got a list of fireworks containing  1) Number in stock  2) Number of fireworks in this package  3) Diameter which equals the noise and  \n4) The price.\n\nThis is the list: \n25 17 10 21 \n10 15 10 18 \n  5 16 10 19 \n10 15 12 20 \n15   9  11 12 \n10   7  28 23 \n  8   7  16 11 \n10   6  16 10 \n25 10 18 25 \n25 12 18 27 \n10   5  40 35 \n60 40   5 27 \n  5  25 30 90 \n50   1  60   8 \n\nOur task is to create a shopping list and buy fireworks so we get the highest possible noise. We've got a knapsack capacity of 1000€. We're also supposed to solve this without using tables (so with dynamic programming instead).\n\nI only use one class called Package which contains the four constraints as shown above.\n\nAt first I thought it would make sense to try to write an algorithm for a normal knapsack, so just with the price and the diameter (=weight). I tested it with a different list and it worked perfectly fine. I just iterated through all packages and then again used a nested for loop to find the best constellation (exhaustive search). My next idea was to merge the number of fireworks per package with the diameter, because fireworks can only be bought in a full package. \n\nThe only thing left which I still haven't found out is what to do with the amount of packages in stock. Like, with my current algorithm it just buys all packages of a firework until the knapsack is full. But obviously that won't be correct.\n\n```\nvoid knapsack(vector<Package*> stock){\n    vector<int> indices, tmp_indices;\n    int noise,tmp_noise= 0;\n    int price;\n\n    for (unsigned int i = 0; i < stock.size(); i++) {\n\n        price = stock[i]->price;\n        noise = stock[i]->diameter*stock[i]->number_fireworks; \n\n        indices.push_back(i);\n\n        for (unsigned int j = 0; j < stock.size(); j++) {\n            if (i != j) {\n\n                if (price+stock[j]->price<= BUDGET) {\n                    price+=stock[j]->price;\n                    noise+=stock[j]->diameter*stock[j]->number_fireworks;\n                    indices.push_back(j);\n                }\n            }\n\n        }\n\n        // After second loop we have a new possible constellation\n        // Check if the previous constellation had a lower value and if so, set it to the current one\n\n        if (noise > tmp_noise) {\n            tmp_noise = noise;\n            tmp_indices.clear();\n\n            // tmp save\n            for (auto &index : indices) {\n                tmp_indices.push_back(index); \n            }\n\n        }\n        price= 0;\n        noise = 0;\n        indices.clear();\n\n    }\n\n\n    // Best constellation found, Print the shopping list\n    cout << \"\\Stock.\\tNum\\Diameter.\\Price\\n\" << endl;\n    for(unsigned int i = 0; i < tmp_indices.size(); i++) {\n\n        cout << stock[tmp_indices[i]]->stock<< \"\\t\";\n        cout << stock[tmp_indices[i]]->number_fireworks<< \"\\t\";\n        cout << stock[tmp_indices[i]]->diameter<< \"\\t\";\n        cout << stock[tmp_indices[i]]->price<< \"\\t\\n\";\n    }\n\n }\n```\n\n\nWe've been told that we should be able to spend exactly 1000€ to get the correct constellation of fireworks. My idea was to add another for loop to iterate through the amount of available packages, but that didn't really work...\n\nThis was our first lesson and I'm a bit desperate, because we have only learned how to solve a knapsack problem with 2 constraints and by using a table R. \n\nEdit: Since one user insisted to get a specific question, here it is: Is the idea of using another loop to include the third constraint correct or is there a better/easier way of doing it? Or is it possible that I need a completely different approach for a knapsack with 3 instead of 2 constraints?\n\nThanks for help in advance\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Bounded Knapsack Problem in time O(NW) and space O(W)\r\n                \r\nI'm trying to implement Bounded Knapsack Problem in O(NW) time and O(W) space, where N is number of items and W is capacity.\nBounded Knapsack Problem:\n\nThere are N types of items (k_i copies of item i with weight w_i and cost c_i). Maximise total cost of items with weight less or equal to W.\n\nMy approach:\nUse dynamic programming, create a table DP (rows are items, columns are capacities, DP[ i ][ j ] is max cost of items 1, 2,...,i with total weight not greater than j). The answer will be max of DP[N]. To complete row i we only need values from row i - 1, thus, we can calculate the last row by keeping track of only two rows. Hence, O(W) space.\n\nThus, using queue we can compute all cells of type DP[ i ][start + step * w_i] in one go, which implies that we can complete each row in O(W) time. (I use queue with O(1) amortised time max operation)\nHere's my implementation:\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\n\n\nclass MyQueue {\n    std::deque<int64_t> Deq_;\n    std::deque<int64_t> Max_;\npublic:\n    void push(int64_t element) {\n        Deq_.push_back(element);\n        while (!Max_.empty() and Max_.back() < element) {\n            Max_.pop_back();\n        }\n        Max_.push_back(element);\n        }\n    void pop() {\n        if (Max_.front() == Deq_.front()) {\n            Max_.pop_front();\n        }\n        Deq_.pop_front();\n    }\n\n    int max() {\n        return Max_.front();\n    }\n};\n\n\nint main() {\n    int number_of_items, capacity;\n    std::cin >> number_of_items >> capacity;\n    std::vector<int64_t> dp_cur(capacity + 1, 0);\n    std::vector<int64_t> dp_prev(capacity + 1, 0);\n\n    int64_t weight, cost, num;\n    for (int item = 0; item < number_of_items; ++item) {\n        dp_cur.swap(dp_prev);\n        std::cin >> weight >> cost >> num;\n        for (int start = 0; start < weight; ++start) {\n            if (item == 0) {\n                for (int step = 0; start + step * weight < capacity + 1; ++step) {\n                    if (step == 0) {\n                        dp_cur[start + step * weight] = 0;\n                    } else if (step < num + 1) {\n                        dp_cur[start + step * weight] = dp_cur[start + (step - 1) * weight] + cost;\n                    } else {\n                        dp_cur[start + step * weight] = dp_cur[start + (step - 1) * weight];\n                    }\n                }\n            } else {\n                MyQueue que;\n                int64_t penalty = cost;\n                for (int step = 0; start + step * weight < capacity + 1; ++step) {\n                    penalty -= cost;\n                    if (step > 1) {\n                        if (step > num) {\n                            que.pop();\n                        }\n                        dp_cur[start + step * weight] =\n                                std::max(dp_prev[start + step * weight], que.max() - penalty);\n                    } else if (step == 1) {\n                        dp_cur[start + step * weight] =\n                                std::max(dp_prev[start + step * weight], dp_cur[start] + cost);\n                    } else {\n                        dp_cur[start + step * weight] = dp_prev[start + step * weight];\n                    }\n                    que.push(dp_prev[start + step * weight] + penalty);\n                }\n            }\n        }\n    }\n\n\n    std::cout << *std::max_element(dp_cur.begin(), dp_cur.end());\n\n    return 0;\n}\n```\n\nInput format:\nFirst line contains N and W. Next N lines contain w_i, c_i, k_i.\nThe problem is that my implementation gives a wrong solution on some test (I cannot see the contents of it) and it seems that my second implementation (worse asymptotic) has the same problem. Could you please tell me where the problem might be or where I could find test cases? I only found this problem, but my (adapted) solution passes all tests.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python Knapsack problem - using the average value of the selected items as a constraint?\r\n                \r\nI'm still relatively new to python so I'm having trouble figuring out how to accomplish a certain feat.\nWhat I'm trying to do: I have an Excel file with two columns - Sell and margin. There could be a variable number of rows. I need to find a \"best fit\" where the sum of n# of Sell rows is within 5% of a target sell amount AND where the avg margin is also within 5% of a target margin % (if there is a solution, if not increase the % tolerances and run again. But I can figure that out later).\nFrom my googling, I learned this a multi-constraint knapsack problem and I was able to find some examples to work off of.\nThe code I borrowed is from here: https://towardsdatascience.com/solving-the-multiple-knapsack-problem-with-google-or-tools-e961dfc8288e\nMy problem: I can't figure out how to set a constraint where the average margin of the items placed in the bag are near the target average margin.\nHere's my modified code from the above site where I'm using random data for sell and margin:\n```\nfrom ortools.linear_solver import pywraplp\n\nsolver = solver = pywraplp.Solver.CreateSolver('SCIP')\n\ndata = {}\nsell = [8520,9600,5340,8379,846,1098,1510,4954,1039,620,795,3260,75,200,75]\nmargin = [25, 25, 25, 34, 25, 25, 25, 25, 25, 25, 27, 20, 100, 27, 100]\n\nassert len(sell) == len(margin)\ndata['values'] = values\ndata['sell'] = sell\ndata['margin'] = margin\ndata['items'] = list(range(len(sell)))\ndata['num_items'] = len(sell)\nnumber_bags = 1 #All have the same capacity of 50 pounds\ndata['target_amount'] = [9262]\ndata['avg_margin'] = [27] \ndata['bags'] = list(range(number_bags))\nassert len(data['target_amount']) == number_bags\nassert len(data['target_amount']) == len(data['avg_margin'])\nprint('sell:',*data['sell'])\nprint('margin:',*data['margin'])\nprint(\"Number of Items:\", data['num_items'])\nprint(\"Number of Knapsacks:\" , number_bags)\n\nx = {}\nfor i in data['items']:\n    for j in data['bags']:\n        x[(i,j)] = solver.IntVar(0,1,'x_%i_%i' % (i, j))\n\n#Constraint for an item being placed in 1 knapsack\nfor i in data['items']:\n    solver.Add(sum(x[i,j] for j in data['bags'])<=1)\n    \n#Knapsack Capacity Constraint\nfor j in data['bags']:\n    solver.Add(sum(x[(i,j)]*data['sell'][i] \n                  for i in data['items']) <= data['target_amount'][j])\n#margin Constraint\n#for j in data['bags']:\n#    solver.Add(sum(x[(i,j)]*data['margin'][i]\n#                  for i in data['items']) <= data['target_amount'][j])\n\n#objective function\nobjective = solver.Objective()\nfor i in data['items']:\n    for j in data['bags']:\n        objective.SetCoefficient(x[(i,j)], data['sell'][i])\nobjective.SetMaximization()\n\nsolv = solver.Solve()\nif solv == pywraplp.Solver.OPTIMAL:\n    print('Total Packed Value:', objective.Value())\n    total_Sell = 0\n    for j in data['bags']:\n        bag_Sell = 0\n        avg_margin= 0\n        count = 0\n        print('\\n','Bag', j+1 , '\\n')\n        for i in data['items']:\n            if x[i,j].solution_value()>0:\n                print('Line:', i , \n                      'Sell', data['sell'][i], \n                      'margin',data['margin'][i],\n                     )\n                bag_Sell += data['sell'][i]\n                avg_margin += data['margin'][i]\n                count += 1\n        print('Packed Knapsack Sell: ', bag_Sell)\n        print('Packed Knapsack margin: ', round(avg_margin / count, 2))\nelse:\n    print(\"There is no optimal solution\")\n\n\nIs this even possible? Am I just way out of my league?\n\nThanks\n```\n\n    ", "Answer": "\r\nAdding an average Margin constraint is not very difficult, once you write things down.\nConstraint to keep the Average margin within two bounds\nTo your model you would add the following:\n```\nmin_acceptable_margin = data['target_margin'][0] * 0.95\nmax_acceptable_margin = data['target_margin'][0] * 1.05\n\n#Average Margin Constraints\nfor j in data['bags']:\n   solver.Add(sum(x[(i,j)]*data['margin'][i] - x[(i,j)] * min_acceptable_margin\n                 for i in data['items']) >= 0 , name=f\"GT_Target_Avg\")\n   solver.Add(sum(x[(i,j)]*data['margin'][i] - x[(i,j)] * max_acceptable_margin\n                 for i in data['items']) <= 0 , name=f\"LT_Target_Avg\")\n```\n\nAs you can see, we write out the terms to keep the constraint Linear in our LP.\nSince you say you are new to Python, I am providing the full code:\nFull Working Code (OR-Tools LP)\n```\nfrom ortools.linear_solver import pywraplp\nsolver = solver = pywraplp.Solver.CreateSolver('SCIP')\n\nsell = [8520,9600,5340,8379,846,1098,1510,4954,1039,620,795,3260,75,200,75]\nmargin = [25, 25, 25, 34, 25, 25, 25, 25, 25, 25, 27, 20, 100, 27, 100]\ntarget_margin = [40]\nbag_capacities = [9262]\n\n\ndef prepare_data():\n  data = {}\n  assert len(sell) == len(margin)\n  data['sell'] = sell\n  data['margin'] = margin\n  data['items'] = list(range(len(sell)))\n  data['num_items'] = len(sell)\n  number_bags = 1 \n  data['target_amount'] = bag_capacities\n  data['target_margin'] = target_margin\n  data['bags'] = list(range(number_bags))\n  assert len(data['target_amount']) == number_bags\n  assert len(data['target_amount']) == len(data['target_margin'])\n  print('sell:',*data['sell'])\n  print('margin:',*data['margin'])\n  print(\"Number of Items:\", data['num_items'])\n  print(\"Number of Knapsacks:\" , number_bags)\n\n  return data\n\n\ndata = prepare_data()\nprint(data)\n\n\n#Start Formulating the problem\nx = {}\nfor i in data['items']:\n    for j in data['bags']:\n        x[(i,j)] = solver.IntVar(0,1,'x_%i_%i' % (i, j))\n\n#Constraint for an item being placed in 1 knapsack\nfor i in data['items']:\n    solver.Add(sum(x[i,j] for j in data['bags'])<=1, name=\"Max_One_Item\"+str(i))\n\n#Knapsack Capacity Constraint\nfor j in data['bags']:\n    solver.Add(sum(x[(i,j)]*data['sell'][i] \n                  for i in data['items']) <= data['target_amount'][j], name=f\"BagCapacity_{i}\")\n\n#Average Margin Constraints\nmin_acceptable_margin = data['target_margin'][0] * 0.95\nmax_acceptable_margin = data['target_margin'][0] * 1.05\n\nfor j in data['bags']:\n   solver.Add(sum(x[(i,j)]*data['margin'][i] - x[(i,j)] * min_acceptable_margin\n                 for i in data['items']) >= 0 , name=f\"GT_Target_Avg\")\n   solver.Add(sum(x[(i,j)]*data['margin'][i] - x[(i,j)] * max_acceptable_margin\n                 for i in data['items']) <= 0 , name=f\"LT_Target_Avg\")\n\n#objective function\nobjective = solver.Objective()\nfor i in data['items']:\n    for j in data['bags']:\n        objective.SetCoefficient(x[(i,j)], data['sell'][i])\nobjective.SetMaximization()\n\n#Call the solver\nsolv = solver.Solve()\n\n#Print the results\nif solv == pywraplp.Solver.OPTIMAL:\n    print('Total Packed Value:', objective.Value())\n    total_Sell = 0\n    for j in data['bags']:\n        bag_Sell = 0\n        avg_margin= 0\n        count = 0\n        print('\\n','Bag', j+1 , '\\n')\n        for i in data['items']:\n            if x[i,j].solution_value()>0:\n                print('Selected:', i , \n                      'Sell', data['sell'][i], \n                      'margin',data['margin'][i],\n                     )\n                bag_Sell += data['sell'][i]\n                avg_margin += data['margin'][i]\n                count += 1\n        print('Packed Knapsack Sell: ', bag_Sell)\n        print('Avg Packed Knapsack margin: ', round(avg_margin / count, 2))\n        print(f'Target Margin {data[\"target_margin\"][0]} (Min {min_acceptable_margin} Max {max_acceptable_margin})')\nelse:\n    print(\"There is no optimal solution\")\n```\n\nWhen I ran it with the numbers above, I got the following result:\n```\nTotal Packed Value: 9109.0\n\n Bag 1 \n\nSelected: 7 Sell 4954 margin 25\n\nSelected: 9 Sell 620 margin 25\nSelected: 11 Sell 3260 margin 20\nSelected: 12 Sell 75 margin 100\nSelected: 13 Sell 200 margin 27\nPacked Knapsack Sell:  9109\nAvg Packed Knapsack margin:  39.4\nTarget Margin 40 (Min 38.0 Max 42.0)\n```\n\nUseful Commands when debugging\nA couple of handy commands to know which will help you debug your LP:\n```\nprint('Number of variables =', solver.NumVariables())\n\nprint('Number of constraints =', solver.NumConstraints())\n```\n\nFinally, one last very useful trick. It is good to write out the formulation that the solver is seeing.\n```\n#Use this to print out the ORTOOLS Formulation\nprint(solver.ExportModelAsLpFormat(False).replace('\\\\', '').replace(',_', ','), sep='\\n')\n```\n\nHope that helps you move forward.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Unbounded Knapsack and Classical Knapsack Comparison\r\n                \r\nI have read two distinct problem 0-1 Knapsack Problem and Unbounded Knapsack Problem on the internet. I found that these two problems are both solved by Dynamic Programming but in two different way.\nIf 0-1 Knapsack Problem is solved by using two dimension array, Unbounded Knapsack Problem only utilizes one dimension array.\nYou can read more 0-1 Knapsack Problem and Unbounded Knapsak Problem\nThe difference in these two problem, as I know, is that the 0-1 Knapsack Problem only contains the limited amount of things, while Unbounded Knapsack Problem enables to take 1 or more instances of any resource. However, I do not know why it changes the way to solve this problem? Can you give me the reason for this?\n    ", "Answer": "\r\nTable approach is simpler to explain and debug, that is why algorithm decriptions usually show such way.\nNote that for 0-1 Knapsack Problem we must exclude possibility to reuse item twice. So at every step of outer loop we update previous best results using current item.\nBut we use only the last row of table (look at indices ```\ni```\n and ```\ni-1```\n), so we can diminish table size to ```\n2 x Capacity```\n using only current and last rows.\nMoreover, we can use approach with one-dimensional array, applying a trick - to avoid reusing item, we can perform traversal in backward direction.\nPython code below uses data from wiki page and shows both table and linear array implementations.\n```\nwt = [23,26,20,18,32,27,29,26,30,27]\nval = [505,352,458,220,354,414,498,545,473,543]\n\ndef knap1(w,v, cap):\n    n = len(w)\n    m = [[0]*(cap+1) for _ in range(n)]\n    for i in range(n):\n        for j in range(cap + 1):\n            if w[i] > j:\n                m[i][j] = m[i-1][j]\n            else:\n                m[i][j] = max(m[i-1][j], m[i-1][j-w[i]] + v[i])\n    return m[n-1][cap]\n\ndef knap2(w,v, cap):\n    n = len(w)\n    m = [0]*(cap+1)\n    for i in range(n):\n        for j in range(cap, w[i]-1,-1):\n                m[j] = max(m[j], m[j-w[i]] + v[i])\n    return m[cap]\n\n\nprint(knap1(wt, val, 67))\nprint(knap2(wt, val, 67))\n\n>>1270\n>>1270\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "how to improve the running time for knapsack problem from O(N*M) to O(N)?\r\n                \r\nI'm currently doing a algorithm assignment for knapsack problem, the question is as follow:\nThe size of knapsack is M, and there are N items each with a integer value and integer weight, we need to figure out the optimal maxium weight that we can put into the knapsack.\nI'm using dynamic programming to solve this problem and save the result only for current and the previous loops which takes M2 space, although it saves space, the time complexity for it is still O(MN) as there two for loops, is there any way to improve this?\nThanks\n    ", "Answer": "\r\nThis is a pseudo-polynomial order which means it will take same time no matter how we design the dynamic algorithm approach because the knapsack problem is among np classical problems.\nThanks\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Algorithm design: can you provide a solution to the multiple knapsack problem?\r\n                \r\nI am looking for a pseudo-code solution to what is effectively the Multiple Knapsack Problem (optimisation statement is halfway down the page). I think this problem is NP Complete so the solution doesn't need to be optimal, rather if it is fairly efficient and easily implemented that would be good. \n\nThe problem is this:\n\n\nI have many work items, with each taking a different (but fixed and known) amount of time to complete.  \nI need to divide these work items into groups so as to have the smallest number of groups (ideally), with each group of work items taking no longer than a given total threshold - say 1 hour. \n\n\nI am flexible about the threshold - it doesnt need to be rigidly applied, though should be close. My idea was to allocate work items into bins where each bin represents 90% of the threshold, 80%, 70% and so on. I could then match items that take 90% to those that take 10%, and so on.\n\nAny better ideas?\n    ", "Answer": "\r\nYou need http://www.or.deis.unibo.it/knapsack.html,  chapter 6.6 \"Multiple knapscack problem - Approximate algorithms\". There is pseudo-code (Pascal style) in the text and Fortran implementations (yes, it's an old book) as a ZIP file.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to display all included numbers in KnapSack problem?\r\n                \r\nI have a problem with displaying used numbers. I'm using KnapSack algorithm and I want to display all numbers that I used to get highest value. So there is my code:\n\n```\nstatic int max(int a, int b)\n{\n    int c = (a > b) ? a : b;\n    Console.WriteLine(c);\n    return (a > b) ? a : b;\n}\n\n// Returns the maximum value that can \n// be put in a knapsack of capacity W            \nint knapSack(int[] r, int[] wt, int n, int W)\n{\n\n    if (W < 0)\n        return Int32.MinValue;\n    if (n < 0 || W == 0)\n        return 0;\n    int include = r[n] + knapSack(r, wt, n, W - wt[n]);\n    int exclude = knapSack(r, wt, n - 1, W);\n    int V = max(include, exclude);\n    return V;\n}\n```\n\n\nUse:\n\n```\nint[] r = new int[] { 3, 4, 8, 5, 6 };\nint[] wt = new int[] { 2, 2, 3, 4, 7 };\nint W = 11;\nint z = W;\nint n1 = r.Length;\nstopwatch.Start();\nint keik = knapSack(r, wt, n1 - 1, W);\nstopwatch.Stop();\n```\n\n\nanswer of this is 28, but I need to display all r numbers that was included in this. I know that for this array used numbers are 8 8 8 and 4, so I need somehow to get these numbers and display to the console.\n    ", "Answer": "\r\nYou could try the approach of letting the function return the list of used items. \n You could either return the item values themselves, or the indices of the values, depending on your needs.  I used the values in this example.\n\nHere is an implementation:\n\n```\nstatic int knapSack(int[] r, int[] wt, int n, int W, out List<int> list)\n{\n    if (W < 0) {\n        list = new List<int>();\n        return Int32.MinValue;\n    }\n    if (n < 0 || W == 0) {\n        list = new List<int>();\n        return 0;\n    }\n    int include = r[n] + knapSack(r, wt, n, W - wt[n], out List<int> includedList);\n    int exclude = knapSack(r, wt, n - 1, W, out List<int> excludedList);\n    if (include > exclude) {\n        includedList.Add(r[n]);\n        list = includedList;\n        return include;\n    } else {\n        list = excludedList;\n        return exclude;\n    }\n}\n```\n\n\nCall like this:\n\n```\nint keik = knapSack(r, wt, n1 - 1, W, out List<int> list);\nConsole.WriteLine(string.Join(\",\", list));\n```\n\n\nOutput:\n\n\n4,8,8,8\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "I am trying to solve 0/1 Knapsack problem, but I am getting output as many zeroes\r\n                \r\nBelow is the code given for 0/1 knapsack problem, where i am getting most zeroes in my output table. How can I understand why this problem is happening and how to solve this issue?\n```\n    item = 4\n    profit = [1, 2, 4, 5]\n    weight = [5, 4, 8, 6]\n    bag = 5\n    import numpy as np\n    table=np.zeros([item,bag]) \n\nfor j in range(bag):\n    for i in range(len(weight)):\n        if i==0 or j==0 :continue \n\n        elif j< weight[i]:\n            table[i][j] = table[i-1][j]\n            #print(i,j)\n        else: \n            table[i][j] =max((profit[i]+table[i-1][j-weight[i]]),\n            (table[i-1][j]))\nprint(table)\n```\n\nThe output I am getting is:\n```\n[[ 0.  0.  0.  0.  0.]\n [ 0.  0.  0.  0.  2.]\n [ 0.  0.  0.  0.  2.]\n [ 0.  0.  0.  0.  2.]]\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack problem variation with almost no constraints\r\n                \r\nI have this variation of knapsack with very few constraints, and the lack of contraints does that i really don't know where to start.\nGiven a set S of positive integers. could be:\n1 2 3 4 5 6 7 8 9 10 11 12 13\nfind two non-overlapping subsets that have the same total each. The two sets do not need to contain all numbers in S.\nSo for the former example, the answer would be\n[1,2] and [3]\nUsually these problems have constraints such as the subsets needing to have specific sums, or the subsets needing to span over all elements of S.\nThis makes it hard for me to imagine how to solve this via bruteforce. Every time I come up with a dynamic programming table, I can't get it to cover all possible permutations of subsets\n    ", "Answer": "\r\nThis problem might be solved like subset sum problem in pseudopolynomial time ```\nO(n*summ)```\n\nWe fill array ```\n0..summ```\n with possible subset sums, and when we meet the same sum - we stop.\nTwo equal sums might be composed with some equal items - and we just remove them, so the rest sums contain only distinct items.\nExample in Python using binary arithmetics to store sets (bit ```\ni+1```\n corresponds to using i-th item in sum). ```\ncommon```\n contains equal bits, we remove them using xor operation.\nThe last lines retrieve needed sets themselves.\n```\nL = [2,5,11,17,29,37,43]\nsumm = sum(L)\nA =[0]*(summ+1)\nA[0] = 1\n\nX = 0\nY = 0\nfor i in range(len(L)):\n    for k in range(summ, L[i] - 1, -1):\n        if A[k - L[i]]:\n            t = A[k - L[i]] | (2 << i)\n            if A[k]:\n                common = A[k] & t\n                X = A[k] ^ common\n                Y = t ^ common\n                break\n            else:\n                A[k] = t\n    if X:\n        break\n\nfirst = [L[i] for i in range(len(L)) if (X & (2 << i))]\nsecond = [L[i] for i in range(len(L)) if (Y & (2 << i))]\nprint(first, second)\n\n>>> [2, 11, 29] [5, 37]\n```\n\nIn this example code finds equal sums ```\n59```\n for ```\n[2, 11, 17, 29] and  [5, 17, 37]```\n and removes common ```\n17```\n to get final results with sum ```\n42```\n\n\nIt is not obligatory to store sets in ```\nA[]```\n cells - we can store the last item of sum, then unwind item sequence\n```\nL = [2,5,11,17,29,37,43]\nsumm = sum(L)\nA =[0]*(summ+1)\nA[0] = -1\nlast = 0\nfor i in range(len(L)):\n    for k in range(summ, L[i] - 1, -1):\n        if A[k - L[i]]:\n            t = L[i]\n            if A[k]:\n                last = k\n                break\n            else:\n                A[k] = t\n    if last:\n        break\n\nfirst = set()\nk = last\nwhile k:\n    first.add(A[k])\n    k = k - A[k]\n\nsecond = set()\nsecond.add(t)\nk = last - t\nwhile k:\n    second.add(A[k])\n    k = k - A[k]\n\nprint(first.difference(second),second.difference(first))\n\n>>> {2, 11, 29} {37, 5}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "C# 0-1 Knapsack Problem with known sum and number of zeros in set\r\n                \r\nI have a 5x5 table of values from 0 to 3 inclusive with all values unknown.  I know both the sum of the values and the number of zeros for each row and column.  How would I go about solving this 0-1 knapsack problem using C# and retrieving the possible solutions that satisfy the known sums and number of zeros?  The tables will always be five rows and five columns, so it's not quite a traditional knapsack.\n\nFor example, say we input:\n\n```\nRow[0]: Sum=4, Zeros=1\n   [1]: Sum=5, Zeros=1\n   [2]: Sum=4, Zeros=2\n   [3]: Sum=8, Zeros=0\n   [4]: Sum=3, Zeros=2\n\nCol[0]: Sum=5, Zeros=1\n   [1]: Sum=3, Zeros=2\n   [2]: Sum=4, Zeros=2\n   [3]: Sum=5, Zeros=1\n   [4]: Sum=7, Zeros=0\n```\n\n\nWe would get this as a possible solution:\n\n```\n[[ 0 1 1 1 1 ]\n [ 1 0 2 1 1 ]\n [ 2 1 0 0 1 ]\n [ 1 1 1 2 3 ]\n [ 1 0 0 1 1 ]]\n```\n\n\nWhat type of algorithm should I employ in this rather strange situation?  Would I also have to write a class just to enumerate the permutations?\n\nEdit for clarification: the problem isn't that I can't enumerate the possibilities; it's that I have no clue how to go about efficiently determining the permutations adding to an arbitrary sum while containing the specified number of zeros and a maximum of 5 items.\n    ", "Answer": "\r\nHere there is the code. If you need any comment feel free to ask:\n\n```\nusing System;\nusing System.Diagnostics;\n\nnamespace ConsoleApplication15\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            RowOrCol[] rows = new RowOrCol[] { \n                new RowOrCol(4, 1),\n                new RowOrCol(5, 1),\n                new RowOrCol(4, 2),\n                new RowOrCol(8, 0),\n                new RowOrCol(3, 2),\n            };\n\n            RowOrCol[] cols = new RowOrCol[] { \n                new RowOrCol(5, 1),\n                new RowOrCol(3, 2),\n                new RowOrCol(4, 2),\n                new RowOrCol(5, 1),\n                new RowOrCol(7, 0),\n            };\n\n            int[,] table = new int[5, 5];\n\n            Stopwatch sw = Stopwatch.StartNew();\n\n            int solutions = Do(table, rows, cols, 0, 0);\n\n            sw.Stop();\n\n            Console.WriteLine();\n            Console.WriteLine(\"Found {0} solutions in {1}ms\", solutions, sw.ElapsedMilliseconds);\n            Console.ReadKey();\n        }\n\n        public static int Do(int[,] table, RowOrCol[] rows, RowOrCol[] cols, int row, int col)\n        {\n            int solutions = 0;\n\n            int oldValueRowSum = rows[row].Sum;\n            int oldValueRowZero = rows[row].Zeros;\n            int oldValueColSum = cols[col].Sum;\n            int oldValueColZero = cols[col].Zeros;\n\n            int nextCol = col + 1;\n            int nextRow;\n            bool last = false;\n\n            if (nextCol == cols.Length)\n            {\n                nextCol = 0;\n\n                nextRow = row + 1;\n\n                if (nextRow == rows.Length)\n                {\n                    last = true;\n                }\n            }\n            else\n            {\n                nextRow = row;\n            }\n\n            int i;\n\n            for (i = 0; i <= 3; i++)\n            {\n                table[row, col] = i;\n\n                if (i == 0)\n                {\n                    rows[row].Zeros--;\n                    cols[col].Zeros--;\n\n                    if (rows[row].Zeros < 0)\n                    {\n                        continue;\n                    }\n\n                    if (cols[col].Zeros < 0)\n                    {\n                        continue;\n                    }\n                }\n                else\n                {\n                    if (i == 1)\n                    {\n                        rows[row].Zeros++;\n                        cols[col].Zeros++;\n                    }\n\n                    rows[row].Sum--;\n                    cols[col].Sum--;\n\n                    if (rows[row].Sum < 0)\n                    {\n                        break;\n                    }\n                    else if (cols[col].Sum < 0)\n                    {\n                        break;\n                    }\n                }\n\n                if (col == cols.Length - 1)\n                {\n                    if (rows[row].Sum != 0 || rows[row].Zeros != 0)\n                    {\n                        continue;\n                    }\n                }\n\n                if (row == rows.Length - 1)\n                {\n                    if (cols[col].Sum != 0 || cols[col].Zeros != 0)\n                    {\n                        continue;\n                    }\n                }\n\n                if (!last)\n                {\n                    solutions += Do(table, rows, cols, nextRow, nextCol);\n                }\n                else \n                {\n                    solutions++;\n\n                    Console.WriteLine(\"Found solution:\");\n\n                    var sums = new int[cols.Length];\n                    var zeross = new int[cols.Length];\n\n                    for (int j = 0; j < rows.Length; j++)\n                    {\n                        int sum = 0;\n                        int zeros = 0;\n\n                        for (int k = 0; k < cols.Length; k++)\n                        {\n                            Console.Write(\"{0,2} \", table[j, k]);\n\n                            if (table[j, k] == 0)\n                            {\n                                zeros++;\n                                zeross[k]++;\n                            }\n                            else\n                            {\n                                sum += table[j, k];\n                                sums[k] += table[j, k];\n                            }\n                        }\n\n                        Console.WriteLine(\"| Sum {0,2} | Zeros {1}\", sum, zeros);\n\n                        Debug.Assert(sum == rows[j].OriginalSum);\n                        Debug.Assert(zeros == rows[j].OriginalZeros);\n                    }\n\n                    Console.WriteLine(\"---------------\");\n\n                    for (int j = 0; j < cols.Length; j++)\n                    {\n                        Console.Write(\"{0,2} \", sums[j]);\n                        Debug.Assert(sums[j] == cols[j].OriginalSum);\n                    }\n\n                    Console.WriteLine();\n\n                    for (int j = 0; j < cols.Length; j++)\n                    {\n                        Console.Write(\"{0,2} \", zeross[j]);\n                        Debug.Assert(zeross[j] == cols[j].OriginalZeros);\n                    }\n\n                    Console.WriteLine();\n                }\n            }\n\n            // The for cycle was broken at 0. We have to \"readjust\" the zeros.\n            if (i == 0)\n            {\n                rows[row].Zeros++;\n                cols[col].Zeros++;\n            }\n\n            // The for cycle exited \"normally\". i is too much big because the true last cycle was at 3.\n            if (i == 4)\n            {\n                i = 3;\n            }\n\n            // We readjust the sums.\n            rows[row].Sum += i;\n            cols[col].Sum += i;\n\n            Debug.Assert(oldValueRowSum == rows[row].Sum);\n            Debug.Assert(oldValueRowZero == rows[row].Zeros);\n            Debug.Assert(oldValueColSum == cols[col].Sum);\n            Debug.Assert(oldValueColZero == cols[col].Zeros);\n\n            return solutions;\n        }\n    }\n\n    public class RowOrCol\n    {\n        public readonly int OriginalSum;\n        public readonly int OriginalZeros;\n\n        public int Sum;\n        public int Zeros;\n\n        public RowOrCol(int sum, int zeros)\n        {\n            this.Sum = this.OriginalSum = sum;\n            this.Zeros = this.OriginalZeros = zeros;\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to add termination condition to knapsack problem and how to show the graph?\r\n                \r\nI'm new to python, I have this knapsack problem where there are items and their weight. The user will insert their priority (low-medium-high). And then the GA will then run to find the best backpacking list that maximizes the priority points without exceeding the maximum weight (30kg).\nI did most of the genetic operators, except the termination condition (after 20000 generations or when the fitness reaches 1) did not work,and the graph (plot) of the GA's performance is not showing.\nThe code:\n```\nimport matplotlib.pyplot as plt\nimport random\nimport time\nfrom unittest import result\n\n# Data (search space)\nitems = {\n    'Sleeping bag': 10,\n    'Rope': 3,\n    'Pocket Knife': 2,\n    'Torch': 5,\n    'Water Bottle': 9,\n    'Glucose': 8,\n    'First aid supplies': 6,\n    'Rain jacket': 3,\n    'Personal Locator Beacon': 2\n}\n\n\nGenome = list[int]\n# Number of items\nITEMS_COUNT = len(items)\n\n# # Number of points for the multi point crossover entered by the user. Default is 3\nN_POINT = 3\n\n# # Number of individulas in the population filled with some permutation of 0s and 1s entered by the user. Default is 50\nPOP_SIZE = 20\n\n# # Elitisim for selection. Default is True\nELITISM = True\n\n# # Number of generations entered by the user. Default is 200\nGENERATIONS = 200\n\n# # Crossover probability enterd by the user. Default is 0.1\nCROSSOVER_PROBABILTY = 0.1\n\n# # Mutate probability entered by the user. Defaulst is 0.05\nMUTATION_PROBABITLY = 0.05\n\n# Priorities\nitemsPriorities = {'low': 5, 'medium': 10, 'high': 15}\n\n\n# User input\ndef user_input():\n    print('Welcome to Smart Hiker Backpacking!')\n    print('Input your priority for items based on the priority legend: ')\n    print('Low \\t Medium \\t High')\n    print()\n    print('Choose your priority for these items below: ')\n    print('-'*50)  # design: ------\n    for item, _ in items.items():  # Print items\n        print(item)\n    print('-'*50)  # design: ------\n\n    prio_l = []\n\n# Ask user to enter a priority for every item\n    # Goes through and displays every item in the data (search space)\n    for item in items:\n        prio_input = str(input(f\"What is your priority for {item}? \"))\n        while prio_input.lower() not in itemsPriorities.keys():  # convert entered data by the user to lower case\n\n         # Asks the user again to enter a correct choice (low, medium, high), regardless of the capitalization\n            prio_input = str(input('Please enter low, medium or high: '))\n        else:\n            prio_l.append(itemsPriorities[prio_input.lower()])\n    return prio_l\n\n\npriority_list = user_input()\n\n# Print the item name and its entered priority\nprint('-'*50)  # design: ------\nfor i, j in enumerate(items):\n    print(j, 'has a priority of: ', priority_list[i])\n\n\n# Assume the population size is 20\npop_size = 20\n\n# generate initial population\n\n\ndef create_initial_population(amount):\n    #global pop_size\n    return [generate_genome() for i in range(0, amount)]\n# generate genome\n\n\ndef generate_genome():\n    return [random.randint(0, 1) for x in range(0, len(items))]\n\n\nprint('-'*50)  # design: ------\n#print(\"Population:\\n\", create_initial_population(POP_SIZE))\n\n# Compute fitness function\n\n\ndef compute_fitness(target):\n    total_points = 0\n    total_weight = 0\n    index = 0\n\n    # Sum of priority points and weight\n    for i in target:\n        if index >= len(items):\n            break\n        if (i == 1):\n            total_points += priority_list[index]\n            total_weight += list(items.values())[index]\n        index += 1\n\n    # Cheking to fit\n    if total_weight > 30:\n        return 0\n    else:\n        return total_points\n\n\ndef get_total_points(pop):\n    total_points = 0\n    for target in pop:\n        total_points += compute_fitness(target)\n    return total_points\n\n\n# mutating a point on a solution\ndef mutate(target):\n    r = random.randint(0, len(target)-1)\n    if target[r] == 1:\n        target[r] = 0\n    else:\n        target[r] = 1\n\n# selecting parents by using roulette wheel selection\n\n\ndef roulette_wheel_selection(pop, parent_number):\n    parents = []\n    total_points = get_total_points(pop)\n    current_value = 0\n    # spining the wheel and select parent based on rate of value and total_points\n    for spin in range(0, parent_number):\n        spin_value = random.randint(0, total_points)\n        for target in pop:\n            current_value += compute_fitness(target)\n            if current_value >= spin_value:\n                # print \"SPIN!!! ,%s, TOTAL VALUE / SPIN VALUE : %s/%s, fit: %s\" % (str(target),str(total_points), str(spin_value) , fitness(target))\n                parents.append(target)\n                pop.remove(target)\n                total_points = get_total_points(pop)\n                break\n    # print(\"-------------------------------------------------------------------------\")\n    return parents\n\n# n-point crossover by using two solution to generate their child\n\n\ndef crossover(father, mother):\n    # deciding the lines to split the solution\n    genes_points = [0]\n    genes_points += sorted(random.sample(range(2, ITEMS_COUNT), N_POINT))\n    genes_points += [ITEMS_COUNT]\n    child = []\n    # creating a new child by using father and mother data\n    for count in range(0, N_POINT+1):\n        start = genes_points[count]\n        end = genes_points[count+1]\n        # chosing which part of father or mother\n        if count % 2 == 0:\n            child += father[start:end]\n        else:\n            child += mother[start:end]\n    return child\n\n# generating a new generation by mutation and crossover\n\n\ndef creating_new_generation(pop):\n    # selection with roulette_wheel_selection\n    new_generation = []\n    parents = []\n\n    if ELITISM:\n        parents = pop[int(0): int(POP_SIZE/5)]\n    else:\n        parents = roulette_wheel_selection(pop, (POP_SIZE/5))\n\n    parents_length = len(parents)\n    new_generation.extend(parents[:])\n    # mutating selected parents\n    for p in parents:\n        if MUTATION_PROBABITLY > random.random():\n            mutate(p)\n    children = []\n    desired_length = POP_SIZE - parents_length\n    # creating new children by using parents\n    while len(children) < desired_length:\n        # crossover cheking\n        if CROSSOVER_PROBABILTY > random.random():\n            # selecting two parents randomly\n            father_and_mother = random.sample(range(0, parents_length-1), 2)\n            father = parents[father_and_mother[0]]\n            mother = parents[father_and_mother[1]]\n            # crossover selected two parents to create a new child\n            child = crossover(father[:], mother[:])\n        else:\n            # or cloning a parent randomly\n            child = parents[random.randint(0, parents_length-1)][:]\n        # checking to mutate the new child\n        if MUTATION_PROBABITLY > random.random():\n            mutate(child)\n        children.append(child[:])\n    new_generation.extend(children[:])\n    return new_generation\n\n\ndef genome_to_string(genome) -> str:\n    return \"\".join(map(str, genome))\n\n\ndef genome_to_items(genome, ITEMS):\n    result = []\n    for i, itm in enumerate(ITEMS):\n        if genome[i] == 1:\n            result += [itm]\n    return result\n\n\ndef main():\n    #start_time = time.time()\n    population = create_initial_population(POP_SIZE)\n    max_fit = 0\n    for generation in range(1, GENERATIONS+1):\n        plt.plot(generation, max_fit)\n        plt.ylabel('Fitness')\n        plt.xlabel('Generations')\n        plt.show()\n        #print(\"Generation %d with %d\" % (generation, len(population)))\n        population = sorted(\n            population, key=lambda x: compute_fitness(x), reverse=True)\n\n        for i in population:\n            # print \"%s, fit: %s\" % (str(i), fitness(i))\n            if compute_fitness(i) > max_fit:\n                max_fit = compute_fitness(i)\n\n        population = creating_new_generation(population)\n    # for item in items:\n        # print(item)\n    #elapsed_time = time.time() - start_time\n    #print( \"Best: %s (%f)\" % (genome_to_string(population[0]), compute_fitness(population[0])))\n    print(\n        f\"The Best items for the customer backpacking:{(genome_to_items(population[0],items.items()))}\")\n    print(\"Maximum fitness: \" + str(max_fit))\n    #print (\"Time : \" + str(elapsed_time) + \" seconds\")\n\n\n\nmain()\n```\n\n    ", "Answer": "\r\nIf I change your main loop to this, it seems to work fine:\n```\ndef main():\n    population = create_initial_population(POP_SIZE)\n    fit = []\n    for generation in range(GENERATIONS):\n        #print(\"Generation %d with %d\" % (generation+1, len(population)))\n        population = sorted(\n            population, key=lambda x: compute_fitness(x), reverse=True)\n\n        # First item in population has best fitness.\n        fit.append( compute_fitness(population[0] ) )\n        population = creating_new_generation(population)\n    print(\n        f\"The Best items for the customer backpacking:{(genome_to_items(population[0],items.items()))}\")\n    print(\"Maximum fitness: \" + str(max(fit)))\n    plt.plot(fit)\n    plt.ylabel('Fitness')\n    plt.xlabel('Generations')\n    plt.show()\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to derive max amount of items from DP table of Knapsack problem?\r\n                \r\nI have a little bit changed algorithm for 1-0 Knapsack problem.\nIt calculates max count (which we can put to the knapsack) as well.\nI'm using it to find max subset sum which <= target sum. For example:\n```\nweights: 1, 3, 4, 5, target sum: 10\nresult: 1, 4, 5 (because 1 + 4 + 5 = 10)\n\nweights: 2, 3, 4, 9 target sum: 10\nresult: 2, 3, 4 (2 + 3 + 4 = 9, max possible sum <= 10)\n```\n\nI use 2 DP tables: one for calculating max possible sum (```\ndp```\n) and one for max possible amount (```\ncount```\n).\nThe question is: how I can derive chosen values from the both tables?\nExample:\n```\nweights: [3, 2, 5, 2, 1, 1, 3], target_sum: 10\nindexes:  0, 1, 2, 3, 4, 5, 6\n\ndp:\n0: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n1: [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3]\n2: [0, 0, 2, 3, 3, 5, 5, 5, 5, 5, 5]\n3: [0, 0, 2, 3, 3, 5, 5, 7, 8, 8, 10]\n4: [0, 0, 2, 3, 4, 5, 5, 7, 8, 9, 10]\n5: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n6: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n7: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\ncount:\n0: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n1: [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]\n2: [0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2]\n3: [0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 3]\n4: [0, 0, 1, 1, 2, 2, 2, 2, 2, 3, 3]\n5: [0, 1, 1, 2, 2, 3, 3, 2, 3, 3, 4]\n6: [0, 1, 2, 2, 3, 3, 4, 4, 3, 4, 4]\n7: [0, 1, 2, 1, 2, 3, 3, 4, 4, 5, 5]\n```\n\nHere, items with weight ```\n[3, 2, 1, 3, 1]```\n should be derived (because they have max possible count) instead of (for example) ```\n[5, 2, 3]```\n.\nSome notation explanations:\n```\ndp```\n means the same as in original Knapsack problem: ```\ni```\n - for the items, ```\nj```\n for the weight.\nThe value in the ```\ndp[i][j]```\n mean the sum of chosen items (weights) which have sum <= ```\nj```\n.\nEach cell in the ```\ncount```\n corresponds to ```\ndp```\n and shows max possible amount of items (with total weight = ```\ndp[i][j]```\n)\nHow chosen items could be derived efficiently?\nI know how to derive just any items from the ```\ndp```\n (e.g. not the max amount of them) by reconstructing it from the bottom-right cell.\nAlso, I've found a hack which allows to derive the items if input is sorted.\nBut I'm looking for the way which allows to do that without soring.\nIs it's possible?\n\nThe code which constructs these two tables doesn't matter much, but here it is:\n```\ndef max_subset_sum(ws, target_sum):\n    n = len(ws)\n    k = target_sum\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    count = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            curr_w = ws[i - 1]\n            if curr_w > j:\n                dp[i][j] = dp[i - 1][j]\n                count[i][j] = count[i - 1][j]\n            else:\n                tmp = round(dp[i - 1][j - curr_w] + curr_w, 2)\n                if tmp >= dp[i - 1][j]:\n                    dp[i][j] = tmp\n                    count[i][j] = count[i - 1][j - curr_w] + 1\n                else:\n                    dp[i][j] = dp[i - 1][j]\n                    count[i][j] = count[i - 1][j]\n\n    return get_items(dp, k, n, ws)\n\n\ndef get_items(dp, k, n, ws):\n    # The trick which allows to get max amount of items if input is sorted\n    start = n\n    while start and dp[start][k] == dp[start - 1][k]:\n        start -= 1\n\n\n    res = []\n    w = dp[start][k]\n    i, j = start, k\n    while i and w:\n        if w != dp[i - 1][j]:\n            res.append(i - 1)\n            w = round(w - ws[i - 1], 2)\n            j -= ws[i - 1]\n        i -= 1\n\n    return res\n```\n\nAlso, I have weird attempt to get max amount of items.\nBut it's produces incorrect result which sums to ```\n9```\n: ```\n[3, 1, 1, 2, 2]```\n\n```\ndef get_items_incorrect(dp, count, k, n, ws):\n    start = n\n\n    res = []\n    w = dp[start][k]\n    i, j = start, k\n    while i and w:\n        # while dp[i][j] < ws[i - 1]:\n        #     i -= 1\n        while ws[i - 1] > j:\n            i -= 1\n        if i < 0:\n            break\n\n        max_count = count[i][j]\n        max_count_i = i\n\n        while i and w == dp[i - 1][j]:\n            if count[i - 1][j] > max_count:\n                max_count = count[i - 1][j]\n                max_count_i = i - 1\n            i -= 1\n\n        res.append(max_count_i - 1)\n        w = round(w - ws[max_count_i - 1], 2)\n        j -= ws[max_count_i - 1]\n\n        i = max_count_i - 1\n\n    return res\n```\n\nSorry for the long read and thank you for any help!\n    ", "Answer": "\r\nSeems you have overcomplicated the problem. This kind of problem (without item cost) might be solved using 1D list. Weights for the best cases are stored in parallel list.\nAfter table filling we look for the largest occupied index (largest possible sum <= target) and unwind used items chain.\n```\ndef sol(wts, target):\n    dp = [-1] * (target + 1)\n    dp[0] = 0\n    items = [0] * (target + 1)\n    wts.sort()\n\n    for w in weights:\n        for i in range(target, w-1, -1):\n            if (dp[i-w] >= 0) and (dp[i-w] > dp[i]):\n                dp[i] = dp[i-w] + 1\n                items[i] = w\n\n    last = target\n    while (last) and  (dp[last] < 0):\n        last -= 1\n\n    best = dp[last]\n    res = []\n    while (last):\n        res.append(items[last])\n        last -= items[last]\n\n    return(best, res)\n\nweights = [1, 2, 3, 3, 5, 2, 1]\ntarget_sum = 9\nprint(sol(weights, target_sum))\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is wrong with this implementation of the knapsack problem? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        List of lists changes reflected across sublists unexpectedly\r\n                            \r\n                                (17 answers)\r\n                            \r\n                    \r\n                Closed 3 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am getting Some Wierd output for the input of \n\n1\n\n3\n\n4\n\n1 2 3\n\n4 5 1\n\nI am getting output as 12\n\n(HERE w is the capacity of the knapsack)\n\n```\nt=int(input())\nwhile t:\n   n=int(input())\n   w=int(input())\n   profits=tuple(map(int,input().split()))\n   weights=tuple(map(int,input().split()))\n   dp=[[0]*(w+1)]*(n+1)\n   for i in range(n+1):\n     for j in range(w+1):\n        print()\n        if i==0 or j==0:\n            dp[i][j]=0\n        elif j<weights[i-1]:\n            dp[i][j]=max(dp[i-1][j],dp[i][j-1])\n        else:\n            dp[i][j]=max(dp[i-1][j],dp[i][j-1],profits[i-1]+dp[i-1][j-weights[i-1]])\n   print(dp[n][w])\n   t-=1\n```\n\n    ", "Answer": "\r\nThere is a bug in line 7, ```\ndp=[[0]*(w+1)]*(n+1)```\n, notice that in this kind of initialization if you change one element you change all of the elements in this column. Here you can find a full answer about this bug, why is this happening and how to fix it. But at the end what you need to do is:\n\nTL;DR\n\nchange ```\ndp=[[0]*(w+1)]*(n+1)```\n to ```\ndp = [[0] * (w + 1) for _ in range(n + 1)]```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do I solve 0/1 knapsack problem with big weights given?\r\n                \r\nI've been trying to find the optimal solution for the 0/1 knapsack problem with big weights and values like ```\n{300: 256, 653: 300, 1500: 500}```\n. From my research, I found out that the best solution relies on DP technique where rows have a format ```\n[0..W]```\n. So for the big weights like 1500, table ```\n[0..1500][]```\n would be a total waste of space. Any recommendations on how to avoid such waste? Is it better to use a recursive algorithm for such cases or there is a way to create a table without allocating this much memory?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Binpacking / Knapsack Optimisation problem design\r\n                \r\nI have a scenario I need some help formulating the question in, so that I can properly implement an optimisation method. I hope someone can guide me a little, it seems so simple on the surface, but I am having trouble figuring out how to encode the variables, constraints etc properly.\n\nThe scenario is this:\n\n\nMultiple items need to be placed into bins / knapsacks\nEach item has two factors that must be taken into account when packing\nI have several types of bin / knapsack that can be used for packing\nThe supply of bins / knapsacks is infinite\nEach bin / knapsack has constraints on each of the values from the items so that the values of the items add up in a cumulative way but cannot exceed either constraint on the bin / knapsack\nEach bin / knapsack has a different cost (price) to use it\nThere is an upper limit to the number of items that can fit into a bin / knapsack regardless of which items are in it\n\n\nExample:\n\nA vector of items with two values each:\n\nItems = [[7,6],[14,2],[27,23],[5,15]]\n\nA vector of bins / knapsacks with first value being upper limit it can accept for item first values. Second value is the same but applies to the second value of each item in the bin / knapsack. Third value is the maximum number of items the bin / knapsack can hold. Last value is the price / cost of the bin / knapsack.\n\nBinOptions = [[64000,1450,350,22000],[8000,450,64,8000]]\n\nThe goal is to pack all the items in the most efficient manner so as to provide the least cost (using the price of the bins / knapsacks).\n\nI was looking at two ways the problem might be solved:\n\n\nOR-Tools with the MILP approach\nOR-Tools with the Knapsack solver\n\n\nI am not necessarily stuck on OR-Tools, it is just what I have been playing with and seems to work nicely across different languages from the reports I have seen. It would be nice to be able to model this and then choose a language later.\n\nThe one thing that is probably not apparent is that the number of available bin varieties changes. Sometimes I will have two or three to choose from, other times many many more, possibly up to a hundred. The number of incoming items to pack will also change depending on the day.\n\nIf anybody can provide some guidance on solving this I would be most appreciative.\n\nCheers\n\nThe Frog\n    ", "Answer": "\r\nthe knapsack solver with not solve your problem, as it is a pure 1-knapsack solver.\n\nYou can use the MILP solver, or the CP-SAT.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Do dynamic programming and branch and bound give same result when solving 0/1 knapsack problem?\r\n                \r\nHi I have a question about knapsack problem and it's algorithms.\nI have built some code to solve 0/1 knapsack problem with Dynamic Programming and Branch and Bound.\nThe value and weight are randomly generated.\nI ran the program and obtain the result showing.\nNumber of Items | Processing Time in milliseconds / Maximun Beneift Val\nNumber of Items |   Greedy   |   D.P.   |   B. & B.\n10        |  0/2502  |    0/2469  |  0/2469\n100        |  0/22629  |    8/22621  |  0/19382\n1000        |  0/202083  |  651/202081  | 30/173603\n10000        |  4/2025662  |66624/2025662  |2709/1637172\nSo I was wondering if the result of these two algorithms can be different\nI am expecting if they are different or just my code is bad\n    ", "Answer": "\r\nBranch and Bound is just a additional to DP, which mean you can do 0-1 knapsack without Branch and Bound. But, you can apply Branch and Bound when the weight of bag is less that 0. So it's the same algorithm.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How can I solve knapsack problems with 3 variables?\r\n                \r\nWhat's the best way to solve problems related to knapsack problems, which have 3 variables, such as: value, weight and volume? (with the biggest value possible, with a maximum weight and volume limit)\n\nI have tried using a defined index, based on its value/(weight*volume) but I believe that this won't give me the best solution, so I searched and some people suggest using dynamic programming, but all topics related to that, only have 2 variables (value and weight) and I don't know how having more than 2 variables can affect this.\n    ", "Answer": "\r\nYou should be able to extend the standard dynamic programming problem with one constraint to handle two or more constraints.\nAs a refresher, the standard DP solution for the knapsack problem works by ordering the items in some order, then answering all questions of the following form:\n\nWhat is the maximum value that can be produced using the first i items without exceeding weight w?\n\nThis turns into a 2D table, with one axis for how many items are being considered and another for the different possible weight values. To fill in the table, you fill in the 1D slice of entries where i = 0 by setting them to zero (you can’t get any value if you have no items), then filling in the 1D slice where i = 1 by considering whether to include or exclude the first item, the slice where i = 2 by considering whether to include or exclude the second item, etc. The runtime is then O(nW), where n is the number of items and W is the maximum allowable weight, since those are the dimensions of the table and you do O(1) work per entry.\nIf you now have two constraints (weight and volume), you can solve all problems of the following form:\n\nWhat is the maximum value that can be produced using the first i items without exceeding weight w or volume v?\n\nThis turns into a 3D table, with one axis for how many items are being considered, another for the different possible weight values, and a third for the possible volume values. To fill in the table, you fill in the 2D slice of entries where i = 0 by setting them to zero (you can’t get any value if you have no items), then filling in the 2D slice where i = 1 by considering whether to include or exclude the first item, the slice where i = 2 by considering whether to include or exclude the second item, etc. The runtime is O(nWV), where n is the number of items, W is the maximum allowable weight, and V is the maximum allowable volume(instead of value), since that’s the number of table entries and it takes O(1) work to fill each in.\nDo you see how to adapt this for larger numbers of constraints?\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to solve a Knapsack problem with extra constraints? (Or alternative algorithms)\r\n                \r\nExpanding upon a common dynamic programming solution for the knapsack problem:\n```\ndef knapSack(W, wt, val, n):\n    results = []\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n    # Build tаble K[][] in bоttоm uр mаnner\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if (i == 0)  or  (w == 0):\n                K[i][w] = 0\n            elif wt[i-1] <= w:\n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w])\n            else:\n                K[i][w] = K[i-1][w]\n    print(K[n][W])\n    return(set(results))\n\n\n# Driver code\nval = [60, 100, 120]\nwt = [10, 20, 30]\nW = 50\nn = len(val)\n\nknapSack(W, wt, val, n) = 220\n```\n\nNow perhaps I add extra constraints:\n```\n# Driver code\nval_all = [60, 100, 120, 50, 80, 10]\nwt_all = [10, 20, 30, 15, 20, 5]\nW_all = 50\nn_all = len(val_all)\n\nval_1 = [60, 100, 120]\nwt_1 = [10, 20, 30]\nW_1 = 30\nn_1 = len(val_1)\n\nval_2 = [50, 80, 10]\nwt_2 = [15, 20, 5]\nW_2 = 25\nn_2 = len(val_2)\n```\n\nI want to maximise all 3, using the same values. val_all has a solution of 240 [60, 100, 80]. val_1 is maxed at 160 [60, 100] and val_2 would max at 90 [80, 10] but given I want the same values and 10 does not sit in the other two sets the max solution would be 80.\nI am also wondering if you can add to the function to give you the values chosen as well as the maximum value. And is this approach feasible for large lists as I have a list of 150,000 different values each with different weights.\nThere may be a better algorithm, my problem is I have 150,000 values each with a weight and need to select any number of those values such that we get a close to a ceiling W value. However, the data is actually a mixture of two different types of values and the sum of weights of each type also have a W1 and W2 ceiling value. I'd like to maximise all three equations but using the same set of values. Any value chosen in W1 or W2 must exist in W.\nThis knapsack code won't be very useful as I have 150k values with an average weight of 50 and a weight ceiling of 6mil. The time complexity given such large loops will be huge.\n    ", "Answer": "\r\nBased on the top comment I found a package that is very fast and allows for this:\n```\nfrom mip import Model, xsum, maximize, BINARY\n\nall = pd.read_csv('df_all.csv')\nX = pd.read_csv('df_x_only.csv')\nY = pd.read_csv('df_y_only.csv')\n\np = all.id.values # as we arent optimizing the value of the index, p is irrelevant and we replace xsum(p[i] with xsum(w[i] in the objective function\nw = all.new_weights.values\nw1 = X.new_weights.values\nw2 = Y.new_weights.values\n\nc = 5876834\nCx = 4902953\nCy = 719051.4\n\nI = range(len(w))\nI1 = range(len(w1))\nI2 = range(len(w2))\n\nm = Model(\"knapsack\")\n\nx = [m.add_var(var_type=BINARY) for i in I]\n\nm.objective = maximize(xsum(w[i] * x[i] for i in I)) + maximize(xsum(w1[i] * x[i] for i in I1)) + maximize(xsum(w2[i] * x[i] for i in I2))\n\nm += xsum(w[i] * x[i] for i in I) <= c*1.05\nm += xsum(w[i] * x[i] for i in I) >= c*0.95\nm += xsum(w1[i] * x[i] for i in I1) <= Cx*1.05\nm += xsum(w1[i] * x[i] for i in I1) >= Cx*0.95\nm += xsum(w2[i] * x[i] for i in I2) <= Cy*1.05\nm += xsum(w2[i] * x[i] for i in I2) >= Cy*0.95\n\nm.optimize()\n\n\nselected = [i for i in I if x[i].x >= 0.99]\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python Knapsack Problem with fixed number of elements\r\n                \r\nSo far I have the following code which I believe selects up to a MAX of 4 (or n) elements in the knapsack (hence the 3rd dimension). However, I want to ensure that the code ALWAYS selects 4 (or n) elements. Can someone please advise as I can't find anything about this anywhere...\n```\ndef knapsack2(n, weight, count, values, weights):\n    dp = [[[0] * (weight + 1) for _ in range(n + 1)] for _ in range(count + 1)]\n    for z in range(1, count + 1):\n        for y in range(1, n + 1):\n            for x in range(weight + 1):\n                if weights[y - 1] <= x:\n                    dp[z][y][x] = max(dp[z][y - 1][x],\n                                      dp[z - 1][y - 1][x - weights[y - 1]] + values[y - 1])\n                else:\n                    dp[z][y][x] = dp[z][y - 1][x]\n\n    return dp[-1][-1][-1]\n\nw = 10\nk = 4\nvalues = [1, 2, 3, 2, 2]\nweights = [4, 5, 1, 1, 1]\nn = len(values)\n\n# find elements in \nelements=[]\ndp=m\nwhile (n> 0):\n    if dp[k][n][w] - dp[k][n-1][w - weights[n-1]] == values[n-1]:\n        #the element 'n' is in the knapsack\n        elements.append(n)\n        n = n-1 #//only in 0-1 knapsack\n        w -= weights[n]\n    else: \n        n = n-1\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is the runtime complexity of the Unbounded Knapsack problem really O(n×W)?\r\n                \r\nGiven a knapsack weight W and a set of n items each with certain value value_i and weight w_i, we need to calculate the maximum value we can get from the items with total weight ≤ W. This is different from classical Knapsack problem, here we are allowed to use unlimited number of instances of an item (adapted from [1]).\nThere is a standard solution for this problem using dynamic programming: instead of creating a function f: CurrentWeight -> MaxRemainingValue, we create a function g: (CurrentWeight, CurrentItem) -> MaxRemainingValue that iterates through each item. This way we avoid cycles in the implicit graph formed by g, and then we can use dynamic programming. One standard implementation of such function can be seen here in C++:\n```\n#include<iostream>\n#include<vector>\n#include <chrono>\n#define INF (int)1e8\nusing namespace std;\nusing namespace std::chrono;\n\nconst int MAX_WEIGHT = 10000;\nconst int N_ITEMS = 10;\n\nint memo[N_ITEMS][MAX_WEIGHT + 1];\nvector<int> weights;\nvector<int> values;\n\nvoid initializeMemo(){\n    for(int i = 0; i < N_ITEMS; i++)\n        for(int j = 0; j < MAX_WEIGHT + 1; j++)\n            memo[i][j] = -1;\n}\n\n// return max possible remaining value\nint dpUnboundedKnapsack(int currentItem, int currentWeight){\n    if(currentItem == N_ITEMS)\n        return 0;\n\n    int& ans = memo[currentItem][currentWeight];\n    if(ans != -1)\n        return ans;\n\n    int n_taken = 0;\n    while(true){\n\n        int newWeight = currentWeight + n_taken * weights[currentItem];\n        if(newWeight > MAX_WEIGHT)\n            break;\n\n        int value = n_taken * values[currentItem];\n        ans = max(ans, dpUnboundedKnapsack(currentItem+1, newWeight) + value);\n\n        n_taken++;\n    }\n\n    return ans;\n}\n\nint main(){\n    initializeMemo();\n\n    // weights equal 1\n    weights = vector<int>(N_ITEMS, 1);\n\n    // values equal 1, 2, 3, ... N_ITEMS\n    values = vector<int>(N_ITEMS);\n    for(int i = 0; i < N_ITEMS; i++)\n        values[i] = i+1;\n\n    auto start = high_resolution_clock::now();\n    cout << dpUnboundedKnapsack(0, 0) << endl;    \n    auto stop = high_resolution_clock::now();\n    auto duration = duration_cast<microseconds>(stop - start);\n    cout << duration.count() << endl;\n\n    return 0;\n}\n```\n\nThis solution transverses a DAG (we never go back an item, so there is no cycles here, all edges are of the form (item, weight) -> (item+1, new_weight) ). Each edge of the DAG is visited at most once. Hence, the time complexity of this algorithm is O(E), with E being the number of edges of the graph. In the worst case scenario, each weight is equal to 1, so each vertex (item, weigth) connects to, on average, other W/2 vertexes. So we have O(E) = O(W·#vertexes) = O(W·W·n) = O(W^2·n). The problem is, everywhere I look on the internet it is said the runtime complexity of this algorithm is O(W·n) because every vertex is calculated only once [1][2][3]. This explanation does not seem to make sense. Also, if that was the case, the algorithm above should not run so slowly. Here is a table of the algorithm runtime × MAX_WEIGHT value (try this for yourself, just have to run the code above):\n```\nMAX_WEIGHT    time (microseconds)\n       100                   1349\n      1000                  45773\n     10000                5490555\n     20000               21249396\n     40000               80694646\n```\n\nWe can clearly see a O(W^2) trend for large values of W, as suspected.\nFinally, one may ask: this worst case scenario is pretty dull, as you can just take the greatest value for each repeated weight. Indeed, with this simple pre-processing the worst case scenario now becomes the one with weights = [1, 2, 3, 4, ..., n]. In this case there are around O(W^2·log(n) + W·n) edges (see the image below. I tried my best, hope you understand). So the runtime complexity of the algorithm should be O(W^2·log(n) + W·n) instead of O(W·n) as suggested pretty much every where?\nBtw, here is the runtime I obtained for the case weights = [1, 2, 3, 4, ..., n]:\n```\nMAX_WEIGHT    time (microseconds)\n       100                    964\n       200                   1340\n       400                   2541\n       800                   6878\n      1000                  10407\n     10000                1202582\n     20000                5181070\n     40000               18761689\n```\n\n\n[1] https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/\n[2] https://en.wikipedia.org/wiki/Knapsack_problem#Dynamic_programming_in-advance_algorithm\n[3] Why is the knapsack problem pseudo-polynomial?\n    ", "Answer": "\r\nYou are correct that the runtime of your algorithm is indeed O(nW2). Here’s an easy way to see this: there are O(nW) grid cells to fill in, and each cell requires O(W) time to process because you can take at most W copies of any one item.\nHowever, there’s a faster way to compute the answer than what you’re proposing here. Specifically, we can eliminate the inner while loop in your code by using the following insight. Suppose you want to make the largest possible value using only the first n items of the list and with W available capacity. There are two options:\n\nIf the nth item’s weight exceeds W, you can’t take it. The best option is to get the most value from the first n-1 items and with maximum weight W.\nOtherwise, you have two options. You can either say “I am not interested in this item,” in which case you maximize the value of the first n-1 items with maximum weight W. You could alternatively say “I’d like at least one of these.” In that case, if the item has weight w, then you now have W - w remaining weight. However, you haven’t ruled out the possibility of using more copies of that item. So you recursively compute the maximum value you can get from the last n items using weight W - w, adding in the value of one copy of the item.\n\nStated differently, instead of asking at each point “how many copies of this do I want?,” you ask “am I done taking copies of this item, or do I want one more copy?”\nThis reduces the work done per element in the table to O(1), which is where the O(nW) runtime comes from.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to find the items in the optimal solution of the knapsack problem using dynamic programming?\r\n                \r\nI want to find which items are eventually chosen in the optimal solution of the knapsack problem using the method of dynamic programming.\nThis is my interpretation so far...\n\n```\n#include<stdio.h>\n\nint getMax(int x, int y) {\n    if(x > y) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nint main(void) {\n\n    //the first element is set to -1 as\n    //we are storing item from index 1\n    //in val[] and wt[] array\n    int val[] = {-1, 100, 20, 60, 40};  \n    int wt[] = {-1, 3, 2, 4, 1};   \n    int A[] = {0,0,0,0,0};    \n    int n = 4; //num\n    int W = 5;//cap  \n    int i, j;\n\n\n    // value table having n+1 rows and W+1 columns\n    int V[n+1][W+1];\n\n    // fill the row i=0 with value 0\n    for(j = 0; j <= W; j++) {\n        V[0][j] = 0;\n    }\n\n    // fill the column w=0 with value 0\n    for(i = 0; i <= n; i++) {\n        V[i][0] = 0;\n    }\n\n    //fill the value table\n    for(i = 1; i <= n; i++) {\n        for(j = 1; j <= W; j++) {\n            if(wt[i] <= j) {\n                V[i][j] = getMax(V[i-1][j], val[i] + V[i-1][j - wt[i]]);\n            } else {\n                V[i][j] = V[i-1][j];\n            }\n        }\n    }\n\n    //max value that can be put inside the knapsack\n    printf(\"Max Value: %d\\n\", V[n][W]);\n\n\n    //==================================find items\n    int n1,c;\n    n1=n;\n    c=W;\n    int A2[n1][c];\n\n    while(c>0){\n\n        if(A2[n1][c]==A2[n1-1][c]){\n            A[n1]=0;\n        } else {\n            A[n1]=1;\n        }\n\n        n1=n1-1;\n        c=c-wt[n1];\n\n    }\n\n    printf(\"Final array of items: \");\n    for(i = 0; i < n; i++){\n        printf(\"%d\",A[i]);\n    }\n} // end of main\n```\n\n\nAnd this is the output:\n\n```\nMax Value: 140\nFinal array of items: 0001\n```\n\n\nThis string of ones and zeros is meant to be the finally chosen items, but from the solution this seems to be wrong!\n\nI followed this algorithm:\n\n```\nWhile the remaining capacity is greater than 0 do\nIf Table[n, c] = Table[n-1, c] then\nItem n has not been included in the optimal solution\nElse\nItem n has been included in the optimal solution\nProcess Item n\nMove one row up to n-1\nMove to column c – weight(n)\n```\n\n\nSo, is this algorithm wrong / not suitable for this method, or am I missing something?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do we solve a variant of the knapsack problem in which the capacity of the knapsack keeps increasing as we add more items into the knapsack?\r\n                \r\nGiven a set of N objects of positive integer weights {w_i}, how to find the subset of these objects that maximizes\n\n\n  summation(x_i*(log w_i))   (i goes from 1 to N)\n  \n  such that summation(x_i*w_i) < 10000*sqrt(k) (i goes from 1 to N)\n  \n  where k is the number of items selected and\n  \n  x_i = 1 if w_i is used and\n  \n  x_i = 0 if w_i is not used \n\n\nIn LaTeX:\n\n\n\nNote that weights w_i are positive integers,so log(w_i) is also positive.\nFor this specific problem, N = 1000.\n\nOne approach that I tried was to solve the exact-k knapsack problem for each value of k. But it takes too long to run the program as k goes from 1 to 1000.\nIs there some way that we can find a solution for k and then use that to find the solution for k+1 ?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Please help me in solving Fractional Knapsack problem (Maximum Value of the Loot)\r\n                \r\nMaximum Value of the Loot\n\nProblem Introduction:\nA thief finds much more loot than his bag can fit. Help him to find the most valuable combination of items assuming that any fraction of a loot item can be put into his bag.\nProblem Description\nTask: The goal of this code problem is to implement an algorithm for the fractional knapsack problem. \nInput Format: The first line of the input contains the number 𝑛 of items and the capacity 𝑊 of a knapsack. The next 𝑛 lines define the values and weights of the items. The 𝑖-th line contains integers 𝑣𝑖 and 𝑤𝑖—the value and the weight of 𝑖-th item, respectively. \nConstraints: 1≤𝑛≤103,0≤𝑊 ≤2·106;0≤𝑣𝑖 ≤2·106,0<𝑤𝑖 ≤2·106 for all 1≤𝑖≤𝑛.All the numbers are integers. \nOutput Format Output the maximal value of fractions of items that fit into the knapsack. The absolute value of the difference between the answer of your program and the optimal value should be at most\n−3\nyour answer, while being computed correctly, can turn out to be wrong because of rounding issues).\n\nSample 1.\nInput:\n3 50\n60 20\n100 50\n120 30\nOutput:\n180.0000\nTo achieve the value 180, we take the first item and the third item into the bag.\n\nSample 2.\nInput:\n1 10\n500 30\nOutput:\n166.6667\nMy code:\n```\n# Maximum Value of the Loot\n\ndef knapsack(n, capacity, value_list, weight_list):\n    unitValues_list = []\n    \n    #First lets calculate the unitValues_list\n    for i in range (n):\n        unitValue = (value_list[i]/weight_list[i])\n        unitValues_list.append(unitValue)\n    \n    #Now lets fill the knapsack, intake is how much is in the bag at the moment!\n    intake = 0\n    max_value = 0\n    factor = True\n\n    while(factor):\n        max_index = unitValues_list.index(max(unitValues_list, default=0)) \n        # this gives the index of the max valued element\n        \n        if(weight_list[max_index] <= capacity):\n            # In this case, full item is taken in\n            intake = weight_list[max_index]\n            capacity -= weight_list[max_index]\n            max_value += value_list[max_index]\n            \n        else:\n            # weight_list[max_index] > capacity\n            # In this case, fraction to be taken\n            intake += capacity\n            capacity = 0\n            max_value += unitValues_list[max_index]*intake\n            \n        weight_list.pop(max_index)\n        value_list.pop(max_index)\n        unitValues_list.pop(max_index)\n        print(weight_list)\n\n        n -= 1 #no. of items left\n        factor = ((n != 0) if ((capacity != 0) if True else False) else False)\n\n    return max_value\n\nif __name__ == \"__main__\":\n    value_list = []\n    weight_list = []\n    \n    #The first line of the input contains the number 𝑛 of items and the capacity 𝑊 of a knapsack. \n    #The next 𝑛 lines define the values and weights of the items. \n    \n    n , capacity = map(int, input().split())\n    \n    for i in range (n):\n        value , weight = map(int, input().split())\n        value_list.append(value)\n        weight_list.append(weight)\n        \n    #Output the maximal value of fractions of items that fit into the knapsack.\n    print(\"{:.10f}\".format(knapsack(n, capacity, value_list, weight_list)))\n```\n\nI keep getting an error:\nFailed case #6/13: Wrong answer\ngot: 8740.3008948546 expected: 7777.731\n(Time used: 0.00/5.00, memory used: 9191424/671088640.)\n    ", "Answer": "\r\nCorrecting Wrong Answer\n\nCorrected fraction to be taken by changing\n\n```\nintake += capacity\ncapacity = 0\nmax_value += unitValues_list[max_index]*intake\n```\n\n\nTo\n\n```\nfraction = capacity / weight_list[max_index] \nmax_value += value_list[max_index]*fraction\ncapacity = 0 \n```\n\n\nRefactored Code\n\n```\ndef knapsack(n, capacity, value_list, weight_list):\n    unitValues_list = []\n\n    #First lets calculate the unitValues_list\n    for i in range (n):\n        unitValue = (value_list[i]/weight_list[i])\n        unitValues_list.append(unitValue)\n\n    #Now lets fill the knapsack, intake is how much is in the bag at the moment!\n    intake = 0\n    max_value = 0\n    factor = True\n\n    while(factor):\n        max_index = unitValues_list.index(max(unitValues_list, default=0)) \n        # this gives the index of the max valued element\n\n        if(weight_list[max_index] <= capacity):\n            # In this case, full item is taken in\n            intake = weight_list[max_index]\n            capacity -= weight_list[max_index]\n            max_value += value_list[max_index]\n\n        else:\n            # weight_list[max_index] > capacity\n            # In this case, fraction to be taken\n            fraction = capacity / weight_list[max_index] \n            max_value += value_list[max_index]*fraction\n            capacity = int(capacity - (weight_list[max_index] * fraction))\n\n        weight_list.pop(max_index)\n        value_list.pop(max_index)\n        unitValues_list.pop(max_index)\n        print(weight_list)\n\n        n -= 1 #no. of items left\n        factor = ((n != 0) if ((capacity != 0) if True else False) else False)\n\n    return max_value\n\nif __name__ == \"__main__\":\n    value_list = []\n    weight_list = []\n\n    #The first line of the input contains the number 𝑛 of items and the capacity 𝑊 of a knapsack. \n    #The next 𝑛 lines define the values and weights of the items. \n\n    n , capacity = map(int, input('n, capacity: ').split())\n\n    for i in range (n):\n        value , weight = map(int, input('value, weight: ').split())\n        value_list.append(value)\n        weight_list.append(weight)\n\n    #Output the maximal value of fractions of items that fit into the knapsack.\n    print(\"{:.10f}\".format(knapsack(n, capacity, value_list, weight_list)))\n```\n\n\nNote\n\nTime was not mentioned as an issue.  \n\nComplexity can be changed from current O(n^2) algorithm to O(n*log(n)) by sorting unitValues_list rather than computing max each time.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why is the runtime of Knapsack Problem in terms of n and 2 number of bits of W\r\n                \r\nI recently began to understand what pseudo polynomial means thanks to this post. However, a burning question of mine is why does the knapsack problem when used with dynamic Programming has a runtime of  and not . Where n is number of items that are being considered for the knapsack and  which is the number of bits needed to encode W and  is number of possible states(values) given x bits. Considering that the formal definition of time complexity defines the size of a problem as \n\n\n  The size of the input to a problem is the number of bits required to\n  write out that input.\n\n\nSince number of bits for the weight is not fixed but rather variable, there are at most  total number of bits for all the possible values from 0 to W times the value n or . With that being said why is the runtime for the knapsack when paired with dynamic programming has a runtime of  and not . I know that  but time complexity refers to size of the input as number of bits. What assumptions am I making, or what piece of knowledge am I missing that would rectify the disconnect.\n    ", "Answer": "\r\nHere is an explanation related to the knapsack input size. \n\n\nThe number of items n can be represented by O(lg n) bits;\nn item weights: noting that each item weight must be ≤ W (otherwise we can ignore those items weighting more than W), we can represent each item weight using O(lg W) bits for a total of O(n lg W) bits;\nn item values: let the maximum value be V. Then, each item value can be represented using O(lg V) bits for a total of O(n lg V) bits.\n\n\nThe total input size therefore is O(lg n+n(lg W+lg V)) = O(n(lg W+lg V)).\n\nLet b = lg W and v = lg V. Then the input size is O(n(b+v)). Now, note that in the  O(nW) running time for the Dynamic Programming solution v doesn’t show up explicitly, so that the running time is O(nW) = O(n2^b).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Continuous Knapsack Vs. 0-1 Knapsack\r\n                \r\nWhy does greedy approach work for continuous knapsack and not for 0-1 knapsack problem?\n    ", "Answer": "\r\nFor continuous knapsack, you can't have ```\nq > 0```\n of an item with the cost ```\nc```\n per unit in an optimal solution, while leaving ```\nq' > 0```\n of an another item with the cost ```\nc' > c```\n. Otherwise, you simply replace ```\nmin(q, q')```\n amount of the first item with the same amount of the second, increasing total cost by ```\nmin(q,q')*(c' - c)```\n.\n\nFor 0-1 knapsack, where is a counterexample for a naive greedy algorithm. Consider items with weight ```\n6, 5, 4```\n and cost ```\n8, 5, 4```\n. Let the total allowed weight be ```\n9```\n. Clearly, optimal solution is to take the second and third items for the total cost of ```\n9```\n, but the first item is worth more, both in absolute value and relative to its weight, so should be selected by `greedy' algorithm.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "list index out of range for knapsack problem without repetition\r\n                \r\nProblem introduction:\n\nYou are given a set of bars of gold and your goal is to take as much gold as possible into\nyour bag. There is just one copy of each bar and for each bar you can either take it or not\n(hence you cannot take a fraction of a bar).\n\nProblem Description:\n\nTask. Given 𝑛 gold bars, find the maximum weight of gold that fits into a bag of capacity 𝑊.\nInput Format. The first line of the input contains the capacity 𝑊 of a knapsack and the number 𝑛 of bars of gold. The next line contains 𝑛 integers 𝑤0, 𝑤1, . . . , 𝑤𝑛−1 defining the weights of the bars of gold.\nConstraints. 1 ≤ 𝑊 ≤ 10⁴\n; 1 ≤ 𝑛 ≤ 300; 0 ≤ 𝑤0, . . . , 𝑤𝑛−1 ≤ 10⁵.\nOutput Format. Output the maximum weight of gold that fits into a knapsack of capacity 𝑊.\n\nMy code is as follows:\n```\n\n# Uses python3\nimport sys\n\ndef optimal_weight(W, w):\n    # write your code here\n    n = len(w)\n    value = [[0] * (W+1) for i in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(1, W+1):\n            value[i][j] = value[i-1][j]\n            # does not check every single possible weight\n            # must loop through all diagonally top left cells\n            v = w[i-1] + value[i-1][j-w[i-1]]\n            \n            if v <= j:\n                value[i][j] = max(v, value[i][j])\n            \n    return value[n][W]\n\nif __name__ == '__main__':\n    input = sys.stdin.read()\n    W, n, *w = list(map(int, input.split()))\n    print(optimal_weight(W, w))\n\n```\n\nMy solution worked for the sample test cases given, but was rejected for one of the test cases:\n\nFailed case #7/14: Wrong answer\nwrong output format: list index out of range\n (Time used: 0.01/10.00, memory used: 11313152/2147483648.)\n\nMay I know what could have resulted in the error or if there is a better way to implement a DP solution to this problem?\n    ", "Answer": "\r\nThe only possible cause in my opinion is this statement:\n```\nv = w[i-1] + value[i-1][j-w[i-1]]\n```\n\nThere aren't any constraints which dictate that ```\nj-w[i-1]```\n will be a valid index. Just replace it with\n```\nif j-w[i-1] >= 0:\n    v = w[i-1] + value[i-1][j-w[i-1]]\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Getting problems in my knapsack implementation(PARTY)\r\n                \r\nI was trying to do this simple question from spoj today, and it being the knapsack problem, I have implemented it as follows:\n\n```\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n    while(true)\n    {\n        int budget, t;\n        scanf(\"%d%d\", &budget, &t);\n        if(budget == 0 && t == 0)\n            break;\n\n        int cost[t], fun[t]; \n        vector<pair<double, int> > knap;\n        for(int i = 0;i < t;i++)\n        {\n            scanf(\"%d%d\", &cost[i], &fun[i]);\n            knap.push_back(pair<double, int>(double(fun[i])/double(cost[i]), i));        \n        }\n        sort(knap.rbegin(), knap.rend());\n        int totfun = 0, bud = budget;\n        for(int i = 0;i < int(knap.size());i++)\n        {\n            if(bud - cost[knap[i].second] >= 0)\n            {\n                bud -= cost[knap[i].second];\n                totfun += fun[knap[i].second];        \n            }\n        }\n        printf(\"%d %d\\n\", budget-bud, totfun);\n    }\n}\n```\n\n\nBut this solution give WA(Wrong answer). I have tried all the test cases in spoj's own forum, and my code seems to pass them all, Can anyone guide me, this is one of the first DP problems I've tried... \n    ", "Answer": "\r\nThe code in the question does not implement exact solution via Dynamic Programming, but a greedy algorithm which in general does not calculate an optimal solution. The task from the link in the question apparently requires generation of an optimal solution, however.\n\nThe suboptimality of the greedy algorithm can be proved by considering the following instance.\n\n```\nItem 1: Function 6, Cost 4 (Ratio 18/12)\nItem 2: Function 4, Cost 3 (Ratio 16/12)\nItem 3: Function 3, Cost 3 (Ratio 12/12)\n\nCapacity: 6\n```\n\n\nThe greedy algorithm would choose ```\nItem 1```\n, yielding a profit of ```\n6```\n. However choosing ```\nItem2```\n and ```\nItem3```\n yields a total profit of ```\n7```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Can I add variables to a 2D knapsack problem that can take multiple values?\r\n                \r\nthis is my first question on stack overflow and I am quite new to OR, so bear with me.\nI am trying to solve what could be considered a rectangular 2D knapsack problem with a twist. In order to solve the problem, I need to fill out the entire knapsack. I am, however, allowed to produce rectangles with a minimum height and width - and ratio between these. I would like to build a model that takes this into consideration (and obviously weighs the produced rectangles lower than the ones in existence).\nI am currently using the ORTools' CP-SAT model in python. I am open to model changes, if other models better fit this problem. The model solves the ordinary packing problem and finds feasible and optimal solutions, however, the holes left in my knapsack are problematic.\nBasically, the dumbest way to solve this would be to create tonnes of rectangles that have different sizes and including them in my variable list with a lower value than the rest. Isn't there a smarter way to go about this?\nThis is my solution so far. Don't mind the blue lines, they are part of the problem that I have fixed.\nIn the image, the hole containing two red rectangles would be suitable for me to produce these two rectangles, however, the crossed out holes are too small (and slim in some places)...\nI would appreciate your help. If anything is unclear, please ask!\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Modified knapsack problem gets stuck in infinite loop\r\n                \r\nI've been trying to implement a modified knapsack problem algorithm regarding bioinformatics.\nWhat I have so far is, in my opinion, pretty close to the solution, but the program gets stuck at a certain point.\nI have a list of nodes which have mass (of a certain amino-acid), index, and list of nodes that they can get to.\nNODE:\n```\nclass Node():\ndef __init__(self, mass, index):\n    self.mass = mass\n    self.prev = []\n    self.next = []\n    self.index = index\n\n\ndef chainTo(self, next):\n    self.next.append(next)\n    next.prev.append(self)\n```\n\nThe goal is to find the longest chain possible from given nodes so I could then find from their masses which peptide do they represent.\nTo do that, I have written a function that goes through the list of all nodes and chains them to one another if nodes[i].mass - nodes[j].mass is equal to some amino-acid mass which are predefined in a .txt file.\n```\ndef createTree(massTable, massDev, aminoTable, extras):\n    nodes = createNodes()\n\n    for i in range(0, len(nodes)):\n        for j in range(i+1, len(nodes)):\n            findAmino(nodes[i], nodes[j], massTable, massDev, aminoTable, extras)\n\n    return nodes\n\ndef findAmino(first, second, massTable, massDev, aminoTable, extras):\nfound = False\nfor amino, mass in massTable.items():\n    for extra, extraMass in extras.items():\n        #print(first.mass - second.mass)\n        if ((mass + extraMass - massDev) <= abs(first.mass - second.mass) <= (mass + extraMass + massDev)):\n            first.chainTo(second) #pravimo vezu\n            #print(amino)\n            aminoTable.update({(first, second) : amino})\n            found = True\n            break\n\nreturn False if not found else True #ako ne nađe niti jednu mogućnost, vraća False\n```\n\nSo the final and the main part of the code is the tree-traversing algorithm which follows specific rules:\n\nTake the first node from the list (if it has no nodes in its next list, take the second one, and so on)\nCall the tree-traversal algorithm to find all possible paths (for example, if node[0] has node[1] and node[2] in its next list, then the tree-traversal algorithm has to find path node[0]->node[1] and node[0]->node[2]\nFrom all the generated paths, the program takes the longest one\nProgram repeats step 1 but it doesn't take the first node from the list, but rather the one after the last in the longest found path\nWhen it comes to the last node, it ends and returns list of longest possible chains.\n\n```\ndef traverseRoot(root, chains):\n    traverse(root, [], chains)\n\n#node - čvor na kojem se nalazimo\n#ako nema susjede, u chains dodajemo taj put\n#ako ima, pokrecemo isti algoritam\ndef traverse(node, path, chains):\n    path.append(node)\n    if(len(node.next) == 0):\n        chains.append(path)\n    else:\n        for i in node.next:\n            print(str(i.mass) + \" \" + str(i.index))\n            traverse(i, path.copy(), chains)\n\n\ndef start(nodes, massTable, massDev, extras):\n        #IDEJA:\n        #1. funkcija uzima prvi čvor (ukoliko nema prijelaze, uzima idući, pa idući, itd.)\n        #2. nad tim čvorom provodi neku vrstu tree-traversing algoritma kako bi prošao sve puteve\n        #3. uzima kao konačni put onaj koji je došao najdalje u listi / pokrio najviše čvorova\n        #4. ponavlja sve počevši od prvog koraka samo što ne uzima prvi čvor nego onaj koji dolazi nakon zadnjeg u prethodno pronađenom putu\n        #5. kad dođe do zadnjeg čvora, prestaje sa radom i vraća listu stvorenih lanaca po čijim čemo vezama gledati koje aminokiseline predstavljaju\n        start = 0\n        finalChains = []\n        while(True):\n            currentNodeChains = []\n            found = False\n            for i in range(start, len(nodes)):\n                if(not nodes[i].next): #1.\n                    continue\n                else:\n                    found = True\n                    print(start)\n                    traverseRoot(nodes[i], currentNodeChains) #2.\n                    break\n            \n            if (not found):\n                return finalChains\n                \n            #3.\n            maxLen = 0\n            maxChain = None\n            for chain in currentNodeChains:\n                if (len(chain) > maxLen):\n                    maxLen = len(chain)\n                    maxChain = chain\n            if (maxChain != None):\n                finalChains.append(maxChain)\n                print([i for i in maxChain])\n                print(\"-----------\")\n                start = maxChain[-1].index + 1 #4.\n        return finalChains\n```\n\nMy whole problem is that the program gets stuck at a certain point.\nFor example, I have 300 nodes, and it gets stuck in an infinite loop somewhere towards the end, around 280th node in the example that I'm running it on.\nI doubt that it has to do something with this specific example that I'm running, but more probably there is a logical error somewhere in the recursive function calls.\nIf anyone has a clue as where would the problem lie, I would much appreciate any answer!\n    ", "Answer": "\r\nWhile trying to debug the code, the problem seemed to be in the whole concept of the attribute next in the Node class.\nWhen I printed out all of the Nodes' next lists, I found multiple occurences of the same Node, for example [2,2,2,3,8,...] so when I converted the list to set it didn't get stuck anymore.\nHope this helps someone in the future.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Bin-packing (or knapsack?) problem\r\n                \r\nI have a collection of 43 to 50 numbers ranging from 0.133 to 0.005 (but mostly on the small side).  I would like to find, if possible, all combinations that have a sum between L and R, which are very close together.*\n\nThe brute-force method takes 243 to 250 steps, which isn't feasible.  What's a good method to use here?\n\nEdit: The combinations will be used in a calculation and discarded. (If you're writing code, you can assume they're simply output; I'll modify as needed.)  The number of combinations will presumably be far too large to hold in memory.\n\n* L = 0.5877866649021190081897311406, R = 0.5918521703507438353981412820.\n    ", "Answer": "\r\nThe basic idea is to convert  it to an integer knapsack problem (which is easy). \n\nChoose a small real number ```\ne```\n and round numbers in your original problem to ones representable as ```\nk*e```\n with integer ```\nk```\n. The smaller ```\ne```\n, the larger the integers will be (efficiency tradeoff) but the solution of the modified problem will be closer to your original one. An ```\ne=d/(4*43)```\n where d is the width of your target interval should be small enough. \n\nIf the modified problem has an exact solution summing to the middle (rounded to ```\ne```\n) of your target interval, then the original problem has one somewhere within the interval.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python implementation of Multiple-Choice Knapsack\r\n                \r\nI have been searching for python implementation of multiple choice knapsack problem. So far I have found a java implementation in github: https://github.com/tmarinkovic/multiple-choice-knapsack-problem\n\nAnd a psedu-code: http://www.or.deis.unibo.it/kp/Chapter6.pdf\n\nI have yet to find a python implementation. If there is a library implementing the multiple-choice knapsack problem I would be grateful to find out.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem Variant - Maximizing Weight and Value Up To Limit\r\n                \r\nI'm trying to work out an algorithm (likely using OR Tools in Python) for solving a problem that seems to be related to the Knapsack problem.\n\nI have a set of items at Location A\nI want to get them to Location B\nEach item has a weight and a value\nI can only carry X amount of weight\nI'm afraid of getting robbed along the way, so I only want to carry up to Y amount of value\n\nIf I'm trying to plan my first trip from Location A to Location B, how can I select the items such that:\n\nI maximize the weight that is loaded, up to a limit of X (minimize wasted weight capacity)\nI maximize the value that is loaded, up to a limit of Y (minimize wasted value capacity)\n\nA contrived example:\n\nMy limits are 5kg and $50\nI have 10 of Item C (weight: 0.1kg, value: $10)\nI have 10 of Item D (weight: 1kg, value: $1)\n\nThe \"easy\" solution is to make 4 trips:\n\n5x Item C ($50, 0.5kg)\n5x Item C ($50, 0.5kg)\n5x Item D ($5, 5kg)\n5x Item D ($5, 5kg)\n\nBut the smarter solution is to make only 3 trips:\n\n4x Item C + 4x Item D ($44, 4.4kg)\n4x Item C + 4x Item D ($44, 4.4kg)\n2x Item C + 2x Item D ($22, 2.2kg)\n\nI've worked with the OR Tools linear solver, but only with maximizing one value while having multiple constraints. How can I maximize multiple values (loaded weight and loaded value) with multiple constraints?\n    ", "Answer": "\r\nI believe I found a solution to this. What I did was try to maximize a composite variable that accounts for both weight and value. In Python with OR Tools:\n```\nobjective = solver.Objective()\n\nfor i, item in enumerate(item_list):\n    objective.SetCoefficient(x[i], item['mass']/max_volume + item['value']/max_value)\n\nobjective.SetMaximization()\n```\n\nThis sets the coefficient to account for both mass and value. The important part is that each is normalized against its associated limit. This solution is consistently giving me sets of items that fully use both the weight and value \"space\" to their full extent.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Binary Knapsack problem modification with dynamically changing value based on the solution\r\n                \r\nI have stumbled upon this problem while trying to solve a problem using 0/1 Knapsack algorithm. I have tried to come up with a modification to the algorithm but failed :(\nI have a subset of items, each of the items has its own weight and value, but they also can belong to the same category thus there is a parametr called category_sum that sums values from the given category. Example subset:\n```\nX = [(item1, weigth=1, value=1, category=1, category_sum=3),\n     (item2, weigth=4, value=5, category=2, category_sum=5),\n     (item3, weigth=3, value=2, category=1, category_sum=3)]\n```\n\nThe values which are actually passed to the knapsack algorithm are \"category_sum\"\nThe problem is:\nWhen the solution includes only one item from each category, all is fine, but when the solution would include for example item1 and item2, their category_sum should be divided by 2 since it is a cumulative sum of the whole category.\nI am looking for a way to implement it into DP solution.\nThank you!\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack problem using brute force method in python\r\n                \r\nI am applying the following code to obtain the max CBU. Can I also get the list of selected items in a knapsack? Here is my code\n```\ndef knapsack(CBU, weight, Capacity):\n    return knapsacksolution(CBU, weight, Capacity, 0)\ndef knapsacksolution(CBU, weight, Capacity, currentIndex):\n    \n    if Capacity <= 0 or currentIndex >= len(CBU):\n        return 0\n    CBU1 = 0\n    #selecting a box at currentindex\n    if CBU[currentIndex] <= Capacity:\n         CBU1 = CBU[currentIndex] + knapsacksolution(CBU, weight, Capacity - CBU[currentIndex], currentIndex+1)\n    #excluding a box at currentindex\n    CBU2 = knapsacksolution(CBU, weight, Capacity, currentIndex+1)\n    \n    return max(CBU1, CBU2)\ndef main():\n    weight = [20,15,17,24]\n    CBU = [3,2,3,4]\n    Capacity = 8\n    \n    OptimalCBU = knapsack(CBU, weight, Capacity)\n    print('Optimal CBU for CBU:{} with weight:{} for Capacity:{} is:{}'.format(CBU, weight, Capacity, OptimalCBU))\nif __name__ == '__main__':\n    main()\n```\n\nResult is as follow\nOptimal CBU for CBU:[3, 2, 3, 4] with weight:[20, 15, 17, 24] for Capacity:8 is:8\n    ", "Answer": "\r\nJust recently I learned the itertools.combinations method (from reading solutions on SO).  It seems like a simple tool for generating all of the various configurations of the knapsack.\nIn the code below, we use ```\ncombinations```\n to find all of the combinations of the knapsack configuration, throwing out all of the combos that are over the capacity.\nHaving used brute force to find all of the viable answers, it remains simply to sort the results and present the maximum pay solution.\nHere's the code that does just this (it has not been optimized):\n```\nimport itertools\n\ndef sum_solution( solutions ):\n  pay, load = 0,0\n  for block in solutions:\n    pay += block[0]\n    load += block[1]\n\n  return pay, load \n\ndef knapsack( capacity, blocks ):\n\n  solutions = []\n  for count in range(len(blocks)+1):\n    for solution in itertools.combinations( blocks, count ):\n      pay,load = sum_solution( solution ) \n      if load <= capacity:\n        solutions.append((pay,load,solution))\n\n  solutions.sort( reverse = True, key = lambda x : x[0] )\n  return solutions\n\n\nsolutions = knapsack( 15, [ (4,12) , (2,1) , (10,4), (1,1), (2,2) ])\nsolution = solutions[0]\nprint( f\"Maximum Cash:  {solution[0]}  Weight: {solution[1]} Contents:  {solution[2]}\")\n\n\nprint(f\"Cash  Weight Contents\")\nfor solution in solutions:\n  print(f\"{solution[0]:5d} {solution[1]:6d} {solution[2]}\")\n```\n\nHere's the results:\n```\nMaximum Cash:  15  Weight: 8 Contents:  ((2, 1), (10, 4), (1, 1), (2, 2))\nCash  Weight Contents\n   15      8 ((2, 1), (10, 4), (1, 1), (2, 2))\n   14      7 ((2, 1), (10, 4), (2, 2))\n   13      6 ((2, 1), (10, 4), (1, 1))\n   13      7 ((10, 4), (1, 1), (2, 2))\n   12      5 ((2, 1), (10, 4))\n   12      6 ((10, 4), (2, 2))\n   11      5 ((10, 4), (1, 1))\n   10      4 ((10, 4),)\n    8     15 ((4, 12), (2, 1), (2, 2))\n    7     14 ((4, 12), (2, 1), (1, 1))\n    7     15 ((4, 12), (1, 1), (2, 2))\n    6     13 ((4, 12), (2, 1))\n    6     14 ((4, 12), (2, 2))\n    5     13 ((4, 12), (1, 1))\n    5      4 ((2, 1), (1, 1), (2, 2))\n    4     12 ((4, 12),)\n    4      3 ((2, 1), (2, 2))\n    3      2 ((2, 1), (1, 1))\n    3      3 ((1, 1), (2, 2))\n    2      1 ((2, 1),)\n    2      2 ((2, 2),)\n    1      1 ((1, 1),)\n    0      0 ()\n```\n\nI modified the problem statement to use an example I found at wikipedia.  Simply put, the blocks were:\n```\n$4, 12 kg\n$2, 2 kg\n$1, 1 kg\n$2, 1 kg\n$10,4 kg \n```\n\nYou can see that I coded the blocks as this:\n```\n[ (4,12) , (2,1) , (10,4), (1,1), (2,2) ]\n```\n\nAnyway, HTH.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to solve multiple knapsacks problem with genetic algorithm using PyGAD?\r\n                \r\nI'm trying to solve the multiple knapsacks problem (MKP), in which I want to fit ```\nn```\n items into ```\nm```\n containers (knapsacks). Items have their weights and knapsacks capacity that they can hold.\nI decided to solve it with genetic algorithm in Python using PyGAD. For that I expressed the problem with binary representation, but despite ```\ninitial_population```\n being ```\nm```\nx```\nn```\n, the solution it's looking for has only one knapsack (1x```\nn```\n), so I get an error.\nHow to configure PyGAD to look for a ```\nm```\n-dimensional solution?\nThis is my code right now:\n```\nimport numpy as np\nimport pygad\nimport random\n\nknapsacks = np.array([7, 8])\nitems = np.array([3, 4, 5])\n\ninitial_population = np.array([\n    [1, 0, 0],  # first knapsack\n    [0, 1, 0]   # second knapsack\n])\n\ndef fitness_func(solution, solution_idx):\n    # if sum of items in any knapsack exceeds capacity -> fail\n    if np.sum(np.sum(solution*items, axis=1) > knapsacks) != 0:\n        fitness = 10e4  # penalty\n    # if two items in one column -> fail (an item can't be in two knapsacks)\n    elif np.sum(np.argwhere(np.sum(initial_population, axis=0) > 1)):\n        fitness = 10e4  # penalty\n    else:\n        fitness = np.sum(solution*items)\n    # the higher fitness (sum of items) the better\n    return fitness\n\nga_instance = pygad.GA(\n    num_generations=30,\n    num_parents_mating=2,\n    fitness_func=fitness_func,\n    sol_per_pop=10,\n    num_genes=initial_population.size,\n    gene_space=[0, 1], # binary representation\n    mutation_by_replacement=True,\n    gene_type=int,\n    parent_selection_type=\"sss\",    # steady_state_selection()\n    keep_parents=1,\n    crossover_type=\"single_point\",\n    mutation_type=\"random\",\n    mutation_num_genes=1,  # mutation_percent_genes=10,\n    initial_population=initial_population\n    )\n\nga_instance.run()\nsolution, solution_fitness, solution_idx = ga_instance.best_solution() \n\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "A variation of the knapsack problem where some items must be included but don't count towards the objective\r\n                \r\nI am trying to solve a variation of the 0/1 knapsack problem where n items must be picked, but only k < n items' values are counted towards the objective function.\nMy idea was to set up two vectors of binary variables, x and y - x denoting which n items are picked, and y denoting which k items are counted towards the objective - however my problem is ensuring that y is a subset of x.\nI am using the python mip library, and here is the code I have so far (a slightly modified version of the knapsack example in the mip documentation):\n```\nfrom mip import Model, xsum, maximize, BINARY\n\nvalues = [10, 13, 18, 31, 7, 15, 8, 11, 3, 9, 13, 12, 11, 6, 18, 11, 18, 13, 12, 11]\nweights = [11, 15, 20, 24, 9, 16, 12, 3, 6, 9, 17, 13, 20, 9, 32, 14, 19, 20, 12, 13]\n\nmax_weight = 200\nI = range(len(weights))\nm = Model(\"knapsack\")\n\nx = [m.add_var(var_type=BINARY) for i in I]\ny = [m.add_var(var_type=BINARY) for i in I]\n\nm += xsum(x[i] for i in I) == 15 # n\nm += xsum(y[i] for i in I) == 11 # k\nm += xsum(weights[i] * x[i] for i in I) <= max_weight\n\nm.objective = maximize(xsum(values[i] * y[i] for i in I))\n\n# `m += xsum(x[i] * y[i] for i in I) == 11` doesn't work\nm.optimize()\n\nselected_x = [i for i in I if x[i].x >= 0.99]\nselected_y = [i for i in I if y[i].x >= 0.99]\nprint(\"selected items: {}\".format(selected_x))\nprint(\"selected items: {}\".format(selected_y))\n\n#Output:\n# selected items: [0, 1, 2, 4, 6, 7, 8, 11, 12, 13, 15, 16, 17, 18, 19]\n# selected items: [1, 2, 3, 5, 10, 11, 14, 16, 17, 18, 19]\n```\n\nAny help would be great, thank you.\nedit: for anyone finding this in the future, simply adding\n```\nfor i in I:\n    m += x[i] >= y[i]\n```\n\nworks perfectly.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem - Recursive solution explanation\r\n                \r\nI’m having trouble understanding how and why this naive recursive solution works. If I was given this problem for the first time, I’d think of doing an exhaustive search (iteratively) with all possible combinations, recording and returning the maximum value at the end. Can someone please explain this solution?\n\n\n\nCode from CSDojo\n    ", "Answer": "\r\nThis solution works because the logic is sound. Let's put that logic into words:\n\nMax value for capacity ```\nC```\n, using any of the first to ```\nn```\nth items:\n\n```\ndef KS(n, C):\n```\n\n\nIf we're not using any items or we have no capacity, then we have zero value:\n\n```\nIf n == 0 or C == 0:\n  result = 0\n```\n\n\nOtherwise if the weight of this (the ```\nn```\nth) item is greater than this capacity (```\nC```\n), use the best result we can get for this capacity (```\nC```\n) without this item. That's the solution for ```\nMax value for capacity C, using any of the first to (n-1)th items```\n (remember that the current calculation is looking for ```\nKS(n, C)```\n so we're not permitted to use any items after the ```\nn```\nth in the list):\n\n```\nelse if w[n] > C:\n  result = KS(n - 1, C)\n```\n\n\nOtherwise, let's decide if we should use this item or not:\n\n```\nelse:\n```\n\n\nIf we don't use the ```\nn```\nth item, that's the same as our previous possibility: the solution for ```\nMax value for capacity C, using any of the first to (n-1)th items```\n:\n\n```\n  tmp1 = KS(n - 1, C)\n```\n\n\nIf we do use it, since the current calculation is looking for a solution for capacity ```\nC```\n, let's add the current value, ```\nv[n]```\n, to our solution using any of the previous ```\nn-1```\n items, but with capacity ```\nC - current_weight```\n so that together with the current weight, ```\nw[n]```\n, we will be presenting the solution that still leaves capacity ```\nC```\n:\n\n```\n  tmp2 = v[n] + KS(n - 1, C - w[n])\n```\n\n\nChoose the higher value:\n\n```\n  result = max{ tmp1, tmp2 }\n```\n\n\nReturn the correct result for our current parameters:\n\n```\nreturn result \n```\n\n\nRecursion can be a little counter-intuitive. Calling ```\nKS(n, C)```\n will generate a whole bunch of calls to \"earlier\" parameters ```\nn - 1```\n, ```\nn - 2```\n, etc., and lower capacities, which makes it seem like those calls are happening after the initial call. But actually ```\nKS(n, C)```\n is waiting for all those to complete in order to answer its own calculation so we can accurately say it's happening after the \"earlier\" parameter calls. And many of them might get repeated, when the parameter values coincide, which is why it can be useful to cache them to speed up the routine.\n\nIt can also be useful to consider ```\nn, C```\n as the \"search space\" of the formulation. That means we're really restricted to ```\nn * C```\n different combinations of parameters. That's why some recursions, like knapsack, are often tabulated as an iteration over ```\nn```\n and ```\nC```\n (nested ```\nfor```\n loops, for example).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "docplex maximize problem with multiple knapsack problem\r\n                \r\n```\nimport numpy as np\nfrom docplex.mp.model import Model\nrnd = np.random\nrnd.seed(1995)\n\n#Number of Objects\n\nN = 12  \nM = 3    \n\n#Gnerate the list of objects indices\n\nObj = [j for j in range(0, N)]\nKnap = [i for i in range(0, M)]\n\nprint(Obj)\nprint(Knap)\n\n#Generate objects weights and save them in W list\n\nW = rnd.randint(5, 50, size=N)    \nprint(W)\n\n#Generate objects profits and save them in P list  \n\nP = rnd.randint(10, 100, size=N)  \nprint(P)\n\n#Knapsack Capacity\n\nC = rnd.randint(1, 5, size=M)   ### different of m capisties \n\n\nprint(C)\n\n\n#Create the model\n\nmdl = Model('MKP')\n\n#Define decision variables    \n    \nx = mdl.binary_var_matrix(Obj,M, name='x')\n\nprint(x)\n\n#Add objective function\n\nmdl.maximize(mdl.sum(P[j]*x[j] for j in Obj))   \n \n## mdl.maximize(mdl.sum(P[i]*x[j][i] for i in Knap))   \n\n#Add capacity constraint\n\nmdl.add_constraints(mdl.sum(W[j]*x[j] for j in Obj) <= C[i] for i in Knap)\nmdl.add_constraints(mdl.sum(x[j][i] for i in Knap) <= 1 for j in Obj)\n\n#Write the model on lp file\n\nmdl.export_as_lp(\"./mkp.lp\")\n\n#Define the cpu time limit   \n  \nmdl.parameters.timelimit = 300 \n\n#Solve the model\n\nsolution = mdl.solve(log_output=True)   \n\n#Print the solution status\n\nprint(solution.solve_status)    \n\n#Print the solution\n\nprint(solution)\n```\n\nWell, how about adding more details. Like, what are you trying to accomplish, how are you doing it, what difficulties you have found with the approach, another approaches you have tried, etc. In summary, without code isn't a good question neither is with just code. Search for the balance!\nthis is output how can i solve this maximize problem\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n[0, 1, 2]\n[41 23 43 10 34 25 33  6 16 14 40 11]\n[59 73 50 89 74 66 22 62 42 40 27 10]\n[3 2 3]\n{(0, 0): docplex.mp.Var(type=B,name='x_0_0'), (0, 1): docplex.mp.Var(type=B,name='x_0_1'), (0, 2): docplex.mp.Var(type=B,name='x_0_2'), (1, 0): docplex.mp.Var(type=B,name='x_1_0'), (1, 1): docplex.mp.Var(type=B,name='x_1_1'), (1, 2): docplex.mp.Var(type=B,name='x_1_2'), (2, 0): docplex.mp.Var(type=B,name='x_2_0'), (2, 1): docplex.mp.Var(type=B,name='x_2_1'), (2, 2): docplex.mp.Var(type=B,name='x_2_2'), (3, 0): docplex.mp.Var(type=B,name='x_3_0'), (3, 1): docplex.mp.Var(type=B,name='x_3_1'), (3, 2): docplex.mp.Var(type=B,name='x_3_2'), (4, 0): docplex.mp.Var(type=B,name='x_4_0'), (4, 1): docplex.mp.Var(type=B,name='x_4_1'), (4, 2): docplex.mp.Var(type=B,name='x_4_2'), (5, \n0): docplex.mp.Var(type=B,name='x_5_0'), (5, 1): docplex.mp.Var(type=B,name='x_5_1'), (5, 2): docplex.mp.Var(type=B,name='x_5_2'), (6, 0): docplex.mp.Var(type=B,name='x_6_0'), (6, 1): docplex.mp.Var(type=B,name='x_6_1'), (6, 2): docplex.mp.Var(type=B,name='x_6_2'), (7, 0): docplex.mp.Var(type=B,name='x_7_0'), (7, 1): docplex.mp.Var(type=B,name='x_7_1'), (7, 2): docplex.mp.Var(type=B,name='x_7_2'), (8, 0): docplex.mp.Var(type=B,name='x_8_0'), (8, 1): docplex.mp.Var(type=B,name='x_8_1'), (8, 2): docplex.mp.Var(type=B,name='x_8_2'), (9, 0): docplex.mp.Var(type=B,name='x_9_0'), (9, 1): docplex.mp.Var(type=B,name='x_9_1'), (9, 2): docplex.mp.Var(type=B,name='x_9_2'), (10, 0): \ndocplex.mp.Var(type=B,name='x_10_0'), (10, 1): docplex.mp.Var(type=B,name='x_10_1'), \n(10, 2): docplex.mp.Var(type=B,name='x_10_2'), (11, 0): docplex.mp.Var(type=B,name='x_11_0'), (11, 1): docplex.mp.Var(type=B,name='x_11_1'), (11, 2): docplex.mp.Var(type=B,name='x_11_2')}\nTraceback (most recent call last):\n  File \"c:/Users/User/Downloads/Mmmmkp.py\", line 49, in <module>\n    mdl.maximize(mdl.sum(P[j]*x[j] for j in Obj))\n  File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\docplex\\mp\\model.py\", line 2845, in sum\n    return self._aggregator.sum(args)\n  File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\docplex\\mp\\aggregator.py\", line 176, in sum\n    sum_res = self._sum_with_iter(sum_args)\n  File \"C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\docplex\\mp\\aggregator.py\", line 199, in _sum_with_iter\n    for item in args:\n  File \"c:/Users/User/Downloads/Mmmmkp.py\", line 49, in <genexpr>\n    mdl.maximize(mdl.sum(P[j]*x[j] for j in Obj))\nKeyError: 0\n```\n\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with one additional constraint\r\n                \r\nThis is the old and famous knapsack problem : Knapsack Problem\nHere I have Knapsack problem with one constraint.\nI have Knapsack with size W = 100000000 and N = 100 items I  wrote the dynamic solution for it the Complexity of my algorithm is  ```\nO(100000000*100)```\n and this is too big in both time and space but there is one condition here that either ```\nW ≤ 50000 or max 1≤ i ≤ n Vi ≤ 500.```\n so  if my Knapsack size is more than 50000 my maximum value of items is limited.\nSo now I wonder how can I reduce the time Complexity of my algorithm with this condition I thought Knapsack problem depends on the size of knapsack and the number of items so how the value of items can change the change  my algorithm?\n    ", "Answer": "\r\nInstead of creating a table of size ```\nW*n```\n, where each entry ```\nD[x][i]```\n indicates the best value (highest) you can get with at most ```\nx```\n weight using the first ```\ni```\n items, use the table where now ```\nD[x][i]```\n is the minimal weight needed to get to value of ```\nx```\n, using the first ```\ni```\n elements:\n\n```\nD(0,i) = 0                i>0\nD(x,0) = infinity         x > 0\nD(x,i) = infinity         x<0 or i<0\nD(x,i) = min{ D(x,i-1), D(x-value[i],i-1) + weight[i])\n```\n\n\nWhen you are done, find ```\nmax{ x | D(x,n) <= W) }```\n - this is the highest value you can get, using at most ```\nW```\n weight, and is done by a linear scan of the last line of the DP matrix.\n\nChecking which variation you need is done by a single scan of the data.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do I make my procedural Knapsack problem brute-forcer into an object-oriented one?\r\n                \r\nThis is my first shot at brute-forcing the NP-complete knapsack problem.  In this form you have a list of items which must be thrown off a plane each with a weight and cost.  The goal is to throw out some remain_weight while minimizing cost.\n\nEach recursion level(y direction if graphed) is a new remain_weight after items have been selected.  A for loop searches through all the items(x direction if graphed)\n\n```\nTest Case 1 - Works\nItem / Weight / Cost\n0      100     101\n1      300     297\n```\n\n\nWhat is the best way to put these two functions in a class. \n\n```\nenum item_type {weight, cost};\nint algo(int &cost_low, int &cost_high, int throw_weight, int item_id, int item_matrix[][2])\n{\n    int quantity,remainder;\n    quantity=throw_weight/item_matrix[item_id][weight];\n    remainder=throw_weight%item_matrix[item_id][weight];\n    if(remainder==0)\n    {\n        cost_low=(quantity-1)*item_matrix[item_id][cost];\n        cost_high=quantity*item_matrix[item_id][cost];\n        throw_weight-=(quantity-1)*item_matrix[item_id][weight];\n    }\n    else\n    {\n        cost_low=(quantity)*item_matrix[item_id][cost];\n        cost_high=(quantity+1)*item_matrix[item_id][cost];\n        throw_weight-=(quantity)*item_matrix[item_id][weight];\n    }\n    return throw_weight;\n}\nint branch(int remain_weight)\n{\n    static int depth_level = 0;\n    static int cost_present=32000;\n    int remain_weight_next;\n    int cost_low, cost_high, cost_branch;\n    depth_level++;\n    cout << \"Entering at depth: \" << depth_level << \" :remain_weight: \" << remain_weight << endl ;\n    int item_id, item_count=2; \n    int item_matrix[][2] = \n    {\n        {100, 101},\n        {300, 297},\n    //  {400, 401},\n    //  {800, 800}, \n    //  {1200, 1200}, \n    //  {1999, 1800},\n    //  {2000, 2000},\n    };\n    for(item_id=0; item_id<item_count; ++item_id)\n    {\n        cout << \"--For loop id is: \" << item_id << endl; \n        if(item_matrix[item_id][weight]<remain_weight)\n        {\n            cout << \"----item_weight: \" << item_matrix[item_id][weight] << \" : is less than remain_weight : \" << remain_weight << endl;\n            remain_weight_next=algo(cost_low,cost_high,remain_weight,item_id,item_matrix); \n            cost_branch = branch(remain_weight_next);\n            cost_present=cost_low + cost_branch;  \n            if(cost_present>cost_high)\n                cost_present=cost_high;\n            cout << \"--**remain_weight: \" << remain_weight << endl;\n            cout << \"--**cost_low: \" << cost_low << endl;\n            cout << \"--**cost_high: \" << cost_high << endl;\n            cout << \"--**cost_branch: \" << cost_branch << endl;\n        }\n        else\n        {\n            cout << \"----item_weight: \" << item_matrix[item_id][weight] << \" : is greater than remain_weight : \" << remain_weight << endl;\n            if(cost_present>item_matrix[item_id][cost])\n                cost_present=item_matrix[item_id][cost];\n        }\n        cout << \"--**cost_present: \" << cost_present << endl;\n    }\n    cout << \"Leaving at Depth: \" << depth_level << endl;\n    depth_level--;\n    return cost_present;\n}\n```\n\n    ", "Answer": "\r\n```\nint &cost_low, int &cost_high```\n is a tip-off. If a function is called repeatedly, and on each iteration modifies the same objects, then that function and those objects should probably be members of the same class. \n\nIf you look further, you see that ```\nalgo```\n also works on ```\ncost_matrix[]```\n and ```\nweight_matrix[]```\n (No, it's not a 2D array). These could also become members.\n\n```\nbranch```\n is a bit complex because you 're mixing up things. It's recursive, but you also initialize ```\nitem_matrix```\n in each and every recursion. No problem once you've moved ```\nitem_matrix```\n into a class; the ctor will then initialize it. But do allocate that class outside ```\nbranch()```\n for the same recursive reasons.\n\nFinally, be a bit more compact. Don't define objects early; define them when you have a value. Dare to write ```\ncout << \"Entering at depth: \" << ++depth_level;```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack C# implementation task\r\n                \r\nI'm trying to write knapsack c# algorithm with given conditions but there's always two problems i encountering. I'm getting \"Index was outside the bounds of the array\" error or my result is just 0.\n\nI found couple code examples of Knapsack implementation and just can't figure out what I'm doing wrong.\n\nCode examples:\nhttps://www.programmingalgorithms.com/algorithm/knapsack-problem\n\nhttp://www.csharpstar.com/csharp-knapsack-problem/\n\nMy code:\n\n```\nstatic int Knapsack(int n, int w, int[] s, int[] v)\n{\n    int[,] G = new int[n+1,w+1];\n    for (int k = 0; k <= n; k++)\n    {\n        for (int r = 0; r < w; r++)\n        {\n            if (r == 0 || k == 0)\n                G[k, r] = 0;\n            else if (s[k] <= r)\n                G[k, r] = Math.Max(G[k- 1, r], v[k] + G[k - 1, r - s[k]]);\n            else\n                G[k, r] = G[k - 1, r]; \n        }\n    }\n    return G[n, w];\n}\nstatic void Main(string[] args)\n{\n    int[] s = { 60, 100, 120};\n    int[] v = { 10, 20, 30 };\n    int w = 50;\n    int n = s.Length;\n    Console.WriteLine(Knapsack(n, w, s, v));\n}\n```\n\n\nIn this case my result is 0.\n    ", "Answer": "\r\nThe issue with your code is that ```\ns```\n is the weights and ```\nv```\n is the values and your weights of 60, 100, and 120 will obvious not fit into a capacity of 50, that's why you get a result of 0.  The example you pull those values from set's the 60, 100, and 120 as the values and 10, 20, and 30 as the weights which is why it gets a result of 220.\n\nI think this works better if you create a class to handle the related weight and value for the items.\n\n```\npublic class Item\n{\n    public int Weight { get; set; }\n    public int Value { get; set; }\n}\n```\n\n\nThen the method only needs an array of items and the desired capacity. Also using meaningful names can make understanding what's going on easier than a bunch of single letter names.\n\n```\npublic static int KnapSack(Item[] items, int capacity)\n{\n    int[,] matrix = new int[items.Length + 1, capacity + 1];\n    for (int itemIndex = 0; itemIndex <= items.Length; itemIndex++)\n    {\n        // This adjusts the itemIndex to be 1 based instead of 0 based\n        // and in this case 0 is the initial state before an item is\n        // considered for the knapsack.\n        var currentItem = itemIndex == 0 ? null : items[itemIndex - 1];\n        for (int currentCapacity = 0; currentCapacity <= capacity; currentCapacity++)\n        {\n            // Set the first row and column of the matrix to all zeros\n            // This is the state before any items are added and when the\n            // potential capacity is zero the value would also be zero.\n            if (currentItem == null || currentCapacity == 0)\n            {\n                matrix[itemIndex, currentCapacity] = 0;\n            }\n            // If the current items weight is less than the current capacity\n            // then we should see if adding this item to the knapsack \n            // results in a greater value than what was determined for\n            // the previous item at this potential capacity.\n            else if (currentItem.Weight <= currentCapacity)\n            {\n                matrix[itemIndex, currentCapacity] = Math.Max(\n                    currentItem.Value \n                        + matrix[itemIndex - 1, currentCapacity - currentItem.Weight],\n                    matrix[itemIndex - 1, currentCapacity]);\n            }\n            // current item will not fit so just set the value to the \n            // what it was after handling the previous item.\n            else\n            {\n                matrix[itemIndex, currentCapacity] = \n                    matrix[itemIndex - 1, currentCapacity];\n            }\n        }\n    }\n\n    // The solution should be the value determined after considering all\n    // items at all the intermediate potential capacities.\n    return matrix[items.Length, capacity];\n}\n```\n\n\nThen running this code\n\n```\nvar items = new[]\n{\n    new Item {Value = 60, Weight = 10},\n    new Item {Value = 100, Weight = 20},\n    new Item {Value = 120, Weight = 30},\n};\n\nConsole.WriteLine(KnapSack(items, 50));\n```\n\n\nresults in 220.\n\nHere's a solution that uses recursion.\n\n```\npublic static int KnapSackRecursive(Item[] items, int capacity)\n{\n    // If there are no items or capacity is 0 then return 0\n    if (items.Length == 0 || capacity == 0) return 0;\n\n    // If there is one item and it fits then return it's value\n    // otherwise return 0\n    if (items.Length == 1)\n    {\n        return items[0].Weight < capacity ? items[0].Value : 0;\n    }\n\n    // keep track of the best value seen.\n    int best = 0;\n    for (int i = 0; i < items.Length; i++)\n    {\n        // This is an array of the other items.\n        var otherItems = items.Take(i).Concat(items.Skip(i + 1)).ToArray();\n\n        // Calculate the best value without using the current item.\n        int without = KnapSackRecursive(otherItems, capacity);\n        int with = 0;\n\n        // If the current item fits then calculate the best value for\n        // a capacity less it's weight and with it removed from contention\n        // and add the current items value to that.\n        if (items[i].Weight <= capacity)\n        {\n            with = KnapSackRecursive(otherItems, capacity - items[i].Weight) \n                + items[i].Value;\n        }\n\n        // The current best is the max of the with or without.\n        int currentBest = Math.Max(without, with);\n\n        // determine if the current best is the overall best.\n        if (currentBest > best)\n            best = currentBest;\n    }\n\n    return best;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is pseudopolynomial time? How does it differ from polynomial time?\r\n                \r\nWhat is pseudopolynomial time? How does it differ from polynomial time? Some algorithms that run in pseudopolynomial time have runtimes like O(nW) (for the 0/1 Knapsack Problem) or O(√n) (for trial division); why doesn't that count as polynomial time?\n    ", "Answer": "\r\nTo understand the difference between polynomial time and pseudopolynomial time, we need to start off by formalizing what \"polynomial time\" means.\nThe common intuition for polynomial time is \"time O(nk) for some k.\" For example, selection sort runs in time O(n2), which is polynomial time, while brute-force solving TSP takes time O(n · n!), which isn't polynomial time.\nThese runtimes all refer to some variable n that tracks the size of the input. For example, in selection sort, n refers to the number of elements in the array, while in TSP n refers to the number of nodes in the graph. In order to standardize the definition of what \"n\" actually means in this context, the formal definition of time complexity defines the \"size\" of a problem as follows:\n\nThe size of the input to a problem is the number of bits required to write out that input.\n\nFor example, if the input to a sorting algorithm is an array of 32-bit integers, then the size of the input would be 32n, where n is the number of entries in the array. In a graph with n nodes and m edges, the input might be specified as a list of all the nodes followed by a list of all the edges, which would require Ω(n + m) bits.\nGiven this definition, the formal definition of polynomial time is the following:\n\nAn algorithm runs in polynomial time if its runtime is O(xk) for some constant k, where x denotes the number of bits of input given to the algorithm.\n\nWhen working with algorithms that process graphs, lists, trees, etc., this definition more or less agrees with the conventional definition. For example, suppose you have a sorting algorithm that sorts arrays of 32-bit integers. If you use something like selection sort to do this, the runtime, as a function of the number of input elements in the array, will be O(n2). But how does n, the number of elements in the input array, correspond to the the number of bits of input? As mentioned earlier, the number of bits of input will be x = 32n. Therefore, if we express the runtime of the algorithm in terms of x rather than n, we get that the runtime is O(x2), and so the algorithm runs in polynomial time.\nSimilarly, suppose that you do depth-first search on a graph, which takes time O(m + n), where m is the number of edges in the graph and n is the number of nodes. How does this relate to the number of bits of input given? Well, if we assume that the input is specified as an adjacency list (a list of all the nodes and edges), then as mentioned earlier the number of input bits will be x = Ω(m + n). Therefore, the runtime will be O(x), so the algorithm runs in polynomial time.\nThings break down, however, when we start talking about algorithms that operate on numbers. Let's consider the problem of testing whether a number is prime or not. Given a number n, you can test if n is prime using the following algorithm:\n```\nfunction isPrime(n):\n    for i from 2 to n - 1:\n        if (n mod i) = 0, return false\n    return true\n```\n\nSo what's the time complexity of this code? Well, that inner loop runs O(n) times and each time does some amount of work to compute n mod i (as a really conservative upper bound, this can certainly be done in time O(n3)). Therefore, this overall algorithm runs in time O(n4) and possibly a lot faster.\nIn 2004, three computer scientists published a paper called PRIMES is in P giving a polynomial-time algorithm for testing whether a number is prime. It was considered a landmark result. So what's the big deal? Don't we already have a polynomial-time algorithm for this, namely the one above?\nUnfortunately, we don't. Remember, the formal definition of time complexity talks about the complexity of the algorithm as a function of the number of bits of input. Our algorithm runs in time O(n4), but what is that as a function of the number of input bits? Well, writing out the number n takes O(log n) bits. Therefore, if we let x be the number of bits required to write out the input n, the runtime of this algorithm is actually O(24x), which is not a polynomial in x.\nThis is the heart of the distinction between polynomial time and pseudopolynomial time. On the one hand, our algorithm is O(n4), which looks like a polynomial, but on the other hand, under the formal definition of polynomial time, it's not polynomial-time.\nTo get an intuition for why the algorithm isn't a polynomial-time algorithm, think about the following. Suppose I want the algorithm to have to do a lot of work. If I write out an input like this:\n\n10001010101011\n\nthen it will take some worst-case amount of time, say ```\nT```\n, to complete. If I now add a single bit to the end of the number, like this:\n\n100010101010111\n\nThe runtime will now (in the worst case) be 2T. I can double the amount of work the algorithm does just by adding one more bit!\nAn algorithm runs in pseudopolynomial time if the runtime is some polynomial in the numeric value of the input, rather than in the number of bits required to represent it. Our prime testing algorithm is a pseudopolynomial time algorithm, since it runs in time O(n4), but it's not a polynomial-time algorithm because as a function of the number of bits x required to write out the input, the runtime is O(24x). The reason that the \"PRIMES is in P\" paper was so significant was that its runtime was (roughly) O(log12 n), which as a function of the number of bits is O(x12).\nSo why does this matter? Well, we have many pseudopolynomial time algorithms for factoring integers. However, these algorithms are, technically speaking, exponential-time algorithms. This is very useful for cryptography: if you want to use RSA encryption, you need to be able to trust that we can't factor numbers easily. By increasing the number of bits in the numbers to a huge value (say, 1024 bits), you can make the amount of time that the pseudopolynomial-time factoring algorithm must take get so large that it would be completely and utterly infeasible to factor the numbers. If, on the other hand, we can find a polynomial-time factoring algorithm, this isn't necessarily the case. Adding in more bits may cause the work to grow by a lot, but the growth will only be polynomial growth, not exponential growth.\nThat said, in many cases pseudopolynomial time algorithms are perfectly fine because the size of the numbers won't be too large. For example, counting sort has runtime O(n + U), where U is the largest number in the array. This is pseudopolynomial time (because the numeric value of U requires O(log U) bits to write out, so the runtime is exponential in the input size). If we artificially constrain U so that U isn't too large (say, if we let U be 2), then the runtime is O(n), which actually is polynomial time. This is how radix sort works: by processing the numbers one bit at a time, the runtime of each round is O(n), so the overall runtime is O(n log U). This actually is polynomial time, because writing out n numbers to sort uses Ω(n) bits and the value of log U is directly proportional to the number of bits required to write out the maximum value in the array.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to use memorization in recursion to solve 0-1 Knapsack problem without Runtime Error for larger inputs in c ++?\r\n                \r\nIam doing this 0-1 knapsack problem in GFG practice portal. For small inputs the code is running fine! .For bigger inputs I am getting an \"Time Limit Exceeded\" error. I am new to DP concept can someone explain what is my mistake  .I have used (recursion +memorization).\nLink to the problem:https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1#\nHere is the code :\n```\nint a[10005][10005]; // I have declared this globally.\n\nint knapSack(int W, int wt[], int val[], int n) \n{ \n     memset(a,-1,sizeof(a));\n\n     if (n == 0 || W == 0)\n     {\n     return 0;\n     }\n\n     if(a[n][W]!=-1)\n     {\n     return a[n][W];\n     }\n\n     if (wt[n - 1] > W)\n     {\n     a[n][W]=knapSack(W, wt, val, n - 1);  \n     return a[n][W];\n    }\n\n    if(wt[n - 1] <= W)\n    {\n    a[n][W]= max(val[n - 1]+ knapSack(W - wt[n - 1],wt, val, n - 1),knapSack(W, wt, val, n - 1));\n    return a[n][W];\n    }\n}\n```\n\nFor smaller Input's:\nFor Input:\n3   // n=no.of inputs\n4    //W capacity of the bag\n1 2 3   //val[ ]\n4 5 1    //wt[ ]\nyour output is:\n3\nFor larger Input's:\n\"Time Limit Exceeded\"\n    ", "Answer": "\r\n```\nmemset(a,-1,sizeof(a));```\n\n```\nmemset```\n takes an argument in bytes, so you cleared 1/4 of the array (depends on your int size).  Fortunately the value -1 becomes the byte 0xff which, when placed in each of the bytes of the ```\nint```\n, represent -1 again.  The value -1 is special in that regard, along with 0.  Generally, it's better to use ```\nstd::fill```\n.  (although that's complicated by the use of a two-dimensional array)\nOK, you have recursive calls like:\n```\na[n][W]=knapSack(W, wt, val, n - 1);```\n\nand presumably you keep needing the same ones that you already calculated.\nYou need to keep a database of all the ones you already computed.  A simple way to do that is to make a ```\nstd::map```\n and the key is a structure containing the four values, and the result as the value.  Wrap your real function (renamed) with a new function that first checks the database, and if not already present, calls the real function, stores the result in the database, and then returns.\n\nAh, you seem to already be implementing memoization via your global arrays... As Bob pointed out in a comment, the ```\nmemset```\n is inside the recursive function, so each call wipes out the saved values.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Resource distribution w.r.t. individual capacity - is it a Knapsack problem?\r\n                \r\nI have a problem as follows:\n\n\nI have few office locations and resources with different capabilities (integer numbers).\nI want to distribute all the resources to different office locations to find the best way to divide them almost equally among the locations so that the capabilities of all the office locations are balanced as much as possible. Couple of things to keep in mind:\n\n\n• Difference between number of resources in each office location should not be more than one.\n• The capability of each office location (reached by adding individual capability) should be nearly equal as possible to each other.\n\nI have researched over the internet and came to know about Knapsack algorithm and Bin-pack algorithm which sounds close to this problem.\n\nExample:\nNumber of office locations = 3;\nNumber of people = 8;\nPeople capability = 10, 20, 5, 150, 90, 200, 250, 140 (capabilities values of the 8 resources);\n\nThe above numbers are just sample. It can grow to 1000+ for resources and respective capabilities value. Number of office locations can be varied too.\n\nI didn't start the programming part unless I am sure that the path that I am going to take it correct. I am requesting your help to guide me to a correct direction to solve this.\n\nAlso, if you can share a probable pseudo code for this, will be a great help.\n\nThanks!\n    ", "Answer": "\r\nThis is the knapsack problem or is at least as difficult (consider an instance where there are only two offices), so obtaining the best solution will be very difficult. You may try to use some generic optimization heuristic like simulated annealing: http://en.wikipedia.org/wiki/Simulated_annealing\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "recursive Bounded knapsack algorithm\r\n                \r\nI am struggling with translating the dynamic programming recursive knapsack problem 0-1 to a dynamic bounded recursive knapsack.\nThe formula i am currently using in R is:\n\n```\nF(i,k)=max(v[i]+F(i-1, k-w[i]), F(i-1, k))\n```\n\n\nso now I am wondering what this function would become for a bounded dynamic knapsack problem\n\nthank you \n    ", "Answer": "\r\nThe simplest modification - make needed quantity of repeated elements \n\n```\n {3x1,2x5}=>{1,1,1,5,5}\n```\n\n\nAnother approach - create array/vector with numbers of copies and use it in recursive calls to check only entries with non-zero copy counts\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Implement 0/1 knapsack problem in python using backtracking\r\n                \r\nI would like to display the maximum value possible given a Maxweigth and the indexes of items selected.\nI would also like to count the number of recursive calls happening during the execution.\n\nrandom weight and value lists are generated using the generate function.\nvsol[] has the final list of item indexes selected\ntemp[] holds the temporarily selected indexes\nvalues[] will hold the array of values of items\nweights[] will hold the array of weights of items\nsolution after the Knapsack() will hold the max value it can have from the given weight(second argument of Knapsack())\n\ninput: values[] = [60,100,120], weights[10,20,30], maxWeigth = 50\nExpected Output: 220 [1,2]\noutput sited: 0 [] for every input selected item indexes\n\n```\nimport random\nimport copy\n\nweights = []\nvalues = []\ntemp = []\nvsol = []\nisSol = False\nsolution = 0\ndef Knapsack(i,max,value):\n    for k in range(i,len(values)):\n        if max > 0:\n            if weights[k] <= max:\n                temp.append(k);\n                if (value+values[k] >= solution):\n                    solution = value+values[k];\n                    isSol = True\n            if (k+1)<n:\n                Knapsack(k+1,max-weight[k],value+values[k])\n            else:\n                if isSol == True:\n                    vsol = []\n                    vsol = copy.deepcopy(temp)\n                    temp = []\n                    isSol = False\n                else:\n                    temp = []\n                    return\n        else:\n            if isSol == True:\n                vsol = []\n                vsol = copy.deepcopy(temp)\n                temp = []\n                isSol = False\n            else:\n                temp = []\n                return\n    \n    \n\ndef generator(n):\n    l = [];\n    for i in range(n):\n        l.append(random.randint(1,100))\n    return l    \ndef main():\n    n = 10 #number of random numbers\n    weights = generator(n);\n    values = generator(n);\n    Knapsack(0,10,0)\n    print(solution,vsol)\n    \nmain()\n```\n\nI tried deep copying the temp list to vsol[].\n    ", "Answer": "\r\n```\nimport sys\nimport math\nsys.setrecursionlimit(10**8)\n\nc = 0\ndef knapSack(mW,w,v,n):\n    # counter how many time recursive function is called.\n    global c\n    c += 1\n    \n    if(mW == 0 or n == 0):\n        return [0,[]]\n        \n    if(w[n-1] > mW):\n        return knapSack(mW,w,v,n-1)\n        \n    set1 = knapSack(mW-w[n-1],w,v,n-1)\n    set2 = knapSack(mW,w,v,n-1)\n    \n    if(set1[0]+v[n-1] > set2[0]):\n        set1[1].append(n-1)\n        set1[0] += v[n-1]\n        return set1\n    else:\n        return set2\n        \nval = [160, 100, 120]\nwt = [10, 20, 30]\nW = 50\nn = len(val)\nprint(\"Knapsack Max & list:\",knapSack(W, wt, val, n))\nprint(\"Total Recursive Steps: \",c)\n    \n```\n\nPython tutor : use this simulator in future to learn what is happening.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Genetic Algorithm on modified knapsack problem\r\n                \r\nLet’s say, you are going to spend a month in the wilderness. The only thing you are carrying is a\nbackpack that can hold a maximum weight of 40 kg. Now you have different survival items, each\nhaving its own “Survival Points” (which are given for each item in the table). Some of the items are so\nessential that if you do not take them, you incur some additional penalty.\nHere is the table giving details about each item.\nItem Weight Survival Value Penalty if not taken:\nSleeping Bag 30 20 0,\nRope 10 10 0,\nBottle 5 20 0,\nTorch+Battery 15 25 -20,\nGlucose 5 30 0,\nPocket Knife 10 15 -10,\nUmbrella 20 10 0\n.Formulate this as a genetic algorithm problem where your objective is to maximize the survival points.\nWrite how you would represent the chromosomes, fitness function, crossover, mutation, etc.\nI am not sure about what would be the fitness function. A simple fitness function that I thought of is just simply adding the survival points of the weights that we want to take and subtracting the penalties of the weights that we don't want to take. But by doing this the overall value of the fitness function for a particular gene can be negative as well.\nPlease tell me how should I proceed further and what should be an appropriate fitness function in this case.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to solve the knapsack Problem when more than two properties of the Item are given (3 variables)\r\n                \r\nIn the knapsack Problem how to solve it if one more property other than that of weight and value of the Item is given? Like recently I was asked a question where I was given 3 properties of the same items, Weight, Value and Type:\n```\nint weights[5] = {1, 3, 5, 9, 10};\nint values[5] = {11, 13, 1, 19, 9};\nint types[5] = {1,2,1,3,4};\nint capacity = 26;\n```\n\nWe can choose items of each type only once, e.g. we can have only one item of type = 1 in our final knapsack, so we either choose the item with weight 1 or the item with weight 5 both cannot be present. We have to maximize the profit we get.\nI was thinking along the lines of a 3D matrix, but I'm not able to think of the proper solution, if I couldn't even think of the base case in this situation for the types, how would the recursive solution look like in this case?\nHere is what I tried, I choose each element, the type of the element is put in a set, then we recurse. If the next item type is already present in the set, then we remove it and then recalculate the max value for that particular type among all of them, but if the item type is not present in the set, then we have not considered it, and we add it to the set and proceed further.\nI also have a lingering doubt about the base case. Since we can have a different item of the same type which gives a more profit, in my base case, if the value for that particular item type is already considered, then it will return the same output without maximizing it for the second item of the same type. But then I countered myself that the ```\nn```\n and ```\nw```\n values are different for the same type so it will in fact maximize this too. Is this correct?\nRelated Questions that I found but weren't answered or Did not have a Pseudo code on which I could build upon:\n\nSolving the knapsack problem with special constraint\nHow can I solve knapsack problems with 3 variables?\n\nAfter reading the second link, I'm also curious on how we could apply the constraint of the Volume, how would the code actually look like with the base cases?\nI was also suggested to use a map of ```\n(string, int)```\n values to store the unique values from the recursion, which method would be better? to use a map or to use 3D table?\nHere is my code:\n```\nset<int> ttypes;\nint static t2[6][26][5];\nint knapSack_Memo_Modified(int weights[], int values[], int types[], int w, int n){\n    if(w <= 0 || n <= 0){\n        return 0;\n    }\n    if(t2[n][w][types[n-1]] != -1){\n        return t2[n][w][types[n-1]];\n    }\n\n    if(ttypes.count(types[n-1])){\n        ttypes.erase(types[n-1]);\n        return t2[n][w][types[n-1]] = max(t2[n][w][types[n-1]], knapSack_Memo_Modified(weights, values, types, w, n-1));\n    }\n    else{\n        ttypes.insert(types[n-1]);\n        if(weights[n-1] <= w){\n            return t2[n][w][types[n-1]] = max((values[n-1]+knapSack_Memo_Modified(weights, values, types, w-weights[n-1], n-1)), (knapSack_Memo_Modified(weights, values, types, w, n-1)));\n        }\n        else if(weights[n-1] > w){\n            return t2[n][w][types[n-1]] = knapSack_Memo_Modified(weights, values, types, w, n-1);\n        }\n    }\n}\n\nint main(){\n    int weights[5] = {1, 3, 5, 9, 10};\n    int values[5] = {11, 13, 1, 19, 9};\n    int types[5] = {1,2,1,3,4};\n    int capacity = 25;\n\n    memset(t, -1, sizeof(t));\n    int ans = knapSack_Memo_Modified(weights, values, types, capacity, 5);\n\n    int mx = 0;\n    for(int i = 0; i < 6; i++){\n        for(int j = 0; j < 26; j++){\n            for(int k = 0; k < 5; k++){\n                mx = max(mx, t2[i][j][k]);\n            }\n        }\n    }\n    cout << mx << endl;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "how can I run a formula on multidimensional knapsack problem\r\n                \r\nI solve the knapsack algorithm in Python, for instance:\n```\nweights = [3, 5, 1, 1, 1, 5, 3, 3, 3, 5]\nprofits = [0, 2, 10, 5, 7, 7, 3, 6, 10, 9]\n\nknapsacks_capacity = [15, 14, 13]\n```\n\nfor this sample I got this result:\n```\n# knapsack capacity: [[weights],[profits]]\n\"knapsack 15: [[5, 1, 1, 1, 5], [2, 10, 5, 7, 7]]\"\n\"knapsack 14: [[3, 3, 3, 5], [3, 6, 10, 9]]\"\n\"knapsack 13: [[], []]\"\n```\n\nevery thing is OK :) but I want to calculate this formula for the items:\n\nHow can I do this?\nHas any library for this?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Algorithm for heavily restricted Knapsack problem\r\n                \r\nI have a following problem to solve:\n\nWe have 53 weeks in a year, for each week we need to choose one model from the list: [A1, A2,....,F149, F150]. In total around 750 models in 6 classes: A,B,C,D,E,F.\nModels can repeat and each has a specific value from around 3 to 10 and a weight. The goal is to achieve a target total value of 280+-5% with a minimal weight by the end of the year.\nHowever there are a ton of restrictions. For example:\n\n\nModels must be held for at least 4 weeks in a row. If we have chosen A1 for week 1, then we need to choose A1 for weeks 2,3,4;\nIf we have chosen model classes E,F then, after they end, we cannot choose E, F for another 4 weeks.\nThroughout the year we can only choose 23 models of class D.\nan so on\n\nWhat I've tried so far:\n\nBased on a target value create a corridor of allowed values throughout the year:\nCorridor looks like this\n\nStarting at week 1, choose a random model for the week from the list of allowed models -> Based on the choice modify the list of allowed models for next weeks\n\nIf our choice satisfies the criterion (also lies within a corridor), then week+=1. If not, delete this possibility.\n\nIf there is no more models for this week, go back one week, delete the possibility we have chosen before and choose random from what's left.\n\n\nPictorially the algorithm is like following the branches of a tree. If the branch is bad, return back to the fork and cut off the bad branch.\nThis algorithm can generate a random valid solution (in about 5 to 80 minutes with a mean time of 25 minutes). Then I need to generate more of those and choose one that has the least weight. Which is not a very good approach, I presume.\nQuestion\nThe question is: what is the optimal way to solve the problem? The priority is to find the solution with a minimal weight and a target value and not the fastest algorithm. But it should at least end in a final amount of time =)\nThe problem statement above is a bit oversimplified and due to the complexity of calculations and the amount of combinations, there is no way to consider and compare all combinations.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Maximum recursion depth exceeded in the knapsack problem despite increasing recursion limit\r\n                \r\nFor an online course I'm trying to solve the knapsack problem: given ```\nn```\n items and arrays ```\nv```\n and ```\nw```\n of their values and weights, respectively, find the combination of items with the maximum value subject to the constraint that the total weight is less than a given threshold ```\nW```\n.\n\nI define the solution to the sub-problem ```\nA(i, x, v, w)```\n with ```\ni```\n items and a total weight constraint ```\nx```\n; the problem is thus to compute ```\nA(n, W, v, w)```\n. I've tried the following:\n\n```\nimport sys\nsys.setrecursionlimit(3000)\n\ndef memoize(f):\n    memo = {}\n    def helper(i, x, *args, **kwargs):\n        if (i, x) not in memo:            \n            memo[(i, x)] = f(i, x, *args, **kwargs)\n        return memo[(i, x)]\n    return helper\n\n@memoize\ndef A(i, x, v, w):\n    if i == 0:\n        return 0\n    if x >= w[i-1]:\n        return max(A(i-1, x, v, w), A(i-1, x-w[i-1], v, w) + v[i-1])\n    else:\n        return A(i-1, x, v, w)\n```\n\n\nIf I run this on a simple test case, it works:\n\n```\nimport pytest\n\n@pytest.fixture\ndef data_simple():\n    W = 6\n    n = 4\n    v = [3, 2, 4, 4]\n    w = [4, 3, 2, 3]\n    return W, n, v, w\n\ndef test_A(data_simple):\n    W, n, v, w = data_simple\n    assert A(n, W, v, w) == 8\n\nif __name__ == \"__main__\":\n    pytest.main([__file__, \"-s\"])\n```\n\n\nwhere in this case the maximum value is attained by taking the last two items, each with value 4.\n\nFor the actual problem, however, we need to use a bigger set of input data obtained from knapsack_big.txt, where ```\nW```\n = 2,000,000 and ```\nn```\n = 2,000.\n\nI've tried to run this as follows:\n\n```\ndef readfile(file):\n    with open(file) as f:\n        first_line = f.readline().strip()\n        W, n = tuple(map(int, first_line.split()))\n        data = [tuple(map(int, line.split())) for line in f.read().splitlines()]\n        v, w = zip(*data)\n        assert len(v) == n\n        return W, n, v, w\n\n@pytest.fixture\ndef data_big():\n    return readfile('knapsack_big.txt')\n\ndef test_big(data_big):\n    W, n, v, w = data_big\n    optimal_value = A(n, W, v, w)\n```\n\n\nHowever, when I try to run this I get a ```\nRecursionError```\n:\n\n```\n    def helper(i, x, *args, **kwargs):\n        if (i, x) not in memo:\n>           memo[(i, x)] = f(i, x, *args, **kwargs)\nE           RecursionError: maximum recursion depth exceeded\n```\n\n\nI don't understand this: if every time the function ```\nA```\n is called, it is with a decreased value of ```\ni```\n, and the maximum value of ```\ni```\n is ```\n2000```\n, then shouldn't a recursion depth of 3000 (as set in the beginning) be sufficient?\n\n(What I suspect might be the case is that the ```\nmemoize```\n function wrapper is getting called every time ```\nA```\n is invoked, so it is creating an empty ```\nmemo```\n dictionary every time instead of filling the dictionary. I based it on an example from http://www.python-course.eu/python3_memoization.php, but perhaps I should instead try some of the implementations at https://wiki.python.org/moin/PythonDecoratorLibrary#Memoize?)\n    ", "Answer": "\r\nIt falls with ```\nMaximum recursion depth exceeded```\n because every time you call the function ```\nA```\n ```\nhelper```\n function is also called, so actually you have two recursive calls for every decrementation of the ```\ni```\n. I tried to remove call to ```\nhelper```\n by implementing memoization inside the function ```\nA```\n and it worked:\n\n```\nmemo = {}\ndef A2(i, x, v, w):\n    global memo\n    if i == 0:\n        return 0\n    if (i, x) not in memo:\n        if x >= w[i - 1]:\n            memo[(i, x)] = max(A2(i - 1, x, v, w),\n                               A2(i - 1, x - w[i - 1], v, w) + v[i - 1])\n        else:\n            memo[(i, x)] = A2(i - 1, x, v, w)\n    return memo[(i, x)]\n```\n\n\nOutput:\n\n\n  4243395\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "A simplified 0/1 Knapsack problem with multiple items allowed in Python\r\n                \r\nI have a problem which is a simplified version of the knapsack problem. It goes like this. There is a store and we have a list of items in that store. Let's say like this,\nStore has 2 types of products Normal products and limited products.\nProduct Class\n```\nclass Product:\n    \"\"\" \n    A class to provide abstraction for products availabel in the system.\n    unless the product is a Limited_product its supply is infinite\n    \"\"\"\n    product_counter = 0\n\n    ##### Part 1.1 #####\n    def __init__(self, name, price):\n        \"\"\" Constructor for initialization \"\"\"\n        \n        self.name = name\n        self.price = price\n        self.id = Product.product_counter\n        Product.product_counter += 1\n\n    def __str__(self):\n        \"\"\" returns a string representation of a product \"\"\"\n        return \"<{}> {} - {}$\".format(self.id, self.name, self.price)\n\n    def __repr__(self):\n        \"\"\" represents the class object as a string \"\"\"\n        return \"PRODUCT <{}>\".format(self.id)\n```\n\nLimited Product Class\n```\nclass Limited_Product(Product):\n    \"\"\"\n    A child class of the parent Product class\n    Represents a Limited product where the quantity is depreceating\n    \"\"\"\n\n    ##### Part 1.2 #####\n    def __init__(self, name, price, amount):\n        \"\"\" Constructor for initialization \"\"\"\n        super().__init__(name, price)\n        self.amount = amount\n\n    def __str__(self):\n        \"\"\" returns a string representation of a limited product \"\"\"\n        return \"<{}> {} - {}$ ({} left)\".format(self.id, self.name, self.price, self.amount)\n\n    def decrement_amount(self):\n        \"\"\" decrement the amount of available product \"\"\"\n        self.amount -= 1\n\n    def get_amount(self):\n        \"\"\" returns the amount available from the product \"\"\"\n        return self.amount\n```\n\nNow we are given a list of products and the maximum amount a customer can spend.\n============================\nProduct - Price\nA - 20$\nB - 7$\nC - 1$ (2 left)\n============================\nAnd we have to find out what is the minimum amount left after the customer buys a sequence from these items using both recursion as well as iteratively by completing the given two functions. These functions are given so I cannot write in a different method.\nAs an example:\n```\n>>> store.so_rich(45)\n\noutput - 1\n```\n\nYou have 45 dollars to spend. The optimal solution is buying six B items and two C items. This will leave you with 45 - 7 * 6 - 1 * 2 = 1 dollars left. The least amount of money left is 1 since there is no way to spend all of the money. (although C’s price is 1$, you have purchased all of them already!)\n```\n>>> store.so_rich(61)\n\n0\n```\n\nYou have 61 dollars to spend. You can spend all of them by buying two A and three B (20 * 2 + 7 * 3 = 61). So the least amount of money left is 0.\nThe two functions that I wrote\n```\n    def so_rich(self, money):\n\n        # suppose you haven't seen any product yet\n        # the only possible amount of money left is \"money\"\n        # this is a set to record the possible money left\n        left = set([money])\n\n        # get products\n        lst = list(self.warehouse.inventory.values())\n        print(str(lst))\n        for product in lst:\n\n            # a temporary set to save the updates of \"left\"\n            # you don't want to modify the set you're iterating through\n            tmp_left = set()\n\n            for m in left:\n                # update tmp_left\n                if type(product) != Limited_Product:\n                    new_left = m\n                    #new_left -= product.price\n                    while product.price <= new_left:\n                        print(new_left, product.name)\n                        tmp_left.add(new_left)\n                        new_left = new_left - product.price\n                else:\n                    # handle limited product\n                    new_left = m\n                    product_count = product.amount\n                    while product.price <= new_left and product_count > 0:\n                        print(new_left, product.name)\n                        tmp_left.add(new_left)\n                        new_left = new_left - product.price\n                        product_count -= 1\n            left = tmp_left\n            print(left)\n\n        return min(left)\n\n    def so_rich_recursive(self, money):\n\n        # get products\n        lst = list(self.warehouse.inventory.values())\n        \n        def helper(lst, money):\n            \n            # base case\n            if not lst:\n                return money\n            \n            cur_min = money\n            product = lst[0]\n            if type(product) != Limited_Product:\n                tmp = money\n                while product.price < tmp:\n                    cur_min = tmp\n                    tmp -= product.price\n                    print(cur_min, product.name)\n            else:\n                tmp = money\n                product_count = product.amount\n                while product.price <= tmp and product_count > 0:\n                    cur_min = tmp\n                    tmp -= product.price\n                    product_count -= 1\n                    print(cur_min, product.name)\n            money = money - cur_min\n            print(\"-----\", money)\n            lst.pop(0)\n            return helper(lst, money)\n        \n        return helper(lst, money)\n```\n\nI cannot understand why the above code written by me does not work. Can anyone help me, please?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Constrained Knapsack without weight\r\n                \r\nI just came across the following problem(it reminds me of the knapsack-problem, but there a some differences):\n\nYou are given a number n of items which you have to put inside your knapsack with a maximum profit. Each item has a specific profit value and a specific shape. Because of their shape, some items cannot be put into the knapsack together. Unlike the normal knapsack-problem there is no maximum weight that limits the number of items in the knapsack.\nYou are also given a list for each item. In that list you can see the items that can be put into the knapsack with the corresponding item.\n\nIs there an algorithm that calculates the optimum solution?\nOr is it an NP-complete problem? In that case, is there a method of approximation?\n    ", "Answer": "\r\nI think that this is NPC.\n\nThe polynomial verification requirement is trivial.\n\nThe reduction is to the Maximal Independent Set problem. For each MIS instance G = (V, E), construct a set of items V with unit profit each. For each item v &in; V, the list of items with which it can be placed is the set of vertices to which it doesn't share an edge. I.e., if G(v) is the list of items that can go with v, then G(v) = {w | (u, w) ∉ E}.\n\nIf there is a solution with profit k for the new problem, then it uses k items that are not in each other's lists. It follows that there is a solution of size k to the independent set problem.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to add constraints to Linear Programming of the Knapsack Problem in R?\r\n                \r\nI was working through the code found at: https://sites.math.washington.edu/~conroy/2015/m381-aut2015/Rexamples/knapsack.r\n\nI was wondering if anyone knows how to add a conditional constraint that only allows for a certain number of items in the knapsack. How would I modify the code to still optimize the value of the knapsack but only take a certain number of items?\n\n```\n# import the lpsolve library\nlibrary(lpSolve)\n\n# objective function\nknapsack.obj <- c(500,300,100,210,360,180,220,140,90)\n\n#constraints\nknapsack.con <- matrix(c(30,35,10,15,35,22,29,18,11),nrow=1,byrow=TRUE)\nknapsack.dir <- c(\"<=\")\nknapsack.rhs <- c(100)\n\n#solve\n# Note when we call the lp function, we set all.bin=TRUE to indicate that all variables are 0 or 1\n# If we just wanted to specify integer values generally, we would set all.int=TRUE\n# The default for both of these options if FALSE\nknapsackSolution <- lp(\"max\",knapsack.obj,knapsack.con,knapsack.dir,knapsack.rhs,all.bin=TRUE) \nprint(\"Solution is:\")\nprint(knapsackSolution$solution)\nprint(\"Objective function value at solution is:\")\nprint(knapsackSolution$objval)\n```\n\n    ", "Answer": "\r\nYou can add it to the constraints as follows:\n\n```\nnumItems <- 5\nknapsack.con <- matrix(c(30,35,10,15,35,22,29,18,11, rep(1, length(knapsack.obj))), nrow=2, byrow=TRUE)\nknapsack.dir <- c(\"<=\", \"==\")\nknapsack.rhs <- c(100, numItems)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack variant in JavaScript\r\n                \r\nI have tried to implement this knapsack problem solution algorithm in JavaScript, but the solutions s_opt I get has a total weight greater than the L_max.\n\nWhat am I doing wrong?\n\nI suspect it could be something related to Closures in recursion.\n\n```\n/*\nGENERAL:\n   Assume we have a knapsack and we want to bring as much stuff as possible.\n   Of each thing we have several variants to choose from. Each of these variants have\n   different value and takes different amount of space.\n\nDEFINITIONS:\n    L_max = integer, size of the knapsack for the entire problem having N items\n    l = matrix, having the elements l[i-1][j-1] representing the space taken\n            by variant j of item i (-1 since indexing the matrices has index starting on zero, i.e. item i is stored at position i-1)\n    p = matrix, having the elements p[i-1][j-1] representing the value given by\n            by variant j of item i\n    n = total number of items (used in a sub-problem)\n    N = total number of items (used in the full problem, N >= n)\n    s_opt = vector having the optimal combination of variant selections s_i, i.e. s_opt = arg max p_sum\n\n*/\nfunction knapsack(L_max,l,p) {\n\n    // constructing (initializing) - they are private members\n    var self = this; // in order for private functions to be able read variables\n    this.N = l.length;\n    var DCached = []; // this is only used by a private function so it doesnt need to made public using this.*\n    this.s_opt = [];\n    this.p_mean = null;\n    this.L_max = L_max;\n\n    // define public optimization function for the entire problem\n    // when this is completed the user can read\n    // s_opt to get the solution and\n    // p_mean to know the quality of the solution\n    this.optimize = function() {\n        self.p_mean = D(self.N,self.L_max) / Math.max(1,self.N);\n    }\n\n    // define private sub-problem optimization function\n    var D = function(n,r) {\n        if (r<0)\n         return -Infinity;\n        if (n==0)\n         return 0;\n        if(DCached[n-1] != null) {\n         if(DCached[n-1][r-1] != null) {\n            return DCached[n-1][r-1];\n         }\n        }\n        var p_max = -Infinity;\n        var p_sum;\n        var J = l[n-1].length;\n        for(var j = 0; j < J; j++) {\n         p_sum = p[n-1][j] + D( n-1 , r - l[n-1][j] );\n         if(p_sum>p_max) {\n             p_max = p_sum;\n             self.s_opt[n-1] = j;\n         }\n        }\n        DCached[n-1] = [];\n        DCached[n-1][r-1] = p_max;\n        return p_max;\n    }\n}\n```\n\n\nThe client using this knapsack solver does the following:\n\n```\nvar knapsackSolution = new knapsack(5,l,p);\nknapsackSolution.optimize();\n// now the client can access knapsackSolution.s_opt containing the solution.\n```\n\n    ", "Answer": "\r\nI found a solution. When solving a sub-problem ```\nD(n,r)```\n the code in the question returned the optimized value, but it didn't really manage the array ```\ns_opt```\n in a proper way. In the modified solution, pasted below, I fixed this. Instead of only returning the optimized value of the knapsack also an array of chosen variants (e.g. the arg of the max) are returned. The cache is also modified to manage these two parts of the solution (both max value and arg max value).\n\nThe code below also contains an additional feature addition. The user can now also pass a value ```\nmaxComputingComplexity```\n controlling the computational size of the problem in some kind of heuristic manner.\n\n```\n    /*\nGENERAL:\n    Assume we have a knapsack and we want to bring as much stuff as possible.\n    Of each thing we have several variants to choose from. Each of these variants have\n    different value and takes different amount of space.\n\n    The quantity of each variant is one.\n\nDEFINITIONS:\n    L_max = integer, size of the knapsack, e.g. max number of letters, for the entire problem having N items\n    l = matrix, having the elements l[i-1][j-1] representing the space taken\n            by variant j of item i (-1 since indexing the matrices has index starting on zero, i.e. item i is stored at position i-1)\n    p = matrix, having the elements p[i-1][j-1] representing the value given by\n            by variant j of item i\n    maxComputingComplexity = value limiting the product L_max*self.N*M_max in order to make the optimization\n            complete in limited amount of time. It has a serious implication, since it may cut the list of alternatives\n            so that only the first alternatives are used in the computation, meaning that the input should be well\n            ordered\n    n = total number of items (used in a sub-problem)\n    N = total number of items (used in the full problem, N >= n)\n    M_i = number of variants of item i\n    s_i = which variant is chosen to pack of item i\n    s = vector of elements s_i representing a possible solution\n    r = maximum total space in the knapsack, i.e. sum(l[i][s_i]) <= r\n    p_sum = sum of the values of the selected variants, i.e. sum(p[i][s_i]\n    s_opt = vector having the optimal combination of variant selections s_i, i.e. s_opt = arg max p_sum\n\n    In order to solve this, let us see p_sum as a function\n    D(n,r) = p_sum (just seeing it as a function of the sub-problem n combined with the maximum total space r)\nRESULT:\n*/\n\nfunction knapsack(L_max,l,p,maxComputingComplexity) {\n\n\n    // constructing (initializing) - they are private members\n    var self = this; // in order for private functions to be able read variables\n    this.N = l.length;\n    var DCached = []; // this is only used by a private function so it doesnt need to made public using this.*\n    //this.s_opt = [];\n    //this.p_mean = null;\n    this.L_max = L_max;\n    this.maxComputingComplexity = maxComputingComplexity;\n    //console.log(\"knapsack: Creating knapsack. N=\" + N + \". L_max=\" + L_max + \".\");\n\n    // object to store the solution (both big problem and sub-problems)\n    function result(p_max,s_opt) {\n        this.p_max = p_max; //max value\n        this.s_opt = s_opt; //arg max value\n    }\n\n    // define public optimization function for the entire problem\n    // when this is completed the user can read\n    // s_opt to get the solution and\n    // p_mean to know the quality of the solution\n    // computing complexity O(L_max*self.N*M_max),\n    // think O=L_max*N*M_max => M_max=O/L_max/N => 3=x/140/20 => x=3*140*20 => x=8400\n    this.optimize = function() {\n        var M_max = Math.max(maxComputingComplexity / (L_max*self.N),2); //totally useless if not at least two\n        console.log(\"optimize: Setting M_max =\" + M_max);\n        return D(self.N,self.L_max,M_max);\n        //self.p_mean = mainResult.D / Math.max(1,self.N);\n        // console.log...\n    }\n\n    // Define private sub-problem optimization function.\n    // The function reads to \"global\" variables, p and l\n    // and as arguments it takes\n    //      n delimiting the which sub-set of items to be able to include (from p and l)\n    //      r setting the max space that this sub-set of items may take\n    // Based on these arguments the function optimizes D\n    // and returns\n    //      D the max value that can be obtained by combining the things\n    //      s_opt the selection (array of length n) of things optimizing D\n    var D = function(n,r,M_max) {\n        // Start by checking whether the value is already cached...\n        if(DCached[n-1] != null) {\n         if(DCached[n-1][r-1] != null) {\n            //console.log(\"knapsack.D: n=\" + n + \" r=\" + r + \" returning from cache.\");\n            return DCached[n-1][r-1];\n         }\n\n        }\n        var D_result = new result(-Infinity, []); // here we will manage the result\n        //D_result.s_opt[n-1] = 0; // just put something there to start with\n        if (r<0) {\n            //D_result.p_max = -Infinity;\n            return D_result;\n        }\n        if (n==0) {\n            D_result.p_max = 0;\n            return D_result;\n        }\n        var p_sum;\n        //self.s_opt[n] = 0; not needed\n        var J = Math.min(l[n-1].length,M_max);\n        var D_minusOneResult; //storing the result when optimizing all previous items given a max length\n        for(var j = 0; j < J; j++) {\n            D_minusOneResult = D( n-1 , r - l[n-1][j] , M_max)\n            p_sum = p[n-1][j] + D_minusOneResult.p_max;\n            if(p_sum > D_result.p_max) {\n                D_result.p_max = p_sum;\n                D_result.s_opt = D_minusOneResult.s_opt;\n                D_result.s_opt[n-1] = j;\n            }\n\n        }\n        DCached[n-1] = [];\n        DCached[n-1][r-1] = D_result;\n        //console.log(\"knapsack.D: n=\" + n + \" r=\" + r + \" p_max= \"+ p_max);\n        return D_result;\n    }\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 knapsack with dependent item weight?\r\n                \r\nThe standard 0/1 knapsack requires that the weight of every item is independent to others. Then DP is a efficient algorithm towards the solution. But now I met a similar but extensions of this problem, that \n\n\n  the weight of new items are dependent on previous items already in\n  the knapsack.\n\n\nFor example, we have 5 items ```\na```\n, ```\nb```\n, ```\nc```\n, ```\nd```\n and ```\ne```\n with weight ```\nw_a```\n, ..., ```\nw_e```\n. item ```\nb```\n and ```\nc```\n have weight dependency.\n\nWhen ```\nb```\n is already in the knapsack, the weight of item ```\nc```\n will be smaller than ```\nw_c```\n because it can share some space with ```\nb```\n, i.e. ```\nweight(b&c) < w_b + w_c```\n. Symmetrically, when ```\nc```\n is already in the knapsack, the weight of ```\nb```\n will be smaller than ```\nw_b```\n.\n\nThis uncertainty results a failure of original DP algorithm, since it depend on the correctness of previous iterations which may not correct now. I have read some papers about knapsack but they either have dependencies subjected to profit (quadratic knapsack problem), or have variable weight which follows a random distribution (stochastic knapsack problem). I have also aware of the previous question 1/0 Knapsack Variation with Weighted Edges, but there is only a very generic answer available, and no answer about what is the name of this knapsack.\n\nOne existing solution:\n\nI have also read one approximate solution in a paper about DBMS optimizations, where they ```\ngroup the related items as one combined item for knapsack```\n. If use this technique into our example, the items for knapsack will be ```\na```\n, ```\nbc```\n, ```\nd```\n, ```\ne```\n, therefore there is no more dependencies between any two of these four items. However it is easy to construct an example that does not get optimal result, like when ```\nan item with \"small weight and benefit\" is grouped with another item with \"large weight and benefit\"```\n. In this example, the \"small\" item should not be selected in solution, but is selected together with the \"large\" item.\n\nQuestion:\n\nIs there any kind of efficient solving techniques that can get optimal result, or at least with some error guarantee? Or am I taking the wrong direction for modelling this problem?\n    ", "Answer": "\r\nCould you not have items ```\na```\n, ```\nb```\n, ```\nc```\n, ```\nbc```\n, ```\nd```\n and ```\ne```\n? Possibly with a constraint that ```\nb```\n and ```\nbc```\n can't be both in the knapsack and similarly so with ```\nc```\n and ```\nbc```\n? My understanding is that that would be a correct solution since any solution that has ```\nb```\n and ```\nc```\n can be improved by substituting both by ```\nbc```\n (by definition). The constraints on membership should take care of any other cases.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "IndexError: list index out of range on a Knapsack problem\r\n                \r\nThe Question asks me to give an input weight, the number of items I can keep and the weight array. It asks me to calculate the maximum amount of weight I can carry (0-1 Knapsack: Dynamic Programming)\n\n```\nW```\n: Input Weight\n```\nn```\n: Number of items\n```\nwt```\n: weight array  \n\nI get an Index Error for line 10 when I'm executing this code. It seems to be a very silly mistake at my end and I'm unable to figure it out after hours of running test cases.\nThe solution I googled up and found seems to be taking the value t[j][i] for every place where I write t[i][j]\n\n\r\n\r\n```\n# Uses python3\r\nimport sys\r\n\r\ndef optimal_weight(W, wt, n):\r\n     t = [[0 for x in range(n+1)] for y in range(W+1)]\r\n\r\n     for i in range(1,n+1):\r\n        for j in range(1,W+1):\r\n             if wt[i-1]<=j :\r\n                t[i][j]= max ( wt[i-1] + t[i-1][j-wt[i-1]] , t[i-1][j])\r\n             else :\r\n                t[i][j]= t[i-1][j]\r\n\r\n     return t[n][W]\r\n\r\nif __name__ == '__main__':\r\n    arr = list(map(int, input().split()))\r\n    W = arr[0]\r\n    n = arr[1]\r\n    wt= list(map(int, input().split()))\r\n    print(optimal_weight(W, wt,n))```\n\r\n\r\n\r\n\n    ", "Answer": "\r\n```\nt = [[0 for x in range(n+1)] for y in range(W+1)]\n```\n\n\nYour outer list dimension here is ```\n0..W```\n, and the inner is ```\n0..n```\n; i.e. your valid index range is ```\nt[0..W][0..n]```\n. So you would need ```\n[j][i]```\n instead of ```\n[i][j]```\n, since your ```\ni```\n is going to ```\nn```\n and your ```\nj```\n is going to ```\nW```\n. \n\nAlternatively, you can flip how you define the list:\n\n```\nt = [[0 for x in range(W+1)] for y in range(n+1)]\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Solution using Recursion\r\n                \r\nI am trying to solve Knapsack problem using recursion in Scala but my requirement is to show which items are chosen to keep in Knapsack. ```\navailableMoney```\n indicates the knapsack size.\n\nMy code is as follows:\n\n```\ndef knapsack(availableMoney: Int,wt:List[Int],value :List[Int] ,n:Int) : Int= {\n\n  if(n == 0 || availableMoney == 0)  \n    return 0\n  if (wt(n - 1) > availableMoney) {     \n    return knapsack(availableMoney,wt,value, n - 1)\n  }\n  else {\n    var element1 = value(n-1) + knapsack(availableMoney- wt(n-1), wt, value, n-1)\n    var element2 = knapsack(availableMoney, wt, value, n-1)\n\n    return max(element1,element2);\n  }\n}\n```\n\n\nHow to know which items are picked to keep in Knapsack ?\n    ", "Answer": "\r\nIn your code, you already know if you chose the current element or not.\n\nIf you picked ```\nelement1```\n (it is higher than ```\nelement2```\n), then the last (index=n-1) element was picked. Otherewise, you didn't.\n\nSo, you can add another output argument to be returned from the recursive call, that will indicate the chosen elements.\n\nAnd you will need to modify all ```\nreturn ...```\n to also take care of it:\n\n\n```\nreturn 0```\n will become ```\nreturn (0,[])```\n\n```\nreturn knapsack(availableMoney,wt,value, n - 1)```\n stays as is.\n```\nreturn max(element1,element2)```\n will return ```\n(element1, list1.add(n-1))```\n or ```\n(element2, list2)```\n, depending on which is higher, ```\nelement```\n or ```\nelement2```\n.\n\n\nAlso, if you want to implement is as Dynamic programming, this question discusses how to return the elements and not only values: \n\nHow to find which elements are in the bag, using Knapsack Algorithm [and not only the bag's value]?\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Algorithmic problem : Enhanced - Knapsack\r\n                \r\nThe problem is quite tough to explain but I will try my best.\nThere is total weight W and a bag of fruits.\nThen there are n items.\nTask is to find the best fit.\nThe set of items with Max fruits has to be the answer. If the set has same no of fruit then the set with Max weight has to be selected. If that is same then set with max-item-weight has to be the winner.\nFor W=15, bag of fruits = {A,B,C}, n=5\nItems are as below:\n\nWhich has weight 7 and requires A\nWhich has weight 6 and requires B,C\nWeight 8 and requires no fruits.\nWeight 6 and requires no fruits\nWeight 7 and requires B\n\nHere the follow sets\n\n{1, 3} has weight 15, f: 1\n{1,5} has weight 14, f: 2\n{2,3} has weight 14, f:2\n{1,2} has weight 13, f:3\n\nSo the answer here would be set with item {1, 2}.\nThe things that I have already tried\n\nSearching all possible combination 2^n (not a good idea)\nSort the items by Max fruits and Max weight and then select but does not guarantee best fit.\nObviously this can be done with knapsack\nBut requires state of fruit bag has to be stored on every cell of dp table. Will take up more space.\n\nIs any further optimization possible?\nAnother example:\nn = 4, W = 1, fruits { A,A,A,A,A}\n\nw=0, f = {A,A,A,A}\nw=0, f = {A,A,A}\nw=0, f = {A,A}\nw=1, no fruits\n\nIt should select items {2,3}\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How does DP helps if there are no overlapping in sub problems [0/1 knapsack]\r\n                \r\nConsider below inputs for typical Knapsack problem.\n\n```\nV = [10,8,12]\nW = [2,3,7]\ni =  1,2,3\nC = 10\n```\n\n\nI tried recursion with memoization to solve this sample but found no overlapping sub problem. \n\nSignature of the recursive procedure : \n\n```\nknapsack(int c, int i) \n```\n\n\nCalled initially as ```\nknapsack(10,1)```\n\n\n\n\nThe method of the solution is like as explained in https://www.youtube.com/watch?v=6h6Fi6AQiRM and https://www.youtube.com/watch?v=ocZMDMZwhCY.\n\nHow does Dynamic programming helps in reducing the time complexity for such samples of Knapsack ? If it does not help improving the time complexity of this case then does worst case complexity of DP solution also same as of back track search based i.e. 2 to the power n [ignoring the pruning, as if pruning applied then complexity will reduce for both the solution and again DP will not be better than non memoized recursive solution]  \n\n** Is overlapping in sub problems really missing in the above sample or I am missing something ?**\n    ", "Answer": "\r\nDP doesn't help at all on your specific problem instance.  But in general, i.e. over all possible input instances, it never solves more subproblems than the pure recursion, and on many instances it solves much fewer.  That's why DP is good.\n\nAll your DP formulation guarantees is that it can solve any instance of the problem by solving at most ```\nn(c+1)```\n subproblems, and indeed it does so for your example: here ```\nn```\n = 3 and ```\nc```\n = 10, and it solves the problem by solving 14 <= 33 subproblems (including the original problem).\n\nSimilarly, the purely recursive solution guarantees that it can solve any instance of the problem by solving at most ```\n2^n```\n subproblems.\n\nYou seem to be thinking that the DP algorithm should solve every problem instance faster than the recursive algorithm, but this is not true, and no one is making this claim.  There exist instances (like yours) for which there are no overlapping subproblems, and for these instances the DP solves the problem using the exact same number of subproblems as the recursive solution.  This does not say anything about the behaviour of the two algorithms in general.  In general, the DP solves every problem using at most as many subproblems as the recursive solution, and sometimes much fewer -- since there do exist problem instances for which the recursive algorithm needs to solve the same subproblem more than once.\n\nIn short: The DP is never worse than the recursion, and is better than the recursion in the worst case.  That does not imply that it is better on every instance.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Searching Algorithm: Product Knapsack Problem with goal to find lowest product above a certain threshold?\r\n                \r\nI'm looking for people with some algorithmic knowledge who can help me out with this.\nI'm currently programming a constrained tree search in java, where I want to have a certain amount of leaf nodes that is just bigger than a given threshold T.\nI'm boiling down the problem (which is most likely NP complete) to this:\nProblem\n\nInput: a threshold T, and a List of entries L = [e1, e2, ..., en], where for every ei (where 1 <= i <= n) there is a defined arbitrary maximum weight wMaxi and a minimum weight  wMini = 1. (wMax_i >= wMin_i)\n\n\nOutput: a choice of weights wi, so that:\n\nwMaxi >= wi >= wMini = 1\nthe product W of wi is greater than threshold (W > T)\nthe product of wi is lowest possible or if not possible is linearly constrained in T (W is in O(T) / W < k * T)\n\n\nNotes\n\nall numbers are integers here\nit will always be true that the product of wMaxi Wmax >> T\nit would be highly preferable to find a solution where the wi are evenly distributed, meaning that I would rather have [2,2,2,2 ...] than [4,1,4,1, ...], this would be even more preferred over finding a solution with lowest possible W as long as it's linearly constrained.\n\nI tried to approximate the solution when defining this problem with float numbers: every entry would be able to have a weight of ceil(logn(T)) but this approximation doesn't work as the max weights are distributed quite unevenly.\nFurthermore I read some articles on solving the product knapsack problem, but they were interested with achieving a max weight.\nI'm also not so sure if this problem can be reduced to the knapsack problem, as the threshold is quite tricky to handle and I deal with products.\nEdit:\nI ended up brute forcing it by iteratively and evenly increasing weights until I'm above T.\nEdit:\nExample data:\n\nentries: [e1 ,e2 , e3 , e4]\nweightmax respectively: [3,3,2,5]\nThreshold: T = 15\n\nSolution (nearest Threshold):\n\ne1 = 1, e2 = 3, e2=1, e4 = 5  (Product 15)\ne1 = 3, e2 = 1, e2=1, e4 = 5  (Product 15)\n\nSolution (as balanced as possible, while also near):\n\ne1 = 2, e2 = 2, e3 = 2, e4 = 2 (Product 16)\n\n    ", "Answer": "\r\nI have an algorithm similar to your brute force idea.\n\nbrute forcing it by iteratively and evenly increasing weights until I'm above T.\n\nLet's do this, but using binary search instead. The algorithms goes something like this.\n\nSort by wMaxi\nDefine ```\nf(x)```\n as the product of wi where wi = min(wMaxi, x). See below on how to compute ```\nf(x)```\n\nBinary search to find k where f(k) <= T and f(k+1) > T\nFind the optimal i to \"split\" the list into k and k+1. So wj = min(wMaxi, k) if j < i, and wj = k+1 if j >= i. We can to find i such that the product is just above T with either linear or binary search\n\nTo compute ```\nf(x)```\n, a naive solution would suffice. But we can also compute the prefix product pi, binary search for i where wMaxi < x and wMaxi+1 >= x. Then ```\nf(x)```\n is equal to pi plus x to the power of the number of elements left (watch out for off by 1 error).\nThe product is less than 2 * T. Also note that with this algorithm, the problem (where the product is not minimized but the variance/standard deviation of the weights is minimized) is not NP complete.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "understanding the Knapsack problem O(2^n) where T(n)\r\n                \r\nQuestion: With the best solution of knapsack being O(2^n), how fast would a partition function (below) be in terms on N?\n\nIs this just as simple as saying O(n + 2^n)?\nor is that just wrong and its O(2^n) since we now know what T(n) is.\n\npartition function:\n\n```\nbool Partition(List S){  \n     create two lists //O(n) + O(n) \n     M = (Sum of all elements in S)/2; //O(n) \n     K = (Sum of all elements in S)/2; //O(n)\n     if(Knapsack(Profits, Weights, M, K) == true) // O(2^n) \n          return true; \n     else \n     return false; \n} \n```\n\n    ", "Answer": "\r\nThe time complexity is just ```\nO(2^n)```\n because a complexity of ```\nO(n + 2^n)```\n is ```\nO(2^n)```\n. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack variant problem with topN solutions of fixed size\r\n                \r\nI have a dynamic programming question. I'm trying to find a good-enough solution in python for a knapsack variant problem.\n\nThe additional requirements:\n\n\nInstead of having just the best solution I'm looking for the best\ntopN solutions.\nI'm looking for solutions with exactly size S. i.e. the amount of items in the backpack must be S. Optionaly, if S is -1 we accept flexible sizes\n\n\nSo, I want to put in the knapsack S elements to find the most valuable subsequence of items that weighs no more than maxweight.\nEach element has (value, weight), where the value is a number and weight is a non-negative integer. Maxweight is a non-negative integer.\n\nExample:\n\n```\ndef knapsack_variant(items, maxweight, S=-1, topN=10):\n    \"\"\"\n    >>> items = [(4, 12), (2, 1), (6, 4), (1, 1), (2, 2)]\n    >>> maxweight = 15\n    >>> S = 4\n    >>> topN = 3\n    >>> knapsack_variant(items, maxweight, S, topN)\n    (11, [(2, 1), (6, 4), (1, 1), (2, 2)])\n    next two solutions\n    \"\"\"\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Dynamic Programming of a Knapsack-like problem\r\n                \r\nI need a bit of help coming up with a bottom-up approach to a Knapsack-like problem.\nProblem:\nBasically, you have some items, each item has a value and a weight and you want to pick the items that have the add up to the least weight but the sum of values get you to a certain value that is provided.\nLet's say we have a 2d array with our weights and values.\nThe weights and values are nonnegative.\nex:\n|index| Weights  | Values |\n|-----| -------- | ------ |\n|1    |    3     |   15   |\n|2    |    29    |   5    |\n|3    |    12    |   1    |\n|4    |    99    |   2    |\n|5    |    12    |   9    |\n|6    |    0     |   40   |\nand we also have a threshold for the values that we need to get to or go above(instead of a limit in Knapsack).\nSo we want to pick the items that have the least weight but get us to or above the threshold.\nSo the threshold for the example above is 64. and we can choose the items 1,2,5,6 that gives us a weight of 44 and a value of 69 that is above the threshold.\nI hope the problem is clear, if not I can provide more examples later.\nHere is a formula for what we want:\nFormula\nMy solution till now:\nI'm working to build a dynamic table using a bottom-up approach. This is the pig picture code that I have for building the part that builds the table:\n```\n// arr: 2D array that holds the weigth and values (starting from index 0)\n// Values: the second column of the array\n// Weights: the first column of the array\n// n = Number of distinct items\n// W = the threshold\n// m: table that I store the values in\n\n\n\nfor j from 0 to W do:\nm[0, j] := INF\n\nfor i from 1 to n do:\nfor j from 0 to W do:\nif arr[i-1,1] > j then:\nm[i, j] := m[i-1, j]\nelse:\nm[i, j] := min(m[i-1, j], m[i-1, j-arr[i-1,1]] + arr[i-1,0])\nreturn m[n,W]\n```\n\n\nBasically, I'm getting subtracting the value from the threshold and finding the minimum amount(i.e the minimum weight possible to get there).\nHowever, this isn't giving me the correct table in a lot of tests and I can't figure out where I'm going wrong.\nI'm kind of stuck, any hint or reference to correctly build the table would be really appreciated.\n    ", "Answer": "\r\nYour solution can't get values above the threshold. Just calculate the same dynamic programming up to ```\nW+(max value in array)```\n and for answer find minimum within ```\nm[n, W+e]```\n for ```\ne >= 0```\n and ```\nW+e```\n is within array bounds.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Problem solving question: knapsack variation with two variables and different total\r\n                \r\nI'm trying to figure out the solution to this problem, which is quite similar to the knapsack problem, but I'm not sure what states I should have or how to memorize them.\nYou have an electric car which weighs W units and you want to make it go for as long as possible. To do this you must pick from N batteries which also have an energy e, a weight b and a cost c.\nThe amount of time your car can go for is t = Etotal / Wtotal (the sum of energies of batteries you chose divided by the sum of the weight of the batteries you chose + the weight of the car itself)\nGiven that you have a budget B, what is the maximum time your car can go for?\nExample:\n```\nINPUT:\nN = 10 /number of batteries to choose\nB = 1000 /budget\nW = 20 /weight of car\n#N batteries with numbers e (energy), w (weight), c (cost)\n40 40 40\n1 1 1\n70 30 60\n100 20 700\n80 50 200\n30 1 200\n100 100 1\n20 1 500\n30 20 100\n70 50 100\n\nOUTPUT:\n3.17073170731707\n```\n\n    ", "Answer": "\r\nStraightforward DP algorithm\nWe can compute the minimum cost f(i, j, k) of a solution that achieves exactly total energy j and total weight k by choosing some subset of the first i batteries. This is given by:\n```\nf(0, 0, W) = 0\nf(0, j!=0, W) = INF\nf(0, j, k!=W) = INF\nf(i>0, j, k<W) = INF\nf(i>0, j, k>=W) = min(f(i-1, j, k), f(i-1, j-E[i], k-W[i]) + C[i])\n```\n\nwhere E[i], W[i] and C[i] are the energy, weight and cost of battery i, respectively. After computing values of this function for all 0 <= i <= N, 0 <= j <= Sum(E[]) and 0 <= k <= W+Sum(W[]), find the maximum of j/k over all 0 <= j <= Sum(E[]) and 0 <= k <= W+Sum(W[]) such that f(N, j, k) <= B.\nA direct implementation using a 3D DP table will take time and space O(N*Sum(E[])*(W+Sum(W[]))) time and space. But since the recursion never needs to reach back further than 1 step in the first parameter i, we can make the outermost loop increase i and drop the first dimension from the DP table, overwriting its entries as we go, to drop the space complexity by a factor of N.\nThe above DP computes minimum costs, but it could be \"rotated\" to optimise for any of the three variables (minimum cost for given energy and weight, maximum energy for given cost and weight, or minimum weight for given energy and cost). The most efficient approach is to optimise for the variable with the largest range, since the time and space complexity involve the product of the ranges of the remaining two variables.\nGreedy algorithm for unconstrained costs\nThe following simple O(N*log N)-time, O(N)-space algorithm maximises the distance travelled if there are no cost constraints. I think it's interesting because of the proof of correctness.\n\nSort batteries in decreasing order by energy divided by weight (you could think of this as \"energy density\").\nKeep adding batteries from this list until the next battery has energy/weight less than the (total energy)/(total weight) of the batteries (and car) chosen so far.\n\nA key element in proving this correct is the observation that, whenever we combine two multisets of batteries (we can consider the car to be an always-chosen battery with energy level 0), the mean of the resulting multiset is strictly in between the original two means. I'll call this the \"mean-betweenness\" lemma; see Lemma 1 here for a proof. Intuitively this means (hehe) that whenever we can add a battery with higher energy density than the multiset of batteries chosen so far, we should -- since the result of combining these two multisets (the new battery is a multiset of size 1) will be strictly in between them, and thus strictly higher than the multiset of batteries chosen so far.\nRunning the algorithm above will choose a multiset of batteries in which some initial number s of batteries in the sorted list will be chosen, and no other batteries will be chosen. By the mean-betweenness lemma, the algorithm clearly chooses an optimal multiset of solutions among all solutions having this form (that is, among solutions that choose only some initial number of batteries in the list). To establish that it chooses an optimal solution overall, we need to show that no solution that \"skips over\" one or more batteries in this list and then chooses one or more batteries further down can be better.\nSuppose to the contrary that there exists an optimal solution X that skips a battery, and that this solution is strictly better than the solution Y produced by the greedy algorithm. Let i be the first battery that X skips. Thus X and Y share the first i-1 batteries. There are 2 cases:\n\nE[i]/W[i] is strictly greater than the energy/weight of X. In this case, by the mean-betweenness lemma, we can add battery i to X to produce a solution that is strictly better than X, contradicting the optimality of X.\nE[i]/W[i] is less than or equal to the energy/weight of X.\n\nContinuing with case 2, consider the submultiset X' of batteries chosen further down the list by X (by assumption this must contain at least one battery). Because the list is ordered by decreasing energy/weight, these batteries each have energy/weight at most equal to that of battery i (namely, E[i]/W[i]), so by the mean-betweenness lemma their mean energy/weight is also at most equal to E[i]/W[i]. X = (X-X') ∪ X', so by the mean-betweenness lemma, the mean energy/weight of X is strictly between (X-X') and X'. Since the mean energy/weight of X' is less than or equal to the mean energy/weight of X overall, removing the batteries in X' from X to leave (X-X') will in the best case (when the means of X and X' are equal) leave the mean unchanged, and otherwise increase it. Either way, we have constructed a new solution (X-X') with mean energy/weight at least as high as X and which consists of the first i-1 batteries in the list -- that is, a solution of the form that the greedy algorithm is known to maximise over.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Determine set of items upto max n, which give the smallest total value and whose combined weights >= the capacity weight (knapsack problem variant)\r\n                \r\nI'm trying to run a variant of the knapsack problem whereby I need the item combo that gives the smallest total value but whose combined weight equals or surpasses the capacity weight.\n```\nmaxn = 3\nvm = [60, 100, 120, 50, 10, 10]  # Values\nwt = [10, 20, 30, 20, 5, 5]  # Weights\nW = 50  # Capacity weight\nn = len(vm)\n```\n\nWhat I have, gives me the classic knapsack answer (the highest total value):\n```\ndef knapsack(n, W, wt, vm):\n    for i in range(n+1):\n        for w in range(W+1):\n            if i == 0 or w == 0: \n                K[i][w] = 0\n            elif wt[i-1] <= w: \n                K[i][w] = max(vm[i-1]  \n                    + K[i-1][w-wt[i-1]],  K[i-1][w]) \n            else: \n                K[i][w] = K[i-1][w]\n    print(K[n][W])\n    return K[n][W]\n\ndef items_in_optimal(n, W, wm):\n    i = n\n    j = W\n\n    while (i > 0 and j > 0):\n        if(K[i][j] != K[i-1][j]):\n            print(i-1)\n            j = j-wm[i-1]\n            i = i-1\n        else:\n            i = i-1\n\nK = [[0 for i in range(W + 1)] for j in range(n + 1)] \nknapsack(n, W, wt, vm)\nitems_in_optimal(n, W, wt)\n\nOutput: \n220\n2\n1\n```\n\nThe result I'm looking for is:\n```\nOutput:\n170\n3\n2\n```\n\nAny help is much appreciated!\nEdited question to be clearer\nEdit 2:\nThis is what I've come up with, but I'd be very interested if there's a faster method:\n```\nfrom itertools import combinations\nimport numpy as np\n\nrlen = [2, maxn]\na = []\nfor r in rlen:\n    best_value = sum(vm)\n    for i in combinations(np.arange(0, len(vm)), r):\n        if sum(np.array(wt)[list(i)]) >= W:\n            if sum(np.array(vm)[list(i)]) < best_value:\n                best_value = sum(np.array(vm)[list(i)])\n                best_indices = list(i)\n    a.append([r, best_value, best_indices])\n\nsplit_inv = min(a, key=lambda t: t[1])[2]\nprint(split_inv)\n```\n\n    ", "Answer": "\r\nCreate a 2D table where the rows represent weights from 0 to W, and the columns represent the number of items from 0 to N. Each entry should be a tuple: ```\n(valid, value, indexList)```\n.\nInitially, only ```\ntable[0][0]```\n is valid.\nFor each item, scan the table in reverse. In other words, the loops look like this:\n```\nitems = zip(wt, vm)\nfor itemIndex, (itemWeight, itemValue) in enumerate(items):\n    for w in range(W,-1,-1):\n        for n in range(N-1,-1,-1):\n```\n\nNote that the ```\nn```\n loop starts at ```\nN-1```\n. An entry in column N of the table represents a list of N items, and therefore another item cannot be added to that entry.\nWhen you find an entry ```\ntable[w][n]```\n that is valid, compute a new weight, value, and indexList by adding the current item to that entry. (If ```\nw + itemWeight```\n is greater than W, then the new weight is W.) Then compare with the candidate entry ```\ntable[newWeight][n+1]```\n. If the candidate is not valid, or has a higher value, update the candidate. If the candidate is valid and has a lower value, don't change it.\nOnce all the items have been scanned, find the entry in the last row of the table that has the lowest value, and that's the answer.\nFor the given example, the final table is shown below. Only rows with valid entries are shown. The first column is the weight for that row.\n```\n 0 [(True , 0, []), (False,  0, []),  (False,  0, []),     (False,  0, [])]\n 5 [(False, 0, []), (True,  10, [4]), (False,  0, []),     (False,  0, [])]\n10 [(False, 0, []), (True,  60, [0]), (True,  20, [4, 5]), (False,  0, [])]\n15 [(False, 0, []), (False,  0, []),  (True,  70, [0, 4]), (False,  0, [])]\n20 [(False, 0, []), (True,  50, [3]), (False,  0, []),     (True,  80, [0, 4, 5])]\n25 [(False, 0, []), (False,  0, []),  (True,  60, [3, 4]), (False,  0, [])]\n30 [(False, 0, []), (True, 120, [2]), (True, 110, [0, 3]), (True,  70, [3, 4, 5])]\n35 [(False, 0, []), (False,  0, []),  (True, 130, [2, 4]), (True, 120, [0, 3, 4])]\n40 [(False, 0, []), (False,  0, []),  (True, 150, [1, 3]), (True, 140, [2, 4, 5])]\n45 [(False, 0, []), (False,  0, []),  (False,  0, []),     (True, 160, [1, 3, 4])]\n50 [(False, 0, []), (False,  0, []),  (True, 170, [2, 3]), (True, 180, [2, 3, 4])]\n```\n\nThe last row shows that the lowest value for 2 items is 170, and the lowest value for 3 items is 180. So 170 is the lowest value overall.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Problem, with a fixed choice (required)\r\n                \r\nI am new to python and am working through some problems in a book. Right now, I implemented a code (at the beginning creating a class etc) to optimise the combination of the given items.\nNow I would like to put some requirements such as in the combination has to be either Project 1 or Project 2. Another example would be if  Project 1 is include also to append Project 2.\nI tried changing the code below the function fastMaxVal but did not manage to solve the problem.\n\nI hope that somebody can tell me what I would need to change. This would be very helpful and thank you in advance.\n\nBest regards,\n\n```\n\nclass Item(object): # return object which is choosen\n    def __init__(self, n, v, w):\n        self.name = n \n        self.value = v\n        self.weight = w\n    def getName(self):\n        return self.name\n    def getValue(self):\n        return self.value\n    def getWeight(self):\n        return self.weight\n    def __str__(self):\n        result = '< ' + self.name + '  PV: ' + str(self.value) + ', Weight of investment: $'\\\n        + str(self.weight) + ' >'\n        return result\n\ndef value(item): #for the value \n    return item.getValue()\n\ndef weightInverse(item): #weight inverse as said in the name\n    return 1.0/item.getWeight()\n\ndef density(item):\n    return item.getValue()/item.getWeight()\n\n#toConsider(items that are higher in the tree)\n#avail = available\n#memo = memorized (kepp track of possibilities it has already evaluated)\ndef fastMaxVal(toConsider, avail, memo = {}):\n    if (len(toConsider), avail) in memo:\n        result = memo[(len(toConsider), avail)]\n    elif toConsider == [] or avail == 0:\n        result = (0, ())\n    elif toConsider[0].getWeight() > avail:\n        result = fastMaxVal(toConsider[1:], avail, memo)\n    else:\n        nextItem = toConsider[0]\n        withVal, withToTake = fastMaxVal(toConsider[1:], avail - nextItem.getWeight(), memo)\n        withVal += nextItem.getValue()\n        withoutVal, withoutToTake = fastMaxVal(toConsider[1:], avail, memo)\n        if withVal > withoutVal:\n            result = (withVal, withToTake + (nextItem,))\n        else:\n            result = (withoutVal, withoutToTake)\n    memo[(len(toConsider), avail)] = result\n    return result\n\ndef smallTest():\n    names = ['Project 1', 'Project 2', 'Project 3', 'Project 4', 'Project 5', 'Project 6', \n             'Project 7', 'Project 8', 'Project 9', 'Project 10']\n    vals = [NPV_1, NPV_2, NPV_3, NPV_4, NPV_5, NPV_5, NPV_7, NPV_8, NPV_9, NPV_10]\n    weights = [-inv_1[0], -inv_2[0], -inv_3[0], -inv_4[0], -inv_5[0], -inv_6[0], -inv_7[0], \n               -inv_8[0], -inv_9[0], -inv_10[0]]\n    Items = []\n    for i in range(len(vals)):\n        Items.append(Item(names[i], vals[i], weights[i]))\n    val, taken = fastMaxVal(Items, 100000)\n    for item in taken:\n        print(item)\n    print('Total PV of investments taken = $', round(val, 2))\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Maximum and MinCost Knapsack\r\n                \r\nI am familiar with the 01 knapsack problem in that the goal is to put items in the knapsack that fit under the weight constraint. What is the difference between Maximum Knapsack and MinCost Knapsack? In which one am I given a budget or target value? \n    ", "Answer": "\r\nExplainig with examples\n\n\nMaximum Knapsack(From Sartaj Sahni Algo Book) :\n\n\n\n\nHere We have a Target/Budget value i.e. Weight, \nin this case  ```\nm=20```\n, \n```\nNumber of objects i.e. n=3```\n, \n\n```\nweight of each object w1,w2,w3```\n \nand \n```\ncorresponding profits for these weights p1,p2,p3```\n. \n\nYou can fill this sack in numerous ways but in the example they have shown profit values for 4 combinations of objects. Solution 4 gives max profit.\n\nThis is maximum knapsack because we have Profit values associated with each object and we need to fill this knapsack so that we maximize the profit.\n\nNote: for 0-1 Knapsack values in above exapmle for x1,x2,x3 can't be fraction it has to be either  ```\n0 or 1```\n.\n\n\nMin-Cost Knapsack(From GeeksForGeeks) Two examples:\n\n\nNOTE: Also here object weights are the indices in array, starting at 1.\ni.e. w[] = {1,2,3,4,5}\n\ncost[] is cost required when you add particular object.\n\n```\nIf you add cost[1]=20 then w[1]=1 kg, cost[2]=10 then w[2]=2 kg and so on.```\n\n\n\n\nHere, also we have Target/Budget value i.e. Weight, in this case W=5, but we don't have profit values instead we have cost values. We need to minimize cost while filling this sack.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Fractional Knapsack + \"yields a solution that is less than 1% of optimal for the 0/1 Knapsack.\"\r\n                \r\nI am going over a review for an upcoming test and was wondering if someone could restate part b of the question. This is the text from the review sheet passed out, but I am not sure what part b is asking exactly. I guess more straitly what does it mean by \"yields a solution that is less than 1% of optimal for the 0/1 Knapsack problem.\" \n\na) Solve the following instance of the Knapsack problem, i.e., give fraction of each object chosen and value of optimal Knapsack.  Show steps:\n\nCapacity of Knapsack is C = 100\n\n** Here he lists the objects, their values, and weights. in a table **\n\nb) [10pts] Give an example with two objects that shows that the same greedy method used for the fractional Knapsack problem (slightly modified to leave out the last object chosen by the greedy method if it doesn’t fit) yields a solution that is less than 1% of optimal for the 0/1 Knapsack problem.\n    ", "Answer": "\r\nUsually the greedy heuristic works pretty well for the knapsack problem.  If you just come up with a small problem instance at random, it's likely that applying the greedy heuristic will produce a good, or possibly even optimal solution.  (The quality of a solution is measured by taking the total value of the objects it includes, and computing the ratio of that to the total value of the objects included in an optimal solution.)\n\nThis question is asking you to come up with a nasty problem instance (i.e. a list of objects with values and weights) that confuses the greedy heuristic so much that applying it yields a knapsack containing only 1% of the value that an optimal solution would contain.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple Knapsack, weight = profit\r\n                \r\nI have a research on Knapsack Problems. Now I stopped on special type of a Multiple Knapsack Problem, where weight of each item is equal with profit of this item.\n\nI can't find any paper saying anything about the complexity of this problem. Is it NP-complete or not?\n\nAny help will be appreciated.\n    ", "Answer": "\r\nI found a problem that can be reduced to mine - The Multiple Subset Sum Problem. The Multiple Subset Sum Problem (MSSP) is the selection of items from a given ground set and their packing into a given number of identical bins such that the sum of the item weights in every bin does not exceed the bin capacity and the total sum of the weights of the items packed is as large as possible. It can be easily reduced to my problem. It proves that my problem is NP-hard.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Collapsing knapsack, the capacity change is based on the selected items instead of the number\r\n                \r\nThe collapsing knapsack problem is a generalization of the ordinary knapsack problem, where the knapsack capacity is a non-increasing function of the number of items included.\n\nDoes anyone know anything (name, literature, algorithms...) about a variant where the knapsack capacity changes depending which items you select (i.e., the domain is the powerset of the items) instead of the number of items?\n    ", "Answer": "\r\nFor general value of the 'capacities', I believe you will need to do some kind of enumeration on the set elements. If I understand correctly, it corrispond more or less to an arbitrary boolean that say wether a subset is feasible (the sum of the weights of its elements is lower than its capacity) or not.\n\nA 'capacity' in the knapsack problem is something that appears at the right-hand-side of the constraint, i.e.\n\n```\nsum p_i x_i <= C\n```\n\n\nin the classical knapsack and\n\n```\nsum p_i x_i <= C (sum x_i)\n```\n\n\nin the collapsing knapsack.\n\nBecause those are linear constraint, they behave in a somehow predictible way, which avoid to look at all the possible combinations (the elements of the power set) to solve the problem.\n\nNow if you have an arbitrary capacity value ```\nC_J```\n for each element of the power set, your capacity is not a predictible function of the vector ```\nx```\n, so your only way to remove a subset ```\nJ```\n from the list that has to be examined is if its value (```\nsum_J a_i x_i```\n) is lower than the value of one of the subset that you already found to be feasible (you have no information whatsoever from the capacity).\n\nThis means in particular that there is no way to model this with an integer program, because it would require at least one constraint for each ```\nC_J```\n (just computing the cost for each feasible subset will be more efficient).\n\nI would go with an enumeration algorithm and try to reduce the search tree as much as possible.\n\nLet us order the items by non-increasing value ```\na_0 >= a_1 >= ... >= a_n```\n.\n\nWe can look all all the possible subsets by decreasing cardinality. This is because for some cardinal number ```\nk```\n, you know that the best possible subset with cardinality at most ```\nk```\n will have a value of ```\nM_k = sum_{i=0}^k a_i```\n, so you will be able to stop your search before examining all the subsets (I can't think of another way to cut the search tree).\n\nThe algorithm would be:\n\nStart with ```\nM := 0```\n and ```\nk=n```\n.\n\nRepeat:\n\n\nfind the best subset with cardinality ```\nk```\n if its value ```\nA```\n is better than ```\nM```\n\n```\nM := max (A, M)```\n: value of the best subset found so far\nif ```\nM >= M_{k-1}```\n, stop: we found the optimum\nelse ```\nk := k-1```\n\n\n\nTo search the best subset of cardinality ```\nk```\n, you can use the order of the ```\na_i```\n:\n\n\nstart with ```\n{0, ..., k}```\n and recursively examine the subsets ```\n{0} U J'```\n with ```\nJ'```\n a subset of cardinality ```\nk-1```\n of ```\n{1, ..., n}```\n,\nthen examine all the subsets of the form ```\n{1} U J'```\n with ```\nJ'```\na subset of cardinality ```\nk-1```\n of ```\n{2, ..., n}```\n, etc.\n\n\nAs soon as you found a feasible subset, update the bound ```\nM```\n.\n\nThis is again because the subsets of cardinality ```\nk```\n that do not contain ```\na_0, ..., a_i```\n are bounded by ```\na_{i+1} + ... + a_{i+k+1}```\n, and you can stop as soon as this is lower than the current bound ```\nM```\n.\n\nNote:\nI assumed no hypothesis on the capacity ```\nC_J```\n. It is certainly interesting to know if the capacity are increasing in the set-theory sense, i.e. if ```\nI```\n included in ```\nJ```\n implies ```\nC_I <= C_J```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Using Iterative deepening DFS for knapsack similar problem\r\n                \r\nI'm solving a knapsack similar problem: which is to print out the first combination of objects that has value above a number but weight below a limit.\nI have tried:\n```\nvalue = [10, 8, 7, 6, 4]\nweight = [8, 4, 3, 3, 1]\nname = ['A','B','C','D','E']\nWlimit = 8\nVlimit = 8\n\n\ndef ID(maxDepth):\n    for i in range(1, maxDepth):\n        knapsack = []\n        if (DFS(knapsack, 0, 0, i)):\n            return True\n        else:\n            print(\"cannot find solution\")\n            return False\n\ndef DFS(knapsack, currentValue, currentWeight, maxDepth):\n  \n    # If reached the maximum depth, stop recursing.\n    if maxDepth <= 0 : return False\n    if currentValue >= Vlimit and currentWeight <= Wlimit: \n        print(knapsack)\n        return True\n    \n    for i in range(len(name)):\n        if name[i] not in knapsack:\n            if ((currentWeight + weight[i]) < Wlimit):\n                knapsack.append(name[i])\n                DFS(knapsack, currentValue + value[i], currentWeight + weight[i], maxDepth - 1)\n\n                knapsack = knapsack[:-1]\n                DFS(knapsack, currentValue, currentWeight, maxDepth - 1)\n                \n            else:\n                DFS(knapsack, currentValue, currentWeight, maxDepth - 1)\n\n    return False\n```\n\n\nI know the tree looks like this\nBut I don't know how to fix the code with the correct logic\nHope someone can give me a hand on it.\nThank you!!\n    ", "Answer": "\r\nI tried this and it works for some samples:\n```\nweight = [1,1,3,4,5]\nvalue = [2,1,5,3,5]\nname = ['A','B','C','D','E']\nknapsack = []\nlimit_weight = 8\nlimit_value = 8\nn = 5 # number of items\n\ndef ID(maxDepth):\n    for i in range(maxDepth):\n        found, val, arr = DFS(i)\n        if found:\n            return arr\n    return False\n\ndef DFS(maxDepth, idx = 0, sum_val = 0, sum_weight = 0, arr = []):\n    if maxDepth < 0 : return False, None, None\n    if sum_weight > limit_weight : return False, None, None # elements weights exceed knapsack limit\n    if sum_val > limit_value : return True, sum_val, arr # elements values greater than required\n    if idx >= n : return False, None, None # no more elements and no solution (otherwise we would have returned from the previous line)\n    for i in range(idx,n):\n        n_arr = arr.copy()\n        n_arr.append(name[i])\n        found, new_sum_val, new_sum_weight = DFS(maxDepth-1, i+1, sum_val + value[i], sum_weight + weight[i], n_arr)\n        if found : return found, new_sum_val, new_sum_weight\n    return False, None, None # didn't find a solution\n\nres = ID(4)\nprint(res)\n```\n\nThe code returns False if no solution is found, and a list of element names if a solution is found.\nplease let me know if you find anything unclear.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Problems with a branch and bound knapsack algorithm\r\n                \r\nI am working on a knapsack optimization exercise written in Python. The goal is to fill a knapsack with limited weight capacity with items with a certain value and weight resulting maximizing the total value of the knapsack. I ran into a problem with setting the variables when a better solution is found.\nI've created a simplified version of the code without any constraints, demonstrating my problem. Since there are no constraints, the first solution is always the best solution since that is the solution where all items are taken.\nThere is an if statement in the code that sets the max_value and  best_taken variables in case a better solution is found.\nHowever: When the print statement at the end of the code prints the max_value and best_taken variables, the max_value shows the correct value (the sum of the first indices in the list of lists assigned to the items variable). The best_taken value always ends up as [0,0] where a value of [1,1] (=take both items) is expected.\nWhat am I doing wrong?\n```\nitems = [[5,3],[4,1]]\ndepth = 0\n\n\nclass BranchBound():\n    def __init__(self):\n        self.max_value = 0\n        self.best_taken = []\n        self.local_value = 0\n        self.local_taken = [0] * len(items)\n       \n    \n    def branch_and_bound(self,depth):\n        new_depth = depth\n        if new_depth < len(items):\n            #Take item\n            self.local_taken[new_depth] = 1           \n            new_depth += 1\n            self.branch_and_bound(new_depth)\n            \n            # Do not take item\n            new_depth = depth\n            self.local_taken[new_depth] = 0\n            new_depth += 1\n            self.branch_and_bound(new_depth)\n        else:\n            self.local_value = 0\n            for i,j in zip(self.local_taken,items):\n                self.local_value += i*j[0]\n            if self.local_value > self.max_value:\n                print(\"ping\")\n                self.max_value = self.local_value\n                self.best_taken = self.local_taken\n            \n        \nbb = BranchBound()\nbb.branch_and_bound(depth)\nprint(bb.max_value)\nprint(bb.best_taken)\n```\n\n    ", "Answer": "\r\nYou need to copy ```\nlocal_taken```\n. Assigning an array to an attribute just adds a reference to the same (mutable) array\n```\nself.best_taken = self.local_taken[:]```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "how knapsack problem will fit these weights in a theif bag as given below\r\n                \r\nA theft robbing a store find n items; the ith element is worth vi dollars and weight wi pounds. He wants to take as valuable load as possible, but he can carry at most W pounds in his knapsack. The theft is allowed to take fraction of an item for the fraction of the weight and fraction of the value. Determine which items should he take? The goal is to maximize the value of items without exceeding the weight limit W of knapsack. item_1(price=30$, weight=10kg) , item_2(price=100$, weight=25kg) item_3(price=250$, weight=50kg), item_4(price=30$, weight=30kg) item_5(price=20$, weight=10kg), Knapsack capacity (W)=100kg\n    ", "Answer": "\r\nSince the thief is allowed to take a fraction of an item for a fraction of the weight for a fraction of the value, you can use a greedy algorithm.\nSort the (value, weight) pairs by the (value / weight) descending. Then simply choose items from this list until you don't have space.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is wrong in this knapsack problem solution?\r\n                \r\nI understand that this is more of a problem solving  than a coding question as such, so my apologies if this post breaks any rules here, but does anyone have any idea how best to go about this?\nI am trying to solve the problem, but there is a logical error in my code, or rather I have not considered all the conditions, tell me how to find it.\nThe problem: An adventurer found himself in a dungeon full of treasures. However, before entering he activated a trap, which in t minutes will flood the entire room.\nYou are given an array of chests, where chests[i] is the number of treasures in the chest. The explorer can either pick up treasure i, taking one minute, or move to the next chest (i+1), which also takes one minute. He starts at position zero, it is not necessary to reach the end of the array.\nDetermine the maximum amount of treasure the hero can collect. by writing function getResult(chests,t):Integer\nInput:\nchests - number of treasures in chests, 2<length(chests)<20, 0<chests[i]<100\nt - number of minutes to flood, 0<t<20\nOutput:\nInteger - maximum number of treasures collected\nExample 1:\nchests = [1, 4, 2] t = 3\ngetResult(chests, t) = 5 // In the first minute the hero collected treasure from the first chest,\nin the second minute, he moved to the next chest, in the third minute, he gets the treasure from it\nExample 2:\nchests = [7, 8, 9] t = 2\ngetResult(chests, t) = 8 // In the first minute, the hero goes to the second chest and gets the treasure from it,\nthan taking the treasure in the first chest\nbelow are my reasons, and code.\nthe horizontal side of the matrix is moves and captures. They don't differ, because it takes the same amount of time to move or capture an item.\n1 unit per move or capture. The chests are arranged vertically, in order of increasing number of moves to the chest, so we can say\nIf n (number of chests)=4, the values in the chests are in order of distance of moves with the contents of 1, 4, 3, 5\nIt is possible to take any[j,i] chest in i moves. In 10 moves it is possible to take all items, the point is that the number of moves n for taking\nchest is a triangular number, i.e. the sum of the first n natural numbers. The formula for calculating a triangular number is: 1/2 * n * (n+1)\nWe build a matrix, put the inputs [1, 4, 3, 5] there, and place all the sums of those  there, too, as chests.\nIf one cell of the matrix contains more than 1 chest, we choose maximum.\nall combinations without regard to direction, (i.e. 2+3=3+2 without regard to such permutations)\nsummary matrix: chests and their combinations and steps to get\n```\n                1__2__3__4__5__6__7__8__9_10\nfirst chest     1, |  |  |  |  |  |  |  |  |\nsecond chest    0, 4, 5  |  |  |  |  |  |  |\nthird chest     0, 0, 3, 4, 7, 8, |  |  |  |\nfourth chest    0, 0, 0, 5, 6, 9,10, 9 12 13 \n```\n\nthere are combinations not included in the matrix,\ni.e. 4c+1c,2c>4c+3 (throw out the equal in moves option 4+3 chest, this is not the maximum)\nSo, form a one-dimensional array to select the best (maximal) combinations for each move\nmaxs_in_onerow=[1,4,5,5,7,9,10,9,12,13]\ncount sum of elements up to t-1\ncompare with the element with the number t\nANSWER: sumofchests(0,t-1)>maxs_in_onerow(t) ? return sumofchests(0,t-1) : maxs_in_onerow(t)\n// fill in the backpack, output the result\n\r\n\r\n```\nfunction getResult(chests, t) {\n  function transpose(a) { //helper func \n    // Calculate the width and height of the Array\n    let w = a.length || 0;\n    let h = a[0] instanceof Array ? a[0].length : 0;\n    // In case it is a zero matrix, no transpose routine needed.\n    if(h === 0 || w === 0) { return []; }\n    let i, j, t = [];\n    // Loop through every item in the outer array (height)\n    for(i=0; i<h; i++) {\n      // Insert a new row (array)\n      t[i] = [];\n      // Loop through every item per item in outer array (width)\n      for(j=0; j<w; j++) {\n        // Save transposed data.\n        t[i][j] = a[j][i];\n      }\n    }\n    return t;\n  }\n    function sumofsteps(c = chests) {\n    if (!Array.isArray(c)) c=Array.from({length:c})\n    return (c.length * (c.length + 1)) / 2;\n  }\n  function sumofchests(c = chests) {\n    return c.reduce((partialSum, a) => partialSum + a, 0);\n  }\n  const J = sumofsteps(chests);\n  const I =  (chests.length);\n  // console.log(`${chests.length},   ${J}, ${I}`);\n  //create a matrix with the size of the number of chests \n  //for as many moves as it takes to get all the chests=J\n  let matrix = Array.from({ length: I }, () => new Array(J).fill(0));\n  let maxs_in_onerow = [];\n // fill with values \n  let prevstepI = 0;\nchests.forEach((element,index) => {\nlet cchests=chests.slice(0,index)\n      //the side of the matrix, the moves for moving and taking chests, grows like half a square\n      for (let i = prevstepI; i <=cchests.length; i++) {\n        // matrix side, chests,\n        // nothing before the diagonal, skip\n        if (i<index) continue \n        if (i===index) {  //diagonal, minimum moves to take\n          prevstepI=i\n          matrix[index][i]=element\n        }\n        let _x=0\n          while (_x<i) {\n            matrix[_x].forEach((el , ind ) => { /* ... */\n              if  (el > 0) {matrix[index][i+ind+1]=element + el}\n            })\n            //create combinations of chests\n            _x+=1\n            if (_x===i) break\n           }\n         }\n});\n// form maxs_in_onerow=[1,4,5,5,7,9,10,9,12,13] \nlet jmartix=[]\njmartix=transpose(matrix)\n  for (let j = 0; j < J; j++) {\n   let cur=Math.max.apply(null, jmartix[j])  \n   maxs_in_onerow.push(cur);\n    }\n\n  // fill in the backpack, output the result\n  let res;\n  if (t === 1) res = chests[0];\n  if (t >= J) res = sumofchests(chests); \n  if (t<J) { \n    let res1=Math.max.apply(null,maxs_in_onerow.slice(0,t))\n    let res2=sumofchests(maxs_in_onerow.slice(0,t-1))\n    res = res1>res2 ? res1 : res2\n   }\n  \n // console.log(     `${matrix}, ${totalsteps()}, t: ${t}, maxs: ${maxs_in_onerow}, res: ${res}    `   );\n  return res;\n}\nconsole.log(` input: [1, 4, 2], 3 \\n response: ${getResult([1, 4, 2], 3)}`);\nconsole.log(` input: [7, 8, 9], 2 \\n response: ${getResult([7, 8, 9], 2)}`);```\n\r\n\r\n\r\n\n    ", "Answer": "\r\nMy sleep-deprived brain is not up trying to interpret your code or your reasoning.  Instead,  here's a simple recursive solution:\n\r\n\r\n```\nconst maxTreasure = ([c, ...cs], t) =>\n  t <= 0 || c == undefined\n    ? 0\n  : c == 0\n    ? maxTreasure (cs, t - 1)\n  : Math. max (c + maxTreasure ([0, ...cs], t - 1), maxTreasure (cs, t - 1) )\n  \n\nconsole .log (`maxTreasure ([1, 4, 2], 3) //=> ${maxTreasure ([1, 4, 2], 3)}`);\nconsole .log (`maxTreasure ([7, 8, 9], 2) //=> ${maxTreasure ([7, 8, 9], 2)}`);```\n\r\n\r\n\r\n\nWe check whether the time has run out or if there are no more chests found, and if so, simply return 0.  If the first chest is empty, we have no reasonable alternative than to move on to the next one, so we reduce the time by one and recur with the remaining chests.  Otherwise we have to choose the better of two possibilities: taking the current chests' treasures or moving on to the next one.  We use ```\nMath .max```\n to select one of these, and calculate them by recursion.  In one case, we include the current chest (```\nc```\n) and recur with a list of chests that replaces the current chest's value with zero.  In the other, we move on to the remaining chests.  In either case, we reduce the time by one.\nSo we have base cases, and three potential recursive calls.  In each of those calls, we're reducing the time by 1, so we will eventually reach the case ```\nt <= 0```\n.\nThat same foggy brains isn't going to do the analysis of time complexity here.  I wouldn't be surprised if this is horribly inefficient; it's likely of exponential complexity in the number of chests.  But it's simple and a good start at thinking of the problem logically.  If it turns out too inefficient for real world use (ha!) we can come back at a solution using bottom-up dynamic programming... and that may be what you're attempting.\nBut I would always start simply, and often recursion is simplest.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to understand leetcode 494 Target Sum ( knapsack problem ) fastest python code using bit operation\r\n                \r\nThe problem is described as follows\nhttps://leetcode.com/problems/target-sum/\n\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\nFind out how many ways to assign symbols to make sum of integers equal to target S.\nConstraints:\n\nThe length of the given array is positive and will not exceed 20.\nThe sum of elements in the given array will not exceed 1000.\nYour output answer is guaranteed to be fitted in a 32-bit integer.\n\n\nI find this submission in leetcode submission detail Accepted Solutions Runtime Distribution\n```\nclass Solution:\n    def findTargetSumWays(self, nums, S):\n        a = sum(nums) - S\n        if a < 0 or a%2==1: return 0 \n        S = [((1<<(i*21))+1) for i in nums]\n        return reduce(lambda p,i:(p*i)&(1<<((a//2+1)*21))-1,S,1)>>(21*a//2)\n```\n\nSimplify reduce, it becomes\n```\nclass Solution:\n    def findTargetSumWays(self, nums, S):\n        a = sum(nums) - S\n        if a < 0 or a%2==1: return 0 \n        auxarr = [((1<<(i*21))+1) for i in nums]\n        ret=1\n        for i in auxarr:\n            ret= (ret*i)&(1<<((a//2+1)*21))-1\n        return ret>>(21*a//2)\n```\n\nIt transforms the original problem into another problem that finds the number of selections that select some ```\nnums[i]```\n that their sum is ```\n(sum(nums)-S)/2```\n.\nI know how to solve such knapsack problems with dp, but I can't understand the above code, I am very curious how such code works, please help me.\n```\n# my dp code\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\n        S=sum(nums)-S\n        if S%2!=0 or S<0: return 0\n        S//=2\n        dp=[0]*(S+1)\n        dp[0]=1\n        for c in nums:\n            for j in range(S,c-1,-1):\n                dp[j]+=dp[j-c]\n        return dp[S]\n```\n\n    ", "Answer": "\r\nIt seems to use characteristics of a polynomial where you multiply terms formed of (B^n+1) where B is a power of 2 large enough to avoid overlapping.\nSo, let's say you have 3 numbers (x,y,z) to add, it will compute:\n```\n(B^x + 1)(B^y + 1)(B^z + 1)\n```\n\nThe exponents of these polynomials will add up in the result\n```\nB^(x+y+z) + B^(x+z) + B^(y+z) + B^z + B^(x+y) + B^x + B^y + 1\n```\n\nSo, if any combination of exponent (i.e. numbers) adds up to the same total, the number of times B^total occurs will be the number of ways to obtain that total.  Leveraging this characteristic of polynomials, we will find ways*B^total in the result. If the number of ways does not overlap with the value of B^(total+1), it can be extracted using masks and integer divisions.\nFor example, given 4 numbers h,i,j,k, the products will produce the sum of B raised to powers corresponding to every combination of 1 up to 4 of the numbers added together.   So, if we are looking for a total of T, and h+i and j+k equal T.  Then the product will contain 2*B^T formed by B^(h+i) + B^(j+k).  This corresponds to two ways to form the sum T.\nGiven that there are 2 possibility for each number (+ or -), there is a maximum of 2^20 possible ways to combine them. To make sure that any sum of B^x does not overlap with B^(x+1), the value of 2^21 is chosen for B.\nThis is why the offset array (variable name S is a really poor choice here) is formed of (B^n+1) for each n in nums, where B is 2^21, so (2^21^n+1) ... (2^(21n)+1) ... ```\n(1<<(21*n))+1```\n\nTo be able to use the polynomial approach, the problem needs to be converted to an Absence/Presence problem. This is done by reasoning that there has to be a combination of numbers that produces a zero sum by cancelling each other out, leaving the rest to be positive and add up to S.  So, if we remove S from the total of numbers, there will be a combination that adds up to half of what remains (```\na//2```\n). This will be the total we will be looking for.\nThe ```\nreduce```\n function implements the polynomial product and applies a mask (```\n(1<<((a//2+1)*21))-1```\n) to cut off any power of B that is beyond B^(a/2).  The final result cuts off the part below B^(a/2) by shifting bits.\nThis results in the multiple of B^(a/2) which corresponds to the number of ways to produce the sum of exponents (i.e the sum of numbers).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recursive 0-1 knapsack\r\n                \r\nHere I have two functions for the recursive knapsack problem while knapsack() gives the correct output (i.e 220) but knapsack1() gives wrong value (i.e 60) .Can anyone please explain why?\n\n```\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\n long knapsack1(long w,long wt[],long val[],long n)\n    {\n        if(n==0||w==0)\n        {\n            return 0;\n        }\n        if (wt[n] > w)\n        {\n        n--;\n        }\n        else\n        {\n            return max(knapsack1(w,wt,val,n-1),val[n]+knapsack1(w-wt[n],wt,val,n-1));\n        }\n    }\n\n long knapsack(long w,long wt[],long val[],long n)\n    {\n        if(n==0||w==0)\n        {\n            return 0;\n        }\n        if (wt[n] > w)\n        { \n       return knapsack(w, wt, val, n-1);\n        }\n        else\n        {\n            return max(knapsack(w,wt,val,n-1),val[n]+knapsack(w-wt[n],wt,val,n-1));\n        }\n    }\nint main()\n{\n   long val[] = {60, 100, 120};\n    long wt[] = {10, 20, 30};\n    long  w = 50;\n    long n = sizeof(val)/sizeof(val[0]);\n    printf(\"%d\", knapsack(w, wt, val, n));\n    printf(\"%d\", knapsack1(w, wt, val, n));\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nTry compiling it with warnings enabled… the ```\nif```\n-branch in ```\nknapsack1```\n does not return a value, and the behavior is undefined.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recursive solution of unbounded knapsack using logic of 0/1 knapsack\r\n                \r\nOut of all the DP solutions I have checked out for 0/1 knapsack and unbounded knapsack, solution approaches are always defined like this :\n\n0/1 knapsack : Maximise total value by either taking n-th item, or excluding n-th item. For example, 0/1 knapsack\n\nunbounded knapsack : Maximise total value by considering n-th item as the last picked item, or (n-1) item as last picked one etc, etc. For example, unbounded knapsack\n\nBut unbounded knapsack can also be solved using logic of 0/1 knapsack with a minor tweak. What I mean is, that for 0/1 knapsack, we do the following (using the code from first link):\n\n```\nreturn max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\n            knapSack(W, wt, val, n-1)\n          );\n```\n\n\nNotice how in the case when we are including ```\nwt[n-1]```\n we are reducing the size of array by 1. This implies that ```\nwt[n-1]```\n is now exhausted and hence, cannot be used again. But if in unbounded case, we don't reduce the array size by 1 (which would mean ```\nwt[n-1]```\n can be used again), following slightly modified recurrence relation works fine:\n\n```\nreturn max( val[n-1] + knapSack(W-wt[n-1], wt, val, n),\n            knapSack(W, wt, val, n-1)\n          );\n```\n\n\nWhy is this approach for unbounded knapsack never mentioned anywhere then? Actually here it specifically says, we cannot use same logic as 0/1 knapsack for the unbounded one. Excerpt from that link :\n\n```\nObservation:\nI can never exhaust any item because there are an unbounded supply of items.\nTherefore:\nThe technique used in the 0,1 knapsack problem cannot be used.\n```\n\n\nBut I am not able to disprove that my above mentioned solution won't work. This idea came from coin-change problem, where you have to count number of ways to make change for a given amount, assuming infinite supply of coins.\n\nSo my question is why the approach that I have proposed here, never used for unbounded knapsack or at least never mentioned anywhere? Can anyone please help me in proving or disproving this approach? Thanks in advance!\n    ", "Answer": "\r\nIn every recursive call, the function iterate through all the available weights to see if it can be included, if so its value is accumulated in max_val for current recursive call. At the end of the call, if we were able to get a value, then it returns a flag telling that a solution was found and set the maxSoFar to max_value till now.\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\n\n// Returns the maximum value with knapsack of\n// W capacity\nint unboundedKnapsack(int W, int n, int val[], int wt[], int &maxValue)\n{\n    // dp[i] is going to store maximum value\n    // with knapsack capacity i.\n    if( W == 0)\n        return true;\n    int maxSoFar = INT_MIN;\n    bool foundASeries = false;\n    for(int i = 0; i < n; i++)\n    {\n        if(W >= wt[i])\n        {\n            maxValue  = 0;\n            if(unboundedKnapsack(W-wt[i], n, val, wt, maxValue))\n            {\n                foundASeries = true;\n                maxSoFar = max(maxSoFar, maxValue + val[i]);\n            }\n        }\n    }\n    maxValue = maxSoFar;\n    return foundASeries;\n}\n\n// Driver program\nint main()\n{\n    int W = 8;\n    int val[] = {10, 40, 50, 70};\n    int wt[] = {1, 3, 4, 5};\n    int maxValue = 0;\n    int n = sizeof(val)/sizeof(val[0]);\n\n    cout << unboundedKnapsack(W, n, val, wt, maxValue)<<endl;\n    cout<< \"max value is \"<<maxValue;\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Set min and max constraints on the number of items in the Knapsack problem\r\n                \r\nHow do I set a constraint on the minimum and maximum (or just a fixed constant) amount of items in the knapsack using the google or tools solver?\nI would also happily take any suggestions for solutions that do not use the Google ORTools solver...\n```\nfrom ortools.algorithms import pywrapknapsack_solver\nsolver = pywrapknapsack_solver.KnapsackSolver(\n    pywrapknapsack_solver.KnapsackSolver.\n    KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER, 'KnapsackExample')\n\nvalues = [10, 15,1, 5, 7]\nweights = [ [4, 5, 1, 2, 3],\n            [1, 1, 1, 1, 1]]\ncapacities = [ 6, 4 ]\nsolver = pywrapknapsack_solver.KnapsackSolver(\n        pywrapknapsack_solver.KnapsackSolver\n        .KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,\n        'Multi-dimensional solver')\nsolver.Init(values, weights, capacities)\ncomputed_value = solver.Solve()\npacked_items = []\npacked_weights = []\ntotal_weight = 0\nprint('Total value =', computed_value)\nfor i in range(len(values)):\n    if solver.BestSolutionContains(i):\n        packed_items.append(i)\n        packed_weights.append(weights[0][i])\n        total_weight += weights[0][i]\nprint('Total weight:', total_weight)\nprint('Packed items:', packed_items)\nprint('Packed_weights:', packed_weights)\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why am I getting \"unknown signal 11\" with this knapsack problem solver?\r\n                \r\nTask\nGiven n gold bars, find the maximum weight of gold that fits into bag of capacity W\nInput\nfirst line contains the capacity W of the knapsack and the number n of bars of gold. The next line contains n integers\nOutput\nThe max weight of gold that fits into a knapsack of capacity W.\nConstraints\n1 <= W <= 10000; 1<= n <= 300; 0 <= w0, w1, w2, ... , w(n-1) <= 100000\nCode\n```\n#include <iostream>\n#include <vector>\nusing std::vector;\n\nint optimal_weight(int W, vector<int> w) {\n  int n = w.size() + 1;\n  int wt = W + 1;\n  int array [n][wt];\n  int val = 0;\n\n  for(int i = 0; i < wt; i++) array [0][i] = 0;\n  for(int i = 0; i < n; i++) array [i][0] = 0;\n\n  for(int i = 1; i< n; i++) {\n    for(int j = 1; j < wt; j++ ){\n      array[i][j] = array [i-1][j];\n      if (w[i-1] <= j) {\n        val = array[i-1][j - w[i-1]] + w[i-1];\n        if(array[i][j] < val) array[i][j] = val;\n      }\n    }\n  }\n\n  //printing the grid\n  // for(int i=0; i < n; i++) {\n  //   for(int j=0; j < wt; j++) {\n  //     cout<<array[i][j]<<\" \";\n  //   }\n  //   cout<<endl;\n  // }\n  // cout<<endl;\n\n  return array [n-1][wt-1];\n}\n\nint main() {\n  int n, W;\n  std::cin >> W >> n;\n  vector<int> w(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> w[i];\n  }\n  std::cout << optimal_weight(W, w) << '\\n';\n}\n```\n\nThe above code works fine for smaller inputs, but gives an ```\nunknown signal 11```\n error on the platform I wish to submit to. My best guess is of a possible segmentation fault, but I have been unable to debug it since quite some time now. Any help is much appreciated!\n    ", "Answer": "\r\nFirst note that your code doesn't work. That is, it doesn't compile when you adhere strictly to the C++ language standard, as C++ does not support variable-length arrays. (as noted by @Evg in a comment; some compilers offer this as an extension.)\n\nThe main reason for excluding those from C++ is probably why you're experiencing issues for larger problem sizes: the danger of stack overflows, the namesake of this website  (as noted by @huseyinturgulbuyukisik in a comment). Variable-length arrays are allocated on the stack, whose size is limited. When you exceed it, you might attempt to write to a segment of memory that is not allocated to your process, triggering Linux signal 11, also known as SIGSEGV - the segmentation violation signal.\n\nInstead of stack-based allocation, you should allocate your memory on the heap. A straightforward way to do so would be using the ```\nstd::vector```\n container (whose default allocator does indeed allocate on the heap). Thus, you would write:\n\n```\n std::vector<int> vec(n * wt);\n```\n\n\nand instead of ```\narray[i][j]```\n you'd use ```\nvec[i * wt + j]```\n.\n\nNow, this is not as convenient as using ```\narray[x][y]```\n; for the extra convenience you can, for example, write a helper lambda, to access individual elements, e.g.\n\n```\nauto array_element = [&vec, wt](int x, int y) { return vec[x * wt + y]; }\n```\n\n\nwith this lambda function available, you can now write statements such as  ```\narray_element(i,j) = array_element(i-1,j);```\n\n\nor use a multi-dimensional container (```\nstd::vector<std::vector<int>>```\n would work but it's ugly and wasteful IMHO; unfortunately, the standard library doesn't have a single-allocation multi-dimensional equivalent of that).\n\n\n\nOther suggestions, not regarding a solution to your signal 11 issue:\n\n\nUse more descriptive variable names, e.g. ```\nweight```\n instead of ```\nwt```\n and ```\ncapacity```\n instead of ```\nW```\n. I'd also consider```\nsub_solutions_table```\n or ```\nsolutions_table```\n instead of ```\narray```\n, and might also rename ```\ni```\n and ```\nj```\n according to the semantics of the dynamic solution table.\nYou never actually need more than 2 rows of the solutions table; why not just allocate one row for the current iteration and one row for the previous iteration, and have appropriate pointers switch between them?\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack Problem with Dynamic Programming\r\n                \r\nThis is my attempt at the problem asked in this thread. When I try to run it with input ```\negg_weights = (1,5,10,25)```\n and ```\nn = 99```\n, it seems to run into an infinite loop. The code seems to give the correct answer for smaller ```\nn```\n, albeit very slowly. What went wrong here?\n```\ndef dp_make_weight(egg_weights, target_weight, memo = {}):\n    if target_weight < 0:\n        return float('inf')\n    elif target_weight == 0:\n        return 0\n    elif target_weight > 0:\n        try:\n            return memo[target_weight]\n        except:\n            memo[target_weight] = float('inf')\n            for weight in egg_weights:\n                result = dp_make_weight(egg_weights, target_weight - weight, memo = {})\n                if result < memo[target_weight]:\n                    memo[target_weight] = result + 1\n        return result + 1\n```\n\nHere's the code that was provided for testing purpose.\n```\nif __name__ == '__main__':\n    egg_weights = (1, 5, 10, 25)\n    n = 99\n    print(\"Egg weights = (1, 5, 10, 25)\")\n    print(\"n = 99\")\n    print(\"Expected ouput: 9 (3 * 25 + 2 * 10 + 4 * 1 = 99)\")\n    print(\"Actual output:\", dp_make_weight(egg_weights, n))\n    print()\n```\n\n    ", "Answer": "\r\nIf you are planning to call ```\ndp_make_weight```\n for different egg weight lists, then the default memo argument should be handled as follows. Also, read my comments in the code:\n```\ndef dp_make_weight(egg_weights, target_weight, memo=None):\n    if memo is None:\n        memo = {}\n\n    infinity = float('inf')\n\n    if target_weight < 0:\n        return float('inf')\n    elif target_weight == 0:\n        return 0\n    else: # target_weight must be > 0\n        if target_weight in memo:\n            return memo[target_weight]\n        result = infinity\n        for weight in egg_weights:\n            # Only update result when dp_make_weight returns a value smaller than\n            # the current result value. Also note that the current value of memo\n            # is what is being passed and not a new, empty dict:\n            new_result = dp_make_weight(egg_weights, target_weight - weight, memo)\n            if new_result < result:\n                result = new_result\n        result += 1\n        memo[target_weight] = result\n        return result\n\nif __name__ == '__main__':\n    egg_weights = (1, 5, 10, 25)\n    n = 99\n    print(\"Egg weights =\", egg_weights)\n    print(\"n =\", n)\n    print(\"Expected ouput: 9 (3 * 25 + 2 * 10 + 4 * 1 = 99)\")\n    print(\"Actual output:\", dp_make_weight(egg_weights, n))\n\n    print()\n\n    egg_weights = (1, 6, 9, 12, 13, 15)\n    n = 724\n    print(\"Egg weights =\", egg_weights)\n    print(\"n =\", n)\n    print(\"Expected ouput: 49\")\n    print(\"Actual output:\", dp_make_weight(egg_weights, n))\n```\n\nPrints:\n```\nEgg weights = (1, 5, 10, 25)\nn = 99\nExpected ouput: 9 (3 * 25 + 2 * 10 + 4 * 1 = 99)\nActual output: 9\n\nEgg weights = (1, 6, 9, 12, 13, 15)\nn = 724\nExpected ouput: 49\nActual output: 49\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack for table\r\n                \r\nI have a problem that I can't solve. There is this table:\n\n\n\nI have to optimally allocate 1 million dollars among the five products. I think it looks like knapsack problem but I am not sure. If I want to solve this for what should I look? If it is knapsack how should I change an original knapsack solution to fit mine problem?\n    ", "Answer": "\r\nTo my understanding, the problem described can be solved via dynamic programming in a way very similar to the 0/1 Knapsack Problem. However, the recurrence relation has to be adapted. Instead of considering 2 cases at each stage (namely discarding or taking the respective item), 6 cases have to be considered, which correspond to discarding the item (not investing in the product), taking choice 1 (using investment 1) to taking choice 10 (using investment 10). Although each item will have 11 profit values (for each of the choices), the state space remains two-dimensional (one axis for the minimum weight, i.e. the invested amount, and one axis for the enumeration of items). In more detail, a formulation in pseudocode could be as follows. For ease of presentaion, access outside of the state space is supposed to yield a value of positive infinity.\n\n```\n// Input:\n// Values (stored in array v_1,...,v_10)\n// Weights (stored in arrays w_1,...w_10)\n// Number of distinct items (n)\n// Knapsack capacity (W)\n\nfor j from 0 to W do:\n    m[0, j] := 0\n\nfor i from 1 to n do:\n    for j from 0 to W do:\n        m[i, j] := max(m[i-1, j],\n                       m[i-1, j-w_1[i-1]] + v_1[i-1],\n                       ...,\n                       m[i-1, j-w_10[i-1]] + v_10[i-1])\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Wrong answer with user input, correct answer when input entered manually in code (KNAPSACK PROBLEM)\r\n                \r\nI'm new to c++, just moved from python and gave a try to dynamic programming.\nIve written a piece of code for the basic \"0-1 knapsack\" problem, which is supposed to test my basic understanding of dynamic programming.\nI think I got my algorithm right, but for some reason, when i ask the user to enter input for two of the arrays, I get a wrong answer, but when i enter  the values of these arrays within the code, I get the correct answer, everytime.\nWhat went wrong/is wrong?\nEDIT: dp is a 1001*10001 2d vector filled with -1\nMy solver function:\n```\nint knap(int n, int wt[], int price[], int W){          // n = number of items; size of array, w = wt available in knapsack\n                                                        // wt stores weight if items, price:price\n\n\n\n\n        if(dp[n][W] != -1){\n            return dp[n][W];\n        }\n\n        else{\n\n        // base case\n        if(n == 0 || W == 0){\n            return 0;\n        }\n        if(wt[n-1] <= W){           // condition for adding item to knapsack (wt of item must be less than space remaining in knapsack)\n\n            return dp[n][W] = max((price[n-1] + knap(n-1, wt, price, W - wt[n-1])), knap(n-1, wt, price, W)) ;  // max wrt recursion from previous element\n        }\n        else{\n            return dp[n][W] = knap(n-1, wt, price, W);\n        }\n\n}\n}\n```\n\nMy main function:\n```\nint main(){\n    int n, W;\n    cin>>n>>W;\n    /*int b[n], b[n];\n    \n    for(int i = 0; i<n; i++)\n        cin>>a[i];\n\n    for(int j = 0; j<n; j++)\n        cin>>b[j];\n    \n    */\n    int a[] = { 1 ,2 ,10 ,6 ,5 ,1 ,7 ,4 ,10 ,4}, b[] = { 6, 3, 8, 1, 7, 3, 8, 6, 5, 6};\n    cout<<knap(n, a, b, W);\n}\n```\n\nthe answer is supposed to be 21, which i get when a[] and b[] have been defined, but when I make the user input a[] and b[] (as written in the commented region of the code) value, I get the wrong answer.\nexample input test cases with their outputs:\n```\nInput:\n10 10\n1 2 10 6 5 1 7 4 10 4\n6 3 8 1 7 3 8 6 5 6\noutput:\n21\n\nInput:\n4 10\n4 8 5 3\n5 12 8 1\n\nOutput:\n13\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem with repeating components for lowest value, to fill (or slightly over) in Python\r\n                \r\nI'm actually trying to find the lowest cost to supply custom medication doses from vials - however while researching, I found the knapsack problem is the best way to describe the issue, in  way that is currently understood.\n\nBreakdown of problem\n*A dose is prescribed based on clinical need.\n*The vials commercially available to make up the dose (and their respective dose) are then considered. The same size vial can be used more than once.\n*The vial / size combination may provide excess (i.e. provide a higher dose than is required) - as that combination works out cheaper than meeting the dose itself, or providing a smaller overage. Therefore overage or wastage is allowed provided the combinations yields the prescribed dose, even if there is wastage.\n*The output should display the qty/ vial combination used and the cost of that combinations.\n\nExample of vials available are 50mg costs $15, 100mg costs $32 and 200mg costs $64\n\nLets say that a dose of 220mg is prescribed. Some of the possible options to make up the dose are as follows (remembering that the amount of wastage is not relevant provided it provides the cheapest option to make up the dose required.\n\n```\n5 x 50mg = 250mg (30mg over) = $75\n3 x 50mg + 1 x 100mg = 250mg (30mg over) = $77\n2 x 100mg + 1 x 200mg = 400mg (180mg over) = $128\n1 x 50mg + 1 x 200mg = 250mg (30mg over) = $79\n3 x 100mg = 300mg (80mg over) = $96\n```\n\n\nTherefore, we can see that the cheapest option is row1 5x 50mg at $75\n\nIf anyone could point me in the right direction then I'd be grateful!\n\nThe code below only uses each component once - but I'm lost on how to modify to get it to recycle them.\n\n```\nitems = [(\"ITEM01\", 100, 10000), (\"ITEM02\", 24, 576), \\\n    (\"ITEM03\", 24, 576), (\"ITEM04\", 51, 2500), (\"ITEM05\", 155, 25)]\nS = sum([item[1] for item in items])    #sums all the weights in the list of items\ndp = [None for i in range(S + 1)]       #list within which cycles through each integer of weights creates a list of \"None,\"\ndp[0] = []                              #removes the first none from the list\n\nfor item in items:                      #for each element in the list of available vials\n    for i in range(S, -1, -1):          #counts down from sum of all weights of available vial sizes DOWN TO zero (0) \n        if dp[i] is not None and i + item[1] <= S and \\     \n    (                                                               #if the long list of Nones - does not read None\n        dp[i + item[1]] is None\n        or\n        sum(set_item[2] for set_item in dp[i]) + item[2]\n            > sum(set_item[2] for set_item in dp[i + item[1]])\n    ):\n            dp[i + item[1]] = dp[i] + [item]\n\ndesired_sum = 200                   #desired weight \ni = j = desired_sum                 # desired sum becomes i and it also becomes j\n\nwhile i >= 0 and j <= S:            #while desired sum(i) is over 0 and less then sum of weight of all vials in the list.\n    if dp[i] is not None:           #if the none list entry at that point is NOT none\n        print (dp[i])               #print element from that list that isn't 'None'\n        break\n    elif dp[j] is not None:         #if None list at desired_weight index is not None\n        print (dp[j])               #print the element that isn't none\n        break\n    else:\n        i -= 1                      #else diverge i and j which are originally the same\n        j += 1\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Algorithm with a O(2^n*n)\r\n                \r\nWhich algorithm for the knapsack problem has a O(2^n*n) complexity?\n\nI've been asked to implement a solution for the knapsack problem. \n\nI'm familiar with programming but not with asymptotic notation.  \n\nCan anybody advise me on which algorithm has a O(2^n*n) complexity? \n    ", "Answer": "\r\nO(n * 2^n) is the performance of the brute force algorithm (= just try all combinations), see http://en.wikipedia.org/wiki/Knapsack_problem#Meet-in-the-Middle_Algorithm\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Parabolic knapsack\r\n                \r\nLets say I have a parabola. Now I also have a bunch of sticks that are all of the same width (yes my drawing skills are amazing!).  How can I stack these sticks within the parabola such that I am minimizing the space it uses as much as possible?  I believe that this falls under the category of Knapsack problems,  but this Wikipedia page doesn't appear to bring me closer to a real world solution.  Is this a NP-Hard problem?   \n\nIn this problem we are trying to minimize the amount of area consumed (eg: Integral),  which includes vertical area.\n\n\n    ", "Answer": "\r\nI cooked up a solution in JavaScript using processing.js and HTML5 canvas.  \n\nThis project should be a good starting point if you want to create your own solution. I added two algorithms.  One that sorts the input blocks from largest to smallest and another that shuffles the list randomly.  Each item is then attempted to be placed in the bucket starting from the bottom (smallest bucket) and moving up until it has enough space to fit.  \n\nDepending on the type of input the sort algorithm can give good results in O(n^2). Here's an example of the sorted output.\n\n\n\nHere's the insert in order algorithm.\n\n```\nfunction solve(buckets, input) {\n  var buckets_length = buckets.length,\n      results = [];\n\n  for (var b = 0; b < buckets_length; b++) {\n    results[b] = [];\n  }\n\n  input.sort(function(a, b) {return b - a});\n\n  input.forEach(function(blockSize) {\n    var b = buckets_length - 1;\n    while (b > 0) {\n      if (blockSize <= buckets[b]) {\n        results[b].push(blockSize);\n        buckets[b] -= blockSize;\n        break;\n      }\n      b--;\n    }\n  });\n\n  return results;\n}\n```\n\n\nProject on github - https://github.com/gradbot/Parabolic-Knapsack\n\nIt's a public repo so feel free to branch and add other algorithms.  I'll probably add more in the future as it's an interesting problem.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to print element selected in 0/1 knapsack problem using Recurssion\r\n                \r\nI have a code  for 0/1 Knapsack with Recursion. I want to print selected element along with profit. \nCode is giving only profit. \nAny help will be appreciated.\n\n```\n#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\nint knapSack( int weight, int wt[], int val[], int n)\n{\n    if( weight <= 0 )\n       return 0;\n\n    if( n < 0 )\n      return 0;\n\n    // nth element is excluded  \n    int exclude = knapSack(weight, wt, val, n-1);\n\n    // nth element is included\n    int include = knapSack(weight - wt[n], wt, val, n-1) + val[n];\n\n    return  max( include, exclude);\n}\n\nint main()  \n{  \n    int val[] = {60, 100, 120};  \n    int wt[] = {10, 20, 30};  \n    int W = 50; \n\n    int n = sizeof(val)/sizeof(val[0]);  \n    cout<<knapSack(W, wt, val, n-1); \n\n    return 0;  \n}\n```\n\n    ", "Answer": "\r\nYou can use a vector to save the collected items\n\n```\nint knapSack( int weight, int wt[], int val[], int n, vector<int>& items) \n{\n    if( n < 0 ) {\n        return 0;\n    }\n\n    vector<int> tmp1 = items;\n    vector<int> tmp2 = items;\n    // nth element is excluded \n    int exclude = knapSack(weight, wt, val, n-1, tmp1);\n\n    // nth element is included\n    int include = 0;\n    if (weight >= wt[n]) {\n        tmp2.push_back(val[n]);\n        include = knapSack(weight - wt[n], wt, val, n-1, tmp2) + val[n];\n    }\n\n    items = (include >= exclude) ? tmp2 : tmp1;\n    return  max( include, exclude);\n}\n\nint main()  \n{  \n    int val[] = {60, 100, 120};  \n    int wt[] = {10, 20, 30};  \n    int W = 50; \n\n    vector<int> items;\n    int n = sizeof(val)/sizeof(val[0]);\n    int profit = knapSack(W, wt, val, n-1, items);\n\n    cout << \"profit: \" << profit << endl;\n    cout << \"items: \";\n    for (auto it = items.begin(); it != items.end(); it++) {\n        cout << *it << \" \";\n    } \n\n    return 0;  \n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recursive CTE in PostgreSQL for knapsack problem\r\n                \r\nI have a dataset with 3 columns:\n\n\n\n\nItem_id\nSourced_from\nCost\n\n\n\n\n1\nLocal\n15\n\n\n2\nLocal\n10\n\n\n3\nLocal\n20\n\n\n4\nInternational\n60\n\n\n\n\nI am trying to write a query in PostgreSQL to fetch total of local and international items, customer can buy  within the cash limit. For a cash limit 50, this is the output I  am expecting:\n\n\n\n\nLocal\nInternational\n\n\n\n\n3\n0\n\n\n\n\nI have a pretty basic knowledge of PostgreSQL, and after googling it seems like this could be solved with recursive CTE, I am unable to figure out how should I select my source seed/anchor point in this scenario.\nAny ideas, how should I approach this?\n    ", "Answer": "\r\nNot with a recursive CTE, but still works:\nDDL/DML:\n```\ncreate table T\n(\n    id   integer primary key generated by default AS IDENTITY,\n    kind text    not null,\n    cost integer not null\n);\n\ninsert into T(kind, cost)\nvalues ('local', 15),\n       ('local', 10),\n       ('local', 20),\n       ('international', 60);\n```\n\n```\n-- 4. This outer CTE and the following self-join is only necessary in order to display the rows that have a count() of 0\nwith sub as\n         (\n             -- 3. find the total cost of buying this row + all previous rows, grouped by its kind\n             select X.kind, sum(X.cost) as cost, X.rn\n             from (\n                      with cte as (\n                          -- 1. assign an increasing row number on each row from the table ordered by its cost\n                          select *, row_number() over (order by T.cost asc, T.kind) as rn\n                          from T\n                      )\n                      -- 2. self-join the CTE on each row with the same kind, but join it only with the rows that have a row number less than or equal to the current row number \n                      select A.id, A.kind, A.cost, B.rn\n                      from cte as A\n                               join cte as B on A.kind = B.kind and A.rn <= B.rn\n                  ) as X\n             group by X.kind, X.rn\n         )\n\nselect M.kind, count(N.*)\nfrom sub as M -- 5. count only the amount of goods that fit in out budget (i.e. 50)\n         left outer join sub as N on M.rn = N.rn and N.cost <= 50\ngroup by M.kind\n;\n```\n\nOutput (db-fiddle):\n```\n+-------------+-----+\n|kind         |count|\n+-------------+-----+\n|local        |3    |\n|international|0    |\n+-------------+-----+\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack - Unable To Understand a Section While Programming\r\n                \r\nRecently, I am trying to study and implement the Knapsack problem (That I studied few years earlier). So I can understand and have the idea of optimal solution like if the knapsack value is 100 and there are certain weights like 40, 60, 100. Then the optimal solution would be 100 to fill in or equivalent of knapsack value. I stuck in one section of the programming and unable to figure out how this is actually working though tried with recursion using a tutorial. Let me comment out that I've understood: \n\n```\n/*A function or method to determine the max number*/\nint max(int a, int b)\n{\n    return (a > b) ? a : b;\n}\n\n/*Knapsack function or method with parameters knapsack value - w, weights, amounts, number of elements*/\nint Knapsack(int w, int weight[], int amt[], int n)\n{\n    if(n == 0 || w == 0)\n    {\n        return 0;\n    }\n\n    if(weight[n - 1] > w) /*If the nth value is greater than the knapsack value, then there will no optimal solution*/\n    {\n        return Knapsack(w, weight, amt, n - 1);\n    }\n    else\n    {\n        return max(amt[n - 1] + Knapsack(w - weight[n - 1], weight, amt, n - 1), Knapsack(w, weight, amt, n - 1)); /*Stuck in this section - It returns perfect solution but unable to understand how it's working. Debugged not getting the answer as expected*/\n    }\n}\n\nint main(void)\n{\n    int amt[3], weight[3], w, i, elements, n;\n\n    /*printf(\"Enter number of elements: \");\n    scanf(\"%d\", &elements);*/\n\n    printf(\"Enter the weight and amount individually up to 3: \");\n\n    for(i = 0; i < 3; i++)\n    {\n        scanf(\"%d %d\", &weight[i], &amt[i]);\n    }\n\n    printf(\"\\nEnter the knapsack value: \");\n    scanf(\"%d\", &w);\n\n    n = sizeof(amt) / sizeof(amt[0]);\n\n    printf(\"%d %d\", Knapsack(w, weight, amt, n), n);\n\n    return 0;\n}\n```\n\n\nI would appreciate if someone has the time to explain in brief the working procedure in the programming that I am unable to understand. Even trying to use Dynamic programming for it. But it seems quiet complex. Is this a perfect solution to study knapsack problem:\n\nKnapsack Problem\n    ", "Answer": "\r\nI have tried to draw a tree structure for the order of calls that would take place once User has Entered all the Weight, Amount, w values.\n\nHere in my example, \nFollowing are the values for variables,\n\n```\nWeight[0]=18  Amount[0]=17```\n \n  ```\nWeight[1]=14  Amount[1]=15```\n \n  ```\nWeight[2]=15  Amount[2]=10```\n \n\n```\nW=20(knapsack capacity)```\n\n```\nHere value of n according to program would be 3.```\n\n\nFor the First call from main,\nValue will be K(w, W[], a[], n)====>K(20,w[], a[], 3)\nthen ```\na[n-1]==>a[2]==>10```\n\n```\nw[n-1]==>w[2]==>15```\n and so on... values change \n\nNote : Keep in Mind the Value Changes after function is called each time.\nAlso keep a tab on IF conditions.\n\nPlease ignore handwriting. Thanks.\n\n\n\nWhen we are dealing with Recursion problem, We need to remember that we are dealing with STACK and therefore LIFO( Last In First Out). \n\nIn case of recursive functions, the function that is called Last will return result first and function called First will return result at last. Your problem does that if you see tree structure you would understand it. Thanks.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving Knapsack using Dyanamic Programming\r\n                \r\nI was implementing the snippet of Knapsack problem using the algorithm that i found in this link Knapsack Problem\n\nI have also attached the snippet of the algorithm here too. \n\nI have written following python snippet for the algorithm. Here it is:\n\n```\ndef knapsack(v,w,n,W):\n    V = [[None for x in range(W+1)] for x in range(len(v)+1)]\n\n    for wy in range(W+1):\n        V[0][wy] = 0\n\n    for i in range(1,n+1):\n        for wx in range(W+1):\n            # print i,wx\n            if w[i] <= wx:\n\n                V[i][wx] = max(V[i-1][wx], v[i]+V[i-1][wx-w[i]])\n            else:\n                V[i][wx] = V[i-1][wx]\n    return V[n][W]\n\nprint knapsack(v = [10,40,30,50],w=[5,4,6,3],n=4,W=10)\n```\n\n\nI am supposed to get output 90 at position [4,9] . What am I doing wrong here?\n    ", "Answer": "\r\nI am not sure but i think the error is \n\n\nElements ```\nv and w```\n are 0-based index(0 to n-1)\nYou are iterating in the range ```\n1 to n```\n\nSo ```\nw[n]```\n or ```\nv[n]```\n will throw ```\nIndexError```\n\n\n\nUpdated CODE:\n\n```\ndef knapsack(v,w,n,W):\n    V = [[None for x in range(W+1)] for x in range(len(v)+1)]\n\n    for wy in range(W+1):\n        V[0][wy] = 0\n\n    for i in range(1,n+1):\n        for wx in range(W+1):\n            # print i,wx\n            if w[i-1] <= wx:\n\n                V[i][wx] = max(V[i-1][wx], v[i-1]+V[i-1][wx-w[i-1]])\n            else:\n                V[i][wx] = V[i-1][wx]\n    return V[n][W]\n\nprint knapsack(v = [10,40,30,50],w=[5,4,6,3],n=4,W=10)\n```\n\n\nThe output is now ```\n90```\n.\n\n\n\nCheck the results at Ideone\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to optimize solution to the 0/1 knapsack?\r\n                \r\nThe standard knapsack problem solution is ```\nO(nW)```\n where we will increment the weight +1 at a time to get to the solution.\n\nIs there any approach to the knapsack problem that does not require incrementing weight +1 at a time.\n\ne.g. One way that I can think of is to divide all the numbers by its common denominator \n\n```\nCapacity = 100 weights = [5, 10, 20] -> Capacity = 20 weights = [1, 2, 4]```\n\n    ", "Answer": "\r\nIncrementing the weight in steps of 1 is only necessary for a bottom-up dynamic programming implementation. If you implement it top-down, you can just do a recursive call while subtracting the weight of the current item from the remaining capacity.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack with additional restriction (colored items)?\r\n                \r\nI'm working on this problem mostly out of curiosity in my downtime at work.\n\nImagine the normal 0-1 Knapsack problem, except all the items are either yellow, red, blue, or green, and due to your OCD you must have exactly 2 items of each color in your knapsack.  So instead of the normal items each item has 3 properties: Weight, Value, Color.\n\nIs this even still a knapsack problem, or is it better define in some other way?  \n    ", "Answer": "\r\nI'll use ```\nnCk```\n to represent \"n choose k\" for ease of typing. Since you must have exactly 2 items of each color, the number of feasible solutions is O(```\nnC2```\n), which is O(```\nn^2```\n). Each solution can be evaluated in polynomial time, so the problem is solvable in polynomial time as well. In other words, it's far simpler than a regular knapsack problem.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Unbounded Knapsack to minimize the total value\r\n                \r\nI am trying to find a solution to the minimum knapsack problem (least profitable set of items such that the total weight of the selected items is at least the capacity C.)\n\nI am trying to modify the following maximum knapsack problem to get the min version without success.\n\nCould anyone help to solve this problem?\n\n```\npublic class UnboundedKnapSack {\npublic static int fillTable(int capacity, int[] weight, int[] value) {\n    int i, j;\n    int[][] maxValue = new int[value.length][capacity + 1];\n\n    for (j = 0; j < weight[0]; j++) {\n        maxValue[0][j] = 0;\n    }\n    for (j = 0; j <= capacity; j++) {\n        maxValue[0][j] = value[0] * (j / weight[0]);\n    }\n\n    for (i = 1; i < value.length; i++) {\n        for (j = 0; j < weight[i]; j++) {\n            maxValue[i][j] = maxValue[i - 1][j];\n        }\n        for (j = weight[i]; j <= capacity; j++) {\n            maxValue[i][j] = Math.max(maxValue[i - 1][j], value[i] + maxValue[i][j - weight[i]]);\n        }\n    }\n    return maxValue[value.length - 1][capacity];\n}   \n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to get the list of selected items in 0-1 knapsack?\r\n                \r\ni have a code of the naive solution of the Knapsack problem, i want to get the list of index of selected items, currently it is returning the total sum of values of the selected items. \nAny help will be appreciated.\nJAVA CODE:\n\n```\n/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\n/* A Naive recursive implementation of 0-1 Knapsack problem */\nclass Knapsack\n{\n\n    // A utility function that returns maximum of two integers\n\n     static int max(int a, int b) {\n\n        return (a > b)? a : b; }\n\n     // Returns the maximum value that can be put in a knapsack of capacity W\n     static int knapSack(float W, float wt[], int val[], int n)\n     {\n        // Base Case\n\n    if (n == 0 || W == 0)\n        return 0;\n\n    // If weight of the nth item is more than Knapsack capacity W, then\n    // this item cannot be included in the optimal solution\n    if (wt[n-1] > W)\n      {\n\n        return knapSack(W, wt, val, n-1);\n      }\n    // Return the maximum of two cases: \n    // (1) nth item included \n    // (2) not included\n    else { \n        return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\n                     knapSack(W, wt, val, n-1)\n                      );\n    }            \n      }\n\n\n   // Driver program to test above function\n   public static void main(String args[])\n   {\n        int val[] = new int[]{29,74,16,55,52,75,74,35,78};\n        float wt[] = new float[]{85.31f,14.55f,3.98f,26.24f,63.69f,76.25f,60.02f,93.18f,89.95f};\n    float  W = 75f;\n    int n = val.length;\n    System.out.println(knapSack(W, wt, val, n));\n    }\n}\n```\n\n\ncurrent result: 148\nexpected result: 2,7\n    ", "Answer": "\r\nHere's how you can do it (though it uses some extra of memory)-\n\n```\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\n/* A Naive recursive implementation of 0-1 Knapsack problem */\nclass Knapsack\n{\n\n    // A utility function that returns maximum of two integers\n\n     static int max(int a, int b) {\n\n        return (a > b)? a : b; }\n\n     // Returns the maximum value that can be put in a knapsack of capacity W\n     static int knapSack(float W, float wt[], int val[], int n,int visited[])\n     {\n        // Base Case\n\n    if (n == 0 || W == 0)\n        return 0;\n\n    // If weight of the nth item is more than Knapsack capacity W, then\n    // this item cannot be included in the optimal solution\n    if (wt[n-1] > W)\n      {\n\n        return knapSack(W, wt, val, n-1,visited);\n      }\n    // Return the maximum of two cases: \n    // (1) nth item included \n    // (2) not included\n    else {\n\n        int v1[]=new int[visited.length];\n        System.arraycopy(visited, 0, v1, 0, v1.length);\n        int v2[]=new int[visited.length];\n        System.arraycopy(visited, 0, v2, 0, v2.length);\n        v1[n-1]=1;\n\n        int ans1 = val[n-1] + knapSack(W-wt[n-1], wt, val, n-1,v1);\n        int ans2 = knapSack(W, wt, val, n-1,v2);\n        if(ans1>ans2){\n            System.arraycopy(v1, 0, visited, 0, v1.length);\n            return ans1;\n        }\n        else{\n            System.arraycopy(v2, 0, visited, 0, v2.length);\n            return ans2;\n        }\n    }            \n      }\n\n\n   // Driver program to test above function\n   public static void main(String args[])\n   {\n        int val[] = new int[]{29,74,16,55,52,75,74,35,78};\n        float wt[] = new float[]{85.31f,14.55f,3.98f,26.24f,63.69f,76.25f,60.02f,93.18f,89.95f};\n    float  W = 75f;\n    int n = val.length;\n    int visited[] = new int[n];\n    System.out.println(knapSack(W, wt, val, n, visited));\n    for(int i=0;i<n;i++)\n        if(visited[i]==1)\n            System.out.println(i+1);\n    }\n}\n```\n\n\nWhat i did is that i created a visited array and if current element is used than i marked visited of current element one otherwise it remains zero. Finally, i iterated through this array and printed every element for which visited is 1\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack solution with Backtraking in c++\r\n                \r\nIm having troubles trying to resolve the Knapsack problem using backtraking.\n\nFor example, for the following values, the Knapsack function will return 14 as the solution, but the correct result should be 7.\n\n```\nint n = 3, weights[] = {2, 3, 1}, values[] = {6, 15, 7};\n\nint solution = 0, max = 2;\n\n\nvoid Knapsack (int i, int max, int value, int *solution)\n{\n  int k;\n\n  for (k = i; k < n; k++) {\n    if (weights[k] <= max) {\n      Knapsack (k, max - weights[k], value + values[k], solution);\n\n      if (value+ values[k] > *solution) \n         *solution= value + values[k];\n    }\n  }\n}\n```\n\n\nWhat is the problem here?\n    ", "Answer": "\r\n```\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint weights[] = {2, 3, 1}, values[] = {6, 15, 7};\n\nint solution = 0, n = 3;\n\nstd::vector<int> vsol;\nstd::vector<int> temp;\n\nbool issol;\n\n\nvoid Knapsack (int i, int max, int value)\n{\n  for (int k = i; k < n; k++) {\n    if ( max > 0)\n    {\n        if (weights[k] <= max)\n        {\n          temp.push_back(k);\n          if (value+ values[k] >= solution)\n          {\n            solution = value + values[k];\n            issol = true;\n          }\n        }\n        if ( (k+1) < n)\n        {\n          Knapsack (k+1, max - weights[k], value + values[k]);\n        }\n        else\n        {\n          if (issol == true)\n          {\n            if (! vsol.empty()) vsol.clear();\n            std::move(temp.begin(), temp.end(), std::back_inserter(vsol));\n            temp.clear();\n            issol = false;\n          } else temp.clear();\n          return;\n        }\n    }\n    else\n    {\n        if (issol == true)\n        {\n            if (! vsol.empty()) vsol.clear();\n            std::move(temp.begin(), temp.end(), std::back_inserter(vsol));\n            temp.clear();\n            issol = false;\n        } else temp.clear();\n        return;\n    }\n  }\n}\n\nint main()\n{\n    Knapsack(0, 2, 0);\n    cout << \"solution: \" << solution << endl;\n    for(vector<int>::iterator it = vsol.begin(); it != vsol.end(); it++)\n        cout << *it << \" \";\n    return 0;\n}\n```\n\n\nYou need to increase k by 1 when you call the Knapsack function again to move the index forward.\n\nAdded code to print out index locations of the solution. If more than one solution exists (i.e. same total), will only print out the locations for the last solution.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem or permutation? How to solve my problem?\r\n                \r\nHello hopefully someone can help me or atleast give me the view in the right direction.\n\nI have an Array with a size of 100 to 500 items in it. Each item has the attributes name(string), weight(float), points(float), position(int). The max weight is not a fixed number, positions are (1,2,3,4,5) each positions need to be filled. Each items can only be used once. The outcome should be the 15 combinations with the max points of 7 items. \n\nAs far as i get my laptop crashed because of full memory.\n\nI tried a solution in typescript to use firebase.\n\n```\nimport * as functions from \"firebase-functions\";\n\n// // Start writing Firebase Functions\n// // https://firebase.google.com/docs/functions/typescript\n//\nexport const potItems = functions.https.onRequest((request, response) => {\n    let possibleItems: any[] = [];\n    let counter: number = 0;\n    const items = [\n        { name: \"James Harden\", position: \"PG\", weight: 15.9, points: 62.63 },\n        { name: \"Russell Westbrook\", position: \"PG\", weight: 14.9, points: 56.12 },\n        { name: \"LeBron James\", position: \"SF\", weight: 15.9, points: 55.67 },\n        { name: \"Bradley Beal\", position: \"SG\", weight: 14.8, points: 52.69 },\n        { name: \"Anthony Davis\", position: \"PF\", weight: 14.6, points: 52.16 },\n        { name: \"Damian Lillard\", position: \"PG\", weight: 13.5, points: 49.34 },\n        { name: \"Nikola Vucevic\", position: \"C\", weight: 12.9, points: 47.97 },\n        { name: \"Domantas Sabonis\", position: \"PF\", weight: 12.8, points: 47.6 },\n        { name: \"Kristaps Porzingis\", position: \"PF\", weight: 13.5, points: 47.18 },\n        { name: \"Andre Drummond\", position: \"C\", weight: 12.2, points: 45.97 },\n        { name: \"Kawhi Leonard\", position: \"SF\", weight: 13.2, points: 46.08 },\n        { name: \"Hassan Whiteside\", position: \"C\", weight: 12.2, points: 45.83 },\n        { name: \"DeAndre Ayton\", position: \"C\", weight: 11.8, points: 45.57 },\n        { name: \"Paul George\", position: \"SF\", weight: 11.1, points: 43.8 },\n        { name: \"D'Angelo Russell\", position: \"PG\", weight: 11.5, points: 44.0 },\n        { name: \"Julius Randle\", position: \"PF\", weight: 11.3, points: 42.46 },\n        { name: \"DeMar DeRozan\", position: \"SG\", weight: 11.2, points: 40.6 },\n        { name: \"Coby White\", position: \"PG\", weight: 10.5, points: 37.85 },\n        { name: \"Ricky Rubio\", position: \"PG\", weight: 11.1, points: 37.83 },\n        { name: \"Robert Covington\", position: \"SF\", weight: 9.1, points: 37.26 },\n        { name: \"James Harden\", position: \"PG\", weight: 15.9, points: 62.63 },\n        { name: \"Russell Westbrook\", position: \"PG\", weight: 14.9, points: 56.12 },\n        { name: \"LeBron James\", position: \"SF\", weight: 15.9, points: 55.67 },\n        { name: \"Bradley Beal\", position: \"SG\", weight: 14.8, points: 52.69 },\n        { name: \"Anthony Davis\", position: \"PF\", weight: 14.6, points: 52.16 },\n        { name: \"Damian Lillard\", position: \"PG\", weight: 13.5, points: 49.34 },\n        { name: \"Nikola Vucevic\", position: \"C\", weight: 12.9, points: 47.97 },\n        { name: \"Domantas Sabonis\", position: \"PF\", weight: 12.8, points: 47.6 },\n        { name: \"Kristaps Porzingis\", position: \"PF\", weight: 13.5, points: 47.18 },\n        { name: \"Andre Drummond\", position: \"C\", weight: 12.2, points: 45.97 },\n        { name: \"Kawhi Leonard\", position: \"SF\", weight: 13.2, points: 46.08 },\n        { name: \"Hassan Whiteside\", position: \"C\", weight: 12.2, points: 45.83 },\n        { name: \"DeAndre Ayton\", position: \"C\", weight: 11.8, points: 45.57 },\n        { name: \"Paul George\", position: \"SF\", weight: 11.1, points: 43.8 },\n        { name: \"D'Angelo Russell\", position: \"PG\", weight: 11.5, points: 44.0 },\n        { name: \"Julius Randle\", position: \"PF\", weight: 11.3, points: 42.46 },\n        { name: \"DeMar DeRozan\", position: \"SG\", weight: 11.2, points: 40.6 },\n        { name: \"Coby White\", position: \"PG\", weight: 10.5, points: 37.85 },\n        { name: \"Ricky Rubio\", position: \"PG\", weight: 11.1, points: 37.83 },\n        { name: \"Robert Covington\", position: \"SF\", weight: 9.1, points: 37.26 }\n    ];\n\n        for (let index0 = 0; index0 < items.length; index0++) {\n          for (let index1 = 0; index1 < items.length; index1++) {\n            if (index1 == index0) {\n              break;\n            }\n            for (let index2 = 0; index2 < items.length; index2++) {\n              if (index2 == index0 || index2 == index1) {\n                break;\n              }\n              for (let index3 = 0; index3 < items.length; index3++) {\n                if (index3 == index0 || index3 == index1 || index3 == index2) {\n                  break;\n                }\n                for (let index4 = 0; index4 < items.length; index4++) {\n                  if (\n                    index4 == index0 ||\n                    index4 == index1 ||\n                    index4 == index2 ||\n                    index4 == index3\n                  ) {\n                    break;\n                  }\n                  for (let index5 = 0; index5 < items.length; index5++) {\n                    if (\n                      index5 == index0 ||\n                      index5 == index1 ||\n                      index5 == index2 ||\n                      index5 == index3 ||\n                      index5 == index4\n                    ) {\n                      break;\n                    }\n                    for (let index6 = 0; index6 < items.length; index6++) {\n                      if (\n                        index6 == index0 ||\n                        index6 == index1 ||\n                        index6 == index2 ||\n                        index6 == index3 ||\n                        index6 == index4 ||\n                        index6 == index5\n                      ) {\n                        break;\n                      }\n                      let item: number[] = [];\n                        item.push(index0);\n                        item.push(index1);\n                        item.push(index2);\n                        item.push(index3);\n                        item.push(index4);\n                        item.push(index5);\n                        item.push(index6);\n                        item.sort((a, b) => a - b);\n                        counter++;\n                        possibleItems.push(counter);\n                        console.log(\"item \" + counter + \": \" + item);\n\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        response.send(\"All items: \" + possibleItems);\n});\n```\n\n\nThe items here are just an example how they could look\n\nthanks for your help\n    ", "Answer": "\r\nSo, you have 7 positions to fill to maximize the sum of points?\n\nGroup your items by position, sort each group by points.\n\nNow you can pick combinations of top positions in each group, to get maximum points.\n\nSince you have hundreds of items and need only 15 top combinations, you will probably never look at most items after the sorting, and will only juggle the top few in each group. \n\nI don't know what is your measure to choose the 15 combinations. If you only maximize their summary points, you can choose whatever you want. If you want to make combinations more even (each has items with smaller dispersion of points within the combination, or smaller dispersion of summary points among combinations), you might want to add more limitations.\n\nI think something like linear programming can be helpful in this case, because you are optimizing a linear target function (a sum).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with mutually exclusive items\r\n                \r\nWhile standard knapsack problem can be solved by dynamic programming, I am trying to twist the problem a bit to clear my concept, however I found it maybe harder than I thought.\n\nOriginal knapsack problem is that given a knapsack with size ```\nW```\n, and a list of items which weight ```\nw[i]```\n and has a value ```\nv[i]```\n, find the subset of items which can fit in the knapsack with highest total value.\n\nTo my understanding, this can be done by ```\nO(Wn)```\n with dynamic programming, where ```\nn```\n is the number of items.\n\n\n\nNow if I try to add ```\nm```\n constrains, each of them is a pair of items which can only be picked mutual exclusively (i.e. if there exist a constrain of item A and item B, then I can only take either one of them but not both)\n\nUnder such constrains, can this problem still be solved by dynamic programming in ```\nO(Wn)```\n? \n    ", "Answer": "\r\nAssumption: Each element is included in atmost one constraint.\n\nFor the usual Knapsack problem, the optimal substructure that the problem exhibits is as follows:\n\nFor each item there can be two cases:\n1. The item is included in the solution\n2. The item not included in the solution.\n\nHence, the optimal solution for ```\nn```\n items is given by max of following two values.\n1. Maximum value obtained by ```\nn-1```\n items and ```\nW```\n weight.\n2. ```\nv_n```\n + maximum value obtained by ```\nn-1```\n items and ```\nW-w_n```\n weight.\n\nNow if we add the constraint that either of ```\nn```\nth or ```\n(n-1)```\nth item can exist in the solution, then the optimal solution for ```\nn```\n items is given by max of following three values.\n1. Maximum value obtained by ```\nn-2```\n items and ```\nW```\n weight.\n2. ```\nv_n```\n + maximum value obtained by ```\nn-2```\n items and ```\nW-w_n```\n weight.\n3. ```\nv_(n-1)```\n + maximum value obtained by ```\nn-2```\n items and ```\nW-w_(n-1)```\n weight.\n\nSo we treat each pair of elements in the constraint as a single element and execute the dynamic programming algorithm in ```\nO(Wn)```\n time.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "DP two knapsack problem, UVa Feary loading\r\n                \r\nI'm trying to solve UVa 10261/Ferry loading. The question is:\n\nGiven a queue of cars (with given lengths) in a given order and a ship (of a given length) with two lanes, determine the maximum number of cars you can load on the ship. A car can't be skipped and if you can't place more cars, you finish.\n\nAny idea or hints on solving it?  I would prefer an iterative solution.\nIf you wish to see the link to the problem it is here.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Can powerset be reduced and transformed to knapsack?\r\n                \r\nI am wondering can powerset problem be transformed and reduced to knapsack problem? It seems to me that they are identical that for example the changes making problem which we can think of it as powerset that every recursive stage I launch 2 recursive calls (one takes the ```\ni```\nth element, and the other one bypass it). I can also solve it with dynamic programming just like knapsack problem, so this makes me wondering if all the powerset problem can be transformed to knapsack problem. Is that correct ? \n\nThe following are the code fragment of the coin changes making one with O(2N) time complexity and one with dynamic programming O(N2) runtime. \n\n```\n// O(2^N) time complexity\nvoid bruteforce(int[] coins, int i, int N, String expr) \n{\n     if (i == coins.length) {\n         if (N == 0)\n            count++;\n         return;\n     }\n\n     if (N >= coins[i])\n         recursion(coins, i, N - coins[i], expr + \" \" + coins[i]);\n     recursion(coins, i + 1, N, expr);\n}\n\n// O(N^2) time complexity\nint dynamicProgramming(int[] coins, int N) \n{\n     int [] dp = new int[N + 1];\n     dp[0] = 1;\n\n     for(int i = 0; i < coins.length; i++)\n         for(int j = coins[i]; j <= N; j++)\n             dp[j] += dp[j - coins[i]];\n     return dp[N];\n}\n```\n\n    ", "Answer": "\r\nFinding powerset (generating all subsets of a set) can't be done in a way that has a complexity better than O(2n) because there are 2n subsets and merely printing them will take exponential time.\nProblems like subset sum, knapsack or coin change are related to powerset because you implicity have to generate all subsets but there is a big difference between them and powerset. In these problems you are only counting some subsets and you aren't required to explicity generate those subsets. For example if the problem asks you to find all the ways to change X dollars to some coins then you can't solve this in linear time because you have to generate all the desired subsets and there could be 2n of them.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack: return weight and maximum value in C++\r\n                \r\nWe know in 0-1 Knapsack problem we get the maximum benefits from some items with limited capacity. (Knapsack problem).\n\n```\nExample:\n4 10 // 5 items, 10 capacity\n1 120 // weight cost_value\n4 280\n3 150\n4 200\nAns: 600\nTotal Weight: 9\n```\n\n\nBut my question is, I want the total weight and benefit at a time. How is this possible? And what will be the change of my code? Please suggest me with my own code.\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_W 1000\nint n;\nint dp[MAX_N+1][MAX_W+1];\nint weight[MAX_N+1];\nint cost[MAX_N+1];\nint CAP;\nint func(int i,int w)\n{\n    if(i==n+1) return 0;\n    if(dp[i][w]!=-1) return dp[i][w];\n    int profit1=0,profit2=0;\n    if(w+weight[i]<=CAP)\n        profit1=cost[i]+func(i+1,w+weight[i]);\n\n    profit2=func(i+1,w);\n    dp[i][w]=max(profit1,profit2);\n    return dp[i][w];\n}\nint main()\n{\n    memset(dp,-1,sizeof(dp));\n    scanf(\"%d%d\",&n,&CAP);\n    for(int i=1; i<=n; i++)\n    {\n        scanf(\"%d %d\",&weight[i],&cost[i]);\n    }\n    printf(\"%d\\n\",func(1,0));\n\n\n}\n```\n\n    ", "Answer": "\r\nHere is the solution of your problem. You have to use pair.\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define PP pair<int,int>\nint n,target;\nint cost[102], weight[102];\nint CAP;\n\npair<int,int> Knap(int i,int w)\n{\n    if(i==n+1) return make_pair(0,w);\n    pair<int,int> profit1, profit2;\n\n    if(w+weight[i]<=CAP) {\n        pair<int,int> tmp = Knap(i+1, w + weight[i]);\n        profit1 = make_pair(tmp.first+cost[i], tmp.second);\n    }\n    else\n        profit1 = make_pair(0,0);\n\n    profit2=Knap(i+1,w);\n    return max(profit1, profit2);\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        cin>>n;\n        cin>>CAP;\n\n        for(int i=1; i<=n; i++)\n        {\n            scanf(\"%d %d\",&weight[i],&cost[i]);\n        }\n        pair<int,int>P;\n        P=Knap(1,0);\n\n        cout<<P.first<<\" \"<<P.second<<endl;\n    }\n    return 0;\n}\n```\n\n\nTest: \n\n```\n1\n4 10\n1 120\n4 280\n3 150\n4 200\nAns: 600 9\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Multidimensional Knapsack\r\n                \r\nSo I'm trying to generate an algorithm that will find the best combination of n items (in my case 4) that can only be placed in the knapsack once (0-1) with a maximum weight capacity.  Summarized probably more effectively, I want to place no more than four unique items in my knapsack so that the their weights are less than some value W while maximizing their total value.  My first attempt and assumption was to put a volume limit of 4 with all item volumes as 1 for a multidimensional knapsack problem.  But I ran into the problem of it not being 0-1 (meaning either in the bag or not).  Then I tried making an 0-1(bounded) knapsack code multidimensional but I was unable to add the volume limit as well as the 0-1 requirement.  How do I code a 0-1 multidimensional knapsack problem? Or how do I adapt the code to only hold a volume of V with all item volumes as 1?  The code doesnt have to be Java but that's what I have so far.\n\nThe Knapsack:\n\n```\npackage hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.util.*;\n\npublic class ZeroOneKnapsack {\n\n    protected List<Item> itemList  = new ArrayList<Item>();\n    protected int maxWeight        = 0;\n    protected int solutionWeight   = 0;\n    protected int profit           = 0;\n    protected boolean calculated   = false;\n\n    public ZeroOneKnapsack() {}\n\n    public ZeroOneKnapsack(int _maxWeight) {\n        setMaxWeight(_maxWeight);\n    }\n\n    public ZeroOneKnapsack(List<Item> _itemList) {\n        setItemList(_itemList);\n    }\n\n    public ZeroOneKnapsack(List<Item> _itemList, int _maxWeight) {\n        setItemList(_itemList);\n        setMaxWeight(_maxWeight);\n    }\n\n    // calculte the solution of 0-1 knapsack problem with dynamic method:\n    public List<Item> calcSolution() {\n        int n = itemList.size();\n\n        setInitialStateForCalculation();\n        if (n > 0  &&  maxWeight > 0) {\n            List< List<Integer> > c = new ArrayList< List<Integer> >();\n            List<Integer> curr = new ArrayList<Integer>();\n\n            c.add(curr);\n            for (int j = 0; j <= maxWeight; j++)\n                curr.add(0);\n            for (int i = 1; i <= n; i++) {\n                List<Integer> prev = curr;\n                c.add(curr = new ArrayList<Integer>());\n                for (int j = 0; j <= maxWeight; j++) {\n                    if (j > 0) {\n                        int wH = itemList.get(i-1).getWeight();\n                        curr.add(\n                            (wH > j)\n                            ?\n                            prev.get(j)\n                            :\n                            Math.max(\n                                prev.get(j),\n                                itemList.get(i-1).getValue() + prev.get(j-wH)\n                            )\n                        );\n                    } else {\n                        curr.add(0);\n                    }\n                } // for (j...)\n            } // for (i...)\n            profit = curr.get(maxWeight);\n\n            for (int i = n, j = maxWeight; i > 0  &&  j >= 0; i--) {\n                int tempI   = c.get(i).get(j);\n                int tempI_1 = c.get(i-1).get(j);\n                if (\n                    (i == 0  &&  tempI > 0)\n                    ||\n                    (i > 0  &&  tempI != tempI_1)\n                )\n                {\n                    Item iH = itemList.get(i-1);\n                    int  wH = iH.getWeight();\n                    iH.setInKnapsack(1);\n                    j -= wH;\n                    solutionWeight += wH;\n                }\n            } // for()\n            calculated = true;\n        } // if()\n        return itemList;\n    }\n\n    // add an item to the item list\n    public void add(String name, int weight, int value) {\n        if (name.equals(\"\"))\n            name = \"\" + (itemList.size() + 1);\n        itemList.add(new Item(name, weight, value));\n        setInitialStateForCalculation();\n    }\n\n    // add an item to the item list\n    public void add(int weight, int value) {\n        add(\"\", weight, value); // the name will be \"itemList.size() + 1\"!\n    }\n\n    // remove an item from the item list\n    public void remove(String name) {\n        for (Iterator<Item> it = itemList.iterator(); it.hasNext(); ) {\n            if (name.equals(it.next().getName())) {\n                it.remove();\n            }\n        }\n        setInitialStateForCalculation();\n    }\n\n    // remove all items from the item list\n    public void removeAllItems() {\n        itemList.clear();\n        setInitialStateForCalculation();\n    }\n\n    public int getProfit() {\n        if (!calculated)\n            calcSolution();\n        return profit;\n    }\n\n    public int getSolutionWeight() {return solutionWeight;}\n    public boolean isCalculated() {return calculated;}\n    public int getMaxWeight() {return maxWeight;}\n\n    public void setMaxWeight(int _maxWeight) {\n        maxWeight = Math.max(_maxWeight, 0);\n    }\n\n    public void setItemList(List<Item> _itemList) {\n        if (_itemList != null) {\n            itemList = _itemList;\n            for (Item item : _itemList) {\n                item.checkMembers();\n            }\n        }\n    }\n\n    // set the member with name \"inKnapsack\" by all items:\n    private void setInKnapsackByAll(int inKnapsack) {\n        for (Item item : itemList)\n            if (inKnapsack > 0)\n                item.setInKnapsack(1);\n            else\n                item.setInKnapsack(0);\n    }\n\n    // set the data members of class in the state of starting the calculation:\n    protected void setInitialStateForCalculation() {\n        setInKnapsackByAll(0);\n        calculated     = false;\n        profit         = 0;\n        solutionWeight = 0;\n    }\n\n} // class\n```\n\n\nAnd the Item:\n\n```\npackage hu.pj.obj;\n\npublic class Item {\n\n    protected String name    = \"\";\n    protected int weight     = 0;\n    protected int value      = 0;\n    protected int bounding   = 1; // the maximal limit of item's pieces\n    protected int inKnapsack = 0; // the pieces of item in solution\n\n    public Item() {}\n\n    public Item(Item item) {\n        setName(item.name);\n        setWeight(item.weight);\n        setValue(item.value);\n        setBounding(item.bounding);\n    }\n\n    public Item(int _weight, int _value) {\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public Item(int _weight, int _value, int _bounding) {\n        setWeight(_weight);\n        setValue(_value);\n        setBounding(_bounding);\n    }\n\n    public Item(String _name, int _weight, int _value) {\n        setName(_name);\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public Item(String _name, int _weight, int _value, int _bounding) {\n        setName(_name);\n        setWeight(_weight);\n        setValue(_value);\n        setBounding(_bounding);\n    }\n\n    public void setName(String _name) {name = _name;}\n    public void setWeight(int _weight) {weight = Math.max(_weight, 0);}\n    public void setValue(int _value) {value = Math.max(_value, 0);}\n\n    public void setInKnapsack(int _inKnapsack) {\n        inKnapsack = Math.min(getBounding(), Math.max(_inKnapsack, 0));\n    }\n\n    public void setBounding(int _bounding) {\n        bounding = Math.max(_bounding, 0);\n        if (bounding == 0)\n            inKnapsack = 0;\n    }\n\n    public void checkMembers() {\n        setWeight(weight);\n        setValue(value);\n        setBounding(bounding);\n        setInKnapsack(inKnapsack);\n    }\n\n    public String getName() {return name;}\n    public int getWeight() {return weight;}\n    public int getValue() {return value;}\n    public int getInKnapsack() {return inKnapsack;}\n    public int getBounding() {return bounding;}\n\n} // class\n```\n\n    ", "Answer": "\r\nHere is a generic implementation to solve the knapsack 0-1 problem with 2 dimensions (size and volume). I used a matrix instead of a list of list because it is much easier. Here is the whole class with also the main method to test it.\n\nTo add dimensions just add new dimensions to the matrix and add inner cycles to check all conditions.\n\n```\npublic class MultidimensionalKnapsack {\n\n    /** The size of the knapsack */\n    private static int size;\n    /** The volume of the knapsack */\n    private static int vol;\n\n    private static class Item {\n        public int value;\n        public int size;\n        public int volume;\n        public Item(int v, int w, int vol) {\n            value = v;\n            size = w;\n            volume = vol;\n        }\n    }\n\n    // Knapsack 0/1 without repetition\n    // Row: problem having only the first i items\n    // Col: problem having a knapsack of size j\n    // Third dimension: problem having a knapsack of volume h\n    private static int[][][] dynNoRep;\n\n    private static void noRep(Item[] items) {\n        dynNoRep = new int[items.length + 1][size + 1][vol + 1];\n        for(int j = 0; j <= size; j++) {\n            dynNoRep[0][j][0] = 0;\n        }\n        for(int i = 0; i <= vol; i++) {\n            dynNoRep[0][0][i] = 0;\n        }\n        for(int i = 0; i <= items.length; i++) {\n            dynNoRep[i][0][0] = 0;\n        }\n        for(int i = 1; i <= items.length; i++)\n            for(int j = 0; j <= size; j++) {\n                for(int h = 0; h <= vol; h++) {\n                    if(items[i - 1].size > j)\n                        // If the item i is too big, I  can't put it and the solution is the same of the problem with i - 1 items\n                        dynNoRep[i][j][h] = dynNoRep[i - 1][j][h];  \n                else {\n                    if(items[i - 1].volume > h)\n                        // If the item i is too voluminous, I can't put it and the solution is the same of the problem with i - 1 items\n                        dynNoRep[i][j][h] = dynNoRep[i - 1][j][h];\n                    else {\n                        // The item i could be useless and the solution is the same of the problem with i - 1 items, or it could be \n                        // useful and the solution is \"(solution of knapsack of size j - item[i].size and volume h - item[i].volume) + item[i].value\" \n                        dynNoRep[i][j][h] = Math.max(dynNoRep[i - 1][j][h], dynNoRep[i - 1][j - items[i - 1].size][h - items[i - 1].volume] + items[i - 1].value);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        size = 15;\n        vol = 12;\n        Item[] items = {new Item(2, 4, 1), new Item(1, 5, 4), new Item(6, 3, 9), \n            new Item(3, 3, 19), new Item(7, 2, 7), new Item(1, 2, 6), new Item(2, 1, 2),\n            new Item(10, 9, 12), new Item(9, 10, 2), new Item(24, 23, 11)};\n        System.out.print(\"We have the following \" + items.length + \" items (value, size, volume): \");\n        for(int i = 0; i < items.length; i++)\n            System.out.print(\"(\" + items[i].value + \", \" + items[i].size + \", \" + items[i].volume + \") \");\n        System.out.println();\n        System.out.println(\"And a knapsack of size \" + size + \" and volume \" + vol);\n\n        noRep(items);\n        System.out.println();\n        // Print the solution\n        int j = size, h = vol, finalSize = 0, finalValue = 0, finalVolume = 0;\n        System.out.print(\"Items picked (value, size, volume) for 0/1 problems without repetitions: \");\n        for(int i = items.length; i > 0; i--) {\n            if(dynNoRep[i][j][h] != dynNoRep[i - 1][j][h]) {\n                System.out.print(\"(\" + items[i - 1].value + \", \" + items[i - 1].size + \", \" + items[i - 1].volume + \") \");\n                finalSize += items[i - 1].size;\n                finalValue += items[i - 1].value;\n                finalVolume += items[i - 1].volume;\n                j -= items[i - 1].size;\n                h -= items[i - 1].volume;\n            }\n        }\n        System.out.println();\n        System.out.println(\" Final size: \" + finalSize);\n        System.out.println(\" Final volume: \" + finalVolume);\n        System.out.println(\" Final value: \" + finalValue);\n    }\n```\n\n\n}\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack but exact weight\r\n                \r\nIs there a algorithm to determine a knapsack which has an exact weight W? I.e. it's like the normal 0/1 knapsack problem with n items each having weight w_i and value v_i. Maximise the value of all the items, however the total weight of the items in the knapsack need to have exactly weight W!\n\nI know the \"normal\" 0/1 knapsack algorithm but this could also return a knapsack with less weight but higher value. I want to find the highest value but exact W weight.\n\nHere is my 0/1 knapsack implementation:\n\n```\npublic class KnapSackTest {\n    public static void main(String[] args) {\n        int[] w = new int[] {4, 1, 5, 8, 3, 9, 2};  //weights\n        int[] v = new int[] {2, 12, 8, 9, 3, 4, 3}; //values\n\n        int n = w.length;\n        int W = 15; // W (max weight)\n\n        int[][] DP = new int[n+1][W+1];\n\n        for(int i = 1; i < n+1; i++) {\n            for(int j = 0; j < W+1; j++) {\n                if(i == 0 || j == 0) {\n                    DP[i][j] = 0;\n                } else if (j - w[i-1] >= 0) {\n                    DP[i][j] = Math.max(DP[i-1][j], DP[i-1][j - w[i-1]] + v[i-1]);\n                } else {\n                    DP[i][j] = DP[i-1][j];\n                }\n            }\n        }\n        System.out.println(\"Result: \" + DP[n][W]);\n    }\n}\n```\n\n\nThis gives me:\n\n```\nResult: 29\n```\n\n\n(Just ask if anything is unclear in my question!)\n    ", "Answer": "\r\nActually, the accepted answer is wrong, as found by @Shinchan in the comments.\n\nYou get exact weight knapsack by changing only the initial ```\ndp```\n state, not the algorithm itself.\n\nThe initialization, instead of:\n\n```\n            if(i == 0 || j == 0) {\n                DP[i][j] = 0;\n            }\n```\n\n\nshould be:\n\n```\n            if (j == 0) {\n                DP[i][j] = 0;\n            } else if (i == 0 && j > 0) { // obviously `&& j > 0` is not needed, but for clarity\n                DP[i][j] = -inf;\n            }\n```\n\n\nThe rest stays as in your question.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Trying to get knapsack problem to work without multidimensional arrays\r\n                \r\nI'm trying to do my own implementation of the knapsack algorithm, and I was wondering if it could be done without multidimensional arrays, which is what I see online mostly. \n\nThe idea wasn't to make the most optimal one, so I merely used the methods I felt were what could get the job done. (using lists instead of int[])\n\nI feel like i'm close to getting it, but not quite there yet, and I'm not sure what i'm doing wrong.\n\nThe below is fed by a driver function that parses say, the following input (weight:value):\n\nMax\n\n50\n\n10:60,20:100,30:120\n\nShould print 220, and the subset that creates it.\n\nCheckSum returns true if the value, when added is less than or equal to the max weight.\n\nAlthough, half the code is merely getting and placing the values...\n\n```\n public static bool Knapsack(int W, Dictionary<int, Tuple<int,int>> Items, List<int> numbers)\n    {\n        List<int> summationValue;\n        List<int> subset;\n        List<int> summationWeight;\n        List<KeyValuePair<int, List<int>>> finalSet = new List<KeyValuePair<int, List<int>>>();\n\n        for (int auto = 0; auto <= Items.Count-1; auto++)\n        {\n            Console.WriteLine(\"Iteration: \" + auto);\n            int value1 = Items[auto].Item2;\n            int weight1 = Items[auto].Item1;\n            summationValue = new List<int> { value1 };\n            subset = new List<int> { (auto+1) };\n            summationWeight = new List<int> { weight1 };\n            //Initialize//var currentItem = itemIndex == 0 ? null : items[itemIndex - 1];\n            for (int other_nodes = 0; other_nodes <= Items.Count-1; other_nodes++)\n            {\n                if (other_nodes == auto)\n                {\n                    other_nodes++;\n                }\n                int value2 = Items[other_nodes].Item2;\n                int weight2 = Items[other_nodes].Item1;\n                if (CheckSum(summationWeight, weight2, W))\n                {\n                    summationValue.Add(value2); \n                    subset.Add(other_nodes+1);\n                    summationWeight.Add(weight2);\n                    KeyValuePair<int, List<int>> kv = new KeyValuePair<int, List<int>>(summationValue.Sum(), subset);\n                    finalSet.Add(kv);\n                    break;\n                }\n\n\n\n            }\n\n            //After all item iteration, print outputs; [Highest value] [Subset] [Weight]\n            string printValue = summationValue.Sum().ToString();\n            subset.Sort();\n            string printWeight = summationWeight.Sum().ToString();\n\n            Console.WriteLine(\"Highest Value: \");\n            Console.WriteLine(printValue);\n            Console.WriteLine(\"Subsets: \\n\");\n            Console.Write(\"{ \");\n            foreach (var i in subset)\n            {\n                 Console.Write(i + \" \");\n            }\n            Console.WriteLine(\"}\");\n            Console.WriteLine(\"Highest Weight: \");\n            Console.WriteLine(printWeight);\n        }\n        Console.WriteLine(\"[========================]\");\n        var pair = finalSet.OrderByDescending(x => x.Key).First();\n        var keys = finalSet.Where(kvp => kvp.Key == pair.Key).Select(kvp => kvp.Key).ToArray();\n        var fkey = keys.Max();\n        Console.WriteLine(fkey);\n        Console.Write(\"{ \");\n        foreach (var i in pair.Value)\n        {\n            Console.Write(i + \" \");\n        }\n        Console.Write(\"}\");\n        return true;\n    }\n```\n\n\nNot included is the linq function to get the largest key in the list which corresponds to the greatest value, something like: \n\n```\n finalSet.OrderByDescending(x => x.Key).First();\n```\n\n\nI know that this isn't the best way to go about it, but i'd still like to ask what i'm doing wrong in the implementation.\n\nCurrently, it would print for the final set: 180, 1 3. When it should've been 220.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Bounded knapsack - formulation\r\n                \r\nI need to map an optimization problem to a bounded knapsack problem.\n\nI have a set of items, each with a given value vi. All my items have the same weight (wi  = 1) :\n\n\nItem 1 =>  v1 : 2,  w1 : 1\nItem 2 =>  v2 : 3, w2 : 1\nItem 3 => v3 :4, w3 :1\netc.\n\n\nIn my knapsack I can put the same item multiple times (bounded Knapsack) with the constraint that the number of items added to the knapsack cannot exceed c (and, hence, each item cannot be added more than c times).\n\nThe problem is that the value assigned to an item is dependent on the previous content of the bag : each time an item is added to knapsack, its value is divided by the number of occurrence of the item in the bag. For example, if item 1 is added two times to the knapsack, its value must be decreased to v1/2. If it is added 3 times, its value became v1/3, and so on.\n\nMy question is how can I modelize this as a (0-1) knapsack problem and is there a DP solution for that?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 knapsack with weight equal to capacity rather than smaller or equal\r\n                \r\nIn a knapsack problem we usually try to maximise the the value of the goods in the knapsack while keeping the total weight of the goods <= C where C is the capacity of the knapsack. How do I solve the problem when the total weight of the goods should be exactly equal to the capacity of the knapsack = C?\n    ", "Answer": "\r\nThe problem you are solving is same but with tighter constraint. The DP solution for the same will be :-\n\n```\nDP(n,W) = 0;\nValid(n,W) = false;\n\nif(Valid(n-1,W)) {\n\n    DP(n,W) = DP(n-1,W);\n    Valid(n,W) = true;\n}\n\nif(Valid(n-1,W-weight[n])) {\n\n     DP(n,W) = max(DP(n,W),DP(n-1,W-weight[n])+value[n]);\n     Valid(n,W) = true;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack 0-1 in R\r\n                \r\nI have been trying to formulate a simple knapsack problem, but I cannot see why it is not working.\n\n```\ni <- c(1,2,3,4)\nv <- c(100,80,10,120)\nw <- c(10,5,10,4)\nk <- 15\n\nF <- function(i,k){\n  if (i==0 | k==0){\n    output <- 0\n  } else if (k<w[i]){\n    output <- F(i-1,w)\n  } else {\n    output <- max(v[i]+ F(i-1, k-w[i]), F(i-1,k))\n  }\n  return(output)\n}\n```\n\n    ", "Answer": "\r\nHaving a look at the ```\nknapsack```\n function of the package adagio should help you, where ```\nw```\n is the vector of weights, ```\np```\n the vector of profits and ```\ncap```\n is your ```\nk```\n. (see ```\n?knapsack```\n)\n\n```\nknapsack <- function (w, p, cap) {\n    n <- length(w)\n    x <- logical(n)\n    F <- matrix(0, nrow = cap + 1, ncol = n)\n    G <- matrix(0, nrow = cap + 1, ncol = 1)\n    for (k in 1:n) {\n        F[, k] <- G\n        H <- c(numeric(w[k]), G[1:(cap + 1 - w[k]), 1] + p[k])\n        G <- pmax(G, H)\n    }\n    fmax <- G[cap + 1, 1]\n    f <- fmax\n    j <- cap + 1\n    for (k in n:1) {\n        if (F[j, k] < f) {\n            x[k] <- TRUE\n            j <- j - w[k]\n            f <- F[j, k]\n        }\n    }\n    inds <- which(x)\n    wght <- sum(w[inds])\n    prof <- sum(p[inds])\n    return(list(capacity = wght, profit = prof, indices = inds))\n}\n```\n\n\nHowever, the problems in your function seem to be \n\n\nYou did not declare all the objects used in your function (```\nw```\n and ```\nv```\n) : you should also declare them as parameters of your function.\n```\nF```\n which is the name of your function is called inside your function. Hence, as ```\n(i==0 | k==0)```\n could never be true, the function will never stop processing.\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack algorithm\r\n                \r\nIs the following 0-1 Knapsack problem solvable:\n\n\n'float' positive values and \n'float' weights (can be positive or negative)\n'float' capacity of the knapsack > 0\n\n\nI have on average < 10 items, so I'm thinking of using a brute force implementation. However, I was wondering if there is a better way of doing it. \n    ", "Answer": "\r\nThis is a relatively simple binary program.\n\nI'd suggest brute force with pruning.  If at any time you exceed the allowable weight, you don't need to try combinations of additional items, you can discard the whole tree.\n\nOh wait, you have negative weights?  Include all negative weights always, then proceed as above for the positive weights.  Or do the negative weight items also have negative value?\n\nInclude all negative weight items with positive value.  Exclude all items with positive weight and negative value.\n\nFor negative weight items with negative value, subtract their weight (increasing the knapsack capavity) and use a pseudo-item which represents not taking that item.  The pseudo-item will have positive weight and value.  Proceed by brute force with pruning.\n\n```\nclass Knapsack\n{\n    double bestValue;\n    bool[] bestItems;\n    double[] itemValues;\n    double[] itemWeights;\n    double weightLimit;\n\n    void SolveRecursive( bool[] chosen, int depth, double currentWeight, double currentValue, double remainingValue )\n    {\n        if (currentWeight > weightLimit) return;\n        if (currentValue + remainingValue < bestValue) return;\n        if (depth == chosen.Length) {\n            bestValue = currentValue;\n            System.Array.Copy(chosen, bestItems, chosen.Length);\n            return;\n        }\n        remainingValue -= itemValues[depth];\n        chosen[depth] = false;\n        SolveRecursive(chosen, depth+1, currentWeight, currentValue, remainingValue);\n        chosen[depth] = true;\n        currentWeight += itemWeights[depth];\n        currentValue += itemValues[depth];\n        SolveRecursive(chosen, depth+1, currentWeight, currentValue, remainingValue);\n    }\n\n    public bool[] Solve()\n    {\n        var chosen = new bool[itemWeights.Length];\n        bestItems = new bool[itemWeights.Length];\n        bestValue = 0.0;\n        double totalValue = 0.0;\n        foreach (var v in itemValues) totalValue += v;\n        SolveRecursive(chosen, 0, 0.0, 0.0, totalValue);\n        return bestItems;\n    }\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with an amount limitation\r\n                \r\nI'm trying to solve a problem thats some what similar to the knapsack problem but with a twist. At least thats what I have come to think it is anyway. \nIn the knapsack problem we have the weight capacity of the knapsack, the weight and value of the items.\nMy twist to this one is to add a certain amount of slots available to be filled with items. Like this:\nWe have a knapsack with the maximum weight capacity of 30 and it can only hold 6 items regardless of weight. Duplicates are allowed.\n\nI managed to make a recursive function that takes a List containing the same amount of lists that there are slots available \n\n```\nList<List<Item>> workingList\n// Example of a list of items.\n{\"items\" : \n    [\"name\":\"item1\",\"value\":2,\"weight\"4],\n    [\"name\":\"item2\",\"value\":3,\"weight\"5],\n    [\"name\":\"item3\",\"value\":4,\"weight\"6],\n    [\"name\":\"item4\",\"value\":5,\"weight\"8]\n}\n```\n\n\nand returning suggested list of items optimal for the weight and value. Problem with this function is that its very greedy. It takes forever (or run out of memory) if I have more than 4 slots and 10 items. I need to be able to fit about 50 items or more and around 3-8 slots. I've looked at some examples of the knapsack problem but can't get a good grip on if it will work for my problem. Is it possible to use the knapsack or is it a completely other approach?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Can we use knapsack + recursion for leetcode combination sum 4\r\n                \r\nFor https://leetcode.com/problems/partition-equal-subset-sum\n```\nvar canPartition = function(ns) {\n    // sum\n    const s = ns.reduce((acc, t) => acc+t, 0);\n    \n    // half\n    condi = s % 2 === 0 ? true : false\n    if(condi === false) return false;\n    \n    // sort\n    ns.sort((a, b) => a-b);\n    const sum = s/2;\n    \n    // memo_2D\n    const dp = [];\n    for(let i=0; i<ns.length; ++i) {\n        dp[i] = Array(sum+1).fill(null);\n    }\n\n    return recur(ns, 0, sum, dp);\n};\n\n\nvar recur = function(ns, i, tar, dp) {\n    // ind guard\n    if(i >= ns.length) return false;\n    // equal\n    if(tar === 0) return true;\n    // over_consume\n    if(tar < 0) return false;\n    // if top, this catch everything   \n    if(dp[i][tar] !== null) return dp[i][tar];\n    \n    // knapsack recur, memo_2D\n    const res = recur(ns, i+1, tar-ns[i], dp) || recur(ns, i+1, tar, dp);\n\n    return dp[i][tar] = res;\n}\n```\n\nI can use knapsack (pick this element or not) + recursion. It passes all test cases.\nI tried to apply the same method (knapsack + recursion) in the following question.\nhttps://leetcode.com/problems/combination-sum-iv\n```\nvar combinationSum4 = function(ns) {\n    const s = ns.reduce((acc, t) => acc+t, 0);\n    ns.sort((a, b) => a-b);\n    const sum = s;\n    \n    // memo_2D\n    const dp = [];\n    for(let i=0; i<=sum; ++i) {\n        dp[i] = Array(ns.length+1).fill(null);\n    }\n\n    return recur(ns, 0, sum, dp);\n};\n\n\nvar recur = function(ns, i, tar, dp) {  \n    if(i >= ns.length) return 0;\n    if(tar === 0) return 1;\n    if(tar < 0) return 0;\n    if(dp[tar][i] !== null) return dp[tar][i];\n    \n    const res = recur(ns, i+1, tar-ns[i], dp) + recur(ns, i+1, tar, dp);\n    return dp[tar][i] = res;\n}\n```\n\nThe dp 2D array is not filled.\nMy question:\n\nIs it a knapsack problem?\nCan we use knapsack + recursion to resolve?\n\n    ", "Answer": "\r\nI think the second problem is more of a coin change type DP problem (rather ```\nknapsack + recursion```\n one). The following code solves the problem:\n```\nint combinationSum4(vector<int>& nums, int target) {\n    vector<int> dp(target+1, 0);\n    dp[0] = 1;\n    int sz = nums.size();\n\n    for(int i=1; i<=target; i+=1) {\n        for(int j=0; j<sz; j+=1) {\n            if(i >= nums[j]) dp[i] += dp[i - nums[j]];\n        }\n    }\n\n    return dp[target];\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving knapsack with fractional knapsack approach\r\n                \r\nThere are two well-known knapsack problems:\n\n1) Given ```\nn```\n items, each has its ```\nweight```\n and ```\ncost```\n. We need to select items, that will fit in our knapsack and have maximal cost in sum. It can be easily solved using ```\ndynamic programming```\n.\n\n2) Fractional knapsack: same as the first, but we can take not the whole item only, but its part. This problem can be easily solved with ```\ngreedy algorithm```\n.\n\nImagine we are using ```\ngreedy algorithm```\n from second problem to solve the first one. How can I prove, that the solution we will get is no more than two times worse, than the optimal one?\n    ", "Answer": "\r\nAs far I can see, the greedy solution can be as much as inefficient as you want.\nImagine that you have a knapsack with capacity ```\n1```\n and two (```\nn = 2```\n) items:\n\n```\nitem weight cost density\n------------------------\n   A      ε    ε       1  <- greedy choice\n   B      1  1-ε     1-ε  <- optimal choice\n```\n\n\nso the greedy algorithm takes ```\nA```\n with ```\nε```\n cost when the optimal solution is\nto take ```\nB```\n with ```\n1-ε```\n cost. The chosen (greedy) solution is\n\n```\n  (1-ε)/ε = 1/ε - 1 \n```\n\n\ntimes inefficient than optimal one. Make ```\nε```\n as little as you want (say, ```\nε = 1e-100```\n) and have a very inefficient greedy solution. \n\nEdit: in case of integer values only, just scale the sample above: you have a knapsack with capacity ```\nX```\n and two (```\nn = 2```\n) items\n\n```\nitem weight cost density\n------------------------\n   A      1    1       1  <- greedy choice\n   B      X  X-1   1-1/X  <- optimal choice\n```\n\n\nin this case the greedy solution is\n\n```\n   (X - 1) / 1 = X - 1\n```\n\n\ntimes inefficient than optimal one. Finally, make ```\nX```\n to be large enough (say, ```\nX = 1e100```\n) \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Bounded Knapsack Problem set-up. Want: a list of all possible packings\r\n                \r\nRather than optimize anything, I want to list all the possible - including \"incomplete\" - packings of the knapsack. Of course, I could loop through all subsets of the set of objects and pick the ones satisfying the weight constraint (can be improved by placing an upper bound on the size of the subsets to look through), but I'd really like something more efficient.\n\nThanks.\n    ", "Answer": "\r\nFirst sort your objects by weight. Then recursively pack the knapsack.  If the smallest weight object not yet considered does not fit, or we have no objects remaining, then add the current knapsack to our list and return, else add the current knapsack to our list for each object in the list that fits put it in and try to pack the rest of the knapsack with objects heavier than the last object we packed.\n\nIf we can pack more than one item of a given type then replace less than with less than or equal to.\n\nIf we have multiple objects of the same weight we need to sort first by weight, then by some arbitrary order, and use that.\n\n```\n PackKnapsack(knapsack, objects)\n   add knapsack to list\n   if objects is empty return\n   if smallest object does not fit return\n   for each object in order from smallest to largest\n      if currentobject does not fit\n         break\n      PackKnapsack(knapsack + currentObject, objects heavier than current object)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Real Weights Knapsack in polynomialtime\r\n                \r\n\n  In the lecture, we have considered the Knapsack problem: There are n items with positive weights\n  w1, . . . , wn and values v1, . . . , vn and a knapsack (a bag) of capacity W. A feasible solution to the\n  problem is a subset of the items such that their total weight does not exceed W. The objective is to\n  find a feasible solution of maximum possible total value.\n  For the case where all weights are positive integers, we have discussed a dynamic programming solution\n  that solves the knapsack problem in time O(nW).\n  \n  \n  \n  a)Assume that instead of the weights, the values of all items are positive integers. The weights of\n  the items can be arbitrary positive real numbers. Describe a dynamic programming algorithm that\n  solves the knapsack problem if all values are positive integers.\n\n\nIdea - Round the values but this would just be a approximation right? This does only work if we have limited limited decimal space...\n\nis there an other approach?\n\nIm even more confused of the next questions:\n\n\n  b) What is the running time of your algorithm? Justify your answer.\n  \n  \n  \n  c) Knapsack is one of Karp’s NP-complete problems. Both dynamic programming solutions lead to\n  polynomial time algorithms. Why is this not a contradiction to the NP-completeness of Knapsack?\n\n    ", "Answer": "\r\nPart A: Since the values of all items are positive integers, and therefore the items cannot be broken meaning the items have to be taken as a whole or left behind, this is an example of the 0/1 Knapsack problem. This problem lacks the Greedy Choice Property and so cannot be solved by a Greedy approach. Dynamic Programming is necessary.\n\nSay for example we have item 1 (total value: $60, weight: 10lbs, value/weight: $6/lb), item 2 (total value: $100, weight: 20lbs, value/weight: $5/lb), and item 3: (total value: $120, weight: 30lbs, value/weight: $4/lb). \n\nWith a greedy approach you take the most valuable item first. item 1+item 2=$160. This is not the optimal solution since if we include item 1, other items might be forced out and empty space could remain. Must look at the solution with item 1 vs. solution without item 1. This is called overlapping subproblems.\n\nFor an optimal solution, either our last item n is in the optimal solution A, or it is not.\n\n\nIf it is: The rest of the objects in the optimal solution can be found by finding optimal solution given N-{n} items and max capacity of C-s{sub n}.\nIf it is not: The rest of the objects in the optimal solution can be found by finding optimal solution given N-{n} items and max capacity of C.\n\n\nTo find max value(N,C):\n - if s{sub n} <= C: max(value(N-{n},C),v{sub n} + value(N-{n},C-s{sub n}))\n - if s{sub n} > C: value(N-{n},C)\n\nAs this is a lot of subproblems to try, create a table with #columns = size of backpack + 1 (i.e. 0...C, with C being size of backpack), and #rows = inputs in any order. Fill out the table with the rules listed above starting at C=0 and going across the table for each item. Choose the combination that provides the highest capacity and highest total worth.\n\nPart B: The running time of the algorithm is O((Cn)^2). The table is Capacity x number of items. Each element in the table compares 2 values (max of not including element n{sub k}, and including element n{sub k}).\n\nPart C: The 0/1 Knapsack is NP-complete and is polynomial in the capacity of the backpack. This is not a contradiction to the NP-completeness of the Knapsack problem because there are many instances where the capacity is O(2^n).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Reduce 0-1 knapsack prob. to a SAT prob\r\n                \r\nIs there any way to reduce the 0-1 knapsack problem to a SAT problem in Conjunctive Norm Form?\n    ", "Answer": "\r\nYou could always work out the digital circuits necessary to implement adders and comparators and then turn the result of that into conjunctive normal form. You can get circuits into CNF form without expanding them exponentially by making up intermediate variables which represent the outputs of small sections of circuit.\n\nEach node of a circuit amounts to a=f(b, c) where a is the output, b and c the input, and f is some simple function like & or |. You can create a CNF function that is true only when a really is the result of f(b, c) and it can't be too unwieldy, because it is a function on only three variables.\n\nYou can rewrite any circuit into a large number of terms of the form a=f(b, c) and all you have to do with the CNF versions of these is to AND them all together. Assuming you want to solve for the output being true, you then just stick on the output variable as the final component of that big AND.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "KNapsack variant. Ideas?\r\n                \r\nI have the following knapsack problem variant:\n\nI want to buy X units of a product at min cost, and there are m farmers that offer:\n- \n\nand I can choose at most one option from each farmer.\n\nFormally, I want to\n\n\n\nCould you please let me know if this problem resembles a variant of 0-1 knapsack problem?\n\nI would be grateful if you could provide any references where I can find more information about this or any relevant algorithms.\n    ", "Answer": "\r\ni think you can relate this to those (0-1 Knapsack) kind of problems. here also you will have to select one  option (the max number of units) from a farmer, possibly the one having the least cost/unit ratio, and then call the programm recursively, this time having one less farmer (the one from which the items are chosen from) the last time.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Can we solve Fractional Knapsack Problem by DP?\r\n                \r\nI know the Greedy approach is the best solution, but I'm so curious.\nhere is some of my code ...\n```\ndef fractional_knapsack_dp2(): \nglobal resValue\n\n# 각 size W를 넘지 않는 상태에서, i개의 아이템을 담은 상태에서 최대 profit을 담는 배열 \nP = [ [0 for x in range(W+1)] for x in range(n+1)] # [n+1][W+1] 0으로 초기화 \n\nfor i in range(n+1):\n    currWeight = 0\n    for w in range(W+1):\n        if i==0 or w==0: # 0행 또는 0열은 skip \n            P[i][w] = 0;\n\n        elif weights[i-1] <= w:\n            currWeight = weights[i-1]\n            P[i][w] = max( values[i-1] + P[i-1][w - weights[i-1]], P[i-1][w] )\n\n        else:\n            # weight 1 단위로 설정  ... dksl d어케함 ;;\n            frac = 1 / weights[i-1]\n            if ( frac*values[i-1] + P[i-1][w - 1] > P[i-1][w] ) :\n                P[i][w] = P[i-1][w-1]\n                for k in range(w - currWeight) :\n                    currWeight += 1\n                    P[i][w] += frac*values[i-1]\n            else : \n                P[i][w] = P[i-1][w]\n\nresValue = P[n][W]\n```\n\nI don't know how can I solve the problem.\nShould I make another recurrence relation or array? 😢\nI didn't learn about Dynamic Programming yet.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Algorithm design: can you provide a solution to the knapsack problem where there is no maximum weight constraint?\r\n                \r\nI am not able to find suitable algorithm for my problem. my problem is as follows:\nThere are n number of tasks. Each task is replicated different number of times. Two replicas of same task should not be on same agent. assign the replicas to agent such that the sum of replicas on each agent is approximately same. There is no weight constraint on the agent.\ncan this be solved by knapsack?\n    ", "Answer": "\r\nA knapsack problem without weights is just about sorting descending for value and taking as much as you like. So it does not make that much sense without the weight constraint - because now no optimization needed.\n\nI also see no connection to your agents here.\n\nThe problem is quite simple to solve: \n\n\nSort the agents ascending by the length of their queues \nand give the next job to the first one that not already has a copy of that task.\nrepeat until all tasks are assigned\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What's the best non-dp algo for knapsack?\r\n                \r\nI have an equivalent of knapsack problem where multiplication is substituted for addition. Can't find any algo for multiplication-type of problem, so naturally I switched to logarithms, but now I can't use dp-solution to knapsack. What's my best move? Thanks.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "I'm trying to solve the \"knapsack\" problem using Java and recursion\r\n                \r\nThis is for a school assignment and the professor stipulates that recursion must be used, and it must take a single line input in a gui box where the first number is the max capacity (weight) the knapsack can hold and the rest are item weights. This doesn't include the value, just weight.\n\nIt is partially working, as it is following the tree properly and indicating how many solutions there are (via debugging output) but I am having trouble being able to record the valid solutions. It seems to work fine on returns from recursive calls when at the ends of the branches due to storing and removing the items from the sack[] array.\n\nAs far as I can tell from stepping through the code a million times is that it fails when returning somewhere else. This leaves stray items sitting in the sack that shouldn't be there. Hopefully someone will be able to see where I am doing something dumb and help me go in the correct direction. I have deleted and rewritten the code in this so many times that I am about to throw my computer out of a window. lol\n\nI know this is a lot, but I couldn't think of how to properly describe what I am having trouble with other than just posting the entire program. Thanks in advance for any help anyone might be able to provide.\n\n```\nimport javax.swing.*;\nimport java.util.Arrays;\n\n// Main Program\nclass n00868494 {\n\n   static int itemCount = 0; // total number of items \n   static int pos = 0; // position indicator in the \"sack\" array\n   static int sack[] = new int[25]; // sack to hold items on right branches\n\n   public static void main(String[] args) {\n\n   String sinput[] = new String[25]; // temp string array to hold parameters before     converting to integers\n   int items[] = new int[25]; // array to hold the items\n   int capacity = 0; // knapsack capacity\n   String s = null; // temp string to hold user input\n\n   while (true) { // infinite loop\n\n      // Use a JOptionPane dialog to get the user's input\n      s = JOptionPane.showInputDialog(new JFrame(\"Input Params\"), \"Please enter total weight, followed a list of item weights)\",\"Run Parameters\",JOptionPane.QUESTION_MESSAGE);\n\n      if ((s == null) || (s.equals(\"\"))) { // user pressed X, cancel or left it blank.\n         System.exit(0);  // exit cleanly\n      }\n\n      sinput = s.split(\" \"); // split the parameters on the whitespace\n\n      for (int i = 0; i < sinput.length; i++) { // iterate through the array and copy the elements to the correct variables\n         if (i == 0) {\n            capacity = Integer.parseInt(sinput[i], 10); // knapsack weight in the first position\n         } else {\n            items[i-1] = Integer.parseInt(sinput[i], 10); // the rest are item weights\n         }\n      }\n     items = Arrays.copyOfRange(items, 0, sinput.length - 1); // truncate the items array to remove empty elements at the end\n\n      knapSack(capacity, items); // call the knapsack method that will in turn call the recursive function\n   }   \n      }\n\n   public static void knapSack(int capacity, int[] items) {\n\n      itemCount = items.length; // keep track of original number of items\n\n      recknapSack(capacity, items, 0); // start recursive calls\n   }\n\n\n   /*\n      recursive knapsack method: called repeatedly to find the correct combinations of items such that their weights\n  total to the max capacity that the knapsack can hold\n\n      capacity: knapsack capacity\n      items: array of items (weights)\n      branch: flag indicating whether the call is a left branch (item not included) or right branch (item included)\n         0 - initial call, non recursive\n         1 - left branch, weight not included\n         2 - right branch, weight included\n   */\n   public static void recknapSack(int capacity, int[] items, int branch) {\n\n      System.out.print(\"\\nCap: \" + capacity + \" Items: \" + Arrays.toString(items)); // recursive call tracking debugging\n\n      if (capacity == 0){ // debugging - for breaking at certain points in the tree\n         assert Boolean.TRUE; // set breakpoint on this line\n      }\n\n\n      // base cases - ends of the branches\n      if (capacity == 0){ // sack is exactly full, item weights = total weight\n            System.out.print(\"\\t  -> good tree\"); // debugging\n            //JOptionPane.showMessageDialog(new JFrame(\"Results\"), \"The valid combinations are: \");\n            Arrays.fill(sack, 0); // clear the sack, this was a successful branch, will start again for another solution\n            return;\n      } else if (capacity < 0) { // bag overloaded\n            System.out.print(\"\\t  -> overload tree\"); // debugging\n            if (branch == 2) // if this is an \"included\" branch\n               sack[--pos] = 0; // remove the last item placed in the sack\n        return;\n           } else if (items.length == 0){ // out of items and/or capacity not reached\n        System.out.print(\"\\t  -> empty src tree\"); // debugging\n        if (branch == 2)\n           sack[--pos] = 0;\n        return;\n   } else {\n\n     int firstItem; // this the first item, it will either be discarded (not included) or placed in the sack array (included)\n     firstItem = items[0];\n\n     items = Arrays.copyOfRange(items, 1, items.length); // for either recursive branch: remove the first item from the list\n\n     recknapSack(capacity, items, 1); // call recursive function, left branch, where item is discarded and not placed in sack\n\n     // prepare for right branch, where item is placed in sack\n     capacity -= firstItem; // subtract the left most item weight from from capacity\n     sack[pos++] = firstItem; // place the item in the sack\n     recknapSack(capacity, items, 2); // recursive right branch call, item is placed in sack, weight subtracted from capacity\n\n  }\n\n  return;\n   }\n}\n```\n\n    ", "Answer": "\r\nWhat is happening in your code is that when it gets to the last else statement, it is not removing the initial value that was put in.  I made a small change to your code that may get you the results you are looking for.  First, I had the recursive function return an int, which would be the capacity:\n\n```\n public static int recknapSack(int capacity, int[] items, int branch) {\n```\n\n\nI changed every return statement to:\n\n```\n return capacity;\n```\n\n\nThen inside of the else statement, I added the following:\n\n```\n else {\n\n             int firstItem; // this the first item, it will either be discarded (not included) or placed in the sack array (included)\n             firstItem = items[0];\n\n             items = Arrays.copyOfRange(items, 1, items.length); // for either recursive branch: remove the first item from the list\n\n             recknapSack(capacity, items, 1); // call recursive function, left branch, where item is discarded and not placed in sack\n\n             // prepare for right branch, where item is placed in sack\n             capacity -= firstItem; // subtract the left most item weight from from capacity\n             int temp = pos;\n             sack[pos++] = firstItem; // place the item in the sack\n             System.out.println(\"First item \" + firstItem);\n             int ret = recknapSack(capacity, items, 2); // recursive right branch call, item is placed in sack, weight subtracted from capacity\n             if(ret != 0)\n             {\n                  System.out.println(\"Removing \" + sack[temp] + \" at position \" + (temp));\n                 sack[temp] = 0;\n                 pos = temp;\n             }\n\n\n      }\n```\n\n\nThis will keep the sack the same unless the capacity were not 0.  You are still removing everything from the sack if you find it to be 0, so if you need to store that information, I would suggest that in the situation where it does work, you store the sack into an ArrayList of arrays that will contain all of the perfect solutions.  If you need solutions in a situation where there is no perfect solution, you can also store every solution in there and have it ordered by the lowest capacity.\n\nHope that helps.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with SPECIFIC AMOUNT of items from different groups\r\n                \r\nSo this is a variation of the Knapsack Problem I came with the other day.\nIt is like a 0-1 Knapsack Problem where there are multiple groups and each item belongs to only one group. The goal is to maximize the profits subject to the constraints. In this case, a fixed number of items from each group have to be chosen for each group.\nIt is similar to the Multiple Choice Knapsack Problem, but in that case you only pick 1 of item of each group, in this one you want to pick ```\nx```\n amount of items of each group\nSo, each item has: value, weight and group\nEach group has an item count (Ex: if group A (or 0) has 2, the final solution needs to have 2 items of group A, no more no less)\nAnd and you also have a maximum capacity (not related to the groups)\nThis translates into:\n\n```\nvalues[i]```\n = The value of the ith element\n```\nweights[i]```\n = The weigth of the ith element\n```\ngroups[i]```\n = The group of the ith element\n```\nC```\n = Capacity\n```\nn```\n = Amount of elements\n```\nm```\n = Amount of groups\n```\ncount[j]```\n = Amount of items of group j\n\nI'm attempting a Recursive solution first and then I will try a Dynamic approach.\nAny solution would be appreciated (preferably Python, but anything will do :) ).\nUsefull links I found:\n\nTheorical solution of a similar problem\nFirst approach to the Multiple Choice Knapsack Problem\nMultiple Choice Knapsack Problem solved in Python\nKnapsack with count constraint\n\n    ", "Answer": "\r\nFull code also in: https://github.com/pabloroldan98/knapsack-football-formations\nExplanation after the code.\nThis code is for an example where you have a Fantasy League with a ```\nplayersDB```\n where each player has price (weight), points (value) and position (group); there is a list of ```\npossible_formations```\n (group variations); and a ```\nbudget```\n (W) you can't go over.\nFull code:\n\nmain.py:\n```\n  from group_knapsack import best_full_teams\n\n  playersDB = [\n      Player(name=\"Keylor Navas\", price=16, points=7.5, position=\"GK\"),\n      Player(name=\"Laporte\", price=23, points=7.2, position=\"DEF\"),\n      Player(name=\"Modric\", price=22, points=7.3, position=\"MID\"),\n      Player(name=\"Messi\", price=51, points=8.2, position=\"ATT\"),\n      ...\n  ]\n\n  possible_formations = [\n      [3, 4, 3],\n      [3, 5, 2],\n      [4, 3, 3],\n      [4, 4, 2],\n      [4, 5, 1],\n      [5, 3, 2],\n      [5, 4, 1],\n  ]\n\n  budget = 300\n\n\n  best_full_teams(playersDB, possible_formations, budget)\n```\n\n\ngroup_knapsack.py:\n```\n  import itertools\n\n  from MCKP import knapsack_multichoice_onepick\n\n\n  def best_full_teams(players_list, formations, budget):\n      formation_score_players = []\n\n      for formation in formations:\n          players_points, players_prices, players_comb_indexes = players_preproc(\n              players_list, formation)\n\n          score, comb_result_indexes = knapsack_multichoice_onepick(\n              players_prices, players_points, budget)\n\n          result_indexes = []\n          for comb_index in comb_result_indexes:\n              for winning_i in players_comb_indexes[comb_index[0]][comb_index[1]]:\n                  result_indexes.append(winning_i)\n\n          result_players = []\n          for res_index in result_indexes:\n              result_players.append(players_list[res_index])\n\n          formation_score_players.append((formation, score, result_players))\n\n          print(\"With formation \" + str(formation) + \": \" + str(score))\n          for best_player in result_players:\n              print(best_player)\n          print()\n          print()\n\n      formation_score_players_by_score = sorted(formation_score_players,\n                                                key=lambda tup: tup[1],\n                                                reverse=True)\n      for final_formation_score in formation_score_players_by_score:\n          print((final_formation_score[0], final_formation_score[1]))\n\n      return formation_score_players\n\n\n  def players_preproc(players_list, formation):\n      max_gk = 1\n      max_def = formation[0]\n      max_mid = formation[1]\n      max_att = formation[2]\n\n      gk_values, gk_weights, gk_indexes = generate_group(players_list, \"GK\")\n      gk_comb_values, gk_comb_weights, gk_comb_indexes = group_preproc(gk_values,\n                                                                       gk_weights,\n                                                                       gk_indexes,\n                                                                       max_gk)\n\n      def_values, def_weights, def_indexes = generate_group(players_list, \"DEF\")\n      def_comb_values, def_comb_weights, def_comb_indexes = group_preproc(\n          def_values, def_weights, def_indexes, max_def)\n\n      mid_values, mid_weights, mid_indexes = generate_group(players_list, \"MID\")\n      mid_comb_values, mid_comb_weights, mid_comb_indexes = group_preproc(\n          mid_values, mid_weights, mid_indexes, max_mid)\n\n      att_values, att_weights, att_indexes = generate_group(players_list, \"ATT\")\n      att_comb_values, att_comb_weights, att_comb_indexes = group_preproc(\n          att_values, att_weights, att_indexes, max_att)\n\n      result_comb_values = [gk_comb_values, def_comb_values, mid_comb_values,\n                            att_comb_values]\n      result_comb_weights = [gk_comb_weights, def_comb_weights, mid_comb_weights,\n                             att_comb_weights]\n      result_comb_indexes = [gk_comb_indexes, def_comb_indexes, mid_comb_indexes,\n                             att_comb_indexes]\n\n      return result_comb_values, result_comb_weights, result_comb_indexes\n\n\n  def generate_group(full_list, group):\n      group_values = []\n      group_weights = []\n      group_indexes = []\n      for i, item in enumerate(full_list):\n          if item.position == group:\n              group_values.append(item.points)\n              group_weights.append(item.price)\n              group_indexes.append(i)\n      return group_values, group_weights, group_indexes\n\n\n  def group_preproc(group_values, group_weights, initial_indexes, r):\n      comb_values = list(itertools.combinations(group_values, r))\n      comb_weights = list(itertools.combinations(group_weights, r))\n      comb_indexes = list(itertools.combinations(initial_indexes, r))\n\n      group_comb_values = []\n      for value_combinations in comb_values:\n          values_added = sum(list(value_combinations))\n          group_comb_values.append(values_added)\n\n      group_comb_weights = []\n      for weight_combinations in comb_weights:\n          weights_added = sum(list(weight_combinations))\n          group_comb_weights.append(weights_added)\n\n      return group_comb_values, group_comb_weights, comb_indexes\n```\n\n\nMCKP.py:\n```\n  import copy\n\n\n  def knapsack_multichoice_onepick(weights, values, max_weight):\n      if len(weights) == 0:\n          return 0\n\n      last_array = [-1 for _ in range(max_weight + 1)]\n      last_path = [[] for _ in range(max_weight + 1)]\n      for i in range(len(weights[0])):\n          if weights[0][i] < max_weight:\n              if last_array[weights[0][i]] < values[0][i]:\n                  last_array[weights[0][i]] = values[0][i]\n                  last_path[weights[0][i]] = [(0, i)]\n\n      for i in range(1, len(weights)):\n          current_array = [-1 for _ in range(max_weight + 1)]\n          current_path = [[] for _ in range(max_weight + 1)]\n          for j in range(len(weights[i])):\n              for k in range(weights[i][j], max_weight + 1):\n                  if last_array[k - weights[i][j]] > 0:\n                      if current_array[k] < last_array[k - weights[i][j]] + \\\n                              values[i][j]:\n                          current_array[k] = last_array[k - weights[i][j]] + \\\n                                             values[i][j]\n                          current_path[k] = copy.deepcopy(\n                              last_path[k - weights[i][j]])\n                          current_path[k].append((i, j))\n          last_array = current_array\n          last_path = current_path\n\n      solution, index_path = get_onepick_solution(last_array, last_path)\n\n      return solution, index_path\n\n\n  def get_onepick_solution(scores, paths):\n      scores_paths = list(zip(scores, paths))\n      scores_paths_by_score = sorted(scores_paths, key=lambda tup: tup[0],\n                                     reverse=True)\n\n      return scores_paths_by_score[0][0], scores_paths_by_score[0][1]\n```\n\n\nplayer.py:\n```\n  class Player:\n      def __init__(\n              self,\n              name: str,\n              price: float,\n              points: float,\n              position: str\n      ):\n          self.name = name\n          self.price = price\n          self.points = points\n          self.position = position\n\n      def __str__(self):\n          return f\"({self.name}, {self.price}, {self.points}, {self.position})\"\n\n      @property\n      def position(self):\n          return self._position\n\n      @position.setter\n      def position(self, pos):\n          if pos not in [\"GK\", \"DEF\", \"MID\", \"ATT\"]:\n              raise ValueError(\"Sorry, that's not a valid position\")\n          self._position = pos\n\n      def get_group(self):\n          if self.position == \"GK\":\n              group = 0\n          elif self.position == \"DEF\":\n              group = 1\n          elif self.position == \"MID\":\n              group = 2\n          else:\n              group = 3\n          return group\n```\n\n\n\nExplanation:\nOkay,so I managed to find a solution translating what was here: Solving the Multiple Choice Knapsack Problem from ```\nC++```\n to ```\nPython```\n. My solution also gives the path that got you to that solution. It uses Dynamic Programming and it's very fast.\nThe input data, instead of having ```\ngroups[i]```\n, has the weights and the values  as a list of lists, where every list inside represent the values of each group:\n\n```\nweights[i] = [weights_group_0, weights_group_1, ...]```\n\n```\nvalues[i] = [values_group_0, values_group_1, ...]```\n\n\nWhere:\n\n```\nweights_group_i[j]```\n = The weigth of the ```\nj```\nth element of the ```\ni```\nth group\n```\nvalues_group_i[j]```\n = The value of the ```\nj```\nth element of the ```\ni```\nth group\n\nThose would be the inputs of ```\nknapsack_multichoice_onepick```\n. Here is an example:\n```\n# Example\nvalues = [[6, 10], [12, 2], [2, 3]]\nweights = [[1, 2], [6, 2], [3, 2]]\nW = 7\n\nprint(knapsack_multichoice_onepick(weights, values, W))  # (15, [(0, 1), (1, 1), (2, 1)])\n```\n\nAfter that I followed @user3386109 's suggestion and did the combinations with the indexes. The group preprocesing methods are ```\nplayers_preproc```\n, ```\ngenerate_group```\n and ```\ngroup_preproc```\n.\nAgain, this code is for an example where you have a Fantasy League with a ```\nplayersDB```\n where each player has price (weight), points (value) and position (group); there is a list of ```\npossible_formations```\n (group variations); and a ```\nbudget```\n (W) you can't go over.\nThe ```\nbest_full_teams```\n method prints everything and uses all the previous ones.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "questions about knapsack?\r\n                \r\nGood day,\n\nThe knapsack algorithms doesn't quite \"click\" in my head. I know how to answer the knapsack problem questions of different variations (0-1 knapsack, spice-carrying knapsack etc) very well, yet I don't exactly understand the algorithm itself; and I would love to fill in the gap\n\nTo keep my question less vague, I broke my question down to a few subquestions. Also Here is my typical answer to the knapsack problem at the exam,\n\n\n  Construct X-dimensional matrix (where X is a number of variables to keep an eye on). From point 0 {0,0,...0}, calculate neighbouring nodes, and then from the results obtained, will the next diagonal point in the matrix with the result giving by far the most optimal solution. Repeat until all considered options in the algorithm are exahusted \n\n\n\nHow do we know the knapsack algorithm works (aside from empirical observations)? In particular, how do we exactly know that there isn't an optional configuration considered s.t. it yields a more optimal result than our algorithm returns in the end?\nUsing the \"X-dimensional matrix\" seems very redundant memory usage-wise, is there a more optimal data structure for the knapsack problem? Perhaps a min-max binary tree (something that \"seems\" more optimal for this case)\nSuppose we have a very large knapsack. Wouldn't that be more efficient to fill up the knapsack with a greedy approach (with item giving the best ratio), until there is only very little space left? In my mind, until here is ```\n2*(largest item)```\n of space left?\n\n\nCheers\n    ", "Answer": "\r\n1) Since the knapsack algorithm is a greedy algorithm, we know that the algorithm has the greedy choice property (also makes a choice for some optimal solution) and it has optimal substructure. Thus there could not be a more optimal result because our algorithm always chooses the optimal decision.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Need help on 0/1 knapsack-problem in C with highest \"value\" solution, but least \"weight\" wenn same (highest) \"value\"\r\n                \r\nI am already puzzling for two weeks programming a knapsack problem in C.\nSince I didn't manage to get it working with structs directly, I have made a solution with an extra array. If you know how to use the structs directly, that would be great!\nBut the main problem is, that when I get multiple solutions with the same value, I'd want to only get the solution with the least weight.\nMy code till now:\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define TEAMS 5 \n#define max_players 20\n\ntypedef struct Team\n{\n    char name [10];\n    int players;\n    bool Is_Playing;\n    int points;\n} Team;\n\nstruct Team one = { \"Ones\", 12, true, 18 };\nstruct Team two = { \"Twos\", 4, true, 10 };\nstruct Team three = { \"Threes\", 5, true, 9 };\nstruct Team four = { \"Fours\", 12, true, 22 };\nstruct Team five = { \"Fives\", 8, true, 15 };\n\ntypedef struct selection_entry\n{\n    int points;\n    int team;\n    struct selection_entry *prev;\n} selection_entry;\n\nTeam *teams[TEAMS] = { &one, &two, &three, &four, &five };\n\nint selection(int players[], const int *selection_points, size_t n,\n        int capacity, int **solution)\n{\n    int i, j;\n    selection_entry **table;\n    int result;\n    selection_entry *head;\n\n    /* Allocate the table */\n    table = malloc((n + 1) * sizeof(selection_entry *));\n    for (i = 0; i <= n; i++) {\n        table[i] = malloc((capacity + 1) * sizeof(selection_entry));\n    }\n\n    /* Calculate the points and build chains */\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= capacity; j++) {\n            if (i == 0 || j == 0) {\n                /* Initialising the first row or column */\n                table[i][j].points = 0;\n                table[i][j].team = 0;\n                table[i][j].prev = NULL;\n            }\n            else if (players[i - 1] <= j) {\n                /* Can add team */\n                if (selection_points[i - 1] + table[i - 1][j - players[i - 1]].points\n                        > table[i - 1][j].points) {\n                    /* Add team */\n                    table[i][j].points = selection_points[i - 1] + table[i - 1][j - players[i - 1]].points;\n                    table[i][j].team = i - 1;\n                    table[i][j].prev = &table[i - 1][j - players[i - 1]];\n                }\n                else {\n                    /* Don't add team */\n                    table[i][j].points = table[i - 1][j].points;\n                    table[i][j].team = table[i - 1][j].team;\n                    table[i][j].prev = table[i - 1][j].prev;\n                }\n            }\n            else {\n                /* Don't add team */\n                table[i][j].points = table[i - 1][j].points;\n                table[i][j].team = table[i - 1][j].team;\n                table[i][j].prev = table[i - 1][j].prev;\n            }\n        }\n    }\n\n    /* Read back the solution */\n    *solution = calloc(n, sizeof(int));\n    for (i = 0, head = &table[n][capacity];\n            head->prev != NULL;\n            head = head->prev, i++) {\n        (*solution)[head->team] = 1;\n    }\n\n    result = table[n][capacity].points;\n    for (i = 0; i <= n; i++) {\n        free(table[i]);\n    }\n    free(table);\n    return result;\n}\n\nint GetSelectionArraySize()\n{\n    int s=0;\n    for (int i = 0; i < TEAMS; i++)\n    {\n        if (teams[i]->Is_Playing)\n        {\n        s++;\n        }\n    }\n    return s;\n}\n\nvoid main()\n{\n    int a_size = GetSelectionArraySize();\n    int players[a_size];\n    int selection_points[a_size];\n    int i, j=0;\n    for (int i = 0; i < TEAMS; i++)\n    {\n        if (teams[i]->Is_Playing)\n        {\n            players[j] = teams[i]->players;\n            selection_points[j] = teams[i]->points;\n            j++;\n        }\n    }\n    \n    const int capacity = max_players;\n    const size_t n = sizeof(players) / sizeof(players[0]);\n    int *solution;\n    int points = selection(players, selection_points, n, capacity, &solution);\n    fprintf(stdout, \"Value: %d\\n\", points);\n    for (i = 0; i < n; i++)\n    {\n        if (solution[i])\n            {\n            fprintf(stdout, \"Team %d with %d players and %d points.\\n\", i, players[i], selection_points[i]);\n            }\n    }\n    free(solution);\n}\n```\n\nProblems:\nI can't figure out why this isn't working properly and how I get it to give me the best solution (highest points but least players within the maximum specified number of players).\nSub-problem:\nThe array-workaround annoys me, but I fail in making it work with the original arrays of structs directly...\nThank you very much in advance!!!\nKindest regards!\nRalf\n    ", "Answer": "\r\nI'm not going into detail of your code, but instead lets have a look at the problem and the knapsack-like solution.\nBasically, the relevant properties of your solution are ```\nvalue```\n and ```\nweight```\n, where ```\nweight```\n is constrained and a solution A is better than solution B, if ```\nA.value > B.value```\n or if ```\nA.value = B.value AND A.weight < B.weight```\n as long as A and B satisfy the constraint.\nSo, given a list of potential items ```\n[item1, [others...]]```\n, where a solution including items1 is possible, you need to find the better solution\n```\nsubresult1 = solve([others...], weightconstraint - item1.weight)\ncandidate1 = (subresult1.value + item1.value, subresult1.weight + item1.weight)\ncandidate2 = solve([others...], weightconstraint)\nif (candidate1.value > candidate2.value) return candidate1\nif (candidate1.value == candidate2.value && candidate1.weight < candidate2.weight) return candidate1\nreturn candidate2\n```\n\nI hope this pseudo-code is clear enough to explain the logic to be implemented.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "modeling Knapsack with petri net\r\n                \r\nI am new at petri net. what are the steps of drawing a petri net graph for Knapsack problem?\n\nIs petri net suitable for modeling this problem?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem in R: How to use loop in R to check for each item instead of whole column\r\n                \r\nI've been taking a \"Simulation\" course in my uni and now have a task to solve a knapsack problem.\nBasically I have 3 transporters (g1, g2, g3) which each can carry different weights, on top of that you can put each item 5 times in a transporter. My idea is to use a while loop so it would run as long as the total weight is below the maximum weight. And that the program would pick the item with the highest relation first as long as their pick index doesnt equal 0.\nBut here I got stuck, it seems that it takes all items of the column at once per loop and also doesnt stop when the value exceeds the maximum (it returns weight = 748 at the end).\nHence: how do I get the loop to just check per item and not the whole column and how can I ensure that it doesnt exceed the weight limit?\nThanks a lot for your help in advance!!\n```\nWeightIndex<- c(2, 3, 4, 1, 7, 5, 8, 15, 9, 11) #indexing the weight of each item\nWorthIndex <-c(3, 4, 5, 1, 3, 7, 3, 21, 11, 10)#indexing the worth of each item\nRelation <- WorthIndex/WeightIndex #creates a relation between weight/worth of the item\nPickIndex <- rep(5,10) #each item can be picked 5 times\n\n\nItems <-cbind(ItemIndex, WeightIndex, WorthIndex, Relation, PickIndex) #binding the indexes to a matrix\n\n\ng1 <- 300 #Max weight of carrier 1\ng2 <- 250 #max weight of carrier 2\ng3 <- 200 #max weight of carrier 3\n\nItemsSorted<-Items[order(Items[,4],decreasing=TRUE),] #Sorts the items after the highest Relation of weight to worth\n\nItemsSorted1 <- ItemsSorted #creates a copied matrix for the first loop\n\nTWE1 <-0#Total Weight  of carrier 1\n\nTWO1 <-0 #total worth  of carrier 1\n\n\nprint (ItemsSorted1) #bug check\n\nwhile (TWE1 <= g1){    #while the condition is true, the program should execute a for loop\n  \n\n    if(ItemsSorted1[,5]!= 0) #in theory the loop should go bottom down and take the items with the highest price/weight relation first and it should only take items whose pick-index doesnt equal 0\n      {  \n   TWE1<-TWE1+ItemsSorted1[,2] #the weight of the taken item gets appended to the list of the total weight\n   TWO1 <-TWO1 + ItemsSorted1[,3] #the worth of the taken item gets appended to the list of total worth\n    ItemsSorted1[,5] <- ItemsSorted1[,5] - 1 #deducts 1 from the pick- Index as the item has been taken\n    TWE1 <- sum(TWE1) #turns the list into one number\n    TWO1 <- sum(TWO1) #turns the list into one number\n    print(TWE1)    #bug check\n    }\n  \n}\n\n\nprint(paste(\"Total weight C1\",TWE1))\nprint(paste(\"Total worth C1\",TWO1))\nprint(ItemsSorted1)``` \n```\n\n    ", "Answer": "\r\nSkimming your code, it looks like you're missing some way to index which number you're referencing in the ```\nItemsSorted1```\n matrix. Your comment after the ```\nwhile```\n statement says you're expecting the code to run a for-loop, but as written, it doesn't have a variable to increment.\nYou might be able to do something like the following to get at your expected behavior:\n```\ni <- 1 # create row-id variable to keep track of position in ItemsSorted1\n\nwhile (TWE1 <= g1){    \n   if(ItemsSorted1[i,5]!= 0){ # go item by item through the sorted list;\n      TWE1<-TWE1+ItemsSorted1[i,2] #the weight of the taken item gets appended to the list of the total weight\n      TWO1 <-TWO1 + ItemsSorted1[i,3] #the worth of the taken item gets appended to the list of total worth\n      ItemsSorted1[i,5] <- ItemsSorted1[i,5] - 1 #deducts 1 from the pick- Index as the item has been taken\n      TWE1 <- sum(TWE1) #turns the list into one number\n      TWO1 <- sum(TWO1) #turns the list into one number\n      print(TWE1)    #bug check\n   }\n   else if (i<nrow(ItemsSorted1){\n      i <- i+1 \n   }else{\n      break\n   }\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple Set Knapsack Variation\r\n                \r\nI have been trying to find a variation on the knapsack problem that fits my problem, but either I don't understand the definitions on wikipedia well enough (likely) or I am looking in the wrong places.\n\nMy problem requires the maximization of value across multiple sets of data. Given 3 sets of data, I want to be able to pick exactly 2 members from each set while maximizing the profit. \n\nDoes anyone know of a variation of the knapsack problem that I can look into to do this?\n\nThank you\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "C++ implementation of knapsack branch and bound\r\n                \r\nI am trying to a C++ implementation of this knapsack problem using branch and bounding.  There is a Java version on this website here: Implementing branch and bound for knapsack\n\nI'm trying to make my C++ version print out the 90 that it should, however it's not doing that, instead, it's printing out 5.\n\nDoes anyone know where and what the problem may be?\n\n```\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nstruct node\n{\n    int level;\n    int profit;\n    int weight;\n    int bound;\n};\n\nint bound(node u, int n, int W, vector<int> pVa, vector<int> wVa)\n{\n    int j = 0, k = 0;\n    int totweight = 0;\n    int result = 0;\n\n    if (u.weight >= W)\n    {\n        return 0;\n    }\n    else\n    {\n        result = u.profit;\n        j = u.level + 1;\n        totweight = u.weight;\n\n        while ((j < n) && (totweight + wVa[j] <= W))\n        {\n            totweight = totweight + wVa[j];\n            result = result + pVa[j];\n            j++;\n        }\n\n        k = j;\n\n        if (k < n)\n        {\n            result = result + (W - totweight) * pVa[k]/wVa[k];\n        }\n        return result;\n    }\n}\n\nint knapsack(int n, int p[], int w[], int W)\n{\n    queue<node> Q;\n    node u, v;\n    vector<int> pV;\n    vector<int> wV;\n    Q.empty();\n\n    for (int i = 0; i < n; i++)\n    {\n        pV.push_back(p[i]);\n        wV.push_back(w[i]);\n    }\n\n    v.level = -1; \n    v.profit = 0;\n    v.weight = 0;\n\n    int maxProfit = 0;\n\n    //v.bound = bound(v, n, W, pV, wV);\n    Q.push(v);\n\n    while (!Q.empty())\n    {\n        v = Q.front();\n        Q.pop();\n\n        if (v.level == -1)\n        {\n            u.level = 0;\n        }\n        else if (v.level != (n - 1))\n        {\n            u.level = v.level + 1;\n        }\n\n        u.weight = v.weight + w[u.level];\n        u.profit = v.profit + p[u.level];\n\n        u.bound = bound(u, n, W, pV, wV);\n\n        if (u.weight <= W && u.profit > maxProfit)\n        {\n            maxProfit = u.profit;\n        }\n\n        if (u.bound > maxProfit)\n        {\n            Q.push(u);\n        }\n\n        u.weight = v.weight;\n        u.profit = v.profit;\n\n        u.bound = bound(u, n, W, pV, wV);\n\n        if (u.bound > maxProfit)\n        {\n            Q.push(u);\n        }\n    }\n    return maxProfit;\n}\n\nint main()\n{\n    int maxProfit;\n    int n = 4;\n    int W = 16;\n    int p[4] = {2, 5, 10, 5};\n    int w[4] = {40, 30, 50, 10};\n\n    cout << knapsack(n, p, w, W) << endl;\n\n    system(\"PAUSE\");\n}\n```\n\n    ", "Answer": "\r\nI think you have put the profit and weight values in the wrong vectors. Change:\n\n```\nint p[4] = {2, 5, 10, 5};\nint w[4] = {40, 30, 50, 10};\n```\n\n\nto:\n\n```\nint w[4] = {2, 5, 10, 5};\nint p[4] = {40, 30, 50, 10};\n```\n\n\nand your program will output 90.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Adding quantity-per-item constraint to knapsack algorithm\r\n                \r\nI am working knapsack problem. With online solution available i have done this so far\n\n```\n        private void main()\n        {\n        var random = new Random();\n        var products = new List<Product>();\n        products.Add(new Product(\"Coil1\", 0, 0, 5.6));\n        products.Add(new Product(\"Coil2\", 0, 0, 5.91));\n        products.Add(new Product(\"Coil3\", 0, 0, 5));\n        products.Add(new Product(\"Coil4\", 0, 0, 5));\n        products.Add(new Product(\"Coil5\", 0, 0, 5));\n        products.Add(new Product(\"Coil6\", 0, 0, 5));\n        products.Add(new Product(\"Coil7\", 0, 0, 5));\n        products.Add(new Product(\"Coil8\", 0, 0, 5));\n        products.Add(new Product(\"Coil9\", 0, 0, 5.92));\n        products.Add(new Product(\"Coil10\", 0, 0, 15));\n\n        var clock = new Stopwatch();\n        clock.Start();\n        var solution = Profit.OptimizedList(products, 7);\n        clock.Stop();\n        Console.WriteLine(\"Time (ms): \" + clock.ElapsedMilliseconds);\n        foreach (var product in solution)\n        {\n            if (product.Value > 0)\n            {\n                Console.WriteLine(product.Key.Name + \": \" + product.Value + \" : Weight - \" + product.Key.Weight);\n            }\n        }\n     }\n\n\n     public class Profit\n       {\n         public static IDictionary<Product, int> OptimizedList(IEnumerable<Product> products, double maxWeight)\n         {\n        //SOLVER INITIALIZE\n        var solver = SolverContext.GetContext();\n        solver.ClearModel();\n        var model = solver.CreateModel();\n\n        var decisions = products.Select(\n           it => new Decision(Domain.IntegerNonnegative, it.Name));\n        model.AddDecisions(decisions.ToArray());\n\n        //GOAL\n        var objective = new SumTermBuilder(decisions.Count());\n        foreach (var product in products)\n        {\n            var productDecision = model.Decisions.First(\n               it => it.Name == product.Name);\n            objective.Add(productDecision * product.Weight);\n        }\n        model.AddGoal(\"Profit\", GoalKind.Maximize, objective.ToTerm());\n\n\n        //CONTRAINT 2\n        var weightComponents = new SumTermBuilder(decisions.Count());\n        foreach (var product in products)\n        {\n            var productDecision = model.Decisions.First(\n               it => it.Name == product.Name);\n            weightComponents.Add(productDecision * product.Weight);\n        }\n\n        var weightConstraint = weightComponents.ToTerm() <= maxWeight;\n        model.AddConstraint(\"Weight\", weightConstraint);\n\n\n        //SOLVE\n        var solution = solver.Solve();\n\n        var orders = new Dictionary<Product, int>();\n        if (solution.Quality == SolverQuality.Optimal)\n        {\n            foreach (var product in products)\n            {\n                var productDecision = model.Decisions.First(it => it.Name == product.Name);\n                orders.Add(product, (int)productDecision.ToDouble());\n            }\n        }\n\n        return orders;\n    }\n}\n\npublic class Product\n{\n    public Product(string name, double cost, double price, double weight)\n    {\n        this.Name = name;\n        this.Cost = cost;\n        this.Price = price;\n        this.Weight = weight;\n    }\n\n    public string Name { get; private set; }\n    public double Cost { get; private set; }\n    public double Price { get; private set; }\n    public double Weight { get; private set; }\n    public double Margin\n    {\n        get { return this.Price - this.Cost; }\n    }\n}\n```\n\n\nNow i want to add a contraint that, only one quantity per item is allowed. I created a contraint like this,\n\n```\n        //CONTRAINT 1\n        var CountComponents = new SumTermBuilder(decisions.Count());\n        foreach (var product in products)\n        {\n            var productDecision = model.Decisions.First(\n               it => it.Name == product.Name);\n            CountComponents.Add(productDecision);\n        }\n\n        var CountConstraint = CountComponents.ToTerm() <= 1;\n        model.AddConstraint(\"Count\", CountConstraint);\n```\n\n\nbut it is taking only one item in total (0-1 Knapsack problem).\n\nHow to add contraint so that only specified quantity per item is allowed in the optimization?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack constraint python\r\n                \r\nLets say I have a list of tuples representing basketball players and their name, position, cost, and their projected points,\n\n```\nlistOfPlayers = [\n                 (\"Player1\",\"PG\",Cost,projectedPoints),\n                 (\"Player2\",\"PG\",Cost,projectedPoints),\n                 (\"Player3\",\"SG\",Cost,projectedPoints),\n                 (\"Player4\",\"SG\",Cost,projectedPoints),\n                 (\"Player5\",\"SF\",Cost,projectedPoints),\n                 (\"Player6\",\"SF\",Cost,projectedPoints),\n                 (\"Player7\",\"PF\",Cost,projectedPoints),\n                 (\"Player8\",\"PF\",Cost,projectedPoints),\n                 (\"Player9\",\"C\",Cost,projectedPoints),\n                 (\"Player10\",\"C\",Cost,projectedPoints) \n                ]\n```\n\n\nAssume all of the names, costs, and projected points are variable.\n\nI have a traditional knapsack problem working, they can sort and pack a knapsack based on a given weight.  But this does not account for the positions.\nI was wondering if there is a way to edit the knapsack code to only include one of every position, i.e., (pg, sg, sf, pf, c). \n\nCan a traditional 0/1 knapsack do this or do i need to switch to something else?\n    ", "Answer": "\r\nThis is called the \"multiple-choice knapsack problem\".\n\nYou can use an algorithm similar to the dynamic programming solution for the 0/1 knapsack problem.\n\nThe 0/1 knapsack problem's solution is as follows: (from Wikipedia)\n\n\n  Define ```\nm[i, w]```\n to be the maximum value that can be attained with weight less than or equal to ```\nw```\n using items up to ```\ni```\n.\n  We can define ```\nm[i, w]```\n recursively as follows:\n\n```\nm[i, w] = m[i-1, w] if w_i > w   (new item is more than current weight limit)\nm[i, w] = max(m[i-1, w], m[i-1, w-w_i] + v_i) if w_i <= w.\n```\n\n  \n  The solution can then be found by calculating ```\nm[n,W]```\n. To do this efficiently we can use a table to store previous computations.\n\n\nNow the extension is just to find the maximum of all choices instead.\n\nFor ```\nn```\n players available as choices for some position ```\ni```\n (with ```\nc_i_j```\n being the cost of choice ```\nj```\n and ```\np_i_j```\n being the points), we'd have:\n\n```\nm[i, c] = max(m[i-1, c],\n              m[i-1, c-c_i_1] + p_i_1   if c_i_1 <= c, otherwise 0,\n              m[i-1, c-c_i_2] + p_i_2   if c_i_2 <= c, otherwise 0,\n              ...\n              m[i-1, c-c_i_n] + p_i_n   if c_i_n <= c, otherwise 0)\n```\n\n\nSo, say we have:\n\n```\nName     Position  Cost  Points\nPlayer1  PG        15    5\nPlayer2  PG        20    10\nPlayer3  SG        9     7\nPlayer4  SG        8     6\n```\n\n\nThen we'd have 2 positions \"PG\" and \"SG\" and each position will have 2 choices.\n\nThus, for position \"PG\" (at ```\ni=1```\n), we'll have:\n\n```\nm[i, c] = max(m[i-1, c],\n              m[i-1, c-15] + 5    if 15 <= c, otherwise 0,\n              m[i-1, c-20] + 10   if 20 <= c, otherwise 0)\n```\n\n\nAnd for position \"SG\" (at ```\ni=2```\n), we'll have:\n\n```\nm[i, c] = max(m[i-1, c],\n              m[i-1, c-9] + 7    if 9 <= c, otherwise 0,\n              m[i-1, c-8] + 6    if 8 <= c, otherwise 0)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "i made a code for knapsack problem but the system wont tell me whats wrong in my code only tells its wrong\r\n                \r\n*this is my first time posting and have been told that this place is like heaven so Hey everyone :)\ni have this problem with an assigment the  knapsack problem which says\nA thief finds much more loot than his bag can fit.Help him to find the most valuable combination of items assuming that any fraction of a loot item can be put into his bag.The first line of the input contains the number n of items and the capacity W of a knapsack. The next n lines define the values and weights of the items . The i-th line contains integers vi and wi—the value and the weight of i-th item, respectively.\nand i made this code might not be the easiest to read as im a beginer but basicly\nn=number of items   back= the storage limit of the bag  and three lists and x is the ratio of value to weight and tot=is the total value\nthis is the error I get\nFailed case #5/13: Wrong answer\nwrong output format: list index out of range\nhope u guys can help me and one day I be the one tha helps\n\n```\nn,back=map(int,input().split())\nfor i in range(n):\n    v,w=map(int,input().split())\n    values.append(v)\n    weight.append(w)\n    x.append(v/w)\nu=x.index(max(x))\nwhile x !=[]:\n    u=x.index(max(x))\n    if weight[u]< back:\n        back-=weight[u]\n        tot+=values[u]\n        values.pop(u)\n        weight.pop(u)\n        x.pop(u)\n\n    elif weight[u]== back:\n        back-=weight[u]\n        tot+=values[u]\n\n        break\n    elif weight[u]>back:\n        l=weight[u]/back\n        tot+=values[u]/l\n\n        break\n    else:\n        print(\"There is something wrong\")\n        break\nprint(round(float(tot),0))```\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Bin Packing / Knapsack / Perfect Sum Problem With Target Item Quantities\r\n                \r\n\nThere is a set of items, each with a specific weight\nThere are a number of bins each with a limited weight capacity\nFor each item there is a target percentage of its quantity across all bins (e.g. if there are 4 items, 10% item 1, 50% item 2, 20% item 3, 20% item 4)\nItems can be repeated to pack the bins\n\nI need to find the packing solution such that:\n\nthere is zero capacity left in the bins\nthe resulting item quantities are as close as possible to the target percentages per item\n\nThe ideas that come to mind at the moment are a sort of brute force perfect sum algorithm that finds all possible combinations of items to perfectly pack the bins and then returns the one that is closest to the target percentages. This idea of \"closest to target percentages\" can be defined as the least mean square error to the input target percentages. However, this solution will take a long time for numerous / large bins.\nAn unbounded, multi-dimensional, multiple Knapsack problem also comes to mind where capacity is one dimension, and the target percentages per item are the others. Not sure about this.\nAny help / ideas would be greatly appreciated!\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack formula using only weights as the recursion variable\r\n                \r\nI have developed a recursive formula for knapsack problem on my own without any knowledge of present solutions. Please tell me whether it is right or wrong and correct it.Thanks in advance.\n\n```\nB(S) = max (B (s-w(i)) + b(w(i)) )\n```\n\n\nfor all ```\ni```\n belonging to ```\nn```\n;\nnotations are as usual . ```\nS```\n is capacity,```\nB```\n is the answer to knapsack.\n    ", "Answer": "\r\nI do not want to give you straight answer, but to direct you on the flaws of your formula, and let you figure out how to solve them.\n\n\nWell, if you do not address the value, something must be wrong - otherwise, you just simply lose information. If you chose to \"take\" the item (```\nB(s-w(i))```\n) what happens to the current value?\nIn addition, what is ```\ni```\n? How do you change ```\ni```\n over time?\nWhen talking about recursive formula, you must also mention a stop clause for it.\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Branch & Bound Knapsack Algorithm\r\n                \r\nI have to implement an algorithm for the best first, branch and bound knapsack problem. However, my algorithm doesn't give me the right answer. My KWF2 function to find out the upper bound works, but calling knapsack(0,0,0,n) gives me a very off answer of 5, when it should be 90.\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nint C;\nint *w;\nint *p;\nint maxprofit;\nint *include;\nint *bestset;\nfloat *x;\nint numbest;\n\nvoid knapsack(int i, int weight, int profit, int n);\nint promising(int i, int weight, int profit, int n);\nint KWF2(int i, int weight, int profit, int n);\n\nint main(int argc, char **argv){\n\n    FILE *in = fopen(argv[1],\"r\");\n    int n;\n    fscanf(in,\"%d,%d\\n\",&n,&C);\n    //scan in items\n    w = malloc(sizeof(int)*(n+1));\n    p = malloc(sizeof(int)*(n+1));\n    include = malloc(sizeof(int)*(n+1));\n    bestset = malloc(sizeof(int)*(n+1));\n    x = malloc(sizeof(float) * (n+1));\n\n    float ratio[n+1];\n\n    int i;\n    for(i = 0; i < n; i++){\n        fscanf(in,\"%d,%d\\n\",&w[i+1],&p[i+1]);\n        ratio[i+1] = (float)p[i+1] / (float)w[i+1];\n    }\n\n    //sort in decreasing p/w ratio\n    int temp_w,temp_p;\n    float temp_r;\n    int j;\n    for(i = 1; i <= n; i++){\n        for(j = i + 1; j <= n; j++){\n            if(ratio[i] < ratio[j]){\n                temp_w = w[i];\n                temp_p = p[i];\n                temp_r = ratio[i];\n\n                w[i] = w[j];\n                p[i] = p[j];\n                ratio[i] = ratio[j];\n\n                w[j] = temp_w;\n                p[j] = temp_p;\n                ratio[j] = temp_r;\n            }\n        }\n    }\n\n    //printf(\"bound of 1 = %d\",KWF2(1,2,40,n));\n    maxprofit = 0;\n    numbest = 0;\n    //printf(\"node 2 bound = %d\\n\",KWF2(2,2,40,n));\n    knapsack(0,0,0,n);\n    //printf(\"maxprofit = %d\\n\",maxprofit);\n\n    fclose(in);\n    return 0;\n}\n\nvoid knapsack(int i, int weight, int profit, int n){\n    printf(\"profit= %d\\n\",profit);\n    if(weight <= C && profit > maxprofit){\n        maxprofit = profit;\n        numbest = i;\n        int j;\n        for(j = 0; j <= n; j++){\n            bestset[i] = include[i];\n        }\n    }\n    if(promising(i,weight,profit,n)){\n        include[i+1] = 1;\n        knapsack(i+1,profit+p[i+1],weight + w[i+1],n);\n        include[i+1] = 0;\n        knapsack(i+1,profit,weight, n);\n    }\n}\n\nint promising(int i, int weight, int profit, int n){\n\n    if(weight >= C) return 0;\n    int bound = KWF2(i+1,weight,profit,n);\n    //printf(\"bound = %d\\n\",bound);\n    if(bound > maxprofit) {\n        //printf(\"bound = %d\\n\",bound);\n        return 1;\n    }\n    else return 0;\n}\n\nint KWF2(int i, int weight, int profit, int n){\n\n    int weight1 = weight;\n    int bound = profit;\n    int j;\n\n    for(j = i; j <= n; j++){\n        x[j] = 0;\n    }\n\n    while(weight1 < C && (i <= n)){\n\n        if(weight1 + w[i] <= C){\n            x[i] = 1;\n            weight1 += w[i];\n            bound += p[i];\n        }\n        else{\n            x[i] = ((float)C-(float)weight1)/(float)w[i];\n            weight1 = C;\n            bound = bound + p[i] * x[i];\n        }\n        i++;\n    }\n    //printf(\"profit = %d\\n\",profit);\n    //printf(\"%d\\n\",profit+p[2]+(C-7)*p[3]/w[3]);\n    return bound;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Problem for returning the maximum value of knapsack\r\n                \r\n```\n#to avoid calculating those items which violates the terms and to only output , the ansewer satisfying the conditions , with the maximum weigth\ndef knapsack(w_list,v_list,i,i_w_1,v_w_1,w_cap):\n    counter = True\n    highest_value = None\n    if(i_w_1 + w_list[i] <= w_cap): #this is case when there is no problem\n        i_w_2 = i_w_1               #this is basically the evaluation part of the weights of new branch\n        v_w_2 = v_w_1\n        i_w_1 += w_list[i]\n        v_w_1 += v_list[i]\n        if(i == len(w_list) - 1):\n            print(i_w_1,v_w_1)\n            print(i_w_2,v_w_2)\n            max_value =  max(v_w_1,v_w_2)\n            if counter or highest_value <= max_value:\n                counter = False\n                highest_value = max_value\n                return highest_value\n        highest_value = knapsack(w_list,v_list,i+1,i_w_1,v_w_1,w_cap)\n        highest_value = knapsack(w_list,v_list,i+1,i_w_2,v_w_2,w_cap)\n\n    elif(i_w_1 + w_list[i] > w_cap):#in this case we have to check which to evaluate and which to not\n        if(i_w_1 <= w_cap): #this is basically the evaluation part of the weight of new branch\n            i_w_2 = i_w_1\n            v_w_2 = v_w_1\n        if(i == len(w_list) - 1):\n            print(i_w_2,v_w_2)\n            return\n        knapsack(w_list,v_list,i+1,i_w_2,v_w_2,w_cap)\n    return highest_value\n\nw_list =  [1,2]\nv_list = [10,20]\ni = 0\ni_w_1 = 0\nv_w_1 = 0 #let us suppose the initial value associated with our weights be zero\nw_cap = 3\nhighest_value = knapsack(w_list,v_list,i,i_w_1,v_w_1,w_cap)\nprint(highest_value)\n```\n\nI am simply printing all the weight combinations of the given weight capacity and i am returning the maximum possible value , but what is happening here ,that for one brach it returns maximum and as soon as the function call pops out from stack it returns None ,and then the maximum  of second branch is calculated and at end it is returning that only , i want to calculate the highest value by comparing all the branches\nOne way of doing this is by passing a global_var initialized to a value and then updating it and comparing , it , but how to do this by initializing a local inside function\nI see people on this community sometimes , show no sort of compassion for problem faced by beginners , i tried every other way but when i was not able to get a answer , i am posting it here\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Minimization of the Unbounded Knapsack with Dynamic Programming\r\n                \r\nI am curious if it is possible to modify (or use) a DP algorithm of the Unbounded Knapsack Problem to minimize the total value of items in the knapsack while making the total weight at least some minimum constraint C. \n\n\n\nA bottom-up DP algorithm for the maximization version of UKP:\n\n```\nlet w = set of weights (0-indexed)\n\nand v = set of values (0-indexed)\n\n    DP[i][j] = max{ DP[i-1][j], DP[i][j - w[i-1]] + v[i-1] }\n\nfor i = 0,...,N and j = 0,...,C\n\ngiven DP[0][j] = 0 and DP[i][0] = 0\n\nwhere N = amount of items\n\nand C = maximum weight\n\nDP[N][C] = the maximum value of items for a knapsack capacity of C \n```\n\n\n\n\nCan we make a minimization UKP ? If not, can anyone offer another solution or technique to solve a problem like this?\n\nThanks, Dan\n    ", "Answer": "\r\nYou'll have the new recurrence\n```\nDP[i][j] (i = 0, j = 0) = 0\nDP[i][j] (i = 0, j > 0) = infinity\nDP[i][j] (i > 0       ) = min{ DP[i-1][j], DP[i-1][max(0, j - w[i-1])] + v[i-1] },\n```\n\nwhich gives, for each ```\ni```\n and ```\nj```\n, the minimum value of items ```\n0..i-1```\n to make weight at least ```\nj```\n. ```\ninfinity```\n should be some sufficiently large value such that any legitimate value is smaller than ```\ninfinity```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Final weight in 0-1 knapsack?\r\n                \r\nHow do you find the final weight of the optimal set of the 0-1 knapsack problem's DP solution? Given a set of 'n' items, each having it's own weight and value.\n\n```\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector < pair <int, int> > arr;\nmap < pair <int, int>, int > hash_memo;\npair <int, int> temp;\n\nint knapsack(int N, int budget)\n{\n    int a, b=0;\n    pair <int, int> local;\n    if((!N) || (!budget)) return 0;\n    local.first = N;\n    local.second = budget;\n    if(hash_memo[local]) return hash_memo[local];\n\n    a = knapsack(N-1, budget);\n    if(budget >= arr[N-1].first)\n    {\n        b =  arr[N-1].second + knapsack(N-1, budget - arr[N-1].first);\n    }\n\n    if(a>b)\n    {\n        hash_memo[local] = a;\n        return a; \n    }\n    hash_memo[local] = b;\n    return b;\n}\n\nint main()\n{\nint budget, N, a, b;\n\n    while(1)\n    {\n        scanf(\"%d %d\", &budget, &N);\n        if((!budget) && (!N)) break;\n\n        arr.clear();\n        hash_memo.clear();\n        for(int i=0; i<N; i++)\n        {\n            scanf(\"%d %d\", &a, &b);\n            if(b==0) continue;\n            temp.first = a; temp.second = b;\n            arr.push_back(temp);\n        }\n\n        int max_value = knapsack(N, budget);\n        printf(\"%d\\n\", max_value);\n    }\n\nreturn 0;\n}\n```\n\n\nAbove is the code for 0-1 Knapsack problem where 'max_value' gives the final value of the optimal set. How do you find out 'max_weight'?\n'N' is the number of items, 'budget' is the maximum weight that can be considered.\n    ", "Answer": "\r\nReturn a pair of values containing the weight and value:\n\n```\npair<int, int> knapsack(int N, int budget)\n{\n    if((!N) || (!budget)) return pair<int, int>(0, 0);\n\n    pair<int, int> local(N, budget);\n    if(hash_memo[local].second) return hash_memo[local];\n\n    pair<int, int> b = pair<int, int>(0, 0);\n    pair<int, int> a = knapsack(N-1, budget);\n    if(budget >= arr[N-1].first)\n    {\n        pair<int, int> c = knapsack(N-1, budget - arr[N-1].first);\n        b = pair<int, int>(c.first + arr[N-1].first, c.second + arr[N-1].second);\n    }\n\n    if(a.second > b.second)\n    {\n        return hash_memo[local] = a;\n    }\n    return hash_memo[local] = b;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "01 knapsack problem with the limit of m items\r\n                \r\nThere is a backpack with a capacity of C, n items to be selected, each item has one and only one, and their size and value are ci and vi (i=1,2,... ,n), how to select items from the items under the condition of loading at most m items to maximize the total value in the backpack?\nCan someone tell me the specific idea of ​​this question, or is there any code to read?THS\n    ", "Answer": "\r\nYou should define the following function f(i,j,k) which gives you the maximum value  you can get by selecting exactly k items from the first i items (1,2..i) with maximum capacity of j.\naccording to our definition the transitions will be:\n```\nf(i , j , k) = max( t1 , t2 )\n\nt1 = f(i-i , j , k) // here we did not pick the i-th item\n\nt2 = vi + f(i-1 , j - ci , k-1)// here we picked the i-th item\n```\n\nthe result to your question will be max( f(n,C,i) ) where i=1,2...n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Comparison of BFS and DFS algorithm for the Knapsack problem\r\n                \r\nI am fairly new to python and I have a task which tells me to compare both algorithm time expended and space used in memory.\nI have coded both algorithms and ran them both. I was able to measure the time used, but wasnt able to look for ways to know how much space was used. I am also not sure if the question is asking me to calculate it based on general BFS and DFS or the code I have coded.\n\nComparison of the time expended by the algorithms.\nComparison of the space used in memory at a time by the algorithms\n\nTo get the time I used ```\nstart_time = time.time()```\n and ```\nend = time.time()```\n\n```\nBFS algorithm\n0.0060007572174072266s \nDFS algorithm\n0.005002260208129883s\n```\n\nHow would I calculate the space used in memory assuming that it is based on my code. I might be just confused but the wording of the question makes me feel like I need to measure it when running both algorithms to compare the performance.\n\nCode:\nBFS :\n```\ndef knapsack_bfs(items, max_weight):\n    queue = deque()\n    root = Node(-1, 0, 0, [])\n    queue.append(root)\n\n    max_benefit = 0\n    best_combination = []\n\n    while queue:\n        current = queue.popleft()\n\n        if current.level == len(items) - 1:\n            if current.benefit > max_benefit:\n                max_benefit = current.benefit\n                best_combination = current.items\n        else:\n            next_level = current.level + 1\n            next_item = items[next_level]\n\n            include_benefit = current.benefit + next_item.benefit\n            include_weight = current.weight + next_item.weight\n\n            if include_weight <= max_weight:\n                include_node = Node(next_level, include_benefit,\n                                    include_weight, current.items + [next_item.id])\n                if include_benefit > max_benefit:\n                    max_benefit = include_benefit\n                    best_combination = include_node.items\n                queue.append(include_node)\n\n            exclude_node = Node(next_level, current.benefit,\n                                current.weight, current.items)\n            queue.append(exclude_node)\n\n    return max_benefit, best_combination\n```\n\nDFS:\n```\ndef knapsack_dfs(items, max_weight):\n    queue = []\n    root = Node(-1, 0, 0, [])\n    queue.append(root)\n\n    max_benefit = 0\n    best_combination = []\n\n    while queue:\n        current = queue.pop()\n\n        if current.level == len(items) - 1:\n            if current.benefit > max_benefit:\n                max_benefit = current.benefit\n                best_combination = current.items\n        else:\n            next_level = current.level + 1\n            next_item = items[next_level]\n\n            include_benefit = current.benefit + next_item.benefit\n            include_weight = current.weight + next_item.weight\n\n            if include_weight <= max_weight:\n                include_node = Node(next_level, include_benefit,\n                                    include_weight, current.items + [next_item.id])\n                if include_benefit > max_benefit:\n                    max_benefit = include_benefit\n                    best_combination = include_node.items\n                queue.append(include_node)\n\n            exclude_node = Node(next_level, current.benefit,\n                                current.weight, current.items)\n            \n            queue.append(exclude_node)\n\n    return max_benefit, best_combination\n```\n\nEdit:\nResults based on the answer below:\n```\nprogram.py:42: size=4432 B (+840 B), count=79 (+15), average=56 B\nprogram.py:116: size=0 B (-768 B), count=0 (-1)\nprogram.py:79: size=0 B (-744 B), count=0 (-13)\nprogram.py.py:85: size=0 B (-72 B), count=0 (-1)\nprogram.py:57: size=0 B (-56 B), count=0 (-1)\nprogram.py:56: size=0 B (-56 B), count=0 (-1)\nprogram.py:74: size=0 B (-32 B), count=0 (-1)\nprogram.py:37: size=32 B (+0 B), count=1 (+0), average=32 B\n```\n\n    ", "Answer": "\r\nYou can try doing what another answer suggested: https://stackoverflow.com/a/45679009/670693\nWhile I couldn't run your code to try things out, missing the ```\nNode```\n definition, you can try something like:\n```\nimport tracemalloc\n\ntracemalloc.start()\nknapsack_dfs(...)\ndfs_snapshot = tracemalloc.take_snapshot()\nknapsack_bfs(...)\nbfs_snapshot = tracemalloc.take_snapshot()\ntracemalloc.stop()\n\nbfs_snapshot = bfs_snapshot.filter_traces((tracemalloc.Filter(False, '*tracemalloc.py'),))\ndfs_snapshot = dfs_snapshot.filter_traces((tracemalloc.Filter(False, '*tracemalloc.py'),))\n\nfor statdiff in bfs_snapshot.compare_to(dfs_snapshot, 'lineno'):\n  print(statdiff)\n\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with multiple contstraits\r\n                \r\nGiven problem:\n\nn items, each having a ```\nvalue val```\n, a ```\nweight w```\n, and an ```\nvolume vol```\n. Basically the same as knapsack 0/1 problem however the task is to find the maximum value V you can get in the knapsack but the weight can't be more than W_max and also the volume needs to be at least Vol_min.\n\nThe value, weight and volume are given in three arrays:\n\n```\nval[n+1], w[n+1], vol[n+1]\nThe i-th item has value val[i], weight w[i] and volume vol[i]\n```\n\n\nI know how to solve the normal 0/1 knapsack problem with only one limit but I'm not sure how to solve this one. I was thinking of using a 3D DP table but how is an entry in the table defined?\n\nHere's what I've tried so far:\n\n```\nstatic int knapsack(int[] vol, int[] w, int[] val, int n, int Vol_min, int W_max) {\n\n    int[][][] DP = new int[n+1][W_max][Vol_min];\n\n    for(int i = 1; i < n+1; i++) {\n        for(int j = 0; j < W_max; j++) {\n            for(int k = 0; k < Vol_min; k++) {\n\n                if(w[i] > W_max) {\n                    DP[i][j][k] = DP[i-1][j][k];\n                } else {\n\n                    if(j - w[i] >= 0 && k + vol[i] <= n) {\n                        DP[i][j][k] = Math.max(DP[i-1][j][k], DP[i-1][j - w[i]][k + vol[i]] + val[i]);\n                    } else {\n                        DP[i][j][k] = DP[i-1][j][k];\n                    }\n\n                }\n            }\n        }\n    }\n\n    return DP[n][n][n]; \n}\n```\n\n\nHere is an example of the problem:\n\n```\nn = 6, Vol_min = 10, W_max = 12\nvol = {1, 3, 7, 5, 1, 3}, w = {4, 5, 10, 2, 1, 4}, val = {10, 8, 5, 3, 1, 2}\n=> Result: 22\n```\n\n    ", "Answer": "\r\nSo using recursive DP, I came up with a pretty standard solution for 1/0 Knapsack with a slight modification.\n\n```\n    public static int[][] dp;// Item number, Weight, Volume\n    public static int[] vol, w, val;\n    public static int Vol_min, W_max, n;\n\n    static int knapsack(int item, int weight, int volume) {\n        // See if we have calculated this item before\n        if (dp[item][weight] == -1) {\n            // Set initial value to -2 (invalid result)\n            int max = -2;\n            // Iterate though all items past current item\n            for (int i = item; i < n; i++) {\n                // Make sure we don't go over max weight\n                if (weight + w[i] <= W_max) {\n                    // Get the result of taking ith item\n                    int res = knapsack(i + 1, weight + w[i], volume + vol[i]);\n                    // Make sure result is valid (Total volume is greater than\n                    // Vol_min)\n                    if (res != -2) {\n                        // If the result is valid take the max\n                        max = Math.max(res + val[i], max);\n                    }\n                }\n            }\n\n            if (max == -2 && volume >= Vol_min)// No other items taken and over\n                                                // Vol_min\n                dp[item][weight] = 0;\n            else // Eveything else\n                dp[item][weight] = max;\n        }\n        // Return the value\n        return dp[item][weight];\n    }\n\n    public static void main(String[] args) {\n        n = 6;\n        Vol_min = 10;\n        W_max = 12;\n        vol = new int[] { 1, 3, 7, 5, 1, 3 };\n        w = new int[] { 4, 5, 10, 2, 1, 4 };\n        val = new int[] { 10, 8, 5, 3, 1, 2 };\n        dp = new int[n + 1][W_max + 1];\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= W_max; j++) {\n                dp[i][j] = -1;\n            }\n        }\n        System.out.println(knapsack(0, 0, 0));\n\n    }\n```\n\n\nSo imagine that we had a magical function ```\nknapsack(item,weight,volume)```\n that could return the largest valid value of items that could be taken given the item number, weight and volume. \n\nThe solution would then iterate though every item after it and see what the answer would be and take the largest one. Similar to the 1/0 DP that you do. However, you realize that you don't need to keep track of the volume in the dp array hence it being only 2D. You only need to keep track of the volume at the end when you see that there are no more items that can be taken. Then you check to see if the solution is valid.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Optimization problem with multiple knapsack does not work correctly\r\n                \r\nI am trying to solve a Multiple Knapsacks Problem in Python which consists on putting items in 5 bins and the constraint is that each bin(bag) must contains items with same cluster (so we must not find two object with different clusters in the same bin) and maximizing the sum  KPI of items packed in the bins\nHere is the dataframe data:\n```\nindex   Cluster PageId  OsId    BrowserId   Impressions VideoComplete   Clicks  VolumePred  KPIPred ConversionPred  pond\n0          1    0      1016529     11          16           43            16         1       175.0     0.025703     1\n1          2    0      1016529     11          17            1             1         0         4.0     0.100000     1\n2         12    0      1068379     11          12            1             0         0         4.0     0.150000     1\n3         21    0      1074581     11          16           82            36         2       334.0     0.024457     1\n4         22    0      1074581     12          14            3             2         0        12.0     0.035648     1\n... ... ... ... ... ... ... ... ... ... ... ... ...\n310     1392    9       955767     11          11          264           170        12      1076.0     0.056217     1\n311     1396    9       955767     11          17           42            32         2       171.0     0.118330     1\n312     1397    9       955767     12          12            7             1         2        29.0     0.234646     1\n313     1398    9       955767     12          14           31            17         1       126.0     0.026832     1\n314     1405    9       988119     11          16           66            49         1       269.0     0.019075     1\n```\n\nTo solve it:\nI created a first Assignment-matrix A : items <-> bins like this :\n```\n      item     0   1   2   3   4   5   6   7   8   9   10   11   12   13   14   \n bins\n 0   \n 1    \n 2    \n 3    \n 4 \n              <=1 <=1 <=1 ...................................      <=1 <=1 <=1 \n\n\ndata1 = {}\npond = data['pond']\nCluster = data['Cluster']\nOsId = data['OsId']\nBrowserId = data['BrowserId']\nPageId = data['PageId']\nvolume = data['VolumePred']\nconversion = data['ConversionPred']\nKPI = data['KPIPred']\n\nassert len(OsId) == len(BrowserId) == len(PageId) == len(conversion)\n\ndata1['Cluster']  = Cluster\ndata1['pond'] = pond\ndata1['OsId'] = OsId\ndata1['BrowserId'] = BrowserId\ndata1['PageId'] = PageId\ndata1['conversion'] = conversion\ndata1['volume'] = volume\ndata1['KPI'] = KPI\ndata1['items'] = list(range(len(BrowserId)))\ndata1['num_items'] = len(OsId)\nnumber_bags = 5 #All have the same capacity of 50 pounds\n\ndata1['bag_capacities'] = [50,50,50,50,50]#pounds\ndata1['bag_PageId'] = [50,50,50,50,50] #while this equals bag_capacities, I made it its own variable in case\ndata1['conversion_capacities'] = [5,5,5,5,5]\n#data1['bag_capacities'] = [50,50,50,50,50] #while this equals bag_capacities, I made it its own variable in case\n\n#I wanted to change the OsId at a later data1\ndata1['bags'] = list(range(number_bags))\n\nassert len(data1['bag_capacities']) == number_bags\nassert len(data1['bag_capacities']) == len(data1['bag_PageId']) == len(data1['conversion_capacities'])\nprint(\"OsId: \",*data1['OsId'])\nprint('BrowserId:',*data1['BrowserId'])\nprint('PageId:',*data1['PageId'])\nprint('conversioniation Levels:', *data1['conversion'])\nprint(\"Number of Items:\", data1['num_items'])\nprint(\"Number of Knapsacks:\" , number_bags)\nprint('Knapsack Capacities: 50 Pounds, 50 cubic inches, 5 Levels of conversioniation')\n```\n\nVariable 1\n```\n#x[i,j] for item i in knapsack j\nx = {}\nfor i in data1['items']:\n    for j in data1['bags']:\n        x[(i,j)] = solver.IntVar(0,1,'x_%i_%i' % (i, j))\n```\n\nThen, I add a second matrix : Assignment-matrix B item-classes <-> bins:\n```\ndata2={}\n\n\nunique_cluster = set(np.array(Cluster))\n\npartition = [np.where(Cluster == i)[0] for i in unique_cluster]\ndata2['class'] = list(unique_cluster)\ndata2['bags'] = list(range(number_bags))\n\n#x[i,j] for item i in knapsack j\nx2 = {}\nfor i in data2['class']:\n    for j in data2['bags']:\n        x2[(i,j)] = solver.IntVar(0,1,'x_%i_%i' % (i, j))\n  \n```\n\nThen, I precise the list of constraints:\n```\n#Constraint for an item being placed in 1 knapsack\nfor i in data1['items']:\n    \n    solver.Add(sum(x[i,j] for j in data1['bags'])<=1)\n \n #Knapsack Capacity Constraint\nfor j in data1['bags']:\n   \n    solver.Add(sum(x[(i,j)]*data1['pond'][i] \n                 for i in data1['items']) == 5)    \n \n #Constraint for a class of item is  being placed in 1 knapsack\nfor i in data2['class']:\n    solver.Add(sum(x2[i,j] for j in data2['bags'])<=1)\n\nA=np.where(Cluster == 0)[0].tolist()\n\nfor b in data1['bags']:\n    for c in data2['class']:\n        print(b,c)\n        u=len(np.where(Cluster == c)[0].tolist())\n\n        print(c,b)\n        \n        solver.Add(sum(x[z,b]\n                       for z in np.where(Cluster == c)[0].tolist()) <= (x2[c,b]*u))\n  \n                   \n```\n\nThen, I precise the optimization objective:\n```\nobjective = solver.Objective()\nfor i in data1['items']:\n    \n    for j in data1['bags']:\n        objective.SetCoefficient(x[(i,j)], data1['KPI'][i])\n        \nobjective.SetMaximization()\n        \n```\n\nResolution\n```\nsolv = solver.Solve()\nif solv == pywraplp.Solver.OPTIMAL:\n    #print('Total Packed Value:', objective.Value())\n    total = 0\n    kpi_moyen = 0\n    kpi=0\n    total_conversion = 0\n    nombre_impression = 5\n    \n    \n    for j in data1['bags']:\n        bag_value = 0\n        bag_weight = 0\n        bag_volume= 0\n        bag_rad = 0\n        bag_conversion=0\n        max = 0\n        i_max=0\n     \n      \n       \n        print('\\n','Bag', j+1 , '\\n')\n        \n        for i in data1['items']:\n                    \n           \n            if((x[i,j].solution_value()>0)):\n                print('OsId',data1['OsId'][i], \n                      'Cluster', data1['Cluster'][i],\n                      'BrowserId', data1['BrowserId'][i], \n                      'PageId', data1['PageId'][i],\n                      'conversion', data1['conversion'][i],\n                      'volume', data1['volume'][i],\n                      'KPI', data1['KPI'][i]\n                     )\n                bag_value += data1['volume'][i]\n                print(bag_value)\n                bag_weight += data1['KPI'][i]\n                bag_conversion += data1['conversion'][i]\n                \n        print('Packed Knapsack Volume Value: ', bag_value)\n        print('impression number', nombre_impression)\n        print('Packed Knapsack KPI: ', bag_weight/nombre_impression)\n        kpi = bag_weight/nombre_impression\n        total= total+bag_value\n        kpi_moyen = kpi_moyen+kpi\n        total_conversion= total_conversion+bag_conversion\n        \n  \n   \n        \n    print(\"#######################################################\")\n    print(\"#######################################################\")\n    print(\"#######################################################\")\n    \n    \n    print(\"Le volume total\", total)   \n    print(\"KPI Moyen\", kpi_moyen/5)\n    \n    \n    \nelse:\n    print(\"There is no optimal solution\") \n```\n\nAnd finally as result I get this five bins with their items:\n```\n> Bag 1 \n> \n> OsId 11 Cluster 0 BrowserId 12 PageId 1149586 conversion 3.0 volume\n> 4.0 KPI 0.6890546435965691\n> 4.0 \n\nOsId 99 Cluster 0 BrowserId 16 PageId 1154705 conversion 3.0 volume 8.0 KPI 0.3472222222222222\n> 12.0 \n\nOsId 11 Cluster 0 BrowserId 17 PageId 789615 conversion 3.0 volume 4.0 KPI 0.6564351851851853\n> 16.0 \n\nOsId 11 Cluster 0 BrowserId 11 PageId 955761 conversion 9.0 volume 37.0 KPI 0.2541666666666666\n> 53.0 \n\nOsId 99 Cluster 7 BrowserId 16 PageId 917224 conversion 4.0 volume 12.0 KPI 0.3292739040060469\n\n> 65.0 Packed Knapsack Volume Value:  65.0 impression number 5 Packed Knapsack KPI:  0.45523052433533806\n> \n>  Bag 2 \n> \n> OsId 99 Cluster 12 BrowserId 16 PageId 941080 conversion 2.0 volume\n> 4.0 KPI 0.5508680555555555\n> 4.0 \n\nOsId 12 Cluster 9 BrowserId 16 PageId 1018637 conversion 4.0 volume 12.0 KPI 0.321111111111111\n> 16.0 \n\nOsId 11 Cluster 9 BrowserId 17 PageId 1154705 conversion 13.0 volume 33.0 KPI 0.3886526452221044\n> 49.0 \n\nOsId 99 Cluster 9 BrowserId 12 PageId 955761 conversion 11.0 volume 33.0 KPI 0.3366657218442933\n> 82.0 \n\nOsId 12 Cluster 9 BrowserId 12 PageId 955767 conversion 7.0 volume 29.0 KPI 0.2346455795175744\n\n> 111.0 Packed Knapsack Volume Value:  111.0 impression number 5 Packed Knapsack KPI:  0.3663886226501277\n> \n>  Bag 3 \n> \n> OsId 99 Cluster 4 BrowserId 16 PageId 1109643 conversion 1.0 volume\n> 4.0 KPI 0.3055555555555556\n> 4.0 \n\nOsId 11 Cluster 4 BrowserId 11 PageId 1149586 conversion 6.0 volume 8.0 KPI 0.7676237922705315\n> 12.0 \n\nOsId 11 Cluster 4 BrowserId 15 PageId 1149586 conversion 8.0 volume 33.0 KPI 0.2383133975812547\n> 45.0 \n\nOsId 12 Cluster 4 BrowserId 16 PageId 1154705 conversion 10.0 volume 41.0 KPI 0.2528392857142857\n> 86.0 \n\nOsId 12 Cluster 4 BrowserId 14 PageId 955767 conversion 4.0 volume 20.0 KPI 0.2225\n> 106.0 \n\nPacked Knapsack Volume Value:  106.0 impression number 5 Packed Knapsack KPI:  0.35736640622432553\n> \n>  Bag 4 \n> \n> OsId 11 Cluster 15 BrowserId 17 PageId 1109643 conversion 5.0 volume\n> 12.0 KPI 0.3877777777777778\n> 12.0 \n\nOsId 11 Cluster 15 BrowserId 17 PageId 1187774 conversion 3.0 volume 12.0 KPI 0.236237684729064\n> 24.0 \n\nOsId 11 Cluster 15 BrowserId 11 PageId 955765 conversion 10.0 volume 41.0 KPI 0.2319838228361533\n> 65.0 \n\nOsId 11 Cluster 18 BrowserId 17 PageId 1074581 conversion 5.0 volume 16.0 KPI 0.300344742063492\n> 81.0 \n\nOsId 11 Cluster 18 BrowserId 16 PageId 1148073 conversion 3.0 volume 4.0 KPI 0.6833333333333333\n\n> 85.0 Packed Knapsack Volume Value:  85.0 impression number 5 Packed Knapsack KPI:  0.36793547214796407\n> \n>  Bag 5 \n> \n> OsId 11 Cluster 21 BrowserId 12 PageId 1016529 conversion 3.0 volume\n> 8.0 KPI 0.3541076152683295\n> 8.0 \n\nOsId 11 Cluster 21 BrowserId 12 PageId 1068379 conversion 3.0 volume 4.0 KPI 0.6711734693877551\n> 12.0 \n\nOsId 12 Cluster 21 BrowserId 16 PageId 911433 conversion 5.0 volume 16.0 KPI 0.3160714285714284\n> 28.0 \n\nOsId 11 Cluster 21 BrowserId 12 PageId 941080 conversion 2.0 volume 8.0 KPI 0.2876372053872053\n> 36.0 \n\nOsId 12 Cluster 21 BrowserId 14 PageId 941080 conversion 2.0 volume 8.0 KPI 0.275\n> 44.0\n```\n\nThe problem is I found in the same bag or bin item with multiple cluster for example in bag 1 we found items with cluster 0 and 7.\nHow can I fix this?\n    ", "Answer": "\r\nYour \"constraint for a class of item is  being placed in 1 knapsack\"\n```\nfor i in data2['class']:\n    solver.Add(sum(x2[i,j] for j in data2['bags'])<=1)\n```\n\nensures that each class is placed into some knapsack. It does not ensure that each knapsack holds only one class.\nI think you will have to add\n```\n# Only one class per knapsack Constraint\nfor j in data1['bags']:\n    solver.Add(sum(x2[(i,j)] \n                 for i in data2['class']) <= 1)\n\n```\n\ninstead.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack optimization with dynamic variables\r\n                \r\nI am trying to solve an optimization problem, that it's very similar to the knapsack problem but it can not be solved using the dynamic programming.\nThe problem I want to solve is very similar to this problem:\n\n\n\n\n\n\n \n    ", "Answer": "\r\nindeed you may solve this with CPLEX.\nLet me show you that in OPL.\n\nThe model (.mod) \n\n```\n{string} categories=...;\n\n{string} groups[categories]=...;\n\n{string} allGroups=union (c in categories) groups[c];\n\n{string} products[allGroups]=...;\n{string} allProducts=union (g in allGroups) products[g];\n\nfloat prices[allProducts]=...;\n\nint Uc[categories]=...;\nfloat Ug[allGroups]=...;\n\nfloat budget=...;\n\ndvar boolean z[allProducts]; // product out or in ?\n\ndexpr int xg[g in allGroups]=(1<=sum(p in products[g]) z[p]);\ndexpr int xc[c in categories]=(1<=sum(g in groups[c]) xg[g]);\n\nmaximize \nsum(c in categories) Uc[c]*xc[c]+\nsum(c in categories) sum(g in groups[c]) Uc[c]*Ug[g]*xg[g];\nsubject to\n{\nctBudget:\n    sum(p in allProducts) z[p]*prices[p]<=budget;\n}\n\n{string} solution={p | p in allProducts : z[p]==1};\n\nexecute\n{\nwriteln(\"solution = \",solution);\n}\n```\n\n\nThe data .dat\n\n```\ncategories={Carbs,Protein,Fat};\ngroups=[{Meat,Milk},{Pasta,Bread},{Oil,Butter}];\nproducts=[\n{Product11,Product12},{Product21,Product22,Product23},\n{Product31,Product32},{Product41,Product42},\n{Product51},{Product61,Product62}];\n\nprices=[1,4,1,3,2,4,2,1,3,1,2,1];\n\n// User 1\nUc=[1,1,0];\nUg=[0.8,0.2,0.1,1,0.01,0.6];\nbudget=3;\n\n//User 2\n//Uc=[1,1,0];\n//Ug=[0.8,0.2,0.1,1,0.01,0.6];\n//budget=2;\n```\n\n\nand this gives\n\n```\nsolution =  {\"Product11\" \"Product21\" \"Product41\"}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multi-knapsack problem with aggregate objective function/objective with a soft limit\r\n                \r\nI am trying to solve a variant of the multi-knapsack example in Google OR-tools. The one feature I cannot seem to encode is a soft limit on the value.\nIn the original example, an item has a weight that is used to calculate a constraint and a value that is used to calculate the optimum solution. In my variation I have multiple weights/capacities that form quotas and compatibilities for items of certain types. In addition, each bin has a funding target and each item has a value. I would like to minimise the funding shortfall for each bin:\n```\n# pseudocode!\nminimise: sum(max(0, funding_capacity[j] - sum(item[i, j] * item_value[i] for i in num_items)) for j in num_bins)\n```\n\nThe key differences between this approach and the example are that if item_1 has a value of 110 and bin_A has a funding requirement of 100, item_1 can fit into bin_A and makes the funding shortfall go to zero. item_2 with a value of 50 could also fit into bin_A (as long as the other constraints are met) but the optimiser will see no improvement in the objective function. I have attempted to use the ```\nobjective.SetCoefficient```\n method on a calculation of the funding shortfall but I keep getting errors that I think are to do with this method not liking aggregate functions like sum.\nHow do I implement the funding shortfall objective above, either in the objective function or alternatively in the constraints? How can I form an objective function using a summary calculation? The ideal answer would be a code snippet for OR-tools in Python but clear illustrative answers from OR-tools in other programming languages would also be helpful.\n    ", "Answer": "\r\nWorking code follows, but here's how you would proceed with the formulation.\nFormulation changes to the Multiple Knapsack problem given here\n\nYou will need two sets of new variables for each bin. Let's call them ```\nshortfall[j]```\n (continuous) and ```\nfilled[j]```\n (boolean).\n\n```\nShorfall[j]```\n is simply the ```\nfunding_requirement[j] - sum_i(funding[items i])```\n\n\n```\nfilled[j]```\n is a Boolean, which we want to be 1 if the sum of the funding of each item in the bin is greater than its funding requirement, 0 otherwise.\n\nWe have to resort to a standard trick in Integer Programming that involves using a Big M. (A large number)\n```\n        if total_item_funding >= requirement, filled = 1\n        if total_item_funding < requirement, filled = 0\n```\n\n\n\nThis can be expressed in a linear constraint:\n```\n           shortfall + BigM * filled > 0\n```\n\nNote that if the shortfall goes negative, it forces the ```\nfilled```\n variable to become 1. If ```\nshortfall```\n is positive, ```\nfilled```\n can stay 0. (We will enforce this using the objective function.)\n\nIn the objective function for a Maximization problem, you penalize the filled variable.\n```\n Obj: Max sum(i,j) Xij * value_i + sum(j) filled_j * -100\n```\n\n\n\nSo, this multiple knapsack formulation is incentivized to go close to each bin's funding requirement, but if it crosses the requirement, it pays a penalty.\nYou can play around with the objective function variables and penalities.\nFormulation using Google-OR Tools\nWorking Python Code. For simplicity, I only made 3 bins.\n```\nfrom ortools.linear_solver import pywraplp\n\n\ndef create_data_model():\n    \"\"\"Create the data for the example.\"\"\"\n    data = {}\n    weights = [48, 30, 42, 36, 36, 48, 42, 42, 36, 24, 30, 30, 42, 36, 36]\n    values = [10, 30, 25, 50, 35, 30, 15, 40, 30, 35, 45, 10, 20, 30, 25]\n    item_funding = [50, 17, 38, 45, 65, 60, 15, 30, 10, 25, 75, 30, 40, 40, 35]\n    data['weights'] = weights\n    data['values'] = values\n    data['i_fund'] = item_funding\n    data['items'] = list(range(len(weights)))\n    data['num_items'] = len(weights)\n    num_bins = 3\n    data['bins'] = list(range(num_bins))\n    data['bin_capacities'] = [100, 100, 80,]\n    data['bin_funding'] = [100, 100, 50,]\n\n    return data\n\ndef main():\n    data = create_data_model()\n\n    # Create the mip solver with the SCIP backend.\n    solver = pywraplp.Solver.CreateSolver('SCIP')\n\n    # Variables\n    # x[i, j] = 1 if item i is packed in bin j.\n    x , short, filled = {}, {}, {}\n    for i in data['items']:\n        for j in data['bins']:\n            x[(i, j)] = solver.IntVar(0, 1, 'x_%i_%i' % (i, j))\n\n    BIG_M, MAX_SHORT = 1e4, 500\n    for j in data['bins']:\n        short[j] = solver.NumVar(-MAX_SHORT, MAX_SHORT, \n                                 'bin_shortfall_%i' % (j))\n        filled[j] = solver.IntVar(0,1,  'filled[%i]' % (i))\n\n    # Constraints\n    # Each item can be in at most one bin.\n    for i in data['items']:\n        solver.Add(sum(x[i, j] for j in data['bins']) <= 1)\n\n    for j in data['bins']:\n        # The amount packed in each bin cannot exceed its capacity.\n        solver.Add(\n            sum(x[(i, j)] * data['weights'][i]\n                for i in data['items']) <= data['bin_capacities'][j])\n        \n        #define bin shortfalls as equality constraints\n        solver.Add(\n            data['bin_funding'][j] - sum(x[(i, j)] * data['i_fund'][i]\n                for i in data['items']) == short[j])\n        \n        # If shortfall is negative, filled is forced to be true\n        solver.Add(\n            short[j] + BIG_M * filled[j] >= 0)\n\n\n    # Objective\n    objective = solver.Objective()\n\n    for i in data['items']:\n        for j in data['bins']:\n            objective.SetCoefficient(x[(i, j)], data['values'][i])\n\n    for j in data['bins']:\n            # objective.SetCoefficient(short[j], 1)\n            objective.SetCoefficient(filled[j], -100)\n\n    objective.SetMaximization()\n\n    print('Number of variables =', solver.NumVariables())\n    status = solver.Solve()\n\n\n    if status == pywraplp.Solver.OPTIMAL:\n        print('OPTMAL SOLUTION FOUND\\n\\n')\n        total_weight = 0\n        for j in data['bins']:\n            bin_weight = 0\n            bin_value = 0\n            bin_fund = 0\n\n            print('Bin ', j, '\\n')\n\n            print(f\"Funding {data['bin_funding'][j]} Shortfall \\\n            {short[j].solution_value()}\")\n\n            for i in data['items']:\n                if x[i, j].solution_value() > 0:\n                    print('Item', i, '- weight:', data['weights'][i], ' value:',\n                          data['values'][i], data['i_fund'][i])\n                    bin_weight += data['weights'][i]\n                    bin_value += data['values'][i]\n                    bin_fund += data['i_fund'][i]\n\n            print('Packed bin weight:', bin_weight)\n            print('Packed bin value:', bin_value)\n            print('Packed bin Funding:', bin_fund)\n            print()\n            total_weight += bin_weight\n        print('Total packed weight:', total_weight)\n    else:\n        print('The problem does not have an optimal solution.')\n\n\nif __name__ == '__main__':\n    main()\n```\n\nHope that helps you move forward.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Use q-learning method to solve knapsack problem\r\n                \r\nThe question is:Sugar 1 gram for 1 dollar,cookie 7 gram for 5 dollars and ice 12 gram for 10 dollars.Now i have 29 dollars,how to buy will be the heaviest?\nI have found the code on the Internet, but I don’t know how to modify it to solve my question.i don't know how to change the data to what i want.\n```\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom time import time\nimport itertools\nitem = pd.DataFrame(data=[[1, 1],\n                          [6, 2],\n                          [18, 5],\n                          [22, 6],\n                          [28, 7]],\n                    columns=['Value', 'Weight'])\n\nactions = list(range(len(item)))\nlimit_W = 11\ngamma = 0.9\n\nclass RLforKnapsack():\n    def __init__(self, limit_W, actions):\n        self.limit_W = limit_W  # maximal weight\n        self.epsilon = 0.9  # e-greedy algorithm\n        self.gamma = 0.9  # reward decay\n        self.alpha = 0.8  # learning_rate\n        self.actions = actions\n        self.q_table = pd.DataFrame(columns=actions)\n        self.done = False\n\n    def check_state(self, knapsack):\n        if str(knapsack) not in self.q_table.index:\n            # append new state to q table\n            q_table_new = pd.Series([np.NAN]*len(self.actions),\n                                    index=self.q_table.columns,\n                                    name=str(knapsack))\n            # 0-1 knapsack\n            for i in list(set(self.actions).difference(set(knapsack))):\n                q_table_new[i] = 0\n            self.q_table = self.q_table.append(q_table_new)\n\n    def choose_action(self, knapsack):\n        self.check_state(knapsack)\n        state_action = self.q_table.loc[str(knapsack), :]\n        # random state_action in case there are two or more maximum\n        state_action = state_action.reindex(\n                np.random.permutation(state_action.index)\n                )\n        if np.random.uniform() < self.epsilon:\n            # choose best action\n            action = state_action.idxmax()  # the first maximun\n        else:\n            # choose random action\n            action = np.random.choice(\n                    list(set(self.actions).difference(set(knapsack)))\n                    )\n        return action\n\n    def greedy_action(self, knapsack):\n        # testing\n        # choose best action\n        state_action = self.q_table.loc[str(knapsack), :]\n        state_action = state_action.reindex(\n                np.random.permutation(state_action.index)\n                )\n        action = state_action.idxmax()\n        return action\n\n    def take_action(self, knapsack, action):\n        # take the item\n        knapsack_ = knapsack + [action]\n        knapsack_.sort()\n        self.check_state(knapsack_)\n        return knapsack_\n\n    def rewardWithPenalty(self, knapsack_, action):\n        # constraint\n        knapsack_W = np.sum([item['Weight'][i] for i in knapsack_])\n        if knapsack_W > self.limit_W:\n            r = -10\n            self.done = True\n        else:\n            r = item['Value'][action]\n        return r\n\n    def update_qvalue(self, knapsack, knapsack_, action):\n        self.done = False\n        reward = self.rewardWithPenalty(knapsack_, action)\n        q_predict = self.q_table.loc[str(knapsack), action]\n        if len(knapsack) != len(self.actions):\n            q_target = reward + self.gamma * self.q_table.loc[\n                    str(knapsack_), :].max()\n        else:\n            q_target = reward  # no item can be added\n        self.q_table.loc[str(knapsack), action] += self.alpha * (\n                q_target - q_predict)\n        print(\"rl----\")\n        print(self.q_table)\n        print(\"--------\")\n        return self.q_table, self.done\n\n\nt1 = time()\nplt.close('all')\nRL = RLforKnapsack(limit_W=11, actions=actions)\nfor episode in range(100):\n    print(\"episode--\")\n    print(episode)\n    knapsack = []\n    for step in range(5):\n        print(\"step--\")\n        print(step)\n        action = RL.choose_action(knapsack)\n        print(\"action---\")\n        print(action)\n        knapsack_ = RL.take_action(knapsack, action)\n        q_table_RL, done = RL.update_qvalue(knapsack, knapsack_, action)\n        knapsack = knapsack_\n        if done:\n        \n            break\n    plt.scatter(episode, q_table_RL.iloc[0, 3], c='r')\n    plt.scatter(episode, q_table_RL.iloc[0, 4], c='b')\nt2 = time()\nplt.title([t2-t1, 'RL'])\nplt.show()\n\n# %% Policy based on q table\nknapsack = []\n# %%\naction = RL.greedy_action(knapsack)\nknapsack_ = RL.take_action(knapsack, action)\nknapsack = knapsack_\nnp.sum([item['Weight'][i] for i in knapsack_])\nprint(np.sum([item['Weight'][i] for i in knapsack_]))\n# %%\n\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving knapsack prob in F#: performance\r\n                \r\nI found an article:\nSolving the 0-1 knapsack problem using continuation-passing style with memoization in F#\n\nabout knapsack problem implemented in F#. As I'm learning this language, I found this really interesting and tried to investigate this a bit. Here's the code I crafted:\n\n```\nopen System\nopen System.IO \nopen System.Collections.Generic\n\nlet parseToTuple (line : string) =\n    let parsedLine = line.Split(' ') |> Array.filter(not << String.IsNullOrWhiteSpace)         |> Array.map Int32.Parse\n    (parsedLine.[0], parsedLine.[1])\n\nlet memoize f =\n    let cache = Dictionary<_, _>()\n    fun x ->\n        if cache.ContainsKey(x)\n            then cache.[x]\n        else\n            let res = f x\n            cache.[x] <- res\n            res\n\ntype Item =\n    {\n        Value : int\n        Size  : int\n    }  \n\ntype ContinuationBuilder() = \n    member b.Bind(x, f) = fun k -> x (fun x -> f x k)\n    member b.Return x = fun k ->  k x\n    member b.ReturnFrom x = x\n\nlet cont = ContinuationBuilder()\n\nlet set1 =\n    [\n        (4, 11)\n        (8, 4)\n        (10, 5)\n        (15, 8)\n        (4, 3)\n    ]\n\nlet set2 =\n    [\n        (50, 341045); (1906, 4912); (41516, 99732); (23527, 56554); (559, 1818); (45136, 108372); (2625, 6750); (492, 1484)\n        (1086, 3072); (5516, 13532); (4875, 12050); (7570, 18440); (4436, 10972); (620, 1940); (50897, 122094); (2129, 5558)\n        (4265, 10630); (706, 2112); (2721, 6942); (16494, 39888); (29688, 71276); (3383, 8466); (2181, 5662); (96601, 231302)\n        (1795, 4690); (7512, 18324); (1242, 3384); (2889, 7278); (2133, 5566); (103, 706); (4446, 10992); (11326, 27552)\n        (3024, 7548); (217, 934); (13269, 32038); (281, 1062); (77174, 184848); (952, 2604); (15572, 37644); (566, 1832)\n        (4103, 10306); (313, 1126); (14393, 34886); (1313, 3526); (348, 1196); (419, 1338); (246, 992); (445, 1390)\n        (23552, 56804); (23552, 56804); (67, 634)\n    ]\n\n[<EntryPoint>] \nlet main args =\n    // prepare list of items from a file args.[0]\n    let header, items = set1\n                        |> function\n                           | h::t -> h, t\n                           | _    -> raise (Exception(\"Wrong data format\"))\n\n    let N, K = header\n    printfn \"N = %d, K = %d\" N K\n    let items = List.map (fun x -> {Value = fst x ; Size = snd x}) items |> Array.ofList\n\n    let rec combinations =\n        let innerSolver key =\n            cont\n                {\n                    match key with\n                    | (i, k) when i = 0 || k = 0        -> return 0\n                    | (i, k) when items.[i-1].Size > k  -> return! combinations (i-1, k)\n                    | (i, k)                            -> let item = items.[i-1]\n                                                           let! v1 = combinations (i-1, k)\n                                                           let! beforeItem = combinations (i-1, k-item.Size)\n                                                           let v2 = beforeItem + item.Value\n                                                           return max v1 v2\n                }\n        memoize innerSolver\n\n    let res = combinations (N, K) id\n    printfn \"%d\" res\n    0\n```\n\n\nHowever, the problem with this implementation is that it's veeeery slow (in practice I'm unable to solve problem with 50 items and capacity of ~300000, which gets solved by my naive implementation in C# in less than 1s).\n\nCould you tell me if I made a mistake somewhere? Or maybe the implementation is correct and this is simply the inefficient way of solving this problem.\n    ", "Answer": "\r\nWhen you naively apply a generic memoizer like this, and use continuation passing, the values in your memoization cache are continuations, not regular \"final\" results.  Thus, when you get a cache hit, you aren't getting back a finalized result, you are getting back some function which promises to compute a result when you invoke it. This invocation might be expensive, might invoke various other continuations, might ultimately hit the memoization cache again itself, etc.\n\nEffectively memoizing continuation-passing functions such that a) the caching works to full effect and b) the function remains tail-recursive is quite difficult.  Read this discussion and come back when you fully understand it all. ;-)\n\nThe author of the blog post you linked is using a more sophisticated, less generic memoizer which is specially fitted to the problem.  Admittedly, I don't fully grok it yet (code on the blog is incomplete/broken, so hard to try it out), but I think the gist of it is that it \"forces\" the chain of continuations before caching the final integer result.\n\nTo illustrate the point, here's a quick refactor of your code which is fully self-contained and traces out relevant info:\n\n```\nopen System\nopen System.Collections.Generic\n\nlet mutable cacheHits = 0\nlet mutable cacheMisses = 0\n\nlet memoize f =\n    let cache = Dictionary<_, _>()\n    fun x ->\n        match cache.TryGetValue(x) with\n        | (true, v) -> \n            cacheHits <- cacheHits + 1\n            printfn \"Hit for %A - Result is %A\" x v\n            v\n        | _ ->\n            cacheMisses <- cacheMisses + 1\n            printfn \"Miss for %A\" x\n            let res = f x\n            cache.[x] <- res\n            res\n\ntype Item = { Value : int; Size  : int }  \n\ntype ContinuationBuilder() = \n    member b.Bind(x, f) = fun k -> x (fun x -> f x k)\n    member b.Return x = fun k ->  k x\n    member b.ReturnFrom x = x\n\nlet cont = ContinuationBuilder()\n\nlet genItems n = \n   [| for i = 1 to n do\n         let size = i % 5\n         let value = (size * i)\n         yield { Value = value; Size = size }\n   |]\n\nlet N, K = (5, 100)\nprintfn \"N = %d, K = %d\" N K\n\nlet items = genItems N\n\nlet rec combinations_cont =\n    memoize (\n     fun key ->\n       cont {\n                match key with\n                | (0, _) | (_, 0)                   -> return 0\n                | (i, k) when items.[i-1].Size > k  -> return! combinations_cont (i - 1, k) \n                | (i, k)                            -> let item = items.[i-1]\n                                                       let! v1 = combinations_cont (i-1, k)\n                                                       let! beforeItem = combinations_cont (i-1, k - item.Size)\n                                                       let v2 = beforeItem + item.Value\n                                                       return max v1 v2\n        }\n    )\n\nlet res = combinations_cont (N, K) id\nprintfn \"Answer: %d\" res\nprintfn \"Memo hits: %d\" cacheHits\nprintfn \"Memo misses: %d\" cacheMisses\nprintfn \"\"\n\nlet rec combinations_plain =\n    memoize (\n     fun key ->\n                match key with\n                | (i, k) when i = 0 || k = 0        -> 0\n                | (i, k) when items.[i-1].Size > k  -> combinations_plain (i-1, k) \n                | (i, k)                            -> let item = items.[i-1]\n                                                       let v1 = combinations_plain (i-1, k)\n                                                       let beforeItem = combinations_plain (i-1, k-item.Size)\n                                                       let v2 = beforeItem + item.Value\n                                                       max v1 v2\n    )\n\ncacheHits <- 0\ncacheMisses <- 0\n\nlet res2 = combinations_plain (N, K)\nprintfn \"Answer: %d\" res2\nprintfn \"Memo hits: %d\" cacheHits\nprintfn \"Memo misses: %d\" cacheMisses\n```\n\n\nAs you can see, the CPS version is caching continuations (not integers), and there are is a lot of extra activity going on toward the end as the continuations are invoked.\n\nIf you boost the problem size to ```\nlet (N, K) = (20, 100)```\n (and remove the ```\nprintfn```\n statements in the memoizer), you will see that the CPS version ends up doing over 1 million cache lookups, compared to plain version doing only a few hundred.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple-item bounded Knapsack algorithm\r\n                \r\nI have a list of items that each have a price - or in terms of the Knapsack problem, a weight. The number of purchasable items are only limited by a budget, so it is possible to buy as many of each as desirable, as long as the total amount spent isn't over a certain constant. I also have an algorithm that, based on certain variables, tells how profitable each item is (i.e. the value of each item). So basically I have a bounded Knapsack problem with the extra condition that more than one of each item fits into the knapsack.\n\nI want to maximize the profit under these conditions. I understand that there isn't an efficient solution, but is there at least a feasible one?\n    ", "Answer": "\r\nLet dp[i] be the maximum profit that can be earned if our budget is i. And cost[j] denote cost of j item and p[j] the profit earned from it. I assume cost[] and profit[] are given. Then following is the code in c++. ( let there be n items ).\n\n```\n  int max_profit(int budget )\n  {\n       if(budget<=0)\n         return 0;\n       if(dp[budget]!=-1)return dp[budget];\n       int ans=0;\n       for(int i=0;i<n;i++)\n       {\n             if(cost[i]<=budget)\n               ans=max(ans,profit[i]+max_profit(budget-cost[i]));\n       }\n       dp[budget]=ans;\n       return ans;\n  }\n  memset(dp,-1,sizeof(dp));\n  cout<< max_profit(budget);\n```\n\n\nTime Complexity is O(budget*(size of item list )),Memory O(budget). Also I assumed everything \nfits in int.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Issue in understanding Multiple Knapsack Problem IBM CPLEX\r\n                \r\nI found this example in the IBM CPLEX Studio in OPL Examples. However, I am not able to understand these two lines in the program. Is it a special way to use int decision variables instead of boolean?\n```\nint MaxValue = max(r in Resources) Capacity[r];\ndvar int Take[Items] in 0..MaxValue;\n```\n\nWhy do we find the maximum value of the resource capacity? Can someone please explain the logic behind it. I am new to Linear programming but curious about this. I believed that I should use a boolean variable in such situations. Thanks in advance.\n```\nint NbItems = ...;\n    int NbResources = ...;\n    range Items = 1..NbItems;\n    range Resources = 1..NbResources;\n    int Capacity[Resources] = ...;\n    int Value[Items] = ...;\n    int Use[Resources][Items] = ...;\n    int MaxValue = max(r in Resources) Capacity[r];\n    \n    \n    dvar int Take[Items] in 0..MaxValue;\n    \n    maximize\n      sum(i in Items) Value[i] * Take[i];\n      \n    subject to {\n      forall( r in Resources )\n        ct:\n          sum( i in Items ) \n            Use[r][i] * Take[i] <= Capacity[r];\n    }\n    \n    \n    tuple TakeSolutionT{ \n        int Items; \n        int value; \n    };\n    {TakeSolutionT} TakeSolution = {<i0,Take[i0]> | i0 in Items};\n    execute{ \n        writeln(TakeSolution);\n```\n\n    ", "Answer": "\r\nIf MaxValue was 1 then\n```\ndvar int Take[Items] in 0..MaxValue;\n```\n\nwould be equivalent to\n```\ndvar boolean Take[Items];\n```\n\nLikewise\n```\ndvar int x in 0..2;\n```\n\nmeans x is either 0,1 or 2\nwhich will the same result as\n```\ndvar int x;\n\nsubject to\n{\n  0<=x<=2;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Drools Knapsack Optaplanner\r\n                \r\nI try to solve the Knapsack-Problem with the Optaplanner by using drools. Did someone this before? This refers to the example by optaplanner. \n\nThanks for your help \n\nI have implemented these rules as follows: \n\n```\n\nrule \"weigth\" \ndialect \"java\"\nwhen\n$knapsack : Knapsack($capacity : capacity)\n    $weightTotal : Number(intValue > $capacity) from accumulate(\n    Item(\n            $weight : weight),\n        sum($weight)\n        )\n    then\n    scoreHolder.addHardConstraintMatch(kcontext, $capacity - $weightTotal.intValue())\nend\n```\n\n    ", "Answer": "\r\nPresuming ```\nItem```\n is your planning entity and that it has a planning variable ```\nboolean used```\n, then you 'll want to only check the items that are ```\nused == true```\n:\n\n```\n    ... from accumulate(\n        Item(used == true,\n            $weight : weight),\n        sum($weight)\n    )\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Python function\r\n                \r\nI have this question regarding the knapsack problem and the aim is pretty much similar to the outcome of the knapsack problem. The question is:\n\n\n  Suppose you have a collection of n items. All the items have the same weight, w and you can choose at most one of each item. Write a Python function, which is given as input the capacity of the knapsack, capacity, a list (sorted in ascending order) of values, values, of each item, and the weight, w and returns the maximum value that the knapsack can hold.\n\n\nI have tried writing out the function but somehow I couldn't figure out where would the weight, ```\nw```\n, will be suitable in the line of code.\n\n```\ndef knapsack(capacity,n):\n    if len(n) ==0:\n          return 0\n    elif n[-1][0] > capacity:\n          return knapsack(capacity, n[:-1])\n    else:\n          return max(knapsack(capacity,n[:-1]), knapsack(capacity-n[-1][0],n[:-1]+n[-1][1]\n```\n\n\nSomehow, I searched a lot of ways to figure out this question as I'm relatively new to Python, but I didn't like the way the code works as I haven't figured out the question entirely. Is there a much better way to solve this Python function?\n    ", "Answer": "\r\nIf they all have the same weight, then that makes the problem quite trivial.\n\nYou simply have to sort the items by their value in descending order, and start choosing items from the list until either you have no more items in the list of values, or you have run out of capacity to store more.\n\nNote that the problem states that the values are sorted in ascending order of value. Since the list is already sorted in ascending order, you can simply reverse the list to have the items appear in descending order of value. This will give you the item with the largest value first.\n\nStarting from the first item, keep choosing items until you can no longer fit them in your knapsack.\n\n```\ndef knapsack(capacity, values):\n    values.reverse()\n    num_items = capacity // w\n    return sum(values[:num_items])\n```\n\n\n```\nnum_items```\n holds the maximum number of items we can fit in the knapsack.\n```\nvalues[:num_items]```\n uses array slicing to retrieve atmost ```\nnum_items```\n values from the array, then finally we pass this to ```\nsum```\n function to calculate the maximum sum\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is it possible to run a Knapsack 0-1 problem in Python with product couples?\r\n                \r\nI have created an integer program in Python with GurobiPy for the 0-1 knapsack problem. However, I want to add a constraint that sais that if product x is added, then product y must also be added for some product couples.\nMy current model:\nThere are 2 warehouses, if products are stored in the main warehouse, the profit loss (due to delays) is 0. If the products are stored in the new warehouse, the profit loss is as presented in the dataframe. The objective is to minimize the profit loss\n```\n# Note: I run the program for the second warehouse because Xi returns values of 1 if placed in the warehouse\n# so I can calculate the profit loss easier by just multiplying Xi by the profit loss\n\nc = 1720 # total number of boxes minus capacity of the main warehouse\np = dfGurobi['profit'].tolist() # profit of each product\nw = dfGurobi['boxes_required'].tolist() # weight of each product (=number of boxes required)\nl = dfGurobi['profitLoss'].tolist() # profit loss of each product\n\nn = len(p) # so determine the number of variables\nassert n == len(w) # lengths of p and w should be the same\nmodel = Model() # create a model\n\nx = model.addVars(n, vtype=GRB.BINARY) # add variables\nmodel.setObjective(quicksum(l[i] * x[i] for i in range(n)), GRB.MINIMIZE) # set objective to minimize the profit loss generated by placing products in the new warehouse\nmodel.addConstr(quicksum(w[i] * x[i] for i in range(n)) >= c) # set constraint that the number of boxes in the new warehouse is at least 1720 so that the number of boxes in the main warehouse is at most 960\nresult = model.optimize() # optimize the model\nprint(result)\nprint(\"The optimal total profit loss is: %g\" % model.objVal)\n\nprint(dfGurobi)\n```\n\nAlso, I have a list of product couples indicating that if product 1 is placed in the main op new warehouse, the second product must also be placed in the same warehouse. This is the list:\n```\n          product2\nproduct1          \n74              45\n74             328\n74             367\n74             535\n74             642\n74             802\n191            356\n191            931\n328            929\n362            535\n367            929\n382            587\n382            823\n382            828\n535            665\n535           1223\n574            931\n642           1223\n685            535\n685            671\n685            828\n685            845\n685            921\n685           1030\n823            931\n828            747\n828            931\n845            592\n1136           191\n1136           587\n1136           823\n1136           828\n1136           845\n```\n\nBackground info:\nmy Pandas Dataframe looks like this;\n```\n          profitLoss      profit  boxes_required\nproduct_id                                        \n571          96.849644  484.248219             1.0\n533          96.358619  481.793096             1.0\n831          89.424493  447.122466             1.0\n276          77.455923  387.279616             1.0\n162          76.336142  381.680712             1.0\n...                ...         ...             ...\n337           0.478582    0.957163             1.0\n840           0.468519    0.937037             1.0\n433           0.385460    0.770919             1.0\n384           0.305156    0.610311             1.0\n361           0.274544    0.549088             1.0\n\n[1263 rows x 3 columns]\n```\n\nHow can I best add the product couples as a constraint?\nEdit:\nMy specific problem is: If product 1 is added to the warehouse (i.e. has a value of Xi = 1), then product 2 must also be added (i.e. have a value of Xi = 1). How can I do this?\n    ", "Answer": "\r\nA basic precedence constraint can look like:\n```\n x[j] >= x[i]\n```\n\nwhich means ```\nif x[i]=1 then x[j]=1```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Incrementally computing knapsack\r\n                \r\nIs there a way to compute the knapsack problem incrementally? Any approximation algorithm? I am trying to solve the problem in the following scenario.\n\nLet D be my data set which is not ordered and should not be. D is divided into 3 subsets, namely D1, D2 and D3. D1, D2 and D3 can each be ordered if needed. I want to compute separate knapsack solutions for sets (D1,D2) and (D2,D3), but I don't want to avoid computing D2 two times. So, basically, I want to:\n\n\ncompute (D2) // do some operation\nsave it as an intermediate result\nuse it with D1 and get knapsack result for (D1, D2)\nuse it with D3 and get knapsack result for (D2,D3)\n\n\nThat way the data traversal over D2 is done only once.  Is there a way to solve the knapsack incrementally like this?\n    ", "Answer": "\r\nWikipedia gives this pseudocode for 0/1 Knapsack: https://en.wikipedia.org/wiki/Knapsack_problem#0.2F1_knapsack_problem\n\n```\n // Input:\n // Values (stored in array v)\n // Weights (stored in array w)\n // Number of distinct items (n)\n // Knapsack capacity (W)\n\n for j from 0 to W do:\n     m[0, j] := 0\n\n for i from 1 to n do:\n     for j from 0 to W do:\n         if w[i-1] > j then:\n             m[i, j] := m[i-1, j]\n         else:\n             m[i, j] := max(m[i-1, j], m[i-1, j-w[i-1]] + v[i-1])\n```\n\n\nThis builds a 2 dimensional array such that ```\nm[n, W]```\n (the last element in the last row) is the solution -- you run this on D2.\n\nThen you write another algorithm that takes this array as input and \n\n\nDoes not do the ```\nfor j ...```\n part to initialize the array\nDoes ```\nfor i from D2.count+1 to (D2.count + other.count) do:```\n to start where the other one left off. (you have to adjust i when looking up in the w and v arrays)\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is the 0-1 Knapsack that each item has the same weight NP-complete?\r\n                \r\nThe 0-1 Knapsack problem is known as NP-complete. But if the weight for each item are the same, the problem is still NP-complete?\n    ", "Answer": "\r\nNo, because you always just take whatever items are the most valuable.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with unique elements\r\n                \r\nI'm trying to solve the following:\n\n\n  The knapsack problem is as follows: given a set of integers S={s1,s2,…,sn}, and a given target number T, find a subset of S that adds up exactly to T. For example, within S={1,2,5,9,10} there is a subset that adds up to T=22 but not T=23. Give a correct programming algorithm for knapsack that runs in O(nT) time.\n\n\nbut the only algorithm I could come up with is generating all the 1 to N combinations and try the sum out (exponential time).\n\nI can't devise a dynamic programming solution since the fact that I can't reuse an object makes this problem different from a coin rest exchange problem and from a general knapsack problem.\n\nCan somebody help me out with this or at least give me a hint?\n    ", "Answer": "\r\nThe ```\nO(nT)```\n running time gives you the hint: do dynamic programming on two axes.  That is, let ```\nf(a,b)```\n denote the maximum sum <= b which can be achieved with the first ```\na```\n integers.\n\n```\nf```\n satisfies the recurrence\n\n```\nf(a,b) = max( f(a-1,b), f(a-1,b-s_a)+s_a )\n```\n\n\nsince the first value is the maximum without using ```\ns_a```\n and the second is the maximum including ```\ns_a```\n.  From here the DP algorithm should be straightforward, as should outputting the correct subset of S.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Balanced partition vs knapsack 1/0 complexity\r\n                \r\nBalanced partition: . You have a set of n integers each in the range 0 ... K. Partition these integers into two subsets such that you minimize |S1 - S2|, where S1 and S2 denote the sums of the elements in each of the two subsets.\nKnapsack problem: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. Cannot use the same object twice.\n\nIt seems that the solution to the Balanced partition problem is to simply apply the knapsack algorithm, for size of knapsack S/2, where S is the sum of all the input numbers, and the weight is equal to the value of each object. Still, it says here that the knapsack problem is O(nC), while the balanced partition problem is O(n^2 k). What am I missing?\n    ", "Answer": "\r\nBecause C can be equal to k*n if every integer equals to k. So you get run-time of O(k * n^2) for the Integer knapsack problem in that case.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving knapsack fractional optimization\r\n                \r\nI'm trying to solve Knapsack problem \n\nI'm inputing data, and then arrange this data in tuple of list\n\n```\nif __name__ == \"__main__\":\n    data = list(map(int, sys.stdin.read().split()))\n    n, capacity = data[0:2]\n    values = data[2:(2 * n + 2):2]\n    weights = data[3:(2 * n + 2):2]\n    opt_value = get_optimal_value(capacity, weights, values)\n```\n\n\nMy input\n\n```\n3 40\n20 50\n40 60\n50 60\n```\n\n\nMy tuple:\n\n```\n[(20, 50), (40, 60), (50, 60)]\n```\n\n\nThen I'm sorting it by highest value of values//weight. Next I'm implementing algorithm. \n\n```\ndef get_optimal_value(capacity, weights, values):\n    ziplist = list(zip(values, weights))\n\n    newlist = sorted(ziplist, key = lambda x : x[0] / x[1], reverse = True)\n\n    m = capacity\n\n    while (m != 0):\n        for i in range(0,len(newlist)):\n            a = min(newlist[i][1],capacity)\n            value = a * newlist[i][0]/newlist[i][1]\n            m -= newlist[i][1]\n\n\n    return m\n```\n\n\nMy strategy:\n\n\nI'm work until capacity of knapsack would be 0\nIf weight in first list of sorted tuple is less than capacity of knapsack, I decrease capacity of knapsack by weight of this element and increase value by element value\nDo this step with next element of tuple until capacity would be 0\nIf weight in the first list of sorted tuple is more than capacity of knapsack, then I need to add to value variable the proportion of weight to capacity\n\n\nBut when I run function returns nothing - what is the problem?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do I solve the 'classic' knapsack algorithm recursively?\r\n                \r\nThis is my task\n\n\n  The Knapsack Problem is a classic in computer science. In its simplest\n  form it involves trying to fit items of different weights into a\n  knapsack so that the knapsack ends up with a specified total weight.\n  You don't need to fit in all the items. For example, suppose you want\n  your knapsack to weigh exactly 20 pounds, and you have five items,\n  with weights of 11, 8, 7, 6, and 5 pounds. For small numbers of items,\n  humans are pretty good at solving this problem by inspection. So you\n  can probably figure out that only the 8, 7, and 5 combination of items\n  adds up to 20.\n\n\nI really don't know where to begin writing this algorithm. I understand recursion when applied to factorials and triangle numbers. However I'm lost right now.\n    ", "Answer": "\r\nWhat did you try?  \n\nThe idea, given the problem you stated (which specifies we must use recursion) is simple: for each item that you can take, see if it's better to take it or not.  So there are only two possible path:\n\n\nyou take the item\nyou don't take it\n\n\nWhen you take the item, you remove it from your list and you decrease the capacity by the weight of the item.\n\nWhen you don't take the item, you remove if from you list but you do not decrease the capacity.\n\nSometimes it helps to print what the recursive calls may look like.  In this case, it could look like this:\n\n```\nCalling 11 8 7 6 5  with cap: 20\n +Calling 8 7 6 5  with cap: 20\n |  Calling 7 6 5  with cap: 20\n |    Calling 6 5  with cap: 20\n |      Calling 5  with cap: 20\n |      Result: 5\n |      Calling 5  with cap: 14\n |      Result: 5\n |    Result: 11\n |    Calling 6 5  with cap: 13\n |      Calling 5  with cap: 13\n |      Result: 5\n |      Calling 5  with cap: 7\n |      Result: 5\n |    Result: 11\n |  Result: 18\n |  Calling 7 6 5  with cap: 12\n |    Calling 6 5  with cap: 12\n |      Calling 5  with cap: 12\n |      Result: 5\n |      Calling 5  with cap: 6\n |      Result: 5\n |    Result: 11\n |    Calling 6 5  with cap: 5\n |      Calling 5  with cap: 5\n |      Result: 5\n |    Result: 5\n |  Result: 12\n +Result: 20\n  Calling 8 7 6 5  with cap: 9\n    Calling 7 6 5  with cap: 9\n      Calling 6 5  with cap: 9\n        Calling 5  with cap: 9\n        Result: 5\n        Calling 5  with cap: 3\n        Result: 0\n      Result: 6\n      Calling 6 5  with cap: 2\n        Calling 5  with cap: 2\n        Result: 0\n      Result: 0\n    Result: 7\n    Calling 7 6 5  with cap: 1\n      Calling 6 5  with cap: 1\n        Calling 5  with cap: 1\n        Result: 0\n      Result: 0\n    Result: 0\n  Result: 8\nResult: 20\n```\n\n\nI did on purpose show the call to [8 7 6 5] with a capacity of 20, which gives a result of 20 (8 + 7 + 5).\n\nNote that [8 7 6 5] is called twice: once with a capacity of 20 (because we didn't take 11) and once with a capacity of 9 (because with did take 11).\n\nSo the path to the solution:\n\n11 not taken, calling [8 7 6 5] with a capacity of 20\n\n8 taken, calling [7 6 5] with a capacity of 12 (20 - 8)\n\n7 taken, calling [6 5] with a capacity of 5  (12 - 7)\n\n6 not taken, calling [5] with a capacity of 5\n\n5 taken, we're at zero.\n\nThe actual method in Java can fit in very few lines of code.\n\nSince this is obviously homework, I'll just help you with a skeleton:\n\n```\nprivate int ukp( final int[] ar, final int cap ) {\n    if ( ar.length == 1 ) {\n        return ar[0] <= cap ? ar[0] : 0;\n    } else {\n        final int[] nar = new int[ar.length-1];\n        System.arraycopy(ar, 1, nar, 0, nar.length);\n        fint int item = ar[0];\n        if ( item < cap ) {\n            final int left = ...  // fill me: we're not taking the item\n            final int took = ...  // fill me: we're taking the item\n            return Math.max(took,left);\n        } else {\n            return ... // fill me: we're not taking the item\n        }\n    }\n}\n```\n\n\nI did copy the array to a new array, which is less efficient (but anyway recursion is not the way to go here if you seek performance), but more \"functional\".\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is wrong with my implementation of the knapsack problem [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed last year.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nitems = [[profit, weight]...]\n```\nitems = [[44,92], [46,4], [90,43], [72,83], [91,84], [40,68], [75,92], [35,82], [8,6], [54,44], [78,32], [40,18], [77,56], [15,83], [61,25], [17,96], [75,70], [29,48], [75,14], [63,58]]\nmax_weight = 269\ndef knapsack_bruteforce(items, max_weight):\n    def backtrack(i, curr_profit, curr_weight):       \n        if(i+1 >= len(items) or curr_weight + items[i+1][1] > max_weight):\n            return curr_profit\n            \n        return max(backtrack(i+1, curr_profit + items[i+1][0], curr_weight + items[i+1][1]), backtrack(i+1, curr_profit, curr_weight))\n        \n    return backtrack(-1, 0, 0)\n\n```\n\nknapsack_bruteforce(items, max_weight) should return 550 as the maximum profit but I'm getting\n528 instead.\n    ", "Answer": "\r\nThe problem is in the second part of the ```\nif```\n condition:\n```\nif(i+1 >= len(items) or curr_weight + items[i+1][1] > max_weight):\n    return curr_profit\n```\n\nWhen the second condition is true, you should still allow the second recursive call to be done -- the one where this weight is not included -- as there might still be a way to add another item (that has less weight). But as you return immediately here, that attempt is never made.\nWithout changing more than necessary to your code, you can fix this, by bailing out (returning a negative number) when the weight excess has already been made. So split your ```\nif```\n into two:\n```\nif curr_weight > max_weight:\n    return -1\nif i+1 >= len(items):\n    return curr_profit\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why does 0/1 Knapsack problem need a 2-D array to memoize whereas House Robber problem need a 1-D array?\r\n                \r\nI'm asking this in reference to Dynamic Programming, I'm a beginner at it. I understood the House Robbers problem nicely and found 0/1 Knapsack similar to it. But I tried to code it up in similar way using 1-D array but it gave wrong answers. The solution had a 2-D array which is confusing me that why is there a need for 2-D array to store the remaining/occupied weight, as during recursion we are already passing the remaining/occupied weight. Any help would be appreciated.\n```\ndef knapSack(self,sackw, weights, values, n):\n    # my approach using a 1-D array to memoize\n    dp = [-1]*n\n    def recur(i, weightleft):\n        if weightleft <= 0 or i >= n:\n            return 0\n        if weights[i] > weightleft:\n            return recur(i+1, weightleft)\n        if dp[i] != -1:\n            return dp[i]\n        else:\n            res = dp[i] = max(values[i] + recur(i+1, weightleft - weights[i]), recur(i+1, weightleft))\n        return res\n    \n    return recur(0, sackw)\n```\n\nThe given answer using 2-D array below\n```\ndef solve_knapsack(profits, weights, capacity):\n    dp = [[-1 for x in range(capacity+1)] for y in range(len(profits))]\n    return knapsack_recursive(dp, profits, weights, capacity, 0)\n    def knapsack_recursive(dp, profits, weights, capacity, currentIndex):\n\n      # base checks\n        if capacity <= 0 or currentIndex >= len(profits):\n            return 0\n\n  # if we have already solved a similar problem, return the result from memory\n        if dp[currentIndex][capacity] != -1:\n            return dp[currentIndex][capacity]\n\n  # recursive call after choosing the element at the currentIndex\n  # if the weight of the element at currentIndex exceeds the capacity, we\n  # shouldn't process this\n        profit1 = 0\n        if weights[currentIndex] <= capacity:\n            profit1 = profits[currentIndex] + knapsack_recursive(\n        dp, profits, weights, capacity - weights[currentIndex], currentIndex + 1)\n\n  # recursive call after excluding the element at the currentIndex\n        profit2 = knapsack_recursive(\n    dp, profits, weights, capacity, currentIndex + 1)\n\n        dp[currentIndex][capacity] = max(profit1, profit2)\n        return dp[currentIndex][capacity]\n```\n\nTest Cases:\n\nweights = [4,5,1], values = [1,2,3], n = 3, sackweight = 4. Expected output = 3.\n\nOnly this one runs. The rest give wrong answer. They are too big to post here.\n    ", "Answer": "\r\n\"found 0/1 Knapsack similar to it\"\nFrom what I understand, this assumption is incorrect.\nIn 0/1 Knapsack problem, you have to maximize the value and keep the total weight under a given limit. There's no restriction on the item ordering that you select (basically, no constraint like \"you can't select three consecutive items\" or so). Since you're maintaining three properties in the DP state (index, weight, value of each item) you use 2D DP.\nIn the House Robbers problem, you're maximizing the value without having to keep a check on the count/weight of houses robbed. You just have to avoid picking consecutive houses (which can be done using indexes, no additional property needed). So it requires only 2 properties (house value and index), it is done using 1D DP.\nA small note on why your 1D approach is incorrect:\nLet's say your ```\ndp```\n table has a value ```\ndp[5] = 10```\n, which was calculated for a weight of ```\nx```\n. Let's say your recursively reach ```\ni=5```\n again, but with a different weight this time. Your ```\ndp[5] = 10```\n will get returned, which is incorrect because a different weight might lead to a different possible value.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is the variation of Knapsack NP-Complete?\r\n                \r\nIn the knapsack problem, the only constraint is that the total size of picked items is no larger than the total size of the package. We know the Knapsack problem is NP-Complete.\n\nHowever, if we have another constraint of choosing fixed number of items, is this problem still NP-Complete? The formal description of the problem is shown as follows,\n\nMaximize  $\\sum_{j=1}^n p_j x_j$\n\ns.t.      $\\sum_{j=1}^n w_j x_j < W$\n\n```\n      $\\sum_{j=1}^n x_j = N$\n\n      $x_j = \\{0,1\\}$     \n```\n\n\nThis is a formulated problem in my research and I am not sure whether it is NP-Complete or not. Please help me. Thanks! \n    ", "Answer": "\r\nYou can solve the constrained problem by iterating over all combinations of size ```\nN```\n from your set of ```\nn```\n objects. The number of combinations is no more than ```\nn^N```\n:\n\n```\nC = n! / (N! (n-N)!)\n <= n! / (n-N)!                // since N! >= 1\n  = n * (n-1) * ... * (n-N+1)  // N terms\n <= n * n * ... * n            // N terms\n  = n^N\n```\n\n\nSince ```\nN```\n is fixed, the overall complexity is therefore polynomial.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack Problem Python: Why are we returning the max value\r\n                \r\n```\n# A naive recursive implementation \n# of 0-1 Knapsack Problem \n  \n# Returns the maximum value that  \n# can be put in a knapsack of  \n# capacity W \ndef knapSack(W, wt, val, n): \n  \n    # Base Case \n    if n == 0 or W == 0 : \n        return 0\n  \n    # If weight of the nth item is  \n    # more than Knapsack of capacity W,  \n    # then this item cannot be included  \n    # in the optimal solution \n    if (wt[n-1] > W): \n        return knapSack(W, wt, val, n-1) \n  \n    # return the maximum of two cases: \n    # (1) nth item included \n    # (2) not included \n    else: \n        return max( \n            val[n-1] + knapSack( \n                W-wt[n-1], wt, val, n-1),  \n                knapSack(W, wt, val, n-1)) \n  \n# end of function knapSack \n  \n# To test above function \nval = [60, 100, 120] \nwt = [10, 20, 30] \nW = 50\nn = len(val) \nprint knapSack(W, wt, val, n) \n```\n\nWhy are we returning the max value? I mean it is working fine if we just return. The other thing is just a recursive call if that element's weight is greater then our capacity right?\n```\nreturn val[n-1] + knapSack( W-wt[n-1], wt, val, n-1)\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "MiniZinc. Discrete knapsack problem. Аn incomprehensible solution\r\n                \r\nSolve (from https://www.minizinc.org/doc-2.5.5/en/modelling2.html#set-constraints):\n```\nenum ITEM = { I1, I2, I3, I4, I5 };\nint: capacity = 5;\n\narray[ITEM] of int: profits = [1,2,3,4,5];\narray[ITEM] of int: weights = [1,2,3,4,5];\n\nint: maxProfit = sum (profits);\n\nvar set of ITEM: knapsack;\n\nvar int: weight = sum ([weights[i] | i in knapsack]);\nvar int: profit = sum ([profits[i] | i in knapsack]);\n\nconstraint weight <= capacity;\n\nsolve maximize profit;\n\noutput [\"knapsack = \\(knapsack)\\n\",\n        \"weight = \\(weight)/\\(capacity)\\n\",\n        \"profit = \\(profit)\"]\n```\n\nOutput:\n```\nknapsack = {I1, I2}\nweight = 3/5\nprofit = 3\n----------\nknapsack = {I1, I3}\nweight = 4/5\nprofit = 4\n----------\nknapsack = {I1, I4}\nweight = 5/5\nprofit = 5\n----------\n==========\n```\n\nPlease tell me why the output is like this?\nI expected an answer of the form:\n```\n% profit 5 for all\n{ I1, I4 }\n{ I2, I3 }\n{ I5 }\n```\n\nSolver: Gecode 6.3.0\n    ", "Answer": "\r\nIf I understand your question correctly, you are expecting that the output should show all optimal solutions. Is that correct?\nHowever, this is an optimization problem which only shows one optimal solution. The two first \"solutions\" are the intermediate solutions with increasing value of ```\nprofit```\n (3 and 4). The last solution (```\nprofit = 5```\n) is the optimal solution: ```\n{I1, I4}```\n.\nIf you want all optimal solutions (with ```\nprofit = 5```\n), you have to add that as a constraint and change ```\nsolve maximize profit```\n to ```\nsolve satisfy```\n:\n```\nconstraint profit = 5;\n        \n% solve maximize profit;\nsolve satisfy;\n\n```\n\nThen the output will be:\n```\nknapsack = {I1, I4}\nweight = 5/5\nprofit = 5\n----------\nknapsack = {I2, I3}\nweight = 5/5\nprofit = 5\n----------\nknapsack = {I5}\nweight = 5/5\nprofit = 5\n----------\n==========\n```\n\nI am not aware of any flag to MiniZinc (or the FlatZinc solver) that will print all the optimal solutions directly (i.e. without the manual handling as above). However, this would be possible using the Python interface ```\nMiniZinc Python```\n (https://minizinc-python.readthedocs.io/en/latest/ )\nUpdate\nHere is a Python model (using MiniZinc-Python) for showing all optimal solutions. The MiniZinc model is the same as stated except that there is no ```\nsolve```\n line. This is added by the Python program and is the key to getting all optimal solutions.\n```\nfrom minizinc import Instance, Model, Solver\n\ngecode = Solver.lookup(\"gecode\")\n\nmodel = Model(\"./discrete_knapsack.mzn\")\ninstance = Instance(gecode, model)\n\nwith instance.branch() as opt:\n    opt.add_string(\"solve maximize profit;\\n\")\n    res = opt.solve()\n    obj = res[\"objective\"]\n\ninstance.add_string(f\"constraint sum ([profits[i] | i in knapsack]) = {obj};\\n\")\n\nresult = instance.solve(all_solutions=True)\nfor sol in result.solution:\n    print(sol)\n    print()\n```\n\nThe output is:\n```\nknapsack = {I1, I4}\nweight = 5/5\nprofit = 5\n\nknapsack = {I2, I3}\nweight = 5/5\nprofit = 5\n\nknapsack = {I5}\nweight = 5/5\nprofit = 5\n\n```\n\n(This program was much inspired by the MiniZinc-Python example https://minizinc-python.readthedocs.io/en/latest/basic_usage.html#finding-all-optimal-solutions )\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Can we convert a Knapsack problem to Logarithmic time?\r\n                \r\nIf I want an optimal solution that is guaranteed, then the best I can do is a N^(N-1) solution as I have to evaluate every possible combination.\nIf I want to find a good solution that is similar to optional, then I think there are algorithms in O(log(N)) to find such solutions. What is actually is the answer?\n    ", "Answer": "\r\nThat's it, It depends, it depends to me, and to you, and to your system. The scope of such problems is surprisingly large, that is, the data storage capacity it requires. With respect to limiting dynamic programming, the challenge is the number of different sub-problems in the code that you fix. The challenge is always so high that there is no time limit. I will have to optimize it in the situation. The multiplication of the Matrix chain, for instance, is supposed to fall under that group.\nSome scenario, I may use a matrix or a hash table, though; this is because both have time for O(1) lookup. The complexity of time can be increased from O(2^n) exponential time to O(2^n) psuedo-polynomial time complexity (N x W). It also means that if WW is a constant, or bounded by a polynomial in NN, my Knapsack power, the dynamic program is polynomial time.\nBut I need to optimize it from psuedo-polynomial time O(N x W) to logarithmic time complexities O(log n). For Example, I have a Knapsack Problem solved in Dynamic Programming approach which took polynomial time complexities O(N x W) in both space and time:\n```\nclass Knapsack { \n  \n    static int max(int a, int b)  \n    { return (a > b) ? a : b; } \n  \n    static int knapSack(int W, int wt[], int val[], int n) \n    { \n        int i, w; \n        int K[][] = new int[n + 1][W + 1]; \n  \n        for (i = 0; i<= n; i++) { \n            for (w = 0; w<= W; w++) { \n                if (i == 0 || w == 0) \n                    K[i][w] = 0; \n                else if (wt[i - 1]<= w) \n                    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]); \n                else\n                    K[i][w] = K[i - 1][w]; \n            } \n        } \n  \n        return K[n][W]; \n    } \n  \n    public static void main(String args[]) \n    { \n        int val[] = new int[] { 60, 100, 120 }; \n        int wt[] = new int[] { 10, 20, 30 }; \n        int W = 50; \n        int n = val.length; \n        System.out.println(knapSack(W, wt, val, n)); \n    } \n} \n```\n\nBut DP needs a lot of storage capacity in terms of practical constraints, and also easily extends with the vector space dimension.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python Dynamic Knapsack\r\n                \r\nRight now I am attempting to code the knapsack problem in Python 3.2. I am trying to do this dynamically with a matrix. The algorithm that I am trying to use is as follows\n\n\nImplements the memoryfunction method for the knapsack problem \nInput: A nonnegative integer i indicating the number of the first\nitems being considered and a nonnegative integer j indicating the knapsack's capacity\nOutput: The value of an optimal feasible subset of the first i items\nNote: Uses as global variables input arrays Weights[1..n], Values[1...n]\nand table V[0...n, 0...W] whose entries are initialized with -1's except for\nrow 0 and column 0 initialized with 0's\n\n\n```\nif V[i, j] < 0\n    if j < Weights[i]\n        value <-- MFKnapsack(i - 1, j)\n\n    else\n        value <-- max(MFKnapsack(i -1, j),\n            Values[i] + MFKnapsack(i -1, j - Weights[i]))\n\n    V[i, j} <-- value\n\nreturn V[i, j]\n```\n\n\nIf you run the code below that I have you can see that it tries to insert the weight into the the list. Since this is using the recursion I am having a hard time spotting the problem. Also I get the error: can not add an integer with a list using the '+'. I have the matrix initialized to start with all 0's for the first row and first column everything else is initialized to -1. Any help will be much appreciated.\n\n```\n#Knapsack Problem \n\n\ndef knapsack(weight,value,capacity):\n    weight.insert(0,0)\n    value.insert(0,0)\n\n    print(\"Weights: \",weight)\n    print(\"Values: \",value)\n\n    capacityJ = capacity+1\n\n    ## ------ initialize matrix F ---- ##\n    dimension = len(weight)+1\n    F = [[-1]*capacityJ]*dimension\n\n    #first column zeroed\n    for i in range(dimension):\n        F[i][0] = 0\n    #first row zeroed            \n    F[0] = [0]*capacityJ\n    #-------------------------------- ##\n\n    d_index = dimension-2\n    print(matrixFormat(F))\n\n    return recKnap(F,weight,value,d_index,capacity)\n\ndef recKnap(matrix, weight,value,index, capacity):\n\n    print(\"index:\",index,\"capacity:\",capacity)\n    if matrix[index][capacity] < 0:\n        if capacity < weight[index]:\n            value = recKnap(matrix,weight,value,index-1,capacity)\n        else:\n            value = max(recKnap(matrix,weight,value,index-1,capacity),\n                        value[index] +\n                        recKnap(matrix,weight,value,index-1,capacity-(weight[index]))\n\n    matrix[index][capacity] = value\n    print(\"matrix:\",matrix)\n\n\n    return matrix[index][capacity]\n\n\ndef matrixFormat(*doubleLst):\n    matrix = str(list(doubleLst)[0])\n    length = len(matrix)-1\n    temp = '|'\n    currChar = ''\n    nextChar = ''\n    i = 0\n\n    while i < length:\n        if matrix[i] == ']':\n            temp = temp + '|\\n|'\n        #double digit\n        elif matrix[i].isdigit() and matrix[i+1].isdigit():\n            temp = temp + (matrix[i]+matrix[i+1]).center(4)\n            i = i+2\n            continue\n        #negative double digit\n        elif matrix[i] == '-' and matrix[i+1].isdigit() and matrix[i+2].isdigit():\n            temp = temp + (matrix[i]+matrix[i+1]+matrix[i+2]).center(4)\n            i = i + 2\n            continue\n        #negative single digit\n        elif matrix[i] == '-' and matrix[i+1].isdigit():\n            temp = temp + (matrix[i]+matrix[i+1]).center(4)\n            i = i + 2\n            continue\n\n\n\n\n        elif matrix[i].isdigit():\n            temp = temp + matrix[i].center(4)\n\n        #updates next round\n        currChar = matrix[i]\n        nextChar = matrix[i+1]\n        i = i + 1\n\n    return temp[:-1]\n\n\n\n\ndef main():\n    print(\"Knapsack Program\")\n    #num = input(\"Enter the weights you have for objects you would like to have:\")\n    #weightlst = []\n    #valuelst = []\n##    for i in range(int(num)):\n##        value , weight = eval(input(\"What is the \" + str(i) + \" object value, weight you wish to put in the knapsack?  ex. 2,3: \"))\n##        weightlst.append(weight)\n##        valuelst.append(value)\n    weightLst = [2,1,3,2]\n    valueLst = [12,10,20,15]\n    capacity = 5\n\n    value = knapsack(weightLst,valueLst,5)\n\n    print(\"\\n      Max Matrix\")\n    print(matrixFormat(value))\n\nmain()\n```\n\n    ", "Answer": "\r\n```\nF = [[-1]*capacityJ]*dimension\n```\n\n\ndoes not properly initialize the matrix. ```\n[-1]*capacityJ```\n is fine, but ```\n[...]*dimension```\n creates ```\ndimension```\n references to the exact same list. So modifying one list modifies them all.\n\nTry instead\n\n```\nF = [[-1]*capacityJ for _ in range(dimension)]\n```\n\n\nThis is a common Python pitfall. See this post for more explanation.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "This is a solution to the simplest knapsack problem but the result weight always exceeds the permitted amount\r\n                \r\nI'm trying to fix this for a whole night but still the program doesn't work, and I felt like there's nothing wrong with it. The list taken is responsible for recording the objects that's being carried with the knapsack.\nThese are the most essential part of code that I wrote.\n```\nknapsack = [[0 for i in range(itemCount)] for j in range(capacity)]\n\n    for i in range(itemCount):\n        for j in range(capacity):\n            if weights[i] <= j+1:\n                knapsack[j][i] = max(knapsack[j][i-1], knapsack[j-weights[i]][i-1]+values[i])\n            else:\n                knapsack[j][i] = knapsack[j][i-1]\n        if knapsack[capacity-1][i] == knapsack[capacity-1][i-1]:\n            taken[i] = 0\n        else:\n            taken[i] = 1\n    \n    result = knapsack[capacity-1][itemCount-1]\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Integer Knapsack and Independent Set (Graph Theory) Related?\r\n                \r\nIn Algorithms-II course by Tim RoughGarden on Coursera while explaining the 0-1 knapsack problem , he mentions the following and I quote\n\n\" By taking away the Wn from the knapsack capacity, before we look at the residual    subproblem, we're in effect reserving a buffer for item N if we ever need it, and that's how we know we're feasible when we stick N back into this solution S*. This is analogous to deleting the penultimate vertex of the path, again as a buffer to ensure feasibility when we include the Nth vertex back into the Independent set problem.\"\n\nPlease explain this comparison between Knapsack Problem and Maximum Independent Set problem. How are they interrelated. Even though I searched\n\n\n  http://en.wikipedia.org/wiki/Independent_set_(graph_theory)\n\n\nbut couldn't find any relation between the two.\n    ", "Answer": "\r\nThe way I understand this snippet, the author tries to explain how to obtain a smaller subproblem from the current problem.\n\nIn the case of the knapsack, he means that, given for instance weights ```\n{5, 3, 7, 1, 4}```\n and a knapsack of size ```\n15```\n, you can create a subproblem by selecting the first item and looking at the remaining space. That is, the remaining problem is to solve the knapsack problem for ```\n{3, 7, 1, 4}```\n and knapsack size ```\n10```\n (note that this is only part of the solution).\n\nIn the independent set you have something similar. Given the vertices ```\n{A, B, C, D, E}```\n and edges ```\n{(A, B), (A, D), (B, C), (C, D), (C, E), (D, E)}```\n, you can create a subproblem by selecting the first vertex (```\nA```\n) and looking at the remaining graph. All neighbors of ```\nA```\n need to be removed, so the remaining problem is to find an independent set of the vertices ```\n{C, E}```\n and edges ```\n{(C, E)}```\n.\n\nI must say that this similarity is quite a stretch, though.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple Knapsack using Dynamic Programming\r\n                \r\nI'm wondering if there is a reasonable way of solving Multiple Knapsack using DP. I get the point in 0-1 Knapsack Problem. The recurrence is quite straightforward, add item/ not add item.\n\n```\ndp[item][capacity] = max{\n     value[item] + dp[item - 1][capacity - weight[item]],\n     dp[item - 1][capacity]}```\n\n\nHowever, I cannot see how to get an recurrence equation for the Multiple Knapsack. Should I extend the recurrence equation to \"add item bag 1/ not add item bag 1/ add item bag 2/ not add item bag 2\" and so on and so forth? It does not seem a good approach as the number of bags becomes larger and larger.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack problem data storage from table in a File C\r\n                \r\nI am trying to store data for Value, Weight and Cost from a file containing a table which contains three columns of numbers for Value, Weight and Cost. The table may vary in length (9 or 21 rows) depending on the file chosen by the user.\nI am having trouble trying to store the data from this file to use in a brute force function to solve the problem.\nThis is what I have so far.\n\n```\n     #include <stdio.h>\n     #include <stdlib.h>\n     #include <string.h>\n     int main()\n     {\n         int nr_rows;\n         int i = 1;\n         int j = 2;\n         int k = 3;\n         int l,m,n = 0;\n         int budget_cost;\n         int weight_lim;\n         char file_name[50];\n         float c[nr_rows][3];\n         char stringA[20] = \"objectsA.txt\";\n         char stringB[20] = \"objectsB.txt\";\n\n         printf(\"Enter the filename containing item listing: \");\n         scanf(\"%s\", &file_name);\n         if(strcmp(file_name,stringA)==0)\n         {\n             nr_rows = 9;\n         }\n         else if(strcmp(file_name,stringB)==0)\n         {\n             nr_rows = 21;\n         }\n         printf(\"The number of rows is %d\", nr_rows);\n         float value[nr_rows], weight[nr_rows], price[nr_rows];\n         FILE *fpointer;\n         fpointer = fopen(file_name, \"r\");\n         if(!fpointer)\n         {\n             printf(\"The file %s could not be opened.\", file_name);\n             return 1;\n         }\n         j=0;\n         while(j<nr_rows)                            \n         {                                          \n             i=0;                      // Skip the first line\n             while(i<3)\n             {\n                 fscanf(fpointer, \"%f\", &c[j][i]);\n                 //printf(\"%.0f\\n\", c[j][i]);\n                 if(i=1) /* Change this if statement so that 1 ,4 ,7 ,10\n                            etc. activates*/\n                 {\n                     c[j][i] = v[l];\n                     l++;\n                     printf(\"%f\", v[l]);\n                 }\n                 else if(i=2)/* Change this if statement so that 2,5,8 etc. \n                                activates*/\n                 {\n                     c[j][i] = w[m];\n                     m++;\n                 }    \n                 else if(i=3)/* Change this if statement so that 3,6,9 etc. \n                                activates*/\n                 {\n                     c[j][i] = p[n];\n                     n++;\n                 }\n                 i++;\n             }\n             j++;\n         }\n         fclose(fpointer); \n```\n\n    ", "Answer": "\r\n```\n//1. Read carefully your file name by doing:\nscanf(\"%s\", file_name); // instead of scanf(\"%s\", &file_name);\n\n//2. Declare  c[nr_rows][3] only after reading \"nr_rows\"\n\n//3. The main \"while\" loop could look like this\nwhile(j < nr_rows)\n{\n    fscanf(fpointer, \"%f %f %f\", &c[j][0], &c[j][1], &c[j][2]);\n}\n// Then,\nfclose(fpointer);\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Fractional Knapsack Algorithm segmentation fault\r\n                \r\nI am trying to solve the fractional knapsack problem by writing a function get_optimal_value which returns the total optimal value given the capacity of knapsack and weights and values of items. Over here in the function get_optimal_value, i am running into a segmentation fault problem on ```\nv_per_w[i] = values[i]/weights[i]; ```\n and i am not sure what is going on as i can't see where i have accessed foreign memory.\nThis is my program. Help would be appreciated thanks :D\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing std::vector;\n\ndouble get_optimal_value(int capacity, vector<int> weights, vector<int> values) {\n  double value = 0.0;\n  vector<double> v_per_w = {};\n  for (int i =0; i<weights.size(); ++i){\n    v_per_w[i] = values[i]/weights[i]; //calculate v/w for the vector\n  }\n\n  //as long as capacity is not full\n  while (capacity !=0){\n    auto it = std::max_element(v_per_w.begin(), v_per_w.end()); //find max element in v/w\n    auto it2 = find(v_per_w.begin(), v_per_w.end(), *it); // find the index of that max element in v/w\n    int largest_index = it2 - v_per_w.begin(); \n    if (capacity>=weights[largest_index]){ \n      value+= values[largest_index]; //if capacity is more than the weight of that max v/w, add it all in\n    }\n    else{\n      value += v_per_w[largest_index] * capacity; //else add whatever weight you can of that max v/w\n    }\n    values.erase(values.begin(), values.begin()+largest_index-1); //remove that item from all the vectors\n    weights.erase(weights.begin(), weights.begin()+largest_index-1);\n    v_per_w.erase(v_per_w.begin(), v_per_w.begin()+largest_index-1);\n  }\n\n  return value;\n}\n\nint main() {\n  int n;\n  int capacity;\n  std::cin >> n >> capacity;\n  vector<int> values(n);\n  vector<int> weights(n);\n  for (int i = 0; i < n; i++) {\n    std::cin >> values[i] >> weights[i];\n  }\n\n  double optimal_value = get_optimal_value(capacity, weights, values);\n\n  std::cout.precision(10);\n  std::cout << optimal_value << std::endl;\n  return 0;\n}\n```\n\n    ", "Answer": "\r\n```\nvector<double> v_per_w = {};\n```\n\nThis creates a new ```\nvector```\n, which is completely empty. It has no values. Immediately afterwards:\n```\nv_per_w[i] = values[i]/weights[i]; //calculate v/w for the vector\n```\n\nThis attempts to change the existing values of ```\nv_per_w```\n. However, since ```\nv_per_w```\n is completely empty it has no values; this is a near-certain guarantee to produce the type of a crash you've observed. ```\nv_per_w[something]```\n does not add new values to a vector. It modifies/accesses existing values in the vector, which must exist already.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Any pseudo-polynomial algorithm for bounded 0-1 multi-knapsack?\r\n                \r\nSuppose that there are n items, e.g i1, i2, .... in, each of them with a known bounded weight w1, w2, ... wn. There are also a set of m knapsacks e.g. k1, k2 and km. Knapsacks are homogeneous, that they all have the same capacity W. The function F can determine the score of each knapsack. The inputs of F are the items in each knapsack. So,\n\n```\nScore of each knapsack i = F(Items in knapsack i)\n```\n\n\nNow I want to put SOME items in the knapsacks in such a way that:\n\n\nThe weight of items in a knapsack do not exceed its capacity W.  \nThe sum of scores for all knapsacks be maximum \n\n\nIs there a polynomial time solution for this problem or not?\n\nNote: The problem is 0-1, that is each item can be selected or not. All the problem parameters are bounded. \n\nEdit 1: Isn't it possible to reduce this problem to bin packing and then conclude that it is an NP-hard problem?\n\nEdit 2 In this problem, each item has three attributes, e.g. attributes ai, bi and ci. The F function is a linear function that gets the attributes of items inside it and produces the output. \n\nEdit3: It seems that this paper has proposed a exact solution for the multi- knapsack problem. Can it be used in my case?  \n    ", "Answer": "\r\nHow about this?\n\nGiven a standard dynamic solution in Haskell for a 0-1 knapsack problem, found here,\n\n```\ninv = [(\"map\",9,150), (\"compass\",13,35), (\"water\",153,200), (\"sandwich\",50,160),\n       (\"glucose\",15,60), (\"tin\",68,45), (\"banana\",27,60), (\"apple\",39,40),\n       (\"cheese\",23,30), (\"beer\",52,10), (\"cream\",11,70), (\"camera\",32,30),\n       (\"tshirt\",24,15), (\"trousers\",48,10), (\"umbrella\",73,40), \n       (\"trousers\",42,70), (\"overclothes\",43,75), (\"notecase\",22,80),\n       (\"sunglasses\",7,20), (\"towel\",18,12), (\"socks\",4,50), (\"book\",30,10)]\n\nknapsack = foldr addItem (repeat (0,[])) where\n    addItem (name,w,v) list = left ++ zipWith max right newlist where\n        newlist = map (\\(val, names)->(val + v, name:names)) list\n        (left,right) = splitAt w list\n\nmain = print $ (knapsack inv) !! 400\n```\n\n\nwe add a stuffing mechanism, placing the inventory permutations sequentially in the next knapsack that has space,\n\n```\nstuff (name,w,v) left (v2,[]) = (v2,left)\nstuff (name,w,v) left (v2,(cap, lst):xs) =\n  if w <= cap \n     then (v + v2, left ++ [(cap - w, (name,w,v):lst)] ++ xs) \n     else stuff (name,w,v) (left ++ [(cap,lst)]) (v2,xs)\n```\n\n\nand substitute it for the mapped function. Putting it all together:\n\n```\ninv = [(\"map\",9,150), (\"compass\",13,35), (\"water\",153,200), (\"sandwich\",50,160),\n       (\"glucose\",15,60), (\"tin\",68,45), (\"banana\",27,60), (\"apple\",39,40),\n       (\"cheese\",23,30), (\"beer\",52,10), (\"cream\",11,70), (\"camera\",32,30),\n       (\"tshirt\",24,15), (\"trousers\",48,10), (\"umbrella\",73,40), \n       (\"trousers\",42,70), (\"overclothes\",43,75), (\"notecase\",22,80),\n       (\"sunglasses\",7,20), (\"towel\",18,12), (\"socks\",4,50), (\"book\",30,10)]\n\ncapacity = 200::Int\nnumKnapsacks = 3\n\nstuff (name,w,v) left (v2,[]) = (v2,left)\nstuff (name,w,v) left (v2,(cap, lst):xs) =\n  if w <= cap \n     then (v + v2, left ++ [(cap - w, (name,w,v):lst)] ++ xs) \n     else stuff (name,w,v) (left ++ [(cap,lst)]) (v2,xs)\n\nknapsack = foldr addItem (repeat (0, replicate numKnapsacks (capacity,[]))) \n  where addItem (name,w,v) list = left ++ zipWith max right newlist \n          where newlist = map (stuff (name,w,v) []) list\n                (left,right) = splitAt w list\n\nmain = print $ (knapsack inv) !! 600\n```\n\n\nOUTPUT (total value followed by each knapsack's remaining weight capacity and contents):\n\n```\n*Main> main\n(1062,[(1,[(\"map\",9,150),(\"tshirt\",24,15),(\"trousers\",42,70),\n           (\"overclothes\",43,75),(\"notecase\",22,80),(\"sunglasses\",7,20),\n           (\"towel\",18,12),(\"socks\",4,50),(\"book\",30,10)]),\n       (0,[(\"compass\",13,35),(\"cheese\",23,30),(\"cream\",11,70),\n           (\"camera\",32,30),(\"trousers\",48,10),(\"umbrella\",73,40)]),\n       (1,[(\"sandwich\",50,160),(\"glucose\",15,60),(\"tin\",68,45),(\"banana\",27,60),\n           (\"apple\",39,40)])])\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack 0-1 with fixed quanitity\r\n                \r\nI'm writing a variation of knapsack 0-1 with multiple constraints. In addition to a weight constraint I also have a quantity constraint, but in this case I want to solve the knapsack problem given that I'm required to have exactly n items in my knapsack, with a weight less than or equal to W. I'm currently implementing a dynamic programming ruby solution for the simple 0-1 case based off of the code at Rosetta Code at http://rosettacode.org/wiki/Knapsack_problem/0-1#Ruby.\n\nWhat's the best way to implement the fixed quantity constraint?\n    ", "Answer": "\r\nYou could add a third dimension to the table: Number of items. Each item included adds both weight in the weight-dimension, and count in the count-dimension.\n\n```\ndef dynamic_programming_knapsack(problem)\n  num_items = problem.items.size\n  items = problem.items\n  max_cost = problem.max_cost\n  count = problem.count\n  cost_matrix = zeros(num_items, max_cost+1, count+1)\n\n  num_items.times do |i|\n    (max_cost + 1).times do |j|\n      (count + 1).times do |k|\n        if (items[i].cost > j) or (1 > k)\n          cost_matrix[i][j][k] = cost_matrix[i-1][j][k]\n        else\n          cost_matrix[i][j][k] = [\n              cost_matrix[i-1][j][k],\n              items[i].value + cost_matrix[i-1][j-items[i].cost][k-1]\n            ].max\n        end\n      end\n    end\n  end\n  cost_matrix\nend\n```\n\n\nTo find the solution (which items to pick), you need to look at the grid ```\ncost_matrix[num_items-1][j][k]```\n, for all values of ```\nj```\n and ```\nk```\n, and find the cell with maximum value.\n\nOnce you find the winning cell, you need to trace backwards towards the start (```\ni = j = k = 0```\n). On each cell you examine, you need to determine if item ```\ni```\n was used to get here or not.\n\n```\ndef get_used_items(problem, cost_matrix)\n  itemIndex = problem.items.size - 1\n  currentCost = -1\n  currentCount = -1\n  marked = Array.new(cost_matrix.size, 0) \n\n  # Locate the cell with the maximum value\n  bestValue = -1\n  (problem.max_cost + 1).times do |j|\n    (problem.count + 1).times do |k|\n      value = cost_matrix[itemIndex][j][k]\n      if (bestValue == -1) or (value > bestValue)\n        currentCost = j\n        currentCount = k\n        bestValue = value\n      end\n    end\n  end\n\n  # Trace path back to the start\n  while(itemIndex >= 0 && currentCost >= 0 && currentCount >= 0)\n    if (itemIndex == 0 && cost_matrix[itemIndex][currentCost][currentCount] > 0) or\n        (cost_matrix[itemIndex][currentCost][currentCount] != cost_matrix[itemIndex-1][currentCost][currentCount])\n      marked[itemIndex] = 1\n      currentCost -= problem.items[itemIndex].cost\n      currentCount -= 1\n    end\n    itemIndex -= 1\n  end\n  marked\nend\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Item allocation in a knapsack with Choco Solver\r\n                \r\nI try to implement a multidimensionnal knapsack problem with Choco Solver through JAVA. My idea is to assign 3 items in 2 knapsacks. \n\nMy item have a weight and knapsack a limit :\nint[] itemWeight = {2, 2, 2};\nint[] knapsackLimit = {4, 4};\n\nAnd my decision variable where 3 items have a knapsack between {0, 1} :\nint[] itemAllocation = {1, 1, 0};\n\nI wrote this problem by using Choco Solver :\n\n```\nModel model = new Model(\"KnapsackProblem\");\n\n// Allocation variable\nIntVar[] x = new IntVar[3];\nfor (int i = 0; i < itemNumber; i++) {\n    x[i] = model.intVar(\"x\"+i, 0, knapsackNumber-1);\n}\n\n// Knapsack capacities variables\nIntVar[] limitVar = new IntVar[knapsackNumber];\nfor (int i = 0; i < knapsackNumber; i++) {\n    limit[i] = model.intVar(knapsackLimit[i]);\n}\n\nIntVar[] itemWeightVar = new IntVar[itemNumber];\nfor (int i = 0; i < itemNumber; i++) {\n    itemWeightVar[i] = model.intVar(0, 2);\n    model.element(itemWeightVar[i], itemWeight,x[i]);\n}\n\n// Limit Cosntraints\nfor (int i = 0; i < knapsackNumber; i++) {\n    model.sum(itemWeightVar, \"<=\", limit[x[i].getValue()]);\n}\n\nmodel.getSolver().solve();\n```\n\n\nUnfortunately, this method does not work. I always get the following allocation: [x0 = 0, x1 = 0, x2 = 0]\n\nThank you in advance.\n    ", "Answer": "\r\nThis is a common mistake, you simply forget to POST your constraints so they are not taken into account. For instance, you should replace \n\n```\nmodel.element(itemWeightVar[i], itemWeight,x[i]);\n```\n\n\nby \n\n```\nmodel.element(itemWeightVar[i], itemWeight,x[i]).post();\n```\n\n\nNote that the post is not automatic as you may want to reify the constraint instead of posting it (which happens within ifThen statements for instance).\n\nBest,\n\nhttps://www.cosling.com/\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack prob, but allow over-filling\r\n                \r\nLets say I have 5 items (name, size, value) as follows:\n\n```\n(\"ITEM01\", 100, 10000)\n(\"ITEM02\", 24, 576)\n(\"ITEM03\", 24, 576)\n(\"ITEM04\", 51, 2500)\n(\"ITEM05\", 155, 25)\n```\n\n\nand I have to get the closest match to a total size of 150 (each item can only be added once).\n\nThis is very similar to the knapsack problem, but not quite since in this case my preferable solution would be ```\nITEM01```\n, ```\nITEM04```\n giving a total size of 151 (the knapsack problem would stop me going over size = 150 and hence give ```\nITEM01```\n, ```\nITEM02```\n and ```\nITEM03```\n with a total size of 148).\n\nDoes this problem have a name? (Is it still ```\ncombinatorial optimisation```\n)? I'm looking for a python solution, but it would help if I knew the name of what I am looking for.\n    ", "Answer": "\r\nYou can try to do it using dynamic programming. \n\nLet ```\ndp[k]```\n be equal to a list of items, with the sum of size equal to ```\nk```\n. Initially ```\nd[0] = []```\n and ```\ndp[k] = None```\n for ```\nk > 0```\n. The size of the list may be bounded by the sum of sizes of all elements, let's call it ```\nS```\n. \n\nWhat the algorithm does is for each ```\nitem```\n it goes from ```\ni = S```\n down to ```\ni = 0```\n and it checks if ```\ndp[i] != None```\n, which means we know we are able to select items with sum of sizes equal to ```\ni```\n. These items are on the list ```\ndp[i]```\n. Let's observe that we can add the current ```\nitem```\n to that list and have a set of items with sum equal to ```\ni + item.size```\n. So we assign ```\ndp[i + item.size] = dp[i] + [item]```\n. Having processed all items we just have to start at the desired sum of sizes and go both directions to find the closest match.\n\nCode:\n\n```\nitems = [(\"ITEM01\", 100, 10000), (\"ITEM02\", 24, 576), \\\n    (\"ITEM03\", 24, 576), (\"ITEM04\", 51, 2500), (\"ITEM05\", 155, 25)]\nS = sum([item[1] for item in items])\ndp = [None for i in xrange(S + 1)]\ndp[0] = []\n\nfor item in items:\n    for i in xrange(S, -1, -1):\n        if dp[i] is not None and i + item[1] <= S:\n            dp[i + item[1]] = dp[i] + [item]\n\ndesired_sum = 150\ni = j = desired_sum\n\nwhile i >= 0 and j <= S:\n    if dp[i] is not None:\n        print dp[i]\n        break\n    elif dp[j] is not None:\n        print dp[j]\n        break\n    else:\n        i -= 1\n        j += 1\n```\n\n\noutput:\n\n```\n[('ITEM01', 100, 10000), ('ITEM04', 51, 2500)]\n```\n\n\nHowever the complexity of this solution is ```\nO(n*S)```\n where ```\nn```\n is the number of items and ```\nS```\n is the sum of sizes, so it may be too slow for some purposes. What can be improved in this solution is the ```\nS```\n constant. For example you can set ```\nS```\n to ```\n2 * desired_sum```\n because we have guarantee that we can take a set of items with sum of sizes in ```\n[0, 2 * desired_sum]```\n (possibly an empty set with sum ```\n0```\n). If you want to take at least one item you can take ```\nS = max(min_item_size, 2 * desired_sum - min_item_size)```\n where ```\nmin_item_size```\n is the minimum of sizes of all items.\n\nEDIT:\n\nOh, you also wanted get maximise value when two combinations are equally close to ```\ndesired_size```\n. Then you have to alternate the code a bit to keep the best combinations for each sum of sizes.\n\nNamely:\n\n```\nif dp[i] is not None and i + item[1] <= S:\n```\n\n\nshould be:\n\n```\nif dp[i] is not None and i + item[1] <= S and \\\n    (\n        dp[i + item[1]] is None\n        or\n        sum(set_item[2] for set_item in dp[i]) + item[2]\n            > sum(set_item[2] for set_item in dp[i + item[1]])\n    ):\n```\n\n\n(a bit ugly, but I don't know how to break lines to make it look better)\n\nOf course you can keep these sums to avoid calculating them each time.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Keep track of items in dynamic programming(similar to Knapsack problem)\r\n                \r\nHello I'm trying to solve this dp problem: https://vjudge.net/problem/UVA-990\nI'm able to solve the initial problem result using this code below:\nI used recursion and a memo table arr to optimize the code.\n```\ns=list(map(int,input().split()))\nt=s[0] #seconds allowed under water\nw=s[1] #w \nn=int(input()) #number of treasures\ndepth=[-1] \ngold=[-1]\ntime=[-1]\nfor i in range(3):\n    q=list(map(int,input().split()))\n    depth.append(q[0])\n    gold.append(q[1])\n    time.append(q[0]*w*3)\n\narr = [[-1]*(t+1) for i in range(0,(n+1))]\n\ndef maxGold(n,T):\n    if n==0 or T==0:\n        return 0\n    if arr[n][T]!=-1:\n        return arr[n][T]\n    if time[n]>T:\n        answer=maxGold(n-1,T)\n    else:\n        answer=max(maxGold(n-1,T),gold[n]+maxGold(n-1,T-time[n]))\n    arr[n][T]=answer\n    return answer\n\nresult=maxGold(n,t)\nprint(result)\n```\n\nHowever I have no idea how to keep track of the chosen items.\nI was thinking to store all indices of chosen treasures of the maxGold() output and print them later in a loop for instance.\nOne approach I had was to add a paramter to the maxGold() function and append to it the indices and return two result and the indices list from the function like the following:\n```\ndef maxGold(n,T,l):\n    if n==0 or T==0:\n        return 0,l\n    if arr[n][T]!=-1:\n        return arr[n][T],l\n    if time[n]>T:\n        answer=maxGold(n-1,T,l)\n    else:\n        l2=l[:]\n        l2.append(n)\n        answer=max(maxGold(n-1,T,l)[0],gold[n]+maxGold(n-1,T-time[n],l2)[0])\n    arr[n][T]=answer\n    return answer,l\n\nresult=maxGold(n,t,[])\nprint(result[0])\nlist_of_indices=result[1]\nlength=len(list_of_indices)\n\n#proceed outputs\n```\n\nHowever I ran into many tuple/integer type, subscriptable,iteratable errors. from this specific line even after trying to get a round the tuple output due to several outputs :\n```\nanswer=max(maxGold(n-1,T,l)[0],gold[n]+maxGold(n-1,T-time[n],l2)[0])\n```\n\nAnd honestly I'm uncertain whether this approach is the right one.\nAny hints?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem brute force algorithm huge time complexity\r\n                \r\nI'm doing brute force method for my school project, the thing is with my current code it took 15 hours to calculate, when I know it should take just few minutes max. Also it seems to not choose the best possibility, not sure why. It compiles and everything works, but is just soo inefficient. \nI have a file with the data in which in the first line there is a capacity, in next lines there is value and weight.\nWhat can I do to improve the code?\n\n```\npublic class Main {\n\n    static ArrayList<String> weights = new ArrayList<>();\n    static ArrayList<String> values = new ArrayList<>();\n    static int n = 20;\n    private static int maxValue = 0;\n\n    public static void readFile(String dataFile) throws IOException {\n        FileReader read = new FileReader(dataFile);\n        BufferedReader buff = new BufferedReader(read);\n        String line;\n        while ((line = buff.readLine()) != null) {\n            String[] item = line.split(\" \");\n            if (item.length == 1)\n                capacity = Integer.parseInt(item[0]);\n            else {\n                values.add(item[0]);\n                weights.add(item[1]);\n\n            }\n        }\n    }\n\n    public static String toBinary(int a) {\n        String result = \"\";\n        while (a > 0) {\n            result = a % 2 + result;\n            a = a / 2;\n\n        }\n        while (result.length() < n) {\n            result = \"0\" + result;\n        }\n        return result;\n\n    }\n\n    public static boolean isMaxValue(int val) {\n        if (val > maxValue)\n            return true;\n        return false;\n    }\n\n    public static boolean isInCapacity(int weight) {\n        if (weight <= capacity)\n            return true;\n        return false;\n    }\n\n    public static void main(String[] args) {\n\n        long start = System.currentTimeMillis();\n\n        try {\n            readFile(dataFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        int sumValue = 0;\n        int sumWeight = 0;\n        String bestComb = \"\";\n        String finalResult = \"\";\n        int combnum = (int) Math.pow(2, n);\n\n        for (int i = 1; i < combnum; i++) { /\n\n            //System.out.println(toBinary(i));  // 277s with, without 187s for n=20\n\n            for (int j = 0; j < toBinary(i).length(); j++) {\n\n                int arrElem = Character.getNumericValue(toBinary(i).charAt(j));\n                if (arrElem == 1) {\n                    sumWeight += Integer.parseInt(weights.get(j)); \n                    sumValue += Integer.parseInt(values.get(j));\n                }\n\n            }\n            if (isMaxValue(sumValue) && isInCapacity(sumWeight)) { \n                finalResult = sumValue + \" value, \" + sumWeight + \" weight\";\n                bestComb = toBinary(i);\n            };\n\n            sumWeight = 0; \n            sumValue = 0;\n\n        }\n```\n\n\nEDIT:\nchanged the way of calculating (also made item into class instead of 2 arrayLists) to this:\n\n```\nfor (int i = 1; i < combnum; i++) {\n            String comb = Integer.toBinaryString(i);\n            sumValue = 0;\n            sumWeight = 0;\n            for (int j = 0; j < comb.length(); j++) {\n                if (comb.charAt(j) == '1') {\n                    sumValue += itemList.get(j).getValue();\n                    sumWeight += itemList.get(j).getWeight();\n                }\n            }\n            if (isMaxValue(sumValue) && isInCapacity(sumWeight)) { \n                maxValue=sumValue;\n                maxWeight = sumWeight;\n                finalResult = sumValue + \" value, \" + sumWeight + \" weight\";\n                bestComb = toBinary(i);\n            };\n```\n\n\nand the timer dropped to few minutes for 2^30 combinations. Cheers.\n    ", "Answer": "\r\nYour solution at least has a problem: you brute force all possible configurations and check that configuration. The only problem is: there are many sub-problems that is exactly duplicated that you don't need to solve again.\n\nIn this case, I propose you dynamic programming approach for solving this problem. In layman term, dynamic programming is another kind of brute force. You try all possible solutions. The only difference is it \"has memorized\" old sub-problem result. You should take a look.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack using Dyanmic Programming Fails to give correct answer\r\n                \r\nI was implementing the snippet of Knapsack problem using the algorithm that i found in this link Knapsack Problem\n\nI asked the question earlier on Stack Overflow, where's I was having problem in getting output from the return statement of program. You can check that here Previous question\n\nI have also attached the snippet of the algorithm here too. \n\nI have written following python snippet for the algorithm. Here it is:\n\n```\ndef knapsack(v,w,n,W):\n    V = [[None for x in range(W+1)] for x in range(len(v)+1)]\n    keep = [[0 for x in range(W+1)] for x in range(len(v)+1)]\n    # print keep\n\n    for wy in range(W+1):\n        V[0][wy] = 0\n\n    for i in range(1,n+1):\n        for wx in range(W+1):\n            # print i,wx\n            if w[i-1] <= wx:\n\n                V[i][wx] = max(V[i-1][wx], v[i-1]+V[i-1][wx-w[i-1]])\n                keep[i][wx] = 1\n            else:\n                V[i][wx] = V[i-1][wx]\n                keep[i][wx] = 0\n    K = W\n    # print keep\n    for i in range(n,0,-1):\n        if keep[i][K] == 1:\n            print i\n            K = K - w[i-1]\n\n    return V[n][W]\n\nprint knapsack(v = [10,40,30,50], w=[5,4,6,3],n=4,W=10)\n```\n\n\nI am supposed to get 4,2 as my value, but getting 4,3 . Please correct where I'm going wrong.\n    ", "Answer": "\r\nProblems in if statament:\n\n```\n        if w[i-1] <= wx:\n\n            V[i][wx] = max(V[i-1][wx], v[i-1]+V[i-1][wx-w[i-1]])\n            keep[i][wx] = 1\n        else:\n            V[i][wx] = V[i-1][wx]\n            keep[i][wx] = 0\n```\n\n\nif ```\n(w[i-1] <= wx) and (v[i-1]+V[i-1][wx-w[i-1]] <= V[i-1][wx])```\n you are doind\n\n```\n            V[i][wx] = max(V[i-1][wx], v[i-1]+V[i-1][wx-w[i-1]])\n            keep[i][wx] = 1\n```\n\n\nbut you should\n\n```\n            V[i][wx] = V[i-1][wx]\n            keep[i][wx] = 0\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving the Integer Knapsack\r\n                \r\nI a new to dynamic programing and have tried the integer knapsack problem here at SPOJ (http://www.spoj.pl/problems/KNAPSACK/) . However, for the given test cases my solution is not giving the correct output. I'd be thankful to you if you could suggest if the following implementation by me is correct. Please note that the variable ```\nback```\n is for backtracking, about which I'm not sure how to do. I hope to have your help in implementing the backtracking too. Thanks.\n\n```\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint knapsack(int value[], int weight[], int n, int C,\n         vector < int >&back)\n{\n    int *M = new int[C + 1];\n    int k;\n    int i, j, tmp, pos;\n    for (i = 1; i <= C; i++) {\n        M[i] = M[i - 1];\n        pos = i - 1;\n        for (j = 0; j < n; j++) {\n            k = i - weight[j];\n            if (k >= 0)\n                tmp = M[k] + value[j];\n            if (tmp > M[i]) {\n                M[i] = tmp;\n            }\n        }\n        back.push_back(pos);\n    }\n    int ans = M[C];\n    delete[]M;\n    return ans;\n}\n\n\nint main()\n{\n    int C, N;\n    cin >> C >> N;\n    int* value = new int[N+1];\n    int* weight = new int[N+1];\n    for ( int i = 0; i <= N; i++) {\n        cin>>value[i]>>weight[i];\n    }\n    vector < int >back(N, 0);\n    cout<<knapsack(value,weight,N,C,back)<<endl;\n    return 0;\n}\n```\n\n\nHere are the correct input/output test cases:\n\n```\nInput:\n4 5\n1 8\n2 4\n3 0\n2 5\n2 3\n\n\nOutput:\n13\n```\n\n\nHowever, the output that I am getting is ```\n17```\n.\n    ", "Answer": "\r\nThis is a version of the Knapsack problem known as the 0-1 knapsack.\n\nYou are making some silly mistakes in your code.\n\nTo begin with the first integer in input is the weight and the second is the value. While you are taking first as value and second as weight. Moreover you are taking n+1 values as input 0 to N inclusive.\n\nNow in your algorithm, you are considering that you can take any number of copies of the items, this is not true this is a 0-1 knapsack. Read this http://en.wikipedia.org/wiki/Knapsack_problem .\n\nI came up with this algorithm and I submitted and got accepted. So this should work fine. \n\n```\nint M[2000][2000];\nint knapsack(int value[], int weight[], int C, int n)\n{      \n  for(int i = 1; i <= C; i++){\n    for(int j = 0; j <n; j++){\n      if(j > 0){\n        M[j][i] = M[j-1][i];\n        if (weight[j] <= i)\n          M[j][i] = max(M[j][i], M[j-1][i-weight[j]]+value[j]);\n      }\n      else{\n        M[j][i] = 0;\n        if(weight[j] <= i)\n          M[j][i] = max(M[j][i], value[j]);\n      }\n    }\n    //    cout << M[i][n-1] << endl;\n  }        \n  return M[n-1][C];\n}  \n\nint main()\n{\n    int C, N;\n    cin >> C >> N;\n    //    cout << C << endl;\n    int* value = new int[N+1];\n    int* weight = new int[N+1];\n    for ( int i = 0; i < N; i++) {\n        cin>>weight[i]>>value[i];\n    }\n    //   vector < int >back(N, 0);\n    cout<<knapsack(value,weight,C,N)<<endl;\n    return 0;\n}\n```\n\n\nBTW don't dynamically allocate arrays simply use vectors\n\n```\nvector <int> My_array(n);\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack I/O classic problem to get least valuable items\r\n                \r\nThe classic knapsack addresses the solution to get the most valuable items inside the knapsack which has a limited weight it can carry.\n\nI am trying to get instead the least valuable items.\n\nThe following code is a very good one using Recursive dynamic programming from rosetacode http://rosettacode.org/wiki/Knapsack_problem/0-1#Recursive_dynamic_programming_algorithm\n\n```\n\ndef total_value(items, max_weight):\n    return  sum([x[2] for x in items]) if sum([x[1] for x in items]) <= max_weight else 0\n\ncache = {}\ndef solve(items, max_weight):\n    if not items:\n        return ()\n    if (items,max_weight) not in cache:\n        head = items[0]\n        tail = items[1:]\n        include = (head,) + solve(tail, max_weight - head[1])\n        dont_include = solve(tail, max_weight)\n        if total_value(include, max_weight) > total_value(dont_include, max_weight):\n            answer = include\n        else:\n            answer = dont_include\n        cache[(items,max_weight)] = answer\n    return cache[(items,max_weight)]\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nmax_weight = 400\n\nsolution = solve(items, max_weight)\nprint \"items:\"\nfor x in solution:\n    print x[0]\nprint \"value:\", total_value(solution, max_weight)\nprint \"weight:\", sum([x[1] for x in solution])\n\n```\n\n\nI have been trying to figure out how can i get the least valuable items looking on the internet with no luck so maybe somebody can help me with that.\n\nI really apreciate your help in advance.\n    ", "Answer": "\r\nI'll try my best to guide you through what should be done to achieve this.\n\nIn order to make changes to this code and find the least valuable items with which you can fill the bag make a function which,\n\n\nTakes in the most valuable items(```\nsolution```\n in your code) as the\ninput\nFind the (I'll call it ```\nleast_items```\n) items that you \nwill be leaving behind\nCheck if the total weight of the items in ```\nleast_items```\n is greater\nthan the max_weight.\n\n\nIf yes find the most valuable  items in ```\nleast_items```\n and remove them from least_items.This will be a place where you will have\nto    initiate some sort of recursion to keep seperating the least\nvalueable from the most valuable\nIf no that means you could fill you knapsack with more items.So then you have to go back to the most valuable items you had\nand keep    looking for the least valuable items until you fill the\nknapsack.Again some sort of  recursion will have too be initiated\n\n\n\nBut take note that you will also have to include a terminating step so that the program stops when it has found the best solution.\n\nThis is not the best solution you could make though.I tried finding something better myself but unfortunately it demands more time than I thought.Feel free to leave any problems in the comments.I'll be happy to help.\n\nHope this helps.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Dual knapsack algorithm\r\n                \r\nSay you have a warehouse with fragile goods (f.e. vegetables or fruits), and you can only take out a container with vegetables once. If you move them twice, they'll rot too fast and cant be sold anymore.\n\nSo if you give a value to every container of vegetables (depending on how long they'll still be fresh), you want to sell the lowest value first. And when a client asks a certain weight, you want to deliver a good service, and give the exact weight (so you need to take some extra out of your warehouse, and throw the extra bit away after selling).\n\nI don't know if this problem has a name, but I would consider this the dual form of the knapsack problem. In the knapsack problem, you want to maximise the value and limit the weight to a maximum. While here you want to minimise the value and limit the weight to a minimum.\n\nYou can easily see this duality by treating the warehouse as the knapsack, and optimising the warehouse for the maximum value and limited weight to a maximum of the current weight minus what the client asks.\n\nHowever, many practical algorithms on solving the knapsack problem rely on the assumption that the weight you can carry is small compared to the total weight you can chose from. F.e. the dynamic programming 0/1 solution relies on looping until you reach the maximum weight, and the FPTAS solution guarantees to be correct within a factor of (1-e) of the total weight (but a small factor of a huge value can still make a pretty big difference).\n\nSo both have issues when the wanted weight is big.\n\nAs such, I wondered if anyone studied the \"dual knapsack  problem\" already (if some literature can be found around it), or if there's some easy modification to the existing algorithms that I'm missing.\n    ", "Answer": "\r\nThe usual pseudopolynomial DP algorithm for solving knapsack asks, for each i and w, \"What is the largest total value I can get from the first i items if I use at most w capacity?\"\n\nYou can instead ask, for each i and w, \"What is the smallest total value I can get from the first i items if I use at least w capacity?\"  The logic is almost identical, except that the direction of the comparison is reversed, and you need a special value to record the possibility that even taking all i of the first i items cannot reach w capacity -- infinity works for this, since you want this value to lose against any finite value when they are compared with min().\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "The Knapsack Max Profit\r\n                \r\nThere are 4 items: A weights 2LB has profit $40, B weights 5LB has profit $30, C weights 10LB has profit $50, and D weights 5LB has profit $10. Compute the maximum total profit you can take from any of the 4 items with a knapsack weight 16LB. You cannot take any portions of an item but the whole.\n\nPlease show how can the above problem be solved using knapsack problem approach.\n    ", "Answer": "\r\nA simple solution is to consider all subsets of items and calculate the total weight and value of all subsets. Then you should consider taking only the subsets that weighs less or equal to the capacity of your knapsack. From all such subsets, pick the maximum value subset.\n\nTo consider all subsets of items, there can be two cases for every item:\n\n\nthe item is included in the optimal subset,\nthe item is not included in the optimal subset.\n\n\nLet's say the capacity of your knapsack is W. Therefore, the maximum value that can be obtained from n items is max of following two values.\n\n\nMaximum value obtained by n-1 items and W weight (excluding the nth item)\nValue of nth item plus maximum value obtained by n-1 items and W minus weight of the nth item (including nth item).\n\n\nIf weight of the nth item is greater than W, then the nth item can't be included and case 1 is the only option. This would be a naive approach and the solution would take 2n time.\n\nNow for the overlapping subproblem:\n\n```\nweight = {2, 5, 10, 5}\nCapacity = 16\nThe recursion tree would look like:       \n// Here n,k -> items remaining, capacity remaining\n// Going to left child -> including the item at hand\n// Going to right child -> excluding the item at hand\n                       _______4,16______    \n                      /                 \\   \n                     /                   \\\n                  3,14                     3,16\n                 /    \\                    /   \\\n                /      \\                  /     \\\n             2,9        2,14             2,5     2,16\n              \\          / \\             \\         / \\\n               \\        /   \\             \\       /   \\__\n               1,9   1,4   1,14          1,5     1,6     1,16\n              /\\            /\\          /\\       /\\        /  \\\n             /  \\          /  \\        /  \\     /  \\      /    \\\n           0,4  0,9      0,9  0,14    0,0 0,0  0,1  0,6   0,11   0,16\n```\n\n\nSince there are overlapping subproblems in the leaf, we can solve it using dynamic programming. If you store the values, it will be efficient to use them later. Here the match occurs in leaf nodes, if you take other examples, you'll see a match can occur far before the leaf nodes.\n\nThe pseudo-code would look like:\n\n```\nProcedure Knapsack(n, W):    //here, n = number of items, W = capacity of Knapsack\nfor i from 0 up to n\n    for j from 0 up to W\n        if i == 0 or j == 0\n            table[i][j] :=0\n        else if weight[i-1] <= j\n            table[i][j] := max(profit[i-1] + table[i-1][w-weight[i-1]], table[i-1][j])\n        else\n            table[i][j] := table[i-1][j]\n        end if\n    end for\nend for\nReturn table[n][W]\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Brute Force algorithm for multidimensional knapsack\r\n                \r\nI'm looking for a brute force algorithm for the multidimensional knapsack problem with 4 knapsacks. \n\nI have done some research on here and other websites but couldn't find anything helpful so far. Would be great if someone could point me in the right direction. Thanks!\n    ", "Answer": "\r\nDo you mean multiple knapsack problem where we have n items and m knapsacks?\n\nThe answers to this or this similar questions on stackexchange can be helpful.\n\nNote: I don't have enough points to write a comment.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack Heap Space\r\n                \r\nI have a problem with 0/1 Knapsack problem. There is data which as 400 rows and 9476897 knapsack capacity. I have also another big data(10.000rows). When i run the program it gives an error in 2 dimensional array. How can i change it? By the way i changed the -Xms all situations, but it didn't work.    \n\nERROR:\n    Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n    at Knapsack.simple_fill(Knapsack.java:108)\n    at Knapsack.main(Knapsack.java:99)\n\n```\n    int[][] s = new int[n + 1][W + 1];\n\n     for (int w = 0; w <= W; w++) {\n        s[0][w] = 0;\n    }\n    for (int i = 0; i <= n; i++) {\n        s[i][0] = 0;\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int w = 0; w <= W; w++) {\n            if (st[i].weight <= w) {\n                if (st[i].profit + s[i - 1][w - st[i].weight] > s[i - 1][w]) {\n                    s[i][w] = st[i].profit + s[i - 1][w - st[i].weight];\n\n                } else {\n                    s[i][w] = s[i - 1][w];\n                }\n            } else {\n                s[i][w] = s[i - 1][w];\n            }\n\n        }\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm dynamic programming .(incorrect output) here is what I have so far\r\n                \r\nI wrote this code for dynamic programming implementation of the knapsack problem.\n\n```\n#B = maximum weight\n#n = number of items\n#p = list of weights\n#a = list of values\n\n#p[i] = weight with value a[i]\n\n\n\n   def maximum_attractiveness(n, B, p, a):\n     f = [i for i in range(n+1)]\n     m = [f for i in range(B+1)]\n     m[0] = [0 for i in range(len(m[0]))]\n     for i in m:\n      i[0] = 0\n     print(m)\n     for j in range(n):\n      for w in range(B):\n       if (p[j]) > (w):\n        m[w][j] = m[w][j-1]\n       else:\n        m[w][j] = max(m[w][j-1],m[w-p[j]][j-1]+a[j])\n    return m[B][n]\n```\n\n\nI get an incorrect output for this algorithm.  where did I go wrong?\n    ", "Answer": "\r\n```\nf = [i for i in range(n+1)]\nm = [f for i in range(B+1)]\n```\n\n\nThis uses the same array ```\nf```\n for every position ```\nm```\n, so for example if you change ```\nm[1][k]```\n, you also change ```\nm[i][k]```\n for every ```\ni```\n. You probably meant to do\n\n```\nm = [[i for i in range(n+1)] for i in range(B+1)]\n```\n\n\nThere might be some other bugs I think, so maybe you should print out the intermediate arrays at some points to check out where the results are not what you'd expect them to be.\n\nUPDATE: \n\n\nYour initialization seems strange to me. I think it should be just  ```\nm = [[0]*n for i in range(B+1)]```\n because you need a matrix of zeroes. \nit should be ```\nfor w in range(B+1)```\n\nyou should not return ```\nm[B][n]```\n, but ```\nmax(m[j][n] for j in range(B+1))```\n.\n\n\nMy attempt, which avoids the the matrix altogether and only uses a single array:\n\n```\nm = [0]*(B+1)\nfor j in range(n):\n    for w in range(B,p[j]-1,-1):\n        m[w] = max(m[w], m[w-p[j]] + a[j])\nreturn max(m)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple Choice Knapsack\r\n                \r\nSo the standard multiple choice knapsack problem allows 1 item to be chosen from each class to create an optimal knapsack. However, how would I go about modifying this algorithm to allow 0 or 1 items to be chosen? i.e. an item doesn't need to be chosen from each class for the optimal solution, but at most 1 item can be chosen from a class. Is it just the same algorithm allowing no item to be chosen from a class?\n\nthanks\n    ", "Answer": "\r\nJust modify your original problem set by adding one zero-profit/zero-weight choice to each class.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "algorithm for the 0-1 Knapsack with 2 sacks?\r\n                \r\nformally, say, we have 2 sacks with capacities c1 and c2. There are N items with profits pi and weights wi. As in 0-1 Knapsack problem, we need to fill in c1 and c2 with these items in such a way the overall profit is maximized. Assume pi and wi are positive integers!\n\nFor the 2 knapsack problem does below recurrence relation hold good?\n\nDP[I][J][K] is maximum profit we could achieve from the first i items such that the weight of exactly j was used in knapsack #1 and a weight of exactly k was used in knapsack #2\n\nDP[i][j][k] = max(DP[i-1][j][k], DP[i][j-1][k], DP[i][j][k-1], DP[i][j-W[j]][k] +           C[i], DP[i][j][k-W[k]] + C[i])\n    ", "Answer": "\r\nSuppose C[i] and W[i] are the value and weight of item respectively. \n\nGiven that j-W[i] >0, k-W[i] > 0 (for the ease of writing the formula. We could still write a formula without this assumption by adding two more lines), the equation should be \n\nDP[i][j][k] = max(DP[i-1][j][k], DP[i-1][j-W[i]][k]+C[i],DP[i-1][j][k-W[i]]+C[i]) \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack with different profits and weights\r\n                \r\nI have n items and m knapsacks. Each item has a profit and weight that depend on on which knapsack to put the item in. For example, for item 1, the profits are 9 and 10 for knapsacks m=1 and 2 respectively.Also, the weights of item 1 are 3 Kg and 4 Kg for knapsacks m=1 and 2 respectively.  what category of knapsacks problems does this problem belong to?. Is there an efficient method to solve such problem?.\n\nI really appreciate your assistance.\n    ", "Answer": "\r\nThis is called the multiple knapsack problem and is also related to the bin-packing problem. Some googling should get you some basic references. It's NP-hard but there are decent algorithms.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to know what items are taken in 2 knapsack problem?\r\n                \r\nThis function takes:\n\n\ncar1_laod: KnapSack1 size.\ncar2_load: KnapSack2 size.\nN: Number of items in the shop.\nload: an array that carries the weight of the items.\nprice: an array that carries the price of the items.\ncar1_items: List that contains which items I picked and put inside car1.\ncar2_items: List that contains which items I picked and put inside car2.\n\n\nThe Goal is to know the max profit that I can get by adding items to car1 & car2\nitems cannot be selected twice.\n\n```\n    public static int GetMaximumProfit(int car1_load, int car2_load, int N, \n     int[] loads, int[] prices, List<int> car1_items, List<int> car2_items)\n    {\n        Console.WriteLine();\n        int[,] dp = new int[car1_load+1, car2_load+1];\n        for(int i=0;i<N;i++)\n        {\n            for (int ks1=car1_load;ks1>=0;ks1--)\n            {\n                for(int ks2 = car2_load;ks2>=0;ks2--)\n                {\n                    if (ks1 >= loads[i] && ks2 >= loads[i])\n                    {\n                        dp[ks1, ks2] = max(\n                                       dp[ks1, ks2],\n                                       dp[ks1 - loads[i], ks2] + prices[i],\n                                       dp[ks1, ks2 - loads[i]] + prices[i]\n                                        );\n                    }\n                    else if (ks1 >= loads[i])\n                    {  \n                        dp[ks1, ks2] = Math.Max(\n                                       dp[ks1, ks2],\n                                       dp[ks1 - loads[i], ks2] + prices[i]\n                                        );\n                    }\n                    else if (ks2 >= loads[i])\n                    {\n\n                        dp[ks1, ks2] = Math.Max(\n                                       dp[ks1, ks2],\n                                       dp[ks1, ks2 - loads[i]] + prices[i]\n                                        );\n                    }\n\n                }\n            }\n\n\n\n        }\n\n\n\n        cout(dp);\n        Console.WriteLine(\"Answer : \" + dp[car1_load, car2_load]);\n\n        return dp[car1_load,car2_load];\n    }\n```\n\n\nExample:\n\nInput:\n\nN = 4, car1_load = 5, car2_load = 2\n\nLoads[4] = {1,2,3,5}\n\nprices[4]={20,10,15,25}\n\nOutput:\n\nThe items to be inserted in the lists are the indices [1-based] of products selected to be loaded in both cars\n\nProfit = 45\n\nCar1 items = [2, 3]\n\nCar2 items = [ 1 ]\n\nMy output:\n\nExample output of the function\n\nI calculated the max  profit.\n\nThe Problem is that I don't know how to backtrack on the dp array to know where the items came from.\n    ", "Answer": "\r\nYou should add another dimension to your array for the item index, similar to the dynamic programming solution to the regular knapsack problem (you may be able to calculate it without this, but at the very least it's going to be more complex).\n\nI'll leave the specifics to you, but that will give you something like this:\n\n```\ndp[i, ks1, ks2] = max(\n    dp[i-1, ks1, ks2],\n    dp[i-1, ks1 - loads[i], ks2] + prices[i],\n    dp[i-1, ks1, ks2 - loads[i]] + prices[i]\n);\n```\n\n\nNow you need to start at the end and repeatedly figure out which one of the above values was the maximum and continuing with that value.\n\nThis can be done by just checking whether the left-hand side is equal to any of the values on the right-hand side.\n\n```\nint ks1 = car1_load, ks2 = car2_load;\nfor (i = N; i > 0; i--)\n{\n    if (ks1 >= loads[i] && dp[i, ks1, ks2] == dp[i-1, ks1 - loads[i], ks2] + prices[i])\n    {\n        // Add i to car 1\n        ks1 -= loads[i];\n    }\n    else if (ks2 >= loads[i] && dp[i, ks1, ks2] == dp[i-1, ks1, ks2 - loads[i]] + prices[i])\n    {\n        // Add i to car 2\n        ks2 -= loads[i];\n    }\n    // if it's equal to dp[i-1, ks1, ks2], we don't need to do anything\n}\n```\n\n\nThe code may look a bit different than this, depending on how you actually changed your code to add the item index as an array dimension.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Fractional Knapsack java implementation\r\n                \r\nSo I get the whole idea of the fractional knapsack problem, which is to optimally fill your container with fractional amounts of the given items that you have. \n\nHowever, I'm confused to how I can implement this algorithm into a java function? I need to solve it for my Coursera course. So if anyone can explain how to write this function I would really appreciate it. This is the question prompt:\n\n\n  Task. The goal of this code problem is to implement an algorithm for the > fractional knapsack problem.\n  Input Format. The first line of the input contains the number n of items > and the capacity W of a knapsack.\n  The next n lines define the values and weights of the items. The i-th > line contain integers vi and wi —\n  the value and the weight of i-th item, respectively.\n  Constraints. 1 ≤ n ≤ 103\n\n\nThis is what I have so far (this includes starter code from which the course provided to me) \n\n`\n\n```\npublic class FractionalKnapsack {\n  private static double getOptimalValue(int capacity, int[] values, int[] weights) {\n        //filling array vallues with 0\n        Arrays.fill(values,0);\n        //total value is 0\n        double value = 0;\n\n        for(int i=0; i<values.length; i++){\n            if(W==0){\n                return \n            }\n        }\n        //write your code here\n        //fit first the item with the maximal value per unit\n\n        //while knapsack is not full\n        //choose item with maxmimum v/wi\n        //if item fits into knapsack, take all of it\n        //else take so much to fill knapsack to end\n        //return total value and amounts taken\n\n        return value;\n    }\n\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int capacity = scanner.nextInt();\n        int[] values = new int[n];\n        int[] weights = new int[n];\n        for (int i = 0; i < n; i++) {\n            values[i] = scanner.nextInt();\n            weights[i] = scanner.nextInt();\n        }`   \n```\n\n    ", "Answer": "\r\nFractional Knapsack implies you can use Greedy Algorithm. You should fill with that item which has the highest ```\nvalue/weight```\n ratio. Sort all your items in decreasing order of the above ratio and start filling the knapsack with items one by one until knapsack is full. \n\nFor the last item you are putting in knapsack, that can be either full or partial which will depend upon the space left for that last item in the knapsack.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with Specific Item Requirements\r\n                \r\nI have a knapsack problem that has a weight capacity and a required combination of items. Here's the set up: The goal is to maximize utility (p) when the sum of the weights (w) is capped at 5000, but the knapsack can only contain 8 items and there are specific requirements for the items. The Knapsack must contain the following combination of 5 unique items:\n\n```\nItem_1 = Type_1\n\nItem_2 = Type_2\n\nItem_3 = Type_3\n\nItem_4 = Type_4\n\nItem_5 = Type_5\n\nItem_6 = Type_1 or Type_2\n\nItem_7 = Type_3 or Type_4\n\nItem_8 = Type_1 or Type_2 or Type_3 or Type_4 of Type_5\n```\n\n\nI have been using ```\nlpSolve```\n in R and have the following code:\n\n\n\n```\nlibrary(lpSolve)\n\np <- c(40,50,30,20,10,20,15,20,35,40)\n\nw <-c(100,200,300,400,500,400,300,300,400,200)\n\ncap<-5000\n\nexact.num.elt <- 8\n\nmod<-lp(direction=\"max\",objective.in=p,\nconst.mat= rbind(w,rep(1, length(p))),const.dir=c(\"<=\",\"=\"),const.rhs=c(cap,exact.num.elt),all.bin=TRUE)\n\nwhich(mod$solution>=0.999)\n```\n\n\n\n\nThis does not account for the combination requirements. Is there a way I can account for this? I would also like to see the top 20 combinations for comparison.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack, with 1 constraint! (can only have even number of items in knapsack) (3d array)\r\n                \r\nI am struggling to come up with a thorough algorithm to the following problem. \n\nSimilar to the original (or famous) 0-1 Knapsack problem, given a capacity, C, and items (v,w) where each item has a value, v, and a weight, w, we want to obtain the greatest possible sum of values such that the total weight of items in the knapsack will be <= C. \n\nBut we have only one constraint: \n - We can ONLY have an even number of items that go into the knapsack.\n\nSame approach, same problem to solve, but this time, there can only be an even number of items that eventually maximize the value sum in the knapsack. \n\nThis is my general Java code approach for solving the answer, ignoring the constraint. Is there a way to evolve this solution given the constraint? \n\n```\npublic static int max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\npublic static int knapSackMult(int capacity, Item[] items, int len,ArrayList<Item> bestItems){\n\n    int lookup[][] = new int[len + 1][capacity + 1]; //left column and top row all 0's \n    for (int row = 0; row <= len; row++){\n        for (int col = 0; col <= capacity; col++){\n\n            //base case \n            if (row == 0 || col == 0) {\n                lookup[row][col] = 0;\n            }\n\n            //if the current value's weight is <= current column (remember columns are from 0 to capacity so they indicate current weight\n            else if (items[row - 1].weight <= col) {\n                //will be the max of : 1) product of current value+above and left corresponding 2) one directly above \n                lookup[row][col] = max(items[row - 1].value + lookup[row - 1][col - items[row - 1].weight], lookup[row - 1][col]);\n            }\n            //otherwise just take the one above\n            else {\n                lookup[row][col] = lookup[row - 1][col];\n            }\n        }\n    }\n\n    int row = len; \n    int col = capacity;\n    while (row > 0) {\n        //if num above in LU is different than num \n        if (lookup[row][col] != lookup[row - 1][col]) {\n            //add it to our sumParts since we have a valid one\n            bestItems.add(items[row - 1]);\n            row--; //go up a row \n            col = col - items[row].weight; //go over current number in Array times\n        } \n        //otherwise go up a row\n        else {\n            row--;\n        }\n    }\n\n    return lookup[len][capacity];\n}}\n\nclass Item {\n\npublic int weight;\npublic int value;\n\npublic Item(int w, int v){\n    this.weight = w;\n    this.value = v; \n}}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Genetic Algorithm: Crossover for 0-1 Knapsack\r\n                \r\nI'm following the genetic algorithm approach to solving the Knapsack problem as seen here. I understand that they used a direct value encoding scheme rather than a binary representation. The crossover function is as follows:\n\n```\ndef cxSet(ind1, ind2):\n\"\"\"Apply a crossover operation on input sets. The first child is the\nintersection of the two sets, the second child is the difference of the\ntwo sets.\n\"\"\"\ntemp = set(ind1)                # Used in order to keep type\nind1 &= ind2                    # Intersection (inplace)\nind2 ^= temp                    # Symmetric Difference (inplace)\nreturn ind1, ind2\n```\n\n\nIf I were to encode the chromosomes of the Knapsack problem as binary representations, inersection would be an AND operation. What would be the analgous operation for set difference? \n\nAlso, I was just wondering what the rationale behind this type of crossover might be, and if there are advantages of this type of crossover over other usual crossover techniques like single point crossover or two-point crossover. \n    ", "Answer": "\r\nThe easiest way to solve such things is to make a small example:\n\n```\ns1 = {1, 2, 3, 4} => 11110000\ns2 = {3, 4, 5, 6} => 00111100\ns1 intersect s2 = {3, 4} => 00110000\ns1 difference s2 = {1, 2, 5, 6} => 11001100\n```\n\n\nLooking at this we come up with the following bitwise operators:\n\n\nintersect: s1 AND s2 (usually ```\n&```\n)\ndifference: s1 XOR s2 (usually ```\n^```\n)\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Optimal MLB lineup using Knapsack variant\r\n                \r\nI am writing a program to find the best possible MLB lineup using a knapsack solution.  For this I pass in player data which has a players calculated value and salary.  The salary will be my \"weight\" in terms of being a knapsack problem.\n\nMy problem is not be able to select players, but rather select the most optimal lineup.  I am choosing a pitcher, a center, first baseman, second baseman, third baseman, short stop, and three outfielders.  I can do this all successfully.  I want my \"weight\" to be 36,000, but I am currently only choosing a lineup with a total of 21,000.\n\nHere is my knapsack code:\n\n```\nCalculateLineUp.prototype.findOptimalLineUp = function(data, capacity) {\n  var items = data.data;\n  var idxItem   = 0,\n      idxCapSpace = 0,\n      idxPosition = 0,\n      oldMax    = 0,\n      newMax    = 0,\n      numItems  = items.length,\n      weightMatrix  = new Array(numItems+1),\n      keepMatrix    = new Array(numItems+1),\n      positionArray = new Array(\"P\", \"C\", \"1B\", \"2B\", \"3B\", \"SS\", \"OF\", \"OF\", \"OF\"),\n      solutionSet   = [];\n\n  // Setup matrices\n  for(idxItem = 0; idxItem < numItems + 1; idxItem++){\n    weightMatrix[idxItem] = new Array(capacity+1);\n    keepMatrix[idxItem]   = new Array(capacity+1);\n  }\n\n  // Build weightMatrix from [0][0] -> [numItems-1][capacity-1]\n  for (idxItem = 0; idxItem <= numItems; idxItem++){\n    for (idxCapSpace = 0; idxCapSpace <= capacity; idxCapSpace++){  \n\n          // Fill top row and left column with zeros\n          if (idxItem === 0 || idxCapSpace === 0){\n            weightMatrix[idxItem][idxCapSpace] = 0;\n          }\n\n          // If item will fit, decide if there's greater value in keeping it,\n          // or leaving it\n          else if (items[idxItem-1][\"Salary\"] <= idxCapSpace){\n            newMax = items[idxItem-1][\"Value\"] + weightMatrix[idxItem-1][idxCapSpace-items[idxItem-1][\"Salary\"]];\n            oldMax = weightMatrix[idxItem-1][idxCapSpace];\n\n            // Update the matrices\n            if(newMax > oldMax ){ \n              weightMatrix[idxItem][idxCapSpace]  = newMax;\n              keepMatrix[idxItem][idxCapSpace]    = 1;\n\n            }\n            else{\n              weightMatrix[idxItem][idxCapSpace]  = oldMax; \n              keepMatrix[idxItem][idxCapSpace]    = 0;\n            }\n          }\n\n          //Else, item can't fit; value and weight are the same as before\n           //else\n             //weightMatrix[idxItem][idxCapSpace] = weightMatrix[idxItem-1][idxCapSpace];\n    }\n  }\n\n  // Traverse through keepMatrix ([numItems][capacity] -> [1][?])\n  // to create solutionSet\n  idxCapSpace = capacity;\n  idxItem   = numItems;\n  for(idxItem; idxItem < capacity; idxItem--){\n    if(keepMatrix[idxItem][idxCapSpace] === 1 && !this.filledAllPositions(items[idxItem - 1][\"Position\"])){\n      solutionSet.push(items[idxItem - 1]);\n      idxCapSpace = idxCapSpace - items[idxItem - 1][\"Salary\"];\n    }\n  }\n  return {\"maxValue\": weightMatrix[numItems][capacity], \"set\": solutionSet};\n};\n```\n\n\nAm I making a blatant mistake that I am just not seeing, or is my logic completely off?\n    ", "Answer": "\r\nYou are checking the solutionSet right? The logic to accept positions is not a included in the knapsack logic, which means that the solutionSet is a filter on top of the knapsack solution. You did arrive at the right knapsack solution, but because, on top of the solution, you are checking if the position was already filled, a few items were eliminated from the solutionSet (items which were fighting for the same position) and the total weight decreased. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "DP algorithm for bounded Knapsack?\r\n                \r\nThe Wikipedia article about Knapsack problem contains lists three kinds of it:\n\n\n1-0 (one item of a type)\nBounded (several items of a type)\nUnbounded (unlimited number of items of a type)\n\n\nThe article contains DP approaches for 1. and 3. types of problem, but no solution for 2.\n\nHow can the dynamic programming algorithm for solving 2. be described?\n    ", "Answer": "\r\nUse the 0-1 variant, but allow repetition of an item in the solution up to the number of times specified in its bound. You would need to maintain a vector stating how many copies of each item you already included in the partial solution.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 knapsack TLE\r\n                \r\nI was solving 0-1 knapsack problem (src:https://www.interviewbit.com/problems/0-1-knapsack/)\nand would like to understand why I got TLE and know how to get rid of TLE .\nMy solution : (which showed TLE in hard case)\n```\nint knapsack(vector<int> A , vector<int> B, int weight , int n , vector<vector<int>> &dp ){\n    if(weight==0 || n==0){\n        // dp[weight][n] = 0;\n        return 0 ;\n    }\n    if(dp[weight][n]!=(-1)){\n        return dp[weight][n];\n    }\n    if(B[n-1]<=weight){\n        dp[weight][n] = max( (knapsack(A,B,weight,n-1,dp)) , (A[n-1] + knapsack(A,B,weight-B[n-1],n-1,dp))  );\n        return max( (knapsack(A,B,weight,n-1,dp)) , (A[n-1] + knapsack(A,B,weight-B[n-1],n-1,dp))  );\n    }\n    // if(B[n-1]>weight){\n    else{\n        dp[weight][n] = knapsack(A,B,weight,n-1,dp);\n        return knapsack(A,B,weight,n-1,dp);\n    }\n    \n}\n\nint Solution::solve(vector<int> &A, vector<int> &B, int C) {\n    int N = A.size();\n    // n rows and weights written vertically in columns \n    vector<vector<int>> dp(C+1, vector<int> (N+1,-1));\n    return knapsack(A,B,C,N,dp);\n}\n```\n\nOne solution which I found in discussion tab and does not get TLE which is exactly same as my solution :\n```\nint knapsack(vector<int>& wt, vector<int>& val, int W, int n, vector<vector<int>>& dp)\n{\n    if(n == 0 || W == 0)\n        return 0;\n    if(dp[n][W] != -1)\n        return dp[n][W];\n    \n    if(wt[n-1] <= W)\n    return dp[n][W] = max(val[n-1] + knapsack(wt, val, W-wt[n-1], n-1, dp), knapsack(wt, val, W, n-1, dp));\n    else\n    return dp[n][W] = knapsack(wt, val, W, n-1, dp);\n}\n\nint Solution::solve(vector<int> &val, vector<int> &wt, int W) \n{\n    int n = wt.size();\n    vector<vector<int>> dp(n+1 , vector<int> (W+1, -1));\n    return knapsack(wt, val, W, n, dp);\n}\n```\n\nIs it possible that using a bigger variable name caused me a TLE in the hard case ?\n    ", "Answer": "\r\nYou do too many recursive calls.\n```\nknapsack```\n is not a pure function. It has side effect of modifying ```\ndp```\n, and the compiler is not smart enough to figure out that a second call in the ```\nelse```\n branch\n```\n    dp[weight][n] = knapsack(A,B,weight,n-1,dp);\n    return knapsack(A,B,weight,n-1,dp);\n```\n\nis redundant. Help the compiler and optimize it out manually:\n```\n    dp[weight][n] = knapsack(A,B,weight,n-1,dp);\n    return dp[weight][n];\n```\n\nor, just as in the other solution\n```\n    return dp[weight][n] = knapsack(A,B,weight,n-1,dp);\n```\n\nDitto for the ```\nif```\n branch,\n(And no, variable names do not affect performance).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "can 0-1 knapsack be implemented using 1D array? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI found implementation using 2D array http://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/. But how to implement it using 1D array and if it is not possible then why?\n    ", "Answer": "\r\nNote that each of values in the current row uses only elements of the current and previous rows. Hence you can implement the algorithm with an array ```\nK[2][W]```\n, which is the same as using an array ```\nK[2*W]```\n with some additional trivial index calculations\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack beginner python\r\n                \r\nI have trouble finding a solution to the knapsack problem that that is suitable for beginners.\n\n```\ndef fill_bag(max_weight, value, weight):\n    # Zero Weight\n    if max_weight <= 0:\n        return 0\n    # Invalid parameters\n    if len(value) != len(weight):\n        raise ValueError\n    # Empty values\n    elif value == [] or weight == []:\n        return 0\n\n    # Include current item in bag and recur for remaining items with decreased capacity\n    include = value[-1] + fill_bag(max_weight - weight[-1], value[:-1], weight[:-1])\n\n    # Exclude current item from bag and recur for remaining items\n    exclude = fill_bag(max_weight, value[:-1], weight[:-1])\n\n    return max(include, exclude)\n\nprint(fill_bag(10, [20, 5, 10, 40, 15, 25], [1, 2, 3, 8, 7, 4]))\n```\n\n\nShould return 60, but in my case it returns 65.\nWhile debugging i noticed that the max_weight of exclude is carried on from the include from before. Is the problem that I somehow don't reset the max_weight/capacity?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack dynamic in R\r\n                \r\nI am trying to implement the sudo code from wikepedia in order to solve the knapsack problem but my code fails.\nMy function takes as input a data frame X with 2 columns,the first was the weights and second the values   \n\n```\n weights value\n    10   110\n    20   150\n    15   180\n    30   170\n    18   130\n\nknapsnack_dyn<-function(X,W){\n  w<-c(0,X[,1])\n  v<-c(0,X[,2])\n  n<-nrow(X)\n  m<- matrix(0,nrow=n+1,ncol=W+1)\n  keep<-m\n  res<-c()\n  for (i in 1:n+1){\n    for (j in 0:W+1){\n      if (w[i]>j ){\n        m[i,j]<-m[i-1,j]\n        keep[i,j]<-0\n      }else{\n        m[i,j]<-max(m[i-1, j], m[i-1, j-w[i]] + v[i])\n        keep[i,j]<-1\n      }\n    } \n  }\n  K=W+1\n  for (i in n+1:1){\n    if(keep[i,K]==1){\n      res[i]<-i\n      K=K-w[i]\n    }\n  }\nreturn(c(res,m[n+1,W+1]))\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Is my javascript implementation of a DP solution to Knapsack properly utilizing a memoization table?\r\n                \r\nThis is my javascript implementation for the knapsack problem. In this problem, you are given a list of items with weights and values, and a knapsack with a weight capacity. The object is to determine how to maximize the value of objects you can hold in the knapsack without exceeding the weight capacity. My function below takes two parameters, items (an array of item objects, each containing a weight and value field, and a capacity integer representing the knapsack weight capacity. I use a memo table in which each index:weight is stored for repeated access to avoid duplicate calculations of getMax(). Is my implementation good? Can it be improved?\n\n```\nfunction knapsackMaxValue(items, capacity) {\n  const memo = {}\n  function getMax(i, weight) {\n    if (i == items.length) {\n      return 0;\n    }\n    if (memo[i + ':' + weight] != undefined) {\n      console.log('memo found')\n      return memo[i + ':' + weight]\n    }\n    if (items[i].weight + weight > capacity) {\n      memo[i + ':' + weight] = getMax(i + 1, weight)\n      return memo[i + ':' + weight]\n    } else {\n      let maxValue = Math.max(getMax(i + 1, weight), items[i].value + getMax(i + 1, weight + items[i].weight))\n      memo[i + ':' + weight] = maxValue\n      return maxValue\n    }\n  }\n  return getMax(0, 0)\n}\n```\n\n\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Modified Knapsack algorithm\r\n                \r\nI've different classes of items. Each item has ```\nvalue```\n and ```\nweight```\n. \n\nFor example:\n\n```\nClassA: [A1, A2, A3]```\n\n\n```\nClassB: [B1, B2, B3]```\n\n\n```\nClassC: [C1, C2, C3]```\n\n\nHow should I modify classic 0-1 Knapsack problem so that algorithm optimize solution maximizing overall value, consider all items in class but allowed to pick at at most one item from one class?\n\n```\npackage knapsack;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Knapsack {\n\n    private int totalNumberOfItems;\n    private int maxmimumKnapsackCapacityUnits;\n\n    private double[][] optimum;\n    private boolean[][] solution;\n\n    private double [] value;\n    private int [] weight;\n\n    public Knapsack(int knapsackCapacityUnits, List<KnapsackItem> items){\n\n        this.totalNumberOfItems = items.size();\n        this.maxmimumKnapsackCapacityUnits = knapsackCapacityUnits;\n\n        this.optimum = new double[items.size() + 1][knapsackCapacityUnits + 1];\n        this.solution = new boolean[items.size() + 1][knapsackCapacityUnits + 1];\n\n        this.value = new double[items.size() + 1];\n        this.weight = new int[items.size() + 1];\n\n        int index=1;\n        for(KnapsackItem item : items){\n            value[index] = item.value;\n            weight[index] = item.weight;\n            index++;\n        }\n\n\n}\n\npublic List<KnapsackItem> optimize(){\n\n    for(int currentItem = 1; currentItem <= totalNumberOfItems; currentItem++){\n        for(int currentWeightUnit = 1; currentWeightUnit <= maxmimumKnapsackCapacityUnits; currentWeightUnit++){\n\n            double option1 = optimum[currentItem - 1][currentWeightUnit];\n\n            double option2 = Integer.MIN_VALUE;\n\n            if(weight[currentItem] <= currentWeightUnit){\n                option2 = value[currentItem] + optimum[currentItem-1][currentWeightUnit - weight[currentItem]];\n            }\n\n            optimum[currentItem][currentWeightUnit] = Math.max(option1, option2);\n            solution[currentItem][currentWeightUnit] = (option2 > option1);\n        }\n    }\n\n    boolean take [] = new boolean[totalNumberOfItems + 1];\n    for(int currentItem = totalNumberOfItems,\n            currentWeightUnit = maxmimumKnapsackCapacityUnits; \n            currentItem > 0; currentItem --){\n        if(solution[currentItem][currentWeightUnit]){\n            take[currentItem] = true;\n            currentWeightUnit = currentWeightUnit - weight[currentItem];\n        }\n        else{\n            take[currentItem] = false;\n        }\n    }\n\n    List<KnapsackItem> items = new ArrayList<KnapsackItem>();\n    for(int i = 0; i < take.length; i++){\n        KnapsackItem newItem = new KnapsackItem();\n        newItem.value = value[i];\n        newItem.weight = weight[i];\n        newItem.isTaken = take[i];\n        items.add(newItem);\n    }\n\n    return items;\n}\n}\n```\n\n\nThanks!\n    ", "Answer": "\r\nThe classic algorithm goes like:\n\n```\nfor i in items:\n    for w in possible total weights (downwards):\n        if w is achievable with maximum value v:\n            (w + weight[i]) is also achievable with at least value (v + value[i])\n```\n\n\nThe approach here will be a slight variation of that:\n\n```\nfor c in classes:\n    for w in possible total weights (downwards):\n        if w is achievable with maximum value v:\n            for i in items of class c:\n                (w + weight[i]) is also achievable with at least value (v + value[i])\n```\n\n\n\n\nWith your code, the changes would be the following:\n\n\nPerhaps you will want to make a separate list of items for each class. In line with what is currently done, I'd expect ```\nvalue```\n and ```\nweight```\n to become lists of lists, and some variable and array named like ```\nnumberOfClasses```\n and ```\nnumberOfClassItems```\n to monitor the lengths of the new lists.\nFor example, suppose two class 1 items are (w=2,v=3) and (w=3,v=5), and three class 2 items are (w=1,v=1), (w=4,v=1) and (w=1,v=4). Then we will have:\n```\ntotalNumberOfItems = 5```\n,\n```\nnumberOfClasses = 2```\n,\n```\nnumberOfClassItems = [2, 3]```\n,\n```\nvalue  = [[3, 5], [1, 1, 4]]```\n and\n```\nweight = [[2, 3], [1, 4, 1]]```\n.\nThat is if you index from ```\n0```\n.  Indexing from ```\n1```\n as you do will leave unused zeroes or empty lists at the start of each list.\nThe ```\nfor (currentItem)```\n loop will become a ```\nfor (currentClass)```\n loop. The arrays ```\noptimum```\n and ```\nsolution```\n will be indexed by ```\ncurrentClass```\n instead of ```\ncurrentItem```\n.\nThe value ```\noption2```\n will in fact be calculated as the best of several options, one per class item:\n```\n\ndouble option2 = Integer.MIN_VALUE;\nfor (currentItem = 1; currentItem <= numberOfClassItems[currentClass];\n     currentItem++){\n    if(weight[currentClass][currentItem] <= currentWeightUnit){\n        option2 = Math.max (option2, value[currentClass][currentItem] +\n                  optimum[currentClass - 1][currentWeightUnit -\n                                            weight[currentClass][currentItem]]);\n    }\n}\n```\n\nPerhaps the ```\nsolution```\n array should now contain ```\nint```\n instead of ```\nboolean```\n: the number of item of this class which we take, or some sentinel value (```\n0```\n or ```\n-1```\n) if we take ```\noption1```\n and don't use any item of this class.\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Jenetics constraint seems to have no effect\r\n                \r\nI have implemented a variant of the knapsack problem using Jenetics as follows:\n\n```\n@Value\npublic class Knapsack {\n\n    public static void main( final String[] args ) {\n        final var knapsackEngine = Engine.builder( Knapsack::fitness, Knapsack.codec() )\n                .constraint( Knapsack.constraint() )\n                .build();\n        final var bestPhenotype = knapsackEngine.stream()\n                .limit( 1000L )\n                .collect( EvolutionResult.toBestPhenotype() );\n        final var knapsack = bestPhenotype.getGenotype().getGene().getAllele();\n        final var profit = bestPhenotype.getFitness();\n        final var weight = knapsack.getWeight();\n        System.out.println( \"Valid: \" + bestPhenotype.isValid() );\n        System.out.println( String.format( \"Solution: profit %d | weight %d\", profit, weight ) );\n        System.out.println( String.format( \"Optimum: profit %d | weight %d\", Problem.OPTIMAL_PROFIT, Problem.OPTIMAL_WEIGHT ) );\n    }\n\n    List<Item> items;\n\n    public int getProfit() {\n        return items.stream()\n                .mapToInt( Item::getProfit )\n                .sum();\n    }\n\n    public int getWeight() {\n        return items.stream()\n                .mapToInt( Item::getWeight )\n                .sum();\n    }\n\n    private static Codec<Knapsack, AnyGene<Knapsack>> codec() {\n        return Codec.of(\n                Genotype.of( AnyChromosome.of( Knapsack::create ) ),\n                genotype -> genotype.getGene().getAllele() );\n    }\n\n    private static Knapsack create() {\n        final Random rand = RandomRegistry.getRandom();\n        final List<Item> items = Problem.ITEMS.stream()\n                .filter( item -> rand.nextBoolean() )\n                .collect( Collectors.toList() );\n        return new Knapsack( items );\n    }\n\n    private static int fitness( final Knapsack knapsack ) {\n        return knapsack.getProfit();\n    }\n\n    private static Constraint<AnyGene<Knapsack>, Integer> constraint() {\n        return Constraint.of( phenotype -> {\n            final Knapsack knapsack = phenotype.getGenotype().getGene().getAllele();\n            final int weight = knapsack.getItems().stream()\n                    .mapToInt( Item::getWeight )\n                    .sum();\n            return weight <= Problem.MAX_CAPACITY;\n        } );\n    }\n\n}\n```\n\n\n```\n@Value```\n is part of Lombok and generates a bunch of code like a constructor, getters, etc. The ```\nProblem```\n class defines some constants for a particular knapsack problem (P07 from https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html):\n\n```\npublic class Problem {\n\n    public static final int MAX_CAPACITY = 750;\n\n    public static final BitChromosome OPTIMAL_SOLUTION = BitChromosome.of( \"101010111000011\" );\n\n    public static final int OPTIMAL_PROFIT = 1458;\n\n    public static final int OPTIMAL_WEIGHT = 749;\n\n    private static final List<Integer> profits = List.of(\n            135, 139, 149, 150, 156,\n            163, 173, 184, 192, 201,\n            210, 214, 221, 229, 240 );\n\n    private static final List<Integer> weights = List.of(\n            70, 73, 77, 80, 82,\n            87, 90, 94, 98, 106,\n            110, 113, 115, 118, 120 );\n\n    public static final List<Item> ITEMS = IntStream.range( 0, profits.size() )\n            .mapToObj( i -> new Item( profits.get( i ), weights.get( i ) ) )\n            .collect( Collectors.toList() );\n\n}\n```\n\n\nAlthough the Jenetics user guide says (see section 2.5):\n\n\n  A given problem should usually encoded in a way, that it is not possible for the evolution ```\nEngine```\n to create invalid individuals (```\nGenotypes```\n).\n\n\nI wonder why the engine constantly creates solutions with a weight that exceed the knapsack's maximum capacity. So although these solutions are invalid according to the given ```\nConstraint```\n, ```\nPhenotype#isValid()```\n returns ```\ntrue```\n.\n\nI'm able to fix this issue by changing the fitness function to:\n\n```\nprivate static int fitness( final Knapsack knapsack ) {\n    final int profit = knapsack.getProfit();\n    final int weight = knapsack.getWeight();\n    return weight <= Problem.MAX_CAPACITY ? profit : 0;\n}\n```\n\n\nOr by making sure the codec can only create valid solutions:\n\n```\nprivate static Knapsack create() {\n    final Random rand = RandomRegistry.getRandom();\n    final List<Item> items = Problem.ITEMS.stream()\n            .filter( item -> rand.nextBoolean() )\n            .collect( Collectors.toList() );\n    final Knapsack knapsack = new Knapsack( items );\n    return knapsack.getWeight() <= Problem.MAX_CAPACITY ? knapsack : create();\n}\n```\n\n\nBut then what is the purpose of ```\nConstraint```\n if it has no effect?\n    ", "Answer": "\r\nI introduced the ```\nConstraint```\n interface in the latest version of Jenetics. It is meant as the last line of defense, when it comes to check the validity of an individual. In your example you used the factory method of the ```\nConstraint```\n interface, which only takes the validity predicate. The second important method of the ```\nConstraint```\n is the ```\nrepair```\n method. This method tries to fix the given individual. Without defining this method, only a new, random phenotype is created. Since this interface is new, it seems that I haven't explained the intended use of the ```\nConstraint```\n interface good enough. It's on my agenda #541. One possible usage example is given in #540, in the second example.\n\n```\nvoid constrainedVersion() {\n    final Codec<double[], DoubleGene> codec = Codecs\n        .ofVector(DoubleRange.of(0, 1), 4);\n\n    final Constraint<DoubleGene, Double> constraint = Constraint.of(\n        pt -> isValid(codec.decode(pt.getGenotype())),\n        (pt, g) -> {\n            final double[] r = normalize(codec.decode(pt.getGenotype()));\n            return newPT(r, g);\n        }\n    );\n}\n\nprivate static Phenotype<DoubleGene, Double> newPT(final double[] r, final long gen) {\n    final Genotype<DoubleGene> gt = Genotype.of(\n        DoubleChromosome.of(\n            DoubleStream.of(r).boxed()\n                .map(v -> DoubleGene.of(v, DoubleRange.of(0, 1)))\n                .collect(ISeq.toISeq())\n        )\n    );\n    return Phenotype.of(gt, gen);\n}\n\nprivate static boolean isValid(final double[] x) {\n    return x[0] + x[1] + x[2] == 1 && x[3] > 0.8;\n}\n\n\nprivate static double[] normalize(final double[] x) {\n    double[] r = x;\n    final double sum = r[0] + r[1] + r[2];\n    if (sum != 1) {\n        r[0] /= sum;\n        r[1] /= sum;\n        r[2] /= sum;\n    }\n    if (r[3] > 0.8) {\n        r[3] = 0.8;\n    }\n    return r;\n}\n```\n\n\nAnd the ```\nPhenotype::isValid```\n method returns ```\ntrue```\n, because it's a local validity check, which only checks if all chromosomes and genes of the individual are valid or in the valid range.\n\nI hope I could answer your question, and a better description with one (or more) examples is on the way. On the other hand: if you have ideas for good usage examples of the ```\nConstraint```\n interface, let me know.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack / Bin Packing Problem with a twist?\r\n                \r\nSo, I've been searching far and wide and I'm still not sure what the correct classification of the problem that I'm dealing with is, so I can't really search for solutions to it.\nI have x amount of different objects (of which I know their H/W/L) and I want to fit them into boxes, but I don't want to fit as many in one box as possible, one object goes into one box.\nI want to decide on how many different sizes of boxes I would need to fit those objects into them, while also minimizing the amount of different sized boxes.\nOne thing that makes the problem a little easier is that the width and height of the objects are the same for all objects, so length is the only issue.\nTo give a more practical idea of what my use case would be, the problem at hand is how does a company determine, which different box sizes they should have in order to fit all their different products into them, without having unnecessarily many different box sizes.\nExample: I have an object that has a length of 1200 mm and another one that has a length of 1150 mm, both share the same width and height. Since the difference in length is so small, it would make sense to not have an extra box size just for that 1150 mm object and use the same box for both.\nMy idea to solve the problem was to cluster the objects using an algorithm and playing around with the number or the center of clusters.\nWhat type of problem am I looking at and what type of algorithm would be best to cluster my objects?\n    ", "Answer": "\r\nClustering is a good solution for this problem. Find the clusters but then get the max length from the cluster because a smaller object from the cluster will be able to fit into a big box but it will not be possible for the big object to fit into a small box.\nThe number of clusters will indicate the number of box sizes you will have. But you might also have some outliers for example you might have a cluster with heights from 1 to 15 but only one height is 15 while the rest are less than 10. So, in that case you will have to decide if you want a box of size 15 or you want two boxes of 10 and 15 height.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "ArrayIndexOutofBoundsException in Knapsack Scala\r\n                \r\nI am trying to solve Knapsack problem in Scala using dynamic programming .As a part of requirement I also need to show which items are picked to be filled in Knapsack.But I am getting \"ArrayIndexOutOfBoundException\".\nAnd so far what I have code is like :\n\n```\navailableMoney is equivalent to weight of knapsack.products.channels is equivalent to value[] in knapsack.products.price is equivalent to weight[] in knapsack.\n\ndef knapSack(availableMoney: Int, products: List[Product]) : Int = {\n    var wt = List[Int](products.length)\n    var value = List[Int](products.length)\n    for (product <- products) {\n      value ::= product.channels.length\n      wt ::= product.price\n    }\n\n    val matrix = Array.fill(2, 2)(0)\n    val picks = Array.fill(2, 2)(0)\n\n\n    for (i <- 1 to products.length){\n        for (j <- 0 to availableMoney){\n            if (wt(i-1)<=j){\n                matrix(i)(j) = max(matrix(i-1)(j),value(i-1)+matrix(i-1)(j-wt(i-1)));\n                if (value(i-1)+matrix(i-1)(j-wt(i-1))>matrix(i-1)(j))\n                    picks(i)(j)= 1;\n                else\n                    picks(i)(j)= -1;\n            }\n            else{\n                picks(i)(j) = -1;\n                matrix(i)(j) = matrix(i-1)(j);\n            }\n        }\n    }\n\n    matrix(products.length)(availableMoney)\n\n}\n```\n\n    ", "Answer": "\r\nThere are a couple of issues I think:\n\n\nj runs from 0 to availableMoney, and is then used as an index into ```\npicks```\n and ```\nmatrix```\n which have been initialised to specific sizes, so if availableMoney exceeds those dimensions, it will fail\ni runs from 1 to products.length but is also used as an index into ```\npicks```\n and ```\nmatrix```\n, so will miss 0 and if there are more products than the second dimension size, it will fail\n\n\nUse some println debugging to check more closely what is going on. Looks like an interesting algorithm. Post us a solution once you get it working :)\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to code a dynamic solution for the 0/1 Knapsack with a specific number of each item\r\n                \r\nIs it possible to code a dynamic solution to a 1/0 knapsack problem that has a requirement for the number of each item?\n\nFor example the knapsack requires:\n\n1 of item_one\n\n2 of item_two\n\n3 of item_three\n\n1 of item_four\n\n1 of item_five\n\n1 of item_six\n\neach item has a weight and there is a max weight of 60000 so in that sense it is just a normal knapsack problem.\n\nbeyond that the only difference is Im trying to minimize value instead of maximize.\n\nHere is my brute force code in vba but Im running this over hunderes of items so I need a faster solution. Thanks for the help!\n\n```\n Function knapsacksolver(item_one, item_two, item_three, item_four, item_five, item_six)\n    Dim knapsack  As Variant\n    ReDim knapsack(1 To 9, 1 To 5) As Variant\n    Dim Value As Long\n    Dim MinValue As Long\n    Dim Cap As Long\n    Dim weight As Long\n\n    MinValue = 9999999\n    weight = 0\n    Cap = 60000\n\n    For i = 1 To UBound(item_one)\n        For j = 1 To UBound(item_two)\n            For t = 1 To UBound(item_two)\n                If j <> t Then\n                    For m = 1 To UBound(item_three)\n                        For n = 1 To UBound(item_three)\n                            If n <> m Then\n                                For p = 1 To UBound(item_three)\n                                    If n <> p Then\n                                        For q = 1 To UBound(item_four)\n                                            For r = 1 To UBound(item_five)\n                                                For s = 1 To UBound(item_six)\n                                                        weight = item_one(i, 3) + item_two(j, 3) + item_two(t, 3) + item_three(m, 3) + item_three(n, 3) + item_three(p, 3) + item_four(q, 3) + item_five(r, 3) + item_six(s, 3)\n                                                        Value = item_one(i, 4) + item_two(j, 4) + item_two(t, 4) + item_three(m, 4) + item_three(n, 4) + item_three(p, 4) + item_four(q, 4) + item_five(r, 4) + item_six(s, 4)\n\n                                                        If Value < MinValue And weight < Cap Then\n                                                            MinValue = Value\n                                                            'adding attribute from each item to array'\n                                                            knapsack(1, 1) = item_one(i, 1)\n                                                            knapsack(1, 2) = item_one(i, 2)\n                                                            knapsack(1, 3) = item_one(i, 3)\n                                                            knapsack(1, 4) = item_one(i, 4)\n                                                            knapsack(1, 5) = item_one(i, 5)\n\n                                                            knapsack(2, 1) = item_two(j, 1)\n                                                            knapsack(2, 2) = item_two(j, 2)\n                                                            knapsack(2, 3) = item_two(j, 3)\n                                                            knapsack(2, 4) = item_two(j, 4)\n                                                            knapsack(2, 5) = item_two(j, 5)\n\n                                                            knapsack(3, 1) = item_two(t, 1)\n                                                            knapsack(3, 2) = item_two(t, 2)\n                                                            knapsack(3, 3) = item_two(t, 3)\n                                                            knapsack(3, 4) = item_two(t, 4)\n                                                            knapsack(3, 5) = item_two(t, 5)\n\n                                                            knapsack(4, 1) = item_three(m, 1)\n                                                            knapsack(4, 2) = item_three(m, 2)\n                                                            knapsack(4, 3) = item_three(m, 3)\n                                                            knapsack(4, 4) = item_three(m, 4)\n                                                            knapsack(4, 5) = item_three(m, 5)\n\n                                                            knapsack(5, 1) = item_three(n, 1)\n                                                            knapsack(5, 2) = item_three(n, 2)\n                                                            knapsack(5, 3) = item_three(n, 3)\n                                                            knapsack(5, 4) = item_three(n, 4)\n                                                            knapsack(5, 5) = item_three(n, 5)\n\n                                                            knapsack(6, 1) = item_three(p, 1)\n                                                            knapsack(6, 2) = item_three(p, 2)\n                                                            knapsack(6, 3) = item_three(p, 3)\n                                                            knapsack(6, 4) = item_three(p, 4)\n                                                            knapsack(6, 5) = item_three(p, 5)\n\n                                                            knapsack(7, 1) = item_four(q, 1)\n                                                            knapsack(7, 2) = item_four(q, 2)\n                                                            knapsack(7, 3) = item_four(q, 3)\n                                                            knapsack(7, 4) = item_four(q, 4)\n                                                            knapsack(7, 5) = item_four(q, 5)\n\n                                                            knapsack(8, 1) = item_five(r, 1)\n                                                            knapsack(8, 2) = item_five(r, 2)\n                                                            knapsack(8, 3) = item_five(r, 3)\n                                                            knapsack(8, 4) = item_five(r, 4)\n                                                            knapsack(8, 5) = item_five(r, 5)\n\n                                                            knapsack(9, 1) = item_six(s, 1)\n                                                            knapsack(9, 2) = item_six(s, 2)\n                                                            knapsack(9, 3) = item_six(s, 3)\n                                                            knapsack(9, 4) = item_six(s, 4)\n                                                            knapsack(9, 5) = item_six(s, 5)\n\n                                                        End If\n                                                        weight = 0\n                                                Next s\n                                            Next r\n                                        Next q\n                                    End If\n                                Next p\n                            End If\n                        Next n\n                    Next m\n                End If\n            Next t\n        Next j\n    Next i\n\n    knapsacksolver = knapsack\nEnd Function\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Printing out result in 0/1 KnapSack (Recursive Brute Force)\r\n                \r\n```\npublic static int KnapSack(int capacity, Item[] items, int numItems) {\n    if (numItems == 0 || capacity == 0)\n        return 0;\n    if (items[numItems-1].weight > capacity)\n        return KnapSack(capacity, items, numItems-1);\n    else {\n        int took = items[numItems-1].value + KnapSack(capacity - items[numItems-1].weight, items, numItems-1);\n        int left = KnapSack(capacity, items, numItems-1);\n        return Math.max(took, left);\n    }     \n}  \n```\n\n\nSo I have a working 0/1 recursive brute force algorithm working for the KnapSack problem. I was wondering of what would be an approach to print out the working solution (i.e the items collected into the knapsack from the set of items). I've tried a number of things such as adding into a list and trying to keep track of what things I have added, but none of worked out either do to implementation or design problem. So I came here for some help, thanks!\n    ", "Answer": "\r\nTo track the items taken, try something like:\n\n```\npublic static int KnapSack(int capacity, Item[] items, int numItems, ArrayList<Integer> taken) {\n    if (numItems == 0 || capacity == 0)\n        return 0;\n    if (items[numItems-1].weight > capacity)\n        return KnapSack(capacity, items, numItems-1, taken);\n    else {\n        final int preTookSize = taken.size();\n        final int took = items[numItems-1].value + KnapSack(capacity - items[numItems-1].weight, items, numItems-1, taken);\n\n        final int preLeftSize = taken.size();\n        final int left = KnapSack(capacity, items, numItems-1, taken);\n\n        if (took > left) {\n            if (taken.size() > preLeftSize)\n                taken.removeRange(preLeftSize, taken.size());\n            taken.add(Integer.valueOf(numItems - 1));\n            return took;\n        }\n        else {\n            if (preLeftSize > preTookSize)\n                taken.removeRange(preTookSize, preLeftSize);\n            return left;\n        }\n    }     \n}\n```\n\n\nThis may not be the most efficient, but I think it should work.  \n\n(For efficiency you might try pre-allocating the taken ArrayList to be \"big enough\" such that no allocations need to happen during the recursive looping.)\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What's wrong with the following implementation of the Knapsack stuffing algorithm?\r\n                \r\nEdit2: Now fails for test({64, 1, 36, 81}, 82)\nEdit1: Now updated to fix problems because of delta > max(items)\nEdit0: Now updated to fix the infinite recursion due to oscillating delta problem.\n\n\n\nIn this algorithms video (at around 2:52) Prof. Skiena specifies the knapsack problem as follows...\n\nThe Knapsack problem: Given a set of integers S = {s1, s2,..., sN} and given a target number T find a subset of S which adds up exactly to T.\n\nThen he goes on to say that this is one of those problems for which no known efficient solution exists!\n\nBut I tried anyway and here is my attempt at a solution (and it seems to work for the numbers I have tried)...\n\n```\nfrom itertools import accumulate\n\n#items   - All available items\n#target  - The size of the knapsack\n#returns - A subset of {items} whose sum adds upto target\n#          if possible else returns None\ndef KnapsackItems(items, target):\n    s = sum(items)\n    if s < target:\n        return None\n    delta = s - target\n\n    if delta == 0:\n        return items\n\n    if delta in items:\n        result = items - {delta}\n        return result\n\n    if delta > max(items):\n        sortedItems = list(sorted(items))\n        deltas = list(map(lambda x: x - target, accumulate(sortedItems)))\n        ul = [i for i,d in zip(sortedItems, deltas) if d <= i]\n        return KnapsackItems(set(ul), target)\n    else:\n        U = {i for i in items if i < delta}\n\n    V = KnapsackItems(U, delta)\n    if V:\n        result = items - V\n        return result\n    return None\n```\n\n\nAnd here is the test harness...\n\n```\ndef test(items, target):\n    print(\"Items:\", items)\n    print(\"Target:\", target)\n\n    result = KnapsackItems(items, target)\n\n    if result and not sum(result) == target:\n        print(\"Result:\", result)\n        print(\"FAIL: sum of returned set does not match target ({})\".format(target))\n    elif result:\n        print(\"Result:\", result)\n        print(\"Success (sum of returned set:{})\".format(sum(result)))\n    else:\n        print(\"No solution could be found\")\n```\n\n\nExamples from the video...\n\n```\ntest({1,2,5,9,10}, 22)\ntest({1,2,5,9,10}, 23) #No solution expected\ntest({1,2,3,4,5}, 11)\ntest({1,2}, 2)\ntest({4,3,2}, 5)\ntest({1, 3, 4, 7, 9}, 13)\ntest({6,7,8,3,14,5,15,2,4}, 29)\ntest({1,2,3,4,5,6,7},14)\ntest({64, 1, 36, 81}, 82)\n```\n\n\nResult...\n\n```\nItems: {9, 10, 2, 5, 1}\nTarget: 22\nResult: {9, 10, 2, 1}\nSuccess (sum of returned set:22)\n\nItems: {9, 10, 2, 5, 1}\nTarget: 23\nNo solution could be found\n\nItems: {1, 2, 3, 4, 5}\nTarget: 11\nResult: {1, 2, 3, 5}\nSuccess (sum of returned set:11)\n\nItems: {1, 2}\nTarget: 2\nResult: {2}\nSuccess (sum of returned set:2)\n\nItems: {2, 3, 4}\nTarget: 5\nResult: {2, 3}\nSuccess (sum of returned set:5)\n\nItems: {9, 3, 4, 1, 7}\nTarget: 13\nResult: {9, 4}\nSuccess (sum of returned set:13)\n\nItems: {2, 3, 4, 5, 6, 7, 8, 14, 15}\nTarget: 29\nResult: {14, 15}\nSuccess (sum of returned set:29)\n\nItems: {1, 2, 3, 4, 5, 6, 7}\nTarget: 14\nResult: {2, 5, 7}\nSuccess (sum of returned set:14)\n\nItems: {64, 81, 36, 1}\nTarget: 82\nNo solution could be found\n```\n\n\nSo now I guess the question is what is wrong with my solution to the knapsack problem? Is it inefficient and unusable for very large sets of numbers? Also please let me know if this is not the right place for such questions.\n    ", "Answer": "\r\nWhen ```\nmax(items) < target < sum - max(items)```\n (I don't know Python) then ```\ndelta```\n will always be more than ```\nmax(items)```\n and no items will ever be removed before the recursive check, and the algorithm will never terminate.\n\nEdited version:\n\nIt now fails when ```\nmax(items)```\n cannot be part of the solution (such as when ```\nmax(items) > target```\n) and ```\nmax(items) < delta```\n. Example: ```\n{2, 3, 4, 6}, 5```\n. After the first iteration, it becomes ```\n{2, 3, 4}, 10```\n, which returns ```\nNone```\n, causing the top level call to return ```\nNone```\n, which is incorrect.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What's the time complexity of branch and bound approach to knapsack\r\n                \r\nI try to implement the branch and bound approach to knapsack problem with ```\nPython```\n.\n\n```\ndef bound(vw, v, w, idx):\n    if idx >= len(vw) or w > limit:\n        return -1\n    else:\n        while idx < len(vw) and w + vw[idx][1] <= limit:\n            v, w, idx = v+vw[idx][0], w+vw[idx][1], idx + 1\n        if idx < len(vw):\n            v += (limit - w)*vw[idx][0]/(vw[idx][1] * 1.0)\n        return v\n\ndef knapsack(vw, limit, curValue, curWeight, curIndex):\n    global maxValue\n    if bound(vw, curValue, curWeight, curIndex) >= maxValue:\n        if curWeight + vw[curIndex][1] <= limit:\n            maxValue = max(maxValue, curValue + vw[curIndex][0])\n            knapsack(vw, limit, curValue + vw[curIndex][0], curWeight + vw[curIndex][1], curIndex+1)\n    if curIndex < len(vw) - 1:\n            knapsack(vw, limit, curValue, curWeight, curIndex+1)\n    return maxValue\n\nmaxValue = 0\n\ndef test():\n    with open(sys.argv[1] if len(sys.argv) > 1 else sys.exit(1)) as f:\n    limit, n = map(int, f.readline().split())\n    vw = []\n    for ln in f.readlines():\n        vl, wl = map(int, ln.split())\n        vw.append([vl, wl, vl/(wl*1.0)])\n    knapsack(sorted(vw, key=lambda x: x[2], reverse=True), limit) \n```\n\n\nHere I have two questions:\n\n\nWhat's the time complexity of the above codes?\nAny improvement or optimization of the above codes? \n\n    ", "Answer": "\r\nAs a general rule, CS theorists have found branch-and-bound algorithms extremely difficult to analyse: see e.g. here for some discussion.  You can always take the full-enumeration bound, which is usually simple to calculate -- but it's also usually extremely loose.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to find optimum combination for Cutting Stock Problem using Knapsack\r\n                \r\nEDIT (31-12-2019) - https://jonathan.overholt.org/projects/cutlist\n\nAbove is the link of the free project which is what exactly I am looking for. I am just looking for proper guidance so that I can make it work.\n\nI am working on minimizing the wastage of aluminium extrusion cutting for Aluminium Sliding Window Fabricators and I am not able to figure out which Algorithm/Data Structure I should go with for the problem.\n\nI have done basic research and found that the problem falls in Cutting Stock Problem (Also called One dimensional cutting problem), Linear Programming Problem, Greedy Algorithm. BUT I am unable to decide which one I should go with and also how to start with.\n\nBrief about the problem :\n\nBasically the window fabricators have 3 sizes of material options to purchase.\n\n```\n12 | 15 | 16 (IN FT)\n```\n\n\nNow the input would be the size of Window.\n\nWIDTH x HEIGHT (IN FT)\n\n1) 6 x 8 - 10 Windows\n\n2) 9 x 3 - 20 Windows\n\nThe calculation is (2 x Width) + (2 x Height). So from the above sizes of window, they need extrusion as follow.\n\n1) 6' (FT) Size Pieces -> 2 x 10 = 20\n\n2) 8' (FT) Size Pieces -> 2 x 10 = 20\n\n3) 9' (FT)  Size Pieces -> 2 x 20 = 40\n\n4) 3' (FT) Size Pieces -> 2 x 20 = 40\n\nUsing knapsack, we can find out the combination but it has restriction of having size to 1 only whereas here in my case I have 3 different sizes available out of which I would like to generate the best optimum combination for the cutting stock problem.\n\nI would need help in how should I proceed for the above problem with respect to data structure and algorithm in Java or any other language. My knowledge in Maths is not up to the mark and that's why I am facing issue in implementing the logic in my project and like to get some help from the community.\n    ", "Answer": "\r\nThere is no algorithm that will guarantee you the optimal solution other than brute-force checking all possible combinations. That's obviously not a good algorithm, at least not if you have large data sets.\n\nYou should have a look at heuristic search algorithms like Simulated Annealing, MCTS or the like. It should be no problem finding existing implementations of heuristic search engines that allow you to provide them with\n\n\nan input set (random distribution of pieces on material),\na transition function (move pieces between materials),\nand an evaluation function (the amount of waste)\n\n\nand compute a near-optimal solution for you.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "C++ Knapsack Algorithm Implementation\r\n                \r\nMy algorithm for the best-first, branch and bound knapsack problem is giving me a max profit of 80 when it should be 90. I'm wondering where I went wrong... my thinking is the priority queue is a bit off.\n\nGiven input:\n\n```\n4,16 // 4 items to follow , 16 capacity knapsack\n2,40 // item1.. weighs 2, costs 40\n5,30 // item2.. weighs 5, costs 30\n10,50 // item3.. weighs 10, costs 50\n5,10 // item4.. weighs 5, costs 10\n```\n\n\nCode: \n\n```\n#include <iostream>\n#include <string>\n#include <queue>\n#include <utility>\n\ntypedef struct node{\n    int level;\n    int profit;\n    int weight;\n    int bound;\n} node;\n\nstruct node_cmp{\n    bool operator()(const node& a, const node& b) const{\n        return a.bound < b.bound;\n    }\n};\n\nint KWF2(int i, int weight, int profit, int *w, int *p, int C, int n){\n    int weight1 = weight;\n    int bound = profit;\n    int j;\n    float x[n+1];\n    for(j = i; j <= n; j++){\n        x[j] = 0;\n    }\n\n    while(weight1 < C && (i <= n)){\n\n        if(weight1 + w[i] <= C){\n            x[i] = 1;\n            weight1 += w[i];\n            bound += p[i];\n        }\n        else{\n            x[i] = ((float)C-(float)weight1)/(float)w[i];\n            weight1 = C;\n            bound = bound + p[i] * x[i];\n        }\n        i++;\n    }\n    return bound;\n}\n\nvoid knapsack(int *w, int *p, int C, int maxprofit, int n){\n    int maxp = maxprofit;\n    std::priority_queue<node,std::vector<node>,node_cmp> PQ;\n    node u,v;\n\n    v.level = 0;\n    v.profit = 0;\n    v.weight = 0;\n    v.bound = KWF2(v.level+1,v.weight,v.profit,w,p,C,n);\n    PQ.push(v);\n\n    while(!PQ.empty()){\n        v = PQ.top();\n        PQ.pop();\n        if(v.bound > maxp){\n            u.level = v.level + 1;\n            //yes child\n            u.weight = v.weight + w[u.level];\n            u.profit = v.profit + p[u.level];\n\n            if((u.weight <= C) && (u.profit > maxp)){\n                maxp = u.profit;\n            }\n\n            if(KWF2(u.level+1,u.weight,u.profit,w,p,C,n) > maxp){\n                PQ.push(u);\n            }\n\n            //no child\n            u.weight = v.weight;\n            u.profit = v.profit;\n            u.bound = KWF2(u.level+1,u.weight,u.profit,w,p,C,n);\n            if(u.bound > maxp){\n                PQ.push(u);\n            }\n        }\n    }\n    printf(\"%d\\n\",maxp);\n}\n\n\nint main(int argc, char **argv){\n\n    int n,C;\n    FILE *in = fopen(argv[1],\"r\");\n    fscanf(in,\"%d,%d\",&n,&C);\n\n    int w[n+1];\n    int p[n+1];\n    float ratio[n+1];\n\n    for(int i = 0; i < n; i++){\n        fscanf(in,\"%d,%d\",&w[i+1],&p[i+1]);\n        ratio[i+1] = (float)p[i+1]/(float)w[i+1];\n    }\n\n    int temp_w,temp_p;\n    float temp_r;\n\n    for(int i = 1; i <= n; i++){\n        for(int j = i + 1; j <= n; j++){\n            if(ratio[i] < ratio[j]){\n                temp_w = w[i];\n                temp_p = p[i];\n                temp_r = ratio[i];\n\n                w[i] = w[j];\n                p[i] = p[j];\n                ratio[i] = ratio[j];\n\n                w[j] = temp_w;\n                p[j] = temp_p;\n                ratio[j] = ratio[i];\n            }\n        }\n    }\n\n    int maxprofit = 0;\n    knapsack(w,p,C,maxprofit,n);\n\n    fclose(in);\n    return 0;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack recursive solution with the part sets\r\n                \r\nI have the recursive solution for knapsack problem in java, here's my code:\n\n```\npublic class OptimalIncome{\nfinal static int length[] = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nfinal static int price[] = new int[] {1, 5, 8, 9, 10, 17, 17, 20, 24, 30};\npublic static int totalLength = 9;\n\npublic static int bestCut(int i, int totalLength){\n    if(i < 0){\n        return 0;\n    }\n    else if(length[i] > totalLength){\n        return bestCut(i - 1, totalLength);\n    }\n    else{\n        return Math.max(bestCut(i - 1, totalLength), bestCut(i - 1, totalLength - length[i]) + price[i]);\n    }\n}\n\npublic static void main(String[] args){\n    System.out.println(\"Given total rod length : \" + totalLength);\n    System.out.println(\"Maximum income         : \" + bestCut(price.length-1, totalLength));\n    System.out.println(\"Smaller part sets      : \");\n}\n}\n```\n\n\nIt works just fine, as you can see I want to print the set of choices (smaller parts). How can I do that?\nThanks\n    ", "Answer": "\r\nHere we go : \n\nimport java.util.ArrayList;\nimport java.util.List;\n\n```\npublic class OptimalIncome {\n    final static int length[] = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    final static int price[] = new int[] { 1, 5, 8, 9, 10, 17, 17, 20, 24, 30 };\n    public static int totalLength = 9;\n    static List<Integer> pickedObjects = new ArrayList<Integer>();\n    public static int bestCut(int i, int totalLength) {\n        if (i < 0) {\n            return 0;\n        } else if (length[i] > totalLength) {\n            return bestCut(i - 1, totalLength);\n        } else {\n            return Math.max(bestCut(i - 1, totalLength),\n                    bestCut(i - 1, totalLength - length[i]) + price[i]);\n        }\n    }\n\n    public static void printSolution(int i,int totalLength){\n        if(i < 0)\n            return;\n        else if(length[i]>totalLength){\n            printSolution(i-1, totalLength);\n        }else{\n            int sol1 = bestCut(i-1,totalLength);\n            int sol2 = bestCut(i - 1, totalLength - length[i]) + price[i];\n            // check whether the optimal solution coming from picking the object or not .\n            if(sol1>sol2){\n                printSolution(i-1, totalLength);\n            }else{\n\n                pickedObjects.add(i);\n                printSolution(i-1, totalLength - length[i]);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        System.out.println(\"Given total rod length : \" + totalLength);\n        System.out.println(\"Maximum income         : \"\n                + bestCut(price.length - 1, totalLength));\n        System.out.println(\"Smaller part sets      : \");\n        printSolution(price.length-1, totalLength);\n        for (Integer i : pickedObjects) {\n            System.out.println(\"picked object: \"+ i +\" length : \"+ length[i]+ \" price \"+ price[i]);\n        }\n    }\n}\n```\n\n\nwe just need to do an inverse recursion and check were did you get the optimal solution to construct the output.\n\nAlthough i think you might add some memoisation to your solution so that it would be fast enough.\nHope it helped.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Understanding knapsack solution in c\r\n                \r\n```\n#include <stdio.h>\n#include <conio.h>\n\nvoid main() {\n    int p[20], w[20], kn[20][20], x[20], i, j, n, weight;\n    Clrscr();\n    printf(\"\\nEnter the value of n \");\n    scanf(\"%d\", &n);\n    printf(\"\\nEnter the price of the items \");\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    printf(\"\\nEnter the weight of the items \");\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &w[i]);\n    }\n    printf(\"\\nEnter the weight of the knapsack \");\n    scanf(\"%d\", &weight);\n    printf(\"\\nThe knapsack is \");\n    for (i = 0; i <= n; i++) {\n        printf(\"\\n\");\n        for (j = 0; j <= weight; j++) {\n            if (i == 0 || j == 0) {\n                kn[i][j] = 0;\n            } else\n            if (w[i - 1] > j) {\n                kn[i][j] = kn[i - 1][j];\n            } else {\n                kn[i][j] = (kn[i - 1][j] > (kn[i - 1][j - w[i - 1]] + p[i - 1])) ?\n                            kn[i - 1][j] : (kn[i - 1][j - w[i - 1]] + p[i - 1]);\n            }\n            printf(\"%d \", kn[i][j]);\n        }\n    }\n    printf(\"\\n\\nThe optimal solution is %d\", kn[n][weight]);\n    i = n;\n    j = weight;\n    while (i != 0) {\n        if (kn[i][j] == kn[i - 1][j]) {\n            x[i-1] = 0;\n            i = i - 1;\n        } else {\n            x[i - 1] = 1;\n            j = j - w[i - 1];\n            i = i - 1;\n        }\n    }\n    printf(\"\\n\\nThe 0/1 knapsack is \");\n    for (i = 0; i < n; i++) {\n        printf(\"\\nX[%d]=%d\", i + 1, x[i]);\n    }\n    getch();\n}\n```\n\n\nHey guys.. Well I am new to 'C' but I tried this knapsack problem from the textbook.  I really don't understand how it is working and especially not understanding this line\n```\nkn[i][j]=(kn[i-1][j]>(kn[i-1][j-w[i-1]]+p[i-1]))?kn[i-1][j]:(kn[i-1][j-w[i-1]]+p[i-1]);```\n  \n\nWell, if anyone would like to explain please do...\nThank You so much:)\n    ", "Answer": "\r\nThis is the dynamic programming implementation of knapsack defined by two states weight and index. The sol above us built in a bottom-up manner meaning we start from one item initially and build our solution to n items considering the constraints which are cost maximum cost and weight.For the above problem i defines the index and j defines the weight.\n\nThus kn[i][j] defines the maximum profit the problem setter can make by taking items from 0 to ith index having the capacity of the sack to be weight j.\n\nThe approach to find the max value that can be obtained from n items is max of the below conditions\n\n\nMax value obtained by n-1 (here i-1) items and weight W (here in each iteration j) \nInclude the value of the nth item + Max value obtained by n-1 items and weight W which includes the nth item weight.\n\n\nI have included the reason for each stmt in comments.\n\nThus for each item, we can either include it in the sol or we cant.\n\n```\nfor(i=0;i<=n;i++)\n    {\n        printf(\"\\n\");\n        for(j=0;j<=weight;j++)\n        {\n            if(i==0||j==0)     //if no of items to be included is 0 or max capacity is 0 the sol is 0\n            {\n                kn[i][j]=0;\n            }\n            else if(w[i-1]>j)   //if the nth item is greater than the weight j we can remove the item from our solution. \n            {  \n                kn[i][j]=kn[i-1][j];\n            }\n            else\n            {  //writing this cond in easier format\n                kn[i][j]=max( val[i-1] + k[i-1][j-w[i-1]] , k[i-1][j])\n            }\n            printf(\"%d \",kn[i][j]);\n        }\n}\n```\n\n\nEveryone has difficulty in 2nd & 3rd condition so for the sake of mankind lets take an example i=1. Thus knapsack has only 1 item which is represented by index i=0.\n\nIf the weight of this 0th item is greater than the max weight(which is incremented in steps from 0 to weight w) we cant include this item. Thus for all j we have max value of knapsack as kn[1][j]= kn[i-1][j] i.e kn[0][j] which in turn is 0 since i=0 till we reach a stage where w[i-1]==j. \n\nIn easier english this means that max value that knapsack can hold with 1 item but with weight constraint less than that of item i-1 (here 0th item in array but actually 1st item) is 0 till j is incremented to a weight >= to this item represented by i=1(i.e 0th item in array).\n\nElse (As soon as weight represented by j is > item i-1 weight)\n\n(Now we have 2 conditions since although weight of this item is less than W or whatever j \n\n1.If we include this item total weight of the previous included items and this current item (we are building sol bottom up) may exceed the total weight thus we dont want to include the item ) Knapsack value k[i][j]=k[i-1][j] previous included items only.\n\n\nWe can include this current item  thus K[i][j]= value of this ith item + max value obtained by i-1 items (for i=1 none here) which have a weight j- weight of current item.kn[i][j]=max( val[i-1] + k[i-1][j-w[i-1]] , k[i-1][j])\n\n\nThus i=1 we have a knapsack value as val[current item] + 0 (Since no previous items.) \n\nThe iteration goes on building solution bottom up.\n\n)\n\nHope this helps !\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack: One constraint, each item can only be selected once, with a large number of items\r\n                \r\nI'm writing an algorithm taking the knapsack problem form. I am trying to maximize the value (V) of my knapsack given a maximum weight (W). The catches are that each item (I) can only be selected once, the knapsack regardless of weight can only hold 10 items, and there is a very large number of items (500+). \n\nMy thoughts so far have been to generate a knapsack that is overweight and recursively work backwards replacing items one at a time until it is <= the max weight. This is not a problem for generating the most optimal knapsack, however, I would really like to generate the following 100 or so knapsacks. I was thinking I could do this by continuing my recursive process, however, I do not feel as though this is entirely accurate as a may be missing slightly more optimal knapsacks.\n    ", "Answer": "\r\nThis problem can be formulated as an integer program.\n\n```\nmaximize sum_{i in items} v_i * x_i\nsubject to\nsum_{i in items} x_i <= 10       [u]\nsum_{i in items} w_i * x_i <= W  [z]\nfor all i in items, x_i in {0, 1}  [y_i]\n```\n\n\nThere are many solver libraries that will solve this program for you; alternatively, you can do the branch and bound yourself. Here's the dual linear program, which can be solved to obtain an upper bound on the objective value of the integer program, which is needed for branch and bound.\n\n```\nminimize 10 * u + W * z + sum_{i in items} y_i\nsubject to\nfor all i in items, u + w_i * z + y_i >= v_i  [x_i]\nu >= 0\nz >= 0\nfor all i in items, y_i >= 0\n```\n\n\nGiven a value for ```\nz```\n, setting the other variables is a matter of assigning positive ```\ny_i```\n to the nine top items by ```\nv_i - w_i * z```\n while assigning ```\nu```\n to be the tenth greatest value. It should be possible to ternary search for ```\nz```\n in time ```\nO(n log n)```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Print the values of knapsack\r\n                \r\nsolving the knapsack problem recursively, I want to know which items are taken in the bag that gives the maximum value. so far I have this:\n\nI also tried to copy arr to another array to prevent overwriting but also didn't work!\n\n```\nint knapSack(int W, int wt[], int val[], int n, int arr[])\n{\n    int x, y, c, j, arr1[50], arr2[50];\n\n    if (n == 0 || W == 0)\n        return 0;\n\n    // If weight of the nth item is more than Knapsack capacity W, then \n    // this item cannot be included in the optimal solution \n    if (wt[n - 1] > W)\n    return knapSack(W, wt, val, n - 1, arr2);\n\n    // Return the maximum of two cases:  \n    // x nth item included  \n    // y not included \n    arr1[n - 1] = val[n - 1];// I think this line isn't doing anything\n    x = val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1, arr1);\n    //copyArr(arr, out, n);\n    y = knapSack(W, wt, val, n - 1, arr2);\n\n    if (x > y)\n       c = x;\n    else\n        c = y;\n\n    if (c == x)\n        for (j = 0; j < 50; j++)\n            arr[j] = arr1[j];\n\n    else\n        for (j = 0; j < 50; j++)\n            arr[j] = arr2[j];\n\n    return c;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack with Minimum Cost\r\n                \r\nThe famous ```\n0/1```\n knapsack problem focuses on getting the maximum cost/value in the given ```\nWeight (W)```\n.\n\nThe code for the above is this ::\n\n```\nn = cost_array / weight_array size\nINIT :: fill 0th col and 0th row with value 0\nfor (int i=1; i<=n; i++) {\n            for (int j=1; j<=W; j++) {\n                if (weight[i-1] <= j) {\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j - weight[i-1]] + cost[i-1]);\n                }else {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n```\n\n\nAns :: ```\ndp[n][W]```\n\n\nNEW  Problem :: So, here we are calculating the maximum cost/value. But what if I want to find the minimum cost/value (Its still bounded knapsack only).\n\nI think the problem boils down how I do the ```\nINIT```\n step above. As in the loop I think it will remain same with the only difference of ```\nMath.max```\n becoming ```\nMath.min```\n\n\nI tried the ```\nINIT```\n step with ```\nInfinity```\n, ```\n0```\n etc but am not able to build the iterative solution.\nHow can we possibly do that?\n    ", "Answer": "\r\nWriting answer as mentioned by @radovix\n\n\nConvert every weight to negative number and write the same algorithm.\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "multi-dimensional cost 0-1 knapsack problem with two backpack sizes\r\n                \r\nI was going through the solutions to this problem found on leetcode.\nThe problem states:\n\nGiven an array, ```\nstrs```\n, with strings consisting of only 0s and 1s. Also\ntwo integers ```\nm```\n and ```\nn```\n.\nNow your task is to find the maximum number of strings that you can\nform with given ```\nm```\n 0s and ```\nn```\n 1s. Each 0 and 1 can be used at most once.\n\n\nInput: ```\nstrs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"]```\n, ```\nm = 5```\n, ```\nn = 3```\n\nOutput: ```\n4```\n\n\n\nExplanation: This are totally 4 strings can be formed by the using of\n5 0s and 3 1s, which are \"10\",\"0001\",\"1\",\"0\".\n\nThe algorithm used to solve the problem is below:\n```\ndef findMaxForm(strs, m, n):\n\n    dp = [[0] * (n + 1) for _ in range(m +1)]\n    \n    for s in strs:\n        \n        zeros, ones = s.count('0'), s.count('1')\n        \n        for i in range(m, zeros - 1, -1):\n            \n            for j in range(n, ones -1, - 1):\n                \n                # dp[i][j] indicates it has i zeros ans j ones,\n                # can this string be formed with those ?\n                \n                dp[i][j] = max( 1 + dp[i - zeros][j - ones], dp[i][j])\n                \n            # print(dp)\n            \n    return dp[-1][-1]\n```\n\nthe confusing part of the problem is the ```\ndp[i][j] = max( 1 + dp[i - zeros][j - ones], dp[i][j])```\n. I am not sure what is going on here. Why do we minus i from zeros and j from ones?\nI also found a diagram that explains how the dp table should look for ever element in the array.\nMy Questions:\n\nwhat does the first table represent? The x and y axis? Why are there so many ```\n1```\n's. I think if i understand this part, something might click. I would appreciate if someone walks through the diagram\nwhy does this way give us the maximum number of ```\n0```\n's and ```\n1```\n's that can be formed? i think i am stil confused about this part ```\ndp[i][j] = max( 1 + dp[i - zeros][j - ones], dp[i][j])```\n.\nAlso the solution is described as a \"3d-DP optimized to 2D space: dp[j][k]: i dimension is optimized to be used in-place.\" What does that mean?\n\n\n    ", "Answer": "\r\nWhen you encounter a string ```\ns```\n, you basically have two options. It either belongs to the maximal solution, or it doesn't.\nIf you do, the size of the set is increased by one, but you have less ones and zeros left to use. If you don't use it, the size of the set remains unchanged, but so is the number if left ones and zeros.\nThe table ```\ndp```\n represnts the maximal such set you can get until now for different number of ones and zeros \"left\". For example. ```\ndp[m][n]```\n means the best value you can get so far with ```\nm```\n zeros and ```\nn```\n ones. Similarly, for ```\ndp[2][3]```\n you can use 2 zeros and 3 ones for the rest of the strings.\nLet's wrap it together:\nFor some given number of zeros (```\ni```\n) left to use, and some number of ones (```\nj```\n) left to use, and a string ```\ns```\n:\n\n```\n1 + dp[i - zeros][j - ones]```\n means the maximal set if you decide to\nadd ```\ns```\n to the set (and you are left with less ones and zeros)\n```\ndp[i][j]```\n means you are not taking this element, and moving on.\n\nWhen you invoke ```\nmax()```\n on both values, you basically say: I want the better one out of these two options.\nI hope this answers the first two questions, of why it is maximal and what the dp line means.\n\n\nAlso the solution is described as a \"3d-DP optimized to 2D space:\ndp[j][k]: i dimension is optimized to be used in-place.\" What does\nthat mean?\n\nIn here, you have 3d problem: the strings themselves, which you iterate over - but you don't have another dimension for the array. You optimize it to be inplace since you always only need the previous string, and never something \"older\" than it, saving you precious space.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How can I improve this algorithm for a variation of the unbounded knapsack in Ruby\r\n                \r\nThe problem is a variation of the unbounded knapsack problem, where you have items of equal value but different weights. This algorithm solves the problem, but I would like to optimize its performance. Does anyone have any recommendations?\n\n```\ndef knapsack(capacity, bars)\n    if capacity == 0 || bars.nil? || bars[0].nil?\n        return 0\n    end\n\n    solutions = []\n    sum = 0\n    (1..capacity).each do |i|\n        break if sum > capacity\n        bars.combination(i).lazy.each do |comb|\n            sum = comb.reduce(&:+)\n            solutions << sum\n        end\n    end\n\n    solutions.select{|i| i <= capacity}.max\nend\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "My knapsack code is giving wrong output?\r\n                \r\nI was trying to write a simple 0-1 knapsack problem but am encountering some error. Help would be appreciated.\n\n```\nT = int(input().strip())\ndef knapsack(n,k,ar):\n    if n==0 or k==0:\n        return 0\n    elif ar[n-1]>k:\n        return knapsack(n-1,k,ar)\n    else:\n        return max(knapsack(n-1,k,ar),ar[n-1] + knapsack(n-1,k-ar[n-1],ar))\nfor t in range(T):\n    a = input().strip()\n    n,k = int(a[0]),int(a[2])\n    ar = [int(i) for i in input().strip().split(' ')]\n    print(knapsack(n,k,ar))\n```\n\n\nI ran this again an input of \n\n```\n2\n3 12\n1 6 9\n5 9\n3 4 4 4 8\n```\n\n\nand I am receiving wrong output? I cannot find any error. Thanks in advance\n\nOutput\n\n```\n1\n8\n```\n\n    ", "Answer": "\r\nYour algorithm is fine but your input to the function is wrong.  \n\nIn the first input, the line ```\nn,k = int(a[0]),int(a[2])```\n is taking ```\n3```\n and ```\n1```\n as an input instead of ```\n3```\n and ```\n12```\n.\nI guess you should use ```\nlist(map(int, input().split()))```\n instead, and get ```\na[0]```\n and ```\na[1]```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Dynamic Programming Python\r\n                \r\n01 Knapsack problem: You are given weights and values of N items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. Note that we have only one quantity of each item.\nIn other words, given two integer arrays val[0..N-1] and wt[0..N-1] which represent values and weights associated with N items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item, or don’t pick it (0-1 property).\nLink to the judge : LINK\n```\nExample 1:\n\nInput:\nN = 3\nW = 4\nvalues[] = {1,2,3}\nweight[] = {4,5,1}\nOutput: 3\nExample 2:\n\nInput:\nN = 3\nW = 3\nvalues[] = {1,2,3}\nweight[] = {4,5,6}\nOutput: 0\n```\n\nMy code:\n```\n# <- Creating DP table ->\nmemory = []\nfor x in range(1001):\n    list1 = []\n    for y in range(1001):\n        list1.append(-1)\n    memory.append(list1)\n\nclass Solution:\n    \n    #Function to return max value that can be put in knapsack of capacity W.\n    def knapSack(self,W, wt, val, n):\n        \n        if W == 0 or n <= 0:\n            return 0\n        \n        if memory[W][n] != -1:\n            return memory[W][n]\n        \n        if wt[n-1] > W:\n            return self.knapSack(W,wt,val,n-1)\n        \n        memory[W][n] = max(val[n-1] + self.knapSack(W-wt[n-1],wt,val,n-1),self.knapSack(W,wt,val,n-1))\n        \n        return memory[W][n]\n```\n\nProblem with the code:\nThe code and the logic looks fine and I have been debugging it for sometime however some of the test cases are failing, whats wrong with the logic?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Algorithm that is a combination of the continuous knapsack problem and the variable size bin packing problem\r\n                \r\nI'm trying to solve a problem (in php, but programming language doesn't matter).\nI'm having a n number of persons that have paid money, and I have got a m number of persons that are going to pay the same amount as the sum of what the n number of people have paid.\nI want to calculate the shortest route of money transfers between these persons. It is possible to split the payments and pay to different persons.\nThe ideal is that one person only makes one or two transactions.\nCan someone maybe point me in the right direction or help me with this?\n\nAn example:\nperson A has paid $100\n\nperson B has paid $200\n\nperson C has paid $50\n\nperson D will pay $24\n\nperson E will pay $175\n\nperson F will pay $151\n\nOne possible solution to this is \n\nperson E pays $100 to person A,\n\nperson E pays $75 to person B,\n\nperson F pays $125 to person B,\n\nperson F pays $26 to person C\n\nperson D pays $24 to person C\n    ", "Answer": "\r\nIn theory this could be framed as an optimization problem:\n\nBasically we're going to establish a set of constraints that enumerate the structure of your problem, seed the initial values, and make sure that we allocate all the money as you've indicated.\n\nInitial condition constraints:\n\n```\nA_paid = 100\nB_paid = 200\nC_paid = 50\nD_out  = 24\nE_out  = 175\nF_out  = 151\n```\n\n\nAmount paid out cannot exceed the amount available: (we define ```\nD_to_A```\n as a variable holding the amount paid from person ```\nD```\n to person ```\nA```\n)\n\n```\nD_out >= D_to_A + D_to_B + D_to_C\nE_out >= E_to_A + E_to_B + E_to_C\nF_out >= F_to_A + F_to_B + F_to_C\n```\n\n\nAmount paid to each individual must be equal to what they've already paid:\n\n```\nA_paid = D_to_A + E_to_A + F_to_A\nB_paid = D_to_B + E_to_B + F_to_B\nC_paid = D_to_C + E_to_C + F_to_C\n```\n\n\nIf we were to stop now and solve this as a linear program we'd find any solution spanning the entire variable space, but you're looking to minimize the number of actual payments.  We can do this by minimizing over all ```\nX_to_Y```\n variables in concert with the constraints above.\n\n```\nmin: D_to_A + D_to_B + D_to_C + ...\n```\n\n\nYou can use your favorite optimization technique to solve the problem, there's plenty of available linear program solvers, I like lpsolve.\n\nThough this solves the specific example you described it's easy to see how it can be expanded to larger problems by adding more variables...but the problem grows in complexity substantially as you add people. If I recall correctly the knapsack problem is NP or NP-hard, so this isn't unexpected.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recursive Knapsack Java -- Errors\r\n                \r\nyet another knapsack question... I understand the concept of the knapsack problem but I am having troubles with parts of my code.. I would like to believe that I am headed into the right direction but maybe not?\n\n```\nLet's say I have a list of 1,2,3,6,7 and my goal weight is 4:\nThe items that will equal this weight are 1 and 3. \nMy first iteration will go like this:\nItem: 1\nGoal Weight: 3 (I did weight - the item)\nItems: 1,2\nGoal Weight: 1\nItems: 1,2,3\nGoal Weight: -2\n-- Once the weight reaches < 0, it should restart the goal weight and then restart the position    \nbut the items should start at 1 and skip over 2, going straight to 3. An Example below:\nItems: 1\nGoal Weight: 3\nItems: 1, 3\nGoal Weight: 0 // Finished\n```\n\n\n--However, I do not know how skip over the 2 and go to 3. In a way, I understand that this problem uses combinations/permutations. I just can't get my code to work the way I want it to. Below is my code. Please let me know if I am unclear in anything.\n\n```\n    public boolean recursive(int weight, int start){\n       if(weight == 0){// if weight is zero, we found what we wanted.\n           System.out.println(\"We did it\");\n           return true;\n       }\n       else if(weight < 0){ //Too much weight in the bag.\n           if(start == storeItems.length-1){ //reached the end of the array.\n           recursive(goalWeight, start + 1);\n           return false;\n           }\n           else{ // did not reach end of the array but still not the right combination of numbers.\n              recursive(weight, start + 1);\n           }\n       }\n       else if(weight > 0){\n           System.out.println(storeItems[start]);\n           boolean x = recursive(weight - storeItems[start], start + 1);\n       }else{\n           System.out.print(\"No values\");\n       }\n    return false;\n\n}\n```\n\n    ", "Answer": "\r\nSo, I figured out the answer to my question: How can I get a combination of each element in my array \n\nMy code demonstrates the use of a boolean. With this boolean labeled 'x', it will traverse the rest of my recursion, looking for the correct combination until x should return false. Without giving away the answer to people who were potentially stuck where I was, I will give a small code example.\n\n```\nboolean x = recursive(weight - storeItems[start], start + 1)\n```\n\n\nUsing this piece of code, one can restructure the above base cases to determine whether the above piece of code will return true or false. If it returns true, then it should print out all of the necessary data that added up to the goal weight. If it returns false, then it should continue to the next item in the list.\n\nThings to keep in mind:\nCalling this boolean does not mean you will alter any variables in \"our world\", what the boolean does is it goes into it's own recursive dive without actually altering anything we originally had. This is where the thought of \"unwinding\" a recursive dive comes in, because once the boolean finds its answer, it will unwind the recursive dive, allowing the boolean to check the combinations without ever changing your start position unless necessary. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Depth first knapsack using stack and no recursion\r\n                \r\nI need to solve the Knapsack problem using depth first and stacks with no recursive calls. I solved the problem using a list and recursion. I have no clue of how to solve the problem using stacks and no recursion.\n\nThis is what I have right now:\n\n```\n   private int knapsackDepthFirst(List<KnapsackObject> list, int weight, int price, int maxWeight) {\n      if (list.size() == 0) return price;\n      int max = Integer.MIN_VALUE;\n      for (KnapsackObject item : list) {\n         int best;\n         if (weight + item.getWeight() > maxWeight) {\n            best = Integer.MIN_VALUE;\n         } else if (weight + item.getWeight() == maxWeight) {\n            best = price + item.getPrice();\n         } else {\n            best = knapsackDepthFirst(list.subList(1, list.size()), weight + item.getWeight(), price + item.getPrice(), maxWeight);\n         }\n         if (best > max) max = best;\n      }\n      return max;\n   }\n```\n\n\n```\nKnapsackObject```\n holds the price and weight of an item.\n    ", "Answer": "\r\nWhat you need is to maintain stack yourself. In stack (or stacks) you need to keep function call parameters, and local variable (you also need to reduce their count). It's not very clear from your code whether in your knapsack statement allowed to take multiple items of same type. So I assume that it's forbidden (It's easy to rewrite code it's not true). Check out following solution in c#:\n\n```\n    public class KnapsackObject\n    {\n        public int weight;\n        public int price;\n    }\n\n    public static Int32 KnapsackSolve(int maxWeight, List<KnapsackObject> items)\n    {\n        Int32 max = Int32.MinValue;\n        Int32 count = items.Count;\n        // Its actually a stack contains a weight parameter for current iteration.\n        Int32[] weights = new Int32[count + 2];\n        // Its actually a stack contains a price parameter for current iteration.\n        Int32[] prices = new Int32[count + 2];\n        // Its actually a stack contains a flag which specify whether we already try to get item steps[current] of not.\n        // If it's allowed to get multiple item of same type, it must be store index variable (int) instead of bool flag.\n        Boolean[] itemGetted = new Boolean[count + 2];\n        // Indicates that we need to leave current iteration when back track to it.\n        Boolean[] finishIteration = new Boolean[count + 2];\n        // Represents depth of current iteration.\n        Int32 current = 0;\n\n        // Put the first \"call\" into stack. Current weight = 0, price = 0.\n        weights[current] = 0;\n        prices[current] = 0;\n        itemGetted[current] = false;\n        finishIteration[current] = false;\n\n        while (current >= 0)\n        {\n            // we already have done everything here, back tracking.\n            if (finishIteration[current])\n            {\n                // Pop current call from stack.\n                --current;\n                continue;\n            }\n\n            // we already make our decision about all item types. \n            // Compare and back track.\n            if (current == count)\n            {\n                if (max < prices[current])\n                    max = prices[current];\n                // Pop current call from stack.\n                --current;\n                continue;\n            }\n\n            // if we haven't tried to get current item\n            if (!itemGetted[current])\n            {\n                itemGetted[current] = true;\n                // and we can put it in knapack, try it.\n                if (weights[current] + items[current].weight <= maxWeight)\n                {\n                    weights[current + 1] = weights[current] + items[current].weight;\n                    prices[current + 1] = prices[current] + items[current].price;\n                    itemGetted[current + 1] = false;\n                    finishIteration[current + 1] = false;\n                    // Push new call into stack.\n                    current++;\n                    continue;\n                }\n            }\n\n            // and try not to put current item. \n            finishIteration[current] = true;\n            weights[current + 1] = weights[current];\n            prices[current + 1] = prices[current];\n            itemGetted[current + 1] = false;\n            finishIteration[current + 1] = false;\n            // Push new call into stack.\n            current++;\n        }\n\n        return max;\n    }\n```\n\n\nNote: I suppose you know that just eliminate recursion doesn't improve performance too much. As soon as this solution is brute force and has exponential complexity. For not very big and integer weights (prices) there are good dynamic programming solutions which take polynomial depends on items count and max weight (max price upper bound). \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recursive Dynamic Programming Knapsack Solution in Java\r\n                \r\nI have written this dynamic function to find maximum packed value for knapsack problem.\n\n```\nstatic int dyn(int maxItems, int maxSize)\n    {\n        if(maxItems < 0)\n        {\n            return 0;\n        }\n        if(tab[maxItems][maxSize] != -1)\n        {\n\n            return tab[maxItems][maxSize];\n        }\n\n        if( itemArray[maxItems].s > maxSize)\n        {\n            result =  dyn(maxItems-1,maxSize);\n            return result;\n        }\n        else\n        {\n            result =  Math.max(dyn(maxItems-1, maxSize), dyn(maxItems-1, maxSize - itemArray[maxItems].s) + itemArray[maxItems].v);\n            tab[maxItems][maxSize] = result;\n            return result;\n        }\n\n    }\n```\n\n\nI'm calling this function from main as\n\n```\nint x = dyn(maxItems - 1, maxSize)\n```\n\n\nThe itemArray structure is\n\n```\npublic class Item {\n int v;\n int s;\n}\n```\n\n\nEvery time I'm getting 0 as an answer. Please tell me where I am going wrong\n    ", "Answer": "\r\nRemove the ```\nif```\n loop where you check ```\ntab[][] != -1```\n. This will always be true and the actual knapsack recursion below it will never run. And I assume you populate the ```\nitemArray```\n with items. Now this should work.\n\n```\nstatic int dyn(int maxItems, int maxSize)\n{\n    if(maxItems < 0)\n    {\n        return 0;\n    }\n\n    if( itemArray[maxItems].s > maxSize)\n    {\n        return dyn(maxItems-1,maxSize);\n    }\n    else\n    {\n        int result =  Math.max(dyn(maxItems-1, maxSize), dyn(maxItems-1, maxSize - itemArray[maxItems].s) + itemArray[maxItems].v);\n        tab[maxItems][maxSize] = result;\n        return result;\n    }\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Dynamic Programming Knapsack K-exact items\r\n                \r\nI found this very handy example code which implements a DP solution to the knapsack problem (kudos to the person who posted it).\n\nhttps://codereview.stackexchange.com/questions/20569/dynamic-programming-solution-to-knapsack-problem\n\nI am trying to modify it to include a constraint on the number of items k in the knapsack.\n\nI added a third argument \n\n```\ndef knapsack(items, maxweight, maxitems):\n```\n\n\nand modified the reconstruction as follows:\n\n```\nwhile i > 0:\n\n    if bestvalues[i][j] != bestvalues[i - 1][j] and len(reconstruction) < maxitems:\n        reconstruction.append(items[i - 1])\n        j -= items[i - 1][1]\n\n    i -= 1\n```\n\n\nProvided I input enough items to choose from this will always converge to the desired k number of items.  However, I am fairly certain that this is not finding the closest approximation of the global optimum.  The discussions I have read after some searching refer to adding a third dimension k and accounting for the constraint before the reconstruction (I *think this would be during the best value assessment).\n\nCan someone provide an example of how to do this?  Ideally a working python example would be fantastic but I'll settle for pseudocode.  I have read a few instructions using notation but I am still not sure how to constrain with k (outside of what I have done here).\n\nThanks!\n    ", "Answer": "\r\nAs i stated in the comment above a third dimension is required, i have written a recursive dynamic programming solution :\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint noOfItems, items[100], maxWeight, maxItems, value[100];\nint dp[100][1000][100];\n\nint solve(int idx, int currentWeight, int itemsLeft){\n    if(idx == noOfItems || itemsLeft == 0) return 0;\n    if(dp[idx][currentWeight][itemsLeft] != -1) return dp[idx][currentWeight][itemsLeft];\n    int v1 = 0, v2 = 0;\n    //try to included the current item\n    if(currentWeight >= items[idx]) v1 = solve(idx+1, currentWeight-items[idx], itemsLeft-1) + value[idx];\n    //exclude current item\n    v2 = solve(idx+1, currentWeight, itemsLeft);\n    return dp[idx][currentWeight][itemsLeft] = max(v1, v2);\n}\n\n//print the contents of the knapsack\nvoid print(int idx, int currentWeight, int itemsLeft){\n    if(idx == noOfItems || itemsLeft == 0) return;\n    int v1 = 0, v2 = 0;\n    if(currentWeight >= items[idx]) v1 = solve(idx+1, currentWeight-items[idx], itemsLeft-1) + value[idx];\n    v2 = solve(idx+1, currentWeight, itemsLeft);\n    if(v1 >= v2){\n        cout << idx << \" \" << items[idx] << \" \" << value[idx] << endl;\n        print(idx+1, currentWeight-items[idx], itemsLeft-1);\n        return;\n    }else{\n        print(idx+1, currentWeight, itemsLeft);\n        return;\n    }\n}\n\nint main(){\n    cin >> noOfItems >> maxWeight >> maxItems;\n    for(int i = 0;i < noOfItems;i++) cin >> items[i] >> value[i];\n    memset(dp, -1, sizeof dp);\n    cout << solve(0, maxWeight, maxItems) << endl;  //prints the maximum    value that we can get from the constraints\n    cout << \"Printing the elements in the knapsack\" << endl;\n    print(0, maxWeight, maxItems);\nreturn 0;\n}\n```\n\n\nLink to solution on ideone : https://ideone.com/wKzqXk\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to Find Max Average and Lowest value in knapsack problem\r\n                \r\n\nOur basket will hold a weight of 1000. Using a random number generator, generate 100 possible items for the basket. The items should have random weights between 1 and 300. \nUse the dynamic programming algorithm to compute the exact optimal solution for the set of 100 items. Note that the solution is a weight, wj, where 0 < wj < 1000. \nUse the greedy approximation algorithm to compute an approximate solution using the same set of items. \nRun this set of steps 10 times, keeping track of the high, low and average values. Also, keep track of the running times for both algorithms. \n\n\nThis project requires a track of high, low and average values and is should contain a table with your experimental results:\n\n```\n    Dynamic(Exact)  Greedy(Approx.) Approximation Factor\n```\n\n\nHighest\nAverage\nLowest           \n\n```\npackage knapsack;\nimport java.util.Random;\n\n/**\n *\n * @author Muhammad Ali Ghaffar\n */\npublic class Knapsack {\n\n    public int max(int a, int b){\n        return (a > b) ? a : b;\n    }\n\n    public int min(int a, int b){\n        return (a < b) ? a : b;\n    }\n\n\n    public int KSKMAX(int W, int wt[], int val[], int n) \n    { \n        int i, w; \n        int K[][] = new int[n + 1][W + 1]; \n\n        for (i = 0; i<= n; i++) { \n            for (w = 0; w<= W; w++) { \n                if (i == 0 || w == 0) \n                    K[i][w] = 0; \n                else if (wt[i - 1]<= w) \n                    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]); \n                else\n                    K[i][w] = K[i - 1][w]; \n            } \n        } \n\n        return K[n][W]; \n    }\n\n\n\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Knapsack k1=new Knapsack();\n        Random rand = new Random();\n\n        int randomvalues = rand.nextInt(100);\n\n        int val[] = new int[100]; \n        int wt[] = new int[1000]; \n\n        for(int i=0;i<100;i++){\n            val[i]=rand.nextInt(100)+1;\n\n        }\n\n\n\n        int W = rand.nextInt(300); \n        int n = val.length;\n        System.out.println(\"----------------\");\n        System.out.println(\"| Highest :\"+k1.KSKMAX(W, wt, val, n)+\"  |\");\n        System.out.println(\"----------------\");\n        System.out.println(\"| Average :\"+k1.KSKMAX(W, wt, val, n)+\"  |\");\n        System.out.println(\"----------------\");\n        System.out.println(\"| Lowest  :\"+k1.KSKLOW(W, wt, val, n)+\"  |\");\n        System.out.println(\"----------------\");\n\n    }\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to Find Max Average and Lowest value in knapsack problem\r\n                \r\n\nOur basket will hold a weight of 1000. Using a random number generator, generate 100 possible items for the basket. The items should have random weights between 1 and 300. \nUse the dynamic programming algorithm to compute the exact optimal solution for the set of 100 items. Note that the solution is a weight, wj, where 0 < wj < 1000. \nUse the greedy approximation algorithm to compute an approximate solution using the same set of items. \nRun this set of steps 10 times, keeping track of the high, low and average values. Also, keep track of the running times for both algorithms. \n\n\nThis project requires a track of high, low and average values and is should contain a table with your experimental results:\n\n```\n    Dynamic(Exact)  Greedy(Approx.) Approximation Factor\n```\n\n\nHighest\nAverage\nLowest           \n\n```\npackage knapsack;\nimport java.util.Random;\n\n/**\n *\n * @author Muhammad Ali Ghaffar\n */\npublic class Knapsack {\n\n    public int max(int a, int b){\n        return (a > b) ? a : b;\n    }\n\n    public int min(int a, int b){\n        return (a < b) ? a : b;\n    }\n\n\n    public int KSKMAX(int W, int wt[], int val[], int n) \n    { \n        int i, w; \n        int K[][] = new int[n + 1][W + 1]; \n\n        for (i = 0; i<= n; i++) { \n            for (w = 0; w<= W; w++) { \n                if (i == 0 || w == 0) \n                    K[i][w] = 0; \n                else if (wt[i - 1]<= w) \n                    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]); \n                else\n                    K[i][w] = K[i - 1][w]; \n            } \n        } \n\n        return K[n][W]; \n    }\n\n\n\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Knapsack k1=new Knapsack();\n        Random rand = new Random();\n\n        int randomvalues = rand.nextInt(100);\n\n        int val[] = new int[100]; \n        int wt[] = new int[1000]; \n\n        for(int i=0;i<100;i++){\n            val[i]=rand.nextInt(100)+1;\n\n        }\n\n\n\n        int W = rand.nextInt(300); \n        int n = val.length;\n        System.out.println(\"----------------\");\n        System.out.println(\"| Highest :\"+k1.KSKMAX(W, wt, val, n)+\"  |\");\n        System.out.println(\"----------------\");\n        System.out.println(\"| Average :\"+k1.KSKMAX(W, wt, val, n)+\"  |\");\n        System.out.println(\"----------------\");\n        System.out.println(\"| Lowest  :\"+k1.KSKLOW(W, wt, val, n)+\"  |\");\n        System.out.println(\"----------------\");\n\n    }\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapSack problem returning a list of values instead of total value\r\n                \r\n```\ndef knapSack(W, wt, val, n):\n\n    if n == 0 or W == 0:\n        return 0\n\n    if (wt[n - 1] > W):\n        return knapSack(W, wt, val, n - 1)\n\n    else:\n        return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1),\n                   knapSack(W, wt, val, n - 1))\n```\n\n\nSo far I have this code as my reference.\nIs that possible that I can return a list of value instead of returning a total value?\n\nThank you!\n    ", "Answer": "\r\nAnalyzing this code I came to believe your parameters are: W - max weight of the knapsack, wt - list of item weights, val - list of item values, n - number of items. I propose a different approach, without using recursion at all, utilizing ```\npowerset```\n from itertools instead:\n\n```\nfrom itertools import combinations, chain\n\ndef powerset(iterable):\n    \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\ndef weight(subset): # returns total weight of items in subset\n    return sum(i[0] for i in subset)\n\ndef value(items): # returns total value of items in subset\n    return sum(i[1] for i in subset)\n\ndef knapsack(W, items): \n    return max( (subset for subset in powerset(items) if weight(subset) <= W), key=value)\n\nval = [60, 100, 120]\nwt = [10, 20, 30]\nW = 50\n\nprint(knapsack(W, zip(wt, val)))\n\n# prints ((20, 100), (30, 120)) ie. pairs (weight, value) of the best combination\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "get the element of a list in knapsack 0-1\r\n                \r\nI have this python code solving knapsack problem using dynamic programming. \nthis function returns the total cost of best subset but I want it to return the elements of best subset . can anybody help me with this?\n\n```\ndef knapSack(W, wt, val, n):\n    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n\n    # Build table K[][] in bottom up manner\n    for i in range(n + 1):\n        for w in range(W + 1):\n            if i == 0 or w == 0:\n                K[i][w] = 0\n            elif wt[i - 1] <= w:\n                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1] [w])\n            else:\n                K[i][w] = K[i - 1][w]\n\n    return K[n][W]\n\n\nval = [40, 100, 120,140]\nwt = [1, 2, 3,4]\nW = 4\nn = len(val)\nprint(knapSack(W, wt, val, n))\n```\n\n    ", "Answer": "\r\nWhat you can do is instead of returning only K[n][W], return K\nThen iterate K as :\n\n```\nelements=list()\ndp=K\nw = W\ni = n\nwhile (i> 0):\n  if dp[w][i] - dp[w - wt(i)][i-1] == val(i):\n     #the element 'i' is in the knapsack\n     element.append(i)\n     i = i-1 //only in 0-1 knapsack\n     w -=wt(i)\n  else: \n     i = i-1 \n```\n\n\nThe idea is you reverse iterate the K matrix to determine which elements' values were added to get to the optimum K[W][n] value.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack - lowest priority, minimum weight\r\n                \r\nI have to implement the following variation of the knapsack problem. Each item for the knapsack has a priority and a weight. Now I specify a weight X. I must know compute the smallest set of items of which the sum of weight is at least X and have the lowest priority. Each item can only chosen once. Example:\n\n```\n    KnapsackItem a = new KnapsackItem(\"a\", 1000, 0.1);\n    KnapsackItem b = new KnapsackItem(\"b\", 1000, 0.01);\n    KnapsackItem c = new KnapsackItem(\"c\", 1000, 0.01);\n\n    Knapsack sack = new Knapsack(1900);\n    sack.addItem(a);\n    sack.addItem(b);\n    sack.addItem(c);\n\n    for (KnapsackItem item : sack.compute()) {\n        System.out.println(item);\n    }\n```\n\n\nThis should return b,c.\n\nMy solution returns b, a. I don't know why. Spent hours debugging, but I just don't get it. Maybe someone can have a look or post a solution of this problem variation as code.\n\n```\npublic class Knapsack {\n/**\n * The sum of the priorities. For example \"prisoSum.get(2) returns 5\" means,\n * that element 2 returns a sum priority of 5.\n */\nprivate HashMap<Integer, Double> prioSum = new HashMap<Integer, Double>();\n\n/**\n * List of items.\n */\nprivate ArrayList<KnapsackItem> items;\n\n/**\n * Minimum weight. The sum of the weights of the items in the item list must\n * at least be equal to this value.\n */\nprivate int minWeight;\n\n/**\n * Constructor.\n *\n * @param minWeight\n *            the minimum weight.\n */\npublic Knapsack(final int minWeight) {\n    this.items = new ArrayList<KnapsackItem>();\n    this.minWeight = minWeight;\n}\n\n/**\n * Computes the items to select.\n *\n * @return list of items to select.\n */\npublic final ArrayList<KnapsackItem> compute() {\n    ArrayList<KnapsackItem> ret = new ArrayList<KnapsackItem>();\n    int weightLeft = this.minWeight;\n    KnapsackItem item;\n\n    while (weightLeft > 0) {\n        ArrayList<KnapsackItem> diff = getDifference(this.items, ret);\n        if (diff.size() == 0) {\n            break;\n        }\n\n        item = computeBestItemForMinVal(diff,\n                weightLeft);\n\n        ret.add(item);\n        weightLeft -= item.getWeight();\n    }\n\n    return ret;\n}\n\n/**\n * Gets the best item to select for a given weight.\n *\n * @param list\n *            List of items to select form\n * @param minVal\n *            given weight\n * @return best item from list for given weight\n */\nprivate KnapsackItem computeBestItemForMinVal(\n        final ArrayList<KnapsackItem> list, final int minVal) {\n    int[] best = new int[minVal + 1];\n    for (int w = 0; w <= minVal; w++) {\n        for (int i = 0; i < list.size(); i++) {\n            KnapsackItem curIt = list.get(i);\n\n            // Current priority inclusive all antecessors\n            double curVal = 0;\n            if (prioSum.get(w - curIt.getWeight()) != null) {\n                curVal = prioSum.get(w - curIt.getWeight())\n                        + curIt.getPriority();\n            } else {\n                curVal = 0 + curIt.getPriority();\n            }\n            if (prioSum.get(w) == null) {\n                prioSum.put(w, curVal);\n                best[w] = i;\n            } else if (prioSum.get(w) > curVal) {\n                prioSum.put(w, curVal);\n                best[w] = i;\n            }\n        }\n    }\n    return list.get(best[minVal]);\n}\n\n/**\n * Computes the difference between two given list of Knapsack items and\n * returns it.\n *\n * @param main\n *            first list\n * @param sub\n *            second list\n * @return difference\n */\nprivate ArrayList<KnapsackItem> getDifference(\n        final ArrayList<KnapsackItem> main,\n        final ArrayList<KnapsackItem> sub) {\n    ArrayList<KnapsackItem> ret = new ArrayList<KnapsackItem>();\n\n    for (int m = 0; m < main.size(); m++) {\n\n        boolean found = false;\n        for (int s = 0; s < sub.size(); s++) {\n            if (main.get(m).getName() == sub.get(s).getName()) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            ret.add(main.get(m));\n        }\n    }\n\n    return ret;\n}\n\n}\n```\n\n    ", "Answer": "\r\nI found my mistake. I have to add ```\n\n        prioSum.clear();```\n\nto computeBestItemForMinVal(). So the data of the previous calls gets deleted.\nI also start the for-loop for weight now at 1, not at 0:\n\n```\nprivate KnapsackItem computeBestItemForMinVal(\n        final ArrayList<KnapsackItem> list, final int minVal) {\n    int[] best = new int[minVal + 1];\n    prioSum.clear();\n    for (int w = 1; w <= minVal; w++) {\n...\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What's wrong with my DP solution for 0-1 Knapsack?\r\n                \r\nThe question is classical 0-1 knapsack problem:\n\n```\nGiven n items with size A[i], an integer m denotes the size of a backpack. How full you can fill this backpack?\n\nExample\nIf we have 4 items with size [2, 3, 5, 7], the backpack size is 11, we can select 2, 3 and 5, so that the max size we can fill this backpack is 10. If the backpack size is 12. we can select [2, 3, 7] so that we can fulfill the backpack. \n```\n\n\nI wrote two solution for it, and the first recursion one works, but DP one doesn't.\n\n```\nclass Solution:\n    # @param m: An integer m denotes the size of a backpack\n    # @param A: Given n items with size A[i]\n    # @return: The maximum size\n    def backPack(self, m, A):\n        if len(A) <= 0 or m <= 0:\n            return 0\n        if A[0] > m:\n            return self.backPack(m, A[1:])\n        put = A[0] + self.backPack(m - A[0], A[1:])\n        not_put = self.backPack(m, A[1:])\n        return max(put, not_put)\n\n    def YetAnotherBackPack(self, m, A):\n        mapping = [(m + 1) * [0]] * (len(A) + 1)\n        for i in range(len(A) + 1):\n            for j in range(m + 1):\n                if i == 0 or j == 0:\n                    mapping[i][j] = 0\n                elif A[i - 1] > j:\n                    mapping[i][j] = mapping[i - 1][j]\n                else:\n                    put = mapping[i - 1][j - A[i - 1]] + A[i - 1]\n                    mapping[i][j] = max(mapping[i - 1][j], put)\n\n        return mapping[len(A)][m]\n\nprint Solution().backPack(10, [3, 4, 8, 5]) # output: 9\nprint Solution().YetAnotherBackPack(10, [3, 4, 8, 5]) # output: 10 WRONG!\n```\n\n\nCan anyone help point that what's wrong with my DP solution?\n    ", "Answer": "\r\nThis line is the problem:\n\n```\nmapping = [(m + 1) * [0]] * (len(A) + 1)\n```\n\n\nYou're creating a list of lists, but you're not creating a unique inner list for each row - all of the rows are pointing to the same list (the one created by [(m + 1) * [0]].\n\nTo fix it, change that line to something like this:\n\n```\nmapping = [[0 for i in range(m+1)] for j in range(len(A) + 1)]\n```\n\n\nFor a more detailed description of this issue: Nested List Indices\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "how to find best element in bag in knapsack\r\n                \r\nhow can I find best items in the bag in KNAPSACK problem in recursive mode with C#?\n\nI have tried to collect indexes which function return larger value for them but i did not seem to work....\n\n```\nstatic int recursiveknapsnack(int i,int W) {\n    if (i < 0) {\n        return 0;\n    } else if (wt[i] > W) {\n        return recursiveknapsnack(i - 1, W);\n    } else {\n        return Math.Max(recursiveknapsnack(i-1, W),recursiveknapsnack(i-1,W - wt[i])+val[i]);\n    }\n}\n```\n\n    ", "Answer": "\r\nOf course it depends on which Knapsack problem you aim to solve, but if it is the default one, you should separate the weight aspects from the value-aspects, thus:\n\n```\nstatic int recursiveknapsnack(int i,int W, int v) {\n    if (i < 0 || w <= 0) {\n        return v;\n    } else if (wt[i] > W) {\n        return recursiveknapsnack(i-1,W,v);\n    } else {\n        return Math.Max(recursiveknapsnack(i-1,W,v),recursiveknapsnack(i-1,W- wt[i],v+val[i]));\n    }\n}\n```\n\n\nAnd call it with:\n\n```\nrecursiveKnapsack(n,W,0);\n```\n\n\nwith ```\nn```\n the number of items and ```\nW```\n the total capacity of the Knapsack.\n\nNote however that this recursive algorithm is far from optimal. The knapsack problem is pseudo-polynomial using a dynamic programming approach, one can achieve a way more efficient algorithm.\n\nEDIT: in case you want to calculate the bag and not the maximum value itself, you can store the optimal value and bag:\n\n```\nint[] wt;//the weights\nint[] val;//the values\n\nstatic bool[] solveKnapsack (int W) {\n    int n = wt.length;\n    bool[] knapsack = new bool[n];\n    bool[] opt = null;\n    int vopt = 0;\n    recursiveknapsnack(n-1,W,0,knapsack,ref vopt,ref opt);\n    return opt;\n}\n\nstatic void recursiveknapsnack(int i, int W, int v, bool[] knapsack, ref int vopt, ref bool[] kopt) {\n        if (i < 0 || w <= 0) {\n            if(v > vopt) {\n                vopt = v;\n                kopt = (bool[]) knapsack.Clone();\n            }\n        } else if (wt[i] > W) {\n            return recursiveknapsnack(i-1,W,v);\n        } else {\n            return Math.Max(recursiveknapsnack(i-1,W,v,ref vopt, ref kopt),recursiveknapsnack(i-1,W-wt[i],v+val[i],ref vopt,ref kopt));\n        }\n    }\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Fractional Knapsack : why value/weight?\r\n                \r\nIn Fractional Knapsack problem, \n\n1. prepare the third array, value per weight array, dividing the weight of each item by its corresponding value\n\n2. sort the items in descending order according to their value per weight\n\nthe reason behind the step 1 and 2?\n    ", "Answer": "\r\nBecause it is more profitable to fill all possible volume with substance having the highest value/weight ratio. So use up all given quantity of item with the best value/weight ratio, then with the second and so on.\n\nJust think - if you believe that it is possible to fill some part with less valuable item (while more valuable  one is available) - change it to more valuable and you'll have got some additional money\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multi-objective problem with non-primitive types in Jenetics\r\n                \r\nI would like to implement a multi-objective knapsack problem with two knapsacks in Jenetics, but I struggle with some typing issues. I had a look at the ```\nDTLZ1```\n problem from the Jenetics manual—which is to my knowledge the only MOO example available—and mapped it to the ```\nProblem```\n class:\n\n```\npublic class DTLZ1 implements Problem<double[], DoubleGene, Vec<double[]>> {\n\n    // Constants...\n\n    public static void main(String[] args) {\n        // Engine setup and evolution stream execution...\n    }\n\n    @Override\n    public Function<double[], Vec<double[]>> fitness() {\n        // Original fitness function...\n    }\n\n    @Override\n    public Codec<double[], DoubleGene> codec() {\n        // Original codec...\n    }\n\n}\n```\n\n\nI have previously implemented a single-objective knapsack problem in Scala using the following type signature (converted to Java):\n\n```\nProblem<ISeq<BitGene>, BitGene, Integer>\n```\n\n\nWhere:\n\n\n```\n<ISeq<BitGene>```\n: a knapsack as a (immutable) sequence of bits.\n```\nBitGene```\n: the gene type of the evolution engine.\n```\nInteger```\n: the fitness of the knapsack, i.e., its profit.\n\n\nUsing two knapsacks, I thought about something like (based on the ```\nDTLZ1```\n example):\n\n```\nProblem<ISeq<BitGene>[], BitGene, Vec<int[]>>\n```\n\n\nWhere:\n\n\n```\nISeq<BitGene>[]```\n: multiple knapsacks as (immutable) sequences of bits, wrapped in an array.\n```\nBitGene```\n: the gene type of the evolution engine (same as above).\n```\nint[]```\n: the fitness of the knapsacks, i.e., their profit.\n\n\nApart from ```\nISeq<BitGene>[]```\n, which takes some time getting used to (could I also use ```\nList```\n or something similar?), I don't know how to create a proper codec:\n\n```\n@Override\npublic Codec<ISeq<BitGene>[], BitGene> codec() {\n    return Codecs.ofVector(\n            () -> {\n                // What kind of supplier do I need?\n            },\n            NUMBER_OF_KNAPSACKS);\n}\n```\n\n    ", "Answer": "\r\nIf I understand your problem correctly, the codec would look like this:\n\n```\npublic static <T> Codec<ISeq<ISeq<T>>, BitGene>\ncodec(final ISeq<? extends T> items, final int knapsackCount) {\n    return Codec.of(\n        Genotype.of(\n            BitChromosome.of(items.length()).instances()\n                .limit(knapsackCount)\n                .collect(ISeq.toISeq())\n        ),\n        gt -> gt.stream()\n            .map(ch -> ch.as(BitChromosome.class))\n            .map(ch -> ch.ones()\n                .<T>mapToObj(items)\n                .collect(ISeq.toISeq()))\n            .collect(ISeq.toISeq())\n    );\n}\n```\n\n\nInstead of an ```\nISeq<T>[]```\n array, I'm using a ```\nISeq<ISeq<T>>```\n, but the size of the first sequence will be ```\nknapsackCount```\n and the size of the nested sequence is ```\nitmes.length()```\n. The signature of your problem will be ```\nProblem<ISeq<ISeq<T>>, BitGene, Vec<double[]>>```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Finding the best knapsack solver [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am looking for the stat-of-the-art solver for the 0-1 knapsack problem,\nDo any one know how to find such a solver?\nbetter if it will be written in python or matlab.\n\nDo you know what is limitation of current solver?\n\nThanks\nTomer\n    ", "Answer": "\r\nIn 2019, Google's or-tools won 4 of 5 \"gold medals\" in the mini zinc challenge.\n\nThey nicely present how to solve knapsack among other things in their documentation. They have python bindings as well. \n\nI'm not a mathematician, but I use these tools and they are really good for developers, IMHO. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Optimizing 1-0 Knapsack problem to maximize weight instead of value\r\n                \r\nI want to know how to approach the following problem: given a limited amount of people allowed on a bus (not exceeding 100) and the following data: group name, amount of members in the group, their luggage weights. I have to make use of dynamic programming, to calculate the most profitable way to pack the busses. The profit is obtained by multiplying the weight of the luggage by $5.\nTo my understanding, majority of the resources online cater for maximizing the value-field, however I need to maximize profit, and thus maximize the weight of the luggage, while just keeping in mind the constraint of having only 100 people on the bus. (there are 5 busses in total, so would reiterate 5 times)\nAny advice would be greatly appreciated, as I have only created a group object, and am busy deciding if it would be more efficient to use an List, or matrix in order to evaluate the most profitable way to arrange the groups. (using Java, but basic pseudocode/algorithm analysis would suffice)\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm restricted to N-element solution\r\n                \r\nThis excerpt from the CRAN documentation for the adagio function knapsack() functions as expected -- it solves the knapsack problem with profit vector ```\np```\n, weight vector ```\nw```\n, and capacity ```\ncap```\n, selecting the subset of elements with maximum profit subject to the constraint that the total weight of selected elements does not exceed the capacity.\n\n```\nlibrary(adagio)\np <- c(15, 100, 90, 60, 40, 15, 10,  1)\nw <- c( 2,  20, 20, 30, 40, 30, 60, 10)\ncap <- 102\n(is <- knapsack(w, p, cap))\n```\n\n\nHow can I add a vector length constraint to the solution and still get an optimal answer? For example, the above exercise, but the selected subset must include exactly three elements.\n    ", "Answer": "\r\nOne approach would be to explicitly model the problem as a mixed integer linear programming problem; the advantage of explicitly modeling it in this way is that linear constraints like \"pick exactly three objects\" are simple to model. Here is an example with the lpSolve package in R, where each element in the knapsack problem is represented by a binary variable in a mixed integer linear programming formulation. The requirement that we select exactly three elements is captured by the constraint requiring the decision variables to sum to exactly 3.\n\n```\nlibrary(lpSolve)\np <- c(15, 100, 90, 60, 40, 15, 10,  1)\nw <- c( 2,  20, 20, 30, 40, 30, 60, 10)\ncap <- 102\nexact.num.elt <- 3\nmod <- lp(direction = \"max\",\n          objective.in = p,\n          const.mat = rbind(w, rep(1, length(p))),\n          const.dir = c(\"<=\", \"=\"),\n          const.rhs = c(cap, exact.num.elt),\n          all.bin = TRUE)\n# Solution\nwhich(mod$solution >= 0.999)\n# [1] 2 3 4\n\n# Profit\nmod$objval\n# [1] 250\n```\n\n\nWhile subsetting the optimal solution from the ```\nadagio:::knapsack```\n function to the desired size is a reasonable heuristic for the case when the desired subset size is smaller than the cardinality of the optimal solution to the standard problem, there exist examples where the optimal solution to the standard knapsack problem and the optimal solution to the size-constrained knapsack problem are disjoint. For instance, consider the following problem data:\n\n```\np <- c(2, 2, 2, 2, 3, 3)\nw <- c(1, 1, 1, 1, 2, 2)\ncap <- 4\nexact.num.elt <- 2\n```\n\n\nWith capacity 4 and no size constraint, the standard knapsack problem will select the four elements with profit 2 and weight 1, getting total profit 8. However, with size limit 2 the optimal solution is instead to select the two elements with profit 3 and weight 2, getting total profit 6.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Variation on knapsack - minimum total cost with exact weight [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThere are types of items (N types), each have weight wi and cost ci. There are an infinite number of each. The problem is to make a knapsack with EXACT (W) weight and minimum total cost of items. I know I should use dynamic in this case, but it's not a usual knapsack problem and I can't find the relation. I also found some similar questions, but I haven`t understood theese solutions. Here are the links 1, 2.\nHow to use DP to solve it?\n    ", "Answer": "\r\nlet f[i] means, to get weight i, the minimum cost. g[i] means whether it is possible to combine exactly weight i;\n\n```\nf[0]=0;g[0]=true;\nfor (int i=0;i<N;i++)\n    for (int j=0;j<W;j++)\n        if (g[j]) {\n            g[j+w[i]]=true;\n            if (f[j+w[i]]==0||f[j+w[i]]>f[j]+c[i])\n                f[j+w[i]]=f[j]+c[i];\n        }\n\nif (g[W]) return f[W];\nelse return 0;//impossible\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Optimal way of filling 2 knapsacks?\r\n                \r\nThe dynamic programming algorithm to optimally fill a knapsack works well in the case of one knapsack. But is there an efficient known algorithm that will optimally fill 2 knapsacks (capacities can be unequal)? \n\nI have tried the following two approaches and neither of them is correct. \n\n\nFirst fill the first knapsack using the original DP algorithm to fill one knapsack and then fill the other knapsack.\nFirst fill a knapsack of size W1 + W2 and then split the solution into two solutions (where W1 and W2 are the capacities of the two knapsacks).\n\n\nProblem statement (see also Knapsack Problem at Wikipedia): \n\n\nWe have to fill the knapsack with a set of items (each item has a weight and a value) so as to maximize the value that we can get from the items while having a total weight less than or equal to the knapsack size. \nWe cannot use an item multiple times. \nWe cannot use a part of an item. We cannot take a fraction of an item. (Every item must be either fully included or not).\n\n    ", "Answer": "\r\nI will assume each of the ```\nn```\n items can only be used once, and you must maximize your profit.\n\nOriginal knapsack is ```\ndp[i] = best profit you can obtain for weight i```\n\n\n```\nfor i = 1 to n do\n  for w = maxW down to a[i].weight do\n    if dp[w] < dp[w - a[i].weight] + a[i].gain\n      dp[w] = dp[w - a[i].weight] + a[i].gain\n```\n\n\nNow, since we have two knapsacks, we can use ```\ndp[i, j] = best profit you can obtain for weight i in knapsack 1 and j in knapsack 2```\n\n\n```\nfor i = 1 to n do\n  for w1 = maxW1 down to a[i].weight do\n    for w2 = maxW2 down to a[i].weight do\n      dp[w1, w2] = max\n                   {\n                       dp[w1, w2], <- we already have the best choice for this pair\n                       dp[w1 - a[i].weight, w2] + a[i].gain <- put in knapsack 1\n                       dp[w1, w2 - a[i].weight] + a[i].gain <- put in knapsack 2\n                   }\n```\n\n\nTime complexity is ```\nO(n * maxW1 * maxW2)```\n, where ```\nmaxW```\n is the maximum weight the knapsack can carry. Note that this isn't very efficient if the capacities are large.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Optimal way of filling 2 knapsacks?\r\n                \r\nThe dynamic programming algorithm to optimally fill a knapsack works well in the case of one knapsack. But is there an efficient known algorithm that will optimally fill 2 knapsacks (capacities can be unequal)? \n\nI have tried the following two approaches and neither of them is correct. \n\n\nFirst fill the first knapsack using the original DP algorithm to fill one knapsack and then fill the other knapsack.\nFirst fill a knapsack of size W1 + W2 and then split the solution into two solutions (where W1 and W2 are the capacities of the two knapsacks).\n\n\nProblem statement (see also Knapsack Problem at Wikipedia): \n\n\nWe have to fill the knapsack with a set of items (each item has a weight and a value) so as to maximize the value that we can get from the items while having a total weight less than or equal to the knapsack size. \nWe cannot use an item multiple times. \nWe cannot use a part of an item. We cannot take a fraction of an item. (Every item must be either fully included or not).\n\n    ", "Answer": "\r\nI will assume each of the ```\nn```\n items can only be used once, and you must maximize your profit.\n\nOriginal knapsack is ```\ndp[i] = best profit you can obtain for weight i```\n\n\n```\nfor i = 1 to n do\n  for w = maxW down to a[i].weight do\n    if dp[w] < dp[w - a[i].weight] + a[i].gain\n      dp[w] = dp[w - a[i].weight] + a[i].gain\n```\n\n\nNow, since we have two knapsacks, we can use ```\ndp[i, j] = best profit you can obtain for weight i in knapsack 1 and j in knapsack 2```\n\n\n```\nfor i = 1 to n do\n  for w1 = maxW1 down to a[i].weight do\n    for w2 = maxW2 down to a[i].weight do\n      dp[w1, w2] = max\n                   {\n                       dp[w1, w2], <- we already have the best choice for this pair\n                       dp[w1 - a[i].weight, w2] + a[i].gain <- put in knapsack 1\n                       dp[w1, w2 - a[i].weight] + a[i].gain <- put in knapsack 2\n                   }\n```\n\n\nTime complexity is ```\nO(n * maxW1 * maxW2)```\n, where ```\nmaxW```\n is the maximum weight the knapsack can carry. Note that this isn't very efficient if the capacities are large.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Modifed version of the knapsack\r\n                \r\nI know how to code the solution for the 0-1 knapsack problem. However, I do not know how to change this code such that we can pick multiple copies of the same item. So, for each item i , we have another paramter k(i) which denotes the number of copies of i present. I will be obliged if someone could help me with this. Below is my code when k(i) = 1. Look at the knapsack function for a top down dp solution\n\n```\n#include<cstring>\n#include<cstdio>\n#include<iostream>\nusing namespace std;\nint n, g;\nint p[1005],w[1005];\nint dp[1004][35];// num of object and weight left\n\nint knapsack(int resourcel, int item){\n    //if(resourcel < 0) return (1<<31);\n    if(item == n) return 0;\n    if(resourcel == 0) return 0;\n    if(dp[item][resourcel] != -1) return dp[item][resourcel];\n\n    if(resourcel - w[item] < 0){\n        dp[item][resourcel]  = knapsack(resourcel,item+1);\n        return dp[item][resourcel];\n    }\n    else{\n        int take = knapsack(resourcel - w[item],item+1) + p[item];\n        int notTake = knapsack(resourcel,item+1);\n        dp[item][resourcel] = take > notTake?take : notTake;\n        return dp[item][resourcel];\n    }\n\n\n}\nint main(){\n    int tc,dummy, sum =0;\n    //freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d\",&tc);\n    for(int i = 0 ; i < tc; i++){\n        sum  = 0;\n        memset(dp,-1,sizeof(dp));\n        scanf(\"%d\",&n);\n        //cout<<\" n is : \"<<n<<endl;\n        for(int j = 0 ; j < n ;j++){\n            scanf(\"%d %d\",&p[j],&w[j]);\n            //cout<<\" price and val  is : \"<<p[j]<<\" \" << w[j]<<endl;\n        }\n        scanf(\"%d\",&g);\n        //cout<<\"g is : \"<<g<<endl;\n        for(int p = 0 ; p< g;p++){\n            scanf(\"%d\",&dummy);\n            sum+= knapsack(dummy,0);//wight allowed and item visited\n        }\n        printf(\"%d\\n\",sum);\n\n    }\n\n    return 0;\n\n}\n```\n\n    ", "Answer": "\r\nYour knapsack code is overly complicated. Here is another way to do it:\n\nLet ```\ndp[i] = maximum profit we can get for weight i```\n.\n\n```\nfor i = 1 to numItems do\n  for j = knapsackWeight down to items[i].weight do\n    dp[j] = max(dp[j], dp[j - items[i].weight] + items[i].profit)\n```\n\n\nNow, you also want a field ```\nitem.copies```\n. We can simply add another loop in the middle to iterate this many times.\n\n```\nfor i = 1 to numItems do\n  for k = 1 to items[i].copies do\n    for j = knapsackWeight down to items[i].weight do\n      dp[j] = max(dp[j], dp[j - items[i].weight] + items[i].profit)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Select the same item several times in the knapsack problem [pulp]\r\n                \r\nI'm doing a coursera' discrete optimization course\nwhich, in the course a tool called Minizinc is used to solve the problems. \n\nI want to translate class examples to python, starting for this one:\n\n\nI'm using this example code  reproduce the results:\n\n```\nv = {'hammer':6, 'wrench':10, 'screwdriver':8, 'towel':40}\nw = {'hammer':13, 'wrench':21, 'screwdriver':17, 'towel':100}\nq = {'hammer':1000, 'wrench':400, 'screwdriver':500, 'towel':150}\nlimit = 1000\nitems = list(sorted(v.keys()))\n\n# Create model\nm = LpProblem(\"Knapsack\", LpMaximize)\n\n# Variables\nx = LpVariable.dicts('x', items, lowBound=0, upBound=1, cat=LpInteger)\n\n# Objective\nm += sum(v[i]*x[i] for i in items)\n\n# Constraint\nm += sum(w[i]*x[i] for i in items) <= limit\n\n\n# Optimize\nm.solve()\n\n# Print the status of the solved LP\nprint(\"Status = %s\" % LpStatus[m.status])\n\n# Print the value of the variables at the optimum\nfor i in items:\n    print(\"%s = %f\" % (x[i].name, x[i].varValue))\n\n# Print the value of the objective\nprint(\"Objective = %f\" % value(m.objective))\n```\n\n\nBut this is giving a wrong answer since is only taken one of a kind.\nHow can I add the amount available for each item (dict q) into the constraints?\n    ", "Answer": "\r\nYou need to make two very small changes to your code. Firstly you need to remove the upper bound you have set on your ```\nx```\n variables. At the moments you have binary variables ```\nx[i]```\n which can be only one or zero.\n\nSecondly you need to add in the constraints which effectively set a custom upper bound for each of the items. Working code and resulting solution below - as you can see multiple wrenches (the highest ```\nv/w```\n ratio) are chosen, with a single hammer to fill up the small amount of space left.\n\n```\nfrom pulp import *\nv = {'hammer':6, 'wrench':10, 'screwdriver':8, 'towel':40}\nw = {'hammer':13, 'wrench':21, 'screwdriver':17, 'towel':100}\nq = {'hammer':1000, 'wrench':400, 'screwdriver':500, 'towel':150}\nlimit = 1000\nitems = list(sorted(v.keys()))\n\n# Create model\nm = LpProblem(\"Knapsack\", LpMaximize)\n\n# Variables\nx = LpVariable.dicts('x', items, lowBound=0, cat=LpInteger)\n\n# Objective\nm += sum(v[i]*x[i] for i in items)\n\n# Constraint\nm += sum(w[i]*x[i] for i in items) <= limit\n\n# Quantity of each constraint:\nfor i in items:\n    m += x[i] <= q[i]\n\n\n# Optimize\nm.solve()\n\n# Print the status of the solved LP\nprint(\"Status = %s\" % LpStatus[m.status])\n\n# Print the value of the variables at the optimum\nfor i in items:\n    print(\"%s = %f\" % (x[i].name, x[i].varValue))\n\n# Print the value of the objective\nprint(\"Objective = %f\" % value(m.objective))\nprint(\"Total weight = %f\" % sum([x[i].varValue*w[i] for i in items]))\n```\n\n\nWhich returns:\n\nStatus = Optimal\n\n```\nx_hammer = 1.000000\nx_screwdriver = 0.000000\nx_towel = 0.000000\nx_wrench = 47.000000\nObjective = 476.000000\nTotal weight = 1000.000000\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack 0/1 algorithm - unlimited resources\r\n                \r\nI've run into a thinking trouble and I'm just frustrated. I have a working algorithm of the knapsack problem, using dynamic programming, where I specify \n\n\nMax load\nItems (their weight)\n\n\nand the algorithm calculates the optimal fill of the knapsack using those items. But now I need to fill it completely, using least items, but I have unlimited amount of each item. (Those items have weights ```\n{1; w1; w2; ...}```\n so it is always possible to complete).\n\nHow do I fit this in the 'classic' algorithm?\n\nThanks\n    ", "Answer": "\r\nLet \n    M    = Amount need to fill\n    w[]  = Array of weights\n    dp[] = Array of optimal fill(dp[i] contains minimum number of items needed to fill weight i).\n\n```\n initialize the dp array with INFINITY, dp[0] = 0;\n for(i = 0;i<size of w;i++) {\n    for(j = 1;j<=M;j++) {\n       if(j-w[i] >= 0) {\n          dp[j] = min(dp[j], dp[j-w[i]]+1);\n       }\n    }\n }\n\n final solution is the value of dp[M];\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple Knapsack Variations\r\n                \r\nI'm and undergrad doing some evolutionary algorithm work on the multiple knapsack problem. I've completed my code, but I'm struggling to understand an aspect of test cases. I've noticed that they have a constraint (weights or costs) matrix, as opposed to a list. Why? Why should the cost of an object depend on which knapsack it's in? I can certainly add to the algorithm to make this happen, but I don't understand its applications. Each test case I've found is in this format. Any help with the matrix or data with 1-dimensial constraint would be appreciated.\n    ", "Answer": "\r\nAs a popular paper on the travelings salesman says:\n\n\n  The popularity of the travelings salesman problem does not originate from millions of salesman that want to calculate the optimal route.\n\n\nBased on your specification of the problem, I think you are talking about the Multiple-Choice Knapsack Problem (p. 12). With P the price matrix and W the weight matrix.\n\nThe same of course holds for the Knapsack problem. Although the story is about a knapsack that knapsack can be anything.\n\nTake for instance a scheduling problem. Say you have a (fictitious)  hospital with three employees: two doctors and one nurse. Now each day, one makes a list of tasks these employees have to carry out (for instance examining patients, filling in forms,...). Now we can represent each of the employees as a knapsack since they have a limited number of hours they work that day.\n\nThe weight of a task describes the amount of time employee i needs to handle task j. And furthermore it can be used to specify that a certain task is forbidden. For instance in Belgium a nurse with an A-certificate is not allowed to give a patient an injection. You can enforce this by specifying that the nurse would take years to handle such task, the \"weight\" of that task is thus too large with respect to the capacity of that bag.\n\n\n  So: wij describes the time employee i spends to carry out task j and is set above the capacity if that task cannot be carried out by that employee.\n\n\nFurthermore the value is for instance the quality of carrying out the task. If one of the doctors is specialized in heart diseases, evidently his diagnosis for patients with heart problems will be better. Or you can for instance use the inverse of the amount you need to pay the employee to handle that task (if the employees are paid on a per-task basis), to minimize the cost.\n\n\n  So pij specifies the quality with which employee i will carry out task j, or for instance the inverse of the cost of employee i carrying out task j.\n\n\nThe optimal configuration of the knapsack will thus specify which tasks the employees will handle that day such that no employee works more than is allowed (or performs tasks he/she is not licensed for), and furthermore optimizes the quality of service or minimizes the operational costs.\n\n\n  So if xij=1, that means in the optimal scenario, employee i will carry out task j that day.\n\n\nA typical application is thus one where multiple employees/machines/servers handle tasks/problems/requests with different costs and bounds.\n\n\n\n@IVlad made some constructive comments pointing to related problems:\n\n\nIn the Assignment problem, one aims to construct a set of edges in a bipartite graph such that no two edges share a node and the total weight is maximized. One cannot (evidently) map the MCKP to the AP, since the weights will discard situations where an employee will perform too much tasks, simply because it is optimal.\nThe multi-objective variant transforms the price matrix P into a tensor (or beyond) such that you have different evaluation criteria you can take into account (for instance both the quality and the price), and you search for an optimal solution for both objectives.\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Modified dynamic knapsack - problematic input?\r\n                \r\nFollowing is an attempted solution to this SPOJ problem. The input is: \n\n\nTotal weight of a certain amount of money in coins\nvalues and corresponding weights of the coins of used currency and the goal is to find the minimum possible monetary value of the given amount of money.\n\n\nI slightly modified a dynamic programming solution of the knapsack problem from the wikipedia article on the knapsack problem - I just first sorted the coins by weight so I don't have to go through all the coins to get the smallest value and (hopefully) made sure that the combined weight is equal to the capacity. (Please, see the code, it's really simple and commented.)\n\nHowever, according to the judge, there is an input for which my algorithm give an incorrect answer. Can you please suggest what is wrong with the algorithm?\n\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\ntypedef unsigned int weight_t;\ntypedef unsigned int value_t;\n\nstruct coin {\n    weight_t weight;\n    value_t value;\n};\n\ncoin make_coin(weight_t weight, value_t value) {\n    coin ret;\n    ret.weight = weight;\n    ret.value = value;\n    return ret;\n}\n\nbool compare_by_weight(const coin& coin1, const coin& coin2) {\n    return coin1.weight < coin2.weight;\n}\n\nint main() {\n    unsigned int test_cases;\n    cin >> test_cases;\n    while(test_cases--) {\n        //Initialization\n        unsigned int number_of_coins, n = 0;\n        weight_t empty_pig, full_pig, coin_weight, coins_weight;\n        value_t coin_value, min_value, current_value = 0;\n        vector<coin> coins;\n        vector<unsigned int> min_value_for_the_weight;\n\n        //Input\n        cin >> empty_pig >> full_pig;\n        cin >> number_of_coins;\n        n = number_of_coins;\n        while(n--) {\n            cin >> coin_value >> coin_weight;\n            coins.push_back(make_coin(coin_weight, coin_value));\n        }\n\n        //Input processing\n        coins_weight = full_pig - empty_pig;\n        sort(coins.begin(), coins.end(), compare_by_weight);\n        min_value_for_the_weight.resize(coins_weight+1);\n        for(unsigned int i = 0; i < coins_weight; i++) min_value_for_the_weight[i] = 0;\n\n        //For all weights\n        for(unsigned int i = 1; i <= coins_weight; i++) {\n            //Find the smallest value\n            min_value = numeric_limits<value_t>::max();\n            for(unsigned int j = 0; j < number_of_coins; j++) {\n                //The examined coin weights more or same than examined total weight and we either already have put a coin\n                //in, or this is the first one\n                if(coins[j].weight <= i && (min_value_for_the_weight[i - coins[j].weight] > 0 || i == coins[j].weight)){\n                    current_value = coins[j].value + min_value_for_the_weight[i - coins[j].weight];\n                    if(current_value < min_value) min_value = current_value;\n                } else break;  // <- this I deleted to get accepted\n            }\n            if(min_value == numeric_limits<value_t>::max()) min_value = 0;\n            min_value_for_the_weight[i] = min_value;\n        }\n\n        //If the piggy empty, output zero\n        if(!min_value_for_the_weight[coins_weight] && coins_weight != 0)\n            cout << \"This is impossible.\" << endl;\n        else\n            cout << \"The minimum amount of money in the piggy-bank is \" << min_value_for_the_weight[coins_weight] << \".\" << endl;\n        }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nThe case ```\nempty_pig == full_pig```\n is problematic, because you have neglected to repeat the logic special-casing the zeroth entry of ```\nmin_value_for_the_weight```\n.\n\nThe other bug is that it's only a good idea to ```\nbreak```\n if ```\ncoins[j].weight > i```\n. The old code could ```\nbreak```\n when ```\ncoin[j].weight <= i```\n and the other half of the conjunct was false, i.e., it was impossible to make coins with weight ```\ni - coins[j].weight```\n. This happens on the following test case.\n\n```\n1\n10 13\n2\n2 2\n3 3\n```\n\n\nWe have to make weight 3 using coins of weight 2 or 3. Weight 1 is correctly determined to be impossible. Weight 2 is correctly determined to be possible. For weight 3, we try the weight-2 coin, determine that weight 1 is impossible, and ```\nbreak```\n before trying the weight-3 coin. The result is that the code erroneously reports that it's impossible to make weight 3.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "IndexError: list index out of range - {0, 1} Knapsack Problem\r\n                \r\nThis has code has been working fine for a few weeks but hit an error earlier and I can't figure out why. The error is coming from the look in sack function at the line \"if dp[z][i][w] - dp[z][i-1][w - player_costs[i-1]] == player_scores[i-1]:\" and 'i' is hitting 0 and it shouldn't be right? I am assuming there's an issue with what it's searching for and the way that dp is formed.\nAny help would be really appreciated, let me know if you need more info? Super stuck.\n```\ndef knapsack(num_items, weight, count, values, weights, add):\n    dp = [[[0] * (weight + 1) for _ in range(num_items + 1)] for _ in range(count + 1)]\n    for i in range(len(values)):\n        values[i] = values[i] + add\n    for z in range(1, count + 1):\n        for y in range(1, num_items + 1):\n            for x in range(weight + 1):\n                if weights[y - 1] <= x:\n                    dp[z][y][x] = max(dp[z][y - 1][x],\n                                      dp[z - 1][y - 1][x - weights[y - 1]] + values[y - 1])\n                else:\n                    dp[z][y][x] = dp[z][y - 1][x]\n    return dp\n\ndef look_in_sack(result, budget, count, num_items, player_costs, player_scores):\n    elements = []\n    dp = result\n    w = budget\n    i = num_items\n    z = count\n    while (i>0 and len(elements)<count): \n\n        if dp[z][i][w] - dp[z][i-1][w - player_costs[i-1]] == player_scores[i-1]:\n            #the element 'i' is in the knapsack\n            elements.append(i)\n            i = i-1\n            w -= player_costs[i]\n        else:\n            i = i-1\n    return elements\n\nresult = knapsack(num_items, budget, count, player_scores, player_costs, add_this)\nelements = look_in_sack(result, budget, count, num_items, player_costs, player_scores)\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm, How to get better performance?\r\n                \r\nOpenmp outperforms the serial code by factor x2, but I would like to have a better performance if it is possible.\n\nHere is the serial code in c++:\n\n```\nfor (int k = 0; k < numelem[i]; k++)\n{\n    sumK = sumK - weight[k];\n    int cmax = 0;\n    cmax = max(capacity - sumK, weight[k]);\n\n    for (int c = capacity; c >= cmax; c--)\n    {\n        if (f[c] < f[c - weight[k]] + value[k])\n        {\n            f[c] = f[c - weight[k]] + value[k];\n            M[capacity * k + c] = 1;\n        }\n    }\n}\n```\n\n\nFor the openmp version, I use two f0,f1 arrays which are swapped at each iteration. This helps me to prevent the race condition, but I suppose that false sharing is still present (not sure). Other my supposition is that, the conditional statements inside pragma for slow down the execution.\n\n```\n        for (int k = 0; k < numelem[i]; k++) {\n\n            sumK = sumK - weight[k];\n            int cmax = 0;\n            cmax = max(capacity - sumK, weight[k]);\n            int c = capacity;\n\n            if (k % 2 == 0) {\n\n#pragma omp parallel\n    {\n\n#pragma omp for\n                for (c = capacity; c >= cmax; c--) {\n\n                    //FALSE SHARING???\n\n                    if (f0[c] < f0[c - weight[k]] + value[k]) {\n                        f1[c] = f0[c - weight[k]] + value[k];\n                        M[capacity * k + c] = 1;\n                    } else {\n                        f1[c] = f0[c];\n                    }\n                }\n            } \n\n            else {\n\n#pragma omp for\n                for (c = capacity; c >= cmax; c--) {\n\n                    //FALSE SHARING???\n\n                    if (f1[c] < f1[c - weight[k]] + value[k]) {\n                        f0[c] = f1[c - weight[k]] + value[k];\n                        M[capacity * k + c] = 1;\n                    } else {\n                        f0[c] = f1[c];\n                    }\n                }\n\n            }\n\n        }\n    }   \n```\n\n\nHere you can find the full code for serial c++ and openmp c++\n\nThis work is based on this article:\n\n\nSolving knapsack problems on GPU by V. Boyera, D. El Baza,  M. Elkihel\nrelated work: Accelerating the knapsack problem on GPUs by Bharath Suri\n\n    ", "Answer": "\r\nI have no idea what the pragma instructions are for, but regarding the algorithm, you could optimize this part:\n\n```\nfor (c = capacity; c >= cmax; c--) {\n```\n\n\nWhere I'm guessing ```\ncapacity```\n represents the entire capacity of your knapsack.\n\nThe idea is that you don't always need to iterate down starting from this. It's enough to iterate starting from the sum of weights of the items you have currently visited.\n\nSo you can do something like this:\n\n```\n      currentCapacity = 0;\n      for (int k = 0; k < numelem[i]; k++) {\n\n            currentCapacity += weight[k];\n            sumK = sumK - weight[k];\n            int cmax = 0;\n            cmax = max(currentCapacity - sumK, weight[k]);\n            int c = currentCapacity;\n\n            if (k % 2 == 0) {\n\n#pragma omp parallel\n    {\n\n#pragma omp for\n                for (c = currentCapacity; c >= cmax; c--) {\n```\n\n\nIt won't affect the big-oh complexity, but it should offer a performance boost in practice, especially if you have large capacities.\n\nAfter this, you should also force the current capacity to never exceed your knapsack's capacity:\n\n```\ncurrentCapacity = min(currentCapacity, capacity);\n```\n\n\nAfter the ```\n+=```\n I've added.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack with irrational weights\r\n                \r\nConsider the 0/1 knapsack problem.\nThe standard Dynamic Programming algorithm applies only when the capacity as well as the weights to fill the knapsack with are integers/ rational numbers. What do you do when the capacity/weights are irrational? \n\nThe issue is that we can't memoize like we do for integer weights because we may need potentially infinite decimal places for irrational weights - leading to an infinitely large number of columns for the Dynamic Programming Table . \n\nIs there any standard method for solving this? Any comments on the complexity of this problem? Any heuristics?\n\nWhat about associated recurrences like (for example):\n```\n\nf(x)=1, for x< sqrt(2) \nf(x)=f(x-sqrt(2))+sqrt(3),otherwise\n```\n\n?\n\nOr the Pibonacci number problem here: http://www.spoj.pl/problems/PIB/ ?\n    ", "Answer": "\r\nI don't know of any general method which will solve problems of the kind you stated. Perhaps the memoization technique used in Pibonacci (see second section below) can be used.\n\nIn any case, sometimes, we can give really fast algorithms by exploiting the problem (see the sqrt(2) & sqrt(3)) solution below.\n\nReducing such problems to knapsack might not be such a good idea as I expect there will be other ways which will be much faster.\n\nSo to answer your questions:\n\n\n\nProblem involving sqrt(2) and sqrt(3)\n\nI will answer your second question first.\n\n```\nf(x) = 1 for x < sqrt(2). (x >= 0 also, I presume)\nf(x) = f(x-sqrt(2)) + sqrt(3)\n```\n\n\nThis can be solved very fast (in O(log logn) time!), using only integer arithmetic (which is assumed O(1)), expect for one last step which requires multiplying by sqrt(3) and adding 1.\n\nGiven an n we need to find the smallest m such that\n\n```\nn - m sqrt(2) < sqrt(2)\n```\n\n\ni.e.\n\n```\nn - m sqrt(2) < sqrt(2) => n < (m+1)*sqrt(2) => n * sqrt(2) < m+1\n```\n\n\nand\n\n```\nn - (m-1)sqrt(2) > sqrt(2) => n > m sqrt(2) => n*sqrt(2) > m.\n```\n\n\nThus m is the integer part of ```\nn*sqrt(2)```\n\n\nand we have that f(n) = (m-1)*sqrt(3) + 1.\n\nThus we only need to calculate ```\n[n *sqrt(2)]```\n the integer part of ```\nn*sqrt(2)```\n.\n\nThis can be quickly calculated by using the Continued Fractions of sqrt(2) which are rational approximations to sqrt(2) and they are in some sense the 'best' approximations with given denominator sizes.\n\nThe continued fraction a(i)/b(i) of sqrt(2) can be formed using the recurrence:\n\n```\na0 = 1\nb0 = 1\na(i+1) = a(i) +2*b(i)\nb(i+1) = a(i) + b(i)\n```\n\n\nIt can be shown that in order to approximate [n*sqrt(2)] it is enough to consider some odd i for which b(i) > 10*n^2 (using Liouville's approximation Theorem and theorems on continued fractions) and that ```\n[n*sqrt(2)] = [n*a(i)/b(i)]```\n for that i.\n\nNow a(i), b(i) satisfies the matrix equation\n\n```\n[1 2] [a(i)]    [a(i+1)]\n[1 1] [b(i)]  = [b(i+1)]\n```\n\n\nThus we need to compute powers of the matrix\n\n```\n[1 2]\n[1 1]\n```\n\n\nSo that the entries get bigger than 10*n^2.\n\nIt can be shown that the required power of the matrix is O(logn) and thus can be calculated in O(log log n) time using only integer arithmetic (assuming that is O(1)).\n\nSo the value of your function f at n can be calculated in O(log logn) time using only integer arithmetic (except for the last step, where you need to multiply an integer by sqrt(3)).\n\n\n\nPibonacci Number\n\nFrom your comment, this is the problem\n\n```\ng(x) = 1 if 0 <= x < 4\ng(x) = g(x-1) + g(x-pi) x >= 4\n```\n\n\nThis can be solved using memoization:\n\nLet ```\nh(m,n) = g(m - n*pi)```\n\n\nThen we have that\n\n```\nh(m,n) = h(m-1, n) + h(m, n+1)\n```\n\n\nAnd so we have that\n\n```\ng(m) = g(m-1) + h(m, 1)\n```\n\n\nYou can now use memoization by maintaining two tables, one for g(m) and other for h(m,n). Note that even though you need to calculate ```\nh(m,n+1)```\n, increasing n only reduces m -n*pi and will become between 0 and 4 within a reasonable time (O(m) I suppose), thus you won't keep going on forever.\n\nThis is not as nice (or fast) as the sqrt(2) and sqrt(3) solution, but I believe it does give a way to do the calculation.\n\n\n\n0-1 Knapsack with irrational coefficients\n\nPerhaps taking better and better rational approximations to the irrationals and then solving the 0-1 knapsack problem for approximation will ultimately converge to the right solution.\n\nMy guess is, the fixed point in this iteration will give you the solution.\n\nOf course, as the approximations get better the W in O(nW) of they dynamic programming algorithm might become exponential soon and you might be better off just consider all possibilities.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Variation on knapsack - minimum total value exceeding 'W'\r\n                \r\nGiven the usual ```\nn```\n sets of items (each unlimited, say), with weights and values:\n\n```\nw1, v1\nw2, v2\n...\nwn, vn\n```\n\n\nand a target weight ```\nW```\n, I need to choose items such that the total\nweight is at least ```\nW```\n and the total value is minimized.\n\nThis looks to me like a variation (or in some sense converse) of the\ninteger/unbounded knapsack problem.  Any help in formulating the DP algorithm\nwould be much appreciated!\n    ", "Answer": "\r\nlet ```\nTOT = w1 + w2 + ... + wn```\n.\n\nIn this answer I will describe a second bag. I'll denote the original as 'bag' and to the additional as 'knapsack'\n\nFill the bag with all elements, and start excluding elements from it, 'filling' up a new knapsack with size of at most ```\nTOT-W```\n, with the highest possible value! You got yourself a regular knapsack problem, with same elements, and bag size of ```\nTOT-W```\n.\n\nProof:\nAssume you have best solution with k elements: ```\ne_i1,e_i2,...,e_ik```\n, then the bag size is at least of size ```\nW```\n, which makes the excluded items knapsack at most at size ```\nTOT-W```\n.  Also, since the value of the knapsack is minimized for size ```\nW```\n, the value of the excluded items is maximized for size ```\nTOT-W```\n, because if it was not maximized, there would be a better bag of size at least ```\nW```\n, with smaller value.\nThe other way around [assuming you have maximal excluded bag] is almost identical.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Dynamic programming: modified Knapsack\r\n                \r\nI am trying to solve a variation on the knapsack problem using dynamic programming:\n\nSo what I have is a field of squares with dimensions: N*N (like a chessboard). On each square I have some values. What I can do is to add one (+1) to the value on the square or remove one (-1). There is a special rule which says that if there are neighboring squares (squares which have common side - diagonal squares don't count) that have a value equal to the new value of the square, then the values of all such neighboring squares are set to zero \n\nThe goal is to decrease the total value of all squares as much as possible. \n\nFor example if I have a matrix 3x3 representing a field with 3*3 squares then we can have something like this:\n\n\nint[3,3] field = { 1, 2, 3,\n                   5, 1, 6,\n                   7, 3, 9 }\n\n\nand now if I decrease with one the element [0, 1] which has a value of two, then all the elements [0, 0] [0, 1] and [1, 1] will set their values to 0. \n\nSo basically what have I done till now is to rate each action for each square and with some depth of the actions (meaning that I have calculated the rating if one action is repeated several times on one square) and I hold these ratings in a four dimensional array, ```\nratings[action, depth, row, col]```\n. \n\nThe rating represents the number by which the total value of the squares will be decreased. \n\nWhat I want is to find the optimal sequence of actions that will remove as much as possible values from the field. And this must happen in predefined number of actions (or there are defined number of turns and I can make only one action each turn). And with the last said it is clear that I have to find which combination of subsets of the depths from the ratings of the squares will give me highest total rating. \n\nFirst I thought that this can be done with subset sum problem and after that sort the received list of items by their ratings but after that I realized that this can be realized with the knapsack problem except that the ratings are dependent from each other and here is where my problem comes. For example if there is square that changes its value then it is possible that its neighbouring squares can change their ratings automatically. I can write a method for checking if the neighbours of the square will change their ratings after the action but this is not what is troubling me. What worries me is how to realize the knapsack problem with changing values (ratings of the squares)?\n\nTo summarize what I have so far: \n\n\n\nI have a defined number of turns (actions) C - which can be represented as the maximal weight of the matrix\n\n\nI have depth of actions for each square (from 1 to C) - which can be represented as the weight for each item\n\n\nI have ratings for all of the squares (non-negative integer number) - which can be represented as the values of the items.\n\n\n\nThe main problem for me is that the value of the items that are going to be put in the knapsack can change depending on which items are kept.\n\nI have to admit that I didn't wrote my knapsack algorithm from scratch but rather than that I used an already written one and transformed it for my needs. I get the algorithm from here: http://sriwantha.blogspot.com/2011/07/knapsack-problem-in-c.html\n\nAnd here is my code:\n\n```\n//Knapsack problem:\n\n//class for the items in the knapsack\npublic class Item \n{\n    public int row;\n    public int col;\n    public int action;\n    public int depth;\n    public int rating;\n    public Item(int row, int col, int action, int depth, int rating)\n    {\n        this.row = row;\n        this.col = col;\n        this.action = action;\n        this.depth = depth;\n        this.rating = rating;\n    }\n\n    public override string ToString()\n    {\n        return \"row,col,action=\" + row + \",\" + col + \",\" + action + \", depth=\" + depth + \", rating=\" + rating;\n    }\n}\n\nclass KnapSackProblem\n{\n    public static List<Item> FindItemsToPack(List<Item> items, int depthCapacity, out int totalRatingValue)\n    {\n        int[,] ratings = new int[items.Count + 1, depthCapacity + 1];\n        bool[,] keep = new bool[items.Count + 1, depthCapacity + 1];\n\n        for (int i = 1; i <= items.Count; i++)\n        {\n            Item currentItem = items[i - 1];\n            for (int depth = 1; depth <= depthCapacity; depth++)\n            {\n                if (depth >= currentItem.depth)\n                {\n                    int remainingDepth = depth - currentItem.depth;\n                    int remainingDepthRating = 0;\n                    if (remainingDepth > 0)\n                    {\n                        remainingDepthRating = ratings[i - 1, remainingDepth];\n                    }\n                    int currentItemTotalRating = currentItem.rating + remainingDepthRating;\n                    if (currentItemTotalRating > ratings[i - 1, depth])\n                    {\n                        keep[i, depth] = true;\n                        ratings[i, depth] = currentItemTotalRating;\n                    }\n                    else\n                    {\n                        keep[i, depth] = false;\n                        ratings[i, depth] = ratings[i - 1, depth];\n                    }\n                }\n            }\n        }\n\n        List<Item> itemsToBePacked = new List<Item>();\n\n        int remainDepth = depthCapacity;\n        int item = items.Count;\n        while (item > 0)\n        {\n            bool toBePacked = keep[item, remainDepth];\n            if (toBePacked)\n            {\n                itemsToBePacked.Add(items[item - 1]);\n                remainDepth = remainDepth - items[item - 1].depth;\n            }\n            item--;\n        }\n\n        totalRatingValue = ratings[items.Count, depthCapacity];\n        return itemsToBePacked;\n    }\n}\n```\n\n\nAnd from another method I'm calling the Knapsack algorithm:\n\n```\nList<Item> actionsToDo = new List<Item>();\nItem newItemTake;\nItem newItemAdd;\n\nfor (int depth = 0; depth < maxDepth; depth++)\n    {\n    for (int row = 0; row < dimension; row++)\n    {\n        for (int col = 0; col < dimension; col++)\n        {\n            if (ratings[Take, depth, row, col] >= 0)\n            {\n                newItemTake = new Item(row, col, Take, depth + 1, ratings[Take, depth, row, col]);\n                actionsToDo.Add(newItemTake);\n            }\n            if (ratings[Add, depth, row, col] >= 0)\n            {\n                newItemAdd = new Item(row, col, Add, depth + 1, ratings[Add, depth, row, col]);\n                actionsToDo.Add(newItemAdd);\n            }\n        }\n    }\n}\n\nint totalRating = 0;\n\nList<Item> itemsToBePacked = KnapSackProblem.FindItemsToPack(actionsToDo, maxDepth, out totalRating);\n\nforeach (var item in itemsToBePacked)\n{\n    Console.WriteLine(item);\n}\nConsole.WriteLine(totalRating);\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How does 0-1 knapsack have mathmatically exponential time complexty?\r\n                \r\nI wrote an algorithm to solve 0-1 knapsack problem which works perfect which is as follows:\n```\ndef zero_one_knapsack_problem(weight: list, items: list, values: list, total_capacity: int) -> list:\n    \"\"\"\n    A function that implement dynamic programming to solve the zero one knapsack problem. It has exponential\n     time complexity as supposed.\n\n    :param weight: the weight list each element correspond to item at same index\n    :param items: the array of items ordered same as weight list and values list\n    :param values: the values list\n    :param total_capacity: the total capcaity of knapsack\n    :return: How to fill the knapsack\n    \"\"\"\n\n    items_length = len(items)+1\n    total_capacity += 1\n    # Create The table\n    table = [[0 for w in range(total_capacity)] for y in range(items_length)]\n\n    for i in range(1, items_length):\n        for j in range(total_capacity):\n            if weight[i-1] > j:   # Item does not fit\n                pass\n            else:\n                # calculate Take It or Not\n                table[i][j] = max(values[i-1]+table[i-1][j-weight[i-1]], table[i-2][j])\n    print(\"The optimal value to carry is: ${}\".format(table[items_length-1][total_capacity-1]))\n```\n\nFrom the analysis the time complexity is ```\nseta(items_length * total_capacity)```\n which is the summation of the 2 loops together(ignoring constants). Then i read online that this method has exponential time complexity(Not from one source many blogs says exponential also). Which I can't see how it comes for example consider any of below examples:\n```\n1-) 10 * 100000000000 = 1×10¹²\n2-) 11 * 100000000000 = 1.1×10¹²\n3-) 12 * 100000000000 = 1.2×10¹²\n\n# difference between each\n2 and 3 = 100000000000 = 1.2*10^12 - 1.1*10^12\n1 and 2 = 100000000000 = 1.1*10^12 - 1*10^12\n```\n\nas you can see increasing input by 1 didn't cause any exponential growth. So how can they say this algorithm is exponential in a mathematical way.\n    ", "Answer": "\r\nWith a problem size of N bits, you can have, for example, sqrt(N) objects with weights about sqrt(N) bits long, and total_capacity about sqrt(N) bits long.\nThat makes total_capacity about sqrt(2)N, and your solution takes O(sqrt(N)*sqrt(2)N) time, which is certainly exponential.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Fractional Knapsack\r\n                \r\nI need to implement fractional knapsack to solve this problem\n\nValue($}     20   50   10   90  110   70   60\n\nWeight(lb)    3    4    1    5    6    3    4\n\nbut I'm getting confusing in how fractional knapsack work , I understand how the  knapsack only work.\nSo , in my program when I enter for example  the weight limit = 7\n\nit's gave me  143\n\ncan you help me to understand how fractional knapsack work.\n\nThank you\n    ", "Answer": "\r\n\nSorted list in Descending order of Value / Weight is created.\nin your case the list will be 20/3 =6.6 , 50/4=12.75, 10/1=10,90/5=18,110/6=18.3,70/3=23.3,60/4=15\nDescending order : 23.3,18.3,18,15,12.5,10,6.6\nWeight =7.\npick item 1 from Desc order list. its w=3 and 3 < 7 So Total value =0+70=70\npick item 2 , w=6 ; 3+6<7? No. (so take fraction of it )\nweight left=7-3=4.  Parts taken=4*(18.3)=73.2\ntotal value =70+73.2=143.2 =answer\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack with irrational weights\r\n                \r\nConsider the 0/1 knapsack problem.\nThe standard Dynamic Programming algorithm applies only when the capacity as well as the weights to fill the knapsack with are integers/ rational numbers. What do you do when the capacity/weights are irrational? \n\nThe issue is that we can't memoize like we do for integer weights because we may need potentially infinite decimal places for irrational weights - leading to an infinitely large number of columns for the Dynamic Programming Table . \n\nIs there any standard method for solving this? Any comments on the complexity of this problem? Any heuristics?\n\nWhat about associated recurrences like (for example):\n```\n\nf(x)=1, for x< sqrt(2) \nf(x)=f(x-sqrt(2))+sqrt(3),otherwise\n```\n\n?\n\nOr the Pibonacci number problem here: http://www.spoj.pl/problems/PIB/ ?\n    ", "Answer": "\r\nI don't know of any general method which will solve problems of the kind you stated. Perhaps the memoization technique used in Pibonacci (see second section below) can be used.\n\nIn any case, sometimes, we can give really fast algorithms by exploiting the problem (see the sqrt(2) & sqrt(3)) solution below.\n\nReducing such problems to knapsack might not be such a good idea as I expect there will be other ways which will be much faster.\n\nSo to answer your questions:\n\n\n\nProblem involving sqrt(2) and sqrt(3)\n\nI will answer your second question first.\n\n```\nf(x) = 1 for x < sqrt(2). (x >= 0 also, I presume)\nf(x) = f(x-sqrt(2)) + sqrt(3)\n```\n\n\nThis can be solved very fast (in O(log logn) time!), using only integer arithmetic (which is assumed O(1)), expect for one last step which requires multiplying by sqrt(3) and adding 1.\n\nGiven an n we need to find the smallest m such that\n\n```\nn - m sqrt(2) < sqrt(2)\n```\n\n\ni.e.\n\n```\nn - m sqrt(2) < sqrt(2) => n < (m+1)*sqrt(2) => n * sqrt(2) < m+1\n```\n\n\nand\n\n```\nn - (m-1)sqrt(2) > sqrt(2) => n > m sqrt(2) => n*sqrt(2) > m.\n```\n\n\nThus m is the integer part of ```\nn*sqrt(2)```\n\n\nand we have that f(n) = (m-1)*sqrt(3) + 1.\n\nThus we only need to calculate ```\n[n *sqrt(2)]```\n the integer part of ```\nn*sqrt(2)```\n.\n\nThis can be quickly calculated by using the Continued Fractions of sqrt(2) which are rational approximations to sqrt(2) and they are in some sense the 'best' approximations with given denominator sizes.\n\nThe continued fraction a(i)/b(i) of sqrt(2) can be formed using the recurrence:\n\n```\na0 = 1\nb0 = 1\na(i+1) = a(i) +2*b(i)\nb(i+1) = a(i) + b(i)\n```\n\n\nIt can be shown that in order to approximate [n*sqrt(2)] it is enough to consider some odd i for which b(i) > 10*n^2 (using Liouville's approximation Theorem and theorems on continued fractions) and that ```\n[n*sqrt(2)] = [n*a(i)/b(i)]```\n for that i.\n\nNow a(i), b(i) satisfies the matrix equation\n\n```\n[1 2] [a(i)]    [a(i+1)]\n[1 1] [b(i)]  = [b(i+1)]\n```\n\n\nThus we need to compute powers of the matrix\n\n```\n[1 2]\n[1 1]\n```\n\n\nSo that the entries get bigger than 10*n^2.\n\nIt can be shown that the required power of the matrix is O(logn) and thus can be calculated in O(log log n) time using only integer arithmetic (assuming that is O(1)).\n\nSo the value of your function f at n can be calculated in O(log logn) time using only integer arithmetic (except for the last step, where you need to multiply an integer by sqrt(3)).\n\n\n\nPibonacci Number\n\nFrom your comment, this is the problem\n\n```\ng(x) = 1 if 0 <= x < 4\ng(x) = g(x-1) + g(x-pi) x >= 4\n```\n\n\nThis can be solved using memoization:\n\nLet ```\nh(m,n) = g(m - n*pi)```\n\n\nThen we have that\n\n```\nh(m,n) = h(m-1, n) + h(m, n+1)\n```\n\n\nAnd so we have that\n\n```\ng(m) = g(m-1) + h(m, 1)\n```\n\n\nYou can now use memoization by maintaining two tables, one for g(m) and other for h(m,n). Note that even though you need to calculate ```\nh(m,n+1)```\n, increasing n only reduces m -n*pi and will become between 0 and 4 within a reasonable time (O(m) I suppose), thus you won't keep going on forever.\n\nThis is not as nice (or fast) as the sqrt(2) and sqrt(3) solution, but I believe it does give a way to do the calculation.\n\n\n\n0-1 Knapsack with irrational coefficients\n\nPerhaps taking better and better rational approximations to the irrationals and then solving the 0-1 knapsack problem for approximation will ultimately converge to the right solution.\n\nMy guess is, the fixed point in this iteration will give you the solution.\n\nOf course, as the approximations get better the W in O(nW) of they dynamic programming algorithm might become exponential soon and you might be better off just consider all possibilities.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "KnapSack Branch & Bound weird compiling errors\r\n                \r\nSo I am working on implementing the KnapSack problem, using the Branch and Bound algorithm. I have finished implementing it but I am getting some weird compiling errors which I have no idea how to fix:\n\nCOMPILING ERRORS\n\n```\ngcc -Wall -pedantic -g -std=c99   -c -o bnb.o bnb.c\nbnb.c: In function ‘branch_and_bound’:\nbnb.c:225: warning: cast from pointer to integer of different size\nbnb.c:229: warning: implicit declaration of function ‘copy_string’\nbnb.c:248: warning: cast from pointer to integer of different size\nbnb.c:251: error: ‘struc_sol’ has no member named ‘string’\nbnb.c:260: error: ‘struc_sol’ has no member named ‘string’\nbnb.c:260: warning: cast from pointer to integer of different size\nbnb.c:263: error: ‘struc_sol’ has no member named ‘string’\nmake: *** [bnb.o] Error 1\n```\n\n\nAny suggestions on what I am doing wrong?\n    ", "Answer": "\r\n\n  bnb.c:225: warning: cast from pointer to integer of different size\n\n\nThis is from the line:\n\n```\n     topNode->solution_vec[i] = (int)malloc(sizeof(int));\n```\n\n\nJust as the message mentioned, ```\nmalloc()```\n returns a pointer. You shouldn't cast it into an integer. Indeed, you don't need to allocate memory for ```\nsolution_vec[i]```\n at all since it's already allocated by the earlier allocation of ```\ntopNode```\n.\n\n\n\n\n  bnb.c:229: warning: implicit declaration of function ‘copy_string’\n\n\nCheck if ```\ncopy_string()```\n was declared in your header files.\n\n\n\n\n  bnb.c:251: error: ‘struc_sol’ has no member named ‘string’\n\n\nJust as it mentioned, ```\nstruc_sol```\n has no member called ```\nstring```\n and thus ```\nchild1Node->string```\n leads to syntax error.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Java Knapsack: NullPointerException\r\n                \r\nWhen my code is trying to solve/create the greatest Knapsack (greatest Knapsack maximizes the overall total value of the Knapsack with items in it and minimizes amount of weight), I am trying to get my genetic algorithm to stop running after ten generations if the best Knapsack passed to it is the same as before.\n\nThe knapsack labeled reference is a knapsack that contains all potential items that can be put into the later generation knapsacks. The knapsack labeled copy is a copy of the reference, but items will be removed from that copy Knapsack to avoid duplicates within the new generated Knapsack. The portions commented with // ... is code removed that I believe are not apart of the problem, but I labeled the instructions on what the code would do.\n\n```\nArrayList<Knapsack> knapsackPopulation = new ArrayList<Knapsack>();\n  // creates initial population to find Fittest to compare to later\n  // ...\n\n     Knapsack generated = new Knapsack();\n     boolean canRun = true;\n     int currentWeight = 0;\n     int itemsContained = 0;\n\n     // this is the process to find the best/fittest Knapsack, which will be used later to compare to\n     // ...\n\n  Knapsack bestKnapsack = knapsackPopulation.get(indexOfBest); // best Knapsack found\n\n  // Print out results, weight, and value of overall best Knapsack.\n\n  // ...\n\n  // Mutation portion of code, comparing it to the fittest Knapsack we found earlier \n  boolean hasNotChangedInTenGenerations = true;\n  int generationsUnchanged = 0; \n\n  while ((hasNotChangedInTenGenerations != false) && (generationsUnchanged < 10)) {   \n  for (int m=0; m<100; m++) {\n\n     Knapsack copy = new Knapsack(); \n     for (int j=0; j<reference.size(); j++) {\n        copy.add(reference.get(j));\n     }\n\n     Knapsack copyBest = new Knapsack();\n     for (int p=0; p<bestKnapsack.size(); p++) {\n        copyBest.add(bestKnapsack.get(p));\n     }\n\n     Knapsack generated = new Knapsack();\n     boolean canRun = true;\n     int currentWeight = 0;\n     int itemsContained = 0;\n\n     while (canRun && (currentWeight <= reference.getMaxWeight())) {\n        int randomNum = (int)(Math.random() * (((copy.size()-1) + 1)));\n        int randomNumBest = (int)(Math.random() * (((copyBest.size()-1) + 1)));\n        if (((currentWeight + copy.get(randomNum).getWeight()) < reference.getMaxWeight()) && ((currentWeight + copyBest.get(randomNumBest).getWeight()) < reference.getMaxWeight()) && (copy.get(randomNum) != null) && (copyBest.get(randomNumBest) != null)){\n\n           int randomTwoThirds = (int)(Math.random() * 3);\n\n           if (randomTwoThirds >= 2) { \n              currentWeight += copy.get(randomNum).getWeight();\n              generated.add(copy.get(randomNum));\n              copy.remove(randomNum);\n           } else {\n              currentWeight += copyBest.get(randomNumBest).getWeight();\n              generated.add(copyBest.get(randomNumBest));\n              copyBest.remove(randomNumBest);\n           }\n\n           itemsContained++;\n\n        } else {\n           canRun = false;\n        }\n     }\n     knapsackPopulation.add(generated);      \n  }\n  indexOfBest = 0;\n  valueOfBest = 0;\n  for(int k=0; k<knapsackPopulation.size(); k++) {\n     if (knapsackPopulation.get(k).getTotalValue() > valueOfBest){\n        indexOfBest = k;\n     }         \n  }\n  if (bestKnapsack.getTotalValue() == knapsackPopulation.get(indexOfBest).getTotalValue()) {\n     generationsUnchanged++;\n  } else if (bestKnapsack.getTotalValue() < knapsackPopulation.get(indexOfBest).getTotalValue()) {\n     bestKnapsack = knapsackPopulation.get(indexOfBest);\n  }\n\n  if(generationsUnchanged == 10){\n     hasNotChangedInTenGenerations = false;\n  }\n```\n\n\nSpecifically, the error is at this line, returning an IndexOutOfBoundsException: Index: 0, Size: 0.\n\n```\nif (((currentWeight + copy.get(randomNum).getWeight()) < reference.getMaxWeight()) && ((currentWeight + copyBest.get(randomNumBest).getWeight()) < reference.getMaxWeight()) && (copy.get(randomNum) != null) && (copyBest.get(randomNumBest) != null)) {\n// ...\n}\n```\n\n\nI am unsure on how there could be an out of bounds error exception/null pointer exception as for every time an item is added to the new generated knapsack, the Knapsack labeled copy removes the same item from itself in order to remove future duplicates.\n    ", "Answer": "\r\n```\nIndexOutOfBoundsException: Index: 0, Size: 0.```\n means you are trying to get the first element (index 0) from an empty list (size 0). \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "High-performance knapsack variant\r\n                \r\nI often (well, a few times a year) come across problems which are particular cases of a knapsack problem, like so:\n\n\n  Given a set S of integers and a number n of sacks, find the smallest integer N such that S can be partitioned into n sets S1, S2, ..., Sn such that the product of each is at most N.\n\n\n(Variants giving lower bounds, upper bounds, and estimates are also interesting, but exact values are the primary interest.)\n\nSo far each time this comes up I end up writing my own code, customized to the particular situation. But there is a lot known about the knapsack problem and similar (bin packing, etc.) and I'm sure there is existing code which could handle this type of problem better than what I'm doing. Alternately, there should at least be good algorithms for doing this efficiently which should scale better than what I cook up on the spur of the moment. Ideas?\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem - selecting best possible combination of items from 5 sets including 1 item from each set\r\n                \r\nI have 5 two dimensional arrays containing item value & item price, they look like this\n\n```\nA = [\n    [1, 1],\n    [2, 5],\n    [3, 7],\n    ...\n]\n...\n...\n\nE = [\n    [4, 15],\n    [12, 25],\n    [33, 57],\n    ...\n]\n```\n\n\nfirst column is item ```\nvalue```\n and second is ```\nprice```\n\n\nwhat I want to achieve is final set of 5 values in which each item will be from different starting array, so the final result should look like e.g. ```\n[A[1], B[15], C[46], D[3], E[0]]```\n, criteria for the elements selected are kinda standard for rucksack problem - best value of all items while keeping the sum of prices of selected elements (second column) under given treshold, e.g. 500\n\nhow could I approach it? I literally have no ideas how to do it in proper way, the main issue for me is that I have to pick one item from each set and maximize the output, or maybe there's better approach to this issue than knapsack solving? Only things I can think of currently are \n\n1) precompute all possible results for given params and cache them \n\n2) create price / performance ratio and order items by it and then find some way to find approximate best solution\n    ", "Answer": "\r\nYou can use dynamic programming to solve this problem.\nLet ```\ndp[i][j]```\n be the best value with ```\nj```\n price already used after picking an element from ith array.\n```\nfor (int i = 0; i <= 5; i++)\n  for (int j = 0; j <= 500; j++)\n    dp[i][j] = -1;\n\ndp[0][0] = 0;\n\nfor (int i = 1; i <= 5; i++) { // From array A to array E\n  for (int j = 0; j < size_of_ith_array; j++) {\n    for (int p = 0; p <= 500; p++) {\n      if (p >= price[i][j] && dp[i - 1][p - price[i][j]] != -1)\n        dp[i][p] = max(dp[i - 1][p - price[i][j]] + value[i][j], dp[i][p]);\n      if (p >= price[i][j] && dp[i][p - price[i][j] != -1)\n        dp[i][p] = max(dp[i][p - price[i][j]] + value[i][j], dp[i][p]);\n    }\n  }\n}\n\nans = max(dp[5][0 to 500])\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Variation on knapsack algorithm\r\n                \r\nI think this might be a variation of the multiple knapsack problem (or maybe even could be reduced to it) but I'm not sure. Here's the problem:\n\nYou have a set of items with known values and weights. You also have a set of knapsacks, and each knapsack can hold a fixed number of items (different knapsacks might be able to hold different numbers of items). Maximize total value of items in knapsacks while staying under a given weight.\n\nNote that the individual knapsacks don't have a weight restriction. Each knapsack only has a \"number of items it can contain\" restriction. The only other restriction is the total weight of the items.\n\nAny ideas?? (other than brute force of course). Thanks in advance! :)\n\nEDIT: one important restriction I forgot to include:\n\nItems can't necessarily be put into any bag. Essentially their value becomes zero if they are put into a bag they aren't compatible with. You can imagine a general case where each item has a value dependent on its bag, but for my case, its value will either be 0 or it's normal value, depending on the bag.\n    ", "Answer": "\r\nThis is called a transportation problem or some variants as bin packing problem.\nThere is good set of video lectures on youtube by G. Srinivasan on OR problems.\ncheck out LEC 13, 14, and 15\nhttp://www.youtube.com/watch?v=Q31jKiEXxdc - Lec 13\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "modified KnapSack runtime error\r\n                \r\nI am facing a problem in solving a program on codechef which is a modified version of knapsack problem ..\n1.here i have to find maximum cost for all possible weight..1<=n<=W\n2.i have solved it using standard DP algo...but each time i submit my code ..i get a runtime error...\nPlease have a look at my code ..\n\n```\n   #include<bits/stdc++.h>\n   using namespace std;\n   #define  ll long long\n   ll _max(ll a,ll b){return a>b?a:b;}\n   ll sol[200009];\n   void knapsack(ll W,ll val[],ll wt[],ll n,ll sol[])\n   {\n      ll i,w;\n      ll K[n+1][W+1];\n\n\n         for(ll i=0;i<=n;i++)\n         {\n              for(ll w=0;w<=W;w++)\n              {\n                if(i==0 || w==0)\n                K[i][w]=0;\n                else\n                {\n                   if(wt[i-1]<=w)\n                   K[i][w]=max(val[i-1]+K[i-1][w-wt[i-1]],K[i-1][w]);\n                   else\n                   K[i][w]=K[i-1][w];\n                }\n              }\n         }\n         for(int j=0;j<W;j++)\n         {\n             sol[j]=K[n][j+1];\n             printf(\"%lld \",sol[j]);\n         }\n\n    }\n\n    int main()\n    {\n        ll n;\n        scanf(\"%lld\",&n);\n        ll val[n];\n        ll wt[n];\n\n        ll sum =0;\n        for(ll i=0;i<n;i++)\n        {\n           scanf(\"%lld\",&wt[i]);\n           scanf(\"%lld\",&val[i]);\n           sum+=wt[i];\n        }\n\n        knapsack(sum, val, wt, n,sol);\n        return 0;\n    }\n```\n\n    ", "Answer": "\r\nOk i don't guarantee this will give you an AC \n\nYou overlooked the constraints while coding your solution \n\n```\n3 ≤ N ≤ 100000;\n\n1 ≤ W ≤ 2, for each item;\n\n1 ≤ C ≤ 109, for each item.\n```\n\n\nYour matrix\n\n```\nlong long  K[n+1][W+1];\n```\n\n\nwill not be allocated because the highest value of n is 100000 and \n\nW = sum = weight[i] * n which can be as high as 2*100000 \n\nwhich is equivalent to allocating  K[100000][200000] which will give Runtime error\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "List index out of range (Fractional Knapsack)\r\n                \r\nI'm attempting to implement a greedy algorithm for the fractional knapsack problem for a coursera assignment. The course insists on not giving the inputs that cause the problem. Below is my code of the solution and the code I used for stress testing.\n```\ndef optimal_value(capacity, weights, values):\n    value = 0.\n\n    while capacity > 0 and len(values) > 0:\n        maxval = 0\n\n        # I need values per weight\n        prices = [val / wei for val, wei in zip(values, weights)]\n\n        for i in range(len(prices)):\n            if prices[i] > maxval:\n                maxval = prices[i]\n                best_item = i\n\n        # put as much of the best item into the pack as we can and update the value\n        added = min(capacity, weights[best_item])\n        value += (added / weights[best_item]) * values[best_item]\n        capacity += -added\n\n        #print(f\"prices are {prices}, values are {values}, best item is {best_item}\")\n        #print(f\"value is {value}, added is {added}, capacity is {capacity}\")\n\n        if added == weights[best_item]:\n            # we used up the best option\n            values = [val for i, val in enumerate(values) if i != best_item]\n            weights = [weight for i, weight in enumerate(\n                weights) if i != best_item]\n\n    return value\n```\n\n```\nimport numpy as np\n\ndef create_knapsack_test_case():\n    capacity = np.random.randint(0, 2e6)\n    n = np.random.randint(1, 1000)\n    weights = np.random.randint(1, 2e6, n)\n    values = np.random.randint(0, 2e6, n)\n\n    return capacity, weights, values\n\nfor i in range(20000):\n    try:\n        inputs = create_knapsack_test_case()\n        opt = optimal_value(*inputs)\n    except:\n        print(f\"faulty inputs are {inputs}\")\n```\n\nI'm missing an edge case and have no idea what it could be. Please help.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "KnapSack algorithm in Java without recursion and without value\r\n                \r\nI have seen many solutions which solves the Knapsack problem in java using recursion; I'm trying to convert the solution into non-recursive function which probably uses \"Stack\" or any other optimal solution. I also don't have a value array and I just want to fit the weights into total weight capacity.\n\nFor e,g, I have weight input as 60,50, 40,10,30 and the W (capacity) is 180.\n\nSample KnapSack (with value array); but I don't need value array in my solution:\nI have seen many solutions which solves the Knapsack problem in java using recursion; I'm trying to convert the solution into non-recursive function which probably uses \"Stack\" or any other optimal solution. I also don't have a value array and I just want to fit the weights into total weight capacity.\n\nFor e,g, I have weight input as 60,50, 40,10,30 and the W (capacity) is 180.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm application\r\n                \r\nWhere else can we apply Knapsack problem apart from stealing gold and platinum bricks ? I tried to relate it with the stock market but some parameters didn't match like one for the weight. Even there is a time dimension  in stock market. Please let me know if there is any  real time application based on it.\n    ", "Answer": "\r\nIn any real-world problems where you have resources with certain values and you want to waste as little as possible. Shipping containers, to be packed as efficiently as possible (this is about money). To cut large pieces of materials into smaller packages (paper, metal, wood-logs). To optimize portfolios (which shares and how many should you buy). Storing goods in warehouses. There are quite some problems that generalise the knapsack problem, and the solving-algorithms are there to help.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python fractional knapsack\r\n                \r\nQuestion: \nThe goal of this code problem is to implement an algorithm for the fractional knapsack problem\n\nInput: \nThe first line of the input contains the number 𝑛 of items and the capacity 𝑊 of a knapsack.The next 𝑛 lines define the values and weights of the items. The 𝑖-th line contain integers 𝑣𝑖 and 𝑤𝑖 which is the value and the weight of 𝑖-th item, respectively.\n\nOutput:\nOutput the maximal value of fractions of items that fit into the knapsack. The absolute value of the difference between the answer of your program and the optimal value should be at most 0.001.\n\nBelow is my answer:\n\n```\nimport sys\n\ndef get_optimal_value(capacity, weights, values):\n\n    unit_value = [a/b for a,b in zip(values,weights)]\n    unit_value = sorted(unit_value, key=int, reverse=True)\n    m = len(unit_value)\n\n    if capacity == 0: return []\n    for i in range(0,m):\n        if weights[i] > capacity: return unit_value[i]*capacity\n        if weights[i] <= capacity: return values[i] + get_optimal_value(capacity-weights[i], weights, values)\n\nif __name__ == \"__main__\":\n    data = [int(x) for x in input(\"\").split()]\n    n, capacity = data[0:2]\n    values = data[2:(2 * n + 2):2]\n    weights = data[3:(2 * n + 2):2]\n    opt_value = get_optimal_value(capacity, weights, values)\n    print(\"{:.10f}\".format(opt_value))\n```\n\n\nHowever, when I run the case as \n\n```\nn = 3 , capacity = 50,\n1st item: 60 20\n2nd item: 100 50\n3rd item: 120 30\n```\n\n\nThe output is 160 not as 180 which is the correct answer.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How can I implement the knapsack algorithm where the index of the array represent the weight of the item\r\n                \r\nI am trying to implement an algorithm to solve the Knapsack problem:\n\n```\ncst = 1;\n\nfor (j = 0; j < 200; j++) {\n    if (kk - cst < 0) {\n        continue;\n        cst++;\n    }\n\n    for (i = kk - cst; i >= 0; --i) {\n        C[i + cst] = max(C[i + cst], C[i] + index[cst]);\n    }\n    cst++;\n}\n```\n\n\nThe ```\nindex```\n array has the values of respective items represented by index of the array. I want to know where I'm going wrong.\n    ", "Answer": "\r\nIn your code\n\n```\nif(kk-cst < 0)\n        {\n            continue;\n            cst++;\n        }\n```\n\n\nis wrong. the ```\ncst++```\n will never be executed. Please check and change your logic accordingly.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to get the list of selected items in naive 0-1 knapsack?\r\n                \r\nI have a code of the naive solution of the Knapsack problem, i want to get the list of of selected items, currently it is returning the total sum of values of the selected items. Any help will be appreciated. PYTHON CODE:\n```\n    def knapSack(W, wt, val, n):\n \n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n \n    # If weight of the nth item is\n    # more than Knapsack of capacity W,\n    # then this item cannot be included\n    # in the optimal solution\n    if (wt[n-1] > W):\n        return knapSack(W, wt, val, n-1)\n \n    # return the maximum of two cases:\n    # (1) nth item included\n    # (2) not included\n    else:\n        return max(\n            val[n-1] + knapSack(\n                W-wt[n-1], wt, val, n-1),\n            knapSack(W, wt, val, n-1))\n \n# end of function knapSack\n \n \n#Driver Code\nitems= [a, b, c, d, e]\nval = [60, 100, 120, 125, 129]\nwt = [10, 20, 30, 40, 50]\nW = 70\nn = len(val)\nprint knapSack(W, wt, val, n)\n```\n\n    ", "Answer": "\r\nSo the trick here is to return both the path of items selected ```\np```\n along with the value accrued ```\nv```\n by choosing that path.  Then you select the best path based on the maximum value ```\nv```\n.\n```\ndef knapSack(W, wt, val, n):\n \n    # Base Case\n    if n == 0 or W == 0:\n        return 0, []\n \n    # If weight of the nth item is\n    # more than Knapsack of capacity W,\n    # then this item cannot be included\n    # in the optimal solution\n    if (wt[n-1] > W):\n        return knapSack(W, wt, val, n-1)\n \n    # return the maximum of two cases:\n    # (1) nth item included\n    v1, p1 = knapSack(W-wt[n-1], wt, val, n-1)\n    v1 += val[n-1]\n    p1 = [items[n-1]] + p1\n    \n    # (2) not included\n    v2, p2 = knapSack(W, wt, val, n-1)\n    \n    return (v1, p1) if v1 >= v2 else (v2, p2)\n    \n            \nif __name__ == \"__main__\":\n    items = list('abcde')\n    val = [60, 100, 120, 125, 129]\n    wt = [10, 20, 30, 40, 50]\n    W = 70\n    n = len(val)\n    val, path = knapSack(W, wt, val, n)\n    print(val, path)\n```\n\nNote, there are a few additional measures you can use to speed up this code.  The most notable would be adding memoization, then would be converting it to a bottom-up dp solution.  Feel free to drop a comment if you would like to know more about how to apply these.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How can I implement the knapsack algorithm where the index of the array represent the weight of the item\r\n                \r\nI am trying to implement an algorithm to solve the Knapsack problem:\n\n```\ncst = 1;\n\nfor (j = 0; j < 200; j++) {\n    if (kk - cst < 0) {\n        continue;\n        cst++;\n    }\n\n    for (i = kk - cst; i >= 0; --i) {\n        C[i + cst] = max(C[i + cst], C[i] + index[cst]);\n    }\n    cst++;\n}\n```\n\n\nThe ```\nindex```\n array has the values of respective items represented by index of the array. I want to know where I'm going wrong.\n    ", "Answer": "\r\nIn your code\n\n```\nif(kk-cst < 0)\n        {\n            continue;\n            cst++;\n        }\n```\n\n\nis wrong. the ```\ncst++```\n will never be executed. Please check and change your logic accordingly.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to get the list of selected items in naive 0-1 knapsack?\r\n                \r\nI have a code of the naive solution of the Knapsack problem, i want to get the list of of selected items, currently it is returning the total sum of values of the selected items. Any help will be appreciated. PYTHON CODE:\n```\n    def knapSack(W, wt, val, n):\n \n    # Base Case\n    if n == 0 or W == 0:\n        return 0\n \n    # If weight of the nth item is\n    # more than Knapsack of capacity W,\n    # then this item cannot be included\n    # in the optimal solution\n    if (wt[n-1] > W):\n        return knapSack(W, wt, val, n-1)\n \n    # return the maximum of two cases:\n    # (1) nth item included\n    # (2) not included\n    else:\n        return max(\n            val[n-1] + knapSack(\n                W-wt[n-1], wt, val, n-1),\n            knapSack(W, wt, val, n-1))\n \n# end of function knapSack\n \n \n#Driver Code\nitems= [a, b, c, d, e]\nval = [60, 100, 120, 125, 129]\nwt = [10, 20, 30, 40, 50]\nW = 70\nn = len(val)\nprint knapSack(W, wt, val, n)\n```\n\n    ", "Answer": "\r\nSo the trick here is to return both the path of items selected ```\np```\n along with the value accrued ```\nv```\n by choosing that path.  Then you select the best path based on the maximum value ```\nv```\n.\n```\ndef knapSack(W, wt, val, n):\n \n    # Base Case\n    if n == 0 or W == 0:\n        return 0, []\n \n    # If weight of the nth item is\n    # more than Knapsack of capacity W,\n    # then this item cannot be included\n    # in the optimal solution\n    if (wt[n-1] > W):\n        return knapSack(W, wt, val, n-1)\n \n    # return the maximum of two cases:\n    # (1) nth item included\n    v1, p1 = knapSack(W-wt[n-1], wt, val, n-1)\n    v1 += val[n-1]\n    p1 = [items[n-1]] + p1\n    \n    # (2) not included\n    v2, p2 = knapSack(W, wt, val, n-1)\n    \n    return (v1, p1) if v1 >= v2 else (v2, p2)\n    \n            \nif __name__ == \"__main__\":\n    items = list('abcde')\n    val = [60, 100, 120, 125, 129]\n    wt = [10, 20, 30, 40, 50]\n    W = 70\n    n = len(val)\n    val, path = knapSack(W, wt, val, n)\n    print(val, path)\n```\n\nNote, there are a few additional measures you can use to speed up this code.  The most notable would be adding memoization, then would be converting it to a bottom-up dp solution.  Feel free to drop a comment if you would like to know more about how to apply these.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Algorithm Code\r\n                \r\nI am trying to code the algorithm for the knapsack problem in C++. I can't get this to work. I am getting max sum equals 0 for any input. I think the problem relies in the nested for-loop. Can someone point out what went wrong and how to fix the code ?. I would like to know also what you think about my implementation. Thanks for the help.\n\n```\n#include <iostream>\n#include <vector>\n#include <set>\n#include <utility>\nusing namespace std;\nusing knapsack_pair = pair<int,int>; // pair<value,weight>\nusing matrix_value_type = pair<int, set<knapsack_pair>>; // pair<max, set of elements>\n\nmatrix_value_type max(matrix_value_type first_value, matrix_value_type second_value){\n      if(first_value.first >= second_value.first)\n         return  first_value;\n      else return second_value;\n}\n\nint main(){\n    int number_of_values;\n    int knapsack_size;\n    cout << \"How many values are you going to enter?\" << endl;\n    cin >> number_of_values;\n    cout << \"what's the size of the knapsack?\" << endl;\n    cin >> knapsack_size;\n    int counter = 0;\n    vector<knapsack_pair> knapsack_vector;\n    while(counter < number_of_values){\n        knapsack_pair new_pair;\n        cout << \"insert the value of the element\" << endl;\n        cin >> new_pair.first;\n        cout << \"insert the weight of the element\" << endl;\n        cin >> new_pair.second;\n        knapsack_vector.push_back(new_pair);\n        ++counter;\n    }\n    matrix_value_type matrix[number_of_values + 1][knapsack_size + 1];\n    for(int i = 0; i < knapsack_size + 1; ++i){\n        set<knapsack_pair> empty_set;\n        matrix_value_type value(0,empty_set);\n        matrix[0][i] = value;\n    }\n\n    for(int x = 1; x < number_of_values + 1; ++x){\n        knapsack_pair current_pair = knapsack_vector.at(x-1);\n        for(int y = 0; y < knapsack_size + 1; ++y){\n            matrix_value_type first_value = matrix[x-1][y];\n            matrix_value_type second_value;\n            int weight_s_pair = y - current_pair.second;\n            if(weight_s_pair >= 0){\n               second_value = matrix[x-1][weight_s_pair];\n               second_value.first = second_value.first + current_pair.first;\n               second_value.second.insert(current_pair);\n            }\n            else second_value.first = -999;\n            matrix[x][y] = max(first_value,second_value);\n        }\n    }\n\n    matrix_value_type result = matrix[number_of_values][knapsack_size];\n    cout << \"the max value is: \" << result.first << endl;\n    cout << \"the elements in the knapsack are: \" << endl;\n    for(auto& it : result.second)\n        cout << \"element of value: \" << it.first << \" and weight: \" << it.second;\n}   \n```\n\n    ", "Answer": "\r\nI have a little problem following logic in your code. There has to be differentiated if you want to search only for the maximal value or if you want also to print the elements that build this maximal value. For just searching the optimal value I provide some  updated code. \n\n```\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nusing WeightValue = pair<int, int>;\nusing WeightValueList = vector<WeightValue>;\n\nint main() {\n\n  int knapsack_weight;\n  cout << \"what's the weight of the knapsack?\" << endl;\n  cin >> knapsack_weight;\n\n  int number_of_elements;\n  cout << \"How many elements are you going to enter?\" << endl;\n  cin >> number_of_elements;\n\n  WeightValueList elements(number_of_elements);\n\n  for (int i = 0; i < number_of_elements; ++i) {\n    int w,v;\n    cout << \"insert the weight of the element\" << endl;\n    cin >> w;\n    cout << \"insert the value of the element\" << endl;\n    cin >> v;\n    elements[i] = make_pair(w,v);\n  }\n\n  int mat[number_of_elements+1][knapsack_weight+1];\n\n  for (int i = 0; i <= number_of_elements; ++i)\n    for (int j = 0; j <=knapsack_weight; ++j)\n      mat[i][j] = 0;\n\n  for (int i = number_of_elements-1; i >=0; --i)\n    for (int j = 1; j <= knapsack_weight; ++j) {\n\n      int wi = elements[i].first;\n      int vi = elements[i].second;\n\n        if (wi <= j) {  // -> check if we can to better for weight j\n                          // by try choosing the i-th element\n          mat[i][j] = max(vi + mat[i+1][j-wi], mat[i+1][j]);\n        } else {          // if the weight of i is too big, then just \n                          //copy the previously found optimum\n          mat[i][j] = mat[i+1][j];\n        }\n    }\n\n  cout << \"The maximum value is : \" << mat[0][knapsack_weight] << endl;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why Capacity-1 in integer knapsack?\r\n                \r\nThe dynamic programming solution to the integer knapsack problem,\nFor a knapsack of capacity C, and for n items, where ith item has the size Si and value Vi, is:\n\nM(C)=max(M(C-1), M(C-Si)+Vi), where i goes from 1 to n\n\nHere M is an array. M(C) denotes the maximum value of a knapsack of capacity C.\n\nWhat is the use of M(C-1) in this relation? I mean the solution should just be this:\n\nM(C)=max(M(C-Si)+Vi), where i goes from 1 to n\n\nI think all the cases that M(C-1) covers are covered in M(C).\n\nIf I'm wrong, please give me an example situation.\n    ", "Answer": "\r\nI think you have to setup of the formula a bit confused - specifically, you've mixed up the capacity of the bag with a sub problem of n-1 items. Let's redefine a bit.\n\n\nLet ```\nP```\n denote the problem, as represented by a list of ```\nn```\n items.\nFurther, let ```\nPk```\n represent the subproblem consisting of items at indices ```\n1...k```\n from the original problem, where ```\n1 <= k <= n```\n. Thus ```\nPn```\n is equivalent to ```\nP```\n.\nFor each item at index ```\ni```\n, let ```\nVi```\n denote the value of that item and ```\nSi```\n denote the size of that item.\nLet ```\nC```\n be the capacity of the bag, ```\nC >= 0```\n\nLet ```\nM(Pk, C)```\n denote the optimal solution to the problem described by ```\nPk```\n with a bag of capacity ```\nC```\n. ```\nM(Pk, C)```\n returns the list of items included in the solution (and thus also returns the value of the optimal solution and the excess capacity in the bag).\n\n\nFor each item, we could either include it in the optimal solution, or not include it in the optimal solution. Clearly, the optimal solution is whichever of these two options is preferable. The only corner case to consider is if the item in question cannot fit in the bag. In this case we must exclude it.\n\nWe can rely on recursion to cover every item for us, thus have no need for iteration. Thus all together:\n\nM(Pk,C) = if(Sk > C) M(P(k-1), C) else max(M(P(k-1),C), Vk + M(P(k-1),C-Sk))\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with limit on total items used\r\n                \r\nSo, I have a knapsack where a number of items that can be placed into the knapsack has a limit, while the amount of weight of the items also has a limit. \n\nSo given item limit 5, and weight 100:\nWe would find the 5 items (can repeat 5x same item) that best fit weight 100.\n\nI have solved both unbounded and bounded(each item has a limit, but the total amount of items used has no limit) in dynamic programming. But I'm a bit confused with how to do this new approach. Would this be a multidimensional knapsack problem, like volume and weight? But instead, we want item's used and weight? Or is it a 0-1 knapsack with alterations?\n\nIf anyone able to break this down into smaller logical steps or point me in the direction of some solid code to read (my google-fu is struggling to find solutions) that would be greatly appreciated. \n\nThank you for your time!\n    ", "Answer": "\r\nThis is the multiply constrained knapsack problem. Your new constraint is that the sum of the number of items is less than some number unrelated to their weight.\n\nThere's some good approaches in here: http://www2.math.uni-wuppertal.de/~klamroth/publications/klwidp00.pdf\n\nYou should also try adapting the recurrence relation of the regular knapsack problems with your new constraint and see where you get.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving Knapsack Problem for large dataset using PULP library in Python\r\n                \r\nI have the below dataframe:\n```\nimport itertools\nimport pandas as pd\nimport numpy as np\n\np1_values = np.arange(19, 29.1, 0.1)\np2_values = np.arange(23, 33.1, 0.1)\np3_values = np.arange(36, 46.1, 0.1)\n\np1_values = np.arange(19, 29.1, 0.1)\np2_values = np.arange(23, 33.1, 0.1)\np3_values = np.arange(36, 46.1, 0.1)\n\ndf = pd.DataFrame(list(itertools.product(p1_values, p2_values, p3_values)), columns=['P1', 'P2', 'P3'])\ndf['P1_Rev'] = 150000 - ((150000-25000)/(29-19))*(df['P1']-19)\ndf['P2_Rev'] = 150000 - ((150000-25000)/(33-23))*(df['P2']-23)\ndf['P3_Rev'] = 150000 - ((150000-25000)/(46-36))*(df['P3']-36)\ndf['P1_GM'] = 50000 - ((50000-5000)/(29-19))*(df['P1']-19)\ndf['P2_GM'] = 50000 - ((50000-5000)/(33-23))*(df['P2']-23)\ndf['P3_GM'] = 50000 - ((50000-5000)/(46-36))*(df['P3']-36)\ndf['P1_RM'] = 50000 - ((50000-5000)/(29-19))*(df['P1']-19)\ndf['P2_RM'] = 50000 - ((50000-5000)/(33-23))*(df['P2']-23)\ndf['P3_RM'] = 50000 - ((50000-5000)/(46-36))*(df['P3']-36)\n\ndef p1_promo(x):\n    if x <= 20:\n        return \"HP\"\n    elif x <= 26:\n        return \"Deep\"\n    else:\n        return \"Base\"\n\ndef p2_promo(x):\n    if x <= 24:\n        return \"HP\"\n    elif x <= 28:\n        return \"Deep\"\n    else:\n        return \"Base\"\n\ndef p3_promo(x):\n    if x <= 36:\n        return \"HP\"\n    elif x <= 40:\n        return \"Deep\"\n    else:\n        return \"Base\"\n\ndf['P1_Promo'] = df['P1'].apply(p1_promo)\ndf['P2_Promo'] = df['P2'].apply(p2_promo)\ndf['P3_Promo'] = df['P3'].apply(p3_promo)\ndf['Total_GM']=df['P1_GM']+df['P2_GM']+df['P3_GM']\ndf['Total_RM']=df['P1_RM']+df['P2_RM']+df['P3_RM']\ndf['Total_Rev']=df['P1_Rev']+df['P2_Rev']+df['P3_Rev']\n```\n\nUsing the above dataframe I want to get a final dataframe with 52 rows where it meets the below criteria:\n\nThere should be at least 37 rows where P1_Promo = Base\nThere should be at least 5 rows where P1_Promo = HP\nThere should be at least 10 rows where P1_Promo = Deep\nThere should be at least 40 rows where P2_Promo = Base\nThere should be at least 5 rows where P2_Promo = HP\nThere should be at least 7 rows where P2_Promo = Deep\nThere should be at least 37 rows where P3_Promo = Base\nThere should be at least 7 rows where P3_Promo = HP\nThere should be at least 8 rows where P3_Promo = Deep\nThe Total of Total_GM should be maximum\nThe Total of Total_RM should be maximum\nThe Total of Total_Rev should be maximum\n\nI have tried solving this using LpProblem from PULP library in python. It does give me an optimal solution - but it takes a lot of time. I want to see if there are other methods that can solve this using Python (potentially for larger datasets like 10 mil rows). Appreciate your help.\n    ", "Answer": "\r\nI think a MIP model would need a binary variable for each row. That would mean a model with 10 million binary variables. This is large. However, the structure is simple, so it may be doable with a good MIP solver. It is very difficult to predict these things, so you just have to try it out.\nThere is one more conceptual issue.\n\nThe Total of Total_GM should be maximum\nThe Total of Total_RM should be maximum\nThe Total of Total_Rev should be maximum\n\nmeans you have a multi-objective problem. One way to make a normal optimization out of this, is to form a weighted sum and use that as single objective. That requires some thought about these weights.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python Knapsack with Constraint by Type\r\n                \r\nHere is a simple knapsack problem that I took from the MIT open Course where I took from here.  \n\nThe script optimizes for the weights and values, but I'd like it to optimize so there are no class repeats.  So for example if I had a cap of 10, it would return ```\nw[0] v[0] c[0] and w[2] v[2] c[2]```\n and NOT ```\nw[0] v[0] c[0] and w[1] v[1] c[1] and w[2] v[2] c[2]```\n\n\n```\nweight= [5,3,2]\nvalue = [9,7,8]\nthe_class = [\"A\",\"C\",\"C\"]\ncap = 5\n\n'''\nw = the weight of item\nv = the value of item\ni = index of the item\naW = availible weight left (cap - w[i])\nc = class of item\n'''\n\ndef maxVal(w, v, i, aW,c): \n    if i == 0: \n        if w[i] <= aW: \n            return v[i] \n        else: \n            return 0 \n    without_i = maxVal(w, v, i-1, aW, c) \n    if w[i] > aW: \n        return without_i \n    else: \n        with_i = v[i] + maxVal(w, v, i-1, aW - w[i], c) \n\n    return max(with_i, without_i)\n\nres = maxVal(weight,value, len(value)-1, cap, the_class)\nprint \"The result: \",res\n```\n\n    ", "Answer": "\r\nRemove the unwanted items from the list first.  \n\n```\nimport itertools as it\nfrom operator import itemgetter\nweight= [5,3,2]\nvalue = [9,7,8]\nthe_class = [\"A\",\"C\",\"C\"]\ncap = 5\n\n# define functions to sort with\nclassitem = itemgetter(0)\nvalueitem = itemgetter(1)\nweightitem = itemgetter(2)\n\n# combine the list elements to keep them together\nclasses = zip(the_class, value, weight)\nclasses.sort(key = classitem)\n\n# use itertools.groupby() to aggregate the classes\nfor k, g in it.groupby(classes, classitem):\n    things = list(g)\n    print k, len(things)\n    # remove the least valuable duplicates from the class list\n    if len(things) > 1:\n        things.sort(key = valueitem)\n        for thing in things[:-1]:\n            classes.remove(thing)\n\n# reconstruct the original lists, sans unwanted duplicates\nthe_class = map(classitem, classes)\nvalue = map(valueitem, classes)\nweight = map(weightitem, classes)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recursive solution for Knapsack in Java\r\n                \r\nHERE recursive solution is given for Knapsack problem, but I am not able to understand it. Why there is no check on W? Shall we not return if W (leftover weight) goes below 0? What is the point it going a step ahead in a particular recursive call is W is already less than 0 ?\n\n```\n// Returns the maximum value that can be put in a knapsack of capacity W\nint knapSack(int W, int wt[], int val[], int n)\n{\n   // Base Case\n   if (n == 0 || W == 0)\n       return 0;\n\n   // If weight of the nth item is more than Knapsack capacity W, then\n   // this item cannot be included in the optimal solution\n   if (wt[n-1] > W)\n       return knapSack(W, wt, val, n-1);\n\n   // Return the maximum of two cases: (1) nth item included (2) not included\n   else return max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\n                    knapSack(W, wt, val, n-1)\n                  );\n}\n```\n\n    ", "Answer": "\r\nNotice that in every recursive call value of ```\nW```\n is also getting updated. And we subtract a new weight from leftover weight ```\nW```\n only if it is less than ```\nW```\n. Otherwise that weight can not be included. This logic is captured here\n\n```\nif (wt[n-1] > W)\n       return knapSack(W, wt, val, n-1);\n```\n\n\nAs you can see above, if new weight is more than leftover we do not include it by reducing value of ```\nn```\n by ```\n1```\n. Had it been lesser than W, we would have returned Max of Knapsack including and not including it.\n\n```\nreturn max( val[n-1] + knapSack(W-wt[n-1], wt, val, n-1),\n                    knapSack(W, wt, val, n-1)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Why swap the item order of the knapsack lead to the same solution?\r\n                \r\nAs far as I know, knapsack problem uses dynamic programming to find the best solution of each item depending on its previous items. This hypothesis assumes that the solution is depending on the order of items. Why the final solution is not depend on the order?\n    ", "Answer": "\r\nNo. The dynamic programming solution for knapsack problem does not depend on the previous items.\n\nWhen considering whether to put an item into the knapsack or not, we just need to consider the remaining capacity of the knapsack before and after selecting the item. So we loop through all the possible remaining capacity and choose the best one.\n\n```\ndp[i][c] = max(dp[i-1][c+w[i]] + v[i], dp[i-1][c])\n```\n\n\nwhere dp[i][c] indicates the maximum possible value after considering the i-th item with the remaining capacity of the knapsack equals to c. w[i] indicates the weight(or volume) of the i-th item, and v[i] indicates the value of the i-th item.\n\nIt's not necessary to consider the items in order. Considering the items in order is just for convenience. You can also consider selecting the items in a reversed order, or in a random order.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Streaming Knapsack in Java\r\n                \r\nI want to implement efficiently \"streaming Knapsack\" problem in java.\n\nThe problem is I have a stream input of integer data coming continuously for example -1, 2, 9, 5, 5, 11, 1 -3,... \n\nThe question is to find the first \"k\" elements in which their sum is \"n>0\". for example k=3 and n=12, then the solution is: ...,2,...,5, 5.\n\nWhat is the efficient algorithm for it?\n    ", "Answer": "\r\nKeep a reverse ordered PriorityQueue of the ```\nk-1```\n highest value integers you have met so far. Each time a new integer is entered checked if the sum of it and those k-1 numbers is more than n. If it is - return the set you've found. Otherwise check if this number is greater than the smallest of the ```\nk-1```\n numbers(that is why you need the priority queue to be reverse ordered). If it is, extract the minimum element and push the new element into the queue. If it is not simply go to the next number in the stream.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Algo for payment device amount suggestion for cash payment\r\n                \r\nI have done knapsack problems, etc but I am not sure if this problem somehow falls in that area and regardless of that, how to solve it. Here is the question:\n\n```\nSuppose we are given a set of denominations {1, 2, 10, 20, 50, 100}. A customer is checking out and is paying in cash. How we suggest the top 6 or top x choices on our own payment screen based on what amount the customer may have handed over. For example if customer has to pay 87$, customer might hand over 5 bills of 100, or 4 bills of 20 and a 5 and a 2, etc```\n I am not able to come up with an algo, though I keep getting the feeling it is around knapsack problem but with multiple answers for a given value?\n    ", "Answer": "\r\nOne important thing to mention is that you should get more specific requirements. It is really important to sit with client, prepare examples and ask them questions: \"I have to pay 87, I give you 87x$1, is it good or not and why\". From more obvious you get to: \"whats better 50x2 or 50+20+20 and why\". To create algorithm of anything, you first need to be able to say how would you proceed as a human (with unlimited time and lot of patience) and then you can implement it.\n\nOne quite straightforward metric here is that you want value as close as possible to real amount and also you dont want to pay with too much bills, right?\n\nSo we have to find all the solutions, then count score (less bills and more close to target value the better), sort by the score and take 'x' of best ones.\n\nYou can upgrade the \"score\" function with i.e. \"10 and 20\" bills are preferred so they give you better score using them. Or the lower amount of bills is more important than the difference between target value and sum of your bills, so you penalize the bills more (like each $10 difference has same penalization as 1 bill more)\n\nThis is working javascript code based on backtracking.\n\n\r\n\r\n```\n// const countables = [100, 50, 20, 10, 2, 1];\r\n// const targetAmount = 87;\r\n\r\nconst countables = [5, 2, 1];\r\nconst targetAmount = 13;\r\n\r\n\r\nconst payments = [];\r\nconst solutions = [];\r\nlet index = 0;\r\n\r\nlet end = false;\r\nlet i = 0;\r\n\r\nwhile (end === false) {\r\n    const sum = payments.reduce((prev, val) => prev + val, 0);\r\n    if (sum >= targetAmount) {\r\n        solutions.push({\r\n            sum,\r\n            score: countTheScore(payments, targetAmount, sum),\r\n            payments: [...payments],\r\n        })\r\n        index++;\r\n        if (index === countables.length) {\r\n            let popped = null;\r\n            do {\r\n                popped = payments.pop();\r\n            } while (popped === countables[countables.length - 1]);\r\n            if (payments.length === 0) {\r\n                end = true;\r\n            }\r\n            const indexOfLastNonLowest = countables.indexOf(popped);\r\n            index = indexOfLastNonLowest + 1;\r\n        } else {\r\n            payments.pop();\r\n        }\r\n    } else {\r\n        payments.push(countables[index]);\r\n    }\r\n}\r\n\r\n\r\nfunction countTheScore(payments, targetAmount, sum) {\r\n    amount = payments.length;\r\n    difference = sum - targetAmount;\r\n    return amount + difference;\r\n}\r\n\r\nconsole.log(solutions.sort((a, b) => a.score - b.score));\r\n// const sortedSolutions = solutions.sort((a, b) => a.score - b.score);\r\n// const bestSolutions = [];\r\n// for (var j=0; j < 5; j++) {\r\n//     bestSolutions.push(sortedSolutions[j]);\r\n// }\r\n// console.log(bestSolutions);```\n\r\n\r\n\r\n\n\nIt has this output of all solutions sorted from best to worst:\n\n```\n[ { sum: 13, score: 4, payments: [ 5, 5, 2, 1 ] },\n  { sum: 15, score: 5, payments: [ 5, 5, 5 ] },\n  { sum: 14, score: 5, payments: [ 5, 5, 2, 2 ] },\n  { sum: 13, score: 5, payments: [ 5, 5, 1, 1, 1 ] },\n  { sum: 13, score: 5, payments: [ 5, 2, 2, 2, 2 ] },\n  { sum: 13, score: 6, payments: [ 5, 2, 2, 2, 1, 1 ] },\n  { sum: 13, score: 7, payments: [ 5, 2, 2, 1, 1, 1, 1 ] },\n  { sum: 13, score: 8, payments: [ 5, 2, 1, 1, 1, 1, 1, 1 ] },\n  { sum: 13, score: 9, payments: [ 5, 1, 1, 1, 1, 1, 1, 1, 1 ] } ]\n```\n\n\n(lower the score the better)\n\nFor your original requirements, this would be the output of best 5:\n\n```\n[ { sum: 90, score: 6, payments: [ 50, 20, 20 ] },\n  { sum: 90, score: 7, payments: [ 50, 20, 10, 10 ] },\n  { sum: 87, score: 7, payments: [ 50, 20, 10, 2, 2, 2, 1 ] },\n  { sum: 87, score: 8, payments: [ 50, 10, 10, 10, 2, 2, 2, 1 ] },\n  { sum: 90, score: 8, payments: [ 50, 10, 10, 10, 10 ] } ]\n```\n\n\n\n\nbtw: If I change the score function to\n\n```\nfunction countTheScore(payments, targetAmount, sum) {\n    amount = payments.length*3;\n    difference = sum - targetAmount;\n    return amount + difference;\n}\n```\n\n\nThen the output would be probably more accurate to what you need\n\n```\n[ { sum: 90, score: 12, payments: [ 50, 20, 20 ] },\n  { sum: 90, score: 15, payments: [ 50, 20, 10, 10 ] },\n  { sum: 100, score: 16, payments: [ 100 ] },\n  { sum: 90, score: 18, payments: [ 50, 10, 10, 10, 10 ] },\n  { sum: 100, score: 19, payments: [ 50, 50 ] } ]\n```\n\n\nYou can play a little more with these metrics and finding out what has the best output for you.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "1/0 Knapsack Variation with Weighted Edges\r\n                \r\nI'm currently investigating a routing problem (finding a subset of places [each with a certain score] I want to visit while not exceeding a maximum travel time) and came up with a variation of the 1/0 knapsack problem that seems to solve my original problem.  \n\nAccording to Wikipedia the 1/0 knapsack is described as:\n\n\n  Given a set of items, each with a mass and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.\n\n\nSo for each item there is a fixed weight (mass) that can easily be used when trying to solve the problem, for instance using Dynamic Programming. \n\nBut what if the weight of a specific item is dependent on the previous content of the bag? In other words (and in a more general way): Let's consider the following complete graph: \n\n\n\nEach node (A,B,C,D,E) represents an item I might want to put into my knapsack. Let's assume each node also has a certain value assigned to it (left out in the graph). I still want to have an optimal knapsack, thus a subset of the nodes with the maximum scores, but this time the weight (or costs of adding a specific node to my current knapsack) is not assigned to the node itself but rather to the edge leading to it. \n\nThis means that the costs of adding a node depend on the previous content of the knapsack (for example by using the edge with the lowest cost from any of the already included nodes). For instance, if my current knapsack consisted of {A,C} the costs of adding B were 2 (taking either A->B or C->B). If my current knapsack consisted of {D,E} the costs of adding B were 3 instead. \n\nUnfortunately I can't really come up with a good algorithm to solve this problem. \nThe classical knapsack DP approach doesn't really work here because you can easily construct cases where it does not return the optimal solution. For example if you start building your knapsack with the \"wrong\" nodes the costs to add a very good node (which should be included in an optimal solution but is tried very late) might exceed the capacity. \n\nAm I taking a completely wrong approach to the problem? Do you think there is a better algorithm to tackle this problem? \n    ", "Answer": "\r\nFirst of all, this problem is NP-hard. Here is a reduction from the shortest hamiltonian path in a weighted complete graph to this one. Given a graph, we can assign values of all nodes to 1 and then run binary search over the answer. If there was a polynomial solution for this problem, it could tell if there is a path that contains all vertices and is not longer than a given value. Thus, we would be able to solve the shortest hamiltonian path problem in polynomial time. In practice it means that no one knows an efficient correct polynomial solution to your problem.\n\nNow there are two ways to go:\n\n\nIf the number of vertices is rather small(around 20), you can use dynamic programming to get an exact solution. The state is ```\n(mask, last_vertex)```\n. The value is the shortest possible time we need to visit all vertices in the ```\nmask```\n and stop in the ```\nlast_vertex```\n. The time complexity of this solution is ```\nO(2^n * n^2)```\n.\nIf the number of vertices is much bigger, you can find an approximate solution. There are a lot ways to do it: heuristics, different greedy algorithms, random sampling with local optimizations and so on.\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How to apply knapsack method in this algorithmic puzzle?\r\n                \r\nSuppose you have got a list of items along with their ```\nWeights[]```\n and ```\nPrice[]```\n.\nNow given two integers ```\nN<=100```\n and ```\nK<=100```\n you have to find the minimum amount of money you should spend such that total weight of the items you have bought is exactly equal to K and number of items do not exceed N and if it is not possible to satisfy given conditions just print a ```\nIMPOSSIBLE```\n.\nYou can buy each item as many times you want.\n\nPlease tell me how to apply knapsack in this problem and if it is not a knapsack problem then how to solve it?\n    ", "Answer": "\r\n```\ndp[i] = minimum money you have to pay to get weight i\n\ndp[_] = infinity\n\nfor i = 1 to N do\n  for j = item[i].weight to MaxWeight do\n    dp[j] = min(dp[j], dp[j - item[i].weight] + item[i].price)\n```\n\n\nIf ```\ndp[K] != infinity```\n, that is your solution, otherwise there is no solution. The practical efficiency depends on how you compute ```\nMaxWeight```\n: either sum all of the item weights, or try to be smarter about it.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm with special objects\r\n                \r\nI need to create algorithm for extended Knapsack problem, where we have special items with normal items and I can pack only several special items.\n\nSo, we have N items and we know weight/value/isSpecial of each one. Also we have defined S, which is maximum number of special items.\n\nAny idea?\n    ", "Answer": "\r\nThe problem can be modeled as a non-geometric knapsack problem where each item has two weights (namely the actual weight and a second weight which is ```\n1```\n if and only if it is special); the first weight capacity is the knapsack capacity and the second weight capacity is the desired maximum number of special items. According to this Wikipedia article, the problem is known to be ```\nNP```\n-complete and does not admit an FPTAS unless ```\nP=NP```\n, but admits an FPTAS. Apparently the two-dimensional version also admits a dynamic programming algorithm similar to the one-dimensional version. The semantics of the state space would be as follows, where each item has two weights ```\nw1[i]```\n and ```\nw2[i]```\n and profit ```\np[i]```\n and where ```\nC1```\n and ```\nC2```\n are the respective capacities.\n```\nP[i,j,k] := maximum profit attainable for items in {1,...,i} with weight\n            in the first component at most j and weight in the second\n            component at most k\n            \n            for any i in {1,...,N}\n                    j in {1,...,C1}\n                    k in {1,...,C2}\n```\n\nThe recurrence relation would be as follows.\n```\nP[i,j,k] = max{ P[i-1,j-w1[i],k-w2[k]] + p[i], // item i occurs\n                P[i-1,j,k]                     // item i does not occur\n              }\n```\n\nIn an actual implementation, some index checking would be necessary to determine whether the first case can actuallty occur.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Minimization of the Knapsack 01 using dynamic programming\r\n                \r\nI'd like to know if it is possible to use the knapsack 01 problem to solve a minimization problem. It is possible?\nThis is the maximization version of the knapsack 01.\n```\nKNAPSACK01(values, weights, W)\n    n = values.length\n    Let V[0...n, 0...W] be a new table\n    for i = 0 to n\n        V[i, 0] = 0\n    for w = 0 to W\n        V[0, w] = 0\n    for i = 1 to n\n        for w = 1 to W\n            if weights[i] > w\n                V[i, w] = V[i - 1, w]\n            else \n                if V[i - 1, w - weights[i]] + values[i] > V[i - 1, w]\n                    V[i, w] = V[i - 1, w - weights[i]] + values[i]\n                else\n                    V[i, w] = V[i - 1, w]\n    return V[n, W]\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Program Aborts when it runs, 0-1 Knapsack\r\n                \r\nThe following is a C++ program that using a dynamic programming algorithm to solve the 0-1 Knapsack problem. Keep is a 2D array that holds whether the item was included in the maximum answer or not (using 1 and zero). The program compiles but gives the following error when running: \nterminate called after throwing an instance of 'std::length_error'\nwhat():  basic_string::_S_create\nAbort\n\nHere is my code:\n\n```\n#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <vector>\nusing namespace std;      \n\nstatic ifstream fr;\nstatic vector<int> stolen_Profit;\nstatic vector<int> stolen_Weight;\nstatic vector<string> stolen_Name;\n\n   /**class for item object*/\n   class Item\n    {\npublic:\n    /**constructor that will get information from the file*/\n    Item()\n    {\n        fr>>name>>p>>w;\n        r=p/w;\n    }\n\n    /**@return the name of the item object*/\n    string getName()\n    {return name;}\n\n    /**@return the weight of the item object*/\n    int getWeight()\n    {return w;}\n\n    /**@return the weight of the item object*/\n    int getProfit()\n    {return p;}\n\n    /**@return the weight of the item object*/\n    double getRatio()\n    {return r;}\n\nprivate:\n    string name;\n    double r;\n    int w, p;\n};\n\nint max(int a, int b)\n{\n    int max=a;\n    if (b>a)\n    {max=b;}\n    return max;\n}\n\nvoid finditems(int remainingweight, int item, int **Keep, int Weight[], int     Profit[], string Name[])\n{   \n    if (item!=0)\n    {\n        if(Keep[item][remainingweight]==1)\n        {\n            stolen_Weight.push_back(Weight[item]);\n            stolen_Profit.push_back(Profit[item]);\n            stolen_Name.push_back(Name[item]);\n            remainingweight=remainingweight-Weight[item];\n            item=item-1;\n            finditems(remainingweight,item, Keep, Weight, Profit, Name);\n\n            //add the item to stolen\n\n        } \n\n        if(Keep[item][remainingweight]==0)\n        {\n            item=item-1;\n            finditems(remainingweight,item, Keep, Weight, Profit, Name);\n        }\n    }\n    else return;\n}\n\nvoid knapsack(int n, int W, int Weight[], int Profit[], string Name[], int *P[], int *Keep[])\n{\n    //set all values in the 0 row to 0\n    for(int i=0; i<=W; i++)\n    {\n        P[0][i]=0;\n        Keep[0][i]=0;\n    }\n\n    for(int i=0; i<=n; i++)\n    {\n        //set all values in the 0 weight column to 0\n        P[i][0]=0;\n        Keep[i][0]=0;\n\n    for (int j=1; j<=W; j++)\n    {\n        if (Weight[i]<=j)\n        {\n            P[i][j]= max(P[i-1][j], Profit[i] + P[i-1][j-Weight[i]]);\n            if (P[i][j]==P[i-1][j])\n            {Keep[i][j]=0;}\n            else \n            Keep[i][j]=1;\n        }\n        else \n        P[i][j]=P[i-1][j];\n        Keep[i][j]=0;\n    }\n}\n\nfinditems(W, n, Keep, Weight, Profit, Name);\n\nint totalweight=0;\n/**print out information to output file*/\nofstream fw;\nfw.open(\"outputp1.txt\");\n//# of items in solution\ncout<<stolen_Name.size()<<endl;\n//total weight\nfor(int i=0; i<stolen_Weight.size(); i++)\n{\n    totalweight=totalweight+stolen_Weight[i];\n}\ncout<<totalweight<<endl;\n\n//total profit\ncout<<P[n][W]<<endl;\n//print out the information of each item\nfor(int i=0; i<stolen_Name.size(); i++)\n{cout<< stolen_Name[i]<<\" \"<< stolen_Profit[i] << \" \"<< stolen_Weight[i]<<endl;}\n\nfw.close();\n\n}\n\nint main()\n{\n    int n, W;\n    fr.open(\"inputp1.txt\");\n    fr>>n>>W; \n\n/**create an array of Items objects based on n*/\nItem tosteal[n];\n\nint *Profit=new int[n+1];\nint *Weight=new int[n+1];\nstring *Name=new string[n+1];\nfor (int i=0; i<=n; i++)\n{\n    if (i==0)\n    {\n        Profit[i]=0;\n        Weight[i]=0;\n        Name[i]=\"\";\n    }\n    else\n    Profit[i]= tosteal[i-1].getProfit();\n    Weight[i]= tosteal[i-1].getWeight();\n    Name[i]= tosteal[i-1].getName();\n}\n\nint **P= new int *[n+1];\nint **Keep= new int *[n+1];\nfor (int i=0; i<=n; i++ )\n{\n    P[i]=new int [W];\n    Keep[i]=new int [W];\n}\n\nfr.close();\nknapsack(n, W, Weight, Profit, Name, P, Keep);\n\ncout <<\"Solution to 0-1 Knapsack Problem written to file.\"<<endl;\n\n//garbage collection\nfor (int i=0; i<=n;i++)\n{\n    delete P[i];\n    delete Keep[i];\n}   \ndelete P;\ndelete Keep;\ndelete Weight;\ndelete Profit;\ndelete Name;\n//delete stolen_Name;\n//delete stolen_Profit;\n//delete stolen_Weight;\n}\n```\n\n    ", "Answer": "\r\n\nMake sure that variable ```\nn```\n is a number that you expect (try ```\ncout << \"n = \" << n << \" W = \" << W << '\\n';```\n to debug)\nLooks like you probably want that else statement in its own block\nYour best bet is to run your code in a debugger. Are you using Linux? If so run the command with ```\ngdb [your-command]```\n, then type ```\nrun```\n, then when it crashes type ```\nwhere```\n to get the stack trace. It should tell you what line is causing the crash.\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm: strange behavior with pown() on the gpu\r\n                \r\nThe version on the CPU OCL produces right results, where the GPU OCL in some places gives slightly different results in some places that after all influence the correctness of the result. I have debugged on Intel OCL SDK where I get right results. I haven't spotted any race condition or concurrent access to the memory. This problem has appeared after I have introduced in the kernel (one line of code) pown function.\n\n```\nvoid kernel knapsack(global int *input_f, global int *output_f, global uint *m_d,  int cmax, int weightk, int pk, int maxelem, int i){\n\nint c = get_global_id(0)+cmax;\n\nif(get_global_id(0)<maxelem){\n    if(input_f[c] < input_f[c - weightk] + pk){\n        output_f[c] = input_f[c - weightk] + pk;\n        m_d[c-1] = pown(2.0,i); *//previous version: m_d[c-1] = 1;*\n    } \n    else{\n    output_f[c] = input_f[c];\n\n    }   \n }\n}\n```\n\n\nThe purpose of pown is to compress the m_d buffer which holds the outcomes. \n\n```\nFor example \n1 0 1 0    2^0+2^2, 2^1, 2^0, 2^1  \n0 1 0 1 =>\n1 0 0 0\n```\n\n\nOn the gpu I get something like this:\n\n```\n    2^0+2^2, 2^1, 2^0+2^2, 2^1  in the \n    3rd column I access to pown one more again, when I'm not supposed to. \n```\n\n\nThis gives me that \"slight\" different result.\n    Here you can find full code\n\nThis work is based on this article:\n\n\nSolving knapsack problems on GPU by V. Boyera, D. El Baza,  M. Elkihel\nrelated work: Accelerating the knapsack problem on GPUs by Bharath Suri\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with 2 constraits\r\n                \r\nGiven problem:\n\n0/1-Knapsack problem, n items each having weight w_i and value v_i. Find the maximum total value of items whose weights sum up to weight W.\n\nBut there are two constraits:\n\n\nThe total weight of all items in the knapsack need to be exactly W. \nThe total amount of items must be even.\n\n\nI want to find an algorithm that pays attention to both constraits. I already found out how I can pay attention to one of them at one time.\n\nHere is my implementation which pays attention to constrait 1 (exact weight W):\n\n```\npublic class KnapSackExactWeight {\n    public static void main(String[] args) {\n        int[] w = new int[] {4, 1, 5, 8, 3, 9, 2};  //weights\n        int[] v = new int[] {2, 12, 8, 9, 3, 4, 3}; //values\n\n        int n = w.length;\n        int W = 10; // W (max weight)\n\n        int[][] DP = new int[n+1][W+1];\n\n        for(int i = 1; i < n+1; i++) {\n            for(int j = 0; j < W+1; j++) {\n                if(i == 0 || j == 0) {\n                    DP[i][j] = 0;\n                } else if (j - w[i-1] >= 0) {\n                    DP[i][j] = Math.max(DP[i-1][j], DP[i-1][j - w[i-1]] + v[i-1]);\n                } else {\n                    DP[i][j] = -Integer.MAX_VALUE;\n                }\n            }\n        }\n        System.out.println(\"Result: \" + DP[n][W]);\n    }\n}\n\nResult: 22\n```\n\n\nAnd here is my implementation which takes constrait 2 into account (even amount of items):\n\n```\npublic class KnapSackEvenAmount {\n    public static void main(String[] args) {\n        int[] weights = new int[] {4, 1, 5, 8, 3, 9, 2};    //weights\n        int[] values = new int[] {2, 12, 8, 9, 3, 4, 3};    //values\n\n        int n = weights.length;\n        int W = 10;\n\n        int[][] DP_odd = new int[n+1][W+1];\n        int[][] DP_even = new int[n+1][W+1];\n\n        for(int i = 0; i < n+1; i++) {\n            for(int j = 0; j < W+1; j++) {\n                DP_even[i][j] = -1;\n                DP_odd[i][j] = -1;\n                if(i == 0 || j == 0) {\n                    DP_odd[i][j] = -1;\n                    DP_even[i][j] = 0;\n                } else if(j - weights[i-1] >= 0) {\n                    if(DP_odd[i-1][j - weights[i-1]] >= 0) {\n                        DP_even[i][j] = Math.max(DP_even[i-1][j], DP_odd[i-1][j - weights[i-1]] + values[i-1]);\n                    }\n                    if(DP_even[i-1][j - weights[i-1]] >= 0) {\n                        DP_odd[i][j] = Math.max(DP_odd[i-1][j], DP_even[i-1][j - weights[i-1]] + values[i-1]);\n                    }\n                }\n                if(i > 0) {\n                    DP_odd[i][j] = Math.max(DP_odd[i][j], DP_odd[i-1][j]);\n                    DP_even[i][j] = Math.max(DP_even[i][j], DP_even[i-1][j]);\n                }\n            }\n        }\n        System.out.println(\"Result: \" + DP_even[n][W]);\n    }\n}\n\nResult: 21\n```\n\n\nThe idea for that: I use two DP tables (DP_even and DP_odd) and save the best solution for a knapsack with odd amount of items in DP_odd and for one with an even amount of items in DP_even.\n\nNow my Problem is how to implement that both constraits work together. Is there a way to solve this?\n\n(If anything is unclear in my question, just ask!)\n    ", "Answer": "\r\nNot sure if it's the best way to do this problem but what I've done here is to initially reduce the problem to fit the constraints. First find the possible even number of items that weigh equal to the knapsack weight and then find the combination with highest value\n\n```\nimport java.util.Scanner;\nimport static java.lang.Math.pow;\n\npublic class subSet{\n\nvoid subset(int num,int n, int x[])\n{\n    int i;\n    for(i=1;i<=n;i++)\n        x[i]=0;\n    for(i=n;num!=0;i--)\n    {\n        x[i]=num%2;\n        num=num/2;\n    }\n}\npublic static void main(String[] args) {\n    int n,d,sum,present=0;\n    int j;\n    System.out.println(\"enter the number of items\");\n    Scanner sc=new Scanner(System.in);\n    n=sc.nextInt();\n    int a[]=new int[n+1];\n    int x[]=new int[n+1];\n    System.out.println(\"enter the weights of items\");\n    for(int i=1;i<=n;i++)\n        a[i]=sc.nextInt();\n    System.out.println(\"enter the values of items\");\n    int v[]=new int[n+1];\n    for(int i=1;i<=n;i++)\n        v[i]=sc.nextInt();\n    System.out.println(\"enter the max weight\");\n    d=sc.nextInt();\n\n    int sol=0;int max=0;\n    if(d>0)\n    {\n        for(int i=1;i<=Math.pow(2,n)-1;i++)\n        {\n            subSet s=new subSet();\n            s.subset(i,n,x);\n            sum=0;int count=0;\n            for(j=1;j<=n;j++)\n                if(x[j]==1)\n                {\n                    sum=sum+a[j];\n                    count++;\n                }\n            sol=0;\n            if(d==sum && count%2==0)\n            {\n                present=1;\n                for(j=1;j<=n;j++)\n                {\n                    if(x[j]==1)\n                        sol=v[j]+sol;\n                    if(sol>max)\n                        max=sol;\n                }\n            }\n\n        }\n\n    }\n    if(present==0)\n        System.out.println(\"Solution does not exists\");\n    else\n        System.out.print(\"solution = \"+max);\n\n}\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Fractional knapsack using JavaScript\r\n                \r\nIm trying to convert my teacher's implementation of psuedo code for a greedy implementation of the classic knapsack problem in which, given a bag that can old said max_weight. Choose the items you want and the weight of the items for your knapsack so that you maximize your benefit. \n The Psuedo Code Given\n\n```\ninitialize(S)\n    if S is empty then return\n    i <-- any element of S\n    Xi <-- 0\n    Vi <-- bi/wi\n    initialize (S-{i})\n\ngrab(S)\n   if w >= W or S is empty then return \n   i <-- item in S w/ highest value \n   ... update Xi, update w....\n   grab(S-{i})\n```\n\n\nWhat I Got Up To\n\n```\n// Test Items, [weight, benefit]\nvar test_input = [\n    [4, 12],\n    [8, 32],\n    [2, 40],\n    [6, 30],\n    [1, 50]\n];\n\n// Output, [weight of item at index];\nvar test_output = [0, 1, 2, 6, 1];\n\nvar fractionalKnapsack = function(knapsack, max_weight) {\n    var amt_to_take = [];\n    var value = [];\n    var curr_weight = 0;\n\n    (function initialize(i) {\n        if (i >= knapsack.length) return;\n\n        amt_to_take[i] = 0;\n        var weight = knapsack[i][0];\n        var benefit = knapsack[i][1];\n        value[i] = benefit / weight;\n        initialize(++i);\n    })(0);\n\n    (function grab(knapsack, value) {\n        if (curr_weight >= max_weight || knapsack.length < 1) return;\n\n        var max_value_i = findMax(value);\n        console.log(max_value_i);\n        var weight_available = max_weight - curr_weight;\n\n        var item_weight;\n        if (knapsack[max_value_i][0] <= weight_available) {\n            weight = knapsack[max_value_i][0];\n        } else {\n            weight = weight_available;\n        }\n        curr_weight += weight;\n\n        knapsack.splice(max_value_i, 1); // remove ith element from knapsack\n        value.splice(max_value_i, 1); // remove ith element from value\n        grab(knapsack, value);\n    })(knapsack.slice(), value.slice());\n\n    function findMax(arr) {\n        var max = Number.MAX_VALUE * -1;\n        var max_i = -1;\n\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n                max_i = i;\n            }\n        }\n\n        return max_i;\n    }\n\n    return amt_to_take;\n}\n\nconsole.log(fractionalKnapsack(test_input));\n```\n\n\nThe part that Im getting caught up on is in the grab method, if you remove i from the set. How can you update xi because your index i of the item in S w/ highest value is not going to correspond with xi if you are removing elements from S.\n    ", "Answer": "\r\nAs fractional knapsack is a greedy algorithm I suggest you first sort the items by their ```\nbenefit/weight```\n and take items from the start of the array until your knapsack is full. This way you don't have to search for the max item every time and you won't face the problem you are having at the moment.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Isn't this a correct but very efficient and simple way of solving the 0-1 knapsack?\r\n                \r\nAs I understand it, in a 0-1 knapsack problem, only 0 or 1 objects of the same variant are allowed. Wouldn't it be better to just divide every weight by it's value to get the respectiv ratios and then just take every ratio beginning from the largest and put it in the knapsack until the maximum allowed weight is reached? Wouldn't its time complexity be better than the dynamic programming solution and obviously better than bruteforcing?\n    ", "Answer": "\r\nThe point of the 0-1 Knapsack problem is to find if the maximum value occurs if an item is put into the knapsack or not included in the knapsack.  This prevents the problem where including an item results in an unfillable space in the knapsack.  A greedy approach that always includes an object could result in an unfillable space in the knapsack.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Number of all combinations in Knapsack task\r\n                \r\nThere is a classic Knapsack problem. My version of this problem is a little different. \n\nGiven set of items, each with a mass, determine the number of combinations to pack items so that the total weight is less than or equal to a given limit.\n\nFor example, there is 5 items with mass: ```\n1, 1, 3, 4, 5```\n. There is a bug with ```\nlimit = 7```\n. There are the following combinations:\n\n```\n1 + 3\n1 + 4\n1 + 5\n1 + 1 + 3\n1 + 1 + 4\n1 + 1 + 5\n3\n3 + 4\n4\n5\n```\n\n\nIs there a way to count number of combinations without brute?\n    ", "Answer": "\r\nThis is one solution:\n\n```\nitems = [1,1,3,4,5]\nknapsack = []\nlimit = 7\n\ndef print_solutions(current_item, knapsack, current_sum):\n    #if all items have been processed print the solution and return:\n    if current_item == len(items):\n        print knapsack\n        return\n\n    #don't take the current item and go check others\n    print_solutions(current_item + 1, list(knapsack), current_sum)\n\n    #take the current item if the value doesn't exceed the limit\n    if (current_sum + items[current_item] <= limit):\n        knapsack.append(items[current_item])\n        current_sum += items[current_item]\n        #current item taken go check others\n        print_solutions(current_item + 1, knapsack, current_sum )\n\nprint_solutions(0,knapsack,0)\n```\n\n\nprints: \n\n```\n[]\n[5]\n[4]\n[3]\n[3, 4]\n[1]\n[1, 5]\n[1, 4]\n[1, 3]\n[1]\n[1, 5]\n[1, 4]\n[1, 3]\n[1, 1]\n[1, 1, 5]\n[1, 1, 4]\n[1, 1, 3]\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm, weird behavior (python3)\r\n                \r\nI have been working on recursion and tried to solve the Knapsack problem [https://en.wikipedia.org/wiki/Knapsack_problem]. I came up with the algorithm below which works just fine:\n\n```\ncost_array = [2,3,4,5,9]\nvalue_array = [3,4,8,8,10]\n\ndef KP(Weight, C, V):\n    if Weight < 2:\n        return 0\n    q = 0\n    for i in range(len(C)):\n        q = max(q, (KP(Weight-C[i], [x for j,x in enumerate(C) if j!=i], \\\n                [x for j,x in enumerate(V) if j!=i]) + V[i]*(Weight-C[i] >= 0)))\n    return q\n\n\nprint(KP(25,cost_array,value_array))\n```\n\n\nHowever when I change the value of ```\nq```\n to ```\nq < 0```\n and call ```\nprint(KP(25,cost_array,value_array))```\n the result I get is ```\n33 - q```\n. With ```\n33```\n being the max value the knapsack can have.\n\nWhat is weird here is that I only get this behavior if I call the initial function with a ```\nWeight > 23```\n and here ```\n23=2+3+4+5+9```\n.\n\nI can't figure out at what point the negative ```\nq```\n gets added to my result for me this line never performs such an operation, can you guys enlighten me ?\n\n```\nq = max(q, (KP(W-C[i], [x for j,x in enumerate(C) if j!=i], [x for j,x in enumerate(V) if j!=i]) + V[i]*(W-C[i] >= 0)))\n```\n\n\nThanks,\n\nd_darric\n    ", "Answer": "\r\nSuppose ```\nq=-2```\n (a negative value)\nTherefore you are filling your base cases with ```\n-2```\n . That is ```\n-2```\n is returned for base cases of your function which is then getting added to the answer on each step in recursion. Try a bottom up approach with a 2D array. You can look at that here https://www.youtube.com/watch?v=8LusJS5-AGo . In your case you are filling matrix base cases with -2.\n\n```\ndef knapSack(W, wt, val, n): \n    K = [[0 for x in range(W+1)] for x in range(n+1)] \n\n    q=-2 #Make it zero for correct answer\n\n    # Build table K[][] in bottom up manner \n    for i in range(n+1): \n        for w in range(W+1): \n            if i==0 or w==0: \n                K[i][w] = q #Here you are assigning negative value\n            elif wt[i-1] <= w: \n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]) \n            else: \n                K[i][w] = K[i-1][w] \n\n    return K[n][W] \n\n# Driver program to test above function \nvalue_array = [3,4,8,8,10]\ncost_array =  [2,3,4,5,9]\nWeight = 25\nn = len(val) \nprint(knapSack(Weight, cost_array, value_array, n))\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack in PuLP, adding Constraints on Number of Items selected\r\n                \r\nI have some puLP code, which solves my knapsack problem.\n\n```\nprob = LpProblem(\"Knapsack problem\", LpMaximize)\n\nx1 = LpVariable(\"x1\", 0, 12, 'Integer')\nx2 = LpVariable(\"x2\", 0, 12, 'Integer')\nx3 = LpVariable(\"x3\", 0, 12, 'Integer')\nx4 = LpVariable(\"x4\", 0, 12, 'Integer')\nx5 = LpVariable(\"x5\", 0, 12, 'Integer')\nx6 = LpVariable(\"x6\", 0, 12, 'Integer')\nx7 = LpVariable(\"x7\", 0, 12, 'Integer')\nx8 = LpVariable(\"x8\", 0, 12, 'Integer')\nx9 = LpVariable(\"x9\", 0, 12, 'Integer')\nx10 = LpVariable(\"x10\", 0, 12, 'Integer')\nx11 = LpVariable(\"x11\", 0, 12, 'Integer')\nx12 = LpVariable(\"x12\", 0, 12, 'Integer')\nx13 = LpVariable(\"x13\", 0, 12, 'Integer')\nx14 = LpVariable(\"x14\", 0, 12, 'Integer')\nx15 = LpVariable(\"x15\", 0, 12, 'Integer')\nx16 = LpVariable(\"x16\", 0, 12, 'Integer')\nx17 = LpVariable(\"x17\", 0, 12, 'Integer')\nx18 = LpVariable(\"x18\", 0, 12, 'Integer')\nx19 = LpVariable(\"x19\", 0, 12, 'Integer')\nx20 = LpVariable(\"x20\", 0, 12, 'Integer')\nx21 = LpVariable(\"x21\", 0, 12, 'Integer')\nx22 = LpVariable(\"x22\", 0, 12, 'Integer')\nx23 = LpVariable(\"x23\", 0, 12, 'Integer')\nx24 = LpVariable(\"x24\", 0, 12, 'Integer')\nx25 = LpVariable(\"x25\", 0, 12, 'Integer')\n\nprob += 15 * x1 + 18 * x2 + 18 * x3 + 23 * x4 + 18 * x5 + 20 * x6 + 15 * x7 + 16 * x8 + 12 * x9 + 12 * x10 + 25 * x11 + 25 * x12 + 28 * x13 + 35 * x14 + 28 * x15 + 28 * x16 + 25 * x17 + 25 * x18 + 25 * x19 + 28 * x20 + 25 * x21 + 32 * x22 + 32 * x23 + 28 * x24 + 25 * x25, \"obj\"\n\nprob += 150 * x1 + 180 * x2 + 180 * x3 + 230 * x4 + 180 * x5 + 200 * x6 + 150 * x7 + 160 * x8 + 120 * x9 + 120 * x10 + 250 * x11 + 250 * x12 + 280 * x13 + 350 * x14 + 280 * x15 + 280 * x16 + 250 * x17 + 250 * x18 + 250 * x19 + 280 * x20 + 250 * x21 + 320 * x22 + 320 * x23 + 280 * x24 + 250 * x25 == 6600, \"c1\"\n\nprob.solve()\n\nprint \"Status:\", LpStatus[prob.status]\n\nfor v in prob.variables():\n    print v.name, \"=\", v.varValue\n\nprint (\"objective = %s\" % value(prob.objective))\n```\n\n\nBut to this code I need append another restriction: For example, a restriction That the number of non-zero ```\nprob.variables```\n must equal (say) 10.\n\nCould anybody help with that?\n\nUPDATE:\n\nFor this code I have output:\n\n```\nStatus: Optimal\nX1 = 1.0\nx10 = 0.0\nx11 = 0.0\nx12 = 0.0\nx13 = 0.0\nx14 = 0.0\nx15 = 0.0\nx16 = 0.0\nx17 = 0.0\nx18 = 0.0\nx19 = 0.0\nx2 = 0.0\nx20 = 0.0\nx21 = 0.0\nx22 = 0.0\nx23 = 0.0\nx24 = 0.0\nx25 = 0.0\nx3 = 0.0\nx4 = 11.0\nx5 = 0.0\nx6 = 10.0\nx7 = 0.0\nx8 = 12.0\nx9 = 0.0\nobjective = 660.0\n```\n\n\nThe number of ```\nprob.variables```\n that have non-zero values equals only 4.  But say I need 10, how would I ensure that?\n    ", "Answer": "\r\nIf you want a certain number of non-zero values, you can do that by introducing new 0/1 variables.\n\nFormulation\n\nIntroduce 25 new ```\nY```\n variables [y1..y25] which are all binary {0,1}\n\nIf X[i] > 0, we want Y[i] to take on the value 1.\nYou can do by adding the following constraints.\n\n```\nx[i] < y[i] x M (where M is some big number, say 10,000) for 1 in 1..25\n```\n\n\nNow, to ensure that at least 10 Y values are non-zero, we want at least 10 of them to be 1.\n\nSum over Y[1]...y[25] >= 10 will ensure that.\n\nIn PuLP\nThe puLP code is untested, but will give you the right idea to proceed.\n\n```\nx=[]\ny=[]\n\nfor index in range(25):\n    y[index] = LpVariable(\"y\"+str(index), 0, 1) #binary variables\n    prob += x[index] <= 10000 * y[index], \"If x%s is non-zero, then y%s is forced to be 1\",%index, %index\n\nprob += lpSum([y[i] for i in range(25)]) >= 10,\"Ensuring at least 10 items are non-zero\"\n```\n\n\nHope that helps.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Given an elevator with max weight and n people with x_i weights, find out minimum number of rides needed\r\n                \r\n```\ninput:\nmax_weight = 550\nn = 4\nx_i = [120, 175, 250, 150]\n\noutput:\n2  \n// [[250, 175, 120], [150]]\n```\n\n\nMy initial impression is that this looks very similar to a dynamic programming coin change/knapsack problem, however it is not coin change (which would be asking for the fewest number of weights to make an exact amount), and it is not knapsack (the weights do not have values and it's like I can have more than 1 knapsack).\n\nIs there a common name/solution for this problem?\n    ", "Answer": "\r\nThis is actually a (1D) Bin Packing problem:\n\n\n  In the bin packing problem, objects of different volumes must be packed into a finite number of bins or containers each of volume V in a way that minimizes the number of bins used. In computational complexity theory, it is a combinatorial NP-hard problem.\n\n\nHere the persons map on the objects en the bins on the rides. Like the bin packing problem we want to minimize the number of rides \"used\" and each person occupies a certain \"volume\" (that person's weight).\n\nThe bin packing problem is - as said in the article - NP-hard. We can use dynamic programming (but it still has - worst case - exponential time).\n\nThe paper A New Algorithm for Optimal Bin Packing by Richard E. Korf discusses an algorithm to solve this problem exactly. It works by using a heuristic approach first and calculating a lower bound, and then use branch and bound to iteratively derive a better solution than the heuristic one until the lower bound is reached, or no solution can be found anymore.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What's the fastest way to solve knapsack prob with two properties\r\n                \r\nLet's say we've got an input:\n\n```\n10 // saying 1st property should be 10(in total)\n10 // saying 2d property should be 10 (in total)\n5 // saying theres 5 records below\n// (1st property) (2nd property) (cost)\n2 5 8 \n7 3 10 \n4 2 9\n4 3 5\n8 5 15\n```\n\n\nIn this case, the output would look like that:\n\n```\n22 // lowest possible cost\n1 3 4 // indexes of records, we've been using (indexing starts with 1)\n\n 2  5  8\n 4  2  9\n 4  3  5\n+---------\n 10 10 22\n```\n\n\nIf there wasn't possible way to achieve those properties to be 10 and 10, program would output -1;\nI do know how to solve knapsack problem, however I've got no clue how to solve this prob.\n    ", "Answer": "\r\nYou can use the same approach of knapsack problem, but instead of 2D matrix, you will have a 3D table, a dimension for each parameter (2 constraint + index).\n\nThe recursive formula will be similar, but of course will be done for both parameters.\n\n```\nf(item,cost1,cost2) = max {\n               f(item-1,cost1,cost2), \n               f(item,cost1-firstCost[i],cost2-secondCost[i]) + profit[i]\n                          }\n```\n\n\n(Base clauses will be similar as well, but with an extra dimension.)\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python Knapsack Branch and Bound\r\n                \r\nI have spent a week working on this branch and bound code for the knapsack problem, and I have looked at numerous articles and books on the subject.  However, when I am running my code I don't get the result I expect.  Input is received from a text file, such as this:\n\n```\n12\n4 1\n1 1\n3 2\n2 3\n```\n\n\nwhere the first line is the capacity, and each subsequent line are value/weight pairs.  The result I get from using this file is '8' instead of '10' (unless I am mistaken and all the items won't fit in the knapsack). Here is my code:\n\n```\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport Queue\nfrom collections import namedtuple\nItem = namedtuple(\"Item\", ['index', 'value', 'weight', 'level', 'bound', 'contains'])\n\nclass Node:\n    def __init__(self, level, value, weight, bound, contains):\n         self.level = level\n         self.value = value\n         self.weight = weight\n         self.bound = bound\n         self.contains = contains\n\ndef upper_bound(u, k, n, v, w):\n    if u.weight > k:\n        return 0\n\n    else:\n        bound = u.value\n        wt = u.weight\n        j = u.level + 1\n\n        while j < n and wt + w[j] <= k:\n            bound += v[j]\n            wt += w[j]\n            j += 1\n\n    # fill knapsack with fraction of a remaining item\n            if j < n:\n                bound += (k - wt) * (v[j] / w[j])\n\n            return bound\n\ndef knapsack(items, capacity):\n    item_count = len(items)\n    v = [0]*item_count\n    w = [0]*item_count\n\n# sort items by value to weight ratio\n    items = sorted(items, key=lambda k: k.value/k.weight, reverse = True)\n\n    for i,item in enumerate(items, 0):\n        v[i] = int(item.value)\n        w[i] = int(item.weight)\n\n    q = Queue.Queue()\n\n    root = Node(0, 0, 0, 0.0, [])\n    root.bound = upper_bound(root, capacity, item_count, v, w)\n    q.put(root)\n\n    value = 0\n    taken = [0]*item_count\n    best = set()\n\n    while not q.empty():\n        c = q.get()\n\n        if c.bound > value:\n            level = c.level+1\n\n    # check 'left' node (if item is added to knapsack)\n        left = Node(c.value + v[level], c.weight + w[level], level, 0.0, c.contains[:])\n        left.contains.append(level)\n\n        if left.weight <= capacity and left.value > value:\n            value = left.value\n            best |= set(left.contains)\n\n        left.bound = upper_bound(left, capacity, item_count, v, w)\n\n        if left.bound > value:\n            q.put(left)\n\n        # check 'right' node (if items is not added to knapsack)\n        right = Node(c.value, c.weight, level, 0.0, c.contains[:])\n        right.contains.append(level)\n        right.bound = upper_bound(right, capacity, item_count, v, w)\n\n        if right.bound > value:\n            q.put(right)\n\n    for b in best:\n        taken[b] = 1\n\n    value = sum([i*j for (i,j) in zip(v,taken)])\n\n    return str(value)\n```\n\n\nAre my indices off? Am I not traversing the tree or calculating the bounds correctly?\n    ", "Answer": "\r\n```\ndef upper_bound(u, k, n, v, w):\n        if u.weight > k:\n            return 0\n        else:\n            bound = u.value\n            wt = u.weight\n            j = u.level \n            while j < n and wt + w[j] <= k:\n                bound += v[j]\n                wt += w[j]\n                j += 1\n            # fill knapsack with fraction of a remaining item\n            if j < n:\n                bound += (k - wt) * float(v[j])/ w[j]\n            return bound\n\n\ndef knapsack(items, capacity):\n        item_count = len(items)\n        v = [0]*item_count\n        w = [0]*item_count\n        # sort items by value to weight ratio\n        items = sorted(items, key=lambda k: float(k.value)/k.weight, reverse = True)\n        for i,item in enumerate(items, 0):\n            v[i] = int(item.value)\n            w[i] = int(item.weight)\n        q = Queue.Queue()\n        root = Node(0, 0, 0, 0.0,[])\n        root.bound = upper_bound(root, capacity, item_count, v, w)\n        q.put(root)\n        value = 0\n        taken = [0]*item_count\n        best = set()\n        while not q.empty():\n            c = q.get()\n            if c.bound > value:\n                level = c.level+1\n            # check 'left' node (if item is added to knapsack)\n            left = Node(level,c.value + v[level-1], c.weight + w[level-1], 0.0, c.contains[:])\n            left.bound = upper_bound(left, capacity, item_count, v, w)\n            left.contains.append(level)\n            if left.weight <= capacity:\n                if left.value > value:\n                    value = left.value\n                    best = set(left.contains)\n                if left.bound > value:\n                    q.put(left)\n                # check 'right' node (if items is not added to knapsack)   \n            right = Node(level,c.value, c.weight, 0.0, c.contains[:])\n            right.bound = upper_bound(right, capacity, item_count, v, w)\n            if right.weight <= capacity:\n                if right.value > value:\n                    value = right.value\n                    best = set(right.contains)\n                if right.bound > value:\n                    q.put(right)\n        for b in best:\n            taken[b-1] = 1\n        value = sum([i*j for (i,j) in zip(v,taken)])\n        return str(value)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is a plain English explanation of \"Big O\" notation?\r\n                \r\nI'd prefer as little formal definition as possible and simple mathematics.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack with google or-tools (c#)\r\n                \r\nI'm trying to implement knapsack problem with 3 constraint with google-or tools.\nLet's say i want to have an additional property called size for each of the item. So each item with have 3 property and i have to maximize the total value for the items. \n\n```\nKnapsackSolver k = new KnapsackSolver(KnapsackSolver.KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER, \"mybin\");\n        long[, ,] profits = { {{ 10,20,30} ,{40,50,60}} };\n        long[,] weights = {{44,21}};\n        long[] capa = { 110 };\n        k.Init(profits, weights, capa);\n```\n\n\nBut it is not going anywhere. can somebody please correct me.\n    ", "Answer": "\r\nSee https://github.com/google/or-tools/blob/stable/examples/dotnet/csknapsack.cs\n\n```\nlong[] profits = { 360, 83, 59, 130, 431, 67, 230, 52, 93,\n                   125, 670, 892, 600, 38, 48, 147, 78, 256,\n                   63, 17, 120, 164, 432, 35, 92, 110, 22,\n                   42, 50, 323, 514, 28, 87, 73, 78, 15,\n                   26, 78, 210, 36, 85, 189, 274, 43, 33,\n                   10, 19, 389, 276, 312 };\n\nlong[,] weights = { { 7, 0, 30, 22, 80, 94, 11, 81, 70,\n                      64, 59, 18, 0, 36, 3, 8, 15, 42,\n                      9, 0, 42, 47, 52, 32, 26, 48, 55,\n                      6, 29, 84, 2, 4, 18, 56, 7, 29,\n                      93, 44, 71, 3, 86, 66, 31, 65, 0,\n                      79, 20, 65, 52, 13 } };\n\nlong[] capacities = { 850 };\n```\n\n\nprofits is a ```\nlong[]```\n\nweights is ```\nlong[,]```\n\ncapacities is a ```\nlong[]```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "multi-dimensional knapsack with multiple constraints\r\n                \r\ni am unsure if i have even identified the problem correctly, but reading up on Knapsack problem seems the closest to what i am trying to solve:\n\nA cook has several ingredients of varying quantities. for example:\n\n8 eggs\n3 sausages\n500 mL milk\n12 strawberries\n\nThere is a finite list of recipes, each consisting varying ingredients of varying quantities. The universe of ingredients is finite, as is the quantity of each ingredient in all recipes.\n\nEach recipe may or may not contain any of the ingredients the cook has.\n\nThe cook wants to use up all his ingredients as much as possible to minimize waste on 1 recipe. \n\nThere is a case where the cook wants to use all his ingredients on 2 or 3 different recipes, with minimal leftovers.\n\nWhat is his optimized solution?\n\nEDIT: My question is a more complex version of the following knapsack problem\nhttp://www.g12.cs.mu.oz.au/wiki/doku.php?id=simple_knapsack\n    ", "Answer": "\r\nThis doesn't sound like the knapsack problem if i'm not missing anything in your Q. \nThe amount of each ingredient to go into each recipe is known\nso your slot size isn't a variable. \n\nIf i read your Q correctly, all you need to do is to run the \ningredients thru each recipe, see whether the amounts are sufficient, \nand if so, calculate the value of the ingredients \nto be left out on that one. the recipe with the minimum of \nsuch positive values is your answer. takes \\theta(m*n) \ntime with direct access to the ingredients list-- m & n the number \nof ingredients and the recipes. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is a plain English explanation of \"Big O\" notation?\r\n                \r\nI'd prefer as little formal definition as possible and simple mathematics.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Stack Overflow for Fractional Knapsack\r\n                \r\nI am fairly new to C++. I have implemented the fractional knapsack problem in c++ for the course \"Algorithmic Toolbox\" on Coursera:\n\n```\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint get_max_index(double A[], double B[],int l)\n{\n    /*\n    int A = array of value\n    int B = array of weights\n    int l = length of the array\n    */\n    int p,Max{0};\n    for(int j=0;j<l;j++)\n    {\n        if((A[j]/B[j]) > Max){Max = A[j]/B[j];p = j;}\n    }\n    return p;\n}\n\nint main()\n{\n    int n,W,q,Max{0},W1{0};\n    cin >> n >> W;\n    double values[n],weights[n],loot{0};\n    for(int i=0;i<n;i++)\n    {\n        cin >> values[i] >> weights[i];\n    }\n    for(int j=0;j<n;j++)\n    {\n        if(W==0){break;}\n        else\n        {\n            q = get_max_index(values,weights,n);\n            if(weights[q] <= W){W1 = weights[q];}\n            else{W1 = W;}\n            loot += W1 * (values[q]/weights[q]);\n            W -= W1;\n            weights[q] -= W1;\n            if(weights[q] == 0){values[q] = 0;}\n        }\n    }\n    cout << setprecision(4) << fixed;\n    cout << loot << endl;\n}\n```\n\n\nAfter submitting this code I got a stack overflow error (unknown signal 11). Please help me understand why this happens and solution to this problem.\n\nEDIT :\n\nI have changed the code. I am not using the get_max_index function with dynamically sized arrays. Here is the new code:\n\n```\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n\nint main()\n{\n    long long int n,W,q,p,Max{0},W1{0};\n    cin >> n >> W;\n    long double values[n],weights[n],loot{0},VPU[n];\n    for(long long int i=0;i<n;i++)\n    {\n        cin >> values[i] >> weights[i];\n        VPU[i] = values[i] / weights[i];\n    }\n    for(long long int j=0;j<n;j++)\n    {\n        if(W==0){break;}\n        else\n        {\n            for(long long int k=0;k<n;k++)\n            {\n                if(VPU[k] > Max){Max = VPU[k];p=k;}\n            }\n            Max = 0;\n            q = p;\n            if(weights[q] <= W){W1 = weights[q];}\n            else{W1 = W;}\n            loot += W1 * (values[q]/weights[q]);\n            W -= W1;\n            weights[q] -= W1;\n            if(weights[q] == 0){VPU[q] = 0;}\n        }\n    }\n    cout << setprecision(4) << fixed;\n    cout << loot << endl;\n}\n```\n\n    ", "Answer": "\r\nC++ standard doesn't allow variable-length arrays. So that it is not legal(even though some compilers might support it) to create a static array(allocated in stack)  ```\ndouble values[n],weights[n]...```\n with a size that is not known in compile time. The stack overflow error is most probably because of that(n is not known at compile time and a junk value that breaks your stack might be read). Instead try allocating them in heap with ```\nnew double[n]```\n syntax. Don't forget to free the array at the end.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Bin Packing or Knapsack?\r\n                \r\nI'm having some issues with an assignment I have. I've been searching stackoverflow and other websites to see which kind of problem I'm dealing with, and turns out I'm not sure if it's a knapsack problem or a bin packing problem. Here's the problem:\nAn old lady bought N products, each product with a different weight (kg), and she wants to fit it all into a bag that can hold K kg. Find the set of objects that the sum of the weights gets as close as it can to K.\n    ", "Answer": "\r\nThis is a special case of the knapsack problem where each item's value is equal to its weight.  (In general knapsack problems, you may be maximizing the total \"value\" of all the objects as defined by the problem -- perhaps their monetary value in a physical problem, or desirability to the user when scheduling programs or tasks.)\n\nFrom Wikipedia,\n\n\n  When the number of bins is restricted to 1 and each item is characterised by both a volume and a value, the problem of maximising the value of items that can fit in the bin is known as the knapsack problem.\n\n\nSo you could consider it a special case of bin-packing, as well (\"volume\" being the item's weight).\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Backtracking for Knapsack\r\n                \r\nI need to do use backtracking to solve a Knapsack problem. This is an example of what I might have to do for my problem. My question is, how do I know the bounds? I understand that the bound for the root node is $115 because it is the sum of all values. But what I don't understand is how the right child of the root has a bound of $82.\n\nI found this text explaining what it means, but I am still confused:\n\n```\nFor a maximization problem the bound is an upper bound, \n    – the largest possible solution that can be achieved by \n      expanding the node is less or equal to the upper bound \n```\n\n\n\n    ", "Answer": "\r\nI have figured it out:\n\nbound = profit  +  p1 + p2 + (C - 7 ) * p3 / w3 = $0 + $40 + $30 + (16 -7) X $50/10 = $115\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "01 Knapsack Using single dimension array for storing intermediate solutions\r\n                \r\nI have read couple of solutions to 01 Knapsack problem online. Each one of them is trying to store the solution for sub-problem chosen weights from 0..i and total weight w, when total weight is W. So basically they require a 2D array to store solutions to sub-problem. My question is why they are solving the problem for  a set of weights and thus adding another dimension. I am posting my solution which iterates over all available weights and build up the solution till the weight of knapsack. This requires using only a single dimension array. Am I missing some thing here. I am pasting my code below.\n\n```\npublic class KnapSack01 {\n\n//The Weight Matrix\nint[] weight;\n\n//The Benefit Matrix\nint[] benefit;\n\n//The size of Knap-Sack\nint M;\n\n//array to store solutions to subproblem\n//B[i] = optimal solution for capacity i\nint[] B;\n\n//Array to print out the chosen weights\nString[] chosenWeight;\n\nint calculate() {\n    B = new int[M + 1];\n    chosenWeight = new String[M + 1];\n    for (int i = 0; i < B.length; i++) {\n        B[i] = 0;\n        chosenWeight[i] = \"\";\n    }\n    for (int w = 1; w <= M; w++) {\n        for (int i = 0; i < weight.length; i++) {\n            int b1 = benefit[i];\n            int remaining = w - weight[i];\n            int temp = B[w];\n            if (remaining >= 0) {\n                temp = b1 + B[remaining];\n            }\n            if (temp >= B[w]) {\n                B[w] = temp;\n                chosenWeight[w] = chosenWeight[w] + \",\" + weight[i];\n            }\n        }\n    }\n    System.out.println(chosenWeight[M].substring(1,\n        chosenWeight[M].length()));\n    return B[M];\n}\n\n/**\n * @param args\n */\npublic static void main(String[] args) {\n    int[] w = { 2, 3, 4, 5 };\n    int[] b = { 3, 4, 5, 6 };\n    int capacity = 5;\n\n    KnapSack01 ks = new KnapSack01();\n    ks.weight = w;\n    ks.benefit = b;\n    ks.M = capacity;\n    System.out.println(ks.calculate());\n}\n```\n\n\n}\n    ", "Answer": "\r\nYour code is not correct because you can pick the same item twice(or more times).\nHere is an example:  \n\n```\nw = {1, 1}  \nb = {2, 1}\ncapacity = 2\n```\n\n\nThe correct answer is 3, but your code returns 4(it picks the first item twice). \n\nIt is actually possible to implement this algorithm using one-dimensional array, but it requires different order of loops:\nThe outer loop should iterate over items and the inner loop should iterate over weights from ```\nW```\n down to ```\n0```\n.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Specific knapsack-like\r\n                \r\nI am looking for some ideas how to deal with this specific knapsack problem (I believe it is knapsack-like problem although I might be mistaken).\n\nAs input we get set of numbers, and each can be positive or negative - we don't know that.\nWe have to find minimum possible absolute value of sum of some these numbers.\nWe don't have to use all numbers. We have to do additions (or subtractions) in same order in which numbers are given and we have to start with first number (and add or subtract following ones).\n\nExample would be:\n\n```\n4 11 5 5 => 0\nbecause 4+11-5-5 = 0\n\n10 3 9 4 100 => 2\nbecause 10-3-9 = -2\n```\n\n\nIn second example we skipped two last numbers - because adding next numbers wouldn't give us smaller absolute number.\n\nAmount of numbers can be up to 5,000\n, and the sum of them won't over exceed 10,000\n\nThey are integers\n    ", "Answer": "\r\nIf you were to explore all combinations of addition and subtraction of 5000 numbers, you would have to go through 25000−1 ≈ 1.4⋅101505 alternatives. That's obviously not reasonable. However, since the sum of the numbers is at most 10000, we know that all partial sums (including subtraction) must lie between -10000 and 10000, so there can be less than 20000 different sums. If you only consider different sums when you work through the 5000 positions you have less than 100 million sums to consider, which is not that much work for a computer.\n\n\nExample: suppose the first three numbers are 5,1,1. The possible sums that include exactly three numbers are\n\n```\n5+1+1=7\n5+1-1=5\n5-1+1=5\n5-1-1=3\n```\n\n\nBefore adding the fourth number it is important to recognize that you have only three unique results from the four computations.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Find path to optimal solution unboundeed knapsack\r\n                \r\nI need to find solution to the following problem:\n\n\n  Maximize W = sum({n_k * v_k}) with respect to n_k, under the constraint W<=W_max\n\n\nThis is appears to be a variant of the unbounded knapsack problem. I have the following DP approach (written in C++): \n\n```\nauto findSize(int n_vals, int capacity, const int* values, int** mem)\n    {\n    if(n_vals == 0)\n        {return 0;}\n    if(capacity == 0)\n        {return 0;}\n    auto n = mem[n_vals - 1][capacity - 1];\n    if(n != -1)\n        {return n;}\n\n    auto max_result = 0;\n    auto k = 0;\n    while(k*values[n_vals - 1] <= capacity)\n        {\n        auto val = k*values[n_vals - 1] + findSize(n_vals - 1, capacity - k*values[n_vals-1], values, mem);\n        if(val > max_result)\n            {max_result = val;}\n        ++k;\n        }\n    mem[n_vals - 1][capacity - 1]=max_result;\n    return max_result;\n    }\n```\n\n\nI think I get the right answer, but I only get N. I also want the different n_k. How can I find these?\n    ", "Answer": "\r\nIn general, to record optimal path, you have to remember source coordinates (write them into additional storage array ```\nprev```\n, parallel to ```\nmem```\n) when choosing the best next step. \n\nPerhaps something like this:\n\n```\n if(val > max_result)\n        {max_result = val;\n         bestK = k}\n...\nmem[n_vals - 1][capacity - 1]=max_result;\nprev[n_vals - 1][capacity - 1] = bestK;\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Reconstructing the list of items from a space optimized 0/1 knapsack implementation\r\n                \r\nA space optimization for the 0/1 knapsack dynamic programming algorithm is to use a 1-d array (say, A) of size equal to the knapsack capacity, and simply overwrite A[w] (if required) at each iteration i, where A[w] denotes the total value if the first i items are considered and knapsack capacity is w. \nIf this optimization is used, is there a way to reconstruct the list of items picked, perhaps by saving some extra information at each iteration of the DP algorithm? For example, in the Bellman Ford Algorithm a similar space optimization can be implemented, and the shortest path can still be reconstructed as long as we keep a list of the predecessor pointers, ie the last hop (or first, depending on if a source/destination oriented algorithm is being written).\n\nFor reference, here is my C++ function for the 0/1 knapsack problem using dynamic programming where I construct a 2-d vector ans such that ans[i][j] denotes the total value considering the first i items and knapsack capacity j. I reconstruct the items picked by reverse traversing this vector ans: \n\n```\nvoid knapsack(vector<int> v,vector<int>w,int cap){\n //v[i]=value of item i-1\n //w[i]=weight of item i-1, cap=knapsack capacity\n //ans[i][j]=total value if considering 1st i items and capacity j\n vector <vector<int> > ans(v.size()+1,vector<int>(cap+1));\n\n //value with 0 items is 0\n ans[0]=vector<int>(cap+1,0);\n\n //value with 0 capacity is 0\n for (uint i=1;i<v.size()+1;i++){\n    ans[i][0]=0;\n }\n\n //dp\n for (uint i=1;i<v.size()+1;i++) {\n    for (int x=1;x<cap+1;x++) {\n        if (ans[i-1][x]>=ans[i-1][x-w[i-1]]+v[i-1]||x<w[i-1])\n            ans[i][x]=ans[i-1][x];\n        else {\n            ans[i][x]=ans[i-1][x-w[i-1]]+v[i-1];\n        }\n    }\n }\n cout<<\"Total value: \"<<ans[v.size()][cap]<<endl;\n\n //reconstruction\n cout<<\"Items to carry: \\n\";\n for (uint i=v.size();i>0;i--) {\n    for (int x=cap;x>0;x--) {\n        if (ans[i][x]==ans[i-1][x]) //item i not in knapsack\n            break;\n        else if (ans[i][x]==ans[i-1][x-w[i-1]]+v[i-1]) { //item i in knapsack\n            cap-=w[i-1];\n            cout<<i<<\"(\"<<v[i-1]<<\"), \";\n            break;\n        }\n    }\n }\n cout<<endl;\n}\n```\n\n    ", "Answer": "\r\nThe following is a C++ implementation of yildizkabaran's answer. It adapts Hirschberg's clever divide & conquer idea to compute the answer to a knapsack instance with n items and capacity c in O(nc) time and just O(c) space:\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Returns a vector of (cost, elem) pairs.\nvector<pair<int, int>> optimal_cost(vector<int> const& v, vector<int> const& w, int cap) {\n    vector<pair<int, int>> dp(cap + 1, { 0, -1 });\n\n    for (int i = 0; i < size(v); ++i) {\n        for (int j = cap; j >= 0; --j) {\n            if (w[i] <= j && dp[j].first < dp[j - w[i]].first + v[i]) {\n                dp[j] = { dp[j - w[i]].first + v[i], i };\n            }\n        }\n    }\n\n    return dp;\n}\n\n// Returns a vector of item labels corresponding to an optimal solution, in increasing order.\nvector<int> knapsack_hirschberg(vector<int> const& v, vector<int> const& w, int cap, int offset = 0) {\n    if (empty(v)) {\n        return {};\n    }\n\n    int mid = size(v) / 2;\n    auto subSol1 = optimal_cost(vector<int>(begin(v), begin(v) + mid), vector<int>(begin(w), begin(w) + mid), cap);\n    auto subSol2 = optimal_cost(vector<int>(begin(v) + mid, end(v)), vector<int>(begin(w) + mid, end(w)), cap);\n\n    pair<int, int> best = { -1, -1 };\n    for (int i = 0; i <= cap; ++i) {\n        best = max(best, { subSol1[i].first + subSol2[cap - i].first, i });\n    }\n\n    vector<int> solution;\n    if (subSol1[best.second].second != -1) {\n        int iChosen = subSol1[best.second].second;\n        solution = knapsack_hirschberg(vector<int>(begin(v), begin(v) + iChosen), vector<int>(begin(w), begin(w) + iChosen), best.second - w[iChosen], offset);\n        solution.push_back(subSol1[best.second].second + offset);\n    }\n    if (subSol2[cap - best.second].second != -1) {\n        int iChosen = mid + subSol2[cap - best.second].second;\n        auto subSolution = knapsack_hirschberg(vector<int>(begin(v) + mid, begin(v) + iChosen), vector<int>(begin(w) + mid, begin(w) + iChosen), cap - best.second - w[iChosen], offset + mid);\n        copy(begin(subSolution), end(subSolution), back_inserter(solution));\n        solution.push_back(iChosen + offset);\n    }\n\n    return solution;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Maximizing Knapsack with additional constraints\r\n                \r\nThe old and famous Knapsack problem requires that given a capacity C and a list of n items {I_1, I_2,..., I_n} with each I_j=(weight_j, value_j), one tries to maximize the value while filling up the knapsack.\n\nBut what happens if we add a constraint that \n\n1) the number of times a specific item is chosen must either be 0 or must be odd (ex: can only take either no 10lb dumb-bells or 1, 3, 5,.. number of them).\n2) C = n^2 and n <= weight_j <= n^2 for all j.\n\nWhat implementation of dynamic programming can be used to handle the additional constraints?\n\nSome advice would be greatly appreciated on how to begin. Thanks!\n    ", "Answer": "\r\nYou can formulate this variation of the knapsack problem as an Integer Program\n\nStandard Knapsack problem:\n\n```\n Maximize sum(j) Value_j x X_j\n subject to\n         sum(j) Wt_j x X_j <= C\n         X_j is integer\n```\n\n\nIn your variation, X_j can only take on distinct values: {0, 1,3,5,...}\n\nFormulating the constraint to limit X to take on odd values\n\nWhenever there are these types of restrictions on values a variable can take, introduce 0/1 variables to handle these conditions. \n\nFor each item ```\nj```\n let's introduce a bunch of binary Y variables, and a couple of new constraints.\n\n```\nX_j - 1 Y_j1 - 3 Y_j3 - 5 Y_j5 ... - M Y_jm = 0 \n```\n\n\nm is the largest value (odd number) that Xj can take.\n\nAnd to limit X_j to assume one of these values, we add\n\n```\nY_j0 + Y_j1 + Y_j3 + ... + Y_jm = 1 for each item j\nY_j0, Y_j1, Y_j3 ..., Y_jm are {0,1} (binary)\n```\n\n\nThe variable Y_j0 is to allow X_j to take on the value 0.\n\nThe fact that ```\nC = n^2```\n ensures that we can come up with reasonable upper limits ```\nm```\n for each constraint. \n\nYou can now solve this modified knapsack with an integer programming solver. It will still look for the items in decreasing order of \"value density\" (value per kilo), while the constraints limiting it to odd values will kick in for certain boundary conditions.\n\nHope that helps.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Code is showing showing wrong output in 'fractional knapsack' problem even when answer is properly typecasted\r\n                \r\nI am solving question called fractional knapsack on geeks for geeks but I don't know why it is giving wrong output for a particular test case. I am not able to find any error in it.\n```\n// { Driver Code Starts\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Item{\n    int value;\n    int weight;\n};\n\n\n // } Driver Code Ends\n//class implemented\n/*\nstruct Item{\n    int value;\n    int weight;\n};\n*/\n\nstatic bool compare(Item i1,Item i2)\n{\n    double v1=i1.value/i1.weight;\n    double v2=i2.value/i2.weight;\n    \n    return v1>v2;\n}\nclass Solution\n{\n    public:\n    //Function to get the maximum total value in the knapsack.\n    double fractionalKnapsack(int W, Item arr[], int n)\n    {\n        // Your code here\n        sort(arr,arr+n,compare);\n        double ans=0.0;\n        long long int i=0;\n        while(i<n)\n        {\n            \n            if(arr[i].weight<=W)\n            {\n                ans+=arr[i].value;\n                W-=arr[i].weight;\n            }\n            else\n            {\n                double partialvalue=(double)((double)arr[i].value/(double)arr[i].weight)*(double)W;\n                ans+=partialvalue;\n                break;\n            }\n            i++;\n        \n        }\n        return ans;\n        \n    }\n        \n};\n\n\n\n// { Driver Code Starts.\nint main()\n{\n    int t;\n    //taking testcases\n    cin>>t;\n    cout<<setprecision(2)<<fixed;\n    while(t--){\n        //size of array and weight\n        int n, W;\n        cin>>n>>W;\n        \n        Item arr[n];\n        //value and weight of each item\n        for(int i=0;i<n;i++){\n            cin>>arr[i].value>>arr[i].weight;\n        }\n        \n        //function call\n        Solution ob;\n        cout<<ob.fractionalKnapsack(W, arr, n)<<endl;\n    }\n    return 0;\n}  // } Driver Code Ends\n     \n```\n\nRESULT:\nWrong Answer. !!!Wrong Answer\nPossibly your code doesn't work correctly for multiple test-cases (TCs).\nThe first test case where your code failed:\nInput:\n84 87\n78 16 94 36 87 43 50 22 63 28 91 10 64 27 41 27 73 37 12 19 68 30 83 31 63 24 68 36 30 3 23 9 70 18 94 7 12 43 30 24 22 20 85 38 99 25 16 21 14 27 92 31 57 24 63 21 97 32 6 26 85 28 37 6 47 30 14 8 25 46 83 46 15 18 35 15 44 1 88 9 77 29 89 35 4 2 55 50 33 11 77 19 40 13 27 37 95 40 96 21 35 29 68 2 98 3 18 43 53 7 2 31 87 42 66 40 45 20 41 30 32 18 98 22 82 26 10 28 68 7 98 4 87 16 7 34 20 25 29 22 33 30 4 20 71 19 9 16 41 50 97 24 19 46 47 2 22 6 80 39 65 29 42 1 94 1 35 15\nIts Correct output is:\n1078.00\nAnd Your Code's output is:\n1075.57\n    ", "Answer": "\r\nYou forgot casts in your comparison function:\n```\nstatic bool compare(Item i1,Item i2)\n{\n    double v1=i1.value/i1.weight;\n    double v2=i2.value/i2.weight;\n    \n    return v1>v2;\n}\n```\n\nshould be\n```\nstatic bool compare(Item i1,Item i2)\n{\n    double v1=(double)i1.value/(double)i1.weight;\n    double v2=(double)i2.value/(double)i2.weight;\n    \n    return v1>v2;\n}\n```\n\nThere may be other issues, but this is the one that jumps out!\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Scaling a Knapsack-Like Quandry With Dynamic Programming\r\n                \r\nSo I have a typical recursive implementation of a problem that requires a 1-0 knapsack problem-like solution. Here's the code for the main function:\n\n```\ndef knapsack(items,sizeLimit):\n    P = {}\n\n    def recurse(nItems,lim):\n        if not P.has_key((nItems,lim)):\n            if nItems == 0:\n                P[nItems,lim] = 0\n            elif itemSize(items[nItems-1]) > lim:\n                P[nItems,lim] = recurse(nItems-1,lim)\n            else:\n                P[nItems,lim] = max(recurse(nItems-1,lim),\n                    recurse(nItems-1,lim-itemSize(items[nItems-1])) +\n                    itemValue(items[nItems-1]))\n        return P[nItems,lim]\n\n    return recurse(len(items),sizeLimit)\n```\n\n\nThe problem is that I have millions upon millions of pieces of data, and it seems like this approach will calculate every entry, leading to obvious memory and speed problems. Is there some kind of dynamic programming/memoization technique I could use to further optimize this implementation? \n    ", "Answer": "\r\nIt seems you have problems when scaling your problem\ntake a look at this dir example in specific this file\n\nThe following is taken from given url:\n\nIf your knapsack problem is composed of three items (weight, value)\ndefined by (1,2), (1.5,1), (0.5,3), and a bag of maximum weight 2,\nyou can easily solve it this way::\n\n```\nsage: from sage.numerical.knapsack import knapsack\nsage: knapsack( [(1,2), (1.5,1), (0.5,3)], max=2)\n[5.0, [(1, 2), (0.500000000000000, 3)]]\n```\n\n\nSuper-increasing sequences\n\nWe can test for whether or not a sequence is super-increasing::\n\n```\nsage: from sage.numerical.knapsack import Superincreasing\nsage: L = [1, 2, 5, 21, 69, 189, 376, 919]\nsage: seq = Superincreasing(L)\nsage: seq\nSuper-increasing sequence of length 8\nsage: seq.is_superincreasing()\nTrue\nsage: Superincreasing().is_superincreasing([1,3,5,7])\nFalse\n```\n\n\nSolving the subset sum problem for a super-increasing sequence\nand target sum::\n\n```\nsage: L = [1, 2, 5, 21, 69, 189, 376, 919]\nsage: Superincreasing(L).subset_sum(98)\n[69, 21, 5, 2, 1]\n```\n\n\n\"\"\"\n\nAlso, there is one from Number Jack, to test this you will have to import all necesary files.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "multi-capacities Knapsack in CPLEX\r\n                \r\nI came cross Knapsack problem, where the maximum number of multiple items from a set of items need to be placed into one bin by minimizing the cost. I am able to solve the optimization problem in CPLEX. \n\nHowever, I am finding difficulties in implementing in CPLEX, when the problem consists of two bins (with different capacities).\n\nThe problem:\n\n```\nBin = [B1, B2] \nCapacity = [7,5]\n\nItem = [I1, I2, I3, I4]\nWeight = [6,3,1,4]\nPrice = [2,8,2,4]\n```\n\n\nThe objective is to place the maximum number of items and to minimize the total price. \n\nHow can I implement this objective problem in CPLEX?\n\nBelow is my code snippet:\n\n```\n// ITEMS\nint n=4; // no of items\nrange items = 1..n; // range of items\nint p[items] = [2,8,2,6]; //price\nint w[items] = [6,3,1,4]; //weight\n\n// BINS\nint m=2; // no of bins\nrange bins=1..m; // range of bin\nint capacity[bins] = [7,5]; // capacity of each bin\n\ndvar boolean x[items][bins]; \n\n// model ; max the profit\nmaximize sum(i in items, j in bins) p[i]*x[i][j];\n\nsubject to {\n    forall (j in bins)\n        cons1 : sum(i in items) w[i]*x[i][j] <= capacity[j];\n    forall (i in items)\n        cons2 : sum(j in bins) x[i][j] == 1;    \n} \n```\n\n\n-Thanks\n    ", "Answer": "\r\nIf you add\n```\nassert sum(i in items) w[i]<=sum(b in bins) capacity[b];\n```\n\nthen this assert is violated and this explains why you do not get a solution. You do not have enough bin capacity.\nBut then if you turn:\n```\nint capacity[bins] = [7,5]; // capacity of each bin\n```\n\ninto\n```\nint capacity[bins] = [7,7]; // capacity of each bin\n```\n\nthen you'll get a solution.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Printing Knapsack items (Repetition of items allowed)\r\n                \r\nI implemented 2 ways to solve knapsack, but i cant print the selected items in 1 way and the other one doesnt really work well because it misses my first item values. Baiscally, my knapsack problem is dividing a bar of lenght N, in sub-bars of lenght 1,2,...., N where each sub-bar has different costs. \n\nThe  repetition of items is allowed as soon as you dont exceed lenght of course.\nSo:\n1) I have a bar of lenght N, which can be divided. Each division from 1 to N has a price related.\n2) Knapsack to find the max profit, where it is possible to take multiple times the same item.\n3)Printing the elements selected by Knapsack.\n\nMy problems are:\n1) In the first piece of code, i cant understand how to print the chosen items.\n2)I tried the matrix approach , but i can't understand how to set the Knapsack matrix's equations with repetition of items allowed.\n\nThis is my first try, this actually works and gives me the proper answer, but i cant really understand how i can print the chosen items. \n\n```\nint *k = malloc(sizeof(int ) * lenght+1);\nfor( i = 0 ; i <= lenght; i++) k[i] = 0;\n```\n\n\nFilling knapsack array.\n\n```\nfor(i = 0 ; i <= lenght ; i++){\n    for(w = 0 ; w < lenght ; w++){\n        if( bar[w] <= i){\n            k[i] = searchmax( prices[w] + k[i-bar[w]] , k[i] );\n        } \n    }\n}\n```\n\n\nThis is my second approach, which doesnt works, but i have much more clear how to print the items after, because it works with classic knapsack.\n\n```\nint **k = malloc(sizeof(int*) * (lenght+1));\nfor(i=0;i<=lenght;i++) k[i] = malloc(sizeof(int)*(lenght+1));\n\nfor( i = 0 ; i <= lenght; i++)k[0][i]= 0;\nfor(i = 0 ; i <=lenght;i++) k[i][0]=0;\n\nfor(i=1;i<=lenght;i++){\n    for(w=1;w<=lenght;w++){\n        if(bar[i]<=w){\n            printf(\"\\nPrices: %d  Barlenght: %d\" , prices[i], bar[i]);\n            k[i][w]=searchmax(prices[i]+k[i][w-bar[i]], k[i-1][w]);\n        }\n        else k[i][w] = k[i-1][w];\n\n    }\n}\n```\n\n\nThe result with this set of inputs: Lenght of bar:4 \n\nPrices for sub-bar of lenght 1 to N, where N in this case is 4, is : 1, 5, 8, 9.\n\nShould be : Profit: 10 ,Items: 2 , 2\n    ", "Answer": "\r\nYou should print the element only if it is 'kept in the knapsack'. With each iteration, you check whether to put an element in the knapsack or to discard it. In your code, you should check this: if a element 'is kept in the knapsack', print it and its weight, along with other values ​​that were already in the knapsack and that when adding this element do not exceed the capacity of the knapsack. There are several ways to do this. I thought about this: while executing the method, save the selected values ​​in the knapsack for each possible capacity of it (if it has capacity W, you would have to store the selected values ​​in a matrix, where each line w represents a value 0 <= w <= W) and the columns contain the elements of the knapsack with a certain capacity.\nI implemented a solution using C++. If you don't understand any part, tell me I can explain.\n\nCode\n\n```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <string>\n\n\n/**\n* Responsible for dealing with the unbounded knapsack problem.\n*/\nclass UnboundedKnapsack\n{\n    //-------------------------------------------------------------------------\n    //      Attributes\n    //-------------------------------------------------------------------------\n    /**\n    * Stores maximum value of the knapsack for a certain capacity.\n    */\n    std::vector<int> knapsack;\n\n    /**\n    * Stores elements that are part of the knapsack with a certain capacity.\n    * <li><b>Line:</b> Knapsack capacity</li>\n    * <li><b>Column:</b> Elements</li>\n    */\n    std::vector<std::vector<int> > selectedElements;\n\n    /**\n    * Stores maximum knapsack capacity.\n    */\n    int maximumCapacity;\n\n\npublic:\n    //-------------------------------------------------------------------------\n    //      Constructor\n    //-------------------------------------------------------------------------\n    UnboundedKnapsack()\n    {\n        maximumCapacity = -1;\n    }\n\n\n    //-------------------------------------------------------------------------\n    //      Destructor\n    //-------------------------------------------------------------------------\n    ~UnboundedKnapsack()\n    {\n        delete this;\n    }\n\n\n    //-------------------------------------------------------------------------\n    //      Methods\n    //-------------------------------------------------------------------------\n    /**\n    * Unbounded knapsack allows to use one or more occurrences of an item.\n    *\n    * @param        w Weight of the elements\n    * @param        v Value of the elements\n    * @param        N Number of itens\n    * @param        W Maximum weight capacity\n    * @return       This object to allow chained calls\n    */\n    UnboundedKnapsack* knapsack_unbounded(std::vector<int>& w, std::vector<int>& v, int N, int W)\n    {\n        // Stores the maximum value which can be reached with a certain capacity\n        knapsack.clear();\n        knapsack.resize(W + 1);\n\n        maximumCapacity = W + 1;\n\n        // Stores selected elements with a certain capacity\n        selectedElements.resize(W + 1);\n\n        // Initializes maximum value vector with zero\n        for (int i = 0; i < W + 1; i++) {\n            knapsack[i] = 0;\n        }\n\n        // Computes the maximum value that can be reached for each capacity\n        for (int capacity = 0; capacity < W + 1; capacity++) {\n            // Goes through all the elements\n            for (int n = 0; n < N; n++) {\n                if (w[n] <= capacity) {\n                    // max(knapsack[capacity], knapsack[capacity - w[n]] + v[n])\n                    if (knapsack[capacity] <= knapsack[capacity - w[n]] + v[n]) {\n                        knapsack[capacity] = knapsack[capacity - w[n]] + v[n];\n\n                        // Stores selected elements\n                        selectedElements[capacity].clear();\n                        selectedElements[capacity].push_back(n + 1);\n\n                        for (int elem : selectedElements[capacity - w[n]]) {\n                            selectedElements[capacity].push_back(elem);\n                        }\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n    * Returns maximum value for a certain number of elements and a certain\n    * capacity.\n    *\n    * @param        capacity Capacity of the knapsack\n    * @return       Maximum possible value with capacity provided\n    * @throws       std::invalid_argument If capacity provided is out of bounds\n    */\n    int getMaximumValue(int capacity)\n    {\n        if (capacity < 0 || capacity >= maximumCapacity)\n            throw std::invalid_argument(\"Capacity out of bounds\");\n\n        return knapsack[capacity];\n    }\n\n    /**\n    * Returns elements that belong to the knapsack with a certain capacity.\n    *\n    * @param        capacity Capacity of the knapsack\n    * @return       Elements that are part of the knapsack with the capacity\n    * provided\n    * @throws       std::invalid_argument If capacity provided is out of bounds\n    * @apiNote      Elements are referenced by their index + 1\n    */\n    std::vector<int>& getSelectedElements(int capacity)\n    {\n        if (capacity < 0 || capacity >= maximumCapacity)\n            throw std::invalid_argument(\"Capacity out of bounds\");\n\n        return selectedElements[capacity];\n    }\n\n    /**\n    * Returns elements that are part of the knapsack with a certain capacity.\n    * This method will return a {@link std::string} with the following format:\n    * <code>[elem1, elem2, elem3...]</code>\n    *\n    * @param        capacity Capacity of the knapsack\n    * @return       Elements that are part of the knapsack with the capacity\n    * provided\n    * @apiNote      Elements are referenced by their index + 1\n    */\n    std::string selectedElements_toString(int capacity)\n    {\n        std::string response = \"[\";\n\n        for (int element : selectedElements[capacity]) {\n            response.append(std::to_string(element));\n            response.append(\", \");\n        }\n\n        // Removes last \", \"\n        response.pop_back();\n        response.pop_back();\n\n        response.append(\"]\");\n\n        return response;\n    }\n};\n\n\n//-------------------------------------------------------------------------\n//      Main\n//-------------------------------------------------------------------------\n/**\n* Example made based on this exercise:\n* {@link https://www.urionlinejudge.com.br/repository/UOJ_1487_en.html}\n*/\nint main()\n{\n    UnboundedKnapsack* knapsack = new UnboundedKnapsack();\n    int totalCapacity = 60, elements = 5;\n    std::vector<int> elements_weight = { 10, 20, 5, 50, 22 };\n    std::vector<int> elements_values = { 30, 32, 4, 90, 45 };\n\n    knapsack->knapsack_unbounded(elements_weight, elements_values, elements, totalCapacity);\n\n    std::cout << \"Maximum value: \"\n        << knapsack->getMaximumValue(totalCapacity)\n        << std::endl;\n    std::cout << \"Selected elements: \"\n        << knapsack->selectedElements_toString(totalCapacity)\n        << std::endl;\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n\nOutput\n\n```\nMaximum value: 180\nSelected elements: [1, 1, 1, 1, 1, 1]\n```\n\n\nI hope this helps. In case you are interested, I also implemented a version that displays the elements stored with the classic version of the knapsack. It is available here:\nhttps://github.com/williamniemiec/algorithms/blob/master/Dynamic%20programming/knapsack/c%2B%2B/BoundedKnapsack.cpp\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Memory Function Knapsack\r\n                \r\nOk, I am having a problem with the Memory Function implementation of the Knapsack problem. My implementation if giving me the incorrect answer in Java but in C++ the same implementation is giving me the correct answer.\n\n```\nimport java.io.*;\nimport java.util.*;\n\npublic class KnapsackMF {\n\n    public static void main(String args[]){\n        int wt;\n        int vl;\n        long start, end, runTime;\n        Scanner input = new Scanner(System.in);\n        int n, W;\n\n        System.out.println(\"Please enter the number of items: \");\n        n = input.nextInt();\n\n        System.out.println(\"Please enter the capacity of the knapsack: \");\n        W = input.nextInt();\n\n        int[][] V = new int[n+1][W+1];\n        int[] Wt = new int[n];\n        int[] Vl = new int[n];\n\n        for(int i = 0; i < n; i++){\n            System.out.println(\"Enter the weight and the value of item \" + i + \": \");\n            wt = input.nextInt();\n            vl = input.nextInt();\n\n            Wt[i] = wt;\n            Vl[i] = vl;\n        }\n\n        for(int i = 0; i <= n; i++ ){\n            for(int j = 0; j <= W; j++){\n                if(j == 0 || i == 0){\n                    V[i][j] = 0;\n                }\n                else{\n                    V[i][j] = -1;\n                }\n            }\n        }\n        /*\n        for(int i= 0; i <= n; i++){\n                for(int j = 0; j <= W; j++){\n                    System.out.print(V[i][j] + \" \");\n                }\n            System.out.println();\n        }\n        */\n\n        start = System.nanoTime();\n\n        System.out.println(\"The highest value is: \" + MFKnapsack(n, W, V, Vl, Wt));\n\n        end = System.nanoTime();\n        runTime = (end - start);\n\n        System.out.println(\"Nanoseconds: \" + runTime);\n\n\n        for(int i= 0; i <= n; i++){\n                for(int j = 0; j <= W; j++){\n                      System.out.print(V[i][j] + \" \");\n                }\n                System.out.println();\n        }\n\n        //system(\"PAUSE\");\n    }\n\n    public static int MFKnapsack(int i, int j, int[][] V, int[] Vl, int[] Wt){\n        int value = 0;\n\n        if(V[i][j] < 0){\n             if(j < Wt[i-1]){\n                  value = MFKnapsack(i-1, j, V, Vl, Wt);\n             }\n             else{\n                  value = Math.max(MFKnapsack(i-1, j, V, Vl, Wt), Vl[i-1] + MFKnapsack(i-1, j-Wt[i-1], V, Vl, Wt));\n             }\n        }\n        V[i][j] = value;\n        return V[i][j];\n\n    }\n\n}\n```\n\n\nThe example I used is out of my book, the inputs should be:\n\n4\n\n5\n\n2 12\n\n1 10\n\n3 20\n\n2 15\n\nThe answer to this should be 37 but something is going on that I am not seeing and it is giving me 35.\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Adding a cache array to recursive knapsack solution?\r\n                \r\nI'm familiar with the naive recursive solution to the knapsack problem. However, this solution simply spits out the max value that can be stored in the knapsack given its weight constraints. What I'd like to do is add some form of metadata cache (namely which items have/not been selected, using a \"one-hot\" array ```\n[0,1,1]```\n).\nHere's my attempt:\n```\nclass Solution:\n    def __init__(self):\n        self.array = []\n    \n    def knapSack(self,W, wt, val, n): \n        index = n-1 \n        if n == 0 or W == 0 : \n            return 0\n        if (wt[index] > W): \n            self.array.append(0)\n            choice = self.knapSack(W, wt, val, index) \n\n        else: \n            option_A = val[index] + self.knapSack( W-wt[index], wt, val, index)\n            option_B = self.knapSack(W, wt, val, index)\n            if option_A > option_B:\n                self.array.append(1)\n                choice = option_A\n            else:             \n                self.array.append(0)\n                choice = option_B\n\n        print(int(option_A > option_B)) #tells you which path was traveled\n        return choice\n\n  # To test above function \nval = [60, 100, 120] \nwt = [10, 20, 30] \nW = 50\nn = len(val) \n# print(knapSack(W, wt, val, n))\ns = Solution()\ns.knapSack(W, wt, val, n)\n>>>\n1\n1\n1\n1\n1\n1\n\n220\n\ns.array\n>>>\n[1, 1, 1, 1, 1, 1]\n```\n\nAs you can see, ```\ns.array```\n returns ```\n[1,1,1,1,1,1]```\n and this tells me a few things. (1), even though there are only three items in the problem set, the knapSack method has been called twice for each item and (2) this is because every item flows through the ```\nelse```\n statement in the method, so ```\noption_A```\n and ```\noption_B```\n are each computed for each item (explaining why the array length is 6 not 3.)\nI'm confused as to why 1 has been appended in every recursive loop. The item at index 0 would is not selected in the optimal solution. To answer this question, please provide:\n(A) Why the current solution is behaving this way\n(B) How the code can be restructured such that a one-hot \"take or don't take\" vector can be captured, representing whether a given item goes in the knapsack or not.\nThank you!\n    ", "Answer": "\r\n\n(A) Why the current solution is behaving this way\n\n\n```\nself.array```\n is an instance attribute that is shared by all recursion paths. On one path or another each item is taken and so a one is appended to the list.\n```\noption_A = val[index]...```\n takes an item but doesn't append a one to the list.\n```\noption_B = self.....```\n skips an item but doesn't append a zero to the list.\n```\nif option_A > option_B:```\n When you make this comparison you have lost the information that made it - the items that were taken/discarded in the branch;\n\nin the suites you just append a one or a zero regardless of how many items made those values.\nThe ones and zeroes then represent whether branch A (```\n1```\n) or branch B (```\n0```\n) was successful in the current instance of the function.\n\n\n\n\n(B) How the code can be restructured such that a one-hot \"take or don't take\" vector can be captured, representing whether a given item goes in the knapsack or not.\n\nIt would be nice to know what you have taken after running through the analysis, I suspect that is what you are trying to do with ```\nself.array```\n. You expressed an interest in OOP: instead of keeping track with lists of numbers using indices to select numbers from the lists, make objects to represent the items work with those. Keep the objects in containers and use the functionality of the container to add or remove items/objects from it. Consider how you are going to use a container before choosing one.\n\nDon't put the function in a class.\nChange the function's signature to accept\n\navailable weight,\na container of items to be considered,\na container holding the items currently in the sack (the current sack).\n\n\nUse a collections.namedtuple or a class for the items having value and weight attributes.\n\n\n```\nItem = collections.namedtuple('Item',['wt','val'])\n```\n\n\n\n\nWhen an item is taken add it to the current sack.\nWhen recursing\n\nif going down the take path add the return value from the call to the current sack\nremove the item that was just considered from the list of items to be considered argument.\nif taken subtract the item's weight from the available weight argument\n\n\nWhen comparing two branches you will need to add up the values of each item the current sack.\n\nreturn the sack with the highest value\n\n\ncarefully consider the base case\n\n\nMake the items to be considered like this.\n```\nimport collections\nItem = collections.namedtuple('Item',['wt','val'])\nitems = [Item(wght,value) for wght,value in zip(wt,val)]\n```\n\nAdd up values like this.\n```\nvalue = sum(item.val for item in current_sack)\n# or\nimport operator\nval = operator.itemgetter('val')\nwt = operator.itemgetter('wt')\nvalue = sum(map(val,current_sack)\n```\n\n\nYour solution enhanced with debugging prints for the curious.\n```\nclass Solution:\n    def __init__(self):\n        self.array = []\n        self.other_array = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n    \n    def knapSack(self,W, wt, val, n,j=0):\n        index = n-1 \n        deep = f'''{' '*j*3}'''\n        print(f'{deep}level {j}')\n        print(f'{deep}{W} available: considering {wt[index]},{val[index]}, {n})')\n        # minor change here but has no affect on the outcome0\n        #if n == 0 or W == 0 :\n        if n == 0:\n            print(f'{deep}Base case found')\n            return 0\n        print(f'''{deep}{wt[index]} > {W} --> {wt[index] > W}''')\n        if (wt[index] > W):\n            print(f'{deep}too heavy')\n            self.array.append(0)\n            self.other_array[index] = 0\n            choice = self.knapSack(W, wt, val, index,j+1) \n\n        else:\n            print(f'{deep}Going down the option A hole')\n            option_A = val[index] + self.knapSack( W-wt[index], wt, val, index,j+1)\n            print(f'{deep}Going down the option B hole')\n            option_B = self.knapSack(W, wt, val, index,j+1)\n            print(f'{deep}option A:{option_A} option B:{option_B}')\n            if option_A > option_B:\n                print(f'{deep}option A wins')\n                self.array.append(1)\n                self.other_array[index] = 1\n                choice = option_A\n            else:             \n                print(f'{deep}option B wins')\n                self.array.append(0)\n                self.other_array[index] = 0\n                choice = option_B\n\n        print(f'{deep}level {j} Returning value={choice}')\n        print(f'{deep}---------------------------------------------')\n        return choice\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "DP for 0-1 knapsack with two factors to optimize upon. Link - http://www.spoj.com/problems/SCUBADIV/\r\n                \r\nThe problem is a 0-1 Knapsack and tries  to minimize the output based on 2 constraint factors. Can somebody suggest whats wrong with the following code? Its giving WA.I am using a bottom-up approach. \nCan somebody point out the test-cases where it fails?\n\n```\n#include<cstdio>\n#include<climits>\n\nusing namespace std;\n#define DEBUG 0\n\ninline int min(int x, int y)\n{\n    int p= (x<y?x:y);\n    return p;\n}\n\n\nint dp[1001][22][80];\nint main()\n{\n    int tc,o,n;\n    int num;\n    int ox[1000],nn[1000],wt[1000];\n\n    scanf(\"%d\",&tc);\n    while(tc--){\n        scanf(\"%d %d\",&o,&n);\n        scanf(\"%d\",&num);\n\n        for(int i=1;i<=num;i++){\n            scanf(\"%d %d %d\",ox+i,nn+i,wt+i);\n        }\n\n    //DP\n\n        for(int i=0;i<=o;i++){\n            for(int j=0;j<=n;j++){\n                dp[0][i][j]=INT_MAX;    \n            }\n        }\n        dp[0][0][0]=0;\n\n        for(int items=1;items<=num;items++){\n            for(int oxygen=0;oxygen<=o;oxygen++){\n                for(int nitrogen=0;nitrogen<=n;nitrogen++){\n                    if(oxygen>=ox[items] && nitrogen>=nn[items] &&  dp[items-1][oxygen-ox[items]][nitrogen-nn[items]]!=INT_MAX){\n                    dp[items][oxygen][nitrogen]=min(dp[items-1][oxygen][nitrogen],(dp[items-1][oxygen-ox[items]][nitrogen-nn[items]]+wt[items]));\n                    }\n                    else if(oxygen>=ox[items] && nitrogen<nn[items] && dp[items-1][oxygen-ox[items]][0]!=INT_MAX){\n                    dp[items][oxygen][nitrogen]=min(dp[items-1][oxygen][nitrogen],(dp[items-1][oxygen-ox[items]][0]+wt[items]));\n                    }\n                    else if(nitrogen>=nn[items] && oxygen<ox[items] && dp[items-1][0][nitrogen-nn[items]]!=INT_MAX){\n                    dp[items][oxygen][nitrogen]=min(dp[items-1][oxygen][nitrogen],(dp[items-1][0][nitrogen-nn[items]]+wt[items]));\n                    }\n                    else if(oxygen<ox[items] && nitrogen<nn[items]){\n                    dp[items][oxygen][nitrogen]=min(dp[items-1][oxygen][nitrogen],wt[items]);   \n                    }\n                    else{\n                    dp[items][oxygen][nitrogen]=INT_MAX;\n                    }\n#if DEBUG\n                printf(\"\\ndp[%d][%d][%d]=%d\",items,oxygen,nitrogen,dp[items][oxygen][nitrogen]);\n#endif\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[num][o][n]);\n    }\n\n}\n```\n\n    ", "Answer": "\r\nYour program will fail when n=1000 because you are using 1-based indexing for the test cases, and therefore you will be accessing elements beyond the ends of your arrays.\n\nSolution: use 0-based indexing (best solution) or increase the array sizes to 1001 (ugly hack).\n\nThere may be other bugs too, but this one definitely needs to be fixed.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Using Knapsack approach without value?\r\n                \r\nRegarding to  question, I am wondering that  according to the following approach:\nAssume that there is no value and\nI am wondering that which approach or algorithm should be used for a Knapsack problem when the values are equal and there is a parameter (called n) that describes times for carrying items in a time?\nFor example, the bag has 3kg capacity and there are some blocks with the weight of 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 2.5, 2,75. Then we want to carry all the blocks with the minimum number of times (n). In this scenario, should I use Knapsack approach by giving value as 1. Or should I use completely another approach? Any idea?\n    ", "Answer": "\r\nKnapsack problem calculates maximum profit,So you obtain maximum number of times(n) if you assume all value as 1.\nBut if you set all values as -1 and find max profit, you can achieve your goal.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving Coin Change using knapsack . Reference : Another Knapsack Hackerrank CodeAgon\r\n                \r\nThe problem is fairly simple and straight .However i cannot solve it exclusively using dp knapsack style . I have solution for that but since the number of coins in each denomination here is limited (in this question it's )it's creating a problem . I want to arrive at a 2d recurrence that i can use to implement the knapsack . \nMy actual solution which runs fine goes below : \n\n```\n#include<iostream> \nusing namespace std ; \nint main ()\n{ int flag ;\n  int N,i ; \n  int sum ; \n  int counter ; \n  while (cin >> N >>sum )\n  {  \n    counter = 0; \n    flag= 0 ;\n    int count =0; \n    for( i = N ; i>=1;i--){\n      count += i ;\n      counter++;\n      if (count >sum){\n      count-=i ;\n      counter -- ;  \n      }\n      if(count == sum){\n      flag = 1 ;\n      break ; \n      }\n      }\n if (flag==1)\n cout << counter<<\"\\n\" ;\n else cout <<-1<<\"\\n\" ;\n}\nreturn 0 ;\n}\n```\n\n    ", "Answer": "\r\nDynamic programming solution is not required for the problem as the constraint are quite high.A simple greedy approach would work fine.\n\nThe algorithm works as follows:\n\n\nIf the sum of all the values form 1 to n is less than m then you cannot pay m coins because even after using all the n coins you have money remaining to be paid.\nIf the sum of all the values form 1 to n is greater than or equal to m then you can definitely pay because you have enough coins.\nSince you have to minimize the number of coins to be given you consecutively pick coins that have the maximum value until your m become zero and you need to only keep track of number of coins that you have picked.\n\n\nBelow is the code that implements the above algorithm\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int n, m;\n    cin >> n >> m;\n    if (m > (n * (n + 1) / 2)) {\n        //if sum of all coins form 1 to n is less than m\n        cout << \"-1\";\n    } else {\n        int cnt = 0;\n        while (m != 0) {\n            if (n >= m) {\n                m = 0;\n            } else {\n                m -= n;\n                --n;\n            }\n            ++cnt;\n        }\n        cout << cnt;\n    }\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "minimizaton of 0/1 knapsack with additional constraint\r\n                \r\nI have the same problem as here:\nVariation on knapsack - minimum total value exceeding 'W'\nwith an added constraint.\n\nDetails:\n\nWe have a group of items, each item (i) has a weight (w_i) and a value (v_i) and a price(p_i). We have to select a subgroup of these items such that: \n\n\nminimize the total aggregate value \n\n\ns.t.\n\n\ntotal aggregate weight is at least W. \ntotal aggregate price is at most P.\n\n\nIf we ignore the last constraint, this is equivalent of 0/1 knapsack problem and can be solved as amit mentioned in the question linked above. With the addition of last constraint is it still solvable using dynamic programming ?\n\nAny tips are appreciated.\n    ", "Answer": "\r\nSince it is a NP-hard problem, you just have to test all cases.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "find items in knapsack bag\r\n                \r\nI want to solve the knapsack problem recursively in C#. This is my code:\n\n```\npublic  int f(int n, int remain)\n{\n    if (n < 0) return 0;\n    if (w[n] > remain)\n    {\n        //    Thread.VolatileWrite(ref   check[n], 0);\n        check[n] = 0;\n        return f(n - 1, remain);\n    }\n    else\n    {\n        int a = f(n - 1, remain);\n        int b = p[n] + f(n - 1, remain - w[n]);\n        if (a >= b)\n        {\n            //   Thread.VolatileWrite(ref   check[n], 0);\n            check[n] = 0;\n            return a;\n        }\n        else\n        {\n            //  Thread.VolatileWrite(ref   check[n], 1);\n            check[n] = 1;\n            return b;\n        }\n    }\n}\n```\n\n\n```\nw```\n is an array that holds weights and ```\np```\n is an array that holds prices. ```\nn```\n is the number of items and ```\nremain```\n is the maximum weight.\n\nMy problem is with the ```\ncheck```\n array. I have used this array to store items that are going to be in the bag but it does not work always, sometimes the solution is right and sometimes not. I have tried everything but could not figure it out. How can I solve this?\n    ", "Answer": "\r\nThe usage of the check array is wrong, since it indicates the last assignment, and it does not have to be the one chosen.\n\nHere is a counter example that explains why it does not work.\n\nAssume:\n\n```\nweights = [1,2]\nvalues = [2,1]\nw = 2\n```\n\n\nNow, let examine what will happen:\n\n```\nf(1,2):\n   f(0,2):\n       f(-1,2)  = 0\n       a = 0\n       f(-1,1) = 0\n       b = 2 + 0 = 2\n       b>a -> check[0] = 1\n    return f(0,2) = 2\n    a = 2\n    f(0,0):\n       w[0] > 0: check[0] = 0\n       return f(-1,0) = 0\n    return f(0,0) = 0\n    b = 1 + 0 = 1\n    a > b: check[1] = 0\nreturn  f(1,2) = 2\n```\n\n\nSo, the optimal solution to this problem is 2 (chosing the 2nd element), but your solution chose no element (check = [0,0])\n\nThis happens because the changing of ```\ncheck```\n is global, and not local to the calling environment, and specifically - the assignment in deep levels do not depend on the choice you made in higher levels.\n\nTo handle it you can either:\n\n\nmake your list not global, and each recursive call will have its own\ninstance of a list. The \"parent\" call will chose not only which\nvalue to take, but according to this choice - the parent will also\nchose the list it will use, and append \"his\" choice to it, before forwarding  up to its parent.\nSwitch to a DP solution, or mimic the DP solution, and then use the table you created to figure out which elements to chose as I described in this thread: How to find which elements are in the bag, using Knapsack Algorithm [and not only the bag's value]?\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Haskell Knapsack\r\n                \r\nI've written an answer to the bounded knapsack problem with one of each item in Scala, and tried transposing it to Haskell with the following result:\n\n```\nknapsack :: [ ( Int, Int ) ] -> [ ( Int, Int ) ] -> Int -> [ ( Int, Int ) ]\nknapsack xs [] _   = xs\nknapsack xs ys max =\n    foldr (maxOf) [ ] [ knapsack ( y : xs ) ( filter (y /=) ys ) max | y <- ys\n        , weightOf( y : xs ) <= max ]\n\nmaxOf :: [ ( Int, Int ) ] -> [ ( Int, Int ) ] -> [ ( Int, Int ) ]\nmaxOf a b = if valueOf a > valueOf b then a else b\n\nvalueOf :: [ ( Int, Int ) ] -> Int\nvalueOf [ ]        = 0\nvalueOf ( x : xs ) = fst x + valueOf xs\n\nweightOf :: [ ( Int, Int ) ] -> Int\nweightOf [ ]        = 0\nweightOf ( x : xs ) = snd x + weightOf xs\n```\n\n\nI'm not looking for tips on how to clean up the code, just to get it working. To my knowledge it should be doing the following:\n\n\nFor each tuple option (in ys)\n\nif the weight of the current tuple (y) and the running total (xs) combined is less than the capacity\nget the optimal knapsack that contains the current tuple and the current total (xs), using the available tuples (in ys) less the current tuple\n\nFinally, get the most valuable of these results and return it\n\n\n*Edit: * Sorry, forgot to say what's wrong... So it compiles alright, but it gives the wrong answer. For the following inputs, what I expect and what it produces:\n\n```\nknapsack [] [(1,1),(2,2)] 5\nExpect: [(1,1),(2,2)]\nProduces: [(1,1),(2,2)]\n\nknapsack [] [(1,1),(2,2),(3,3)] 5\nExpect: [(2,2),(3,3)]\nProduces: []\n\nknapsack [] [(2,1),(3,2),(4,3),(6,4)] 5\nExpect: [(2,1),(6,4)]\nProduces: []\n```\n\n\nSo I was wondering what could be the cause of the discrepancy?\n\nThe solution, thanks to sepp2k:\n\n```\nks = knapsack []\n\nknapsack :: [ ( Int, Int ) ] -> [ ( Int, Int ) ] -> Int -> [ ( Int, Int ) ]\nknapsack xs [] _   = xs\nknapsack xs ys max =\n    foldr (maxOf) [ ] ( xs : [ knapsack ( y : xs ) ( ys #- y ) max\n                             | y <- ys, weightOf( y : xs ) <= max ] )\n\n(#-) :: [ ( Int, Int ) ] -> ( Int, Int ) -> [ ( Int, Int ) ]\n[ ]        #- _ = [ ]\n( x : xs ) #- y = if x == y then xs else x : ( xs #- y )\n\nmaxOf :: [ ( Int, Int ) ] -> [ ( Int, Int ) ] -> [ ( Int, Int ) ]\nmaxOf a b = if valueOf a > valueOf b then a else b\n\nvalueOf :: [ ( Int, Int ) ] -> Int\nvalueOf [ ]        = 0\nvalueOf ( x : xs ) = fst x + valueOf xs\n\nweightOf :: [ ( Int, Int ) ] -> Int\nweightOf [ ]        = 0\nweightOf ( x : xs ) = snd x + weightOf xs\n```\n\n\nWhich returns the expected results, above.\n    ", "Answer": "\r\nYour first case fires when ```\nys```\n contains. so for ```\nknapsack [foo,bar] [] 42```\n, you get back ```\n[foo, bar]```\n, which is what you want. However it does not fire when ```\nys```\n contains nothing except elements that would put you over the max weight, i.e. ```\nknapsack [(x, 20), (y,20)] [(bla, 5)]```\n will return ```\n[]```\n and thus discard the previous result. Since this is not what you want you should adjust your cases so that the second case only fires if there's at least one element in ```\nys```\n that's below the max weight.\n\nOne way to do that would be to throw out any elements that put you over the max weight when recursing, so that that scenario simply can't happen.\n\nAnother way would be to switch the order of the cases and add a guard to the first case that says that ```\nys```\n must contain at least one element that does not put you over the total weight (and adjust the other case to not require ```\nys```\n to be empty).\n\nPS: Another, unrelated problem with your code is that it ignores duplicates. I.e. if you use it on the list ```\n[(2,2), (2,2)]```\n it will act as if the list was just ```\n[(2,2)]```\n because ```\nfilter (y /=) ys```\n will throw out all occurrences of ```\ny```\n, not just one.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with min weight\r\n                \r\nThis variation of the knapsack problem requires a minimum weight. The goal is to minimize the cost while achieving at least the minimum weight.\nFor example, we have 6 items with weights ```\n{1, 1, 1, 5, 13, 3}```\n and costs ```\n{1, 1, 1, 5, 10, 12}```\n.\nAssume a minimum weight of 15.\nThe optimal solution is items ```\n{1, 2, 5}```\n for a total weight of 15 and cost 12.\nHow should I go about implementing this algorithm as efficiently as possible? Greedy choices don't work, so should I modify the original dynamic programming solution to fit this problem? If so, how?\nIf it matters, I'm planning to write this in Java.\n    ", "Answer": "\r\nLet ```\nminCost[i]```\n denote the minimum value that a knapsack with capacity ```\ni```\n can hold, ```\ncosts[i]```\n represent the cost of the ith item, and ```\nweights[i]```\n represent the weight of the ith item. Then, for each i, ```\nminVal[i]```\n is the minimum of ```\nminVal[i - weights[j]] + costs[j]```\n for all ```\nj```\n from 1 to the number of items.\nThen, the answer is the minimum value in the ```\nminCost```\n array in the range from the minimum weight to the maximum weight.\n```\nfinal int[] weights = {1, 1, 1, 5, 13, 3}, costs = {1, 1, 1, 5, 10, 12};\nfinal int minWeight = 15;\nint maxWeight = 0;\nfor(final int weight: weights){\n    maxWeight += weight;\n}\nfinal int[] minCost = new int[maxWeight + 1];\nfor(int i = 1; i <= maxWeight; i++){\n    minCost[i] = Integer.MAX_VALUE;\n}\nfor(int i = 0; i < weights.length; i++){\n    for(int j = maxWeight; j >= weights[i]; j--){\n        if(minCost[j - weights[i]] != Integer.MAX_VALUE){\n            minCost[j] = Math.min(minCost[j], minCost[j - weights[i]] + costs[i]);\n        }\n    }\n}\nint answer = Integer.MAX_VALUE;\nfor(int i = minWeight; i <= maxWeight; i++){\n    answer = Math.min(answer, minCost[i]);\n}\nSystem.out.println(answer);\n```\n\nDemo\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "A variant of the 2D knapsack or square packing\r\n                \r\nI am dealing with an optimisation issue, which I classified as a combinatorial problem. Now, I know this is a 2D variant of the knapsack problem, but please bear with me:\n\nIf I have an area that is modeled as a grid comprised of equal size cells, how to place a certain number of square objects of different sizes, on this  grid area, if every object has its cost and its benefit and the goal is to have an arrangement of the objects that has the maximum Benefit/Cost ratio:\n\n\nObject 1: 1x1 square, cost = 800, value= 2478336 \nObject 2: 2x2 square    cost= 2000 value = 7565257\nObject 3: 3x3 square cost= 3150 value=    14363679\n\n\nThe object 3 has the best value/cost ratio, so the approach would be a greedy one I guess, to first place as much of the bigger squares as possible, but still there are many optimal solutions depending on the size of the area.\n\nAlso, the square objects cannot overlap.\nI am using R for this, and the package adagio has algorithms for the single and multiple knapsack, but not for a 2D knapsack problem. Because I am very new in optimization and programming, I am not sure if there is way of solving this problem with R, can someone please help?\nThanks!\n    ", "Answer": "\r\nFirstly, I'm not an expert in R and adagio. Secondly, I think that your problem is not exactly 2d knapsack, it looks like a variant of packing problem, so it requires a different approach.\n\nSo, first, check this awesome list of R optimization packages, especially the following sections:\n\n\nSpecific Applications in Optimization (for example, tabu search could be useful for you)\nMathematical Programming Solvers/Interfaces to Open Source Optimizers (lpsolve definitely could solve your task)\nGlobal and Stochastic Optimization (some of this packages could be used to solve your task)\n\n\nIn case if you're not tied to R, consider Minizinc as a solver. It's very easy to install/use and it's pretty efficient in terms of memory/time consumption. Moreover, there is a bunch of great examples how to use it.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Haskell, list of list of different types, retriving values (frac knapsack prob)\r\n                \r\nI am trying to do the fractional knapsack problem in haskell so far I have\n\nCode:\n\n```\n{- Input \"how much can the knapsack hole <- x\" \"Possible items in sack [(label, value, weight), ...]\" -}\nknap x [] = []\nknap x y = if length y == 1 then \n```\n\n\nThe input list is in the form [([Char], Integer, Integer), ... ] a list of lists of (list of chars, integer, and integer). \n\nMy problem is trying to pull out the label, value, and weight of each item that could possibly be put in the knapsack. (pulling values out of the list of lists)\n\nIn my prelude> prompt I am doing some trying by doing\n\nghci output:\n\n```\nPrelude> let x = [(\"label 1\", 2, 14), (\"label 2\", 1, 15)]\nPrelude> :t x\nx :: [([Char], Integer, Integer)]\nPrelude> length x\n2\nPrelude> x !! 0\n(\"label 1\",2,14)\nPrelude> x !! 0 !! 1\n\n<interactive>:1:1:\n    Couldn't match expected type `[a0]'\n                with actual type `([Char], Integer, Integer)'\n    Expected type: [[a0]]\n      Actual type: [([Char], Integer, Integer)]\n    In the first argument of `(!!)', namely `x'\n    In the first argument of `(!!)', namely `x !! 0'\n```\n\n\nAs you can see I am trying to do list !! index !! index to try and pull a weight off of a \"item\". What is the proper syntax to do this?\n    ", "Answer": "\r\nWell, the ```\n!!```\n operator only works on lists, as you can see from its type signature: ```\n[a] -> Int -> a```\n.\n\nIf you'd like to stick with tuples, you could define your own functions for 3-tuples in the style of ```\nfst```\n and ```\nsnd```\n. You could do this with pattern matching; something like:\n\n```\nfirst :: (a,b,c) -> a\nfirst (a,_,_) = a\n```\n\n\nHowever, it might be better to design a datatype for an item, and use records to extract the field you need. \n\n```\ndata Item = Item { label  :: String\n                   value  :: Int\n                   weight :: Int\n                 }\n```\n\n\nThen to make a new item ```\nx```\n you can use ```\nlet x = Item {label = \"label 1\", value = 2, weight = 14}```\n\n\nNow you could model your knapsack as a list of items of type ```\n[Item]```\n, and to get the value of the first item, you could use ```\nvalue $ knapsack !! 0```\n, where ```\nknapsack```\n is your list of items.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "multidimensional knapsack coding in objective-c\r\n                \r\nI am new here so bear with me in my best attempts at formulating detailed questions in keeping with the spirit of this site.\n\nI am working within objective-c on an algorithm for a multidimensional knapsack problem in which there is a number on user determined constraints.  In this instance of baseball players:\n\nI want to solve for creating a list from a database of players based on the cumulative constraints of:\n\n\nsalary (equal or as close to 100 million)\nhome runs (total equal to or as close to 150)\nRBIs (equal to or as close to 200)\n\n\nand Yes or No selections of \n\n\nover/under age of 30: Yes or No\nBorn outside U.S: Yes or No\n\n\nI have had luck in finding some help with coding for a simple knapsack problem in which there are 2 dimensions involved (weight and value) but not so much in finding answers for multiple dimensions beyond that.\n\nCan anyone offer some advice on this for me? Thank you in advance.\n    ", "Answer": "\r\nIf you have a lot of constraints, then probably the best way to formulate and solve this problem is as an integer linear program (you can look it up online). First divide each dimension by the target total sum so that each target total sum is 1.0. Then define a variable Xi for each player which is either 0 or 1 (i.e. greater than or equal to 0 and less than or equal to 1) which is 1 if the player i is included and 0 if the player i is not included. Then for each dimension (salary, homeruns, RBIs, etc.) let Ci be the normalized value for player i. Then you have the constraint C1X1 + C2X2 + ... + CnXn <= 1.0 for each dimension. And to get as close as possible to the target values overall, you want to maximize the grand total sum of all terms CiXi over all players and over all dimensions. There are integer linear programming solvers available online, some for free.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack: Find Solution Set in Space-Optimised Implementation\r\n                \r\nI want to solve a 0-1 Knapsack problem with a maximum weight of ~ 200k and over 100k elements and eventual determination of the item set rather than only the optimal weight.\n\nResearching 0-1 Knapsack, I read that a common way to solve this problem is via dynamic programming and creating a table containing optimal solutions for subproblems, thus splitting up the original problem into smaller parts and later backtracing on the table to determine the item set. The maximum profit, without regard for the items taken, can be calculated in a memory efficient manner (as outlined here). \n\nThe obvious issue here is that for the dimensions I have in mind, this approach would consume more memory than is feasible (requiring ```\nO(n*W)```\n space, with ```\nn```\n being the number of elements and ```\nW```\n being the maximum capacity). Researching further I found mention (here for example, also see \"Knapsack Problems\" by Kellerer, Pferschy and Pisinger) of a memory efficient way to solve 0-1 Knapsack.\n\nWe start by splitting up the item set up into two subsets, roughly equal in size. We treat both subsets as their own knapsack problem given the original maximum weight ```\nW```\n and determine the last row of the maximum profit calculation for both subsets in the memory-efficient way (detailed above).\n\nThe next step is to find out where to optimally split the two subsets. To do this, we determine the maximum profit for weight ```\nw1```\n and ```\nw2```\n of the two rows. As I understand, it is critical to maintain ```\nw1 + w2 = W```\n, so I iterate through the first row and take the index on the opposite end of the current index. My current implementation for this step looks like this:\n\n```\ndef split(weights, values, n, w, i):\n    # s1 is the bigger subset size if n is not even\n    s1 = n // 2 + (n&1)\n    s2 = n // 2\n\n    row1 = maximum_profit(weights, values, s1, w)\n    row2 = maximum_profit(weights[s1:], values[s1:], s2, w)\n\n    max_profits_for_capacity = [x + y for x, y in zip(row1, row2[::-1])]\n    max_profits = max(max_profits_for_capacity)                           \n    optimal_weight_index = max_profits_for_capacity.index(max_value)\n\n    c1 = row1[optimal_weight_index]\n    c2 = row2[w-optimal_weight_index-1]\n```\n\n\n```\nc1```\n and ```\nc2```\n are the maximum profits for each of the subsets then while maintaining ```\nc1 + c2 = W```\n. With these values we recurse into each of the subsets:\n\n```\nsplit(weights[:s1], values[:s1], s1, c1, i)      \nsplit(weights[s1:], values[s1:], s2, c2, i+s1)\n```\n\n\nThis is where the descriptions lose me. Eventually this code will recurse to ```\nn == 1```\n with a value of ```\nw```\n. How do I determine if an element is included given an item index ```\ni```\n and a maximum (local) capacity ```\nw```\n?\n\nI can provide a small example data set to illustrate the workings of my code in detail and where it goes wrong. Thank you very much.\n    ", "Answer": "\r\nFirst, I guess you have a mistake saying about ```\nc```\n, ```\nw```\n and their relation as capacity, but getting ```\nc1```\n and ```\nc2```\n from profit lists. \n\nTo the question, by the returning value of your split function you can define what type of question you are answering.\n\nAs you take the split direct to ```\nn == 1```\n point and you want to get the indices of the picked items into knapsack, you can simply at this step return the value consisting of ```\n[0]```\n or ```\n[1]```\n as the output:\n\n```\nif n == 1:\n  if weights[0] < w:\n    return [1]\n  return [0]\n```\n\n\n\n```\n[1]```\n means picking the item into resulting set\n```\n[0]```\n otherwise\n\n\nthen concatenate them into one during other steps of recurse of your ```\nsplit```\n function like:\n\n```\ndef split(..):\n  ..\n  # since it is lists concatenation\n  return split(weights[:s1], values[:s1], s1, c1, i) + split(weights[s1:], values[s1:], s2, c2, i+s1)\n```\n\n\nIn result you will get list of size ```\nn```\n (for the number of items you make splits) with zeroes and ones.\n\nTotal complexity would be:\n\n\n```\nO(nWlogn)```\n for time, since we make splits till the ```\nn == 1```\n step\n```\nO(W)```\n for memory, since we store always only a part of the resulting list when recurse\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm, large capacity\r\n                \r\nI'm currently in developing a playlist player and im facing a problem. I have gaps of variable length in my playlist that i want to fill with special audio files. These files also have a variable length, usually shorter then the gap i have in my playlist.\n\nThis sounds like a classic knapsack problem, so i tried to implement this algorithm. This works fine for smaller gaps, but whenever i have a gap of 30 minutes the algorithm uses extreme amount of memory. This is expected because im using dynamic programming to solve the problem.\n\nThe knapsack has a capacity of {gap in milliseconds} and the knapsack items have the weight of the audio files in milliseconds.\n\nThis is extremely innefficient. So i was wondering if i could use a different algorithm, or maybe change the weight and capacity into smaller variables. So far i was thinking of dividing everything by an arbitrary number, but il lose precision if i do so.\n\nAnyone has any ideas?\n\nEdit:\n\nI have about 500 fillers to fill the gap. And changing the pitch is not possible. \nThe set of fillers should have a perfect solution. \nI really want millisecond precision but I can live with under 100ms off. \n    ", "Answer": "\r\nYou said play-list so I'm assuming you have songs, and a typical song is about 3 minutes so your solution will be about 10 songs. Thus you can divide all your times by 50 and then the typical error for a song will be plus or minus 25 milliseconds and so for 10 random songs the error will usually be about (25 milliseconds * sqrt(10)) < 100 milliseconds. If you want better guarantees on the error then you can divide your song times and target time by 20 or 10, but certainly if you divide your times by 10 then you should very, very rarely get an error above 100 milliseconds. And a divide by 10 means you divide memory by 10 for the exact O(WN) dynamic programming solution so it can make the difference between fitting into memory and not if you are on the borderline.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 knapsack dynamic programming with two constraints\r\n                \r\nFor a 0-1 knapsack problem with given weights and values of ```\nn```\n items, and a maximum weight capacity ```\nW```\n, I know it can be solved with a double nested loop using dynamic approach. \n\nMy question is if we say that each of the ```\nn```\n items have an additional \"volume\" value and a maximum volume capacity ```\nV```\n, then how do I change the algorithm? Will the algorithm becomes a triple nested loop with time complexity ```\nO(n*W*V)```\n?\n    ", "Answer": "\r\nIf there is a weight and volume constraint then this is an instance of the multi-dimensional 0-1 knapsack problem. The two dimensional knapsack problem is computationally harder than the one dimensional case so the algorithm you use for the 1D case simply no longer works. For 2D and above the 0-1 knapsack problem is NP-complete.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "knapsack with variety of items\r\n                \r\nSuppose a regular knapsack problem: you have a weight constraint, ```\nC```\n, the number of items with ```\nValue```\n and ```\nWeight```\n ```\n(V, W)```\n. You want to maximize the ```\nV```\n while ```\nW```\n being under the ```\nC```\n. In this question, you can only have one of each item.\n\nBut there is an additional twist to the problem. You want to have a variety of items. Suppose the question states that you want to have at least 5 (or any number) of different items. If a solution has any less than 5 different items, the answer is not valid. Is there an approach to this problem that solves this?\n    ", "Answer": "\r\nIt's just another form of constraint, so lets see how Weight (at most C weight) and Diversity (at least 5 different items) differ:\n\n\nWeight starts as a valid (empty bag is below C), while Diversity starts as invalid (empty bag doesn't contain 5 different items).\n\n\nThe first thing to note is, that with the additional constraint you need a notion of invalid / unsolvable, because if there aren't 5 different items that satisfy the weight constraint, there is no solution.\n\nOnce you defined a way to return some ```\ninvalid```\n result, it's really close to the standard knapsack problem. In recursion, just pass remaining allowed Weight and current Diversity. In the recursion anchor case, check Diversity and return ```\ninvalid```\n if Diversity does not meet requirements, otherwise return the result like in the normal knapsack problem. Check recursion results for ```\ninvalid```\n and treat it accordingly.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How can I Solve a 0-1 Multi(constraint/dimensional) Knapsack Problem?\r\n                \r\nI have a 5 bag and 200 items with values. The issue is that each item has a different weight on a different bag, and all bags have different capacities.\n```\nFor bag example:\nBag 1 capacity = 500\nBag 2 capacity = 200\netc....\n\nFor item example:\nItem 1 weight for = bag1:50, bag2:70, bag3:15 etc...\nItem 2 weight for = bag1:1, bag2: 90, ......\netc....\n```\n\nEach bag must have the same item inside of them. So if I put the item 1 to the bag1, I have to put that item to the other bags, so the capacity of any bag must not be passed.\nHow can I find the maximum value items that can be inside of these bags? What should I search or how can I solve that? I researched a lot but could not find an understable solution or a code.\nA sample data with constraints is here:\n```\nnum of knapsacks = 2\nknapsack1 capacity = 600\nknapsack2 capacity = 500\nnum of items = 28\n\nvalues of each item:\n1898 440 22507 270 14148 3100 4650 30800 615 4975 1160 4225 510 11880 479 440 490 330 110 560 24355 2885 11748 4550 750 3720 1950 10500\n\nitem weights for knapsack1 (in same order with item values)\n45 0 85 150 65 95 30 0 170 0 40 25 20 0 0 25 0 0 25 0 165 0 85 0 0 0 0 100\n\nitem weights for knapsack2\n30 20 125 5 80 25 35 73 12 15 15 40 5 10 10 12 10 9 0 20 60 40 50 36 49 40 19 150\n```\n\nThe itemset that satisfies the sample data is:\n```\nSum of values = 138821\nValues: 1898 22507 14148 3100 4650 30800 4975 11880 490 24355 11748 4550 3720\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Python 3: IndexError: list index out of range while doing Knapsack Problem\r\n                \r\nI am currently self-learning python for a career change. While doing some exercises about 'list', I encountered  IndexError: list index out of range.\nSo, I am trying to build a function, that determines which product should be placed on my store's shelves. But, I also put constraints.\n\nThe shelve has a max capacity of 200\nsmall-sized items should be placed first\nif two or more items have the same size, the item with the highest price should be placed first\n\nAs an input for the function, I have a list of tuples \"dairy_items\", denoted as [(id, size, price)].\nThis is my code:\n```\ncapacity=200\n\ndairy_items=[('p1', 10, 3), ('p2', 13, 5),\n            ('p3', 15, 2), ('p4', 26, 2),\n            ('p5', 18, 6), ('p6', 25, 3),\n            ('p7', 20, 4), ('p8', 10, 5),\n            ('p9', 15, 4), ('p10', 12, 7),\n            ('p11', 19, 3), ('p12', 27, 6),\n            ('p13', 16, 4), ('p14', 23, 5),\n            ('p15', 14, 2), ('p16', 23, 5),\n            ('p17', 12, 7), ('p18', 11, 3),\n            ('p19', 16, 5), ('p20', 11, 4)]\n\ndef shelving(dairy_items):\n    #first: sort the list of tuples based on size: low-to-big\n    items = sorted(dairy_items, key=lambda x: x[1], reverse=False)\n    #second: iterate the sorted list of tuples.\n    #agorithm: retrieve the first 2 elements of the sorted list \n            #then compare those two elements by applying rules/conditions as stated\n                #the 'winning' element is placed to 'result' and this element is removed from 'items'. Also 'temp' list is resetted\n                #do again untill shelves cannot be added anymore (capacity full and do not exceeds limit) \n    result = []\n    total_price = []\n    temp_capacity = []\n    temp = items[:2]\n    while sum(temp_capacity) < capacity:\n        #add conditions: (low first) and (if size the same, highest price first)\n        if (temp[0][1] == temp[1][1]) and (temp[0][2] > temp[1][2]):\n            temp_capacity.append(temp[0][1])\n            result.append(temp.pop(0))\n            items.pop(0)\n            temp.clear()\n            temp = items[:2]\n            total_price.append(temp[0][2])\n        elif ((temp[0][1] == temp[1][1])) and (temp[0][2] < temp[1][2]):\n            temp_capacity.append(temp[1][1])\n            result.append(temp.pop())\n            items.pop()\n            temp.clear()\n            temp = items[:2]\n            total_price.append(temp[1][2])\n        else:\n            temp_capacity.append(temp[0][1])\n            result.append(temp.pop(0))\n            items.pop(0)\n            temp.clear()\n            temp = items[:2]\n            total_price.append(temp[0][2])\n    result = result.append(temp_capacity)\n    #return a tuple with three elements: ([list of product ID to be placed in order], total occupied capacity of shelves, total prices)\n    return result \n\n\n```\n\n```\nc:\\Users\\abc\\downloads\\listexercise.py in <module>\n----> 1 print(shelving(dairy_items))\n\nc:\\Users\\abc\\downloads\\listexercise.py in shelving(dairy_items)\n     28     while sum(temp_capacity) < capacity:\n     29 \n---> 30         if (temp[0][1] == temp[1][1]) and (temp[0][2] > temp[1][2]):\n     31             temp_capacity.append(temp[0][1])\n     32             result.append(temp2.pop(0))\n\nIndexError: list index out of range\n```\n\nEDIT:\nThis is the expected result:\n```\n#Result should be True\nprint(shelving(dairy_items) == (['p8', 'p1', 'p20', 'p18', 'p10', 'p17', 'p2', 'p15', 'p9', 'p3', 'p19', 'p13', 'p5', 'p11'], 192, 60))\n\n```\n\n    ", "Answer": "\r\nThe ```\nIndexError```\n occured because, you had tried to append the 2nd element after popping it from ```\ntemp```\n because, after popping it out, there will be only one element in ```\ntemp```\n which can indexed with ```\n0```\n.\nAlso I noticed a few more bugs which could hinder your program from giving the correct output and rectified them.\nThe following code will work efficiently...\n```\nfrom time import time\n\nstart = time()\n\ncapacity = 200\n\ndairy_items = [('p1', 10, 3), ('p2', 13, 5),\n            ('p3', 15, 2), ('p4', 26, 2),\n            ('p5', 18, 6), ('p6', 25, 3),\n            ('p7', 20, 4), ('p8', 10, 5),\n            ('p9', 15, 4), ('p10', 12, 7),\n            ('p11', 19, 3), ('p12', 27, 6),\n            ('p13', 16, 4), ('p14', 23, 5),\n            ('p15', 14, 2), ('p16', 23, 5),\n            ('p17', 12, 7), ('p18', 11, 3),\n            ('p19', 16, 5), ('p20', 11, 4)]\n\ndef shelving(dairy_items):\n    items = sorted(dairy_items, key=lambda x: x[1])\n    result = ([],)\n    total_price, temp_capacity = 0, 0\n\n    while (temp_capacity+items[0][1]) < capacity:\n        temp = items[:2]\n\n        if temp[0][1] == temp[1][1]:\n            if temp[0][2] > temp[1][2]:\n                temp_capacity += temp[0][1]\n                result[0].append(temp[0][0])\n                total_price += temp[0][2]\n                items.pop(0)\n            elif temp[0][2] < temp[1][2]:\n                temp_capacity += temp[1][1]\n                result[0].append(temp[1][0])\n                total_price += temp[1][2]\n                items.pop(items.index(temp[1]))\n            else:\n                temp_capacity += temp[0][1]\n                result[0].append(temp[0][0])\n                total_price += temp[0][2]\n                items.pop(0)\n        else:\n            temp_capacity += temp[0][1]\n            result[0].append(temp[0][0])\n            total_price += temp[0][2]\n            items.pop(0)\n\n    result += (temp_capacity, total_price)\n    return result\n\na = shelving(dairy_items)\n\nend = time()\n\nprint(a)\n\nprint(f\"\\nTime Taken : {end-start} secs\")\n```\n\nOutput:-\n```\n(['p8', 'p1', 'p20', 'p18', 'p10', 'p17', 'p2', 'p15', 'p9', 'p3', 'p19', 'p13', 'p5', 'p11'], 192, 60)\n\nTime Taken : 3.123283386230469e-05 secs\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "what is wrong with the function parameter?\r\n                \r\n```\n#include <iostream>\nusing namespace std;\n\ntemplate<class Type>\nvoid Knapsack(Type *v,int *w,int c,int n,Type **m)\n{\n int i,j;\n    int jMax=max(w[n]-1,c);\n    for(j=0;j<=jMax;j++)\n    m[n][j]=0;\nfor(j=w[n];j<=c;j++)\n    m[n][j]=v[n];\nfor(i=n-1;i>1;i--)\n{\n    for(j=0;j<=w[i]-1;j++)\n        m[i][j]=m[i+1][j];\n    for(j=w[i];j<=c;j++)\n    {\n        m[i][j]=max(m[i+1][j],m[i+1][j-w[i]]+v[i]);\n    }\n}\nm[1][c]=m[2][c];\nif(c>=w[1])\n    m[1][c]=max(m[2][c],m[1][c-w[1]]+v[1]);\n\n}\n\ntemplate <class Type>\nvoid TrackBack(Type **m,int *w,int c,int n,int *x){\nfor(int i=1;i<=n;i++)\n{\n    if(m[i][c]==m[i+1][c])\n        x[i]=0;\n    else\n        x[i]=1;\n}\n}\n\nint main()\n{\nint m[101][101]={0};\nint x[101];\nint n=5;\nint c=10;\nint w[5]={2,2,6,5,4};\nint v[5]={6,3,5,4,6};\n\nKnapsack(v,w,c,n,m);\n\n\nreturn 0;\n}\n```\n\n\nI an writing the algorithm of 01 Knapsack problem.\n\nmy Xcode says \"No matching function for call to 'Knapsack'  \"\nI am stumbled by the red alarm.\n\nI'm confused for passing arguments.\n\nIs there anyone can help me? Thanks a lot:)\n    ", "Answer": "\r\nThis is not a valid conversion:\n\n```\nint m[101][101]\n...\nKnapsack(v,w,c,n,m);\n              // ^-- expects a Type **m\n```\n\n\n```\nm```\n can decay to type \"pointer to array of 101 ints\", but no further.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "why 0/1 knapsack using dynamic programming is not polynomial time algorithm\r\n                \r\nI have difficuities understanding why 0/1 knapsack using dynamic programming is not polynomial time solvable. Similar question had been asked here. Why is the knapsack problem pseudo-polynomial?. Someone gave explanation, but I still don't get why should we consider the binary representation for the weight input. How about n, if it's considered in binary representation, can I say it's exponentional to number of the items? Similarly, for any other polynomial time algorithms I can claim them having exponentional time complexity, because every input are represented in binary digits in computer. I know I were wrong. Can someone point out why in a easy understanding way? Thanks in advance.\n    ", "Answer": "\r\nA very simple way of thinking about it is that if you double the limit, the size of the input only increases by one bit (since the limit is part of the input), while the run time is doubled. That is clearly exponential behavior with respect to the input size.\n\nHowever, while doubling the number of items also doubles the run time, it also doubles the size of the input items, so that part of the relationship between input size and run time is only linear.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Solving a Knapsack prob with 'min value' constraints on each item\r\n                \r\nEvery item has three properties\n\n\nThe size of the item Si\nThe value of the item Vi\nThe minimum value required to add the item into the knapsack Mi (<= 107)\n\n\nThe will be atmost 100 items.\n\nWe are given the size of the knapsack K (K <= 1000) and the initial value V (which takes no space in the knapsack).  An item 'i' can be put into the knapsack if and only if Mi is less than or equal to V. After adding the item in the knapsack V increases by Vi. We have to maximize the number of items (not the value) put into the knapsack of a given size. \n\nI have found this question which is similar . But the algorithm described in the answer is cubic time which will not be fast enough for this problem. How do we approach this problem in a better way ? \n    ", "Answer": "\r\nI can give out an O(n^3) algorithm here. I don't know if this question can be further optimized to O(n^2).\n\nFirst of all, this question is to maximize the number if items, which is a bit different with other knapsack problems. Meanwhile, it also has a restriction that a single item can only be chosen when the total value of knapsack is larger than its own value. So an obvious inference is, with the same number of items being chosen and fixed total size, the total value should be as large as possible(so that more items can be added to the knapsack).\n\nNotice that the number of items n(<=100) and the size of knapsack K(<=1000) is not very large, let f[i][j] means the maximum value when choose i items with total size j. Initially, all f[i][j] are set to 0 except f[0][0]=V.\n\nThen sort items based on their minimum value required to add. This is a greedy thinking because after sorting, we can go through each item only once.\n\nThe DP method looks like follow:\n\n```\nfor (int k=0;k<n;k++) //iterate items\n    for (int i=n;i>=0;i--)\n        for (int j=K;j>=0;j--) if (item.M[k]<=f[i][j])\n            f[i+1][j+item.S[k]]=max(f[i+1][j+item.S[k]],f[i][j]+item.V[k]);\n```\n\n\nAnd the final answer(the maximum number of items) is:\n\n```\nfor (int i=n;i>=0;i--)\n    for (int j=0;j<=K;j++)\n        if (f[i][j]) return i;\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 Knapsack with penalty for under and overweight cases\r\n                \r\nAssume a classic 0-1 knapsack problem but you are allowed to overflow/underflow the sack with some penalty. X profit is deducted for every unit overflow (weight above max capacity) and Y profit is deducted for every unit underflow (weight below max capacity).\n\nI thought of sorting all items by the ratio of profit to weight and then try to fill the sack like a normal knapsack problem then for remaining weight and items I calculate extra profit by taking the underflow, overflow in consideration.\n\nThis solution fails in some cases like when there are 3 items with weight 30,20,10 and profit 30, 25, 20 respectively. Max weight allowed is 39, underflow penalty is 5 and overflow penalty is 10.\n\nMy solution was to solve it like normal knapsack then considering penalties so it gives the solution of selecting items of weight 20,10 but then it does not add the item of weight 30 as its penalty is higher than profit. The optimal solution should be selection items of weight 30 and 10. The only thing I can think of now is to brute force which should be avoided if possible. If anyone could think of any other solution, that'd be great!\n    ", "Answer": "\r\nYou can break it into two subproblems, one with an underweight penalty and one with an overweight penalty. More specifically, you can solve the problem by solving two different integer linear programming problems, and taking the best of the two solutions:\n\nSay that you have ```\nn```\n items of weights ```\nw1,w2,...,wn```\n and values ```\nv1, v2, ...,  vn```\n. Say that the weight capacity is ```\nC```\n, the penalty for undeweight is ```\nA```\n and the penality for overweight is ```\nB```\n (per unit).\n\nIn both problems, let the binary decision variable be ```\nx1, ..., xn```\n indicating whether or not the corresponding item is selected.\n\nProblem 1)\n\n```\nmax v1*x1 + v2*x2 + ... + vn*xn - A*(C - w1*x1 - w2*x2 - ... - wn*xn)\n\nsubject to\n\nw1*x1 + w2*x2 + ... + wn*xn <= C\n```\n\n\nNote that via algebra the objective function is the same as the affine expression\n\n```\n(v1 + A*w1)*x1 + ... + (vn + A*wn)*xn - A*C \n```\n\n\nand is maximized at the same values ```\nx1, ..., xn```\n which maximize the purely linear function\n\n```\n(v1 + A*w1)*x1 + ... + (vn + A*wn)*xn \n```\n\n\nThis subproblem can be solved using any ILP solver, or just as an ordinary knapsack problem.\n\nProblem 2)\n\n```\nmax v1*x1 + v2*x2 + ... + vn*xn - B*(w1*x1 + w2*x2 + ... + wn*xn - C)\n\nsubject to\n\nw1*x1 + w2*x2 + ... + wn*xn >= C\n```\n\n\nwhich can be solved by maximizing the linear objective function\n\n```\n(v1 - B*w1)*x1 + ... + (vn - B*wn)*xn \n```\n\n\nAgain, that can be solved with any ILP solver. This problem isn't a knapsack problem since the inequality in the main constraint points in the wrong direction, though there might be some way of reducing it to a knapsack problem.\n\nOn Edit. The second problem can also be solved as a knapsack problem -- one in which you decide which items to not include. Start with the solution in which you include everything. If this isn't feasible (if the sum of all weights doesn't exceed the capacity) then you are done. The solution of problem 1 is the global solution. Otherwise. Define the surplus, S, to be\n\n```\nS = w1 + w2 + ... + wn - C\n```\n\n\nNow, solve the following knapsack problem:\n\n```\nweights: w1, w2, ..., wn //same as before\nvalues: Bw1 - v1, Bw2 - v2, ..., BWn - vn\ncapacity: S\n```\n\n\nA word on the values: ```\nBwi - vi```\n is a measure of how much removing the ith object helps (under the assumption that removing it keeps you above the original capacity so that you don't need to consider the underweight penalties). On the one hand, it removes part of the penalty, ```\nBwi```\n, but on the other hand it takes some value away, ```\nvi```\n. \n\nAfter you solve this knapsack problem -- remove these items. The remaining items are the solution for problem 2.\n\nLets see how this plays out for your toy problem:\n\n```\nweights: 30, 20, 10\nvalues: 20, 25, 20\nC: 39\nA: 5  //per-unit underflow penalty\nB: 10 //per-unit overflow penalty\n```\n\n\nFor problem 1, solve the following knapsack problem:\n\n```\nweights: 30, 20, 10\nvalues: 170, 125, 70  // = 20 + 5*30, 25 + 5*20, 20 + 5*10\nC: 39\n```\n\n\nThis has solution: include 20, 10 with value of 195. In terms of the original problem this has value 195 - 5*39 = 0. That seems a bit weird, but in terms of the original problem the value of using the last two items is 25 + 20 = 45 but it leaves you 9 units under with a penalty of 5*9 = 45 and 45 - 45 = 0\n\nSecond problem:\n\n```\nweights: 30, 20, 10\nvalues: 280, 175, 80  // = 10*30 - 20, 10*20 - 25, 10*10 - 20\nS: 26  // = 30 + 20 + 10 - 39\n```\n\n\nThe solution of this problem is clearly to select 20. This means that 20 is selected for non-inclusion. This means that for the second problem I want to include the objects of weights 30 and 10.\n\nThe value of doing so is (in terms of the original problem)\n\n```\n20 + 20 - 10*1 = 30\n```\n\n\nSince 30 > 0 (the value of solution 1), this is the overall optimal solution.\n\nTo sum up: you can solve your version of the knapsack problem by solving two ordinary knapsack problems to find two candidate solutions and then taking the better of the two. If you already have a function to solve knapsack problems, it shouldn't be too hard to write another function which calls it twice, interprets the outputs, and returns the best solution.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Can my recursive solution for Knapsack be improved?\r\n                \r\nI am trying to do knapsack problem and this is the recursive solution I came up with. Can this be made better? I think I need to add memoization by checking if I have reached this state before. Am i right that I need to add state for ```\nstate[c_w][i]```\n?  \n\nI intentionally have not used dynamic programming as i know the recurrence relations for that but rather wanted to get recursion right.\n\n```\n#include <stdio.h>\n\nint memoize[1000][1000];\nint max(int a, int b)\n{\n        return a>b?a:b;\n}\n\n/* c_w-current weight of the container */ \nint max_profit_func(int *val, int *wt, int W, int c_w, int i, int size)\n{\n        int max_profit = 0;\n        int j;\n\n        /* if the current item is beyond the range then we have 0 profit*/\n        if (i >= size)\n                return 0;\n        if (memoize[c_w][i] != -1)\n                return memoize[c_w][i];\n        /* get the profit with this index and if the profit is more than previous\n         * than store it */\n        for(j=i;j<size;j++) {\n                int profit = 0;\n                if (c_w+wt[j] <= W)\n                        profit = val[j] + max_profit_func(val, wt, W, c_w+wt[j], j+1, size);\n                max_profit = max(max_profit, profit);\n        }\n        memoize[c_w][i] = max_profit;\n        return max_profit;\n}\n\nint main(void) {\n        int val[] = {3, 7, 2, 9};\n        int wt[] = {2, 3, 4, 5};\n        int W = 5;\n\n        memset(memoize, -1, sizeof(int)*1000*1000);\n        printf(\"%d\\n\", max_profit_func(val, wt, W, 0, 0, sizeof(wt)/sizeof(wt[0])));\n        return 0;\n}\n```\n\n    ", "Answer": "\r\nYou are correct. While your function is solving the problem it is recalculating the same things again and again. \n\nYou need to drag along 2-D array, which will track which pairs (c_w, i) you have already solved and what is the result. This is called memoization (not memorization): http://en.wikipedia.org/wiki/Memoization\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack: how to add item type to existing solution\r\n                \r\nI've been working with this variation of dynamic programming to solve a knapsack problem:\n\n```\nKnapsackItem = Struct.new(:name, :cost, :value)\nKnapsackProblem = Struct.new(:items, :max_cost)\n\n\ndef dynamic_programming_knapsack(problem)\n  num_items = problem.items.size\n  items = problem.items\n  max_cost = problem.max_cost\n\n  cost_matrix = zeros(num_items, max_cost+1)\n\n  num_items.times do |i|\n    (max_cost + 1).times do |j|\n      if(items[i].cost > j)\n        cost_matrix[i][j] = cost_matrix[i-1][j]\n      else\n        cost_matrix[i][j] = [cost_matrix[i-1][j], items[i].value + cost_matrix[i-1][j-items[i].cost]].max\n      end\n    end\n  end\n\n  cost_matrix\nend\n\ndef get_used_items(problem, cost_matrix)\n  i = cost_matrix.size - 1\n  currentCost = cost_matrix[0].size - 1\n  marked = Array.new(cost_matrix.size, 0) \n\n  while(i >= 0 && currentCost >= 0)\n    if(i == 0 && cost_matrix[i][currentCost] > 0 ) || (cost_matrix[i][currentCost] != cost_matrix[i-1][currentCost])\n      marked[i] = 1\n      currentCost -= problem.items[i].cost\n    end\n    i -= 1\n  end\n  marked\nend\n```\n\n\nThis has worked great for the structure above where you simply provide a name, cost and value. Items can be created like the following:\n\n```\n items = [\n      KnapsackItem.new('david lee', 8000, 30) , \n      KnapsackItem.new('kevin love', 12000, 50), \n      KnapsackItem.new('kemba walker', 7300, 10),\n      KnapsackItem.new('jrue holiday', 12300, 30),\n      KnapsackItem.new('stephen curry', 10300, 80),\n      KnapsackItem.new('lebron james', 5300, 90),\n      KnapsackItem.new('kevin durant', 2300, 30),\n      KnapsackItem.new('russell westbrook', 9300, 30),\n      KnapsackItem.new('kevin martin', 8300, 15),\n      KnapsackItem.new('steve nash', 4300, 15),\n      KnapsackItem.new('kyle lowry', 6300, 20),\n      KnapsackItem.new('monta ellis', 8300, 30),\n      KnapsackItem.new('dirk nowitzki', 7300, 25),\n      KnapsackItem.new('david lee', 9500, 35),\n      KnapsackItem.new('klay thompson', 6800, 28)\n    ]\n\n  problem = KnapsackProblem.new(items, 65000)\n```\n\n\nNow, the problem I'm having is that I need to add a position for each of these players and I have to let the knapsack algorithm know that it still needs to maximize value across all players, except there is a new restriction and that restriction is each player has a position and each position can only be selected a certain amount of times. Some positions can be selected twice, others once. Items would ideally become this:\n\n```\nKnapsackItem = Struct.new(:name, :cost, :position, :value)\n```\n\n\nPositions would have a restriction such as the following:\n\n```\nPositionLimits = Struct.new(:position, :max)\n```\n\n\nLimits would be instantiated perhaps like the following:\n\n```\nlimits = [Struct.new('PG', 2), Struct.new('C', 1), Struct.new('SF', 2), Struct.new('PF', 2), Struct.new('Util', 2)]\n```\n\n\nWhat makes this a little more tricky is every player can be in the Util position. If we want to disable the Util position, we will just set the 2 to 0. \n\nOur original items array would look something like the following:\n\n```\nitems = [\n          KnapsackItem.new('david lee', 'PF', 8000, 30) , \n          KnapsackItem.new('kevin love', 'C', 12000, 50), \n          KnapsackItem.new('kemba walker', 'PG', 7300, 10),\n          ... etc ...\n        ]\n```\n\n\nHow can position restrictions be added to the knapsack algorithm in order to still retain max value for the provided player pool provided?\n    ", "Answer": "\r\nThere are some efficient libraries available in ruby which could suit your task , Its clear that you are looking for some constrain based optimization , there are some libraries in ruby which are a opensource so, free to use , Just include them in you project. All you need to do is generate Linear programming model objective function out of your constrains and library's optimizer would generate Solution which satisfy all your constrains , or says no solution exists if nothing can be concluded out of the given constrains .\n\nSome such libraries available in ruby are \n\n\nRGLPK \nOPL\nLP Solve\n\n\nOPL follows the LP syntax similar to IBM CPLEX , which is widely used Optimization software, So you could get good references on how to model the LP using this , Moreover this is build on top of the RGLPK.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack problem: choose 5 elements among 100, weight <= 100, maximise total value\r\n                \r\nI have a data table containing n=100 elements :\n\n\n\n\nElement\nweight\nvalue\n\n\n\n\nA\n24\n80\n\n\nB\n43\n77\n\n\nC\n51\n72\n\n\nD\n38\n70\n\n\nE\n27\n65\n\n\nF\n7\n58\n\n\n..\n..\n..\n\n\n\n\nAnd I would like to create an algorithm to get 5 elements where :\n\nsum of the 5 weights is capped to 100\nsum of the 5 values should be the maximum possible\n\nI'm on google sheet but I don't know how to do it properly.\nI tried to iterate on every element but it was not really effective...\n    ", "Answer": "\r\nI'm not familiar enough with google sheets, but here is a simple recursive function with memoization in python, using the following recurrence formula:\n```\nif weight(n) <= w:\n    T(n, k, w) = max(\n                     T(n-1, k, w),\n                     value(n) + T(n-1, k-1, w-weight(n))\n                 )\nelse:\n    T(n, k, w) = T(n-1, k, w)\n```\n\nwhere\n\nT(n, k, w) is the maximum sum of ```\nk```\n values whose weights sum up to at most ```\nw```\n, using only items up to the ```\nn```\nth item\nT(100, 5, 100) is the overall solution to your problem\nif the best solution for (n, k, w) doesn't use the nth item, then it's equal to the best solution for (n-1, k, w)\nif the best solution for (n, k, w) uses the nth item, then it's equal to the the value of the nth item plus the value of the best solution for (n-1, k-1, w-weight(n))\n\nIn python:\n```\nimport numpy as np\n\nn_items_total, k_items_solution, max_weight = 100, 5, 100\n\ndata = np.random.randint(0, max_weight+1, (n_items_total,2)))\n\ndef knapsack(n, k, w):\n    if (n, k, w) not in knapsack.t:\n        if w < 0 or n < 0 or k < 0:\n            knapsack.t[(n, k, w)] = -1000  # big negative number, large enough that solution is invalid\n        elif n < k:\n            knapsack.t[(n, k, w)] = -1000 # presuming you want exactly k items; remove this line if <= k is okay\n        elif k == 0:\n            knapsack.t[(n, k, w)] = 0\n        else:\n            knapsack.t[(n, k, w)] = max(knapsack(n-1, k, w), data[n-1, 0] + knapsack(n-1, k-1, w-data[n-1,1]))\n    return knapsack.t[(n, k, w)]\nknapsack.t = {}\n\ndef traceback_solution(t, n, k, w):\n    if k <= 0:\n        return\n    s = t[(n, k, w)]\n    a = t[(n-1, k, w)]\n    b = data[n-1, 0] + t[(n-1, k-1, w-data[n-1, 1])]\n    if s == a:\n        yield from traceback_solution(t, n-1, k, w)\n    elif s == b:\n        yield (n-1, data[n-1])\n        yield from traceback_solution(t, n-1, k-1, w-data[n-1, 1])\n    else:\n        raise Error\n\nbest_score = knapsack(n_items_total, k_items_solution, max_weight)\nsolution = list(traceback_solution(knapsack.t, n_items_total, k_items_solution, max_weight))\n\nprint(solution)\n# [(87, array([97,  2])),\n#  (84, array([97, 29])), \n#  (63, array([98, 11])), \n#  (36, array([98, 32])), \n#  (0, array([99,  6]))]\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack - save time and memory\r\n                \r\nAccording to Wikipedia and other sources I had went through, you need matrix ```\nm[n][W]```\n; ```\nn```\n - number of items and ```\nW```\n - total capacity of knapsack. This matrix get really big, sometimes too big to handle it in C program. I know that dynamic programming is based on saving time for memory but still, is there any solution where can you save time and memory?\n\nPseudo-code for Knapsack problem:\n\n```\n// Input:\n// Values (stored in array v)\n// Weights (stored in array w)\n// Number of distinct items (n)\n// Knapsack capacity (W)\nfor j from 0 to W do\n  m[0, j] := 0\nend for \nfor i from 1 to n do\n  for j from 0 to W do\n    if w[i] <= j then\n      m[i, j] := max(m[i-1, j], m[i-1, j-w[i]] + v[i])\n    else\n      m[i, j] := m[i-1, j]\n    end if\n  end for\nend for\n```\n\n\nLets say, that W = 123456789 and n = 100. In this case we get really big matrix m[100][123456789]. I was thinking how to implement this, but best I have in my mind is just to save which items was selected with one bit (0/1). Is this possible? Or is there any other approach for this problem?\n\n```\nint32 -> 32 * 123456789 * 100 bits\none_bit -> 1 * 123456789 * 100 bits\n```\n\n\nI hope this is not stupid question and thanks for your effort.\n\nEDIT - working C code:\n\n```\n    long int i, j;\n    long int *m[2];\n    m[0] = (long int *) malloc(sizeof(long int)*(W+1));\n    m[1] = (long int *) malloc(sizeof(long int)*(W+1));\n    for(i = 0; i <= W; i++){\n        m[0][i] = 0;\n    }\n\n    int read = 0;\n    int write = 1;\n    int tmp;\n\n    long int percent = (W+1)*(n)/100;\n    long int counter = 0;\n\n    for(i = 1; i <= n; i++){\n        for(j = 0; j <= W; j++){\n            if(w[i-1] <= j){\n                m[write][j] = max(m[read][j],(v[i-1]) + m[read][j-(w[i-1])]);\n            }else{\n                m[write][j] = m[read][j];\n            }\n            counter++;\n            if(counter == percent){\n                printf(\".\");    //printing dot (.) for each percent\n                fflush(stdout);\n                counter = 0;\n            }\n        }\n        tmp = read;\n        read = write;\n        write = tmp;\n    }\n\n    printf(\"\\n%ld\\n\", m[read][W]);\n\n    free(m[0]);\n    free(m[1]);\n```\n\n    ", "Answer": "\r\nKnapsack problem can be solved using ```\nO(W)```\n space. \nAt each step of the iteration you need only 2 rows - current state of the array ```\nm[i]```\n and ```\nm[i + 1]```\n.\n\n```\ncurrent = 1\nint m[2][W]\nset NONE for all elements of m # that means we are not able to process this state\nm[0][0] = 0 # this is our start point, initially empty knapsack\n\nFOR i in [1..n] do\n    next = 3 - current; /// just use 1 or 2 based on the current index\n    for j in [0...W] do\n       m[next][j] = m[current][j]\n    FOR j in [w[i]..W] do\n       if m[current][j - w[i]] is not NONE then  # process only reachable positions\n           m[next][j] = max(m[next][j], m[current][j - w[i]] + v[i]);\n    current = next; /// swap current state and the produced one\n```\n\n\nAlso it is possible to use only 1 array. Here is the pseudocode\n\n```\nFOR i in [1..n] do\n    FOR j in [w[i]..W] do\n       m[j] = max(m[j], m[j - w[i]] + v[i]);\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack: how to add item type to existing solution\r\n                \r\nI've been working with this variation of dynamic programming to solve a knapsack problem:\n\n```\nKnapsackItem = Struct.new(:name, :cost, :value)\nKnapsackProblem = Struct.new(:items, :max_cost)\n\n\ndef dynamic_programming_knapsack(problem)\n  num_items = problem.items.size\n  items = problem.items\n  max_cost = problem.max_cost\n\n  cost_matrix = zeros(num_items, max_cost+1)\n\n  num_items.times do |i|\n    (max_cost + 1).times do |j|\n      if(items[i].cost > j)\n        cost_matrix[i][j] = cost_matrix[i-1][j]\n      else\n        cost_matrix[i][j] = [cost_matrix[i-1][j], items[i].value + cost_matrix[i-1][j-items[i].cost]].max\n      end\n    end\n  end\n\n  cost_matrix\nend\n\ndef get_used_items(problem, cost_matrix)\n  i = cost_matrix.size - 1\n  currentCost = cost_matrix[0].size - 1\n  marked = Array.new(cost_matrix.size, 0) \n\n  while(i >= 0 && currentCost >= 0)\n    if(i == 0 && cost_matrix[i][currentCost] > 0 ) || (cost_matrix[i][currentCost] != cost_matrix[i-1][currentCost])\n      marked[i] = 1\n      currentCost -= problem.items[i].cost\n    end\n    i -= 1\n  end\n  marked\nend\n```\n\n\nThis has worked great for the structure above where you simply provide a name, cost and value. Items can be created like the following:\n\n```\n items = [\n      KnapsackItem.new('david lee', 8000, 30) , \n      KnapsackItem.new('kevin love', 12000, 50), \n      KnapsackItem.new('kemba walker', 7300, 10),\n      KnapsackItem.new('jrue holiday', 12300, 30),\n      KnapsackItem.new('stephen curry', 10300, 80),\n      KnapsackItem.new('lebron james', 5300, 90),\n      KnapsackItem.new('kevin durant', 2300, 30),\n      KnapsackItem.new('russell westbrook', 9300, 30),\n      KnapsackItem.new('kevin martin', 8300, 15),\n      KnapsackItem.new('steve nash', 4300, 15),\n      KnapsackItem.new('kyle lowry', 6300, 20),\n      KnapsackItem.new('monta ellis', 8300, 30),\n      KnapsackItem.new('dirk nowitzki', 7300, 25),\n      KnapsackItem.new('david lee', 9500, 35),\n      KnapsackItem.new('klay thompson', 6800, 28)\n    ]\n\n  problem = KnapsackProblem.new(items, 65000)\n```\n\n\nNow, the problem I'm having is that I need to add a position for each of these players and I have to let the knapsack algorithm know that it still needs to maximize value across all players, except there is a new restriction and that restriction is each player has a position and each position can only be selected a certain amount of times. Some positions can be selected twice, others once. Items would ideally become this:\n\n```\nKnapsackItem = Struct.new(:name, :cost, :position, :value)\n```\n\n\nPositions would have a restriction such as the following:\n\n```\nPositionLimits = Struct.new(:position, :max)\n```\n\n\nLimits would be instantiated perhaps like the following:\n\n```\nlimits = [Struct.new('PG', 2), Struct.new('C', 1), Struct.new('SF', 2), Struct.new('PF', 2), Struct.new('Util', 2)]\n```\n\n\nWhat makes this a little more tricky is every player can be in the Util position. If we want to disable the Util position, we will just set the 2 to 0. \n\nOur original items array would look something like the following:\n\n```\nitems = [\n          KnapsackItem.new('david lee', 'PF', 8000, 30) , \n          KnapsackItem.new('kevin love', 'C', 12000, 50), \n          KnapsackItem.new('kemba walker', 'PG', 7300, 10),\n          ... etc ...\n        ]\n```\n\n\nHow can position restrictions be added to the knapsack algorithm in order to still retain max value for the provided player pool provided?\n    ", "Answer": "\r\nThere are some efficient libraries available in ruby which could suit your task , Its clear that you are looking for some constrain based optimization , there are some libraries in ruby which are a opensource so, free to use , Just include them in you project. All you need to do is generate Linear programming model objective function out of your constrains and library's optimizer would generate Solution which satisfy all your constrains , or says no solution exists if nothing can be concluded out of the given constrains .\n\nSome such libraries available in ruby are \n\n\nRGLPK \nOPL\nLP Solve\n\n\nOPL follows the LP syntax similar to IBM CPLEX , which is widely used Optimization software, So you could get good references on how to model the LP using this , Moreover this is build on top of the RGLPK.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Multiple Knapsack where items can't be reused and have different value for different knapsack\r\n                \r\nI have a problem where:\n\n\nThere are multiple knapsack\nThere is a fixed set of items , ```\nSuperSet```\n you can say\nEvery Knapsack have a ```\nspecific subset```\n of items\nOne item can only be put into one knapsack and can't be reused\nEach item have different value for different knapsack\nWeight of every item is same but value differs according to knapsack\n\n\nNow I need to distribute items in a way that my final Sum of Knapsacks is the highest.\n\nSome Additional Details:\n\n\nI'm a programmer and not an algo writer, so please pardon of I dont know some details\nLanguage: Any (prefer C#)\nI just need a specific algo that resolves my situation, I'll write the code myself\nCurrently an alternative approach is ```\nThe Multiple Subset Sum Problem with non identical bins```\n, but I'm searching\n\n\nI'll provide bounty once Stack Overflow allows me too to the right answer even if its before! In a very crucial fix here.\n    ", "Answer": "\r\nThis is the maximum generalized assignment problem with a specific relaxation (Weight of every item is same but value differs according to bin).\n\nThis relaxation is important: since weight of each item is same but value differs according to knapsack, you can normalize all weights to '1' by dividing the capacity of each knapsack according to the weight of its items.\n\nNow it becomes the multiple subset-sum problem, with a slight difference: the capacity of each knapsack is different.\n\nThis problem had been studied in \"A PTAS for the Multiple Subset Sum Problem with different knapsack capacities\" [Caprara, Kellerer, Pferschy] 1999, where a polynomial-time (1 − ε)-approximation algorithm is given. Another approximation scheme is given in \"Approximating the 0–1 Multiple Knapsack Problem with Agent Decomposition and Market Negotiation\" [Smolinski] 2003.\n\nAn exact algorithm is given in \"ALGORITHM 632 - A Program for the 0-1 Multiple\nKnapsack Problem\" [Martello, Toth] 1985. A Fortran (sorry...) code can be found here.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Recursive Knapsack returning wrong answer\r\n                \r\nThe following code should be returning 16 as far as I can tell but for some reason, it returns 10. Does anyone know what my bug might be? Basically it's the Knapsack problem in Java and I've ran through the whole code on paper and it seems to return the right answer to me but I cannot figure out why when it's properly run, it returns back 10. \n\nAny help would be much appreciated. Thanks!\n\n```\nimport java.util.Stack;\n\npublic class knapsackProblem\n{\n\n  public static int optimalValue(Stack<item> items, int totalWeight)\n  {\n    if (items.isEmpty())\n      return 0;\n\n    int value = items.peek().value;\n    int weight = items.peek().weight;\n\n    items.pop();\n\n    if (totalWeight<weight)\n      return optimalValue(items, totalWeight);\n\n    return Math.max(optimalValue(items,totalWeight), value + optimalValue(items, totalWeight-weight));\n  }\n\n  public static void main(String args[])\n  {\n    int knapsackWeight = 15;\n    Stack<item> items = new Stack<item>();\n\n    items.push(new item(7,10));\n    items.push(new item(3,6));\n\n    System.out.println(optimalValue(items, knapsackWeight));\n\n  }\n}\n\nclass item\n{\n  public int weight;\n  public int value;\n\n  public item(int aWeight, int aValue)\n  {\n    weight = aWeight;\n    value = aValue;\n  }\n}\n```\n\n    ", "Answer": "\r\nYour ```\nStack```\n is being modified across the calls. So a line like \n\n```\nreturn Math.max(optimalValue(items,totalWeight), value + optimalValue(items, totalWeight-weight));\n```\n\n\nwill have two different copies of items for each call. Not what you want.\n\nInstead of using ```\nStack```\n, try changing things around to use an ```\nArrayList```\n. Then pass your index of which item you're evaluating into the ```\noptimalValue```\n method instead. This should help you work through the items correctly. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Meal plan algorithm\r\n                \r\nI've been trying to use the knapsack problem to solve a particular domain. Given a constraint of:\n\n\nCalories (e.g 300)\nNo of meals (e.g. 3)\n\n\nI want to create the optimum meal plan from a search space of about 100,000 recipes. Each recipe is an object with the following properties:\n\n```\npublic class Recipe {\n    private Integer id;\n    private String name;\n    private double calories;\n}\n```\n\n\nHow could I approach this problem using the knapsack problem? I've been looking at the code from here, and I am stumped at how to implement my constraints.\n\n```\nclass Knapsack {\n    public static void main(String[] args) throws Exception {\n        int val[] = {10, 40, 30, 50};\n        int wt[] = {5, 4, 6, 3};   \n        int W = 10;   \n        System.out.println(knapsack(val, wt, W));    \n   }\n\n    public static int knapsack(int val[], int wt[], int W) {\n        int N = wt.length;\n        int[][] V = new int[N + 1][W + 1];\n\n        for (int col = 0; col <= W; col++) {\n            V[0][col] = 0;\n        }\n\n        for (int row = 0; row <= N; row++) {\n            V[row][0] = 0;\n        }\n\n        for (int item=1;item<=N;item++){    \n            for (int weight=1;weight<=W;weight++){\n                if (wt[item-1]<=weight){\n                    V[item][weight]=Math.max (val[item-1]+V[item-1][weight-wt[item-1]], V[item-1][weight]);\n                }\n                else {\n                    V[item][weight]=V[item-1][weight];\n                }\n            }\n\n        }\n\n        for (int[] rows : V) {\n            for (int col : rows) {\n                System.out.format(\"%5d\", col);\n            }\n            System.out.println();\n        }\n        return V[N][W];\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Creating normally distributed Multi-dimensional Knapsack Problem (MKP) data from a basis one\r\n                \r\nI am trying to solve dynamic MKP for my thesis and I need to do the some calculations mentioned in the following passage of an article to create templates from a basis one:\n\n2.3 The Dynamic MKP\nIn our study, we use a dynamic version of the MKP as proposed in [3] and described below. Basis is the ﬁrst instance\ngiven in the ﬁle mknapcb4.txt which can be downloaded from [1]. It has 100 items, 10 knapsacks and a tightness ratio of 0.25. For every change, the proﬁts, resource consumptions and the constraints are  multiplied by a normally distributed random variable as follows:\n\n\npj  ← pj ∗ (1 + N (0, σp))\nrij ← rij ∗ (1 + N (0, σr))\nci ← ci ∗ (1 + N(0, σc))\n\n\nUnless speciﬁed otherwise, the standard deviation of the normally distributed random variable used for the changes has been set to σp = σr = σc = 0.05 which requires on average 11 out of the 100 possible items to be added or removed from one optimal solution to the next. Each proﬁt pj, resource consumption rij and constraint ci is restricted to an interval as determined in Eq. 11.\n\n\nlbp ∗ pj  ≤ pj  ≤ > ubp ∗ pj\nlbr ∗ rij ≤ rij ≤ ubp ∗ rij\nlbc ∗ ci ≤ ci ≤ ubp ∗ ci\nwhere lbp = lbr = lbc = 0.8 and ubp = ubr = ubc = 1.2. If any of the changes causes any of the lower or upper bounds to be exceeded, the value is bounced back from the bounds and set to a corresponding value within the allowed boundaries.\n\nLink to full version of the above paper: https://web.itu.edu.tr/~etaner/evostoc06.pdf\nAnd here is my C++ code to implement it:\n```\nvoid createTemplate()\n{\n    double lb=0.8;\n    double ub=1.2;\n    double previous;\n    std::random_device generator;\n    default_random_engine eng{generator()};;\n    normal_distribution<double> distribution(0,0.05);\n    double number = distribution(generator);\n    \n    //updating profits\n    for(int i=0;i<mkpInfo.numberOfItems;i++){\n        previous=mkpInfo.profits[i];\n        mkpInfo.profits[i]=mkpInfo.profits[i]*(1.0+number);\n        if(mkpInfo.profits[i]<previous*lb)\n            mkpInfo.profits[i]=lb*previous;\n        if(mkpInfo.profits[i]>ub*previous)\n            mkpInfo.profits[i]=ub*previous;\n    }\n    \n    //updating weights\n    for(int i=0;i<mkpInfo.numberOfResources;i++)\n    {\n        for(int j=0;j<mkpInfo.numberOfItems;j++){\n            previous=mkpInfo.Rij[i][j];\n            mkpInfo.Rij[i][j]=mkpInfo.Rij[i][j]*(1.0+number);\n            if(mkpInfo.Rij[i][j]<previous*lb)\n                mkpInfo.Rij[i][j]=lb*previous;\n            if(mkpInfo.Rij[i][j]>ub*previous)\n                mkpInfo.Rij[i][j]=ub*previous;\n        }\n\n    }\n\n    //updating resources\n    for(int i=0;i<mkpInfo.numberOfResources;i++){\n        previous=mkpInfo.resources[i];\n        mkpInfo.resources[i]=mkpInfo.resources[i]*(1.0+number);\n        if(mkpInfo.resources[i]<previous*lb)\n            mkpInfo.resources[i]=lb*previous;\n        if(mkpInfo.resources[i]>ub*previous)\n            mkpInfo.resources[i]=ub*previous;\n    }\n}\n```\n\nI have created 9 different environments by calling ```\nvoid createTemplate()```\n function according to the above code and solved them with CPLEX to find actual optimum values for each. Then, I tried to solve them with the algorithm that I developed for my thesis. Weirdly, either my algorithm is one of its kind, or I have done something really wrong while creating the templates. I mean I found very very good results according to previously studies in the literature. And I know my algorithm is fine because I have published it and solved similar problems before. For instance, the expression ```\ndouble number = distribution(generator);```\n always generates the same number in a run.\nSo, my questions are:\n\nIs it normal to generate the same number over and over with the above-mentioned code line?\nConsidering the explanation in the article, am I doing right? Or I need to generate different random number for each variable in the data file? I mean do I need to put the expression ```\nnumber=distribution(generator)```\n in ```\nfor```\n loops?\n\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Proof by Induction that Knapsack recurrence returns optimum solution\r\n                \r\nI have to show by induction that \n\nif w < w_i then Opt(i,w) = Opt(i-1,w)\n, else Opt(i,w) = max{ Opt(i-1,w), Opt( i-1, w - w_i) + w_i) }\n\nproduces the optimal solution for the Knapsack Problem (Dynamic Programming approach) \n\nI know how mathematical induction works, but I'm stuck on how to do it with this exercise.\nEspecially the inductive step.\nAs base case, I imagine, I only got one element and as long as the weight of this element is smaller or equal the capacity of my knapsack, I'll take it. \nOtherwise I leave it.\n\nAny help would be greatly appreciated!\nThank you\n    ", "Answer": "\r\nTo prove the correctness of this algorithm you can follow the following three steps\n\n\nProve that the algorithm produces a viable list: \n\n\nBecause the algorithm describes that we will make the largest choice available and we will always make a choice, we have a viable list\n\n\nProve that the algorithm has greedy choice property: \n\n\nIn this case we want to prove that the first choice of our algorithm could be part of the optimal solution. \n\n\nProve that the algorithm has optimal substructure: We can do so by hypothetically forming two list: \n\n\nU(the optimal list) and P(the list chosen by our algorithm). We can assume that the two list must be different at some point. Let the point of difference be Uj and Pj (that is after index j, P would contain different object from U, U ends at index j). Because in P is selected by only picking the largest element, with the same amount of element up to j as U does, Pj+1 will overflow the knapsack or we will be making the optimal solution U better which is not possible. Therefore, this problem has optimal substructure.\n\nThis way we can prove that the algorithm is correct.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack - A few clarification on Wiki's pseudocode\r\n                \r\nHere's the code on en.wikipedia's article on the Knapsack problem:\n\n```\n// Input:\n// Values (stored in array v)\n// Weights (stored in array w)\n// Number of distinct items (n)\n// Knapsack capacity (W)\nfor w from 0 to W do\n  m[0, w] := 0\nend for \nfor i from 1 to n do\n  for j from 0 to W do\n    if j >= w[i] then\n      m[i, j] := max(m[i-1, j], m[i-1, j-w[i]] + v[i])\n    else\n      m[i, j] := m[i-1, j]\n    end if\n  end for\nend for\n```\n\n\nI've got two points which my tired brain cannot work out. They're minor, I'm sure, but I could really use the help.\n\n•What's the size of the m[] array? m[n,W]? If it is, is the pseudocode ignoring the last line and last column, because it fills the entire first line with zeroes (the for() loop with m[0,w] := 0), and then loops from 1 to n, and 0 to W. For example, for 3 different items (n==3) and a capacity of 4 (W==3), is m[3,4] or m[4,5]?\n\n•Are there better examples of a dynamic knapsack algo, somewhere?\n    ", "Answer": "\r\nThe size of the array is (n + 1) × (W + 1), since the values range up from [0, 0] through [n, W] inclusive.\n\nThe interpretation of the grid is the following: position [k, w] represents the maximum amount of value that you can get from using the first k items (assuming the items are numbered 1, 2, ..., n) and carrying no more than w total weight.\n\nThe reason that the first row is set entirely to 0 is because any entry of the form [0, w] corresponds to the maximum value you can get using the first 0 items and carrying at most w weight.  This is always zero, since you can never get any value by not picking any items.  This corresponds to the base case of the recursion.\n\nRows after the first are filled in using the following idea: if you want to try picking the kth item, you would first need to make sure that you have the ability to hold it (meaning that w has to be at least w[k]).  If you can't hold it, your best option is to make the most of the first k - 1 items subject to your current weight restriction (so you'd be best off taking the value corresponding to m[k - 1, w].  If you can hold the item, your options are either to not take it (and, as before, to make the most of the other items, yielding m[k - 1, w]), or to take it and maximize the remaining carrying capacity with the remaining items.  This gives you value v[k] + m[k - 1, w - w[k]].\n\nHope this helps!\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "return The optimal set of items that should be put in the knapsack JAVA\r\n                \r\nI am currently working knapsack problem to return the set of the optimal solutions. \n\nthis is my method for that:\n\n```\npublic static int knapsackArray(int val[], int wt[], int W) {\n    //Get the total number of items. \n    int N = wt.length;\n\n    //Create a matrix. \n    int[][] V = new int[N + 1][W + 1]; \n\n    //all columns at row 0 to be 0\n    for (int col = 0; col <= W; col++) {\n      V[0][col] = 0;\n    }\n\n    //Fill the first row with 0\n    for (int row = 0; row <= N; row++) {\n      V[row][0] = 0;\n    }\n\n    for (int item=1;item<=N;item++){\n      for (int weight=1;weight<=W;weight++){\n        if (wt[item-1]<=weight){\n          V[item][weight]=Math.max (val[item-1]+V[item-1][weight-wt[item-1]], V[item-1][weight]);\n        }\n        else {\n          V[item][weight]=V[item-1][weight];            \n        }\n      }\n    }\n\n    //Printing the matrix\n    for (int[] rows : V) {\n      for (int col : rows) {\n        System.out.format(\"%5d\", col);\n      }\n      System.out.println();\n    }\n\n    return V[N][W];\n  }\n```\n\n\nand I have this other method that takes an Item set and a budget as arguments and it returns a Set of optimal solutions for this problem:\n\n```\npublic static Set<Item> knapsack(Set<Item> items, int budget) {\n    //create array of wieghts\n    int[] weights = new int[items.size()];\n    //create array of values\n    int[] values = new int[items.size()];\n\n    int i = 0;\n    for (Item x : items){\n      weights[i] = x.getWeight();\n      values[i] = x.getValue(); \n      //System.out.println(x);\n      i++;\n    }\n    /*int N = weights.length;\n    int[][] V = new int[N + 1][budget + 1];*/\n\n    int j = knapsackArray(values, weights, budget);\n    System.out.println(j);\n    return null;\n  }\n```\n\n\nmy question if how can I make this matrix into the set of the items that are optimal. is this - my approach - even a good way to go for this problem?\n    ", "Answer": "\r\nIn addition to the values matrix you create, inside ```\nknapsackArray```\n, you can create a second matrix to keep track of how you gotten to that point. (i.e. the last element you took) That way, once you're done with your DP solution, you can trace back all the elements you have gotten on your way. Also, in order to be able to pass the value back to ```\nknapsack```\n, you need to pass a set parameter down to ```\nknapsackArray```\n.\n\nBelow is a crude demonstration of the method I outlined.\n\n```\npublic static int knapsackArray(int val[], int wt[], int W, Set<int> itemIndices) {\n    // ...\n\n    // Create a matrix. \n    int[][] V = new int[N + 1][W + 1]; \n    int[][] G = new int[N + 1][W + 1]; \n\n    // ...\n\n    for (int item=1;item<=N;item++) {\n        for (int weight=1;weight<=W;weight++) {\n            if (wt[item-1]<=weight) {\n                int candidate = val[item-1] + V[item-1][weight-wt[item-1]];\n                if(candidate > V[item-1][weight]) {\n                    V[item][weight] = candidate;\n                    G[item][weight] = item - 1;\n                }\n                else {\n                    V[item][weight] = V[item-1][weight];\n                    G[item][weight] = -1;\n                }\n            }\n            else {\n                V[item][weight]=V[item-1][weight];\n                G[item][weight] = -1;\n            }\n        }\n    }\n\n    int currentItem = N;\n    int currentWeight = W;\n    while(currentItem >= 1) {\n        if(G[currentItem][currentWeight] >= 0) {\n            itemIndices.add(currentItem - 1);\n            currentWeight = currentWeight - wt[currentItem - 1];\n            currentItem = G[currentItem][currentWeight] + 1;\n        }\n        else {\n            currentItem = currentItem - 1;\n        }\n    }\n\n    // ...\n\n    return V[N][W];\n}\n```\n\n\nOnce you do this, you can actually process the indices within that parameter ```\nSet<int> itemIndices```\n and populate the ```\nSet<Item> items```\n in ```\nknapsack```\n method, as given below.\n\n```\npublic static Set<Item> knapsack(Set<Item> items, int budget) {\n    // ...\n\n    Set<Item> itemsToAdd;\n    Set<int> itemIndices;\n    int j = knapsackArray(values, weights, budget, itemIndices);\n    int i = 0;\n    for (Item x : items) {\n        if(itemIndices.contains(i)) {\n            itemsToAdd.add(x);\n        }\n        i++;\n    }\n\n    return itemsToAdd;\n}\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0-1 knapSnack problem with negetive numbers\r\n                \r\nGiven an array of positive and negative numbers, find if we can choose some of them and sum them in a way that the final sum is zero. (any non zero number will do).\n\nWe have weights of them and values.\n\nI believe this is a version of the 0-1 knapsack problem.\nthe sample input and output:\n\n```\n4 - weight - percent\n+ 50 30\n+ 80 1\n- 20 30\n- 30 30\n```\n\n\n```\nyes\n\n```\n\n\nThis is the code I wrote for it, but somehow I can't figure out why this won't work:\nI'm getting the output 0 for it (and I should be getting 1000, choosing the first, third and fourth one).\nIs there any way to solve the knapsack problem with negative values?\n\n```\ndef knapSack(W , wt , val , n): \n    if n == 0 : \n        return 0\n    if (wt[n-1] > W): \n        return knapSack(W , wt , val , n-1) \n    else: \n        return max(val[n-1] + knapSack(W-wt[n-1] , wt , val , n-1), knapSack(W , wt , val , n-1)) \n\nval = [80, 50, -20, -30] \nwt = [ 1,30, 30, 30] \nW = 0\nn = len(val) \nprint(knapSack(W, wt, val, n)) \n```\n\n\nAnyone has any idea how should I change this in order to be working??\n    ", "Answer": "\r\nThis is by no ways efficient but it seemed to be the simplest method of seeing if any combination of acids and bases would cancel out. (I did not use the knapsack approach)\n\nFor each (the acids and the bases) create an array that contains their amount. In the case of your example these arrays would be - ```\nacid = [1500, 80]```\n and ```\nbase = [600, 900]```\n. Getting these arrays depends on your input format.\n\nonce you have these arrays you can do the following - \n\n```\ndef SumOfSubsets(arr): \n    Allsums = []\n    for number in arr:\n        Placeholder = Allsums[:]\n        Allsums.append(number)\n        for sum in Placeholder:\n            Allsums.append(sum + number)\n\n    return(Allsums)\n\nAcidList = SumOfSubsets(acid)\nBaseList = SumOfSubsets(base)\n\nfor acids in AcidList:\n    if acids in BaseList:\n        print(\"can be neutralized\")\n\n```\n\n\n*Note that by using this approach you do not know what combinations of acids and bases are needed to achieve the neutralization. You can get this combination by using another function if needed.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Limiting number of each item in knapsack solution\r\n                \r\nI am trying to better understand knapsack problems and am looking at the \"Specific Dynamic Programming solution\" given here:\nhttp://rosettacode.org/wiki/Knapsack_Problem/Python\n\nI want to modify it so at most one of each item in items can be used in the solution. I thought this could be done by looping through items outside of weight and volume, but this did not work.\n\nAny help is appreciated.\n\nEDIT:\nExample:\nCurrently the code defines an items list\n\n```\nitems = [Bounty('panacea', 3000,   3,  25),\n         Bounty('ichor',   1800,   2,  15),\n         Bounty('gold',    2500,  20,   2)]\n```\n\n\nit chooses the maximum value combo of items that is < the weight and volume limits of the knapsack and allows each item to be used multiple times. \n\nI want it to choose the maximum value combo of items that has a weight and value < the weight and volume limits of the knapsack, but with the constraint that each item in items can be used a maximum of one time. \n    ", "Answer": "\r\nIf you want to prevent that each item is used multiple times:\n1) Make the DP algorithm decreasing instead of increasing + process this per item first instead of looping over weigth and volume first\nIn this way each item can't be counted multiple times more than once.\nAnd by looping over the items first you don't take the chance of missing combinations of items.\nAs an example when your table is empty and you process your first item. It will take the best of the current and the best at position ```\n[w-weight][v-volume]+value```\n\n```\ntable[w][v] = max(table[w][v], table[w - item.weight][v - item.volume] + item.value)\n```\n\nSo for panacea:\n\nWhen you are going in increasing order ```\ntable[25][3]```\n will be ```\n3000```\n when processing ```\ntable[50][6]```\n. Making it 6000, using it 2 times.\n\nWhen you are going in decreasing order ```\ntable[25][3]```\n will still be ```\n0```\n when processing ```\ntable[50][6]```\n. Making it 3000, only using it once.\n\n\nSo whatever will be in a lower table value, it won't be from the same item.\n2) Check when all items fit the knapsack\nBy the way this is implemented this indeed crashes when all items fit the knapsack.\nYou can rewrite this or simply add a check at the beginning of the method:\n```\ndef knapsack_dp(items, sack):\n    if(sum(item.weight for item in items) <= sack.weight\n        and sum(item.volume for item in items) <= sack.volume):\n        return [1] * len(items)\n```\n\nWhen it fully fits, return all items.\nRunning example\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Haskell, Knapsack not expected return types error recieved\r\n                \r\nHere is my code to solve the fractional knapsack problem, input to knap should be in the form \n\n```\n[(\"label 1\", value, weight), (\"label 2\", value, weight), ...]\n```\n\n\nAnd output should be in the form\n\n```\n[(\"label 1\", value, solution_weight), (\"label 2\", value, solution_weight), ...]\n```\n\n\nCode:\n\n```\nimport Data.List {- Need for the sortBy function -}\n{- Input \"how much can the knapsack hole <- x\" \"Possible items in sack [(label, value, weight), ...] <- y\" -}\n{-knap x [([Char], Integer, Integer), ... ] = -}\nknap x [] = []\nknap x y = if length y == 1 \n    then \n        if x > last3 (head y)\n            then y\n            else [(frst3 (head y), scnd3 (head y), x)]\n    else \n        knap2 x y []\n{- x is the knap max, y is the sorted frac list, z is the solution list -}\nknap2 x y z = if x == 0\n    then z\n    else\n        if thrd4 (head y) > x\n            then [((frst4 (head y)), (scnd4 (head y)), x)]\n            else knap2 (x-(thrd4 (head y))) (tail y) (z++[((frst4 (head y)), (scnd4 (head y)), (thrd4 (head y)))]) \n\n{- take a list of labels, values, and weights and return list of labels and fractions -}\nfraclist :: (Fractional t1) => [(t, t1, t1)] -> [(t, t1, t1, t1)]\nfraclist xs = [(x, y, z, y/z) | (x, y, z) <- xs]\n\n{- Sort the list -}\nsortList x = sortBy comparator x\n    where comparator (_,_,_,d) (_,_,_,h) = if d > h then LT else GT\n\n{- helper func to get values from tuples -}\nfrst3 (a,b,c) = a\nscnd3 (a,b,c) = b\nlast3 (a,b,c) = c\nfrst4 (a,b,c,d) = a\nscnd4 (a,b,c,d) = b\nthrd4 (a,b,c,d) = c\nlast4 (a,b,c,d) = d\n```\n\n\nHere is the error I am getting\n\n```\nCouldn't match expected type `(t1, t0, t2, t3)'\n            with actual type `(t1, t0, t2)'\nExpected type: [(t1, t0, t2, t3)]\n  Actual type: [(t1, t0, t2)]\nIn the second argument of `knap2', namely `y'\nIn the expression: knap2 x y []\n```\n\n\nI am not quite sure what else I can do. before I sit here and bang my head on the wall for an hour maybe someone could point out an obvious mistake if there are any?\n    ", "Answer": "\r\nI can't tell how the four-tuples in ```\nknap2```\n and the three-tuples in ```\nknap```\n are supposed to fit together but you'll have a much clearer view of the matter if you pattern match and drop ```\nhead```\n, ```\ntail```\n,```\nthrd4```\n, ```\nthirteenth17```\n etc\n\n```\nknap _ []        = []\nknap x [(a,b,c)] = if x > c then [(a,b,c)]  else [(a, b, x)]\nknap x abcs      = knap2 x abcs []\n\nknap2 0 abcs z = z\nknap2 x abcs z = undefined  -- not sure how to do this\n\n-- but this makes sense, it seems:\nknap3 0 _  zs = zs\nknap3 _ [] _ = []\nknap3 x ((a,b,c,d):abcds) zs =\n  if c > x then [(a, b, x)]\n           else knap3 (x - c) abcds (zs ++ [(a, b, c)]) \n```\n\n\nor something like that.  Instead of writing ```\nif length y == 1```\n you can pattern match on the singleton case; instead of using an equality test, ```\nif x == 0```\n you can pattern match on the 0 case,  distinguishing it from other cases.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack using GA\r\n                \r\nI have not asked about the knapsack problem using a genetic algorithm. the initialization I use this kind of chromosomes [1] = [weight] [profit], because his formula KP on chromosome evaluation weight x profit. nah after entry using roulete wheel selection. in to p (a) = 0.04761/0.19761 = 0.24092; p (b) = 0.1/0.19761 = 0.50604; p (c) = 0.025/0.19761 = 0.12651.\nthen setelag that generate random numbers, after the random numbers can be, how will the cross-over?\n\nplease explain, please help me\n    ", "Answer": "\r\nyour chromosome structure is wrong. chromosome should present the solution all choices.\nEx for knapsack, chromosome may be a set of selected objects index. then you calculate the whole weight.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "What is the proper problem name / algorithm for this problem description in computer science theory?\r\n                \r\nThe problem is that I have X items of varying weighted values that must go into Y containers. The containers are of differing sizes (e.g. hold differing maximum weights). The total load of each container must be approximately equivalent to the others, but the containers don't need to be full or minimized. All of the containers must be used. \n\nThis reminds me of the \"knapsack\" problem, but I have multiple knapsacks of differing sizes and the loads between them all must be relatively equivalent (e.g. one knapsack may only hold 12 pounds, and another knapsack may only hold 8 pounds, but they both need to be filled with the same percentage of total weight they can carry). It also reminds me of the \"bin packing\" problem, but that doesn't deal with the varying bin sizes or that the bins don't need to be full or minimized, they just need equivalent loads and all of them need to be used.\n\nCan anyone please point me in the right direction as to the name of this problem within data structures and algorithm theory? I'd also be interested in any algorithms or heuristics that may be commonly used to solve a problem like this or info about the possible time complexity.\n    ", "Answer": "\r\nSounds like multiple-knapsack to me. From Wikipedia:\n\n\n  If we have n items and m knapsacks with capacities Wi, we get the multiple knapsack problem\n\n\nEDIT: Sorry, missed the bit about each container needing to be similarly loaded. Still, it smells like multiple-knapsack, albeit with an extra constraint.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack questions\r\n                \r\nfor leetcode 322 coin change, the code is below:\n```\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n\n        for i in range(len(coins)):\n            for j in range(1, amount + 1):\n                if coins[i] <= j:\n                    dp[j] = dp[j] + dp[j-coins[i]]         \n        return dp[-1]    \n```\n\nfor leetcode 1049 last stone weight II, the code is below:\n```\nclass Solution:\n    def lastStoneWeightII(self, stones: List[int]) -> int:\n        total = sum(stones)\n        \n        Max_weight = int(total/2)\n        print(Max_weight)\n        current = (Max_weight+1)*[0]\n        \n        for stone in stones:\n            for wgt in range(Max_weight, -1, -1):\n                if wgt-stone>=0:\n                    current[wgt] = max(stone + current[wgt-stone], current[wgt])\n                print(stone, wgt, current)\n            \n           \n        return total-2*current[-1]\n```\n\nI like to understand the logic of knapsack more.  My biggest question mark is how do we decide whether the second \"for loop\" is in ascending order or descending order.  For example, the first coin change code  [for j in range(1, amount + 1):], it is in ascending order but the second stone weigh code[ for wgt in range(Max_weight, -1, -1):] is in descending order.  I kind of understand why it works after tracing the code but is there a more intuitive way of really explaining why we use ascending or descending for loop when dealing with knapsack problems.  I really not able to grasp the concept of when to use which one....  Thanks!\n    ", "Answer": "\r\nThey are fundamentally two different problems.\nThe 322 Coin Change problem is an instance of the Unbounded Knapsack problem -- you have infinite quantities of the items that you want to fit in your knapsack.\nThe 1049 LastStoneWeightII problem is an instance of the Bounded Knapsack problem -- you have only one instance of each item that you want to fit in your knapsack.\n\nThe reason you need to run the for loop in descending order in the second problem is because if you don't you will accidentally add the stones more than once. The optimal solution of a subproblem might have already considered the current stone if you run the loop incrementally. But if you run the loop in reverse, you can be sure that the optimal subproblem solution, that you are using to build the solution considering the current stone, does not consist of the current stone.\nIf you want to use the incrementing for loop for the bounded knapsack problem, you can either use the 2D array version of the algorithm OR you need to keep track of the subset that is part of the solution to each subproblem.\nYou can find more discussion here: https://leetcode.com/discuss/study-guide/1200320/Thief-with-a-knapsack-a-series-of-crimes.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do I generate PuLP variables and constrains without using exec?\r\n                \r\nI have written the following Python Code using the PuLP Library for solving the Knapsack Problem using the Integer Programming formulation. I am using strings to generate the LpVariable commands and add the constraints and then executing them with eval. Is there a way to do this without using eval?\n\n```\nfrom pulp import *\n\n#Knapsack problem\n\nitems = input ('Enter the number of items :')\n\nitems = int(items)\n\n#print('Enter %d items one by one')\n\nprint ('Enter {0} items profit one by one'.format(items))\n\nobj = []\nweight = []\nknapweight = 0\n\n\nfor i in range(0,items):\n    print('Enter {0} item profit : '.format(i+1))\n    obj.append(input())\n\nfor i in range(0, items):\n    print('The profit at {0} is {1}'.format(i, obj[i]))\n\nprint ('\\nEnter {0} items weights one by one'.format(items))\n\n\nfor i in range(0, items):\n    print('Enter {0} item weight'.format(i+1))\n    weight.append(input())\n\nfor i in range(0, items):\n    print('The profit at {0} is {1}'.format(i, weight[i]))\n\nprint ('\\nEnter the weight of the knapsack :')\nknapweight = input()\n\nprint ('The weight of the knapsack is : {0}'.format(knapweight))\n\n\n#generating variables\nfor i in range(0, items):\n    str = 'x{0} = LpVariable(\"x{1}\", cat=\\'Binary\\')'.format(i+1,i+1)\n    print (str)\n    exec(str)\n\nprob = LpProblem('Knapsack', LpMaximize)\n\nprint ('\\nDynamic Generaion\\n')\n\n#weight constraint generation\nstr = \"prob += \"\n\nfor i in range(0, items):\n    if i == (items-1):\n        str = str + weight[i] + '*x{0}'.format(i+1)\n    else:\n        str = str + weight[i] + '*x{0}'.format(i+1) + '+'\n\nstr = str + '<=' + knapweight\nexec(str)\nprint(str)\n\n#objective function generation\nstr = \"prob += \"\n\nfor i in range(0, items):\n    if i == (items-1):\n        str = str + obj[i] + '*x{0}'.format(i+1)\n    else:\n        str = str + obj[i] + '*x{0}'.format(i+1) + '+'\n\nexec(str)\nprint(str)\n\nstatus = prob.solve()\nprint(LpStatus[status])\n\nprint ('\\nThe values of the variables : \\n')\n\nfor i in range(0, items):\n    print('x{0} = {1}'.format(i+1, value(eval('x{0}'.format(i+1)))))\n```\n\n    ", "Answer": "\r\nThe key is recognizing that it's okay to have an object -- say one in a list or a dictionary -- which you don't have explicitly bound to a name.  You can make an object, append it to a list, and only ever refer to it as ```\nsome_list[2]```\n.  Once you allow yourself that freedom, your code can become much simpler.\n\nHere I've hardcoded the inputs, because that doesn't matter:\n\n```\nfrom pulp import *\n\nobjs = [2,3,2,5,3]\nweights = [1,2,2,1,3]\nknapweight = 5\n\nprob = LpProblem('Knapsack', LpMaximize)\nxs = [LpVariable(\"x{}\".format(i+1), cat=\"Binary\") for i in range(len(objs))]\n\n# add objective\ntotal_prof = sum(x * obj for x,obj in zip(xs, objs))\nprob += total_prof\n\n# add constraint\ntotal_weight = sum(x * w for x,w in zip(xs, weights))\nprob += total_weight <= knapweight\n\nstatus = prob.solve()\nprint(LpStatus[status])\nprint(\"Objective value:\", value(prob.objective))\nprint ('\\nThe values of the variables : \\n')\nfor v in prob.variables():\n    print(v.name, \"=\", v.varValue)\n```\n\n\nwhich gives me\n\n```\nOptimal\nObjective value: 10.0\n\nThe values of the variables : \n\nx1 = 1.0\nx2 = 1.0\nx3 = 0.0\nx4 = 1.0\nx5 = 0.0\n```\n\n\nHere I'm building the LpVariables in the list comprehension\n\n```\nxs = [LpVariable(\"x{}\".format(i+1), cat=\"Binary\") for i in range(len(objs))]\n```\n\n\nwhere the objects then just live in the list ```\nxs```\n.\n\n```\n>>> xs\n[x1, x2, x3, x4, x5]\n>>> xs[3]\nx4\n>>> type(xs[3])\n<class 'pulp.pulp.LpVariable'>\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "How do I generate PuLP variables and constrains without using exec?\r\n                \r\nI have written the following Python Code using the PuLP Library for solving the Knapsack Problem using the Integer Programming formulation. I am using strings to generate the LpVariable commands and add the constraints and then executing them with eval. Is there a way to do this without using eval?\n\n```\nfrom pulp import *\n\n#Knapsack problem\n\nitems = input ('Enter the number of items :')\n\nitems = int(items)\n\n#print('Enter %d items one by one')\n\nprint ('Enter {0} items profit one by one'.format(items))\n\nobj = []\nweight = []\nknapweight = 0\n\n\nfor i in range(0,items):\n    print('Enter {0} item profit : '.format(i+1))\n    obj.append(input())\n\nfor i in range(0, items):\n    print('The profit at {0} is {1}'.format(i, obj[i]))\n\nprint ('\\nEnter {0} items weights one by one'.format(items))\n\n\nfor i in range(0, items):\n    print('Enter {0} item weight'.format(i+1))\n    weight.append(input())\n\nfor i in range(0, items):\n    print('The profit at {0} is {1}'.format(i, weight[i]))\n\nprint ('\\nEnter the weight of the knapsack :')\nknapweight = input()\n\nprint ('The weight of the knapsack is : {0}'.format(knapweight))\n\n\n#generating variables\nfor i in range(0, items):\n    str = 'x{0} = LpVariable(\"x{1}\", cat=\\'Binary\\')'.format(i+1,i+1)\n    print (str)\n    exec(str)\n\nprob = LpProblem('Knapsack', LpMaximize)\n\nprint ('\\nDynamic Generaion\\n')\n\n#weight constraint generation\nstr = \"prob += \"\n\nfor i in range(0, items):\n    if i == (items-1):\n        str = str + weight[i] + '*x{0}'.format(i+1)\n    else:\n        str = str + weight[i] + '*x{0}'.format(i+1) + '+'\n\nstr = str + '<=' + knapweight\nexec(str)\nprint(str)\n\n#objective function generation\nstr = \"prob += \"\n\nfor i in range(0, items):\n    if i == (items-1):\n        str = str + obj[i] + '*x{0}'.format(i+1)\n    else:\n        str = str + obj[i] + '*x{0}'.format(i+1) + '+'\n\nexec(str)\nprint(str)\n\nstatus = prob.solve()\nprint(LpStatus[status])\n\nprint ('\\nThe values of the variables : \\n')\n\nfor i in range(0, items):\n    print('x{0} = {1}'.format(i+1, value(eval('x{0}'.format(i+1)))))\n```\n\n    ", "Answer": "\r\nThe key is recognizing that it's okay to have an object -- say one in a list or a dictionary -- which you don't have explicitly bound to a name.  You can make an object, append it to a list, and only ever refer to it as ```\nsome_list[2]```\n.  Once you allow yourself that freedom, your code can become much simpler.\n\nHere I've hardcoded the inputs, because that doesn't matter:\n\n```\nfrom pulp import *\n\nobjs = [2,3,2,5,3]\nweights = [1,2,2,1,3]\nknapweight = 5\n\nprob = LpProblem('Knapsack', LpMaximize)\nxs = [LpVariable(\"x{}\".format(i+1), cat=\"Binary\") for i in range(len(objs))]\n\n# add objective\ntotal_prof = sum(x * obj for x,obj in zip(xs, objs))\nprob += total_prof\n\n# add constraint\ntotal_weight = sum(x * w for x,w in zip(xs, weights))\nprob += total_weight <= knapweight\n\nstatus = prob.solve()\nprint(LpStatus[status])\nprint(\"Objective value:\", value(prob.objective))\nprint ('\\nThe values of the variables : \\n')\nfor v in prob.variables():\n    print(v.name, \"=\", v.varValue)\n```\n\n\nwhich gives me\n\n```\nOptimal\nObjective value: 10.0\n\nThe values of the variables : \n\nx1 = 1.0\nx2 = 1.0\nx3 = 0.0\nx4 = 1.0\nx5 = 0.0\n```\n\n\nHere I'm building the LpVariables in the list comprehension\n\n```\nxs = [LpVariable(\"x{}\".format(i+1), cat=\"Binary\") for i in range(len(objs))]\n```\n\n\nwhere the objects then just live in the list ```\nxs```\n.\n\n```\n>>> xs\n[x1, x2, x3, x4, x5]\n>>> xs[3]\nx4\n>>> type(xs[3])\n<class 'pulp.pulp.LpVariable'>\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack witness generation\r\n                \r\nI have written a knapsack class which I am using to solve the knapsack algorithm. The class works and is using the dynamic programming algorithm to solve the problem.\n\nI have implemented some optimizations in the code so that I take linear O(W) space to find the maximum value but when I try to find the witness I still need O(nW) space to keep the table of booleans. \n\nCould someone tell me if it is possible to find the witness for the knapsack with maximum capacity with smaller amount of space and with the same complexity of O(nW), here W is the knapsack capacity.\n\nIf you think there might be some more optimizations in the code please tell them as well.\n\n```\nclass Knapsack{\nprivate:\n  vector< int > value, weight, answer, DP;\n  vector< bool > isin;\n  int capacity;\n\npublic:\n  Knapsack( vector< int > value, vector< int > weight, int capacity, bool needWitness ){\n    this->value = value;\n    this->weight = weight;\n    this->capacity = capacity;\n\n    this->answer.clear(); this->isin.clear(); this->DP.clear();\n    this->DP.resize( capacity + 1, false );\n\n    if ( needWitness ){\n      this->isin.resize( value.size() * (capacity + 1), false );\n      solveWithWitness();\n    }\n    else{\n      solveWithoutWitness();\n    }\n\n  }\n\n  void solveWithoutWitness(){\n    for ( int i = 0; i < value.size(); i++ ){\n      for ( int w = capacity; w >= weight[i]; w-- ){\n        if ( DP[w] < value[i] + DP[w - weight[i]] ){\n          DP[w] = value[i] + DP[w - weight[i]];\n        }\n      }\n    }\n  }\n\n  void solveWithWitness(){\n    for ( int i = 0; i < value.size(); i++ ){\n      for ( int w = capacity; w >= weight[i]; w-- ){\n        if ( DP[w] < value[i] + DP[w - weight[i]] ){\n          DP[w] = value[i] + DP[w - weight[i]];\n          isin[ i*capacity + w ] = true;\n        }\n      }\n    }\n    int position = value.size()-1;\n    int w = capacity;\n    while ( position >= 0 ){\n      if ( isin[ position*capacity + w ] ){\n        answer.push_back( position );\n        w -= weight[position];\n      }\n      position--;\n    }\n  }\n\n\n  vector< int > getWitness(){\n    return this->answer;\n  }\n\n  int solution(){\n    return DP[capacity];\n  }\n\n};\n```\n\n    ", "Answer": "\r\nYou're using O's all over the place, so I can give you a theory solution that's a bit complicated and awkward that still satisfies the time bounds you want:\n\nRun the without-witness DP for n/2 steps; that tells you which of the W weights is reachable using only the first n/2 items.  Now run a DP for the remaining n/2 steps keeping track of how much weight is needed from the first n/2 items to reach each cell.\n\nIf you naively apply this procedure in a recursive way, you get a time recurrences looking like T(n, W) <= 2T(n/2, W) + O(nW), whose solution is O(n log(n) W).  That's not quite good enough.\n\nBut we worked out how much weight was needed from the first n/2 items.  Call that w.  We only need to care about the first w entries of the DP array.  So the first-half recursion should take T(n/2, w) time, the second-half recursion should take T(n/2, W-w) time, and the work needed to get there takes O(nW) time.\n\nThe solution to a recurrence of the form T(n, W) <= max(0 <= w <= W) T(n/2, w) + T(n/2, W-w) + O(nW) is actually O(nW).  You can see this intuitively by imagining an n-by-W rectangle initially of zeroes.  A recursive knapsack call with n' items and weight W' adds 1 to each entry in some n'-by-W' subrectangle.  Then the first level of recursion adds a total of nW, the second level nW/2, the third nW/4, and so forth, giving you a geometric series.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm with an additional property\r\n                \r\nWhen there's 1 property, I do understand what's going on in there.\nI'm having a problem with understanding knapsack problem when there's more than 1 property.\n\n\n\nI have to write a program that uses knapsack algorithm with a 2 properties. Teacher told us, It has to be done in a 3d array. I can't imagine how would such array look like.\n\nLet's say here's my input:\n\n```\n4 3 4 // number of records below, 1st property of backpack, 2nd property  of backpack\n1 1 1 // 1st property, 2nd property, cost\n1 2 2 // 1st property, 2nd property, cost\n2 3 3 // 1st property, 2nd property, cost\n3 4 5 // 1st property, 2nd property, cost\n```\n\n\nAnd the output would look like that:\n\n```\n4    // the cheapest sum of costs of 2 records\n1 3  // numbers of these 2 records\n```\n\n\nThe explanation of output:\n2 sets of records fit's into 1'st line of input:\n\n(1) - record number 1 and record number 3\n\n```\n  1 1 1\n+ 2 3 3\n-------\n  3 4 4\n```\n\n\n(2) - record number 4\n\n```\n  3 4 5\n```\n\n\nBecause 1st set of the records is the cheapest (4 < 5), we chose it. Not only I'll have to find out whether such set of records exists, I'll also have to find records I've summed.\n\nBut for now, I only need to understand, how will 3d array look like. Could some of You help me out with that and show, layer by layer, just like in my image, how would this look like?\nThanks.\n\n\n    ", "Answer": "\r\nSay you are using a three dimension table: ```\nA[x][y][z]=k```\n, ```\nx```\n: sum 1st property; ```\ny```\n: sum 2nd property; ```\nz```\n: sum 3rd property; k: minimal cost (maximal reward, which I prefer using reward)\n\nSo you iterate over items. Say current item is (p1, p2, p3, reward) (reward = - cost). for each ```\n(x,y,z,k)```\n, your update formula:\n\n```\nA[x+p1][y+p2][z+p3] = max(A[x+p1][y+p2][z+p3], A[x+p1][y+p2][z+p3] + reward)\n```\n\n\nIf the 1st term on RHS is greater, on slot ```\nA[x+p1][y+p2][z+p3]```\n, the configuration of knapsack is remain still; otherwise, you update the knapsack by that of ```\nA[x+p1][y+p2][z+p3]```\n plus the current item.\n\nHope this cut things clear.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "0/1 Knapsack with few variables: which algorithm?\r\n                \r\nI have to implement the solution to a 0/1 Knapsack problem with constraints.\nMy problem will have in most cases few variables (~ 10-20, at most 50).\n\nI recall from university that there are a number of algorithms that in many cases perform better than brute force (I'm thinking, for example, to a branch and bound algorithm).\n\nSince my problem is relative small, I'm wondering if there is an appreciable advantange in terms of efficiency when using a sophisticate solution as opposed to brute force.\n\nIf it helps, I'm programming in Python.\n    ", "Answer": "\r\nYou can either use pseudopolynomial algorithm, which uses dynamic programming, if the sum of weights is small enough. You just calculate, whether you can get weight X with first Y items for each X and Y.\nThis runs in time O(NS), where N is number of items and S is sum of weights.\n\nAnother possibility is to use meet-in-the middle approach. \nPartition items into two halves and:\nFor the first half take every possible combination of items (there are 2^(N/2) possible combinations in each half) and store its weight in some set.\nFor the second half take every possible combination of items and check whether there is a combination in first half with suitable weight.\nThis should run in O(2^(N/2)) time. \n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack with two sums and two sets\r\n                \r\nFor an algorithm homework, I'm asked to give a solution for a knapsack problem. I have in input a list of products. A product is assigned a cost and a number of calories. So I have two sets, one of money and one of kcal. My goal is to choose products that give an equal sum of money and kcal.\nfor example if I have this input: (1, 3), (2, 4), (5, 8), (4, 5)\nand the money sum equal to m=7 and kcal sum equal to k=12, I need to choose products that satisfies the two sums exactly. In my example I will choose the products (2, 4) and (5, 8). My solution only needs to return true if there exists products that match the requirement, otherwise return false. No need to return a set of products\nI already wrote a solution using recursion based on the subsetsum problem, where I recall my function using the last product or not. This solution works, but it's too slow -> 2^n.\n```\ndef isSubsetSum(set, n, sum, set2, sum2):\n    if (sum == 0 and sum2==0):\n        return True\n    if (n == 0 or (sum < 0 or sum2 < 0)):\n        return False\n        \n    if (set[n] > sum) or (set2[n] > sum2):              # if one of the two values (money, calories) is bigger than the sum \n        return isSubsetSum(set, n-1, sum, set2, sum2)   # we avoid using this product -> recall with n-1\n\n    inclusion = isSubsetSum(set, n-1, sum-set[n], set2, sum2-set2[n]) # we recurse includig the last product\n    exclusion = isSubsetSum(set, n-1, sum, set2, sum2)  # we recurse excluding the last product\n\nreturn inclusion or exclusion\n```\n\nI tried to change my subsetsum function into a dynamic programming approach, but I have difficulties in changing my function to work with the two sets (set of money and set of calories).\nI talked with the teaching assistants, and they oriented me in choosing the knapsack problem instead of the subset sum problem. I saw how the knapsack dynamic programming approach is, but I have the same problems as before with subsetsum in changing the problem to work with my input.\nI think I am missing something, it would be cool if you could help me understand where I'm wrong.\nThanks\n    ", "Answer": "\r\nHere is how a dynamic programming approach could look like:\n```\nimport numpy as np\n\nM = 7 \nK = 12\nproducts = [(1, 3), (2, 4), (5, 8), (4, 5)]\n\n# For an empty list of products, only the problem with m=k=0 is solvable:\nsolvable = np.zeros(shape=(M + 1, K + 1), dtype=bool)\nsolvable[0, 0] = True\n\ndef one_more(product, solvable):\n    result = solvable.copy()\n    m_inc, k_inc = product\n    for m in range(m_inc, M + 1):\n        for k in range(k_inc, K + 1):\n            if not solvable[m, k]:\n                result[m, k] = solvable[m - m_inc, k - k_inc]\n    return result\n\nfor product in products:\n    solvable = one_more(product, solvable)\n\n# The full problem of interest:\nprint(solvable[M, K])\n```\n\nNumPy is useful here, because it provides a two-dimensional array data structure, but you could achieve the same effect with nested lists.\nWe start with the target values ```\nM```\n and ```\nK```\n as constants and a given list of products. The key idea is to iterate over the list of products, starting with 0 products and adding one product at a time, each time updating a matrix (```\nsolvable```\n) that indicates which subproblems are solvable for the given partial list of problems.\nMore concretely, ```\nsolvable[i, j]```\n is True if the problem with m=i and k=j is solvable with the current partial list of products.\nThe function ```\none_more()```\n updates the ```\nsolvable```\n matrix for adding one more available product. Subproblems that have not been solvable without this new product become solvable if the subproblem with m and k reduced by the values of the new product is already solvable.\nOnce we have updated ```\nsolvable```\n with all the products, we can look up the solution of interest in the bottom right corner of this matrix.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack Backtracking Using only O(W) space\r\n                \r\nSo I have this code that I have written that correctly finds the optimal value for the knapsack problem.\n\n```\nint mat[2][size + 1];\nmemset(mat, 0, sizeof(mat));\n\nint i = 0;\nwhile(i < nItems)\n{\n    int j = 0;\n    if(i % 2 != 0)\n    {\n        while(++j <= size)\n        {\n            if(weights[i] <= j) mat[1][j] = max(values[i] + mat[0][j - weights[i]], mat[0][j]);\n            else mat[1][j] = mat[0][j];\n        }\n    }\n    else\n    {\n        while(++j <= size)\n        {\n            if(weights[i] <= j) mat[0][j] = max(values[i] + mat[1][j - weights[i]], mat[1][j]);\n            else mat[0][j] = mat[1][j];\n        }\n    }\n    i++;\n}\nint val = (nItems % 2 != 0)? mat[0][size] : mat[1][size];\ncout << val << endl;\nreturn 0;\n```\n\n\nThis part I udnerstand.  However I am trying to keep the same memory space, i.e. O(W), but also now compute the optimal solution using backtracking.  This is where I am finding trouble.  The hints I have been given is this\n\n```\nNow suppose that we also want the optimal set of items. Recall that the goal                                                         \n\nin ﬁnding the optimal solution in part 1 is to ﬁnd the optimal path from \n\nentry K(0,0) to entry K(W,n). The optimal path must pass through an \n\nintermediate node (k,n/2) for some k; this k corresponds to the remaining \n\ncapacity in the knapsack of the optimal solution after items n/2 + 1,...n \n\nhave been considered\n```\n\n\nThe question asked is this.\n\n```\nImplement a modiﬁed version of the algorithm from part 2 that returns not \nonly the optimal value, but also the remaining capacity of the optimal \nsolution after the last half of items have been considered\n```\n\n\nAny help would be apprecaited to get me started.  Thanks\n    ", "Answer": "", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Variation on 0/1 Knapsack Algorithm\r\n                \r\nI'm very new to programming and have been asked to solve a program for work. Right now we are dealing with a typical 0/1 Knapsack problem, in which the benefit/value is maximized given mass and volume constraints. \n\nMy task is to basically reverse this and minimize either the volume or mass given a value constraint. In other words, I want my benefit score to be greater than or equal to a set value and then see how small I can get the knapsack given that threshold value. \n\nI have tried researching this problem elsewhere and am sure that it probably has a formal name, however I am unable to find it. If anyone has any information I would greatly appreciate it. I am at a bit of a loss of how to go about solving this type of algorithm as you cannot use the same recursion formulas. \n    ", "Answer": "\r\nLet's call the weight of item i w(i), and its value v(i).  Order the items arbitrarily, and define f(i, j) to be the minimum possible capacity of a knapsack that holds a subset of the first i items totalling at least a value of j.\n\nTo calculate f(i, j), we can either include the ith item or not in the knapsack, so\n\n```\nf(i>0, j>0) = min(g(i, j), h(i, j))      # Can include or exclude ith item; pick the best\nf(_, 0) = 0                              # Don't need any capacity to reach value of 0\nf(i<=0, j>0) = infinity                  # Can't get a positive value with <= 0 items\n\ng(i, j) = f(i-1, j)                      # Capacity needed if we exclude ith item\nh(i, j) = f(i-1, max(0, j-v(i))) + w(i)  # Capacity needed if we include ith item\n```\n\n\nIn the last line, ```\nmax(0, j-v(i))```\n just makes sure that the second argument in the recursive call to ```\nf()```\n does not go negative in the case where ```\nv(i) > j```\n.\n\nMemoising this gives a pseudopolynomial O(nc)-time, O(nc)-space algorithm, where n is the number of items and c is the value threshold.  You can save space (and possibly time, although not in the asymptotic sense) by calculating it in bottom-up fashion -- this would bring the space complexity down to O(c), since while calculating ```\nf(i, ...)```\n you only ever need access to ```\nf(i-1, ...)```\n, so you only need to keep the previous and current \"rows\" of the DP matrix.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Intuition behind Knapsack 0-1 dynamic programming solution?\r\n                \r\nI've been studying dynamic programming as part of a course and have struggle for a few days with the DP solution for the knapsack 0-1 problem. My understanding of the problem and solution is this:\nwe have items ```\n(A, B, C, D)```\n, a knapsack that holds weight ```\nW = 10```\n maximum, and the weights/values of each item is ```\nA = 2w/1v, 2w/3v, 5w/8v, 6w,5v```\n.\nThe solution requires that we look at subproblems where we restrict the knapsack weight from 0 -> W and the items from A -> D.\nWhat I don't understand is\n\nHow does one arrive at this solution intuitively?\nWhy does the solution work even if the items are ordered differently since we need to iterate through each of the items?\nHow does the DP subproblem solution account for all possible combinations of knapsack solutions if one did this without DP and use a brute-force try all combinations approach?\n\n    ", "Answer": "\r\n\nNot sure what you mean by \"intuitively\" but we can develop an understanding of how to form recurrence relations and apply them to problem parameters.\n\nThe soution works regardless of order since each subproblem relates to the current item and the subproblems we already visited. The recurrence does account for \"all combinations\"; which is why if we visit A -> B, when we get to C, we are essentially trying A B AB C AC BC and ABC; if we rather visit A -> C, then B; we'd get the same overall set of possibilities, given that addition is associative (A C AC B BA BC BAC). (We don't actually visit all combinations, see 3.)\n\nWe account for all possibilities by generally visiting the entire search space of W*N. Since we are bound by W, all weight sum combinations will fall at or below it, and what the DP does is record the best seen value for each of those achievable weights. When we reach the ```\ni```\nth item, we don't need to know the specific combinations of items creating all the sums (we may want to track back for the actual items but that does not require an exhaustive record). For each weight we iterate over (we iterate over all possible weights each time we visit an item), we just need to know (1) the best value seen at the same weight (so not using this item), and (2) the best value seen at a weight lower by this item's weight (if we're using this item then we want to add its value to the best value seen at that lower weight so the two weights together represent the current weight we are at in the weight iteration). We choose the best of (1) and (2) for the value at ```\ndp[i][w]```\n.\n\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Loop not running and get struck with the first iteration -Python Knapsack problem (No error)\r\n                \r\nSelf new to Python and trying my skills on already run codes. Unable to get the output as required as a list of output rather getting only the first input and the details.\nFunction code blocks.\nblock-1\n```\nclass Food(object):\n    def __init__(self,n,v,w):\n        self.name=n\n        self.value=v\n        self.calories=w\n        \n    def getValue(self):\n        return self.value\n    \n    def getCost(self):\n        return self.calories\n    \n    def density(self):\n        return self.getValue()/self.getCost()\n    \n    def __str__(self):\n        return self.name + ': <'+str(self.value) +','+str(self.calories)+'>'\n```\n\nblock-2\n```\ndef buildMenu(names,values,calories):\n    menu=[]\n    for i in range(len(values)):\n        menu.append(Food(names[i],values[i],calories[i]))\n        return menu\n```\n\nblock-3\n```\ndef greedy(items,maxCost,keyFunction):\n    itemsCopy=sorted(items,key=keyFunction,reverse=True)\n    result=[]\n    totalValue,totalCost=0.0,0.0\n    \n    for i in range(len(itemsCopy)):\n        if(totalCost+itemsCopy[i].getCost())<=maxCost:\n            result.append(itemsCopy[i])\n            totalCost+=itemsCopy[i].getCost()\n            totalValue+=itemsCopy[i].getValue()\n    return (result,totalValue)\n```\n\nblock-4\n```\ndef testGreedy(items,constraint,keyFunction):\n    taken,val=greedy(items,constraint,keyFunction)\n    print('Total value of items taken',val)\n    for item in taken:\n        print('  ',item)\n```\n\nblock-5\n```\ndef testGreedys(foods,maxUnits):\n    print('Use greedy by value to allocate',maxUnits,'calories')\n    testGreedy(foods,maxUnits,Food.getValue)\n    print('\\nUse greedy by cost to allocate',maxUnits,'calories')\n    testGreedy(foods,maxUnits,lambda x:1/Food.getCost(x)) \n    print('\\nUse greedy by density to allocate',maxUnits,'calories')\n    testGreedy(foods,maxUnits,Food.density)\n```\n\nMain code blocks and input.\n```\nnames=['wine','beer','pizza','burger','fries','cola','apple','donut','cake']\nvalues=[89,90,95,100,90,79,50,10]\ncalories=[123,154,258,354,365,150,95,195]\nfoods=buildMenu(names,values,calories)\ntestGreedys(foods,750)\n```\n\nCurrent output below is taking only the first element.Actually it should run for the entire input item list in names.\n```\nUse greedy by value to allocate 750 calories\nTotal value of items taken 89.0\n   wine: <89,123>\n\nUse greedy by cost to allocate 750 calories\nTotal value of items taken 89.0\n   wine: <89,123>\n\nUse greedy by density to allocate 750 calories\nTotal value of items taken 89.0\n   wine: <89,123>\n```\n\nRequest your help to debug and find out why the complete loop not running as intended.\n    ", "Answer": "\r\nYour ```\nreturn```\n for ```\nmenu```\n is in the loop when you build a menu. This causes it to only ever return one item in the menu, move it back one indentation.\n```\ndef buildMenu(names,values,calories):\n    menu=[]\n    for i in range(len(values)):\n        menu.append(Food(names[i],values[i],calories[i]))\n    return menu\n\nTotal value of items taken 318.0\n   apple: <50,95>\n   wine: <89,123>\n   cola: <79,150>\n   beer: <90,154>\n   donut: <10,195>\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack: Adding items from lists (Python)\r\n                \r\nI'm trying to write a code for a Knapsack problem. Where there is a knapsack with a weight capacity and you pick a certain combination of items to find the best possible solution. I'm trying to randomly generate the possible solutions. So my code will pick a random number of random items (generate a random sized list) and test to see if the solution is feasible (less than the capacity) or infeasible (more than the capacity). However, when I try to add up the total weight and the total value of all the items, the number is off. Say for instance, this is the data of each item.\n\n```\nItms    Wts     Vals   \n=====================\n1       22      80\n2       29      35\n3       12      36\n4       14      24\n5       29      41\n6       30      87\n7       18      10\n8       22      63\n9       12      66\n```\n\n\n10       27      72\n\nHere would be the result after running the code:\n\n```\nItems picked:  [6, 4, 1, 7, 8, 3]\nFeasible:  Total Wt =  18 Total Val =  10\nItems picked:  [1]\nInfeasible:  Total Wt =  135 Total Val =  264\nItems picked:  [5, 1, 8, 6, 7, 4]\nInfeasible:  Total Wt =  89 Total Val =  198\n```\n\n\nSo the values are incorrect. But I don't see what is wrong in my code:\n\n```\ndef genSoln(cap,items):\n    g = input(\"Would you like to generate random potential solutions? [y/n] \")\n    if g == 'y':\n        gen = int(input(\"Number of times to generate/check random potential solutions? \"))\n        totalwt = 0\n        totalval = 0\n        for i in range(1,gen+1):\n            pop = range(1,items)\n            leng = random.randint(1,len(pop))\n            ran = random.sample(pop, leng)\n            for i in ran:\n                totalwt += int(wts[i])\n                totalval += int(vals[i])\n                if i == len(ran):\n                    if totalwt < int(cap):\n                        print(\"Items picked: \", ran)\n                        print(\"Feasible: \", \"Total Wt = \", totalwt, \"Total Val = \", totalval)\n                    else:\n                        print(\"Items picked: \", ran)\n                        print(\"Infeasible: \", \"Total Wt = \", totalwt, \"Total Val = \", totalval)\n                    totalwt = 0\n                    totalval = 0\n```\n\n    ", "Answer": "\r\nNevermind. I figured out the answer myself. I just needed to take out ```\nif i == len(ran):```\n , move ```\ntotalwt```\n and ```\ntotalval```\n into the for loop (```\nfor i in range(1,gen+1)```\n), and subtract 1 from i when adding to ```\ntotalwt```\nand  ```\ntotalval```\n.\n\n```\ndef genSoln(cap,items):\n    g = input(\"Would you like to generate random potential solutions? [y/n] \")\n    if g == 'y':\n        gen = int(input(\"Number of times to generate/check random potential solutions? \"))\n        for i in range(1,gen+1):\n            totalwt = 0\n            totalval = 0\n            pop = range(1,items)\n            leng = random.randint(1,len(pop))\n            ran = random.sample(pop, leng)\n            for i in ran:\n                totalwt += int(wts[i-1])\n                totalval += int(vals[i-1])\n            if totalwt < int(cap):\n                print(\"Items picked: \", ran)\n                print(\"Feasible: \", \"Total Wt = \", totalwt, \"Total Val = \", totalval)\n            else:\n                print(\"Items picked: \", ran)\n                print(\"Infeasible: \", \"Total Wt = \", totalwt, \"Total Val = \", totalval)\n```\n\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Are both conditions necessary (optimal structure and overlapping subproblem) for dynamic programming approach?\r\n                \r\nDoes every problem of DP posseses both property or any single property is sufficient ?\nIf both conditions are necessary, i can't see optimal substructure in knapsack problem.\n    ", "Answer": "\r\nFirst you need optimal structure, i.e., that the problem can be solved by solving smaller instances of the problem (sub-problems).  Then, if the sub-problems overlap, meaning that solving different sub-problems involves solving some of the same sub-sub-problems, then dynamic programming can help.  If there are no overlapping sub-problems then dynamic programming isn't necessary.\n\nFor unbounded knapsack with non-negative weights, let ```\nbest(m)```\n be the best sum <= m.  if ```\nbest(m) != 0```\n, then ```\nbest(m) = best(m-w[i]) + w[i]```\n for some weight ```\nw[i]```\n.\n\n```\nbest(m-w[i])```\n is a sub-problem.  If you can solve all of these, then solving the ```\nbest(m)```\n is easy, so knapsack has optimal structure.\n\nFurthermore, solving ```\nbest(m-w[i])```\n and ```\nbest(m-w[j])```\n will both require solving ```\nbest(m-w[i]-w[j])```\n, which is the same as ```\nbest(m-w[j]-w[i])```\n first, so knapsack has overlapping sub-problems.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Knapsack algorithm for multiplication\r\n                \r\nI have a set of ```\nN```\n numbers with some cost attached to each number, and the problem is to choose all possible set of numbers as a list such that their product is less than a certain number ```\nM```\n, sorted according to the sum of cost.\n\nEg :- The set of numbers is\n\n```\n(number, costOfThatNumber) : {(90, 10) , (80, 20), (60, 40), (40, 60), (15, 85)},\n```\n\n\nand the Product must be less than, ```\nProd <= 1000```\n,\n\nPossible solutions are :- \n\n```\n[Solution 1 :- {(15, 85), (40, 60)} :- Product = 600 (which is less than, 1000), cost = 85 + 60 = 145]\n[Solution 2 :- {(15, 85), (80, 20)} :- Product = 900 and cost = 105]\n```\n\n\nSo the list becomes, ```\n{Solution2, Solution1}```\n.\n\nPS :-\n\n\nThis is not a homework problem, it was asked in an interview. I was asked only the algorithm, all i could say was that it looks kinda similar to knapsack problem, but for multiplication.\nPlease excuse if i am unable to explain the problem properly.\n\n    ", "Answer": "\r\nI assume one can reduce the problem to the knapsack problem.\n\nNote that \n\n```\nx1 * x2 * ... * xn <= M <-> \nlog(x1*x2*...*xn) <= log(M) <-> \nlog(x1) + log(x2) + ... + log(xn) <= log(M)\n```\n\n\nSo finding the optimal solution using the knapsack can be done:\n\n```\nweight'(item) = log(weight(item))\nvalue(item) = value(item)\nM' = log(M)\nrun Knapsack on the items with weight', value, M'\n```\n\n\nMore work will be needed to get all feasible solutions, and not only the optimal, but since there are exponential number of those (```\n2^n```\n if ```\nM = infinity```\n), I doubt there is even pseudo-polynomial solution for this.\n\nA non efficient solution is just creating the power set (A set containing all possible sets), and checking each of them for feasibility and its value, and storing in ordered set the feasible solutions, according to their value. This post explains how to get the power set.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Efficient placement of variable size rectangles within a rectangular field\r\n                \r\nThis seems to me like it may be a version of the knapsack problem: I have a list of rectangles of varying sizes that I want to place within a field without overlapping or grouping similar sizes.\n\nWould it be correct to start looking in the knapsack direction?\n\nThanks.\n    ", "Answer": "\r\nyes, thats some the same kind of problem like the knapsack-problem - it's more difficult because you have to take care of 2 dimensions, not just one - but with looking for the knapsack-problem, you're on the right way.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
{"Question": "Bounded knapsack special case - small individual item weight is small compared to the number of items\r\n                \r\nFor the bounded knapsack problem, assuming the value of each item is the same as its weight and all weights are positive integers, I am wondering if there is an optimisation for the case where individual item weight is small compared to the number of items n and the capacity of the knapsack is half the sum of all item weights? e.g. 100k items and each item weight is restricted to [1, 10]. \n\nThe algorithm should give exact solution. I am aware of the O(n*W) time and O(W) space DP algorithm but thought there might be better ways to solve it in this case. Thanks in advance.\n\nThis is from an algo challenge and the O(n*W) time solution was functionally correct but not fast enough (a magnitude slower than what was required). And I can't seem to find anything on this problem. The input is a list of item weights and required output is the maximum total value of items that can be fitted into the knapsack.\n    ", "Answer": "\r\nThe paper you're looking for is Pisinger 1999, \"Linear Time Algorithms for Knapsack Problems with Bounded Weights\". It's a bit  of a pain though because the pdf seems to have lost the distinguishing markings on some of the variables.\n\nAdd the items to your solution in any order until you reach an item b - the break item -  which causes you to exceed W. The items 1, 2, ... b-1 constitute a balanced filling, and  all other balanced fillings are those that can be reached by a series of two operations:\n\n\nA balanced insert is the addition of an item at b or beyond to a balanced solution with weight <= W.\nA balanced remove is the removal of an item before b from a balanced solution with weight > W.\n\n\nIt's pretty easy to see two things: first that all balanced solutions are within 10 units of weight of W, and second that an optimal solution must be a balanced solution.\n\nWe find our way from the initial solution to the optimal one by dynamic programming. \n\n\nFor each item t from b onwards, \nand for each weight w such that W - 9 < w < W + 10,\nwe're going to keep track of the most recent item s before b \nsuch that there's a balanced filling of weight w which can be reached through adding/removing items solely between s and t\n\n\nRead that through a couple of times. Notice that some point along the way, we're guaranteed to run into an optimal solution (though we won't know it until the end). Letting wBreak be the weight before the break item is added, our algorithm is intitalized with:\n\n```\nfor (w = W-9, w <= W, w++) { s(b-1, w) = 0 }\nfor (w = W+1, w <= W+10, w++) { s(b-1, w) = 1 }\n\ns(b, wBreak) = b - 1\n```\n\n\nThese are all defaults, apart from s(b, wBreak). Then we get to the meat:\n\n```\nfor (t = b, t <= N, t++) \n{\n    for (w = W-9, w <= W, w++) \n    {\n        // Trying adding item t to the solutions with weight <= W \n        s(t, w + w_t) = max( s(t-1, w), s(t-1, w + w_t) )   \n    }\n    for (w = W+10, w > W, w--)\n    {\n        // Removing as many items as needed to get back to a balanced filling\n        for (j = s(t, w) - 1, j >= s(t-1, w), j--) \n        {\n            s(t, w - w_j) = max( s(t, w - w_j), j )\n        }\n    }\n}\n```\n\n\nIn all, this takes O(N) time, and we can identify the weight of the optimal filling as the nontrivial s(t,w) with w closest to W yet no larger than it.\n\nNote this doesn't take advantage of the fact that the sum of the weights of all items is 2W. I'll try and think of a simplification using that, but it might be the question setters added that so you don't have to worry about the trivial edge cases when there's not enough items to fill W.\n    ", "Knowledge_point": "Knapsack Problem", "Tag": "算法分析"}
