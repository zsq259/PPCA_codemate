{"Question": "Priority queue in .Net [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n            This post was edited and submitted for review last month and failed to reopen the post:\r\n            \r\n                    Original close reason(s) were not resolved\r\n            \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am looking for a .NET implementation of a priority queue or heap data structure\n\nPriority queues are data structures that provide more flexibility than simple sorting, because they allow new elements to enter a system at arbitrary intervals. It is much more cost-effective to insert a new job into a priority queue than to re-sort everything on each such arrival.\nThe basic priority queue supports three primary operations:\n\nInsert(Q,x). Given an item x with key k, insert it into the priority queue Q.\nFind-Minimum(Q). Return a pointer to the item\nwhose key value is smaller than any other key in the priority queue\nQ.\nDelete-Minimum(Q). Remove the item from the priority queue Q whose key is minimum\n\n\nUnless I am looking in the wrong place, there isn't one in the framework. Is anyone aware of a good one, or should I roll my own?\n    ", "Answer": "\r\nYou might like IntervalHeap from the C5 Generic Collection Library. To quote the user guide\n\nClass ```\nIntervalHeap<T>```\n implements interface ```\nIPriorityQueue<T>```\n using an interval heap stored as an array of pairs. The ```\nFindMin```\n and\n```\nFindMax```\n operations, and the indexer’s get-accessor, take time O(1). The ```\nDeleteMin```\n,\n```\nDeleteMax```\n, Add and Update operations, and the indexer’s set-accessor, take time\nO(log n). In contrast to an ordinary priority queue, an interval heap offers both minimum\nand maximum operations with the same efficiency.\n\nThe API is simple enough\n```\n> var heap = new C5.IntervalHeap<int>();\n> heap.Add(10);\n> heap.Add(5);\n> heap.FindMin();\n5\n```\n\nInstall from Nuget https://www.nuget.org/packages/C5 or GitHub  https://github.com/sestoft/C5/\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Comparison of Priority Queue implementations in Haskell\r\n                \r\nThere seem to be several priority queue implementations available off-the-shelf for Haskell. For instance, there's:\n\n\nData.PriorityQueue.FingerTree (in fingertree-0.0.1.0 on hackage)\nData.PurePriorityQueue (in pure-priority-queue-0.14 on hackage)\n\n\nboth of which appear to be pure priority queue data structures. The former is based on finger trees, a data structure with which I'm unfamiliar; the latter is a wrapper around Data.Map. There's also\n\n\nData.Heap (in heap-1.0.0 on hackage)\n\n\nwhich defines purely functional heap data structures from which one can trivially make priority queues. . There're also\n\n\nData.Heap (in heaps-0.2 on hackage)\nData.MeldableHeap (in meldable-heap-2.0.3 on hackage)\n\n\nwhich both implement purely functional meldable heaps using the Brodal/Okasaki data structure, which I believe is analogous to the binomial heap data structure in non-pure functional land. \n\n(Oh, and there's also\n\n\nData.PriorityQueue (in priority-queue-0.2.2 on hackage)\n\n\nwhose function is unclear to me, but which seems to be related  building priority queues attached to a monad, and which seems to be built on top of Data.Map anyhow. In this question, I'm concerned with purely functional priority queues, so I think the priority-queue-0.2.2 package is irrelevant. But correct me if I'm wrong!)\n\nI need a pure functional priority queue data structure for a project I'm building. I was wondering if anyone could provide any words of wisdom as I decide between the embarrassment of riches provided by hackage. Specifically:\n\n\nSuppose I want do features apart from the traditional priority queue insert and extract-min operations, in a purely-functional/immutable presentation. What are the pros and cons of the packages mentioned above? Does anyone have experience using any of them 'in anger'? What are the tradeoffs in performance? Reliability? Which are used more widely by others? (Using those might make my code easier for others to read, since they will be more likely to be familiar with the library.) Are there any other things I should know before making a decision between them?\nIf I also want efficient merging of priority queues, what then? (I don't for this project, but I thought adding this but would make the SO question more useful for future readers.)\nAre there any other priority queue packages out there that I missed out?\n\n    ", "Answer": "\r\nThere is an abundance of priority queue implementations to be found on hackage, just to complete your list:\n\n\nhttp://hackage.haskell.org/package/PSQueue\nhttp://hackage.haskell.org/package/pqueue\nhttp://hackage.haskell.org/package/queuelike\nhttp://hackage.haskell.org/package/priority-queue\nhttp://hackage.haskell.org/package/pure-priority-queue\nhttp://hackage.haskell.org/package/fingertree-psqueue\n\n\nOut of those I found that PSQueue has an especially nice interface. I guess it was one of the first implementations and is nicely covered in this paper by Ralf Hinze. It might not be the most efficient and complete implementation but so far it has served all my needs.\n\nThere is a very good article in the MonadReader (issue 16) by Louis Wassermann (who also wrote the pqueue package). In his article Louis gives a variety of different priority queue implementations and also includes algorithmic complexities for each.\nAs a striking example of the simplicity of some priority queue internals he includes some cool little implementations. My favorite one (taken from his article):\n\n```\ndata SkewHeap a = Empty | SkewNode a (SkewHeap a) (SkewHeap a) deriving (Show)\n\n(+++) :: Ord a => SkewHeap a -> SkewHeap a -> SkewHeap a\nheap1@(SkewNode x1 l1 r1) +++ heap2@(SkewNode x2 l2 r2) \n  | x1 <= x2    = SkewNode x1 (heap2 +++ r1) l1 \n  | otherwise = SkewNode x2 (heap1 +++ r2) l2\nEmpty +++ heap = heap\nheap +++ Empty = heap\n\nextractMin Empty = Nothing\nextractMin (SkewNode x l r ) = Just (x , l +++ r )\n```\n\n\nCool little implementation...a short usage example:\n\n```\ntest = foldl (\\acc x->acc +++ x) Empty nodes\n  where nodes = map (\\x-> SkewNode x Empty Empty) [3,5,1,9,7,2]\n```\n\n\nSome benchmarks of priority queue implementations can be found here and in a rather interesting thread on haskell.org here.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is there a priority queue implementation in ATS? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI need to do some sort of priority-based search. Could someone point me to a priority queue implementation in ATS?\n    ", "Answer": "\r\nYou can readily base a priority queue on a binomial heap.\n\nThere are two implementations of binomial heaps in ATS. Here are some use-cases:\n\nhttps://github.com/githwxi/ATS-Postiats/blob/master/doc/EXAMPLE/ATSLIB/libats_linheap_binomial.dats\n\nhttps://github.com/githwxi/ATS-Postiats/blob/master/doc/EXAMPLE/ATSLIB/libats_linheap_binomial2.dats\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "multiway priority queue implementation\r\n                \r\nhere is my code for multiway priority queue implementation\n\n```\n#include<iostream>\n#include<vector>\nusing namespace std;\ntemplate<class T>\nclass pq\n{\n    int d,n;\n    vector<int>pq;\n    vector<int>qp;\n    const vector<T>&a;\n    void exch(int i,int j)\n    {\n        int t=pq[i];\n        pq[i]=pq[j];\n        pq[j]=t;\n        qp[pq[i]]=i;\n        qp[pq[j]]=j;\n    }\n\n    void fixup(int k)\n    {\n        while(k>1 && a[pq[(k+d-2)/d]]>q[pq[k]])\n        {\n            exch(k,(k+d-2)/d);\n            k=(k+d-2)/d;\n        }\n    }\n\n    void fixdown(int k,int n)\n    {\n        int j;\n        while((j=d*(k-1)+2)<=n)\n        {\n            for(int i=j+1;i<j+d&& i<=n;i++)\n                if(a[pq[j]]>a[pq[i]])\n                    j=i;\n            if(!(a[pq[k]]>a[pq[j]]))\n                break;\n            exch(k,j);\n            k=j;\n        }\n    }\n\npublic:\n    pq(int n,const vector<T>&a,int d=3):a(a),pq(n+1,0),qp(n+1,0),n(0),d(d){}\n\n    int empty() const\n    {\n        return n==0;\n    }\n\n    void insert(int v)\n    {\n        pq[++n]=v ;\n        qp[v]=n;\n        fixup(n);\n    }\n\n    int getmin()\n    {\n        exch(1,n);\n        fixdown(1,n-1);\n        return pq[--n];\n    }\n\n    void lower(int k)\n    {\n        fixup(qp[k]);\n    }\n};\n\nint main()\n{\n    return 0;\n}\n```\n\n\nbut it has   some bugs,namely  i have made some incorrected constructor,here is two error which i see when run code\n\n```\n1>c:\\users\\\\documents\\visual studio 2012\\projects\\multiway_heap\\multiway_heap\\multiway_heap.cpp(8): error C2461: 'pq<T>' : constructor syntax missing formal parameters\n1>          c:\\users\\\\documents\\visual studio 2012\\projects\\multiway_heap\\multiway_heap\\multiway_heap.cpp(68) : see reference to class template instantiation 'pq<T>' being compiled\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped =========\n```\n\n\nso please help me to understand where is  bug\n    ", "Answer": "\r\nTry to understand what the compiler is telling you - its not that hard.\n\n```\nclass pq\n{\n/* ... */\n    vector<int> pq;    // I suppose this is line 8 according to compiler error\n```\n\n\nYou are using the same name for your class template and its member. This is not legal in c++.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Reusable Priority queue implementation in google go\r\n                \r\nHow would one go about writing the code for a reusable priority queue in Google Go or is one expected to define the ```\nLess```\n ```\nPush```\n and ```\nPop```\n function everytime a priority queue implementation is needed?\n    ", "Answer": "\r\nThe later case is what one has to do. As far as Go doesn't have generics, it's the only available option at the moment.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue implementation in C# [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 11 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying to implement a priority queue mechanism using SortedDictionary and I would like to get suggestions on my current implementation. \n\nMy implementation is as follows:\n\n```\npublic class PriorityQueue\n{\n    private Object lockObj;\n    private SortedDictionary<PQMsgPriority, Queue<PQMessage>> messageDictionary; \n\n    public PriorityQueue()\n    {\n        lockObj = new object();\n        messageDictionary = new SortedDictionary<PQMsgPriority, Queue<PQMessage>>();\n    }\n\n    public void Enqueue(PQMessage item)\n    {\n        lock (lockObj)\n        {\n            if(item != null && item.MsgPriority == PQMsgPriority.None)\n            {\n                if (messageDictionary.ContainsKey(item.MsgPriority))\n                {\n                    Queue<PQMessage> dataList = messageDictionary[item.MsgPriority];\n                    dataList.Enqueue(item);\n                    messageDictionary[item.MsgPriority] = dataList;\n                }\n                else\n                {\n                    Queue<PQMessage> dataList = new Queue<PQMessage>();\n                    dataList.Enqueue(item);\n                    messageDictionary.Add(item.MsgPriority, dataList);\n                }\n            }\n        }\n    }\n\n    public PQMessage Dequeue()\n    {\n        lock (lockObj)\n        {\n            PQMessage messageData = null;\n            PQMsgPriority deleteKey = PQMsgPriority.None;\n\n            //If no data available, throw an exception\n            if (messageDictionary.Count == 0)\n                throw new InvalidOperationException();\n\n            foreach (KeyValuePair<PQMsgPriority, Queue<PQMessage>> item in messageDictionary)\n            {\n                Queue<PQMessage> dataList = item.Value;\n                messageData = dataList.Dequeue();\n                messageDictionary[item.Key] = dataList;\n\n                //If there is no more elements remaining in the list, set a flag (deleteKey) for deleting the key\n                if (dataList.Count == 0) \n                    deleteKey = item.Key;\n\n                break;\n            }\n\n            //If the deleteKey flag is set, delete the key from the dictionary\n            if (deleteKey != PQMsgPriority.None)\n                messageDictionary.Remove(deleteKey);\n\n            return messageData;\n        }\n    }\n\n    public int Count()\n    {\n        lock (lockObj)\n        {\n            return messageDictionary.Count;\n        }\n    }\n\n    public PQMessage Peek()\n    {\n        lock (lockObj)\n        {\n            PQMessage messageData = null;\n\n            //If no data available, throw an exception\n            if (messageDictionary.Count == 0)\n                throw new InvalidOperationException();\n\n            foreach (KeyValuePair<PQMsgPriority, Queue<PQMessage>> item in messageDictionary)\n            {\n                Queue<PQMessage> dataList = item.Value;\n                messageData = dataList.Peek();\n                break;\n            }\n\n            return messageData;\n        }\n    }\n}\n\npublic enum PQMsgPriority\n{\n    High = 0,\n    Medium = 1,\n    Low = 2,\n    None = 3\n}\n\npublic class PQMessage\n{\n    private PQMsgPriority msgPriority;\n    private Object message;\n\n    #region Properties\n    public PQMsgPriority MsgPriority\n    {\n        get { return msgPriority; }\n        set { msgPriority = value; }\n    }\n    public Object Message\n    {\n        get { return message; }\n        set { message = value; }\n    }\n    #endregion\n\n    public PQMessage(PQMsgPriority msgPriority, Object message)\n    {\n        this.msgPriority = msgPriority;\n        this.message = message;\n    }\n}\n```\n\n\nIf there are any other approach for implementing a priority queue, please do point me in the right direction. \n    ", "Answer": "\r\n(I should just disclaimer this with I'm assuming you're doing this for learning rather than a bullet-proof implementation.  If want something that just works, then you are better off reusing an existing implementation).\n\nJust some general comments.  In the example below, the third line is unnecessary.\n\n```\nQueue<PQMessage> dataList = messageDictionary[item.MsgPriority];\ndataList.Enqueue(item);\nmessageDictionary[item.MsgPriority] = dataList;\n```\n\n\nThe ```\ndataList```\n you get returned from the ```\nmessageDictionary```\n is a copy of the reference within the map.  This means that when you ```\nEnqueue```\n the data, it's working on the same underlying queue as before (not a copy of the queue), therefore there's no need to put it back again, you can just remove that line.\n\nIn your dequeue implementation, you have a loop where you are breaking on the first element every time (e.g. you only ever go around the loop once).  Perhaps you could investigate using LINQ to get the ```\nFirst```\n element out and just return that straight away? (similarly for the ```\nPeek```\n implementation`).\n\nFinally, give that ```\nPQMessage```\n has a priority itself, perhaps you could consider using a ```\nSortedList```\n for your implementation? (see here)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is there priority queue data structure implementation in Ruby's standard library?\r\n                \r\nDoes Ruby's standard library have a priority queue implementation?\n    ", "Answer": "\r\nNope, but there's one in Kanwei Li's Algorithms and Containers GSoC 2008 project.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Best Data Structure for Priority Queue implementation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhich is the best Data Structure for Priority Queue implementation and why ?\n\nname some other Data Structures other than the best one to implement a Priority Queue and Tell its advantages and Disadvantages .Thanks. Thanks Thanks Thanks Thanks Thanks in advance so much thnx\n    ", "Answer": "\r\nUsually a heap is used because of the quick inserts O(log N)\n\nhttp://en.m.wikipedia.org/wiki/Heap_(data_structure)\n\nFor a discussion of the various structures used, and their advantages and disadvantages, see the discussion available here:\nhttp://en.m.wikipedia.org/wiki/Priority_queue\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue implementation in C\r\n                \r\nIs there any reliable and simple priority queue (linked list preferred, not necessary) implementation for C?\n\nMore generally, what C standard libraries do you use?\n    ", "Answer": "\r\nPQLib (the current accepted answer) is incomplete and the functionality doesn't match the documentation as of this posting.  E.g., the pq_dequeue documentation says it returns an entry.  The implementation returns NULL.  There are many \"TO DO\" comments in the code, such as, \"remove node containing highest priority entry from its heap.\"  Essential logic is missing.\n\nTo anyone looking for a priority queue: I recommend finding some code that has good, passing unit tests.  I don't recommend PQLib unless it's updated and includes tests.\n\nTo the owner of PQLib or anyone recommending it: I assumed this code was complete and spent a fair bit of time debugging until I realized it wasn't, which was frustrating.  Please don't recommend code you haven't tried or know to be a work in progress.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement Priority Queues in Python?\r\n                \r\nSorry for such a silly question but Python docs are confusing...\nLink 1: Queue Implementation\nhttp://docs.python.org/library/queue.html\nIt says that Queue has a class for the priority queue. But I could not find how to implement it.\n```\nclass Queue.PriorityQueue(maxsize=0)\n```\n\nLink 2: Heap Implementation\nhttp://docs.python.org/library/heapq.html\nHere they say that we can implement priority queues indirectly using heapq\n```\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>'      # placeholder for a removed task\ncounter = itertools.count()     # unique sequence count\n\ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue'\n```\n\nWhich is the most efficient priority queue implementation in Python? And how to implement it?\n    ", "Answer": "\r\nThere is no such thing as a \"most efficient priority queue implementation\" in any language.\nA priority queue is all about trade-offs. See http://en.wikipedia.org/wiki/Priority_queue\nYou should choose one of these two, based on how you plan to use it:\n\n```\nO(log(N))```\n insertion time and ```\nO(1)```\n (findMin+deleteMin)* time, or\n```\nO(1)```\n insertion time and ```\nO(log(N))```\n (findMin+deleteMin)* time\n\n\n(* sidenote: the findMin time of most queues is almost always O(1), so\nhere I mostly mean the deleteMin time can either be O(1) quick if the\ninsertion time is O(log(N)) slow, or the deleteMin time must be\nO(log(N)) slow if the insertion time is O(1) fast. One should note that\nboth may also be unnecessarily slow like with binary-tree based\npriority queues.)\n\nIn the latter case, you can choose to implement a priority queue with a Fibonacci heap: http://en.wikipedia.org/wiki/Heap_(data_structure)#Comparison_of_theoretic_bounds_for_variants (as you can see, ```\nheapq```\n which is basically a binary tree, must necessarily have ```\nO(log(N))```\n for both insertion and findMin+deleteMin)\nIf you are dealing with data with special properties (such as bounded data), then you can achieve ```\nO(1)```\n insertion and ```\nO(1)```\n findMin+deleteMin time. You can only do this with certain kinds of data because otherwise you could abuse your priority queue to violate the ```\nO(N log(N))```\n bound on sorting. vEB trees kind of fall under a similar category, since you have a maximum set size (```\nO(log(log(M))```\n is not referring to the number of elements, but the maximum number of elements) and thus you cannot circumvent the theoretical ```\nO(N log(N))```\n general-purpose comparison-sorting bound.\nTo implement any queue in any language, all you need is to define the ```\ninsert(value)```\n and ```\nextractMin() -> value```\n operations. This generally just involves a minimal wrapping of the underlying heap; see http://en.wikipedia.org/wiki/Fibonacci_heap to implement your own, or use an off-the-shelf library of a similar heap like a Pairing Heap (a Google search revealed http://svn.python.org/projects/sandbox/trunk/collections/pairing_heap.py )\n\nIf you only care about which of the two you referenced are more efficient (the ```\nheapq```\n-based code from http://docs.python.org/library/heapq.html#priority-queue-implementation-notes which you included above, versus ```\nQueue.PriorityQueue```\n), then:\nThere doesn't seem to be any easily-findable discussion on the web as to what ```\nQueue.PriorityQueue```\n is actually doing; you would have to source dive into the code, which is linked to from the help documentation: http://hg.python.org/cpython/file/2.7/Lib/Queue.py\n```\n   224     def _put(self, item, heappush=heapq.heappush):\n   225         heappush(self.queue, item)\n   226 \n   227     def _get(self, heappop=heapq.heappop):\n   228         return heappop(self.queue)\n```\n\nAs we can see, ```\nQueue.PriorityQueue```\n is also using ```\nheapq```\n as an underlying mechanism. Therefore they are equally bad (asymptotically speaking). ```\nQueue.PriorityQueue```\n may allow for parallel queries, so I would wager that it might have a very slightly constant-factor more of overhead. But because you know the underlying implementation (and asymptotic behavior) must be the same, the simplest way would simply be to run them on the same large dataset.\n(Do note that ```\nQueue.PriorityQueue```\n does not seem to have a way to remove entries, while ```\nheapq```\n does. However this is a double-edged sword: Good priority queue implementations might possibly allow you to delete elements in O(1) or O(log(N)) time, but if you use the ```\nremove_task```\n function you mention, and let those zombie tasks accumulate in your queue because you aren't extracting them off the min, then you will see asymptotic slowdown which you wouldn't otherwise see. Of course, you couldn't do this with ```\nQueue.PriorityQueue```\n in the first place, so no comparison can be made here.)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Indirect priority queue implementation\r\n                \r\nI am reading indirect priority queues in Robert Sedgewick's Algorithms in C++.\n\nThe implementation below maintains ```\npq```\n as an array of indices into some client array. For example, if the client defines ```\noperator<```\n for arguments of type ```\nIndex```\n, then, when ```\nfixUp```\n compares ```\npq[j]```\n with ```\npq[k]```\n, it is comparing ```\ndata.grade[pq[j]]```\n with ```\ndata.grade[pq[k]]```\n, as desired. We assume that Index is a wrapper class whose object can index arrays, so that we can keep the heap position corresponding to index value ```\nk```\n in ```\nqp[k]```\n, which allows us to implement \"change priority\" and \"remove\". We maintain the invariant ```\npq[qp[k]]=qp[pq[k]]=k```\n for all ```\nk```\n in the heap.\n\n```\ntemplate <class Index>\nclass PQ\n{\nprivate:\n    int N; Index* pq; int* qp;\n    void exch(Index i, Index j)\n    {\n        int t;\n        t = qp[i]; qp[i] = qp[j]; qp[j] = t;\n        pq[qp[i]] = i; pq[qp[j]] = j;\n    }\n\n    void fixUp(Index a[], int k);\n    void fixDown(Index a[], int k, int N);\n\npublic:\n    PQ(int maxN)\n    { \n        pq = new Index[maxN+1];\n        qp = new int[maxN+1]; N = 0; \n    }\n\n    int empty() const { return N == 0; }\n\n    void insert(Index v) { pq[++N] = v; qp[v] = N; fixUp(pq, N); }\n\n    Index getmax()\n    {\n        exch(pq[1], pq[N]);\n        fixDown(pq, 1, N-1);\n        return pq[N--];\n    }\n\n    void change(Index k)\n    { \n        fixUp(pq, qp[k]);\n        fixDown(pq, qp[k], N); \n    }\n};\n```\n\n\nThe main disadvantage of using indirection in this way is the extra space used. The size of the index arrays has to be the size of the data array, when the maximum size of the priority queue could be much less. Another approach to building a priority queue on top of existing data in an array is to have the client program make records consisting of a key with its array index as associated information, or to use an index key with a client-supplied overloaded ```\noperator<```\n. Then, if the implementation uses a linked-allocation representation. Then the space used by the priority queue would be proportional to the maximum number of elements on the queue at any one time. Such approaches would be preferred over Program 9.12 if space must be conserved and if the priority queue involves only a small fraction of the data array.\n\n\nWhat does the author mean by the below?\n\n\n  We assume that Index is a wrapper class whose object can index arrays\n\nIn improvement, the author is suggesting:\n\n\n  Another approach to building a priority queue on top of existing data in an array is to have the client program make records consisting of a key with its array index as associated information, or to use an index key with a client-supplied overloaded ```\noperator<```\n. Then, if the implementation uses a linked-allocation representation\n\n\nWhat does author mean here in the two points he is suggesting?\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Implementation in Go\r\n                \r\nI have just seen an implementation of a priority queue in a generic kind of way in which any\ntype satisfying an interface can be put into the queue. Is this the way to go with go or does this introduces any issues?\n\n```\n// Copyright 2012 Stefan Nilsson\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package prio provides a priority queue.\n// The queue can hold elements that implement the two methods of prio.Interface.\npackage prio\n\n/*\nA type that implements prio.Interface can be inserted into a priority queue.\n\nThe simplest use case looks like this:\n\n        type myInt int\n\n        func (x myInt) Less(y prio.Interface) bool { return x < y.(myInt) }\n        func (x myInt) Index(i int)                {}\n\nTo use the Remove method you need to keep track of the index of elements\nin the heap, e.g. like this:\n\n        type myType struct {\n                value int\n                index int // index in heap\n        }\n\n        func (x *myType) Less(y prio.Interface) bool { return x.value < y.(*myType).value }\n        func (x *myType) Index(i int)                { x.index = i }\n*/\ntype Interface interface {\n        // Less returns whether this element should sort before element x.\n        Less(x Interface) bool\n        // Index is called by the priority queue when this element is moved to index i.\n        Index(i int)\n}\n\n// Queue represents a priority queue.\n// The zero value for Queue is an empty queue ready to use.\ntype Queue struct {\n        h []Interface\n}\n\n// New returns an initialized priority queue with the given elements.\n// A call of the form New(x...) uses the underlying array of x to implement\n// the queue and hence might change the elements of x.\n// The complexity is O(n), where n = len(x).\nfunc New(x ...Interface) Queue {\n        q := Queue{x}\n        heapify(q.h)\n        return q\n}\n\n// Push pushes the element x onto the queue.\n// The complexity is O(log(n)) where n = q.Len().\nfunc (q *Queue) Push(x Interface) {\n        n := len(q.h)\n        q.h = append(q.h, x)\n        up(q.h, n) // x.Index(n) is done by up.\n}\n\n// Pop removes a minimum element (according to Less) from the queue and returns it.\n// The complexity is O(log(n)), where n = q.Len().\nfunc (q *Queue) Pop() Interface {\n        h := q.h\n        n := len(h) - 1\n        x := h[0]\n        h[0], h[n] = h[n], nil\n        h = h[:n]\n        if n > 0 {\n                down(h, 0) // h[0].Index(0) is done by down.\n        }\n        q.h = h\n        x.Index(-1) // for safety\n        return x\n}\n\n// Peek returns, but does not remove, a minimum element (according to Less) of the queue.\nfunc (q *Queue) Peek() Interface {\n        return q.h[0]\n}\n\n// Remove removes the element at index i from the queue and returns it.\n// The complexity is O(log(n)), where n = q.Len().\nfunc (q *Queue) Remove(i int) Interface {\n        h := q.h\n        n := len(h) - 1\n        x := h[i]\n        h[i], h[n] = h[n], nil\n        h = h[:n]\n        if i < n {\n                down(h, i) // h[i].Index(i) is done by down.\n                up(h, i)\n        }\n        q.h = h\n        x.Index(-1) // for safety\n        return x\n}\n\n// Len returns the number of elements in the queue.\nfunc (q *Queue) Len() int {\n        return len(q.h)\n}\n\n// Establishes the heap invariant in O(n) time.\nfunc heapify(h []Interface) {\n        n := len(h)\n        for i := n - 1; i >= n/2; i-- {\n                h[i].Index(i)\n        }\n        for i := n/2 - 1; i >= 0; i-- { // h[i].Index(i) is done by down.\n                down(h, i)\n        }\n}\n\n// Moves element at position i towards top of heap to restore invariant.\nfunc up(h []Interface, i int) {\n        for {\n                parent := (i - 1) / 2\n                if i == 0 || h[parent].Less(h[i]) {\n                        h[i].Index(i)\n                        break\n                }\n                h[parent], h[i] = h[i], h[parent]\n                h[i].Index(i)\n                i = parent\n        }\n}\n\n// Moves element at position i towards bottom of heap to restore invariant.\nfunc down(h []Interface, i int) {\n        for {\n                n := len(h)\n                left := 2*i + 1\n                if left >= n {\n                        h[i].Index(i)\n                        break\n                }\n                j := left\n                if right := left + 1; right < n && h[right].Less(h[left]) {\n                        j = right\n                }\n                if h[i].Less(h[j]) {\n                        h[i].Index(i)\n                        break\n                }\n                h[i], h[j] = h[j], h[i]\n                h[i].Index(i)\n                i = j\n        }\n}\n```\n\n    ", "Answer": "\r\nThis package is not the way to go in general, but if you like it and it meets your needs, use it.  I don't see any major issues.\n\nThe concept of this package compared to container/heap is to put the interface on the node rather than the container.  Container/heap allows more flexibility by using your container.  (You might have nodes in a container already, and that container might not even be a slice.  It just has to be indexable.)  On the other hand, it's probably a common case that you don't care about the container and would be happy to let the package manage it for you.  The index management of this package is a nice feature over container/heap, although it adds the overhead of a method call even when index management is not needed.\n\nThere are always tradeoffs.  Container/heap is very general.  This package gets by with a smaller method set (2 instead of 5) and adds index management on top, but only by sacrificing a bit of generality and perhaps a bit of performance in some cases.  (You'd want to benchmark if you really cared.  There are other differences that may dwarf the overhead of the Index call.)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Efficient way to implement Priority Queue in Javascript?\r\n                \r\nPriority Queues have a priority value and data, for every entry.\n\nThus, when adding a new element to the queue, it bubbles up to the surface if it has a higher priority value than elements already in the collection.\n\nWhen one calls pop, we get the data for the element with highest priority.\n\nWhat is an efficient implementation of such a priority queue in Javascript?\n\nDoes it make sense to have a new object called PriorityQueue, create two methods (push and pop) that take two params (data, priority)?  That much makes sense to me as a coder, but I'm uncertain of which data structure to use in the underbelly that will allow manipulation of the ordering of elements.  Or can we just store it all in an array and walk through the array every time to grab the element with max priority?  \n\nWhat's a good way to do this?\n    ", "Answer": "\r\nBelow is what I believe to be a truly efficient version of a ```\nPriorityQueue```\n which uses an array-based binary heap (where the root is at index ```\n0```\n, and the children of a node at index ```\ni```\n are at indices ```\n2i + 1```\n and ```\n2i + 2```\n, respectively).\n\nThis implementation includes the classical priority queue methods like ```\npush```\n, ```\npeek```\n, ```\npop```\n, and ```\nsize```\n, as well as convenience methods ```\nisEmpty```\n and ```\nreplace```\n (the latter being a more efficient substitute for a ```\npop```\n followed immediately by a ```\npush```\n). Values are stored not as ```\n[value, priority]```\n pairs, but simply as ```\nvalue```\ns; this allows for automatic prioritization of types that can be natively compared using the ```\n>```\n operator. A custom comparator function passed to the ```\nPriorityQueue```\n constructor can be used to emulate the behavior of pairwise semantics, however, as shown in the example below.\n\nHeap-based Implementation:\n\n\n\n```\nconst top = 0;\nconst parent = i => ((i + 1) >>> 1) - 1;\nconst left = i => (i << 1) + 1;\nconst right = i => (i + 1) << 1;\n\nclass PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this._heap = [];\n    this._comparator = comparator;\n  }\n  size() {\n    return this._heap.length;\n  }\n  isEmpty() {\n    return this.size() == 0;\n  }\n  peek() {\n    return this._heap[top];\n  }\n  push(...values) {\n    values.forEach(value => {\n      this._heap.push(value);\n      this._siftUp();\n    });\n    return this.size();\n  }\n  pop() {\n    const poppedValue = this.peek();\n    const bottom = this.size() - 1;\n    if (bottom > top) {\n      this._swap(top, bottom);\n    }\n    this._heap.pop();\n    this._siftDown();\n    return poppedValue;\n  }\n  replace(value) {\n    const replacedValue = this.peek();\n    this._heap[top] = value;\n    this._siftDown();\n    return replacedValue;\n  }\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]);\n  }\n  _swap(i, j) {\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\n  }\n  _siftUp() {\n    let node = this.size() - 1;\n    while (node > top && this._greater(node, parent(node))) {\n      this._swap(node, parent(node));\n      node = parent(node);\n    }\n  }\n  _siftDown() {\n    let node = top;\n    while (\n      (left(node) < this.size() && this._greater(left(node), node)) ||\n      (right(node) < this.size() && this._greater(right(node), node))\n    ) {\n      let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);\n      this._swap(node, maxChild);\n      node = maxChild;\n    }\n  }\n}\n```\n\n\n\n\n\n\nExample:\n\n\r\n\r\n```\n{const top=0,parent=c=>(c+1>>>1)-1,left=c=>(c<<1)+1,right=c=>c+1<<1;class PriorityQueue{constructor(c=(d,e)=>d>e){this._heap=[],this._comparator=c}size(){return this._heap.length}isEmpty(){return 0==this.size()}peek(){return this._heap[top]}push(...c){return c.forEach(d=>{this._heap.push(d),this._siftUp()}),this.size()}pop(){const c=this.peek(),d=this.size()-1;return d>top&&this._swap(top,d),this._heap.pop(),this._siftDown(),c}replace(c){const d=this.peek();return this._heap[top]=c,this._siftDown(),d}_greater(c,d){return this._comparator(this._heap[c],this._heap[d])}_swap(c,d){[this._heap[c],this._heap[d]]=[this._heap[d],this._heap[c]]}_siftUp(){for(let c=this.size()-1;c>top&&this._greater(c,parent(c));)this._swap(c,parent(c)),c=parent(c)}_siftDown(){for(let d,c=top;left(c)<this.size()&&this._greater(left(c),c)||right(c)<this.size()&&this._greater(right(c),c);)d=right(c)<this.size()&&this._greater(right(c),left(c))?right(c):left(c),this._swap(c,d),c=d}}window.PriorityQueue=PriorityQueue}\r\n\r\n// Default comparison semantics\r\nconst queue = new PriorityQueue();\r\nqueue.push(10, 20, 30, 40, 50);\r\nconsole.log('Top:', queue.peek()); //=> 50\r\nconsole.log('Size:', queue.size()); //=> 5\r\nconsole.log('Contents:');\r\nwhile (!queue.isEmpty()) {\r\n  console.log(queue.pop()); //=> 40, 30, 20, 10\r\n}\r\n\r\n// Pairwise comparison semantics\r\nconst pairwiseQueue = new PriorityQueue((a, b) => a[1] > b[1]);\r\npairwiseQueue.push(['low', 0], ['medium', 5], ['high', 10]);\r\nconsole.log('\\nContents:');\r\nwhile (!pairwiseQueue.isEmpty()) {\r\n  console.log(pairwiseQueue.pop()[0]); //=> 'high', 'medium', 'low'\r\n}```\n\r\n```\n.as-console-wrapper{min-height:100%}```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Heap based priority queue implementation\r\n                \r\nI've made a priority queue implementation that uses heap, but it works somewhat but I've encountered a problem where if I dequeue the priority queue it doesn't heapify correctly.\nFor example if I input 10 elements from an array ranging from 0 - 9, since this is a MaxHeap implementation it should always return the highest value and then heapify to correct the tree but it doesn't.\nWhen I dequeue and get 9 and I don't get 8 when I dequeue again, I instead get 0 because it swaps from the last index but it doesn't fix the tree.\nI've tried debugging and unit testing but I simply can't find where the problem is. I was wondering if some fresh eyes could see what I could not, thanks in advance!\n```\nimport java.lang.reflect.Array;\n\npublic class HeapPriorityQueue<T extends Comparable<? super T>> implements PriorityQueue<T> {\n    \n    private Class<T> clazz;\n    private int lastIndex, capacity;\n    private T heap[];\n    \n    public HeapPriorityQueue(Class<T> clazz, int capacity) {\n        this.clazz = clazz;\n        this.capacity = capacity;\n        this.heap = (T[]) Array.newInstance(clazz, capacity);\n        this.lastIndex = -1;\n    }\n    \n    @Override\n    public void clear() {\n        this.lastIndex = -1;\n        this.heap = (T[]) Array.newInstance(clazz, capacity);\n        System.out.println(\"The queue has been destroyed!\");\n    }\n\n    @Override\n    public boolean isEmpty() {\n        // TODO Auto-generated method stub\n        return lastIndex == -1;\n    }\n\n    @Override\n    public boolean isFull() {\n        // TODO Auto-generated method stub\n        return lastIndex == capacity-1;\n    }\n\n    @Override\n    public int size() {\n        // TODO Auto-generated method stub\n        return lastIndex;\n    }\n\n    @Override\n    public void enqueue(T element) {\n        if (!isFull()) {\n            heap[++lastIndex] = element;\n            shiftUp();\n            \n            String test = \"\";\n            for (int i = 0; i < heap.length; i++) {\n                test += \"\" + heap[i] + \" \";\n            }\n            System.out.println(test);\n        }\n    }\n\n    @Override\n    public T dequeue() {\n        if(isEmpty()) throw new QueueEmptyException();\n        T rootValue = heap[0];\n        swap(0, lastIndex);\n        heap[lastIndex] = null;\n        lastIndex--;\n        shiftDown();\n        String test = \"\";\n        for (int i = 0; i < heap.length; i++) {\n            test += \"\" + heap[i] + \" \";\n        }\n        System.out.println(test);\n        return rootValue;\n    }\n\n    @Override\n    public T getFront() {\n        if(isEmpty()) throw new QueueEmptyException();\n        return heap[0];\n    }\n    \n    private void shiftUp() {\n        int index = lastIndex;\n        int parentIndex = parent(index);\n        while (parentIndex > -1 && heap[index].compareTo(heap[parentIndex]) > 0) {\n            swap(index, parentIndex);\n            index = parentIndex;\n            parentIndex = parent(parentIndex);\n        }\n    }\n    \n    private void shiftDown() {\n        int index = 0;\n        \n        while (index < lastIndex) {\n            \n            T maxValue = heap[index];\n            int maxIndex = index;\n            \n            int leftIndex = left(index);\n            if (leftIndex > 0 && maxValue.compareTo(heap[leftIndex]) > 0) {\n                maxValue = heap[leftIndex];\n                maxIndex = leftIndex;\n            }\n            \n            int rightIndex = left(index);\n            if (rightIndex > 0 && maxValue.compareTo(heap[rightIndex]) > 0) {\n                maxValue = heap[rightIndex];\n                maxIndex = rightIndex;\n            }\n            \n            if (maxIndex == index) {\n                break;\n            }\n            \n            swap(maxIndex, index);\n            index = maxIndex;\n        }\n    }\n    \n    private int parent(int index) {\n        return index/2;\n    }\n    \n    private int left(int index) {\n        int leftChild = index * 2;\n        return leftChild;\n    }\n\n    private int right(int index) {\n        int rightChild = index * 2 + 1;\n        return rightChild;\n    }\n    \n    private void swap(int index1, int index2) {\n        T temp = heap[index1];\n        heap[index1] = heap[index2];\n        heap[index2 ] = temp;\n    }\n    \n    public static void main(String[] args) {\n        Integer[] data = {1, 2, 5, 6, 7, 8, 9, 10, 15, 20};\n        HeapPriorityQueue<Integer> pq = new HeapPriorityQueue<Integer>(Integer.class,10);\n        for (Integer i : data) {\n            pq.enqueue(i);\n        }\n        System.out.println(pq.dequeue());\n        System.out.println(pq.dequeue());\n    }\n    \n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue implemented Heap\r\n                \r\nHi so i am suppose to be making a priority queue implemented Heap in descending order, largest to small, I want to this with exponents. So i fnished my heap and priority queue classes, but now when making my class I get an error saying\n\n```\nxponents.java:66: error: invalid method declaration; return type required\npublic Exponent(int num, int exponent, int x)\n```\n\n\nI'm not sure where im going wrong\n\n```\n  public class Exponents implements Comparable<Exponents>\n{\n   private int num;\n   private int exponent;\n   private int x;\n\n   public Exponents(int num, int exponent, int x)\n   {\n      this.num = num;\n      this.exponent = exponent;\n      this.x = x;\n   }\n   public int Answer()\n   {\n      int x = Math.pow(num,exponent);\n      return x;\n   }\n\n    public String toString()\n   {\n      String s = (\"Exponent: \" + exponent + \"\\n Number: \"+ num + \"\\nYour x is: )\" + x);\n      return s;\n   }\n   public int compareTo(Answer e)\n   {\n      return this.x - o.x;\n   }\n}\n```\n\n\nProblem was fixed because of a typo and now im getting more errors, im not really sure what i wrote wrong: \n\n```\nExponents.java:83: error: cannot find symbol\n   public int compareTo(Answer e)\n                    ^\n  symbol:   class Answer\n  location: class Exponents\n\n\n\nExponents.java:74: error: incompatible types: possible lossy conversion from double to int\n      int x = Math.pow(num,exponent);\n\n\n                  ^\nExponents.java:85: error: cannot find symbol\n      return this.x - o.x;\n                  ^\n  symbol:   variable o\n  location: class Exponents\n3 errors\n```\n\n    ", "Answer": "\r\nThere's a typo in your constructor. Your class is named ```\nExponents```\n but in your constructor, it says ```\nExponent```\n. It becomes an invalid method declaration because it is looking for a return data type since the name of the 'constructor' you created is not the same as the name of the class.\n\nEdit:\n\n\nYou do not have a class name ```\nAnswer```\n.\nYou cannot implicitly cast double to int. You can use ```\nMath.pow(num,exponent).intValue()```\n\nYou do not have a variable named ```\no```\n within the scope of the method or the class.\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Difference between priority queue and a heap\r\n                \r\nIt seems that a priority queue is just a heap with normal queue operations like insert, delete, top, etc. Is this the correct way to interpret a priority queue? I know you can build priority queues in different ways but if I were to build a priority queue from a heap is it necessary to create a priority queue class and give instructions for building a heap and the queue operations or is it not really necessary to build the class?\nWhat I mean is if I have a function to build a heap and functions to do operations like insert and delete, do I need to put all these functions in a class or can I just use the instructions by calling them in ```\nmain```\n.\nI guess my question is whether having a collection of functions is equivalent to storing them in some class and using them through a class or just using the functions themselves.\nWhat I have below is all the methods for a priority queue implementation. Is this sufficient to call it an implementation or do I need to put it in a designated priority queue class?\n```\n#ifndef MAX_PRIORITYQ_H\n#define MAX_PRIORITYQ_H\n#include <iostream>\n#include <deque>\n#include \"print.h\"\n#include \"random.h\"\n\nint parent(int i)\n{\n    return (i - 1) / 2;\n}\n\nint left(int i)\n{\n    if(i == 0)\n        return 1;\n    else\n        return 2*i;\n}\n\nint right(int i)\n{\n    if(i == 0)\n        return 2;\n    else\n        return 2*i + 1;\n}\n\nvoid max_heapify(std::deque<int> &A, int i, int heapsize)\n{\n    int largest;\n    int l = left(i);\n    int r = right(i);\n    if(l <= heapsize && A[l] > A[i])\n        largest = l;\n    else\n        largest = i;\n    if(r <= heapsize && A[r] > A[largest])\n        largest = r;\n    if(largest != i) {\n        exchange(A, i, largest);\n        max_heapify(A, largest, heapsize);\n        //int j = max_heapify(A, largest, heapsize);\n        //return j;\n    }\n    //return i;\n}\n\nvoid build_max_heap(std::deque<int> &A)\n{\n    int heapsize = A.size() - 1;\n    for(int i = (A.size() - 1) / 2; i >= 0; i--)\n        max_heapify(A, i, heapsize);\n}\n\nint heap_maximum(std::deque<int> &A)\n{\n    return A[0];\n}\n\nint heap_extract_max(std::deque<int> &A, int heapsize)\n{\n    if(heapsize < 0)\n        throw std::out_of_range(\"heap underflow\");\n    int max = A.front();\n    //std::cout << \"heapsize : \" << heapsize << std::endl;\n    A[0] = A[--heapsize];\n    A.pop_back();\n    max_heapify(A, 0, heapsize);\n    //int i = max_heapify(A, 0, heapsize);\n    //A.erase(A.begin() + i);\n    return max;\n}\n\nvoid heap_increase_key(std::deque<int> &A, int i, int key)\n{\n    if(key < A[i])\n        std::cerr << \"New key is smaller than current key\" << std::endl;\n    else {\n        A[i] = key;\n        while(i > 1 && A[parent(i)] < A[i]) {\n            exchange(A, i, parent(i));\n            i = parent(i);\n        }\n    }\n}\n\nvoid max_heap_insert(std::deque<int> &A, int key)\n{\n    int heapsize =  A.size();\n    A[heapsize] = std::numeric_limits<int>::min();\n    heap_increase_key(A, heapsize, key);\n}\n```\n\n    ", "Answer": "\r\nA priority queue is an abstract datatype.  It is a shorthand way of describing a particular interface and behavior, and says nothing about the underlying implementation.\n\nA heap is a data structure.  It is a name for a particular way of storing data that makes certain operations very efficient.\n\nIt just so happens that a heap is a very good data structure to implement a priority queue, because the operations which are made efficient by the heap data strucure are the operations that the priority queue interface needs.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "python Priority Queue implementation\r\n                \r\ni'm having trouble creating an insert function with the following parameters. The insert function should take in a priority queue, and an element and inserts it using the priority rules - \n\nThe priority queue will take a series of tasks and order them\nbased on their importance. Each task has an integer priority from 10 (highest priority) to 1\n(lowest priority). If two tasks have the same priority, the order should be based on the order\nthey were inserted into the priority queue (earlier ﬁrst).\n\nSo, as of right now i've created the following code to initialize some of the things needed...\n\n```\nclass Tasks():\n    __slots__ = ('name', 'priority')\n\n     def __init__(bval):\n         bval.name = myName\n         bval.priority = myPriority\n         return bval\n\nclass PriorityQueue():\n    __slots__ = ('queue', 'element')\n\n     def __init__(aval):\n         aval.queue = queue\n         aval.element = element\n         return aval\n```\n\n\nThe code i'm trying to write is insert(element, queue): which should insert the elements using the priority queue. Similarly, myPriorty is an integer from 1 to 10. \n\nSimilarly can I do the following to insure that I create a priority from 1 to 10...\n\n```\ndef __init__(bval , myPriority = 10):\n      bval.priority = myPriority\n      bval.pq = [[] for priority in range(bval.myPriority)]\n```\n\n\nso that I can replace myPriority in the insert task with bval.pq\n    ", "Answer": "\r\nWhy are you trying to re-invent the wheel?\n\nfrom Queue import PriorityQueue\n\nhttp://docs.python.org/2/library/queue.html?highlight=priorityqueue#Queue.PriorityQueue\n\nThe lowest valued entries are retrieved first (the lowest valued entry is the one returned by sorted(list(entries))[0]). A typical pattern for entries is a tuple in the form:\n\n(priority_number, data).\n\nI use such a module to communicate between the UI and a background polling thread.\n\n```\nREAD_LOOP = 5\nLOW_PRI = 3\nMED_PRI = 2\nHI_PRI = 1\nX_HI_PRI = 0\n```\n\n\nand then something like this:\n\n```\nCoreGUI.TX_queue.put((X_HI_PRI,'STOP',[]))\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue implementation\r\n                \r\nI was trying to build a priority queue but there seems to be some inconsistency when I tested it. I overrode method ```\ncompareTo()```\n but somehow it return student with the youngest age. Why is that ? Shouldn't it be the student with age 22 (highest) ? Here is the code:\n\n```\npublic class Student implements Comparable<Student> {\n\n   private String name;\n   private int age;\n\n   public Student(int i) {\n      age = i;\n   }\n   public int getAge(){\n    return this.age;\n   }\n\n   public int print(){\n    return age; \n   }\n   @Override\n   public int compareTo(Student s) {\n    if(this.age < s.getAge()){return -1;}\n    else if(this.age > s.getAge()){return 1;}\n    else{return 0;}\n   }\n    public static void main(String[] args) {\n        Queue<Student> q = new PriorityQueue<Student>();\n        q.offer(new Student(21));\n        q.offer(new Student(18));\n        q.offer(new Student(22));\n\n        Student s = q.poll();\n        System.out.println(s.print());\n} \n```\n\n    ", "Answer": "\r\nJava's ```\njava.util.PriorityQueue```\n is defined as returning the least element, not the largest element, as you can find by checking the docs.\n\n\n  The head of this queue is the least element with respect to the\n  specified ordering. If multiple elements are tied for least value, the\n  head is one of those elements -- ties are broken arbitrarily. The\n  queue retrieval operations poll, remove, peek, and element access the\n  element at the head of the queue.\n\n\nWhether a priority queue is based on a minimum or maximum depends on the language and library, but minimum queues are by fat the most common from what I've seen.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Does Hazelcast have a distributed priority queue implementation?\r\n                \r\nWe need to implement a distributed priority queue within Hazelcast at the moment and the only documentation we can find on the matter is this: https://blog.hazelcast.com/priority-queueing-using-spi/, which is not a production ready implementation.\n\nIt references ```\nMigrationAwareService```\n and ```\nBackupAwareOperation```\n interfaces and provides a basic example for how to implement them, but after inspecting Hazelcast's own ```\nQueueService```\n it doesn't look like these examples will suffice. Is it better to use ```\nQueueService```\n as guidance instead?\n\nOn top of this, it looks as though there is no documentation or examples to make this custom distributed object adhere to Hazelcast's client-server protocol. \n\nDoes Hazelcast have any plans to implement this object in the near future? I've discovered ```\nOperationQueue```\n - is this a distributed priority queue implementation we can use?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue implementation - logical error in C++?\r\n                \r\nI'm trying to compare hsld (integer) in a structure called AdjList.\nThis is the function to be used for comparisons when entering pointers to the priority queue.\n\n```\nstruct CompareHSLD\n{\n    bool operator()(AdjList* const p1, AdjList* const p2)\n    {\n        return p1->hsld < p2->hsld;\n    }\n};\n```\n\n\nThis is the priority queue declaration.\n\n```\npriority_queue<AdjList*, vector<AdjList*>, CompareHSLD> PriQueueAdj;\n```\n\n\nUnable to figure out what the error is in this implementation. There is no syntax error but the priority queue doesn't seem to be sorted. It pops out the wrong elements.\n\nShould it be ```\np1->hsld > p2.hsld```\n if I want to pop the lowest value elements first?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue implementation explanation\r\n                \r\nI was reading Dijkstra's algorithm from the book competitive programming 1.In the implementation program they have written something like this :\n\n```\n#define pair<int,int> ii;\npriority_queue< ii,vector<ii>,greater<ii> > pq ;\n```\n\n\nIf we are taking an integer s as a source,the implementation shows to push pair (cost,source) like this (nodes are numbered from 1 to n) :\n\n```\npq.push(ii(0,s)) ;\n```\n\n\nMy question is we are pushing a pair of cost and node in the priority queue. But what the two other parameters (namely vector and greater ) are doing in the priority_queue declaration ? \n\n```\npriority_queue< ii,vector<ii>,greater<ii> > pq ;\n```\n\n\nI tried declaring something like :\n\n```\npriority_queue< ii > pq ;\n```\n\n\nAnd the code works (on those testcases I have tried) .\n\nCan anyone tell me what they meant by the declaration : \n\n```\npriority_queue< ii,vector<ii>,greater<ii> > pq ;\n```\n\n\nAnd what is the difference between the upper declaration and \n\n```\npriority_queue< ii > pq ;\n```\n\n\ndeclaration ?\n    ", "Answer": "\r\nSo the declaration of the template class is something like this:\n\n```\n\ntemplate <class T, class Container = vector<T>,\n  class Compare = less<typename Container::value_type> > class priority_queue;\n```\n\n\nThere are supposed to be three template parameters. The first one, \"T\", is the type of the elements (ii in your case). The second parameter is what I called \"underlying container\". You see, priority_queue is an adaptor, i.e. it uses other containers in secret while presenting to you another set of operations. (You might want to look up \"adaptor pattern\" on wikipedia.) For performance considerations, you can tell the compiler what container it should use underneath. The classes, ```\ndeque```\n and ```\nvector```\n from the standard library can be used. See here for the requirements for the container class. \n\nNow, the comparator is something you use to define the ordering of your elements. It can either be a function pointer or a class with the bracket operator overloaded. It takes two arguments of your element type, and returns (bool) \"true\" if the first element should appear after the second in the queue. It's useful when you want to change the default order, or use some exotic ways to order your elements.\n\ne.g. see below for a trivial example\n\n```\nstruct car{\n    car(double engine_displ):_engine_displ(engine_displ) {} \n    double _engine_displ;\n};\nbool cmp_cars(car one, car other){\n    return one._engine_displ < other._engine_displ;\n}\n//..somewhere else\nstd::priority_queue<car, std::vector<car>, cmp_cars> pq;\n```\n\n\nthe queue should then hold a ```\nstd::vector```\n-ful of cars sorted by engine displacement.  \n\nWhen there's something like ```\nclass Container = vector<T>```\n in the list of template arguments, the compiler filles in ```\nstd::vector<T>```\n for you when you don't say what your underlying container type is. That's why you can just say ```\npriority_queue<ii>```\n; the compiler extends it to ```\npriority_queue<ii,vector<ii>,less<ii>>```\n. In your example, the author of the book is explicitly using ```\ngreater<ii>```\n, so the queue should put the least element in front. It makes sense since in Dijkstra's algorithm, you're interested in the path that has the least cost. ```\npriority_queue<ii>```\n uses ```\nless<ii>```\n by default, so now the queue would put the path with the largest cose in front, which doesn't make sense.\n\nAs a side note, you might find that the code is actually ```\ntypedef pair<int,int> ii```\n. The ```\n#define```\n directive tells the preprocessor to replace every ```\npair<int,int>```\n with \"ii\", which doesn't help at all. Typedef tells the compiler \"ii\" means ```\npait<int,int>```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "PHP Priority Queue Implementation\r\n                \r\nI just finished coding a complex job assignment application where a lot of the work was done using priority queues. When I deployed, however, I discovered the web server ran PHP 5.2.\n\nHas there been an implementation for PHP<5.3 that can server as a drop-in replacement for SPLPriorityQueue?\n    ", "Answer": "\r\nI don't know of anything that has the same interface. \n\nBut, I'd like to point out that if you don't need the performance characteristics of the heap implementation(small data sets probably don't), it wouldn't be much work to write your own using a regular php array.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing Priority queue using hashmap\r\n                \r\nThis may be a very naive question or does not make sense. But i am really confused about implementation of priority queue.\n Why we cannot use a hashmap with key as priority and value as the data with that priority.\nAm i missing some basic here.\nFor eg:\nIf priority of A is 1,  B is 3 and c is 4\nwe can simply keep 1,3,4 as keys and A,B,C as values of hashmap respectively for priority queue implementation.\nPlease clear my logic\n    ", "Answer": "\r\nThe problem with that implementation is that it doesn't take advantage of the HashMap capabilities to easily access any element given the key. Since you are making a queue, you won't have the priorities 1, 3, 4 later, and will just need to find the highest priority of the map, having to iterate it entirely to do so!\n\nA map works something like this: it creates a gigantic array with null values in all positions (very, vey big). Then, it uses a formula to take your key, normally a string or a string representation and turn that into a number. A simple way to do this would be to sum the char codes of each letter, though that is a bad choice for the map, you can look it up why later. Then, it caps that number with modulus (remainder) size of the array (e.g., n % size in Java), so that it becomes a valid position in the array, and then put the element there. That way, it is very easy to make intensive search, because you don't need to search, you know exactly where each element is.\n\nTherefore, implementing a queue with a Map would be very memory intensive, without the clear advantage of the HashMap search. Furthermore, iterating over it is very, very expensive, because you need to iterate over a gigantic array and ignore the null values; you are not sure where the actual values are. Imagine in your example, that the priorities go from 0 to 100. Even though you would never have 100 tasks, you would have a 100 position array to iterate over, checking on each position if there is a task with that priority.\n\nA better way would be to use a simple list and store the priority within the data. Assuming that the priority doesn't change over time, you will just need to iterate once upon adding, to find the correct place, and always access the first (or last) element, the one with known highest priority.\n\nOn a final note o performance, it is better to iterate upon adding, even though you are adding the exact same amount of time that you are searching. Because when you search for the highest priority, you need to go until the end, every time, because maybe the last element is the bigger one. Note that the HashMap won't store your items organized in neat crescent order, even if your keys are numeric Strings or Integer. It is designed specially not to do that, to avoid conflicts (two similar objects having the same key, and thus requiring the need to add a list to that particular position of the big array). When you add, however, assuming your list is already ordered, you just need to iterate until you reach the correct destination.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Block(array) implementation of a priority queue?\r\n                \r\nI'm just studying for exams right now, and came across this question in the sample exam:\n\nBlock Implementation of a Priority Queue\n\nIf we know in advance that a priority queue will only ever need to cater for a small number of discrete priorities (say 10), we can implement all operations of the priority queue in constant time by representing the priority queue as an array of queues - each queue storing the elements of a single priority. Note that while an operation may be linear in the number of priorities in the priority queue, the operation is still constant with respect to the size of the overall data structure.\n\nThe Objects stored in this priority queue is not comparable.\n\nI have attempted it but I am lost as to how I am supposed to assign priority with a array implementation priority queue. \n\nI have also tried looking for solutions, but all I've managed to find are examples that used Comparable, which we did not learn in this course. \n\nQuestion: https://i.stack.imgur.com/5F4YS.jpg\n    ", "Answer": "\r\nEach of the arrays will correspond to a different priority.  Your lowest level priority array will deal only with objects of that priority level.  Your highest level priority array will deal with objects of highest priority level, and so on.  When you receive a new object, you place it into the array that corresponds to its priority.\n\nIt doesn't matter, then, that objects are not comparable since they are sorted by priority based on the stratification of the arrays.  Then, when you are looking for next elements to execute, you check the highest priority array and see if there are any elements; if not, move to the next priority, and so on through each array.\n\nI'm hoping I understood the problem and your question correctly; let me know if you have any additional questions in regards to my answer.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ Priority Queue implementation to sort graph edges\r\n                \r\nI am trying to sort graph edges but am unable to do so. \nGiven below is my implementation of a priority queue to achieve the same.\n\n```\n  class CompareDistance\n    {\n        public:    \n            bool operator()(pair<int,int> n1,pair<int,int> n2)\n            {\n                if(g[n1.first][n2.second] < g[n2.first][n2.second])\n                return true;\n                else\n                return false;\n           }\n    };\n    int g[3][3] = {{4,1,3},{3,3,3},{3,3,3}};//graph edges\n\n\nint main()\n{\n\n    priority_queue<pair<int,int>,vector<pair<int,int> >,CompareDistance> pq;\n\n\n    for(int i = 0 ; i < 3 ; i++)\n        for(int j = 0 ; j < 3 ; j++)\n            pq.push(pair<int,int>(i,j));\n\n    cout<<\"\\t\"<<g[pq.top().first][pq.top().second];//does not give the correct result\n    pq.pop();\n\n\n\n\n    getch();\n}\n```\n\n    ", "Answer": "\r\nOK so if I understood you correctly you have a directed graph (like in example complete graph of three nodes). With each of the arc there is associated value -- weight and what you need is to sort the collection of arcs by this value. \nFirst of all you should probably create the collection of arcs. I don't think the priority_queue is the best of your option. I would use the vector here because of the simplicity:\n\n```\nstd::vector<std::pair<int, std::pair<int, int>>> arcs;\n```\n\n\nWhere the first pair would contain the arc weight and the directed pair of the nodes between which the arc exists.\nNext after you add all of the nodes you simply sort the collection specifing the custom function to compare. If you use c++11 it could look as follows:\n\n```\nstd::sort(arcs.begin(), arcs.end(), \n          [] (const std::pair<int, std::pair<int, int>>& a,\n              const std::pair<int, std::pair<int, int>>& b) { \n                  return a.first < b.first; \n              });\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Fast double-valued priority queue implementation in Java\r\n                \r\nI am looking for an implementation of a priority queue that uses constant ```\ndouble```\n values as priorities for the key. I believe that this, if implemented properly, can be faster than the default ```\nPriorityQueue```\n implementation with a flexible comparator. A decreaseKey operation (=decreasing the priority of an element already in the queue) is not necessary.\n\nI have found an implementation from the NLP group in Stanford, but they claim that it's twice as slow as the original implementation. Is there a PQ implementation out there that can outperform the default ```\nPriorityQueue```\n for our use case?\n    ", "Answer": "\r\nTry using the Sedgewick-Wayne code at\n\nhttp://algs4.cs.princeton.edu/24pq/MaxPQ.java.html\n\nbut replace the generic Key type with double and remove the Comparable/Comparator code.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Generic Priority Queue java implementation\r\n                \r\nI need to implement a Generic Priority Queue in JAVA. Note that both key and value is Generic. And all the data structures must be user implemented. The use of Java collections or any other data structures library is strictly forbidden. I used an Array to store data inside the Queue. But apparently generic array declaration is not possible. I can not use array list because then I will have to import libraries. \nAnd the code must be inside a single file. That class must implement a interface.\nInterface:\n\n```\n    public interface PQK<P extends Comparable<P>, T> {\n\n    // Return the length of the queue\n    int length();\n\n    // Enqueue a new element. The queue keeps the k elements with the highest priority. In case of a tie apply FIFO.\n    void enqueue(P pr, T e);\n\n    // Serve the element with the highest priority. In case of a tie apply FIFO.\n    Pair<P, T> serve();\n}\n```\n\n\nClass I wrote for the priority queue implementing the given interface:\n\n```\npublic class PQKImp<P extends Comparable<P>, T> implements PQK<P, T> {\n\n    private int size;\n    private int capacity;\n    private Pair<P , T>[] heap;\n\n    public PQKImp(int k) {\n        heap = new Pair<P,T>[k];\n        this.capacity = k;\n        this.size = 0;\n    }\n\n    public int length(){\n        return size;\n    }\n\n    public void enqueue(P pr, T e){\n        Pair<P ,T> pair = new Pair<P,T>(pr , e);\n        heap[++size] = pair;\n        int pos = size;\n        while(pos!=1 && pair.first.compareTo(heap[pos/2].first)<0){\n            heap[pos] = heap[pos/2];\n            pos /= 2;\n        }\n        heap[pos] = pair;\n    }\n\n    public Pair<P,T> serve(){\n        return heap[0];\n    }\n}\n\n```\n\n\nThis is the error i'm getting:\n\n```\n.\\PQKImp.java:8: error: generic array creation\n                heap = new Pair<P,T>[k];\n                       ^\n1 error\n```\n\n\nCan you please suggest me an possible method to store data in my class.\nThank you\n    ", "Answer": "\r\n```\nclass Employee implements Comparable<Employee>{\n    String name;\n    int rollNumber;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getRollNumber() {\n        return rollNumber;\n    }\n\n    public void setRollNumber(int rollNumber) {\n        this.rollNumber = rollNumber;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee [name=\" + name + \", rollNumber=\" + rollNumber + \"]\";\n    }\n\n    public Employee(String name, int rollNumber) {\n        super();\n        this.name = name;\n        this.rollNumber = rollNumber;\n    }\n\n    @Override\n    public int compareTo(Employee o) {\n        return rollNumber - o.getRollNumber();\n    }\n\n}\n\npublic class PriorityQueueImplementation {\n    public static void main(String[] args) {\n        PriorityQueue<Employee> employees = new PriorityQueue<>();\n\n        Employee e1 = new Employee(\"A\", 1);\n        Employee e2 = new Employee(\"B\", 3);\n        Employee e3 = new Employee(\"C\", 2);\n        Employee e4 = new Employee(\"D\", 5);\n        Employee e5 = new Employee(\"E\", 6);\n        Employee e6 = new Employee(\"F\", 8);\n        Employee e7 = new Employee(\"G\", 10);\n        Employee e8 = new Employee(\"H\", 4);\n        Employee e9 = new Employee(\"I\", 7);\n        Employee e10 = new Employee(\"J\", 9);\n\n        employees.add(e1);\n        employees.add(e2);\n        employees.add(e3);\n        employees.add(e4);\n        employees.add(e5);\n        employees.add(e6);\n        employees.add(e7);\n        employees.add(e8);\n        employees.add(e9);\n        employees.add(e10);\n        \n        for (Employee employee : employees) {\n            System.out.println(employee);\n        }\n        \n        System.out.println();\n        System.out.println(\"Print By Priority Queue\");\n        while(!employees.isEmpty()) {\n            System.out.println(employees.remove());\n        }\n\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Concurrent Priority Queue in .NET 4.0\r\n                \r\nIt seems there are lots of improvements in .NET 4.0 related to concurrency that might rely on concurrent priority queues. Is there decent priority queue implementation inside framework available for reuse?\n    ", "Answer": "\r\nThere is an implementation as part of \"Samples for Parallel Programming with the .NET Framework\" at msdn. See ParallelExtensionsExtras.\nDirect link to source code for file ConcurrentPriorityQueue.cs\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "An efficient way to implement circular priority queue?\r\n                \r\nI have designed a circular priority queue. But it took me a while because it is so conditional and has a bit much of a time complexity.\n\nI implemented it using a list. But I need a more efficient circular priority queue implementation.\n\nI'll illustrate my queue structure, sometimes it would be helpful for someone who seeks for a code to understand circular priority queues.\n\n```\nclass PriorityQueue:\n\n    def __init__(self,n,key=None):\n        if key is None:\n            key=lambda x:x\n        self.maxsize = n\n        self.key=key\n        self.arr = list(range(self.maxsize))\n        self.rear = -1\n        self.front = 0\n        self.nelements=0\n\n    def isPQueueful(self):\n        return self.nelements==self.maxsize\n\n    def isPQueueempty(self):\n        return self.nelements==0\n\n    def insert(self, item):\n\n        if not self.isPQueueful():\n            pos=self.rear+1\n            scope = range(self.rear - self.maxsize, self.front - self.maxsize - 1, -1)\n            if self.rear==0 and self.rear<self.front:\n                scope=range(0,self.front-self.maxsize-1,-1)\n            for i in scope:\n                if self.key(item)>self.key(self.arr[i]):\n                    self.arr[i+1]=self.arr[i]\n                    pos=i\n                else:\n                    break\n            self.rear+=1\n            if self.rear==self.maxsize:\n                self.rear=0\n            if pos==self.maxsize:\n                pos=0\n            self.arr[pos]=item\n            self.nelements+=1\n        else:\n            print(\"Priority Queue is full\")\n\n    def remove(self):\n\n        revalue=None\n        if not self.isPQueueempty():\n            revalue=self.arr[self.front]\n            self.front+=1\n            if self.front==self.maxsize:\n                self.front=0\n            self.nelements-=1\n\n        else:\n            print(\"Priority Queue is empty\")\n        return revalue\n```\n\n\nI really appreciate if someone can say whether what I designed is suitable for used in a production code. I think mostly it is not an efficient one. \n\nIf so can you point out to me how to design a efficient circular priority queue?\n    ", "Answer": "\r\nSo, think of the interface and implementation separately.\n\nThe interface to a circular priority queue will make you think that the structure is a circular queue.  It has a \"highest\" priority head and the next one is slightly lower, and then you get to the end, and the next one is the head again.\n\nThe methods you write need to act that way.\n\nBut the implementation doesn't actually need to be any kind of queue, list, array or linear structure.\n\nFor the implementation, you are trying to maintain a set of nodes that are always sorted by priority. For that, it would be better to use some kind of balanced tree (for example a red-black tree).\n\nYou hide that detail below your interface -- when you get to the end, you just reset yourself to the beginning -- your interfaces makes it look circular.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue implementation with updatePriority O(log n)\r\n                \r\nI have to implement a function with complexity O(log n), that updates priority of an element in the priority queue. That means that given an element, access to its priority should be O(1). I don't really understand how this can be done, if all elements are stored in a heap, and their position is constantly changing, which gives me O(n) search of the element in the heap. \n\nHeap :\n\n```\npublic class Heap<K, V> {\n  private int size;\n  private Element<K, V> heap[];\n  private Comparator<? super K>  comparator;\n\n  public Heap(Comparator<? super K>  comparator) {\n  //\n  }\n\n  //\n  public void add(K priority, V value) {\n    int i;\n\n    size++;\n    if(size > heap.size()) resize();\n\n    i = size;\n    heap[i] = new Element(priority, value);\n\n    while(i > 0 || comparator.compare(heap[parent(i)].priority, heap[i].priority) < 0) {\n      swap(i, parent(i));\n    }\n  }\n\n  // O(log n)\n  public void updatePriority(int i, K priority) {\n    K oldPriority = heap[i].priority;\n    heap[i] = new Element(priority, heap[i].value);\n\n    if(comparator.compare(oldPriority, heap[i].priority) > 0) {\n      heapify(i);\n    } else {\n      while(i > 0 && comparator.compare(heap[parent(i)].priority, heap[i].priority)) < 0) {\n        swap(i, parent(i));\n        i = parent(i);\n      } \n    }\n  }\n }\n```\n\n\nPriorityQueue:\n\n```\npublic class PriorityQueue<K, V> {\n\n  private Heap<Element<K, V>> heap;\n  private Comparator<? super K>  comparator;\n\n  public PriorityQueue(Comparator<? super K>  comparator) {\n    heap = new Heap<K, V>(comparator);\n  }\n\n  //\n\n  // Should be O(log n)\n  public void updatePriority(K priority, V elem) {\n    // get index of elem in O(1)\n    heap.updatePriority(indexOfElem, priority);\n  }\n}\n```\n\n\nElement:\n\n```\npublic class Element<K, V> {\n  public K priority;\n  public V value;\n\n  public Element(K priority, V value) {\n    this.priority = priority;\n    this.value = value;\n  }\n}\n```\n\n\nThis priority queue later should be used to implement Prim's algorithm. So what can I do to get O(1) access complexity?\n    ", "Answer": "\r\nI can think of two approaches:\n\n\nYou can add a ```\nMap<V, Integer>```\n that maps from values to indices. This means some extra bookkeeping, but it's not too bad, because you need to update it exactly when you add or move an element in your main array, so you can easily put that in a single ```\nsetElement```\n method that you always use when manipulating the array. (You could even move the array itself into a helper class that handles that.)\nWhen updating priority, you don't necessarily need to remove the original element; depending on the rest of your algorithm, it may be fine to simply add the new one and mark the old one as \"deleted\". (Deleted elements can be cleared from the array either periodically (amortized-constant time) or when detected.) You can do this by adding a ```\nMap<V, Element<K, V>>```\n mapping from the value to the current element. You can either add an explicit \"deleted\" flag to your ```\nElement```\n class, or just count an element as deleted if its value is no longer mapped to it in your ```\nMap<V, Element<K, V>>```\n.\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Trouble understanding Priority Queue implementation of Dijkstra\r\n                \r\nI am having some trouble wrapping my head around what exactly is the logical flow in which we implement Dijkstra, more precisely what I am having a problem with is how do we actually GET that priority queue, do we build it ( the Priority Queue ) as we go about executing the algorithm on a graph? Or am I looking at this wrong? And then is that it? Do we stop there or do we process this output even further by placing the obtained information in the Priority Queue in some other form or is this is the place where we stop?\n\nI also understand the procedure of producing the corresponding shortest paths which for a chosen node, by recursively following the edges that we took to form the shortest path in the first place, but how is it actually implemented?\n\nIn general I'm having a lot of problems actually being able to think up and/or understand suitable implementations of algorithms during my study, I understand the algorithm just fine ( and in some cases I am able to think of a close substitute ) but I just cannot think up clever ways of implementing them, any suggestions?\n    ", "Answer": "\r\nMy best advice is to start with bfs first. If you can implement BFS, you are just one step away from Dijkstra. BFS uses normal queue (first in first out), Dijkstra uses priority queue (element is chosen according to the current distance to source node). That is the only difference.\n\nTo answer your specific question:\n\n\nHow do we actually GET that priority queue? You start with an empty queue. At every iteration (Dijkstra most often is implemented iteratively, not recursively), you pick the node with the highest priority out of the queue, and push back in queue all the neighbors of that node that have not been visited yet\ndo we build it ( the Priority Queue ) as we go about executing the algorithm on a graph? Yes, at every iteration, you pick out one node, and push in multiple nodes to the priority queue\nAnd then is that it? Yes, it is pretty much it. \nMinor details: (1) You need to keep track of which nodes that have been picked out (and never push it back in) (2) It is possible to push a node multiple times into the queue, and it is fine, (3) You need a trace array to trace back the path along which you reach the node: every time you push a node into the queue, record the trace of that node to be the currently visited node (just popped from the queue)\n\n\nAgain, start with BFS and you will find Dijkstra pretty simple\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementation of priority queue by AVL Tree data structure\r\n                \r\nPriority queue:\n          Basic operations: Insertion\n                      Delete (Delete minumum element)\n\nGoal: To provide efficient running time or order of growth for above functionality.\n\nImplementation of Priority queue By:\n\n```\nLinked List: Insertion will take o(n) in case of insertion at end o(1) in case of \n             insertion at head.\n             Delet (Finding minumum and Delete this ) will take o(n) \n\nBST:\n   Insertion/Deltion of minimum = In avg case it will take o(logn) worst case 0(n)\n\nAVL Tree: \n   Insertion/deletion/searching: o(log n) in all cases.\n```\n\n\nMy confusion goes here:\n\nWhy not we have used AVL Tree for implementation of Priority queue, Why we gone \n   for Binary heap...While as we know that in AVL Tree we can do  insertion/ Deletion/searching in o(log n) in worst case.\n    ", "Answer": "\r\nComplexity isn't everything, there are other considerations for actual performance.\n\nFor most purposes, most people don't even use an AVL tree as a balanced tree (Red-Black trees are more common as far as I've seen), let alone as a priority queue.\n\nThis is not to say that AVL trees are useless, I quite like them. But they do have a relatively expensive insert. What AVL trees are good for (beating even Red-Black trees) is doing lots and lots of lookups without modification. This is not what you need for a priority queue.\n\nAs a separate consideration -- never mind your O(log n) insert for a binary heap, a fibonacci heap has O(1) insert and O(log N) delete-minimum. There are a lot of data structures to choose from with slightly different trade-offs, so you wouldn't expect to see everyone just pick the first thing that satisfies your (quite brief) criteria.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Brodal priority queue implementation\r\n                \r\nHave someone ever implemented a Brodal queue?\n\nIs it worth implementing or has high running time constants like the Fibonacci Heap?\n    ", "Answer": "\r\nThis is a Haskell implementation of Brodal–Okasaki, which is a purely functional variant of Brodal's original data structure with the same time bounds. Since Brodal–Okasaki claim that their structure can be derived by tweaking binomial queues, I expect that pairing heaps would be faster for most uses, though depending on your application, there may be even better structures.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Min Heap Priority Queue Implementation\r\n                \r\nI'm currently trying to implement a min heap PQ, however I'm having some issues regarding the correctness of my implementation and I can't seem to figure out what I'm doing wrong - it doesn't output the lowest priority or sort them properly.\n\n```\n    public void AddItem(Vertex item)\n  {    \n      if (queueSize == QueueArray.length)\n      {\n          Vertex[] QueueArray2 = new Vertex[queueSize*2];          \n          System.arraycopy(QueueArray, 0, QueueArray2, 0, queueSize);           \n          QueueArray = QueueArray2;         \n      }\n\n    if (queueSize == 0)\n    {\n      QueueArray[queueSize] = item; // insert at 0\n      queueSize++;\n    }\n    else\n    {\n        int index=queueSize;\n        //Vertex newNode = new Vertex(item, priority);\n        QueueArray[index] = item;\n        queueSize++;\n\n        int parent=(index-1)/2;\n        while (index!=0 && QueueArray[index].getF()<QueueArray[parent].getF())\n        {\n            // swap parent and index items\n            Vertex temp = QueueArray[parent];\n            QueueArray[parent] = QueueArray[index];\n            QueueArray[index] = temp;\n\n            index=parent;\n            parent=(index-1)/2;\n        } \n    }     \n  }\n\n\n  public Vertex GetNextItem()\n  {\n      if (queueSize == 0)\n      {\n          return null;\n      }\n      Vertex temp = QueueArray[0];\n      --queueSize;\n      if (queueSize > 0)\n      {\n         QueueArray[0] = QueueArray[queueSize];\n         swapNodes(0);\n      }\n      QueueArray[queueSize] = null;\n      return temp;\n   }\n\n   public void swapNodes(int root)\n   {\n      int child;                        \n      if ((2*root+1) >= queueSize)\n      {\n         child = root;        //no children\n      }\n      else \n          if ((2*root)+2 == queueSize)\n          {\n                child = (2*root)+1;     \n          }\n          else \n            if (QueueArray[(2*root)+1].getF()< QueueArray[(2*root)+2].getF())\n            {\n                 child = (2*root)+1;   //left child  \n            }\n            else\n            {\n                 child = (2*root)+2;     //right child\n            }\n      //swap the nodes around\n      if (QueueArray[root].getF() < QueueArray[child].getF())\n      {\n         Vertex temp = QueueArray[root];\n         QueueArray[root] = QueueArray[child];\n         QueueArray[child] = temp;\n         swapNodes(child);\n      }\n   }\n```\n\n\nUsing the following test data:\n\n```\ndata1.setF(71);\ndata2.setF(19);\ndata3.setF(65);\ndata4.setF(16);\ndata5.setF(14);\ndata6.setF(8);\ndata7.setF(10);\ndata8.setF(36);\ndata9.setF(543);\ntest.AddItem(data1);\ntest.AddItem(data2);\ntest.AddItem(data3);\ntest.AddItem(data4);\ntest.AddItem(data5);\ntest.AddItem(data6);\ntest.AddItem(data7);\ntest.AddItem(data8);\ntest.AddItem(data9);\n```\n\n\nI get the following results:\n\n```\nArray data: 8.0 \nArray data: 16.0 \nArray data: 10.0 \nArray data: 36.0   \nArray data: 19.0 \nArray data: 65.0 \nArray data: 14.0 \nArray data: 71.0   \nArray data: 543.0 \nPQ data: 8.0 \nPQ data: 543.0 \nPQ data: 71.0 \nPQ data: 14.0 \nPQ data: 65.0\nPQ data: 19.0\nPQ data: 36.0 \nPQ data: 16.0\nPQ data: 10.0\n```\n\n\nI'm expecting the results to be in ascending order - at first I thought it may be due to the wrong children being swapped but then the last output is the greatest priority so that didn't make sense. I've spent a few hours trying to research Heap priority queues but I can't find anything to help.\n\nEdit:\n\nHere is a better output of the code as asked by CMPS (I think this is what you asked for)\n\n```\nArray data: 8.0\nArray data: 16.0\nArray data: 10.0\nArray data: 36.0\nArray data: 19.0\nArray data: 65.0\nArray data: 14.0\nArray data: 71.0\nArray data: 543.0\nPQ GetNextItem: 8.0\n\nArray data: 543.0\nArray data: 16.0\nArray data: 10.0\nArray data: 36.0\nArray data: 19.0\nArray data: 65.0\nArray data: 14.0\nArray data: 71.0\nPQ GetNextItem: 543.0\n\nArray data: 71.0\nArray data: 16.0\nArray data: 10.0\nArray data: 36.0\nArray data: 19.0\nArray data: 65.0\nArray data: 14.0\nPQ GetNextItem: 71.0\n\nArray data: 14.0\nArray data: 16.0\nArray data: 10.0\nArray data: 36.0\nArray data: 19.0\nArray data: 65.0\nPQ GetNextItem: 14.0\n\nArray data: 65.0\nArray data: 16.0\nArray data: 10.0\nArray data: 36.0\nArray data: 19.0\nPQ GetNextItem: 65.0\n\nArray data: 19.0\nArray data: 16.0\nArray data: 10.0\nArray data: 36.0\nPQ GetNextItem: 19.0\n\nArray data: 36.0\nArray data: 16.0\nArray data: 10.0\nPQ GetNextItem: 36.0\n\nArray data: 16.0\nArray data: 10.0\nPQ GetNextItem: 16.0\n\nArray data: 10.0\nPQ GetNextItem: 10.0\n```\n\n    ", "Answer": "\r\nWhen you bubble down in the heap after removing a node, you need to have the minimum at the top, but in the following code, you are swapping if the minimum is in the top, which should be the opposite way.\n\nChange:\n\n```\n     if (QueueArray[root].getF() < QueueArray[child].getF())\n      {\n         Vertex temp = QueueArray[root];\n         QueueArray[root] = QueueArray[child];\n         QueueArray[child] = temp;\n         swapNodes(child);\n      }\n```\n\n\nTo:\n\n```\n      if (QueueArray[root].getF() > QueueArray[child].getF())\n      {\n         Vertex temp = QueueArray[root];\n         QueueArray[root] = QueueArray[child];\n         QueueArray[child] = temp;\n         swapNodes(child);\n      }\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue using heap - difference between JavaScript and C++ implementation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI have rewritten in JavaScript the priority queue implementation with heap basing on similar implementation written in C++. I have completely no idea why C++ implementation works, whereas JS one don't. Can somebody eplain me the differences that cause the mistakes in JS implementation?\n\nC++ code:\n\n```\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int MAXINT = -2147483647;\n\n struct qelement\n {\n   int prio, data;\n };\n\nclass queue\n{\n  private:\n    qelement * T;  // kopiec dynamiczny\n    int n;         // liczba elementów\n\n  public:\n    queue(int max_n);\n    ~queue();\n    bool empty();\n    int  front();\n    int  frontprio();\n    void push(int prio, int v);\n    void pop();\n};\n\nqueue::queue(int max_n)\n{\n  T = new qelement[max_n];  // tworzymy tablicę dynamiczną\n  n = 0;                    // kopiec jest pusty\n}\n\nqueue::~queue()\n{\n  delete [] T;\n}\n\nbool queue::empty()\n{\n  return !n;\n}\n\nint queue::front()\n{\n  return n ? T[0].data : -MAXINT;\n}\n\nint queue::frontprio()\n{\n  return n ? T[0].prio : -MAXINT;\n}\n\n{\n  int i,j;\n\n  i = n++;\n  j = (i - 1) / 2;\n\n  while(i > 0 && T[j].prio < prio)\n  {\n    T[i] = T[j];\n    i = j;\n    j = (i - 1) / 2;\n  }\n\n  T[i].prio = prio;\n  T[i].data = v;\n}\n\nvoid queue::pop()\n{\n  int i,j,v,p;\n\n  if(n--)\n  {\n    p = T[n].prio;\n    v = T[n].data;\n\n    i = 0;\n    j = 1;\n\n    while(j < n)\n    {\n      if(j + 1 < n && T[j + 1].prio > T[j].prio) j++;\n      if(p >= T[j].prio) break;\n      T[i] = T[j];\n      i = j;\n      j = 2 * j + 1;\n    }\n\n    T[i].prio = p;\n    T[i].data = v;\n  }\n}\n\nint main()\n{\n  queue Q(10);   // kolejka 10-cio elementowa\n  int i,p,v;\n\n  srand(time(NULL));\n\n  for(i = 0; i < 10; i++)\n  {\n     v = rand() % 100;\n     p = rand() %  10;\n     cout << setw(2) << v << \":\" << p << endl;\n     Q.push(p,v);\n  }\n\n  cout << \"----\\n\";\n\n  while(!Q.empty())\n  {\n    cout << setw(2) << Q.front() << \":\" << Q.frontprio() << endl;\n    Q.pop();\n  }\n}\n```\n\n\nand here is incorrect JS code:\n\n```\nvar MAXINT = -2147483647;\n\nfunction qelement(data, prio) {\n  this.prio = prio;\n  this.data = data;\n}\n\nfunction queue(l) {\n  var T = new Array(l);\n  var n = 0;\n\n  for(var i = 0; i < l; i++) T[i] = new qelement(null, 0);\n\n  this.empty = function() {\n    return !n;\n  }\n\n  this.writeq = function() {\n    var i = 0;\n\n    console.log('This is the whole heap');\n    while(i < l) {\n      console.log(T[i].data + ' : ' + T[i].prio);\n      i++;\n    }\n  }\n\n  this.front = function() {\n    return n ? T[0].data : -MAXINT;\n  }\n\n  this.frontPrio = function() {\n    return n ? T[0].prio : -MAXINT;\n  }\n\n  this.push = function(prio, v) {\n    var i, j;\n\n    i = n++;\n    j = parseInt((i - 1) / 2);\n\n    while (i > 0 && T[j].prio < prio) {\n      T[i].prio = T[j].prio;\n      T[i].data = T[j].data;\n      i = j;\n      j = parseInt((i - 1) / 2);\n    }\n\n    T[i].prio = prio;\n    T[i].data = v;\n\n  }\n\n  this.pop = function() {\n    var i, j, v, p;\n\n    if (n--) {\n      p = T[n].prio;\n      v = T[n].data;\n\n      i = 0;\n      j = 1;\n\n      while (j < n) {\n        if (j + 1 < n && T[j + 1].prio > T[j].prio) j++;\n        if (p >= T[j].prio) break;\n        T[i] = T[j];\n        i = j;\n        j = 2 * j + 1;\n      }\n\n\n      T[i].prio = p;\n      T[i].data = v;\n    }\n  }\n}\n\nvar test = new queue(10);\nvar i, p, v;\n\n\nfor(i = 0; i < 10; i++) {\n  v = Math.round(Math.random() * 100);\n  p = Math.round(Math.random() * 10);\n  console.log(v + ' : ' + p);\n  test.push(p, v);\n}\n\nconsole.log('-------');\n\ntest.writeq();\n\nconsole.log('-------');\n\nwhile(!test.empty()) {\n  console.log(test.front() + ' : ' + test.frontPrio());\n  test.pop();\n}\n```\n\n\nFor example for input values (pairs \"value : priority\"):\n\n```\n32 : 6\n88 : 3\n40 : 1\n99 : 8\n70 : 8\n24 : 7\n4 : 6\n3 : 9\n40 : 1\n30 : 5\n```\n\n\nThe queue looks as follows:\n\n```\nJS:             C++:\n3 : 9           3 : 9\n99 : 8          99 : 8\n24 : 7          70 : 8\n70 : 8          24 : 7\n32 : 6          32 : 6\n40 : 1          4 : 6  \n4 : 6           30 : 5 \n88 : 3          88 : 3\n40 : 1          40 : 1\n30 : 5          40 : 1\n```\n\n    ", "Answer": "\r\nYou forgot to replace \n\n```\nT[i] = T[j];\n```\n\n\nwith\n\n```\nT[i].prio = T[j].prio;\nT[i].data = T[j].data;\n```\n\n\nin ```\nwhile```\n loop inside ```\npop()```\n method.\n\nCheers.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java priority queue implementation - memory locality\r\n                \r\nI am trying to implement an efficient priority queue in Java. I got to a good implementation of a binary heap but it doesn't have the ideal cache performance. For this I started studying the Van Emde Boas layout in a binary heap which led me to a \"blocked\" version of a binary heap, where the trick is to calculate the children and parent indices.\n\nAlthough I was able to do this, the cache behavior (and running time) got worse. I think that the problem is: locality of reference is probably not being achieved, since it is Java - I'm not so sure if using an array of objects actually makes objects to be contiguous in memory in Java, can anyone confirm this please?\n\nAlso I would like very much to know what kind of data-structures Java's native PriorityQueue uses, if any would know.\n    ", "Answer": "\r\nIn general, there is no good way to force your objects in the queue to occupy a contiguous chunk of memory. There are, however, some techniques that are suitable for special cases.\n\nAt a high level, the techniques involve using byte arrays and 'serializing' data to and from the array. This is actually quite effective if you are storing very simple objects. For example, if you are storing a bunch of 2D points + weights, you can simply write byte equivalent of the weight, x-coordinate, y-coordinate.\n\nThe problem at this point, of course, is in allocating instances while peeking/popping. You can avoid this by using a callback.\n\nNote that even in cases where the object being stored itself is complex, using a technique similar to this where you keep one array for the weights and a separate array of references for the actual objects allows you to avoid following the object reference until absolutely necessary.\n\nGoing back to the approach for storing simple immutable value-type, here's an incomplete sketch of what you could do:\n\n```\nabstract class LowLevelPQ<T> {\n\n  interface DataHandler<R, T> {\n    R handle(byte[] source, int startLoc);\n  }\n\n  LowLevelPQ(int entryByteSize) { ... }\n  abstract encode(T element, byte[] target, int startLoc);\n  abstract T decode(byte[] source, int startLoc);\n  abstract int compare(byte[] data, int startLoc1, int startLoc2);\n\n  abstract <R> R peek(DataHandler<R, T> handler) { ... }\n  abstract <R> R pop(DataHandler<R, T> handler) { ... }\n}\n\nclass WeightedPoint {\n  WeightedPoint(int weight, double x, double y) { ... }\n  double weight() { ... }\n  double x() { ... }\n  ...\n}\n\nclass WeightedPointPQ extends LowLevelPQ<WeightedPoint> {\n  WeightedPointPQ() {\n    super(4 + 8 + 8); // int,double,double\n  }\n\n  int compare(byte[] data, int startLoc1, int startLoc2) {\n    // relies on Java's big endian-ness\n    for (int i = 0; i < 4; ++i) {\n      int v1 = 0xFF & (int) data[startLoc1];\n      int v2 = 0xFF & (int) data[startLoc2];\n      if (v1 < v2) { return -1; }\n      if (v1 > v2) { return  1; }\n    }\n    return 0;\n  }\n\n  ...\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Heap Implementation\r\n                \r\nI'm writing code to implement a priority queue using a heap. When I enter items into the queue with these priorities in this specific order ```\n8 10 4 3 7 6 9 5```\n I get an error once I start popping them out with the ```\nget_front()```\n function.\n\nThe problem is that an assertion fails for the ```\nswap_with_parent()```\n function in the ```\nwhile```\n-loop of the ```\nget_front()```\n function . The argument is somehow growing larger than the number of items in the array, many_items. I'll post the entire code, if anybody can spot a problem I'd appreciate it if you could let me know. I apologize in advance for the lack of comments, I hope it's clear enough what I had going on.\n\n```\n// INVARIANT for the PriorityQueue Class:\n//   1. The member variable many_items is the number of items in the\n//      PriorityQueue.\n//   2. The items themselves are stored in the member variable heap,\n//      which is a partially filled array organized to follow the usual\n//      heap storage rules from Chapter 11 of the class notes.\n// NOTE: Private helper functions are implemented at the bottom of this\n// file along with their precondition/postcondition contracts.\n\n#include <assert.h>    // Provides assert function\n#include <iomanip>   // Provides setw\n#include <iostream>  // Provides cin, cout\n#include <math.h>      // Provides log2\n#include \"pqueue2.h\"\n\nusing namespace std;\n\nPriorityQueue::PriorityQueue( )\n{\n    heap[CAPACITY];\n    many_items=0;\n}\n\nvoid PriorityQueue::insert(const Item& entry, unsigned int priority)\n{\n    if(many_items==0)\n    {\n        heap[many_items].data= entry;\n        heap[many_items].priority= priority;\n        many_items++;\n    }\n    else\n    {\n        heap[many_items].data= entry;\n        heap[many_items].priority= priority;\n        unsigned int i= many_items;\n        many_items++;\n        while(parent_priority(i)<priority)\n        {\n            swap_with_parent(i);\n            i=parent_index(i);\n        }\n    }\n}\n\nPriorityQueue::Item PriorityQueue::get_front( )\n{\n    assert(many_items>0);\n    if(many_items==1)\n    {\n        Item front_value=heap[0].data;\n        many_items--;\n        return front_value;\n    }\n    else\n    {\n        Item front_value=heap[0].data;\n        heap[0]=heap[many_items-1];\n        unsigned int priority= heap[many_items-1].priority;\n        unsigned int k=0;\n        while( (k<many_items) && !is_leaf(k) && big_child_priority(k)>priority)\n        {\n            unsigned int j=big_child_index(k);\n            swap_with_parent(big_child_index(k));\n            k= j; \n        }\n        many_items--;\n        return front_value;\n    }\n}\n\nbool PriorityQueue::is_leaf(size_t i) const\n// Precondition: (i < many_items)\n// Postcondition: If heap[i] has no children in the heap, then the function\n// returns true. Otherwise the function returns false.\n{    \n    if(((2*i)+1)>many_items)\n        return 1;\n    else \n        return 0;\n}\n\nsize_t PriorityQueue::parent_index(size_t i) const\n// Precondition: (i > 0) && (i < many_items)\n// Postcondition: The return value is the index of the parent of heap[i].\n{\n    //assert( /*(i>0) && */(i<many_items));\n    return (i-1)/2;\n}\n\nunsigned int PriorityQueue::parent_priority(size_t i) const\n// Precondition: (i > 0) && (i < many_items)\n// Postcondition: The return value is the priority of the parent of heap[i].\n{\n    return heap[ (i-1)/2].priority;\n}\n\nsize_t PriorityQueue::big_child_index(size_t i) const\n// Precondition: !is_leaf(i)\n// Postcondition: The return value is the index of one of heap[i]'s children.\n// This is the child with the larger priority.\n{\n    assert(!is_leaf(i));\n    if((2*i)+2<many_items)\n    {\n        if(heap[(2*i)+1].priority>heap[(2*i)+2].priority)\n        {\n            return (2*i)+1;\n        }\n        else\n        {\n            return (2*i)+2;\n        }\n    }\n    else\n    {\n        return(2*i)+1;\n    }\n}\n\nunsigned int PriorityQueue::big_child_priority(size_t i) const\n// Precondition: !is_leaf(i)\n// Postcondition: The return value heap[big_child_index(i)].priority\n{\n    return heap[big_child_index(i)].priority;\n}\n\nvoid PriorityQueue::swap_with_parent(size_t i)\n// Precondition: (i > 0) && (i < many_items)\n// Postcondition: heap[i] has been swapped with heap[parent_index(i)]\n{\n    assert( i>0 && i<many_items);\n    OneItemInfo temp_parent=heap[parent_index(i)];\n    OneItemInfo temp_child=heap[i];\n    heap[i]=temp_parent;\n    heap[parent_index(i)]=temp_child;\n}\n```\n\n    ", "Answer": "\r\nI think ```\nis_leaf```\n is incorrect. The condition should be ```\n(2*i+1 >= many_items)```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing Java Priority Queue\r\n                \r\n```\npublic class PriorityQueue<T> {\n private PriorityNode<T> head, tail;\n private int numItems;\n\n public PriorityQueue(){\n  numItems = 0;\n  head=null;\n  tail=null;\n }\n\n\n public void add(int priority, T value){\n      PriorityNode<T> newNode = new PriorityNode<T>(priority,value);\n\n      if(numItems == 0){\n       head = newNode;\n       tail = newNode;\n      }\n      else{\n       head.setNext(newNode);\n       head = newNode;\n      }\n\n\n\n     }\n\n    }\n```\n\n\nWhere PriorityNode is defined as:\n\n```\n public class PriorityNode<T> implements Comparable<T> {\n     private T value;\n     private PriorityNode<T> next;\n     private int priority;\n\n     public PriorityNode(int priority,T newValue){\n      value = newValue;\n      next = null;\n      priority = 0;\n     }\n\n     public PriorityNode(T newValue){\n      value = newValue;\n      next = null;\n      priority = 0;\n     }\n\n     public void setPriority(int priority){\n      this.priority = priority;\n     }\n\n     public int getPriority(){\n      return this.priority;\n     }\n\n     public T getValue(){\n      return value;\n     }\n\n     public PriorityNode<T> getNext(){\n      return next;\n     }\n\n     public void setNext(PriorityNode<T> nextNode){\n      this.next = nextNode;\n     }\n\n     public void setValue(T newValue){\n      value = newValue;\n     }\n\n           @Override\n     public int compareTo(int pri) {\n      // TODO Auto-generated method stub\n        if(this.priority<pri){\n           return -1;\n        }\n        else if(this.priority == pri){\n           return 0;\n         }\n        else{\n           return 1;\n         }\n\n\n     }\n\n\n    }\n```\n\n\nI'm having a lot of difficulty using the Comparator here and implementing a priority queue - please point me in the right direction.\n    ", "Answer": "\r\nDon't use a tree structure to implement a priority queue. Use a heap. It is more space-efficient, requires fewer memory allocations, and is O(log(N)) for most operations.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Implementation for Kernel Thread Timer Interrupt\r\n                \r\nI'm optimizing my timer interrupt function for kernal threads in Nachos OS. \n\nIntroduction here.\n\nI have a class called alarms:\n\n```\npublic alarms(long wakeTime, KThread my_thread)\n{\n    wakeTime=wakeTime;\n    thread = my_thread;\n}\n\npublic long getWakeTime()\n{\n    return wakeTime;\n}\n\npublic KThread get_my_thread()\n{\n    return thread;\n}\n```\n\n\nI also have a priority queue which is min-heap based:\n\n```\nQueue<alarms> my_alarms = new PriorityQueue<alarms>();\n```\n\n\nHow do I make the priority queue compare the wakeTime attribute of the alarms class, and generate the min-heap based on that.\n\nIn C++ I would overload the operator< function as follows:\n\n```\nbool operator<(alarms a, alarms b){return a.wakeTime < b.wakeTime ? true : false;}\n```\n\n\nBut I'm not sure how to work with the comparator in java. Can someone please clarify how i would compare the wakeTime attributes in java? Would i need to have my alarms class implement the Comparator class, or how would i go about doing it?\n\nThank you for your time!\nBest Regards,\n    ", "Answer": "\r\nThis is how you do it.. \n\n```\npublic class Alarm implements Comparable<Alarm> {\n   @Override \n    public int compareTo(Object o) {\n        Alarm a = (Alarm) o; \n        return this.wakeTime - a.wakeTime ;\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementation of Editable Priority Queue\r\n                \r\nI wanted to implement my own Priority Queue for Dijkstra's shortest path algorithm that stores shortest discovered distance to particular node and also allow editing it, so I thought to make heap that stores pointers to array with distances.\n\n```\nvoid heapify(int **h, int i, int size)\n{\n    int min =i;\n    int l = 2*i;\n    int r =l+1;\n    if(l <= size && *h[l] < *h[i])\n        min = l;\n    else\n        min =i;\n    if(r <=size && *h[r] < *h[min])\n        min =r;\n\n    if(min!=i)\n    {\n        int *temp;\n        temp = h[i];\n        h[i] = h[min];\n        h[min] = temp;\n        heapify(h,min,size);\n    }\n}\n\nvoid build(int **h,int size)\n{\n    int i; \n    for(i = size;i>0;i--)\n        heapify(h,i,size);\n}\n\n\nint main()\n{\n    int a[100];\n    int *h[99];\n    int i;\n\n    for(i=1;i<11;i++)\n        scanf(\"%d\", &a[i]);\n    for(i= 11 ;i<100;i++)\n        a[i] = INT_MAX ;\n    a[0] =INT_MAX ;\n\n\n    for(i=0;i<100;i++)\n    {\n        h[i] = (a+i);\n    }\n    build(h,99);\n\n    // printing elements of heap\n    for(i=1;i<11;i++)\n        printf(\"%d \", *h[i]);\n\n    return 0;\n\n}\n```\n\n\nHow should I implement a function that restores heap property of h after change is made in a?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Correct heap implementation in a priority queue\r\n                \r\nMy issue is more semantic than functional, As the code does seem to implement the deQueue and enQueue functions correctly.\n\nThe reheapDown and reheapUp functions are being used incorrectly, And i believe the issue lies in my heap function\n\n```\npackage priqueue;\n\npublic class Hosheap{\n  private Patient[] elements;\n  private int numElements;\n\n  public Hosheap(int maxSize)\n  {\n    elements= new Patient[maxSize];\n    numElements=maxSize;\n  }\n\n  public void ReheapDown(int root,int bottom)\n  {\n    int maxChild;\n    int rightChild;\n    int leftChild;\n    leftChild=root*2+1;\n    rightChild=root*2+2;\n\n    if (leftChild<=bottom)\n    {\n      if(leftChild==bottom)\n        maxChild=leftChild;\n      else\n      {\n        if(elements[leftChild].getPriority() <= elements[rightChild].getPriority())\n          maxChild=rightChild;\n        else\n          maxChild=leftChild;\n      }\n      if(elements[root].getPriority()<elements[maxChild].getPriority())\n      {\n        Swap(root,maxChild);\n        ReheapDown(maxChild,bottom);\n      }\n    }\n  }\n\n  public void ReheapUp(int root,int bottom)\n  {\n    int parent;\n    if(bottom>root)\n    {\n      parent=(bottom-1)/2;\n      if(elements[parent].getPriority()<elements[bottom].getPriority())\n      {\n        Swap(parent,bottom);\n        ReheapUp(root,parent);\n      }\n    }\n  }\n\n public void Swap(int Pos1, int Pos2)\n {\n   Patient temp;\n   temp = elements[Pos1];\n   elements[Pos1]=elements[Pos2];\n   elements[Pos2]=temp;\n }\n\n public Patient getElement(int e)\n {\n   return elements[e];\n }\n\n public void setElement(Patient p, int n)\n {\n    elements[n]=p;\n }\n}\n```\n\n\nThe idea is to rearrange a simple priority queue system so when a patient object is removed, ReheapUp or down correctly rearranges the queue, Which the code does not accomplish. Should i also include the priority queue code, Or is this already too lengthy?\n\nI am using NetBeans IDE 6.0.1, If that helps.\n    ", "Answer": "\r\nDepending on your usage requirements, the answer relating to TreeSets will most probably do what you want.\n\nHowever if you really need a queue, as opposed to a sorted collection, then the inbuilt PriorityQueue may be of use.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Free implementation of \"bounded priority queue\" in C++\r\n                \r\nI'm looking for a free software implementation of the bounded priority queue abstraction in C++. Basically, I need a data structure that will behave just like ```\nstd::priority_queue```\n but will at all times hold the \"best\" n elements at most.\n\nExample:\n\n```\nstd::vector<int> items; // many many input items\nbounded_priority_queue<int> smallest_items(5);\nfor(vector<int>::const_iterator it=items.begin(); it!=items.end(); it++) {\n  smallest_items.push(*it);\n}\n// now smallest_items holds the 5 smallest integers from the input vector\n```\n\n\nDoes anyone know of a good implementation of such thing? Any experience with it?\n    ", "Answer": "\r\nI think that the algorithm discussed in this thread is probably what you are looking for. If you want to get a head start, you might want to consider building upon Boost's implementation ```\nd_ary_heap_indirect```\n which is part of Boost.Graph (in ```\nd_ary_heap.hpp```\n). If you do a good job with it, you might submit it to Boost. It could make a nice little addition, because such an implementation certainly has many uses.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Heap Priority Queue Implementation\r\n                \r\nI am working on a code involving a Heap implementation and I seem to be getting a dereferenced error in my bubbleUp method, in my while loop line. This may be a rather basic question, but what's the best way to solve this? I've also had some trouble implementing the removeHigh method, which is meant to remove the highest element from the queue.\n\n```\npublic class HeapPriorityQueue implements PriorityQueue \n{\n    protected final static int DEFAULT_SIZE = 10000;\n\n    protected Comparable[] storage;\n    protected int currentSize;\n\n    public HeapPriorityQueue () \n    {\n        this.storage=new Comparable[DEFAULT_SIZE];\n        this.currentSize=0;\n    }\n\n    public HeapPriorityQueue(int size)\n    {\n        this.currentSize=size;\n        this.storage=new Comparable[currentSize];\n    }\n\n    public int size ()\n    {\n        return currentSize;\n    }\n\n    public boolean isEmpty ( )\n    {\n        if(currentSize==0)\n            return true;\n        else\n            return false;\n    }\n\n    public boolean isFull ( )\n    {\n        if(currentSize==DEFAULT_SIZE)\n            return true;\n        else\n            return false;\n    }\n\n    public Comparable removeHigh () throws HeapEmptyException\n    {\n        if(isEmpty()) {\n            throw new HeapEmptyException();\n        }else{\n            Comparable[] k = new Comparable[0];\n            k.equals(storage[1]);\n            storage[1] = storage[currentSize];\n            storage[currentSize] = null;\n            currentSize--;\n            bubbleDown();\n            return storage[currentSize];\n        }\n    }\n\n    public void insert ( Comparable k  ) throws HeapFullException\n    {   \n        if(isFull()) {\n            throw new HeapFullException();\n        }\n            currentSize++;\n            int index = currentSize;\n            storage[index] = k;\n\n            bubbleUp();\n\n    }\n\n    protected void bubbleUp ( ) \n    {\n        int index = this.currentSize;\n\n        while(parent(index).compareTo(storage[index]) > 0) {\n            swapElement(index, parent(index));\n            index = parent(index);\n        }\n\n    }\n\n    protected void bubbleDown() \n    {\n        int index = 1; \n        while (hasLeft(index)) {\n            int smaller = leftChild(index);\n\n            if(hasRight(index) && \n                storage[leftChild(index)].compareTo(storage[rightChild(index)])>0) {\n                    smaller = rightChild(index);\n                }\n\n            if(storage[index].compareTo(storage[smaller]) > 0) {\n                swapElement(index, smaller);\n            }else{\n                break;\n            }\n        }\n\n\n    }   \n\n    protected void swapElement ( int p1, int p2 )\n    {\n        Comparable k = storage[p1];\n        storage[p1] = storage[p2];\n        storage[p2] = k;\n\n    }\n\n    protected int parent ( int pos )\n    {\n        if(pos>1)\n            return pos;\n        else\n            return 0;\n    }\n\n    protected int leftChild ( int pos )\n    {\n        return pos*2;\n    }\n\n    protected int rightChild ( int pos )\n    {   \n        return pos*2+1;\n    }\n\n    protected boolean hasLeft ( int pos )\n    {\n        if(leftChild(pos) <= currentSize)\n            return true;\n        else\n            return false;\n    }\n\n    protected boolean hasRight ( int pos )\n    {\n        if(rightChild(pos) <= currentSize)\n            return true;\n        else\n            return false;\n    }\n\n\n}\n```\n\n    ", "Answer": "\r\nPresumably, once you swap the element the result of ```\nparent(index)```\n will change. Try\n\n```\nprotected void bubbleUp() {\n    int index = this.currentSize;\n    int pi;\n    while((pi = parent(index)).compareTo(storage[index]) > 0) {\n        swapElement(index, pi);\n        index = pi;\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Spring AMQP RabbitMQ implementing priority queue\r\n                \r\nAfter Google for a few days, and i believe i am totally lost.  I would like to implement a kind of priority queue that has about 3 queues:\n\n\nhigh priority queue (daily), that needs to be process first.\nmid priority queue (weekly), that will process if no items in queue #1. (it is ok message in this queue it never process at all)\nlow priority queue (monthly), that will process if no items in queue #1 & #2. (it is ok message in this queue it never process at all)\n\n\nInitially I have the following flow, to have a consumer to consume messages from all three queues and checks whether there is any items in queue #1, #2 and #3. and then I realize that this is wrong because:  \n\n\nI am totally lost with a question: \"How do I know which queue it is coming from?\". \nI'm already consuming a message regardless from any queue, So if I get an object from lower priority queue, am I gonna put it back to the queue if I discover there is a message at the higher priority queue?\n\n\nFollowing is my current configurations, which shows what an idiot I am.\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\nhttp://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd\">\n\n<rabbit:connection-factory id=\"connectionFactory\" host=\"localhost\" />\n\n<rabbit:template id=\"amqpTemplatead_daily\" connection-factory=\"connectionFactory\"\n    exchange=\"\" routing-key=\"daily_queue\"/>\n\n<rabbit:template id=\"amqpTemplatead_weekly\" connection-factory=\"connectionFactory\"\n    exchange=\"\" routing-key=\"weekly_queue\"/>\n\n<rabbit:template id=\"amqpTemplatead_monthly\" connection-factory=\"connectionFactory\"\n    exchange=\"\" routing-key=\"monthly_queue\"/>\n\n<rabbit:admin connection-factory=\"connectionFactory\" />\n\n<rabbit:listener-container connection-factory=\"connectionFactory\">\n    <rabbit:listener ref=\"Consumer\" method=\"consume\" queue-names=\"daily_queue\" />\n</rabbit:listener-container>\n\n<rabbit:listener-container connection-factory=\"connectionFactory\">\n    <rabbit:listener ref=\"Consumer\" method=\"consume\" queue-names=\"weekly_queue\" />\n</rabbit:listener-container>    \n\n<rabbit:listener-container connection-factory=\"connectionFactory\">\n    <rabbit:listener ref=\"Consumer\" method=\"consume\" queue-names=\"monthly_queue\" />\n</rabbit:listener-container>    \n\n<bean id=\"Consumer\" class=\"com.test.Consumer\" />\n\n</beans>\n```\n\n\nAny idea how should I tackle this with priority queue?     \n\nps: I also wonder, if Apache Camel has something I can depend on? \n\nUPDATE 1: I just saw this from Apache Camel: \"https://issues.apache.org/jira/browse/CAMEL-2537\"   the sequencer on JMSPriority seems to be what im looking for, anyone has tried this before?\n\nUPDATE 2: assuming i am to use RabbitMQ's plugin base on @Gary Russell recommendation, I have the following spring-rabbitmq context XML configuration, which seems to make sense (by guest..): \n    \n             \n\n```\n<rabbit:queue name=\"ad_google_dfa_reporting_queue\">\n    <rabbit:queue-arguments>\n            <entry key=\"x-max-priority\" value=\"10\"/>\n    </rabbit:queue-arguments>\n</rabbit:queue>\n\n<rabbit:listener-container connection-factory=\"connectionFactory\">\n    <rabbit:listener ref=\"adGoogleDfaReporting\" method=\"consume\" queue-names=\"ad_google_dfa_reporting_queue\" />\n</rabbit:listener-container>\n\n<bean id=\"Consumer\" class=\"com.test.Consumer\" />\n```\n\n\nThe above xml configuration has successfully create a Queue, with name: \"ad_google_dfa_reporting_queue\", and with Parameter arguments:  x-max-priority: 10 & durable: true\n\nBut not when comes to the code that send the message with priority, I totally lost it. How to define the priority as mention in the Sample URL: https://github.com/rabbitmq/rabbitmq-priority-queue/blob/master/examples/java/src/com/rabbitmq/examples/PriorityQueue.java\n\n```\nAmqpTemplate amqpTemplateGoogleDfaReporting = (AmqpTemplate) applicationContext.getBean(\"amqpTemplateadGoogleDfaReporting\");\namqpTemplateGoogleDfaReporting.convertAndSend(\"message\"); // how to define message priority?\n```\n\n\nUPDATE 3: Based on the @Gary's answer, i manage to sent message with priority set in the message, as per image below:\n\n However, when i sent in 1000 messages with random priority between 1-10, the consumer is consuming message with all kinds of priority. (I was expecting only the high priority message to be consume first). following is the code for Message producer:\n\n```\n    Random random = new Random();\n    for (int i=0; i< 1000; i++){\n        final int priority = random.nextInt(10 - 1 + 1) + 1;\n\n        DfaReportingModel model = new DfaReportingModel();\n        model.setReportType(DfaReportingModel.ReportType.FACT);\n        model.setUserProfileId(0l + priority);\n        amqpTemplateGoogleDfaReporting.convertAndSend(model, new MessagePostProcessor() {\n            @Override\n            public Message postProcessMessage(Message message) throws AmqpException {\n                message.getMessageProperties().setPriority(priority);\n                return message;\n            }\n        });\n    }\n```\n\n\nAnd following is the code for Message consumer:\n\n```\n    public void consume(DfaReportingModel message) {\n        System.out.println(message.getUserProfileId());\n\n        Thread.sleep(500);\n    }\n```\n\n\nThe result im getting: \n\n```\n9, 10, 7, 9, 6, 4, 10, 10, 3, 10, 6, 1, 5, 6, 6, 3, 4, 7, 6, 8, 3, 1, 4, 5, 5, 3, 10, 9, 5, 1, 8, 9, 6, 9, 3, 10, 7, 4, 8, 7, 3, 4, 8, 2, 6, 9, 6, 4, 7, 7, 2, 8, 4, 4, 1,\n```\n\n\nUPDATE 4: Problem solved! Knowing the sample code from https://github.com/rabbitmq/rabbitmq-priority-queue is working in my environment, I presume that the problem is around the spring context. Hence, after countless time on try and error with different type of configurations, and I pin point the exact combination that will make this works! and is as per following:\n\n```\n    <rabbit:queue name=\"ad_google_dfa_reporting_queue\">\n    <rabbit:queue-arguments>\n        <entry key=\"x-max-priority\">\n            <value type=\"java.lang.Integer\">10</value> <!-- MUST specifically define java.lang.Integer to get it to work -->\n        </entry>\n    </rabbit:queue-arguments>\n</rabbit:queue>\n```\n\n\nWithout specifically define the value is Integer type, the priority queue does not work.  Finally, it is solved. Yay!\n    ", "Answer": "\r\nRabbitMQ now has a priority queue plugin where messages are delivered in priority order. It would be better to use that rather than your scheme of requeueing low priority messages which will be quite expensive at runtime.\n\nEDIT:\n\nWhen using the ```\nrabbitTemplate.convertAndSend(...)```\n methods, and you want to set the priority property on the message, you either need to implement a custom ```\nMessagePropertiesConverter```\n in the template (subclass the ```\nDefaultMessagePropertiesConverter```\n) or use the ```\nconvertAnSend```\n variants that take a message post-processor; e.g.:\n\n```\ntemplate.convertAndSend(\"exchange\", \"routingKey\", \"message\", new MessagePostProcessor() {\n\n    @Override\n    public Message postProcessMessage(Message message) throws AmqpException {\n        message.getMessageProperties().setPriority(5);\n        return message;\n    }\n});\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is the different ways to implement Priority queue? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhat is the different ways to implement Priority queue?\nI read that :\nPriority Queue can be viewed as:\nView 1: Priority queue as an ordered list.\nView 2: Priority queue as a set.\n\nwhat is the different between them?\n    ", "Answer": "\r\nIt is just the interface and the behavior that makes a priority queue. You can implement it in any way you like. As long as the interface and behavior are the same, the kind of implementation does not matter to the client in the first place.\n\nThe differences of various approaches are mainly implications to performance or memory-usage. For example, when using a sorted array as the underlying data structure, it might be necessary to reorganize the whole array when adding/removing items to/from the queue, while the same operation is relatively cheap when using a linked list.\n\nThe properties of the data structures and algorithms will propagate to the clients. You will have to choose an implementation that fits your use case by analyzing the most frequent operations etc.\n\nI don't think that set-based implementations are a good fit for this as sets only allow unique items. Just like with priority queues, there are different Set implementations that have different properties, but typically, a set is unordered and you might have to look at each item to figure out which one is the next in queue. But again: if uniqueness of items fits your use case you can use it. But I would rather name such an implementation PrioritySet or UniquePriorityQueue to communicate the properties to the client.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement queue priority in rabbitmq\r\n                \r\nI'm using rabbitmq in my application. There are 2 queues for different kind of requests. On consumer side i've set up a few listeners that are listening to  these 2 queues .Whenever a message comes up, these listeners start processing it. i need to make sure that messages in one queue are treated as high priority item than the messages in other queue.\n\nThe problem is AMQP queues are FIFO queues. If a low priority message comes before the high priority message, that will be consumed first .\n\ni need to do the implementation in such a way that if any listener gets free, it should serve the high priority queue first irrespective of the time of arrival of the message in high priority queue.\n\nFor example there are 3 requests in low priority queue and 2 listeners at consumer end. Since there is no request in high priority queue, both listeners take the messages from low priority queue and process them. Meanwhile, another message gets queued in high priority queue. At this point of time, there is one request in high priority and one in low priority.  In my current implementation, the available listener is consuming the  message from low priority queue first .\n\nI'd like to know how can i set the queue priority such that the listener always processes the messages in high priority queue first\n\nPlease help me\nFYI The publisher is a Grails application and the consumer is a Java App and at grails end, i'm using rabbitmq plugin to publish the messages.\nThanks!\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "implementing priority queues and heaps\r\n                \r\nI am trying to implement a min priority queue using a binary min heap based on the description from \"Introduction to Algorithms, Third Edition\" and have a couple of questions.\n\nThe book says that we often need to store a handle (pointer or integer) to the application object in each heap element and that we also need to store a handle (array index) to the heap element in each application object.\n\n1) Would the heap implementation typically look something like this then?\n\n```\ntemplate <class KeyType, class ObjectType>\nstruct HeapElement\n{\n    KeyType key;\n    ObjectType* pObject;\n};\n\n\ntemplate <class KeyType, class ObjectType>\nclass MinHeap\n{\n  // ...\nprivate:\n  std::vector< HeapElement<KeyType, ObjectType> > data;\n};\n```\n\n\nAnd then the ObjectType class would also store the heapIndex:\n\n```\nclass Foo\n{\n // ...\n  int heapIndex;\n};\n```\n\n\n2) Is the min priority queue and binary min heap typically implemented as a single class or is the min priority queue usually implemented as its own class with a private heap class member?\n\n```\nclass MinPriorityQueue\n{\n  // ...\nprivate:\n  MinHeap minHeap;\n};\n```\n\n\nThe reason I ask is because if you look at the implementation for something like ```\nExtractMin()```\n, it requires that you manipulate the heap data:\n\n```\nint min = data[0]; // data: private heap data member\nheapSize--; // heapSize: private heap data member\nMinHeapify(0); // MinHeapify: private heap member function\n```\n\n\nSo maybe the min priority queue class should act as a wrapper class?\n\n```\nT MinPriorityQueue::ExtractMin()\n{\n  return minHeap.ExtractMin();\n}\n```\n\n\nIn that case, the binary min heap class might implement ```\nMin()```\n, ```\nExtractMin()```\n, ```\nDecreaseKey()```\n, and ```\nInsert()```\n and contain the functionality for both a binary min heap and min priority queue. Then there would be no need for a MinPriorityQueue class at all.\n\nThe scope of the question is implementing heaps/priority queues for job interviews. Any thoughts on this?\n    ", "Answer": "\r\n1)  Usually you don't want to have to modify your value types just because you want to make a heap of them.  You'd make your heap something like this:\n\n```\ntemplate <class KeyType, class ObjectType>\nstruct HeapElement\n{\n    KeyType key;\n    size_t heapIndex;\n    ObjectType* pObject;\n};\n\n\ntemplate <class KeyType, class ObjectType>\nclass MinHeap\n{\n  // ...\nprivate:\n  //this is just to allocate the data.  Elements in here don't move\n  std::vector< HeapElement<KeyType, ObjectType> > data;\n\n  //this is the heap.  Elements are indexes into data vector\n  std::vector<size_t> heapArray;\n};\n```\n\n\nThen, throughout the implementation of Dijkstra's algorithm you use indexes into the data vector to refer to objects, and you can get each item's heap index with ```\ndata[itemIndex].heapIndex```\n.\n\nBUT see my answer over here:  Prim's Algorithm: How to get index of key on which DECREASE_KEY operation is to be performed? ...  I usually implement Dijkstra's algorithm without a decrease_key operation.\n\n2) I don't really see any reason to make a heap class that is separate from the priority queue implementation.  I would actually call the class you need a \"Heap\", though, not a priority queue, since priority queue interfaces don't usually expect the keys to be separate from the objects.\n\nYou should use ```\nstd::make_heap```\n, ```\nstd::push_heap```\n and ```\nstd::pop_heap```\n on a vector.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to Implement stack using priority queue?\r\n                \r\nHow to Implement stack using priority queue?\n\nGuys this is a Microsoft Interview Question for Software Engineer/Developer.I just can't make out the meaning of the question.So I goggled and found this:\n\nStacks and queues may be modeled as particular kinds of priority queues. In a stack, the priority of each inserted element is monotonically increasing; thus, the last element inserted is always the first retrieved. \n\nSo what this question wants us to do.As stacks (Correct me if am wrong) are implicitly implemented as priority queues (priority being monotonically increasing as elements are added).\n\nDoes anybody can make out the meaning of this question.What we are supposed to do when such type of question is asked in an interview.\n    ", "Answer": "\r\nPseudocode:\n\n```\n// stack of Key\nclass Stack {\n    class Element { int prio, Key elem; };\n    MaxPriorityQueue<Element> q;\n    int top_priority = 0;\n\n    void push(Key x) { q.push(Element(top_priority++, x)); }\n    Key pop() { top_priority--; return q.pop().elem; }\n};\n```\n\n\nLIFO behavior follows from the fact that every new element is pushed with a priority higher than all the current elements, so it will be popped before any of them.\n\nThere are two ways to respond to this interview question. One is to explain in detail the structure above. The second is to briefly mention it, mumble something about O(lg n) and say you'd never implement a stack this way.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement priority queue in elevator\r\n                \r\nI have the following code to implement Elevator:\n\n```\npublic class Elevator{\n\n   Direction dir;\n   int floorNum;\n   int capacity;\n\n   public void moveUp{\n      dir = Direction.Up;\n   }\n\n   public void moveDown{\n     dir = Direction.Down\n   }\n\n   public boolean isMoving{\n     returns dir.equals(Direction.STATIONARY);\n   }\n}\n\n\npublic class ElevatorController{\n\n   Elevator[] elevators;\n\n   PriorityQueue<Integer> queue = new PriorityQueue<Integer>;\n\n   public void buttonPressed{Direction d, int fromFloot, int toFloor){ \n\n\n   }\n}\n```\n\n\nI read the a good way to implement elevator would be to implement a priority queue to get the elevator but am not sure how.\n\nqueue would contain the destination floor.\n\nHow would you recommend to implement it?\n    ", "Answer": "\r\nOne possibility is to use two separate TreeSets to order the floors, ```\nup```\n and ```\ndown```\n.  If you're adding a floor above ```\ncurrentFloor```\n then add it to ```\nup```\n, if you're adding a floor below ```\ncurrentFloor```\n then add it to ```\ndown```\n; if you're adding a floor equal to ```\ncurrentFloor```\n then discard it.  The TreeSet automatically discards duplicates.  When determining the next floor to visit, then if direction == UP then visit the next lowest floor in ```\nup```\n, and if direction == DOWN then visit the next highest floor in ```\ndown```\n.\n\nAlternatively you can use a single TreeSet and try to come up with a clever Comparator that takes the elevator direction into account, but that seems like more trouble than it's worth.\n\n```\nprivate TreeSet<Integer> up = new TreeSet<>(); // floors above currentFloor\nprivate TreeSet<Integer> down = new TreeSet<>(); // floors below currentFloor\nprivate int currentFloor = 0;\nprivate Enum direction = direction.UP;\n\npublic void addFloor(int f) {\n    if(f < currentFloor) {\n        down.add(f);\n    } else if(f > currentFloor) {\n        up.add(f);\n    }\n    // else f == currentFloor, so don't add the floor to either queue\n}\n\npublic int nextFloor() {\n    if(direction == direction.DOWN) {\n        return down.pollLast(); // highest floor in down, or null if empty\n    } else {\n        return up.pollFirst(); // lowest floor in up, or null if empty\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Compiler error with priority queue implementation\r\n                \r\nI am working on an assignment that is to create priority queue without using the #include  library. I have written a few functions and have ran into a problem that I cant figure out.\n\n```\n// CSCI 2530\n// Assignment: 6\n// Author:     \n// File:       pqueue.cpp\n// Tab stops:  ***\n\n// **Say what this program does here.  (replace this comment)**\n\n\n#include <cstdio>\n#include \"stdafx.h\"\n#include \"pqueue.h\"\n\nusing namespace std;\n\n\n\n//Structure PQCell holds an item (item), priority (priority) and\n//a pointer to the next item in the priority queue.\n\nstruct PQCell \n{\n    ItemType item;\n    PriorityType priority;\n    PQCell* node;\n\n    PQCell() : item(0), priority(0), node()\n    {\n    }\n};\n\n//Checks the the first element of the linked list (q) for\n//a NULL value. If the list is empty this first element will be NULL.\n\nbool isEmpty(const PriorityQueue& q)\n{\n    if (q.next == NULL)\n    {\n        return false;\n    }\n    return true;\n}\n//-------------------------------------------------------------------\n\n\nvoid insertCell(PQCell*& L, ItemType x, PriorityType p)\n{\n    PQCell cell;\n    cell.item = x;\n    cell.priority = p;\n}\n\n\n\nvoid insert(PriorityQueue& q, ItemType x, PriorityType p)\n{\n    insertCell(q, x, p);\n}\n\n\nint main()\n{\n\n\n\n    return 0;\n}\n```\n\n\nIn the code above it shows the main file of the program where I have written a \"insert\" and a \"insertCell\" function.\n\nThe insertCell function is supposed to insert a new cell into PriorityQueue when called upon. However, when I try to call on insert cell it gives me the error(shown in the image above).\n\nAlso, here is the header file which i have created for this project\n\n```\n// CSCI 2530\n// Assignment: ***\n// Author:     ***\n// File:       ***\n// Tab stops:  ***\n\n// **Say what this program does here.  (replace this comment)**\n\n\n#include <cstdio>\nusing namespace std;\n\nstruct PQCell;\n//Type definitions\n\ntypedef const char* ItemType;\ntypedef double      PriorityType;\n\nstruct PriorityQueue\n{\n\n    PriorityQueue* next;\n\n    PriorityQueue()\n    {\n        next = NULL;\n    }\n};\n//Prototypes\n\nbool isEmpty(const PriorityQueue& q);\nvoid insert(PriorityQueue& q, ItemType x, PriorityType p);\n```\n\n\nAlso, here is the link to the assignment instructions.....\nhttp://cs.ecu.edu/~karl/2530/spr18/Assn/Assn6/assn6.html\n    ", "Answer": "\r\nYou are trying to pass a reference of PriorityQueue as first argument to insertCell, this function needs a PQCell as argument.\n\nI'd say that your insertCell should ask for PriorityQueue instead, so you can push into it\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement regular queue using priority queue?\r\n                \r\nHow to implement regular queue using priority queue?.\nAlso I need to find the running time of \"enqueue\" an \"dequeue\" in this method.\n    ", "Answer": "\r\nYou can have a running index that remembers how many inserts were made, the ```\ni```\nth element that was inserted, will have priority ```\ni```\n. You are always polling the \"lowest\" priority element, which is the oldest one in the queue, as desired.\n\nThe time complexity, assuming you are using a \"black box\" priority queue is ```\nO(logn)```\n for ```\npopHead()```\n and ```\ninsert()```\n, and ```\nO(1)```\n for ```\ntop()```\n. You might be able to tweak it to do the insertions and deletions faster if you don't assume \"black box\", but than again, if you can tweak it - just make it a linked list, or some other data structure that is optimized to be a queue.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Min Heap vs Ordinary array implementation of Priority queue [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is opinion-based. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it can be answered with facts and citations by editing this post.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhen is it best to implement a priority queue in Dijkstra's as a min heap and when is it better to use an ordinary array?\n\nOne has Running time ```\nO(V^2 + E)```\n and the other ```\nO((V+E)logV)```\n. When ```\nE< V```\n, then \n```\nO(V^2+E) = O(V^2)```\n and it is worse than ```\nO((V+E)logV)=O(2VlogV)=O(VlogV)```\n\n\nWhen ```\nV< E```\n, ```\nO(V^2 + E)= O(E^2)```\n and ```\nO((V+E)logV) = O(ElogV)```\n so a heap implementation seems again to be better. \n\nThey also have the same space complexity i.e ```\nO(n)```\n.\n\nI assume that there are cases when a simple array implementation of a min-priority queue in Dijkstra's is better but can't really think of a case.\n    ", "Answer": "\r\nFor Dijkstra as @JimMischel said, I can't think of any example, and I don't think it exists. However, for UCS (Uniform cost search), which is focused on finding a single shortest path to a single finishing node rather than a shortest path to every node, I can think of an example. This would be involving a problem where the transition between states is uniform. \n\nLet's say for example we are solving the 15-puzzle (all transitions have cost 1). Moreover, in this kind of problem the range of solution costs is well known, so you could have an array of states to be explored where for each cost you store a simple vector of paths with such cost. In this case, every operation has ```\nO(1)```\n and it's more efficient using an array than a binary min heap. \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement decreaseKey in STL Priority Queue C++\r\n                \r\nI'm trying to implement Prim's Algorithm and for that I need to have a decreaseKey method for a priority queue (to update the key value in a priority queue). Can I implement this in the STL Priority Queue?\n\nIf it helps, this is the algorithm I'm following:\n\n\nfor each vertex u in graph G\n\nset key of u to INFINITY\nset parent of u to NIL\n\nset key of source vertex to 0\nen-queue to priority queue Q all vertices in graph with keys as above\nwhile Q is not empty\n\npop vertex u with lowest key in Q\nfor each adjacent vertex v of u do\n\nif (v is still in Q) and (key(u) + weight-function(u, v) < key(v)) then\n\nset u to be parent of v\nupdate v's key to equal key(u) + weight-function(u, v)  // This part is giving me problems as I don't know how implement decreaseKey in priority queue\n\n\n\n\n    ", "Answer": "\r\nI do not think you can implement it in STL container. Remember you can always write your own heap(priority queue) based on vector, but there is a work around:\n\nKeep array of distances you have, lets say ```\nd```\n. In you priority queue you put pairs of distances and index of vertex of this distance. When you need to delete some value from queue, do not delete it, just update your value in ```\nd```\n array and put new pair into queue. \n\nEvery time you take new value from queue, check if distance in pair is actually that good, as in your array ```\nd```\n. If not ignore it.\n\nTime is same O(MlogM). Memory is O(MlogM), where M is number of edges.\n\nThere is another approach: use RB-Tree, it can insert and delete keys in O(logN) and get minimum as well. You can find implementation in STL of RB-Tree in ```\nstd::set```\n container.\n\nBut, although time complexity is same, RB-Tree works slower and has bigger hidden constant, so it might be slightly slower, appx. 5 times slower. Depends on data, of course . \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C, Dijkstra Heap Priority Queue Implementation\r\n                \r\nFor a school project I have to modify a Dijkstra short path code given by the professor and change the priority queue from a simple array to an heap. \nThe idea is clear but I can't understand what I should include in the heap nodes because in the code I have there are 3 different arrays, one for the distance between two nodes, one with the predecessors of the nodes and one boolean that says if I have yet visited the node. \n\n```\nint *Dijkstra(int s, int n) //restituisce array dei predecessori\n{\n    //S nodi gia' visitati, Q nodi ancora da visitare\n    int u, v, nVisited;\n    int *d, *p; //array, distanze e pred dei nodi\n    bool *Q; //coda di priorita' con array\n    Vertex *vnext;\n    d = (int*)malloc(n* sizeof(int));\n    p = (int*)malloc(n* sizeof(int));\n    Q = (bool*)malloc(n* sizeof(bool));\n    for (v = 0; v<n; v++)\n    {\n        d[v] = INT_MAX;\n        p[v] = -1;\n        Q[v] = true;\n    }\n    d[s] = 0;\n    p[s] = s;\n    nVisited = 0;\n    while (nVisited < n)\n    {\n        u = extractMin(Q, d, n);\n        nVisited++;\n        Q[u] = false; //non e' più da visitare\n        vnext = Adj[u];\n        while (vnext!= NULL)\n        {\n            v = vnext->id;\n            if ((d[v] > d[u] + vnext->dist))\n            {\n                d[v] = d[u] + vnext->dist;\n                p[v] = u;\n            }\n            vnext = vnext->next;\n        }\n    }\n    return p;\n}\n```\n\n\nWhere Vertex is:\n\n```\ntypedef struct _Vertex\n{\n    int id;\n    int dist;\n    struct _Vertex* next;\n} Vertex;\nVertex** Adj;\n```\n\n\nThe Adj array is initialized through a readfile that properly create it.\n\nMy idea of heap was this: \n\n```\ntypedef struct node {\n    //What should I put here?\n    //I thought about int distance, predecessors;\n} node ;\n\ntypedef struct minHeap {\n    int size ;\n    node *elem ;\n} minHeap ;\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue implementation for SQS Spring and Java\r\n                \r\nLooks like Ruby has shoryuken, what does Java have for this, there is this answer to SO for Ruby, Amazon SQS Priority Queue, I am yet to find any example or way to do this with JMS and Spring, which is weird in itself. It feels like all consumption is pushed into the infrastructure, that I have maybe 5 consumers on high priority and 1 consumer on low priority, but I can't have 6 consumers alternating in where they take their work from.\n    ", "Answer": "\r\nAs I answered to your other question; the ```\nJmsListener```\n is a message-driven approach, similar to JEE MDBs; you can use a ```\nJmsTemplate```\n instead to have complete control over fetching messages.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Prim's Algorithm with Priority Queues implementation\r\n                \r\n```\nvoid PrimMST(float A[GsizeSqr][GsizeSqr])\n{\n    int i, j, pCount, gs, row, ind, findN;\n    gs = sqrt(GsizeSqr);\n    pCount = 0;\n\n    D_array MST; //MST contains the nodes of the MST and is initialized with the starting node\n    initArr(&MST, 1);\n    int p[GsizeSqr];\n    float priority[GsizeSqr]; //priority contains weight(u, p[u])\n\n    //Initialize p and priority with infinity and NULL values (note: -1 means null and 1000000 means inf)\n    for(i=0; i < GsizeSqr; i++){\n        p[i] = -1;\n        priority[i] = 1000000;\n    }\n\n    PriorityQueue Q; //Initialize priority queue that stores (priority, key) values\n    Q = init_heap(GsizeSqr);    \n    for(i=0; i < gs; i++){ //Insert input adjacency matrix into priority queue\n        for(j=0; j < gs; j++){\n            node n;\n            n = create_node(A[i][j], pCount++);\n            enqueue(Q, n);          \n        }\n    }\n\n    node start; //Select starting node and insert to MST\n    start = create_node(0, 0);\n    insArr(&MST, start);\n\n    priority[0] = 0;\n\n    while(Q->heap_size != 1){ //while Q not empty\n        node u;\n        u = dequeue(Q);\n        if(p[u.key] != -1)\n            insArr(&MST, u);\n\n        row = ceil(u.key/gs);\n        //For each adjacent node A[row][i]\n        for(i=0; i < gs; i++){\n            if(A[row][i] != 0.0){\n                ind = i*gs + row; //Calculate index of adjacent node\n                findN = find_node(Q, ind); //find and return index of adjacent node in queue\n\n                if(findN != 0 && u.priority < Q->elements[findN].priority){\n                    set_priority(Q, findN, u.priority);\n                    p[findN] = u.key;                   \n                }               \n            }\n        }\n    }   \n}\n```\n\n\nI am trying to create a C implementation of Prim's Algorithm using priority queues using the pseudocode which is similar to many sources online.  The end goal is (hopefully) some nifty maze generation. I'm just having confusion with the details of the implementation.\n\ninput: An adjacency matrix with random weights\n\ndesired output: The adjacency matrix for a minimal spanning tree\n\n*EDIT: Added my (not working) attempt.  I'm still getting an incorrect tree, I'm not sure where I'm going wrong.  I think I would benefit from another set of eyes over this code.\n    ", "Answer": "\r\nfirst question:\nA is the set that contains the edges of the MST.\np[u] means which node has the minimum edge with u currently, that is to say, if you have three edges(node 1, node 2, weight) (1,2,5), (1,3,4), (1,4,10), then p[1] = 3, and now priority[1] is 4.\n\nsecond one:\nnope, the node is pop after ```\nu := EXTRACT-MIN(Q);```\n, \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority queue using Custom interfaces as attached in both the images?\r\n                \r\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n \nnamespace MyQueue\n{\n    public class PriorityQueue<T> where T : IEquatable<T>\n    {\n        private IDictionary<int, IList<T>> elements;\n      \n \n        public PriorityQueue()\n        {\n           \n            elements = new SortedDictionary<int, IList<T>>();\n           \n        }\n        public PriorityQueue(IDictionary<int, IList<T>> elements) : this()\n        {\n        }\n        public int Count()\n        {\n            return elements.Count;\n        }\n \n        public bool Contains(T item)\n        {\n            bool res = false;\n            foreach (KeyValuePair<int, IList<T>> pair in elements)\n            {\n              \n                enter image description here\n                if (pair.Value[0].Equals(item))\n                {\n                    Console.Write($\"{item} Found --> {pair.Key} {pair.Value[0]}\");\n                    res = true;\n                }\n                if (res == true)\n                {\n                    return res;\n                }\n            }\n            return res;\n        }\n \n        public T Dequeue()\n        {\n           \n            IList<T> list = elements[elements.Keys.First()];\n            int priority = elements.Keys.First();\n            T highestPriority = list.First();\n          \n            list.Remove(highestPriority);\n            if (list.Count == 0)\n            {\n                elements.Remove(priority);\n            }\n            return highestPriority;\n \n        }\n \n        public void Enqueue(int priority, T item)\n        {\n            IList<T> items;\n            if (!elements.ContainsKey(priority))\n                elements.Add(priority, new List<T>());\n            items = elements[priority];\n            items.Add(item);\n        }\n        public T Peek()\n        {\n            IList<T> priorityList = elements[elements.Keys.First()];\n            return priorityList[0];\n        }\n \n        public int getHighestPriority()\n        {\n            int Firstkey = elements.Take(1).Select(d => d.Key).First();\n            return Firstkey;\n        }\n    }\n \n    class Program\n    {\n \n        static void Main(string[] args)\n        {\n            PriorityQueue<string> priorityQueue = new PriorityQueue<string>();\n \n \n            priorityQueue.Enqueue(3, \"Iooawi\"); \n            priorityQueue.Enqueue(1, \"Zuika\"); \n            priorityQueue.Enqueue(2, \"Aki\");\n        \n            priorityQueue.Enqueue(5, \"Iak\"); \n           \n            \n \n \n            Console.WriteLine($\"Top item: -> { priorityQueue.Peek()}\");\n            Console.WriteLine($\"Removed item--> {priorityQueue.Dequeue()}\");\n \n            Console.WriteLine($\"Top item: -> { priorityQueue.Peek()}\");\n            Console.WriteLine($\"Items present in this queue {priorityQueue.Count()}\");\n \n \n \n            Console.WriteLine($\" ---> { priorityQueue.Contains(\"Iak\")}\");\n \n            Console.WriteLine($\"{priorityQueue.getHighestPriority()}\");\n        }\n    }\n}\n```\n\nPriority Queue Implementation 2 \nPriority Queue Implementation 3\nHow do I achieve the following implementations using custom interfaces given in the images, above is the code which I have tried and how do I add the field to the custom interface.\nI have tried using Iequatable in the above implementation but in the custom interface Ipriority it is not allowing me to set the field int priority?\nWhat are the ways to implement interface? Also how to access setHighestPriority method if I set it to private?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue implementation in C- changing chars to ints\r\n                \r\nI am currently working on a project that requires a priority queue in C. I am using the code from Rosettacode.org.\n\nI am attempting to modify the priority queue so that it takes an integer instead of a character. I tried changing all of the variable types but I am getting the following error.\n\n\n  test.c:62:16: warning: incompatible integer to pointer conversion passing 'int'\n        to parameter of type 'int *' [-Wint-conversion]\n\n\nThis works perfectly when its a char, but suddenly stops when its an int. Why is this happening? Here is my code:\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int priority;\n    int *data;\n} node_t;\n\ntypedef struct {\n    node_t *nodes;\n    int len;\n    int size;\n} heap_t;\n\nvoid push (heap_t *h, int priority, int *data) {\n    if (h->len + 1 >= h->size) {\n        h->size = h->size ? h->size * 2 : 4;\n        h->nodes = (node_t *)realloc(h->nodes, h->size * sizeof (node_t));\n    }\n    int i = h->len + 1;\n    int j = i / 2;\n    while (i > 1 && h->nodes[j].priority > priority) {\n        h->nodes[i] = h->nodes[j];\n        i = j;\n        j = j / 2;\n    }\n    h->nodes[i].priority = priority;\n    h->nodes[i].data = data;\n    h->len++;\n}\n\nint *pop (heap_t *h) {\n    int i, j, k;\n    if (!h->len) {\n        return NULL;\n    }\n    int *data = h->nodes[1].data;\n    h->nodes[1] = h->nodes[h->len];\n    h->len--;\n    i = 1;\n    while (1) {\n        k = i;\n        j = 2 * i;\n        if (j <= h->len && h->nodes[j].priority < h->nodes[k].priority) {\n            k = j;\n        }\n        if (j + 1 <= h->len && h->nodes[j + 1].priority < h->nodes[k].priority) {\n            k = j + 1;\n        }\n        if (k == i) {\n            break;\n        }\n        h->nodes[i] = h->nodes[k];\n        i = k;\n    }\n    h->nodes[i] = h->nodes[h->len + 1];\n    return data;\n}\n\nint main () {\n    heap_t *h = (heap_t *)calloc(1, sizeof (heap_t));\n    push(h, 3, 3);\n    push(h, 4, 4);\n    push(h, 5, 5);\n    push(h, 1, 1);\n    push(h, 2, 2);\n    int i;\n    for (i = 0; i < 5; i++) {\n        printf(\"%d\\n\", pop(h));\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nIn your ```\npush()```\n function signature, the third argument is of type ```\nint *```\n, but you're sending an ```\nint```\n while calling it. Pointer to integer conversion is an implementation specific behavior and is has high potential for causing undefined behavior.\n\nAs I see it, you don't need ```\ndata```\n to be a pointer, a simple ```\nint```\n everywhere should do the job.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement queue and priority queue in Tcl?\r\n                \r\nI have to implement either queue or priority queue in Tcl without use of any library.\n\nI have tried to write below code. Kindly help me to implement queue in better way in Tcl/Tk.\n\ncreate node\n\n```\n// crearting node element of queue  \n\nproc createNode {name cost} {\n            namespace eval $name [subst {     \n                variable cost $cost  \n                variable this $name   \n            }]  \n```\n\n\nfunctions\n\n```\nproc ${name}::getCost {} {  \n            variable cost  \n            return $cost  \n        }  \n      return $name  \n     } \n```\n\n\ndelete queue\n\n```\n proc deQueue name {  \n           #upvar 1 $name queue  \n           set queue $name  \n           set res [lindex $queue 0]  \n           set queue [lrange $queue 1 end]; # remove the first element  \n           set res; # return the value  \n        }  \n```\n\n\nqueue insertion\n\n```\n  proc enQueue {newNode name} { \n            #upvar 1 $name queue  \n            set queue $name  \n            set queue [concat $newNode $queue]  \n        }  \n```\n\n\ncreate queue\n\n```\n proc makeQueue {n g } {   \n            set queue [list [createNode $n $g ]] \n            return $queue   \n        }   \n```\n\n    ", "Answer": "\r\nA simple queue implementation:\n\n```\nproc enqueue {name item} {\n    upvar 1 $name queue\n    lappend queue $item\n}\n\nproc dequeue name {\n    upvar 1 $name queue\n    set queue [lassign $queue item]\n    return $item\n}\n\n% enqueue a foo\n% set item [dequeue a]\n```\n\n\nA simple priority queue:\n\n```\nproc enpqueue {name prio item} {\n    upvar 1 $name queue\n    lappend queue [list $prio $item]\n    set queue [lsort -decreasing -integer -index 0 $queue]\n}\n\nproc depqueue name {\n    upvar 1 $name queue\n    set queue [lassign $queue prioitem]\n    return [lindex $prioitem 1]\n}\n\n% enpqueue a 10 foo\n% enpqueue a 40 bar\n% set item [depqueue a]\nbar\n```\n\n\nThe only thing you need for a queue or priority queue is a list and an add/remove interface.\n\nIf you want to store structured data in the queue, make the ```\nitem```\n either a tuple of data:\n\n```\nset item [list \"Smith, John\" 42 1500]\n```\n\n\nor a dictionary:\n\n```\nset item [list name \"Smith, John\" age 42 foo 1500]\n```\n\n\nDocumentation:\nlappend,\nlassign,\nlindex,\nlist,\nlsort,\nproc,\nreturn,\nset,\nupvar\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "F# priority queue\r\n                \r\nDoes the F# library include a priority queue? Else can someone point to me an implementation of priority queue in F#?\n    ", "Answer": "\r\nTake a look at http://lepensemoi.free.fr/index.php/tag/data-structure for a whole bunch of F# implementations of various data structures.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Does R have a priority queue like Java's PriorityQueue?\r\n                \r\nI am looking for a general purpose priority queue in ```\nR```\n. Does R has any general purpose priority queue implementation (package) like Java ```\nPriorityQueue```\n class or Python ```\nheapq```\n?\n    ", "Answer": "\r\nI went ahead and implemented a basic queue as an R Reference Class. The details can be found here. It's been extended to handle a priority queue, as documented here.\n\nThe basic and priority queue implementations are now available as the liqueueR package on CRAN, with a development version on GitHub.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queues implemented with avl in python\r\n                \r\nOperations insert, delete, search for an AVL tree are implemented. How can I\nimplement the operations insert, maximum, extract-max, increase-key, decrease-key that a priority queue should support in python?\n    ", "Answer": "\r\nAn AVL tree is just a balanced binary search tree. The heap operations you've asked about can easily be implemented using the standard AVL operations.\n\n\ninsert - Just insert into the AVL tree as you normally would.\nmaximum - I assume you mean find-max. The maximum element in an AVL tree is the rightmost node. So just start at the root, traverse right pointers to the end, and return the leaf node.\nextract-max - Find the maximum node as above, and delete it.\nincrease-key and decrease-key - Do a standard binary tree search to find the node you're interested in. Delete it from the tree. Modify the key. Re-insert into the tree.\n\n\nNote that this won't be as efficient as a binary heap priority queue, but it will work.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Which implementation of Priority Queue will be effective if there are huge number of insert operation?\r\n                \r\nSuppose that your application will have a huge number of insert operations, but\nonly a few remove the maximum operations. Which priority-queue implementation do\nyou think would be most effective: heap, unordered array, or ordered array?\n\nCan anyone explain with an example?\n    ", "Answer": "\r\nSimilar question Have you seen http://gateoverflow.in/65570/gatebook-exam.\nThere are four implementations for priority queue: For your case Un-ordered preferable.\n\n```\n|Structure          | Insertion | Extract-max|\n|----------         |---------- |------------|\n|Unordered list     |   O(1)    |   O(n)     |\n|Ordered list       |   O(n)    |   O(1)     |\n|Binary Search Tree |  O(logn)  |   O(logn)  |\n|Heap               |  O(logn)  |   O(logn)  |\n----------------------------------------------\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority Queue in dart?\r\n                \r\nIs Priority Queue collection available in dart because I am not able to use priority queue in flutter?\nIf so, then please write a snippet of how to use it. I am not able to find any handy explanation of how to use Priority Queue in flutter.\n    ", "Answer": "\r\n```\nimport 'package:collection/collection.dart';\n\nvoid main() {\n  // queue that prioritizes longer strings\n  final queue = PriorityQueue<String>((a, b) => b.length.compareTo(a.length));\n  queue..add('foo')..add('bazars')..add('zort');\n  \n  while (queue.isNotEmpty) {\n    print('* ${queue.removeFirst()}');\n  }\n}\n```\n\nDocs at https://pub.dev/documentation/collection/latest/collection/PriorityQueue-class.html\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a multiprocessing priority queue in Python?\r\n                \r\nAnybody familiar with how I can implement a multiprocessing priority queue in python?\n    ", "Answer": "\r\nAlas, it's nowhere as simple as changing queueing discipline of a good old ```\nQueue.Queue```\n: the latter is in fact designed to be subclassed according to a template-method pattern, and overriding just the hook methods ```\n_put```\n and/or ```\n_get```\n can easily allow changing the queueing discipline (in 2.6 explicit LIFO and priority implementations are offered, but they were easy to make even in earlier versions of Python).\n\nFor multiprocessing, in the general case (multiple readers, multiple writers), I see no solution for how to implement priority queues except to give up on the distributed nature of the queue; designate one special auxiliary process that does nothing but handle queues, send (essentially) RPCs to it to create a queue with a specified discipline, do puts and gets to it, get info about it, &c. So one would get the usual problems about ensuring every process knows about the aux proc's location (host and port, say), etc (easier if the process is always spawned at startup by the main proc). A pretty large problem, especially if one wants to do it with good performance, safeguards against aux proc's crashes (requiring replication of data to slave processes, distributed \"master election\" among slaves if master crashes, &c), and so forth. Doing it from scratch sounds like a PhD's worth of work. One might start from Johnson's work, or piggyback on some very general approach like ActiveMQ.\n\nSome special cases (e.g. single reader, single writer) might be easier, and turn out to be faster for their limited area of application; but then a very specifically restricted spec should be drawn up for that limited area -- and the results would not constitute a (general purpose) \"multiprocessing queue\", but one applicable only to the given constrained set of requirements.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue with a find function - Fastest Implementation\r\n                \r\nI am looking at implementing a priority queue with an added requirement, a find/search function which will tell whether an item is anywhere within the queue. So the functions will be: insert, del-min and find.\n\nI am unsure whether I should use a Heap or a Self-balancing binary search tree. It appears PQs are usually implemented with a Heap, but I am wondering if there is any advantage in using a binary search tree since I also need that find function.\n\nFurthermore, on average I'll be doing more inserts than deletes. I am also considering a d-ary heap. Basically, every second counts.\n\nThanks!\n    ", "Answer": "\r\nWhy can't you just use a Priority Queue and a Set? When you enqueue something, you add it to the set. When you dequeue it, you remove it from the set. That way the set will tell you if something is in the queue.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Use a linked list to implement a Priority Queue\r\n                \r\nI have implemented a priority queue using a linked list. In this priority queue the smallest int value has the highest value and therefore by calling the remove method the smallest method will be removed.\n\nCode for Node Class\n\n```\npublic class Node {\n\n    public int iData;\n    public Node next;\n\n    public Node(int x) {\n        iData = x;\n    }\n\n    public void displayNode() {\n        System.out.println(iData + \" \");\n    }\n\n}\n```\n\n\nCode for Link List\n\n```\npublic class LinkList {\n\n    private Node first;\n\n    public LinkList() {\n        first = null;\n    }\n\n    public boolean isEmpty() {\n        return first == null;\n    }\n\n    public void insert(int x) {\n        Node newNode = new Node(x);\n        Node previous = null;\n        Node current = first;\n\n        while (current != null && x < current.iData) {\n            previous = current;\n            current = current.next;\n        }\n\n        if (previous == null) {\n            newNode.next = first;\n            first = newNode;\n        }\n\n        else {\n            previous.next = newNode;\n            newNode.next = current;\n        }\n    }\n\n    public Node remove() {\n        Node previous = null;\n        Node current = first;\n        Node temp = current;\n\n        while (current.next != null) {\n            previous = current;\n            current = current.next;\n        }\n\n        previous.next = null;\n\n        return temp;\n    }\n\n    public void display() {\n        Node current = first;\n\n        while (current != null) {\n            current.displayNode();\n            current = current.next;\n        }\n\n        System.out.println(\" \");\n    }\n\n}\n```\n\n\nCode for Priority Queue\n\n```\npublic class PriorityQ {\n\n    private LinkList list;\n\n    public PriorityQ() {\n        list = new LinkList();\n    }\n\n    public void insert(int x) {\n        list.insert(x);\n    }\n\n    public void remove() {\n        list.remove();\n\n    }\n\n    public void displayList() {\n        System.out.println(\"Largest Value to Smallest\");\n        list.display();\n    }\n\n}\n```\n\n\nIt is working fine at the moment, however i am not sure if my remove method in the link list class is the best way to go about removing elements. So i am looking for suggestions.\n    ", "Answer": "\r\n```\nremove()```\n is supposed to remove the first element from the list, right? Why do you loop anything for that?\n\nSince your list is singly-linked (only pointing to next elements in the Node) all you need to do is:\n\n\nStore the ```\nfirst```\n in a temporary variable (if it's != null) \nThen update ```\nfirst```\n to be pointing to the 2nd item in the list\n(```\nfirst.next```\n if != null) \nThen return the temporary variable.\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue implemented by Vector using Abstract Class C++\r\n                \r\nI am trying to implement a Priority Queue using a Vector template in C++. I am most comfortable with Java and want to mimic the idea of an Interface, where all objects that can use the Priority Queue are required to implement certain methods.\n\nI know that C++ does not support Interfaces, however, someone suggested that by tapping into Multiple Inheritance this could be achieved by creating an Abstract Class and requiring some virtual functions.\n\nI would like all objects that can use the Priority Queue to implement:\n\n```\npublic:\nint compareTo(Comparable &obj);\n```\n\n\nHere is a C++ Abstract Class that achieves this:\nComparable.h\n\n```\nclass Comparable {\npublic:\n    Comparable();\n    ~Comparable();\n    virtual int compareTo(Comparable &obj) = 0;\n};\n```\n\n\nThis works great, no errors are formed from supplying the Abstract Class to the Vector template:\n\n```\nvector<Comparable> *mElements = new vector<Comparable>(); // no error\n```\n\n\nIt is not until I try to use polymorphism in a class that inherits from the Comparable class that I run into an issue. Because the Method signature receives a Comparable&, I am having trouble accessing the members of the class that extends Comparable:\n\n```\nint Event::compareTo(Comparable& obj) {\n    // Min-Heap - time of currentObject is less than e.mTime\n    Event e = (Event) obj; // Doesn't work - No C-style cast (can I make one and how?)\n// if I trying obj.mTime, this won't work because it is not a member of the Comparable class\n\n\nif (mTime < e.mTime) return Delta::NEGATIVE_CHANGE;\nif (mTime > e.mTime) return Delta::POSITIVE_CHANGE;\n    return return Delta::NO_CHANGE;\n}\n```\n\n\nAll I need to do is compare the time in this example, but I would like to design the class so that clients only have to inherit from the Comparable class and implement the one method for use of the priority queue.\n\nThanks for any help in advanced!\n    ", "Answer": "\r\nYou are searching for dinamic_cast\nhttp://en.cppreference.com/w/cpp/language/dynamic_cast\n\ndinamic_cast has a ugly name cause you shouldn't use it too much. In this case, you don't need it.\n\nFirst, in C++ you can overload operators (<, >, ==...). If these operators doesn't exist, the class can't be compared. It's more natural and easy for compare :)\n\nSecond, you can use a generic template:\n\n```\ntemplate<class T>\nclass Comparable {\npublic:\n    Comparable();\n    ~Comparable();\n    virtual int compareTo(T &obj) = 0;\n};\n\nclass event : public Comparable<event> {\n    //...\n    public:\n        int compareTo(event &e) override;\n};\n```\n\n\nYou can detect wrong types in compile time, you don't need cast in execution time :)\n\noverride is one c++11 flag for compiler: \"This function should override one parent function, check it\". You can remove it freely if you don't use C++11\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Adaptive trapezoidal rule and clarifications on priority queue implementation\r\n                \r\nOn the subject of adaptive trapezoidal subdivision (see this and this), I need to solve a problem where evaluating ```\nf(x)```\n takes a lot of time, so I need to do it the least number of times possible.\nSearching on SO I found this answer: https://stackoverflow.com/a/29837372/261010\n\nRather than considering the error in each subinterval separately, more advanced codes compute the total error over all the subintervals and refine until the total error is below the desired threshold. Subintervals are chosen for refinement according to their contribution to the total error, with larger errors being refined first. Typically a priority queue is used to quickly chose the subinterval for refinement.\n\nWhat does this mean exactly? How does the priority queue help in this scenario? How many subintervals can be considered \"larger\"?\n    ", "Answer": "\r\nThe priority queue is not used to compute the error in each interval. Instead, it’s used to track which interval currently has the largest error, so the algorithm can refine it. This pattern with a priority queue is used in many so-called “greedy” algorithms, such as Dijkstra search and Prim’s algorithm.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority queue in C programming?\r\n                \r\nI need to implement a priority queue in C programming using singly linked list. \n\nI do not have a clear idea about priority queue. I googled but didn't fully understand what I found. My understanding is that a priority queue is a queue whose elements are ordered by priority. Insertions into the list are positioned within the list on the basis of the element priorities.\n\nLets say,we have following scenario. (Note : I assume, higher value goes with higher priority):\n\n```\nElement-->2 (priority=2)  (Now in position 0)\n```\n\n\nIf another element needs to be inserted, say ```\nElement-->3 (priority=3)```\n which has a higher priority.\n\nI can move the previous element, ```\nElement-->2 (priority=2)```\n, and insert this new ```\nElement-->3 (priority=3)```\n at position 0 with ```\nElement-->2 (priority=2)```\n moved to position 1 in the list.\n\nNow the list becomes,\n\n```\nElement-->3 (priority=3) followed by Element-->2 (priority=2)\n```\n\n\nSimilarly, on the basis of insertion, do I have to shift all the elements in the list?\n\nIs this correct?\n    ", "Answer": "\r\nYou don't have to \"shift\" the list, instead when inserting you do something like this (pseudo-code):\n\n```\nif new_node.priority > list.head.priority:\n    new_node.next = list.head\n    list.head = new_node\nelse:\n    previous = null\n    for current = list.head:\n        if current.priority < node.priority:\n            previous.next = node\n            node.next = current\n            break loop\n        previous = current\n```\n\n\nIf your list has a pointer to the end, you can add a special check for a priority lower than the end as well.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Change priority of a priority queue\r\n                \r\nI have created a priority queue implementation which I am using to simulate a print server. I also have a PrintJob for the items that are going to be printed.In this print server the smallest items (files to be printed) have the biggest priority. Although, sometimes the biggest files may wait too much time in the priority queue so what I am trying to do is : if a file waits in the priority queue for 15 seconds then change the priority. What's the best way to do this ?\n\nMy priority queue implementation is :\n\n```\nimport java.util.Comparator;\n\n\npublic class MaxPQ<T> {\n\npublic T[] heap;\nprivate int size;\nprotected Comparator<T> cmp;\n\n\npublic MaxPQ(int capacity, Comparator<T> cmp) {\n    if (capacity < 1) throw new IllegalArgumentException();\n    this.heap = (T []) new Object[capacity+1];\n    this.size = 0;\n    this.cmp = cmp;\n}\n\nMaxPQ() {}\n\nprivate void swap(int i, int j) {\n    T tmp = heap[i];\n    heap[i] = heap[j];\n    heap[j] = tmp;\n}\n\npublic void print() {\n    for (int i=1; i<=size; i++){\n        System.out.print(heap[i]+ \"\");\n    }\n    System.out.println();\n}\n\nboolean isEmpty(){\n    return size == 0;\n}\n\npublic void insert(T object) {\n    if (object == null) throw new IllegalArgumentException();\n\n    if (size == heap.length - 1) throw new IllegalStateException();\n\n    if (size >= 0.75*heap.length) {\n        resize(2*heap.length);\n    }\n\n    heap[++size] = object;\n\n    swim(size);\n}\n\npublic T getMax() {\n    if (size == 0) throw new IllegalStateException();\n\n    T object = heap[1];\n\n    if (size > 1) heap[1] = heap[size];\n\n    heap[size--] = null;\n\n    sink(1);\n\n    return object;\n}\n\nprivate void swim(int i) {\n    while (i > 1) { //if i root (i==1) return\n        int p = i/2; //find parent\n        int result = cmp.compare(heap[i], heap[p]); //compare parent with child\n        if (result <= 0) return; //if child <= parent return\n        swap(i, p); //else swap and i=p\n        i = p;\n    }\n}\n\nprivate void sink(int i){\n    int left = 2*i, right = left+1, max = left;\n\n    while (left <= size) {\n\n        if (right <= size) {\n            max = cmp.compare(heap[left], heap[right]) < 0 ? right : left;\n        }\n\n        if (cmp.compare(heap[i], heap[max]) >= 0) return;\n\n        swap(i, max);\n        i = max; left = 2*i; right = left+1; max = left;\n    }\n}\n\nprivate void resize(int newSize) {\n    Object[] newHeap = new Object[newSize];\n    System.arraycopy(heap, 0, newHeap, 0, size);\n    heap = (T[]) newHeap;\n}\n\n\npublic int size(){\n    return size;\n}\n\n\n\n\n}\n```\n\n\nThe printjob items contains the following fields : id , size(the size of the file),waitingtime(the time in the queue),arrivaltime(the arrival time in the print,priority)\n\nHere is what I have done:\n\n```\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport static java.lang.Double.min;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class AlgorithmC {\npublic static void runC() throws FileNotFoundException{\n    readFile(\"arxeia\");\n}\n\nprivate static final int MAXSIZE = 128;\nprivate int T = 0;\nstatic ArrayList<PrintJob> printList = new ArrayList<>();\nMaxPQ<PrintJob> printPQ = new MaxPQ<>();\n\npublic static void readFile(String filename) throws FileNotFoundException{\n        Scanner scanner = new Scanner(new File(\"filename.txt\"));\n        int waitingTime = 0;\n        int r = 0;\n        while(scanner.hasNextInt()){\n            int size = scanner.nextInt();\n            int arrivalTime = scanner.nextInt();\n            PrintJob p = new PrintJob(size,waitingTime,arrivalTime,size);\n            printList.add(p);\n        }\n        for(int i = 0;i < printList.size(); i++){\n            if((printList.get(i).getArrivalTime()) <= (printList.get(i+1).getArrivalTime())){\n                r += 1;\n            }\n        }\n        if(r != (printList.size()) - 1){\n            System.out.println(\"Invalid file format!\");\n        }\n\n        for(int i = 0;i < printList.size(); i++){\n            if((printList.get(i).getSize() < 0 || printList.get(i).getSize() > MAXSIZE )){\n                System.out.println(\"Invalid file size!\");\n            }\n        }\n\n\n}\n\npublic void storeFile(String filename){     \n    BufferedWriter bw = null;\n    FileWriter fw = null;\n\ntry {  \n        int i = 0;\n        fw = new FileWriter(filename);\n        bw = new BufferedWriter(fw);\n\n        T = printList.get(1).getArrivalTime();\n        bw.write(\"t = \" + (T + printList.get(1).getSize()) + \",completed file\" + printList.get(1).getid());\n        T = T + printList.get(1).getSize();\n        printList.remove(1);\n        for (PrintJob printItem : printList) {\n            printPQ.insert(printItem);\n        }\n        int size = printPQ.size();\n        int max = 0;\n        int tempID = 0;\n                    int time = 0;\n        while(i < size){\n            PrintJob nextPrint = printPQ.getMax();\n            T = T + nextPrint.getSize();\n            bw.write(\"t = \" + T + \",completed file\" + printList.get(i).getid());\n            time =+ (T - nextPrint.getArrivalTime());\n                            for(int j = 0; j < printPQ.size(); j++){\n                                if((T-(printPQ.heap[j].getArrivalTime())) >= 15){\n                                    printPQ.heap[j].setPriority((int) min(127,printPQ.heap[j].getPriority() + printPQ.heap[j].getWaitingTime()));\n                                }\n                            }\n                            nextPrint.setWaitingTime(time);\n            if(time > max){\n                max = time;\n                tempID = nextPrint.getid();\n            }\n            i =+ 1;\n        }\n        int averageWaitingTime = time/(size-1);\n        bw.write(\"Average waiting time = \" + averageWaitingTime + \" \" );\n        bw.write(\"Maximum waiting time = \" + max + \"achieved by file \" + tempID + \" \");\n\n    }\n    catch (IOException e) {\n        e.printStackTrace();\n\n    } finally {\n        try {\n            if (bw != null)\n                bw.close();\n            if (fw != null)\n                fw.close();\n        } \n        catch (IOException ex) {\n        ex.printStackTrace();\n\n        }\n\n    }\n\n}\n}\n```\n\n\nSo when I change the priority I may ruin the heap structure.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a priority queue using two queues\r\n                \r\nIn a interview question I was asked to implement a priority queue using queues,\n\nAfter the interview I googled it and found that it can be implemented using two queues, but I did not find how..\n\nPlease can anybody explain me.\n\nThanks in advance.\n    ", "Answer": "\r\nThe main advantage of using a priority queue is that we can get min/max at a constant time. So it is the first criteria that should be met. We are considering key values only.\nWe can create a prioity queue using two Queues name them q1 and q2\nif the input element is larger than top of q1 then append it to q1 else\n\nif the input is smaller than top of q1 then repeat\n\nremove element from q1 and insert to q2 till top is greater than that element\n\nnow add the element \n\nnow insert the remaining elements to the q2\n\n```\nso like input is 2 4 1 5 3\npass 1)\nq1-> 2 \nq2->  \npass 2)\nq1-> 2 4\nq2->\npass 3)\nq1-> \nq2->1 2 4 // since 1 is less than top of q1 add it to q2 and then pop all the elements to q2\npass 4)\nq1-> \nq2-> 1 2 4 5 //add it to q2 since it is larger than all the elements\npass 5)\nq1-> 1 2 3 4 5//pop the elements smaller than q3 and then add the element and append the        remaining\n\nq2->\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Python: Using my heap in a priority queue implementation\r\n                \r\nI am having real trouble using my custom-made heap class functions to be used in my Priority Queue class. I am having trouble on what functions from my heap class to use for my \"enqueue\", \"dequeue\", \"front\" and \"size\" functions for my PriorityQueue. I know for \"enqueue\" I need to use my insert function, but I don't know how to go about this because I have a priority. Could someone help me out what I need to do in order to make my PriorityQueue class to use the functions from my Heap class in order to work properly? I have been stuck on this for awhile and I keep finding answers that include using the built in python functions such as queue and heapq.\n\nclass Heap(object):\n\n```\n    def __init__(self, items=None):\n\n        '''Post: A heap is created with specified items.'''\n\n        self.heap = [None]\n        if items is None:\n            self.heap_size = 0\n        else:\n            self.heap += items\n            self.heap_size = len(items)\n            self._build_heap()\n\n    def size(self):\n\n        '''Post: Returns the number of items in the heap.'''\n\n        return self.heap_size\n\n    def _heapify(self, position):\n\n        '''Pre: Items from 0 to position - 1 satisfy the Heap property.\n       Post: Heap Property is satisfied for the entire heap.'''\n\n        item = self.heap[position]\n        while position * 2 <= self.heap_size:\n            child = position * 2\n            # If the right child, determine the maximum of two children.\n            if (child != self.heap_size and self.heap[child+1] > self.heap[child]):\n                child += 1\n            if self.heap[child] > item:\n                self.heap[position] = self.heap[child]\n                position = child\n            else:\n                break\n        self.heap[position] = item\n\n    def delete_max(self):\n\n        '''Pre: Heap property is satisfied\n       Post: Maximum element in heap is removed and returned. '''\n\n        if self.heap_size > 0:\n            max_item = self.heap[1]\n            self.heap[1] = self.heap[self.heap_size]\n            self.heap_size -= 1\n            self.heap.pop()\n            if self.heap_size > 0:\n                self._heapify(1)\n            return max_item\n\n    def insert(self, item):\n\n        '''Pre: Heap Property is Satisfied.\n       Post: Item is inserted in proper location in heap.'''\n\n        self.heap_size += 1\n        # extend the length of the list.\n        self.heap.append(None)\n        position = self.heap_size\n        parent = position // 2\n        while parent > 0 and self.heap[parent] < item:\n            # Move the item down.\n            self.heap[position] = self.heap[parent]\n            position = parent\n            parent = position // 2\n        # Puts the new item in the correct spot.\n        self.heap[position] = item\n\n    def _build_heap(self):\n\n        ''' Pre: Self.heap has values in 1 to self.heap_size\n           Post: Heap property is satisfied for entire heap. '''\n\n        # 1 through self.heap_size.\n\n        for i in range(self.heap_size // 2, 0, -1): # Stops at 1.\n            self._heapify(i)\n\n    def heapsort(self):\n\n        '''Pre: Heap Property is satisfied.\n           Post: Items are sorted in self.heap[1:self.sorted_size].'''\n\n        sorted_size = self.heap_size\n\n        for i in range(0, sorted_size -1):\n            # Since delete_max calls pop to remove an item, we need to append a dummy value to avoid an illegal index.\n            self.heap.append(None)\n            item = self.delete_max()\n            self.heap[sorted_size - i] = item\n```\n\n\nSo this is working but like I previously stated I am having trouble on how to make a priority queue out of this? I know asking for code is wrong, but I'm desperate could anyone help me out here? I have the basic rundown on what I want my priority code to do..\n\n```\n#PriorityQueue.py\nfrom MyHeap import Heap\n\n\nclass PriorityQueue(object):\n\n    def __init__(self):\n        self.heap = None\n\n    def enqueue(self, item, priority):\n        '''Post: Item is inserted with specified priority in the PQ.'''\n        self.heap.insert((priority, item))\n\n    def first(self):\n    '''Post: Returns but does not remove the highest priority item from the PQ.'''\n        return self.heap[0]\n\n    def dequeue(self):\n    '''Post: Removes and returns the highest priority item from the PQ.'''\n    if self.heap is None:\n        raise ValueError(\"This queue is empty.\")\n    self.heap.delete_max()\n\n    def size(self):\n    '''Post: Returns the number of items in the PQ.'''\n        return self.size\n```\n\n\nThis is what I got so far but I do not know if it is entirely correct. Could anyone help me out?\n\nI edited my code to the most current version of it.\n    ", "Answer": "\r\nSince this is presumably homework, all I can do is give hints, which is often easier done as comments. Since this ended up being a fairly thorough series of hints I'm summarizing them as an answer here.\n\nFor the most part, methods in your ```\nPriorityQueue```\n class will map to methods you've already implemented in your Heap class:\n\n\n```\nPriorityQueue.enqueue()```\n maps pretty easily to Heap.insert()\n```\nPriorityQueue.first()```\n does not have a corresponding heap method, but can still be implemented in one line. You just need to return the maximum value, which will always be at a specific place in your heap. \n```\nPriorityQueue.dequeue()```\n is a little more complicated. It needs to save the value of the top item first so that it can return it after calling ```\nheap.delete_max()```\n\nThe heap class already has a ```\nsize()```\n method, which ```\nPriorityQueue.size()```\n can call, instead of maintaining a separate size variable within the ```\nPriorityQueue```\n class.\n\n\nAdditionally, you need an init function, This should create a new Heap object that will be maintained by the class.\n\nIn order to make an iterator, you'll need to make a new class. It will need to maintain an integer variable (let's call it ```\nself.index```\n), indicating its current place in the queue. You'll also want a method that increases ```\nself.index```\n and returns the value that was at the previous index location. That should be about it.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Generics and ArrayList to implement a priority queue\r\n                \r\nI am stuck on an assignment which includes generics and ```\nArrayList```\n. The assignment is to implement a priority queue capable of holding objects of an arbitrary type ```\nT```\n by defining a priority queue class that implements the queue with an ```\nArrayList```\n.\n\nThe method to be supported is ```\nAdd(item, priority)```\n\n\nAnd depending on the priority ```\nremove()```\n removes the highest item in the priority list.\n\nI created the Generic Class with the type being ```\nT```\n, declared ```\nprivate T data```\n. Used multiple constructors to set data. Now I am stuck on how to use this class and Use ```\nArrayList```\n, as I am not sure you can ```\nadd(string, integer)```\n in an ```\nArrayList```\n let alone iterate through it.\n\nAny tips and ideas on how to approach this homework will be greatly appreciated.\n    ", "Answer": "\r\nYou simply need to wrap the data and its priority inside another object, only used internally by your PriorityQueue (just like a LinkedList uses nodes that wrap the data and a pointer to the next node).\n\nSo ```\npriorityQueue(T data, int priority)```\n would end up being implemented as \n\n```\nNode node = new Node(data, priority);\n// find the position where the node must be inserted\narrayList.add(position, node);\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement a priority queue using only ONE stack\r\n                \r\nImplementing a queue or a priority queue using two stacks are not hard.\n\nNow the questions are \n\n\nHow about using only ONE stack to implement a priority queue?\nHow about using only ONE stack to implement a normal queue?\n\n\nAre they even possible?\n\np.s. of course you should use ```\nconstant```\n extra space other than ONE stack if necessary\n    ", "Answer": "\r\nNo, it's not possible using only methods provided through a stack interface (i.e. using only push and pop methods) with constant extra space. [1]\n\nConsider trying to simulate a queue using a stack.\n\nWhen enqueueing, if we simply push onto the stack, we'll end up with another element we need to do something with to get to the front of the queue for a dequeue. It's easy to see that a bunch of enqueues will make it impossible for the next dequeue to take a constant amount of space, as all these enqueued elements need to be popped to get to the front of the queue. We could also put the enqueued element a constant number of elements from the top of the stack, but this doesn't really help much either - the elements below it will need to be dequeued first, so we run into the same problem. Trying to put the enqueued element further than a constant number of elements from the top of the stack will of course take more than a constant amount of space already.\n\nNow consider a priority queue where each new item has lower priority than all items already in the queue. This is synonymous to a simply queue, which, from the above argument, can't be simulated using a single stack with constant space.\n\n[1]: If the stack was implemented as an array or linked-list, as it typically is, it would of course be possible using the functionality for those, but I'm sure that's not what you're asking.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Database based Priority Queue\r\n                \r\ndoes anyone know of a good database based Priority Queue implementation?\n\nI'm dealing with large amounts of data so keeping it all in memory is unfeasible.\n\nThanks!\n    ", "Answer": "\r\nMaybe you want a Message Queue?\n\nThere are several good ones, both proprietary and open source.  For a simple API, check memcacheq, for a more complete, high-performace, take a look at RabbitMQ\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "nullpointerexception while implementing priority queue with nodes [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        What is a NullPointerException, and how do I fix it?\r\n                            \r\n                                (12 answers)\r\n                            \r\n                    \r\n                Closed 6 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am getting the error ```\njava.lang.NullPointerException```\n while implementing priority queue with nodes. Does anyone have a solution without using built in ```\npriorityqueue```\n class?\n\n```\nclass node {                          //NODE CLASS\n\n    public String ch;\n    public int freq;\n    node right_child, left_child;\n\n    public node(String ch, int freq) {\n        this.ch = ch;\n        this.freq = freq;\n\n    }\n\n    public String get_char() {\n        return ch;\n    }\n\n    public int get_freq() {\n        return freq;\n    }\n\n}\n\n//END NODE CLASS\nclass priority_queue {\n\n    private final int size;\n    private final node[] q_array;\n\n    private int no_items = 0;\n\n    public priority_queue(int max) {\n        this.size = max;\n        q_array = new node[size];\n    }\n\n    public void insert(node item) {\n        int j;\n        if (no_items == 0) {\n            q_array[++no_items] = item;\n            System.out.println(\"first item\");\n        } else {\n            for (j = no_items - 1; j >= 0; j--) {\n                if (item.get_freq()> q_array[j].get_freq()) {\n                    q_array[j + 1] = q_array[j];\n\n                } else {\n                    break;\n                }\n\n            }\n            q_array[j] = item;\n            no_items++;\n        }\n    }\n\n    public node remove() {\n        return q_array[--no_items];\n\n    }\n\n    public void process() {\n        node first, second;\n        int new_freq;\n        while (q_array.length > 1) {\n            new_freq = 0;\n            first = this.remove();\n            //f1 = first.freq;\n            second = this.remove();\n            //f2=second.freq;\n\n            new_freq = first.get_freq() + second.get_freq();\n            node new_node = new node(\"*\", new_freq);\n            new_node.left_child = first;\n            new_node.right_child = second;\n            this.insert(new_node);\n\n        }\n\n    }\n```\n\n    ", "Answer": "\r\nYou don't add anything to ```\nq_array[0]```\n. When no_items is 0 you're increasing it first and then insert the element with 1 position. That is how ```\nq_array[++no_items]```\n works.\nHence you have NPE in ```\nq_array[j].get_freq()```\n for the second insertion.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Comparator class implementation for priority queue used in Dijkstra's Algorithm?\r\n                \r\nI'm trying to implement Dijsktra's Algorithm from CLRS - Introduction to Algorithms book,however, i'm having trouble about implementing a priority queue with ```\nComparator```\n interface. This is my Vertex class as you can see;\n\n```\npublic class Vertex {\n\n    public boolean explored;\n    public int vertexID;\n    public LinkedList<Vertex> adjacencyList;\n    public LinkedList<Edge> edgeSet;\n    public int shortestDistance;\n    public Vertex predecessor;\n\n    public Vertex(int vertexID){\n\n        this.vertexID = vertexID;\n        this.explored = false;\n        this.adjacencyList = new LinkedList<>();\n        this.edgeSet = new LinkedList<>();\n        this.shortestDistance = Integer.MAX_VALUE;\n        this.predecessor = null;\n    }\n}\n```\n\n\nSo initially ```\nshortestDistance```\n attribute is declared to ```\nInteger.MAX_VALUE```\n. Furthermore, you can see the class which implements from Comparator, is used for priority queue.\n\n```\npublic class WeightComparator implements Comparator<Vertex> {\n\n    @Override\n    public int compare(Vertex o1, Vertex o2) {\n\n        return Math.min(o1.shortestDistance, o2.shortestDistance);\n    }\n}\n```\n\n\nI'm sure that the whole implementation doesn't have any logical errors due to my some tests,however, in some tests it fails. I create a reference to my queue with this statement\n\n```\nPriorityQueue<Vertex> queue = new PriorityQueue<>(N, weightComparator);```\n\n\nwhere N is the size of the queue. So please correct me if i'm wrong about the way how it works. When you ```\npoll```\n an item from it, it will remove the item which has least priority ?. Hope it had been clear to understand my problem, and i will appreciate a lot if anyone can help about this. So thanks anyway\n    ", "Answer": "\r\n```\nMath.min```\n gives you the smaller of two values. Returning that as a compare value is wrong.\n\nA ```\ncompare```\n return value of <0 means the first value is smaller than the second, but if you return ```\nMath.Min(5, 3)```\n, you will get 3, which is >0, which means that the comparator will tell it that 3 > 5. Which is wrong.\n\nWhat you are looking for is:\n\n```\npublic int compare(Vertex o1, Vertex o2) {\n    return Integer.compare(o1.shortestDistance, o2.shortestDistance);\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue implementation using a Heap, should I do it through inheritance?\r\n                \r\nHere is my issue, I'm working on a custom implementation of AStar and so I had to also create a Priority Queue and so I had to create a Heap. I'm quite happy with my Heap but I'm a bit worried about my Priority Queue, it is done, it works but I am still wondering if the way I have done it will come back and bite me in the ass later.\nHere is the code for my abstract PriorityQueue class:\n```\n    public abstract class PriorityQueueAbstract<T, TPriority>\n    {\n        HeapAbstract<Tuple<T, TPriority>> heap;\n        protected PriorityQueueAbstract(HeapAbstract<Tuple<T, TPriority>> heapImplementation) => heap = heapImplementation;\n        public void Enqueue(T item, TPriority priority) => heap.Insert(new Tuple<T, TPriority>(item, priority));\n        public T Dequeue() => heap.Extract().Item1;\n    }\n```\n\nAnd here is how I make a concrete class out of it:\n```\n    public class MinPriorityQueue<T, TPriority> : PriorityQueueAbstract<T, TPriority> where TPriority : IComparable\n    {\n        public MinPriorityQueue() : base(new Heap<Tuple<T, TPriority>>(new T2Comparer<T, TPriority>())) { }\n    }\n```\n\nI have a version of Heap that works using a Comparer implementation as a parameter, which is why I'm instantiating a Tuple comparer and why TPriority needs to be an IComparable(\"T2Comparer\", maybe I should give it a better name, I take suggestions).\nBut I could also setup my Priority Queue this way:\n```\n    public abstract class PriorityQueueAbstract<T, TPriority> : HeapAbstract<Tuple<T, TPriority>>\n    {\n        public void Enqueue(T item, TPriority priority) => Insert(new Tuple<T, TPriority>(item, priority));\n        public T Dequeue() => Extract().Item1;\n    }\n```\n\nAnd have the concrete class be:\n```\n    public class MinPriorityQueue<T, TPriority> : PriorityQueueAbstract<T, TPriority> where TPriority : IComparable\n    {\n        protected override int Compare(Tuple<T, TPriority> firstItem, Tuple<T, TPriority> secondItem)\n        {\n            return firstItem.Item2.CompareTo(secondItem.Item2);\n        }\n    }\n```\n\nThe second option implements a Compare method because that's how my Heap is implemented.\nI feel like the second option is more clear and easy to understand, extend etc. But my issue is that since it directly implements a Heap, you have access to its Insert and Extract methods on top of the Queue and Dequeue. I could hide them but I feel like that would be an ugly way to solve this.\nI should also explain that I don't have access to the latest versions of NET if it wasn't clear.\nWhat should I do in this case? What are the best practices? Is there a better way to do this?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to update elements within a heap? (priority queue)\r\n                \r\nWhen using a min/max-heap algorithm, priorities may change. One way to handle this is to removal and insert the element to update the queue order.\n\nFor priority queues implemented using arrays, this can be a performance bottleneck that seems avoidable, especially for cases when the change to priority is small.\n\nEven if this is not a standard operation for a priority queue, this is a custom implementation which can be modified for my needs.\n\nAre there well known best-practice methods for updating elements in the min/max-heap?\n\n\n\nBackground Info: I'm no expert in binary-trees, I inherited some code that has a performance bottleneck re-inserting elements in a priority queue. I've made a re-insertion function for the min-heap that re-orders the new element - which gives a measurable improvement over (remove & insert), however this seems the kind of problem that others may have solved in a more elegant way.\n\nI could link to the code if it helps but would rather not focus too much on implementation details - since this Q&A can probably be kept general.\n    ", "Answer": "\r\nTypical Solution\nThe usual solution is to mark an element as invalid and insert a new element, then eliminate the invalid entries as they are popped-off.\nAlternative Solution\nIf that approach doesn't suffice, it is possible restore the min-heap invariant in O(log n) steps as long as the location of the value being changed is known.\nRecall that min-heaps are built and maintained using two primitives, \"siftup\" and \"siftdown\" (though various sources have differing opinions on which is up and which is down).  One of those pushes values down the tree and the other floats them upward.\nCase 1: Value is increased\nIf the new value x1 is greater than the old value x0, then only the tree under x needs to be fixed because ```\nparent(x) <= x0 < x1```\n.  Just push x down the tree by swapping x with the smaller of its two children while x is bigger than one of its children.\nCase 2: Value is decreased\nIf the new value x1 is less than the old value x, the tree below x needs no adjustment because ```\nx1 < x0 <= either_child(x)```\n.  Instead, we just need to move upward, swapping x with its parent while x is less than its parent.  Sibling nodes need not be considered because they are already greater than or equal to a parent which will potentially be replaced with a lower value.\nCase 3:  Value is unchanged\nNo work is necessary.  The existing invariants are unchanged.\nWorking code in Python\nTest 1,000,000 trials:  Create a random heap.   Alter a randomly selected value.  Restore the heap condition.  Verify that the result is a min-heap.\n```\nfrom heapq import _siftup, _siftdown, heapify\nfrom random import random, randrange, choice\n\ndef is_minheap(arr):\n    return all(arr[i] >= arr[(i-1)//2] for i in range(1, len(arr)))\n\nn = 40\ntrials = 1_000_000\nfor _ in range(trials):\n\n    # Create a random heap\n    data = [random() for i in range(n)]\n    heapify(data)\n\n    # Randomly alter a heap element\n    i = randrange(n)\n    x0 = data[i]\n    x1 = data[i] = choice(data)\n\n    # Restore the heap\n    if x1 > x0:                 # value is increased\n        _siftup(data, i)\n    elif x1 < x0:               # value is decreased\n        _siftdown(data, 0, i)\n\n    # Verify the results\n    assert is_minheap(data), direction\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a stack using a priority queue?\r\n                \r\nA priority queue is used to implement a stack that stores characters.\n\n```\nPush(C)```\n is used to implement ```\nInsert(Q,C,K)```\n where ```\nK```\n is the appropriate key chosen by the implementation.\n\n```\nPop```\n is implemented as ```\nDelete_Min(Q)```\n ,for a sequence of operations in what order must the keys be chosen , strictly decreasing or strictly increasing ?\n    ", "Answer": "\r\nLet me begin by saying that priority queue and stack are two completely different data structures with different uses and applications. One can not always be used to implement the other. \n\nYes, there are instances where a data structure can be defined in terms of another: for example you can create a stack or queue using a linked list (quite trivially actually), however implementing a stack using a priority queue will not always work. Why?\n\nBecause a stack is first in last out. The last thing you push on a stack WILL be the first thing to pop out. A stack's sole job is to keep the order of pushed items intact and pop in the reverse order. \n\nA priority queue however, will always give you the minimum (or maximum based on implementation) with a pop. A priority queue will have to -by definition- restructure itself to always maintain the \"heap property\". This means the original order in which you pushed will not necessarily be preserved. \n\nNow, your question should be phrased as \"In what situation will a priority queue and a stack behave the same way?\" \n\nYou mentioned your priority queue ```\npop()```\n will delete the minimum value from your queue which indicates you have a min-heap at hand. In this scenario the only case where a series of pops from priority queue will resemble those that of a stack, would be when the items were all pushed in non-increasing order. It does not have to be strictly decreasing. (think about pushing all of the same values). \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a priority queue using SQS(Amazon simple queue service)\r\n                \r\nI have a situation when a msg fails and I would like to replay that msg with the highest priority using python boto package so he will be taken first. If I'm not wrong SQS queue does not support priority queue, so I would like to implement something simple.\n\nImportant note: when a msg fails I no longer have the message object, I only persist the receipt_handle so I can delete the message(if there was more than x retries) / change timeout visibility in order to push him back to queue.\n\nThanks!\n    ", "Answer": "\r\nI don't think there is any way to do this with a single SQS queue.  You have no control over delivery of messages and, therefore, no way to impose a priority on messages.  If you find a way, I would love to hear about it.\n\nI think you could possibly use two queues (or more generally N queues where N is the number of levels of priority) but even this seems impossible if you don't actually have the message object at the time you determine that it has failed.  You would need the message object so that the data could be written to the high-priority queue.\n\nI'm not sure this actually qualifies as an answer 8^)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Please describe how to use a priority queue to implement a queue\r\n                \r\nI don't understand this question....\n\nPlease describe how to use a priority queue to implement a queue.\n\nDo I simply assign the priority as the time of entrance? and since a queue is fifo I would min prioritize so the oldest time comes first?\n    ", "Answer": "\r\nUsing the time as the priority key is one way to do it. Be careful, though, to use a time that doesn't change externally. You wouldn't want to be using local time when it comes time to set your clocks back an hour during the Daylight Saving Time switch.\n\nYou could also start an integer counter at 0, and increment it with every item you add to the queue.\n\nIn theory, you could just give every item equal priority, but in practice that might end up acting like a stack. It depends on how your priority queue implementation treats equal items. If the implementation is a binary heap, for example, it could insert the equal item as the new smallest item. So you'd end up with LIFO.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue that utilizes BST -- DeleteLargest doesn't work\r\n                \r\nI am creating a priority queue that utilizes a binary search tree for my Data Structures class.  But when I attempt to output the queue I always get 0.  I have looked over my DeleteLargest and Dequeue member function but I can't find the mistake\n\nTest.cpp\n\n```\n#include <iostream>\n#include \"CTree.h\"\n#include \"PriorityQueueBST.h\"\nusing namespace std;\n\nint main()\n{\n\n    int num, input, output;\n    cout << \"Enter number of elements: \";\n    cin >> num;\n    PriorityQueueBST p;\n    for (int x = 0; x < num; x++)\n    {\n        cout << \"Enter number \" << x + 1  \n            << \" of \" << num << \": \";\n        cin >> input;\n        p.Enqueue(input);\n    }\n    for (int y = 0; y < num; y++)\n    {\n        cout << \"Outputting number \" << y + 1  \n            << \" of \" << num << \": \";\n        if(p.IsEmpty())\n        {\n            break; //we are done (this is an error!)\n        }\n        output = p.Dequeue();\n        cout << output << endl;\n    }\n\n    system(\"pause\");\n    return 0;\n    //CTree* tr = new CTree();\n    //\n    //for (int i = 0; i < 3; i++)\n    //  tr->Add();\n\n    //tr->View();\n    //system(\"pause\");\n\n\n    //return 0;\n}\n```\n\n\nBST Declaration file\n\n```\n//#ifndef CTREE_H\n//#define CTREE_H\n//using namespace std;\n\nstruct TreeNode\n{\n    int info;\n    TreeNode* leftLink;\n    TreeNode* rightLink;\n};\n\n\nclass CTree\n{\n\nprivate:\n\n\n    void AddItem( TreeNode*&, TreeNode*);\n    void DisplayTree(TreeNode*);\n    void Retrieve(TreeNode*&, TreeNode*,bool&);\n    void Destroy(TreeNode*&);\n\npublic:\n    CTree();\n    ~CTree();\n    void Add();\n    void View();\n    bool IsEmpty();\n    int DeleteLargest(TreeNode*&);\n    TreeNode *tree;\n};\n\n\n//#endif\n```\n\n\nBST Implementation file\n\n```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#include \"CTree.h\"\n\nCTree::CTree()\n{\n    tree = NULL;\n}\n\nCTree::~CTree()\n{\n    Destroy(tree);\n}\n\nvoid CTree::Destroy(TreeNode*& tree)\n{\n    if (tree != NULL)\n    {\n    Destroy(tree->leftLink);\n    Destroy(tree->rightLink);\n    delete tree;\n    }\n}\n\n\nbool CTree::IsEmpty()\n{\n    if(tree == NULL) \n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nvoid CTree::Add()\n{\n    TreeNode* newPerson = new TreeNode();\n    /*cout << \"Enter the person's name: \";\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n    cin.getline(newPerson->name, 20);*/\n   /* cout << \"Enter the person's contribution: \";\n    cin >> newPerson->info;*/\n    /*bool found = false;*/\n\n\n    newPerson->leftLink = NULL;\n    newPerson->rightLink = NULL;\n\n    /*Retrieve(tree, newPerson, found);\n     if (found)\n         cout << \"info allready entered\\n\";\n     else*/\n         AddItem(tree, newPerson);\n}\n\nvoid CTree::View()\n{\n    if (IsEmpty())\n    {\n        cout<<\"The list is empy\";\n    }\n    else\n    {\n        DisplayTree(tree);\n\n    }\n\n};\n\nvoid CTree::AddItem( TreeNode*& ptr, TreeNode* newPer )\n{\n        if (ptr == NULL)\n        {\n            ptr = newPer;\n        }\n        else if ( newPer->info < ptr->info)\n            AddItem(ptr->leftLink, newPer); \n        else\n            AddItem(ptr->rightLink, newPer); \n}\nvoid CTree::DisplayTree(TreeNode* ptr)\n{\n    if (ptr == NULL)\n                    return;\n    DisplayTree(ptr->rightLink);\n    cout << ptr->info << endl; //cout<<ptr->name<<\" \"<<\"$\"<<ptr->info <<endl;\n    DisplayTree(ptr->leftLink); \n}\nvoid CTree::Retrieve(TreeNode*& ptr, TreeNode* newPer, bool& found)\n{\n    {\n        if (ptr == NULL)\n        {\n            found = false; // item is not found.\n        }\n        else if ( newPer->info < ptr->info)\n        {\n            Retrieve(ptr->leftLink, newPer, found);\n        }\n             // Search left subtree.\n        else if (newPer->info > ptr->info)\n        {\n            Retrieve(ptr->rightLink, newPer, found);// Search right subtree.\n        }   \n        else\n        {\n            //newPer.info = ptr->info; // item is found.\n            found = true;\n        }\n    }\n}\n\nint CTree::DeleteLargest(TreeNode*& tr)\n{\n    int largest = 0;;\n    TreeNode* prev;\n    TreeNode* cur;\n    prev = NULL;\n    cur = tr;\n\n    if (tr == NULL)\n    {\n        cout <<  \"The tree is empty\"<<endl;\n    }\n    else if (tr->rightLink == NULL)\n    {\n        largest = tr->info;\n    }\n    else\n    {\n        prev = tr;\n        tr = tr->rightLink;\n        DeleteLargest(tr);\n    }\n\n    return largest;\n}\n```\n\n\nPriority Queue Declaration\n\n```\n//#include <iostream>\n//using namespace std;\n//#include \"SortedLinkedList.h\"\n\n#ifndef PRIORITYQUEUESLL__H\n#define PRIORITYQUEUESLL__H\n\nclass PriorityQueueBST\n{\n    public:\n        PriorityQueueBST();\n        ~PriorityQueueBST();\n        void Enqueue(int);\n        int Dequeue();\n        bool IsEmpty();\n\n    private:\n        CTree* ourTree;\n        //sslNode* head;\n};\n\n#endif\n```\n\n\nPriority Queue Implementation \n\n```\n#include <iostream>\nusing namespace std;\n#include \"CTree.h\"\n#include \"PriorityQueueBST.h\"\n\nPriorityQueueBST::PriorityQueueBST()\n{\n    ourTree = new CTree();\n    //head = NULL;\n}\n\nPriorityQueueBST::~PriorityQueueBST()\n{\n\n}\n\nvoid PriorityQueueBST::Enqueue(int dataToEnter)\n{\n    ourTree->Add();\n}\n\nint PriorityQueueBST::Dequeue()\n{\n    //check for empty??\n    return ourTree->DeleteLargest(ourTree->tree);\n}\n\nbool PriorityQueueBST::IsEmpty()\n{\n    return ourTree->IsEmpty();\n\n}\n```\n\n    ", "Answer": "\r\nYour output is always 0 because in\n\n```\nint CTree::DeleteLargest(TreeNode*& tr)\n{\n    int largest = 0;;\n    TreeNode* prev;\n    TreeNode* cur;\n    prev = NULL;\n    cur = tr;\n\n    if (tr == NULL)\n    {\n        cout <<  \"The tree is empty\"<<endl;\n    }\n    else if (tr->rightLink == NULL)\n    {\n        largest = tr->info;\n    }\n    else\n    {\n        prev = tr;\n        tr = tr->rightLink;\n        DeleteLargest(tr);\n    }\n\n    return largest;\n}\n```\n\n\nyou only set ```\nlargest```\n to something potentially ```\n!= 0```\n if ```\ntr->rightlink```\n is ```\nNULL```\n. Otherwise you recur and set the ```\nlargest```\n variable local to another invocation of the function. That change is lost when the recursion goes up again, and in the topmost invocation, ```\nlargest```\n is still 0.\n\nIn the last line of the ```\nelse```\n branch, you should either\n\n```\nlargest = DeleteLargest(tr);\n```\n\n\nor\n\n```\nreturn DeleteLargest(tr);\n```\n\n\nAnother problem is that, despite its name, ```\ndeleteLargest```\n doesn't actually delete anything, so with the above, you would still always get the same value.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Comparing attribute of an object in implementation of priority queue\r\n                \r\nI've attempted to implement a priority queue using an Array of Objects \"Queue Items\" which have some data (a string), and an integer which is the priority. I am trying to make those items comparable so that when I add a new object to the queue I can iterate through the items and add the new item in the correct location and move all items that are now behind it backwards, however when I add a new item to the queue I get a null pointer exception. I'll include all my code, but the toString method was just copied in from a queue so it won't work as expected.\n\n```\nclass QueueItem implements Comparable<QueueItem> {\n    String data;\n    int pri;\n\n    public QueueItem(String data, int pri) {\n        this.data = data;\n        this.pri = pri;\n    }\n\n    @Override\n    public int compareTo(QueueItem item) {\n        return this.data.compareTo(item.data);\n    }\n}\n\npublic class PriorityQueue implements Queue<String> {\n    private QueueItem[] arr;\n    private int frontPos, backPos;\n\n    public PriorityQueue() {\n        arr = new QueueItem[20];\n        backPos = -1;\n        frontPos = 0;\n    }\n\n    public boolean isEmpty() {\n        return frontPos == (backPos + 1) % arr.length;\n    }\n\n    public String front() {\n        if (frontPos == (backPos + 1) % arr.length)\n            throw new QueueException(\"Empty Queue - front\");\n        return arr[frontPos].data;\n    }\n\n    public int frontPri() {\n        if (frontPos == (backPos + 1) % arr.length)\n            throw new QueueException(\"Empty Queue - frontPri\");\n        return arr[frontPos].pri;\n    }\n\n    public void addToPQ(String str, int x) {\n        if (arr.length==0) {\n            arr[frontPos] = new QueueItem(str, x);\n            frontPos++;\n            return;\n        }\n        else {\n            for (int i = 0; i < arr.length; i++) {\n                arr[i].compareTo(new QueueItem(str, x));\n            }\n        }\n    }\n\n    public void deleteFront() {\n        if (frontPos==(backPos+1)%arr.length) {\n            throw new QueueException(\"Empty Queue - deleteFront\");\n        }\n        frontPos = (frontPos+1)%arr.length;\n    }\n\n    public String toString() {\n        if (frontPos == (backPos + 1) % arr.length) {\n            return \"<>\";\n        }\n        StringBuffer sb = new StringBuffer();\n\n        sb.append('<');\n\n        int pos = frontPos;\n        while (pos != backPos) {\n            sb.append(arr[pos]);\n            sb.append(',');\n            pos = (pos + 1) % arr.length;\n        }\n\n        sb.append(arr[backPos]);\n        sb.append('>');\n\n        return (sb.toString());\n    }\n}\n\npublic interface Queue<String> {\n    public void addToPQ(String str, int x);\n\n    public void deleteFront();\n\n    public String front();\n\n    public boolean isEmpty();\n\n    public int frontPri();\n}\n\nclass QueueException extends RuntimeException {\n    QueueException(String s) {\n        super(\"Tried to apply \" + s + \" to empty queue\");\n    }\n}\n\npublic class pqTest {\n    public static void main(String[] args) {\n        PriorityQueue pQ = new PriorityQueue();\n        if (pQ.isEmpty()) {\n            System.out.println(\"Queue is Empty - isEmpty\");\n        }\n        pQ.addToPQ(\"Dog\", 4);\n        pQ.addToPQ(\"Cat\", 20);\n        pQ.deleteFront();\n        pQ.addToPQ(\"Fish\", 2);\n    }\n}\n```\n\n    ", "Answer": "\r\nThe problem is that ```\narr```\n is size 20 so the first element won't even be added through the if statement in your ```\naddToPQ```\n method because ```\narr.length != 0```\n. So it will then go to your else statement, which iterates through every single element in ```\narr```\n. But ```\narr```\n has 20 null elements since each spot within the array of QueueItems has not been initialized. So you should change your condition in the if statement to ```\nfrontPos == 0```\n and change the terminating condition in your loop to ```\ni < frontPos```\n so that the method won't iterate through null elements within ```\narr```\n\n\n```\npublic void addToPQ(String str, int x) {\n        if (frontPos==0) {\n            arr[frontPos] = new QueueItem(str, x);\n            frontPos++;\n            return;\n        }\n        else {\n            QueueItem item = new QueueItem(str, x);\n            for (int i = 0; i < frontPos; i++) {\n                arr[i].compareTo(item);\n            }\n        }\n    }\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Trouble implementing priority queue Java\r\n                \r\nI currently have an issue with my priority queue. When i'm testing my methods the I get an error saying my Queue isn't returning the highest priority. I have stepped through and I can't see why the Poll or Offer method is causing this issue. Any help would be appreciated. Thanks\n\n```\npublic class HeapArrayQueue <E extends Comparable<? super E> > extends AbstractQueue <E> { \n\n@SuppressWarnings(\"unchecked\") \nprivate E[] data = (E[])(new Comparable[7]);\nprivate int count = 0;\nprivate int front = 0;\npublic int size() {\n    return count;\n}\n\npublic boolean isEmpty() { \n    return size() == 0; \n}\n\npublic E poll() {\n     if (isEmpty())\n        return null;\n    else {\n        E ans = data[front ];\n        front = (front+1);       \n        return ans;\n    }\n}\n\n\npublic boolean offer(E element) {\n    if (element == null)return false;\n    else {\n        ensureCapacity();\n        data[count] = element;\n        bubbleUpFromIndex(count);\n        count++;\n        return true;\n    }\n}\n\nprivate void bubbleUpFromIndex(int nodeIndex) {\n     if (nodeIndex != 0){\n         int parent = (nodeIndex -1) / 2;\n         if (data[nodeIndex].compareTo(data[parent]) > 0){\n             swap(nodeIndex, parent);\n             bubbleUpFromIndex(parent);\n         }\n    }\n}\n\nprivate void swap(int from, int to) {\n    E temp = data[from];\n    data[from] = data[to];\n    data[to] = temp;\n}\n\nprivate void ensureCapacity() {\n    if (count == data.length) {\n        @SuppressWarnings(\"unchecked\") \n        E[] newData = (E[])new Comparable[data.length * 2];\n\n        for (int loop = 0; loop < count; loop++) {\n            newData[loop] = data[loop];\n        }\n        data = newData;\n    }\n    return;\n}\n\npublic Iterator<E> iterator() { \n    return null; \n}\n}\n```\n\n\nFailing test\n\n```\n@Test\npublic void QueueRespectsPriority() {\n    nonEmptyQueue.offer(t1);\n    assertEquals(\"Queue should return element with highest priority\", t1, nonEmptyQueue.poll());\n}\n```\n\n    ", "Answer": "\r\nDoing comp103 at vic I take it? looks very similar to what I'm doing at the moment.\n\nThe first thing I can see is that you're not preserving the correct priority in poll. Here (in pseudocode is my method)\n\n```\npublic E poll(){\nif (count = 0) return null\nE item = root   // We are returning the root node so store it as a var\nroot = end      // place the end item in root position\nend = null      // set end item to null\ncount--         // subtract count\nsinkDown(0)     // Call sink down to restore ordering\nreturn item     // return item\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Python Implementing a Priority Queue [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        A generic priority queue for Python\r\n                            \r\n                                (13 answers)\r\n                            \r\n                    \r\n                Closed 9 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am trying to make a priority queue without using the Queue module. I have made a class PriorityQueue() and I am trying to create a mk function that takes no arguments and returns an empty queue but can't seem to figure out how. my task function is here:\n\n```\nclass Task():\n\n    __slots__ = ('name', priority)\n\ndef mkTask(myName, myPriority):\n    t = Task()\n    t.name = myName\n    t.priority = myPriority\n    return t\n```\n\n\nWhat I have so far for my PriorityQueue class and a function to check if the queue is empty is this:\n\n```\nclass PriorityQueue():\n    def __init__(queue):\n        queue.length = 0\n        queue.first = None\n        queue.last = None\n\ndef is_empty(queue):\n    return(queue.length == 0)\n```\n\n\nI can't seem to figure out how to create an instance of the Queue and insert elements of a specific Task into the Queue.\n    ", "Answer": "\r\nA priority queue is often implemented using a heap, and here's such an implementation. Note, that the heap implementation in Python returns the smallest thing in the heap, so I negate the priority so that highest priority things get popped first.\n\n```\nimport heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.items = []\n\n    def push(self, priority, x):\n        heapq.heappush(self.items, (-priority, x))\n\n    def pop(self):\n        _, x = heapq.heappop(self.items)\n        return x\n\n    def empty(self):\n        return not self.items\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why is the Dijkstra Implementation working even if I use Simple Queue instead of priority queue?\r\n                \r\nI tried implementing Dijkstra using normal queue and whenever I relax edge I add that vertex to the queue here is the implementation in java\n```\nimport java.util.*;\n\npublic class Main \n{\n    static HashMap<Integer, List<Edge>> graph = new HashMap<>();\n    public static void main(String[] args)\n    {\n        graph.put(0, (List<Edge>)Arrays.asList(new Edge[]{\n            new Edge(0, 1, 5),\n            new Edge(0, 2, 2),\n        }));\n        graph.put(1, (List<Edge>)Arrays.asList(new Edge[]{\n            new Edge(1, 3, 1),\n        }));\n        graph.put(2, (List<Edge>)Arrays.asList(new Edge[]{\n            new Edge(2, 1, 1),\n            new Edge(2, 3, 7),\n        }));\n        graph.put(3, (List<Edge>)Arrays.asList(new Edge[]{}));\n        Integer[] dist = dijkstra(graph, graph.size(), 0);\n        for(int i = 0;i < dist.length;i++)\n        {\n            System.out.print(\" \" + dist[i]);\n        }\n    }\n    public static Integer[] dijkstra(HashMap<Integer, List<Edge>> graph, int numNodes, int start)\n    {\n        Integer[] dist = new Integer[numNodes];\n        for(int i = 0; i < dist.length;i++)\n        {\n            dist[i] = Integer.MAX_VALUE;\n        }\n\n        LinkedList<Integer> queue = new LinkedList<Integer>();\n\n        dist[start] = 0;\n        queue.add(start);\n        while(queue.size()!=0)\n        {\n            Integer current = queue.poll();\n            List<Edge> edges = graph.get(current);\n            for(Edge e : edges)\n            {\n                if(dist[e.from] + e.weight < dist[e.to])\n                {\n                    dist[e.to] = dist[e.from] + e.weight;\n                    queue.add(e.to);\n                }\n            }\n        }\n\n        return dist;\n    }\n}\n\nclass Edge\n{\n    int from, to, weight;\n    Edge(int from, int to, int weight)\n    {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n    }\n}\n\n```\n\nas you can see i am adding vertex to queue whenever there is relaxation.\nMy queustion is that is this correct Implementation, i mean will it work in all cases? and what drawbacks it has over priority queue?\n    ", "Answer": "\r\nProbably you should be good; not using a priority queue will only affect efficiency.\nWikipedia:\n\nWhile the original algorithm uses a min-priority queue and runs in time Θ((V+E)logV) (where V is the number of nodes and E is the number of edges), it can also be implemented in Θ(V2) using an array.\n\nand\n\nBreadth-first search can be viewed as a special-case of Dijkstra's algorithm on unweighted graphs, where the priority queue degenerates into a FIFO queue.\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do I implement a minimum priority queue\r\n                \r\nI already know priority queues are implemented by default as max_priority queues in C++. \nBut how to make a min priority queue, rather than storing negetive of each number.\nPlease help , I am unable to find the syntax , and if able to find any syntax unable to use it and understand it :(.\n    ", "Answer": "\r\nhttp://www.cplusplus.com/reference/queue/priority_queue/\n\nUse the constructor that allows you to pass your own compare object.\n\n\n  template < class T, class Container = vector,\n             class Compare = less > class priority_queue\n  \n  Compare: Comparison class: A class such that the expression comp(a,b), where comp is an object of this class and a and b are elements of the container, returns true if a is to be placed earlier than b in a strict weak ordering operation. This can either be a class implementing a function call operator or a pointer to a function. This defaults to less, which returns the same as applying the less-than operator (a\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority queue in C++?\r\n                \r\nI am implementing a train boarding system using priority queue. I have the working code but I need to make the following changes..\n\nThe priority levels will be : High, Medium and Low. So the passenger should input his/her name and the priority level. The train can have up to 30 passengers.\nIn the end I will sort the passengers accordingly... Here what I have so far my problem is taking strings as arguments instead of the integers I have now.\n\n```\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n#define High 1\n#define Medium 2\n#define Low 3\n/*\n* Node Declaration\n*/\nstruct node\n{\n    int priority;\n    int info;\n    struct node *link;\n};\n/*\n* Class Priority Queue\n*/\nclass Priority_Queue\n{\nprivate:\n    node *front;\npublic:\n    Priority_Queue()\n    {\n        front = NULL;\n    }\n    /*\n    * Insert into Priority Queue\n    */\n    void insert(int item, int priority)\n    {\n        node *tmp, *q;\n        tmp = new node;\n        tmp->info = item;\n        tmp->priority = priority;\n        if (front == NULL || priority < front->priority)\n        {\n            tmp->link = front;\n            front = tmp;\n        }\n        else\n        {\n            q = front;\n            while (q->link != NULL && q->link->priority <= priority)\n                q = q->link;\n            tmp->link = q->link;\n            q->link = tmp;\n        }\n    }\n    /*\n    * Delete from Priority Queue\n    */\n    void del()\n    {\n        node *tmp;\n        if (front == NULL)\n            cout << \"Queue Underflow\\n\";\n        else\n        {\n            tmp = front;\n            cout << \"Deleted item is: \" << tmp->info << endl;\n            front = front->link;\n            free(tmp);\n        }\n    }\n    /*\n    * Print Priority Queue\n    */\n    void display()\n    {\n        node *ptr;\n        ptr = front;\n        if (front == NULL)\n            cout << \"Queue is empty\\n\";\n        else\n        {\n            cout << \"Queue is :\\n\";\n            cout << \"Priority       Item\\n\";\n            while (ptr != NULL)\n            {\n                cout << ptr->priority << \"                 \" << ptr->info << endl;\n                ptr = ptr->link;\n            }\n        }\n    }\n};\n/*\n* Main\n*/\nint main()\n{\n    int choice, item, priority;\n    Priority_Queue pq;\n    do\n    {\n        cout << \"1.Insert\\n\";\n        cout << \"2.Delete\\n\";\n        cout << \"3.Display\\n\";\n        cout << \"4.Quit\\n\";\n        cout << \"Enter your choice : \";\n        cin >> choice;\n        switch (choice)\n        {\n        case 1:\n            cout << \"Input the item value to be added in the queue : \";\n            cin >> item;\n            cout << \"Enter its priority : \";\n            cin >> priority;\n            pq.insert(item, priority);\n            break;\n        case 2:\n            pq.del();\n            break;\n        case 3:\n            pq.display();\n            break;\n        case 4:\n            break;\n        default:\n            cout << \"Wrong choice\\n\";\n        }\n    } while (choice != 4);\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nI would avoid using string values for the queue and just translate plain-text priorities to the respective integer value, think\n\n```\nint ParsePriority(string plainTextPriority)\n{\n    switch(plainTextPriority) {\n        case \"High\": return 1;\n        case \"Medium\": return 2;\n        case \"Low\": return 3;\n    }\n    throw \"Unknown priority class\";\n}\n```\n\n\nYou'll then be able to use the priority values like you did before.\n\n```\ncase 1:\n    cout << \"Input the item value to be added in the queue : \";\n    cin >> item;\n    cout << \"Enter its priority : \";\n    do {\n        string plainTextPriority;\n        cin >> plainTextPriority;\n        try {\n            priority = ParsePriority(plainTextPriority)\n        }\n        catch {\n            priority = 0;\n            cout << \"Could not parse the priority, please enter one of High, Medium, Low\" << endl;\n        }\n    } while (priority == 0);\n    pq.insert(item, priority);\n    break;\n```\n\n\nI added the loop to take the case that a value that does not represent a valid priority has been entered into account.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why does Dijkstra's Algorithm use a heap (priority queue)?\r\n                \r\nI have tried using Djikstra's Algorithm on a cyclic weighted graph without using a priority queue (heap) and it worked.\n\nWikipedia states that the original implementation of this algorithm does not use a priority queue and runs in O(V2) time.\n\nNow if we just removed the priority queue and used normal queue, the run time is linear, i.e. O(V+E). \n\nCan someone explain why we need the priority queue?\n    ", "Answer": "\r\nI had the exact same doubt and found a test case where the algorithm without a priority_queue would not work.\nLet's say I have a Graph object ```\ng```\n, a method ```\naddEdge(a,b,w)```\n which adds edge from vertex ```\na```\n to vertex ```\nb```\n with weight ```\nw```\n.\nNow, let me define the following graph  :-\n```\n   Graph g \n   g.addEdge(0,1,5) ; \n   g.addEdge(1,3,1) ; \n   g.addEdge(0,2,2) ; \n   g.addEdge(2,1,1) ; \n   g.addEdge(2,3,7) ; \n```\n\nNow, say our queue contains the nodes in the following order ```\n{0,1,2,3 }```\n\nSo, node 0 is visited first then node 1 is visited.\nAt this point of time the dist b/w 0 and 3 is computed as 6 using the path ```\n0->1->3```\n, and 1 is marked as visited.\nNow node 2 is visited and dist b/w 0 and 1 is updated to the value 3 using the path ```\n0->2->1```\n, but since node 1 is marked visited, you cannot change the distance b/w 0 and 3 which (using the optimal path) (`0->2->1->3) is 4.\nSo, your algorithm fails without using the priority_queue.\nIt reports dist b/w 0 and 3 to be 6 while in reality it should be 4.\nNow, here is the code which I used for implementing the algorithm :-\n```\n            class Graph\n        {\n            public: \n                vector<int> nodes ; \n                vector<vector<pair<int,int> > > edges ; \n                void addNode() \n                {\n                    nodes.push_back(nodes.size()) ; \n                    vector<pair<int,int> > temp ; edges.push_back(temp);\n                }\n                void addEdge(int n1, int n2, int w)\n                {\n                    edges[n1].push_back(make_pair(n2,w)) ; \n                }\n                pair<vector<int>, vector<int> > shortest(int source) // shortest path djkitra's\n                {\n                    vector<int> dist(nodes.size()) ; \n                    fill(dist.begin(), dist.end(), INF) ; dist[source] = 0 ; \n                    vector<int> pred(nodes.size()) ; \n                    fill(pred.begin(), pred.end(), -1) ; \n                    for(int i=0; i<(int)edges[source].size(); i++)\n                    {\n                        dist[edges[source][i].first] = edges[source][i].second ; \n                        pred[edges[source][i].first] = source  ; \n                    }\n                    set<pair<int,int> > pq ; \n                    for(int i=0; i<(int)nodes.size(); i++)\n                        pq.insert(make_pair(dist[i],i)) ; \n                    while(!pq.empty())\n                    {\n                        pair<int,int> item = *pq.begin() ; \n                        pq.erase(pq.begin()) ; \n                        int v = item.second ; \n                        for(int i=0; i<(int)edges[v].size(); i++)\n                        {\n                            if(dist[edges[v][i].first] > dist[v] + edges[v][i].second)\n                            {\n                                pq.erase(std::find(pq.begin(), pq.end(),make_pair(dist[edges[v][i].first],edges[v][i].first))) ; \n                                pq.insert(make_pair(dist[v] + edges[v][i].second,edges[v][i].first)) ; \n                                dist[edges[v][i].first] = dist[v] + edges[v][i].second ; \n                                pred[i] = edges[v][i].first ; \n                            }\n                        }\n                    }\n                    return make_pair(dist,pred) ; \n                }\n    \n    pair<vector<int>, vector<int> > shortestwpq(int source) // shortest path djkitra's without priority_queue \n            {\n                vector<int> dist(nodes.size()) ; \n                fill(dist.begin(), dist.end(), INF) ; dist[source] = 0 ; \n                vector<int> pred(nodes.size()) ; \n                fill(pred.begin(), pred.end(), -1) ; \n                for(int i=0; i<(int)edges[source].size(); i++)\n                {\n                    dist[edges[source][i].first] = edges[source][i].second ; \n                    pred[edges[source][i].first] = source  ; \n                }\n                vector<pair<int,int> > pq ; \n                for(int i=0; i<(int)nodes.size(); i++)\n                    pq.push_back(make_pair(dist[i],i)) ; \n                while(!pq.empty())\n                {\n                    pair<int,int> item = *pq.begin() ; \n                    pq.erase(pq.begin()) ; \n                    int v = item.second ; \n                    for(int i=0; i<(int)edges[v].size(); i++)\n                    {\n                        if(dist[edges[v][i].first] > dist[v] + edges[v][i].second)\n                        {\n                            dist[edges[v][i].first] = dist[v] + edges[v][i].second ; \n                            pred[i] = edges[v][i].first ; \n                        }\n                    }\n                }\n                return make_pair(dist,pred) ; \n            }\n```\n\nAs expected the results were as follows :-\nWith priority_queue\n0\n3\n2\n4\nNow using without priority queue\n0\n3\n2\n6\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue in R for OPTICS implementation\r\n                \r\nI need to construct a priority queue in R where i will put the ordered seed objects (or the index of the objects) for the OPTICS clustering algorithm.\n\n\nOne possibility is to implement it with heap with the array representation, and pass the heap array in each insert and decrease key call, and return the changed array and reassign it in the calling function. In which case, the reassign operation will make the performance very poor and every time one insert or decrease operation is executed the entire array needs to be copied twice, once for calling, and another once for returning and reassigning.\nAnother possibility is to code the heap operations inside the function instead of calling it. This will result in code repetition and cumbersome code.\nIs there any pointer like access as we do in ```\nC```\n\nCan i declare user defined functions in the S3 or S4 classes in R ? In the the case i think the call to these functions still requires the same reassignment after returning (not like C++/Java classes, operates on the object (am i right?) )\nIs there any builtin way with which i can insert and extract an object in a queue in ```\nO(log(n))```\n time in R?\nIs there any other way with which i can achieve the goal, that is maintain a priority based insertion and removal of the seeds depending on the reachability distance of an object in the OPTICS algorithm, except explicitly sorting after each insertion.\n\n    ", "Answer": "\r\nR5 classes\ndefine mutable objects, and very similar to Java classes:\nthey should allow you to avoid the copies when the object is modified.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to create a generic array in Java?\r\n                \r\nDue to the implementation of Java generics, you can't have code like this: \n\n```\npublic class GenSet<E> {\n    private E a[];\n\n    public GenSet() {\n        a = new E[INITIAL_ARRAY_LENGTH]; // error: generic array creation\n    }\n}\n```\n\n\nHow can I implement this while maintaining type safety?\n\nI saw a solution on the Java forums that goes like this:\n\n```\nimport java.lang.reflect.Array;\n\nclass Stack<T> {\n    public Stack(Class<T> clazz, int capacity) {\n        array = (T[])Array.newInstance(clazz, capacity);\n    }\n\n    private final T[] array;\n}\n```\n\n\nBut I really don't get what's going on.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing Priority Queue in python\r\n                \r\nI'm having a bit of trouble implementing a priority queue in python. Essentially I copied all the code from the heapq implementation documentation, however in my application to recreate the data structure for Dijkstra's algorithm, I would like to update the priorities for each item.\n```\nclass PriorityQueue():\n\n    REMOVED = '<removed-task>'  # placeholder for a removed task\n\n    def __init__(self, arr=None):\n        \n        if arr is None:\n            self.data = []\n        else:\n            self.data = []\n\n        self.entry_finder = {}  # mapping of tasks to entries\n        self.counter = itertools.count()  # unique sequence count\n\n\n    def add_task(self, task, priority=0):\n        'Add a new task or update the priority of an existing task'\n        if task in self.entry_finder:\n            self.remove_task(task)\n        count = next(self.counter)  # Increments count each time item is added ( Saves index ).\n        entry = [priority, count, task]\n        self.entry_finder[task] = entry\n        heapq.heappush(self.data, entry)\n\n\n    def remove_task(self, task):\n        'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n        entry = self.entry_finder.pop(task)\n        entry[-1] = self.REMOVED\n\n\n    def pop_task(self):\n        'Remove and return the lowest priority task. Raise KeyError if empty.'\n        while self.data:\n            priority, count, task = heapq.heappop(self.data)\n            if task is not self.REMOVED:\n                del self.entry_finder[task]\n                return task\n        raise KeyError('pop from an empty priority queue')\n\n\nlist = PriorityQueue()\nlist.add_task(\"A\", 12)\nlist.add_task(\"B\", 6)\nlist.add_task(\"C\", 8)\nlist.add_task(\"D\", 2)\nlist.add_task(\"E\", 1)\nlist.add_task(\"A\", 5)\n\n```\n\nThe following code works fine, except it will add a new task \"A\", and then the old task \"A\" will be renamed to ```\n'removed-task'```\n and keep it's index in the heap. I would prefer to outright delete the original task instead. I was confused as to how calling '''add_task\"\" which calls ```\nremove_task```\n to change the value of '''entry'' was implicitly changing the value of items in ```\nself.data```\n. I then realized that in ```\nadd_task```\n:\n```\n        entry = [priority, count, task]\n        self.entry_finder[task] = entry\n```\n\nwe have these two names interning and referencing the same object. If this is the case, how may I be able to delete an object by it's ID? I think this would solve my problem, unless anyone has another solution to find the item in ```\nself.data```\n and remove it in O(1). Thanks!\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue for Common Lisp?\r\n                \r\nI've been looking everywhere for a priority queue implementation for Common Lisp that works, and so far, I've not had much luck. As I'm fairly new to Common Lisp, whenever I see a huge warning/error dump from the REPL, I'm not really sure what to do about it. This isn't helped by the fact that all the priority queue implementations I've found seem to be really old.\n\nCould someone suggest one to me?\n    ", "Answer": "\r\nA quick search for \"queue\" on http://quickdocs.org turned up a few choices.  I looked at the description and API of ```\npriority-queue```\n and it seems sensible.  You can get it from Quicklisp.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Easiest way of using min priority queue with key update in C++\r\n                \r\nSometimes during programming contests etc., we need a simple working implementation of min priority queue with decrease-key to implement Dijkstra algorithm etc.. I often use set< pair<key_value, ID> > and an array (mapping ID-->key_value) together to achieve that. \n\n\nAdding an element to the set takes O(log(N)) time. To build a priority queue out of N elements, we simply add them one by one into the set. This takes O(N log(N)) time in total.\nThe element with min key_value is simply the first element of the set. Probing the smallest element takes O(1) time. Removing it takes O(log(N)) time.\nTo test whether some ID=k is in the set, we first look up its key_value=v_k in the array and then search the element (v_k, k) in the set. This takes O(log(N)) time.\nTo change the key_value of some ID=k from v_k to v_k', we first look up its key_value=v_k in the array, and then search the element (v_k, k) in the set. Next we remove that element from the set and then insert the element (v_k', k) into the set. We then update the array, too. This takes O(log(N)) time.\n\n\nAlthough the above approach works, most textbooks usually recommend using binary heaps to implement priority queues, as the time of building the binary heaps is just O(N). I heard that there is a built-in priority queue data structure in STL of C++ that uses binary heaps. However, I'm not sure how to update the key_value for that data structure.\n\nWhat's the easiest and most efficient way of using min priority queue with key update in C++?\n    ", "Answer": "\r\nAlthough my response will not answer the original question, I think it could be useful for people who reach this question when trying to implement Dijkstra algorithm in C++/Java (like myself), something that was comment by the OP,\n\n```\npriority_queue```\n in C++ (or ```\nPriorityQueue```\n in Java) do not provide a ```\ndecrease-key```\n operation, as said previously. A nice trick for using those classes when implementing Dijkstra is using \"lazy deletion\". The main loop of Dijkstra algorithm extracts the next node to be processed from the priority queue, and analises all its adjacent nodes, eventually changing the cost of the minimal path for a node in the priority queue. This is the point where ```\ndecrease-key```\n is usually needed in order to update the value of that node.\n\nThe trick is not change it at all. Instead, a \"new copy\" for that node (with its new better cost) is added into the priority queue. Having a lower cost, that new copy of the node will be extracted before the original copy in the queue, so it will be processed earlier.\n\nThe problem with this \"lazy deletion\" is that the second copy of the node, with the higher bad cost, will be eventually extracted from the priority queue. But that will be always occur after the second added copy, with a better cost, has being processed. So the very first thing  that the main Dijkstra loop must do when extracting the next node from the priority queue is checking if the node has being previously visited (and we know the shortest path already). It is in that precise moment when we will be doing the \"lazy deletion\" and the element must be simply ignored.\n\nThis solution will have a cost both in memory and time, because the priority queue is storing \"dead elements\" that we have not removed. But the real cost will be quite small, and programming this solution is, IMHO, easier than any other alternative that tries to simulate the missing ```\ndecrease-key```\n operation.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "A generic priority queue for Python\r\n                \r\nI need to use a priority queue in my Python code, and:\n\n\nam looking for any fast implementations for priority queues\noptimally, I'd like the queue to be generic (i.e. work well for any object with a specified comparison operator).\n\n\nLooking around for something efficient, I came upon heapq, but:\n\n\nI'm looking for something faster than ```\nheapq```\n, which is implemented in native Python, so it's not fast.\nIt looks good, but seems to be specified only for integers. I suppose it works with any objects that have comparison operators, but it doesn't specify what comparison operators it needs. \nUpdate: Re comparison in ```\nheapq```\n, I can either use a ```\n(priority, object)```\n as Charlie Martin suggests, or just implement ```\n__cmp__```\n for my object. \n\n    ", "Answer": "\r\nYou can use Queue.PriorityQueue.\n\nRecall that Python isn't strongly typed, so you can save anything you like: just make a tuple of ```\n(priority, thing)```\n and you're set.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Running time for Dijkstra's algorithm on a priority queue implemented by sorted list/array\r\n                \r\nSo I'm curious to know what the running time for the algorithm is on on priority queue implemented by a sorted list/array.  I know for an unsorted list/array it is O((n^2+m)) where n is the number of vertices and m the number of edges.  Thus that equates to O(n^2) time.  But would it be faster if i used an sorted list/array...What would the running time be?  I know extractmin would be constant time.  \n    ", "Answer": "\r\nWell, Let's review what we need for dijkstra's algorithm(for future reference, usually vertices and edges are used as V and E, for example O(VlogE)):\nMerging together all the sorted adjacency lists: O(E)\nExtract Minimum : O(1)\nDecrease Key : O(V)\nDijkstra uses O(V) extract minimum operations, and O(E) decrease key operations, therefore:\nO(1)*O(V) = O(V)\nO(E)*O(V) = O(EV) = O(V^2)\nTaking the most asymptotically significant portion:\nEventual asymptotic runtime is O(V^2).\nCan this be made better? Yes. Look into binary heaps, and better implementations of priority queues.\n\nEdit: I actually made a mistake, now that I look at it again. E cannot be any higher than V^2, or in other words E = O(V^2).\nTherefore, in the worst case scenario, the algorithm that we concluded runs in O(EV) is actually O(V^2 * V) == O(V^3)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "MST-Prim implemented by a min priority queue\r\n                \r\nif MST is executed on unconnected graphs what will it execute? I thought it won't execute since it is unconnected but since it is being implemented by min priority queue, will that affect the results?\n    ", "Answer": "\r\nSince the graph is unconnected, it won't find a MST for the whole graph (because there is no tree that spans the entire graph). Rather, Prim's algorithm will find the MST for the connected component of your specified source vertex.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementation of priority queue using linked list\r\n                \r\n```\n#include<iostream>\nusing namespace std;\n\n//template<class T>\nclass Node\n{\n    public:\n//  T data;\n    int data;\n    Node *next;\n    int priority;\n};\n\n//template<class T>\nclass Que\n{\n        Node *front , *rear;\n    public:\n        Que(){front = rear = NULL;}\n\n//      void enqueue(T x);\n//      T dequeue();\n        void enqueue(int *x, int l);\n        int dequeue();\n        void display();\n};\n\n//template<class T>\n//void Que<T>::enqueue(T x)\nvoid Que::enqueue(int *x, int l)\n{\n    Node * pt = front;\n    for(int i=0; i<l; i++){\n    Node *t = NULL;\n    t = new Node;\n    if(t==NULL)\n        cout<<\"Queue is full\"<<endl;\n    else\n    {\n        t->next = NULL;\n        t->data = x[i];\n        t->priority = x[i];\n        if(front==NULL)\n            front = rear =t;\n        else\n        {\n            if(front->priority <= t->priority)\n            {\n                t->next = front;\n                front = t;\n            }\n            else\n            {\n                while(pt->next!= NULL && pt->next->priority <= x[i])\n                    pt = pt->next;\n                t->next = pt->next;\n                pt->next = t;\n            }\n        }\n    }\n}\n}\n\n//template<class T>\n//T Que<T>::dequeue()\nint Que::dequeue()\n{\n//  T x = -1;\n    int x = -1;\n    Node *t = NULL;\n    if(front == NULL)\n        cout<<\"Queue is empty\"<<endl;\n    else\n    { \n        x = front->data;\n        t = front;\n        front = front->next;\n        delete t;\n    }\n    return x;\n}\n\n//template<class T>\n//void Que<T>::display()\nvoid Que::display()\n{\n    Node *t = front;\n    while(t)\n    {\n        cout<<t->data<<\" \";\n        t = t->next;\n    }\n    cout<<endl;\n}\n\nint main()\n{\n//  Que <int> q();\n    Que q;\n    int a [] = {6, 1, 2, 5, 4, 3};\n    q.enqueue(a, sizeof(a)/sizeof(a[0]));\n//  q.dequeue();\n    q.display();\n    return 0;\n}\n```\n\n\nIt's a code for priority queue using linked list in C++. The while loop inside enqueue member function is showing segmentation fault.\n\nI think pointer ```\n*pt```\n to node which is used to point front is not pointing correctly. I have been trying to resolve it but couldn't get any idea. What can be reason for it? \n    ", "Answer": "\r\nYou initialize ```\npt```\n at the start of ```\nenqueue```\n but never reset it within the loop.  So when you add multiple elements to an empty list, ```\npt```\n will start as ```\nnullptr```\n, and won't be updated after the first element is added to the list.  When you try to add the second element to the list you dereference ```\npt->next```\n which cause your segmentation fault because ```\npt```\n is still ```\nnullptr```\n.\n\nThe fix is easy: move ```\nNode * pt = front;```\n to within the for loop.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Issue with implementing custom Comparator for Priority Queue in Java\r\n                \r\n\nPlease pardon my understanding towards priority Queue and Comparator in Java.\nIt seems ,I am able to implement basic comparator for Priority Queue based on some sort order.\nBut I am not able to come up with something for the below scenario :\n\n```\n1. Given a list of Files with name convention xx_yy_zz.dat .<br/>\n2.xx,yy,zz can be from 00-50 <br/>\n3.I need to process the files with xx=30 first,xx=35 second xx=40 third and then the rest.<br/>\n```\n\nSince I have limited knowledge with Priority Queue ,I tried to implement it which i was able to sort but only in asc or desc value of xx  which was not the requirement.\nMy approach was\n\nput the list of file names in priority Queue ,split the filename on regex \"_\"\nthen compare the first index of split array using comparator based on it values but as expected i failed miserably since my requirement was something different\n\nPlease share some ideas/approach.\nIt seems sadly ,I am not able to come up with the a required comparator for my case .\nNevertheless thanking you in anticipation\n    ", "Answer": "\r\nYou can use simple ```\nif```\n statements inside the ```\ncompare()```\n method to check if one string starts with ```\n\"30\"```\n and the other does not. Then you know that this string must come before the other one. You run the following ```\nif```\n statements like this on the first part of the filenames:\n\nAre they the same?\nIs the left one ```\n30```\n?\nIs the right one ```\n30```\n?\nIs the left one ```\n35```\n?\nIs the right one ```\n35```\n?\nIs the left one ```\n40```\n?\nIs the right one ```\n40```\n?\n\nThe comparator might look like this:\n```\npublic int compare(String a, String b) {\n    String[] splitA = a.split(\"_\");\n    String[] splitB = b.split(\"_\");\n\n    if (splitA[0].equals(splitB[0])) {\n        return 0;\n    }\n    if (splitA[0].equals(\"30\")) {\n        return -1;\n    }\n    if (splitB[0].equals(\"30\")) {\n        return 1;\n    }\n    if (splitA[0].equals(\"35\")) {\n        return -1;\n    }\n    if (splitB[0].equals(\"35\")) {\n        return 1;\n    }\n    if (splitA[0].equals(\"40\")) {\n        return -1;\n    }\n    if (splitB[0].equals(\"40\")) {\n        return 1;\n    }\n    return 0;\n}\n```\n\nWith the following test source code:\n```\nSystem.out.println(Arrays.toString(data));\nArrays.sort(data, new SpecialComparator());\nSystem.out.println(Arrays.toString(data));\n```\n\nYou might get an output like this (depending on the ```\ndata```\n array):\n```\n[30_45_35.dat, 00_12_34.dat, 35_50_20.dat, 40_03_05.dat, 33_28_14.dat,\n 30_16_31.dat, 20_29_23.dat, 24_41_29.dat, 30_49_18.dat, 40_12_13.dat]\n\n[30_45_35.dat, 30_16_31.dat, 30_49_18.dat, 35_50_20.dat, 40_03_05.dat,\n 40_12_13.dat, 00_12_34.dat, 33_28_14.dat, 20_29_23.dat, 24_41_29.dat]\n```\n\n(new lines added for clarity)\nAs you see you have the ```\n30```\ns first, then the only ```\n35```\n second, then the ```\n40```\ns third and after that all the remaining stuff. You might want to use ```\ncompareTo()```\n on the strings in case the ```\ncompareTo```\n method would return ```\n0```\n to get better \"sub sorting\" of strings, which would be equal based on this basic sorting above.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java: Priority Queue implementation iterable in proper order\r\n                \r\nI'm looking for some implementation of PQ in Java which allows iteration in PQ order - top element first, next one next etc. I tried using TreeSet (which implements NavigableSet) but it causes one problem. In my case:\n\n\nI'm using Comparator for my objects\npriority changes due to some external actions\nif priority changes I know for which object, but I don't know it's previous priority\n\n\nAs a result to the last point - I can't find my element in TreeSet when I would like to update its priority:/\nDo you happen to know: smart way to obey this? or some implementation of PQ that is iterable in \"good\" way? or should I create some linked data structure that will match objects with their positions in tree ?\n\nUPDATE:\n\n\nconcurrency is not an issue\nobject can't be removed from TreeSet because it's priority changed so Comparator will evaluate differently and object won't be found in this data structure. Inserting is not a problem.\nI can't use ```\ncompareTo```\n method as this priority is not proper way to compare those objects. That is why I need to use ```\nComparator```\n\n\n\nPOSSIBLE SOLUTION:\n\n\ncreate class ```\nPrioritizedObject```\n which will be compared by priority and keep my object\nuse map: my object -> ```\nPrioritizedObject```\n\nkeep ```\nPrioritizedObject```\n in some ```\nNavigableSet```\n\n\n\nI would use this map to remove objects from ```\nNavigableSet```\n. And of course update it with new elements if I add something.\nProblem is that I will have to wrap iterator from this ```\nNavigableSet```\n to get iterator returning my objects.\n\nIs there any better solution?\n    ", "Answer": "\r\n\n  if priority changes I know for which object, but I don't know it's previous priority\n\n\nYou don't need to know its previous priority. All you have to do is remove it and re-insert it.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is there a simple way to implement a fast priority queue in Haskell?\r\n                \r\nI've googled a bit and found a paper on Finger Trees, which can be used to implement a priority queue with proper asymptotic complexity, but they're quite complicated, but still about the simplest thing I could find.\n\nIs there a simple data structure that allows to implement a fast priority queue in Haskell?  Think simple as in you could explain it to a novice programmer.\n    ", "Answer": "\r\nThe heap package on Hackage claims to be based on Okasaki's leftist heaps.\nFrom the docs:\n\nChoose MinHeap or MaxHeap if you need a simple minimum or maximum heap (which always keeps the minimum/maximum element at the head of the Heap).\nIf you wish to manually annotate a value with a priority, e. g. an IO () action with an Int use MinPrioHeap or MaxPrioHeap. They manage (prio, val) tuples so that only the priority (and not the value) influences the order of elements.\nIf you still need something different, define a custom order for the heap elements by implementing an instance of HeapItem and let the maintainer know what's missing.\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue linked list implementation in C - enqueue() operation failure\r\n                \r\nThe ```\nenqueue()```\n operation which properly inserts a Node into the queue contains the core logic of my program. I have implemented the same Priority Queue using recursion and i know that the rest of the program works fine. Now i want to implement the priority queue using common iteration. The ```\nenqueue()```\n operation should work according to my draft plan below.\n\n\n\nHowever when i run the program it fails, without any errors at all (tested in VS and gcc). I just cannot understand where my logic in this one fails and it is driving me nuts. Help will be appreciated! \n\nThe code follows.\n\n```\n// The PQ is sorted according to its value\n// Descending order sorted insertion (bigger first -> smaller last)\nvoid enqueue(pqType val, PriorityQueue *PQ)\n{\nif (!isFull(PQ)) {\n    PQ->count++;\n\n    Node *currentNode = PQ->headNode;   // Iterate through PQ using currentNode\n    Node *prevNode = NULL;              // the previous Node of our current iteration\n    Node *newNode = (Node*) malloc(sizeof(Node)); // The new Node that will be inserted into the Queue\n\n    int i = 0;\n    while (i < MAX_QUEUE_SIZE) {\n        // if PQ is empty, or if val is larger than the currentNode's value then insert the new Node before the currentNode\n        if ((currentNode == NULL) || (val >= currentNode->value)) {\n            newNode->value = val;\n            newNode->link = currentNode;\n            prevNode->link = newNode;\n            break;\n        }\n        else {\n            prevNode = currentNode;\n            currentNode = currentNode->link;\n        }\n        i++;\n    }\n    //free(currentNode);\n    //free(prevNode);\n}\nelse\n    printf(\"Priority Queue is full.\\n\");\n}\n```\n\n    ", "Answer": "\r\nI think the problem is in the first Enqueue ( when PQ is empty), in this case you should change the ```\nPQ->headNode = newNode```\n not ```\nprevnode->link = newNode```\n, after the first enqueue I think your code will work fine.\n\n```\nif(prevNode == NULL)\n{\n    PQ->headNode = newNode;\n}\nelse\n{\n    prevNode->link = newNode;\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is the programmer's default selection for implementation of priority queue? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nIs it:\n\n\nHeap? \nUnsorted List? \nSorted List?  \nLinked list?  \nAny other data structure?\n\n\nWhich one of them is the default/natural choice of programmers when implementing priority queue and what is the reason of preference of that particular choice over the other?\n    ", "Answer": "\r\nI would recommend implementing a Ladder Queue, which is an ```\nO(1)```\n priority queue.\n\nFormal definition: Ladder queue: An O(1) priority queue structure for large-scale discrete event simulation\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement O(logn) decrease-key operation for min-heap based Priority Queue?\r\n                \r\nI am working on an application that demonstrates the Djikstra's algorithm, and to use it, I need to restore the heap property when my elements' value is decreased.\n\nThe problem regarding the complexity is that when the algorithm changes the value of an element, that element's index in the internal structure (heap in this case) used for the priority queue is unknown. As such, I currently need to do an O(n) search, in order to recover the index, before I can perform an actual decrease-key on it.\n\nMoreover, I am not exactly sure about the actual code needed for the operation. I am using the D-Heap here for my Priority Queue. Pseudocode would help, but I would prefer an example in Java on how this should be done.\n    ", "Answer": "\r\nYou can do following: store a hashmap inside your heap that maps your heap values to heap indexes. Then you should extend your usual heap-logic just a bit:\n\n```\non Swap(i, j): \n    map[value[i]] = j; \n    map[value[j]] = i;\n```\n\n\n\n\n```\non Insert(key, value): \n    map.Add(value, heapSize) in the beginning;\n```\n\n\n\n\n```\non ExtractMin: \n    map.Remove(extractedValue) in the end;\n```\n\n\n\n\n```\non UpdateKey(value, newKey): \n    index = map[value]; \n    keys[index] = newKey; \n```\n\n\n```\nBubbleUp(index)```\n in case of ```\nDecreaseKey```\n, and ```\nBubbleDown/Heapify(index)```\n in case of ```\nIncreaseKey```\n, to restore min-heap-property.\n\nHere's my C# implementation: http://pastebin.com/kkZn123m\n\nInsert and ExtractMin call Swap log(N) times, when restoring heap property. And you're adding O(1) overhead to Swap, so both operations remain O(log(n)). UpdateKey is also log(N): first you lookup index in a hashmap for O(1), then you're restoring heap property for O(log(N)) as you do in Insert/ExtractMin.\n\nImportant note: using values for index lookup will require that they are UNIQUE. If you're not ok with this condition, you will have to add some uniqueue id to your key-value pairs and maintain mapping between this uniqueue id and heap index instead of value-index mapping. But for Dijkstra it's not needed, as your values will be graph nodes and you don't want duplicate nodes in your priority queue.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to Implement Priority Queues in RabbitMQ/pika\r\n                \r\nI am looking to implement a priority queue with RabbitMQ. The mailing list recommends to use multiple queues, each queue representing a different priority level.\n\nMy question is, how do you poll multiple queues in some prioritized order using pika (or possibly some other python library)?\n    ", "Answer": "\r\nThe accepted answer is outdated.\nFrom ```\nrabbitmq 3.5.0```\n there's native support for priority queues:\n\n\n  RabbitMQ has priority queue\n  implementation in the core as of version 3.5.0. Any queue can be\n  turned into a priority one using client-provided optional arguments\n\n\nIt's also available as of ```\npika 1.1.0```\n\n\n\n  class pika.spec.BasicProperties(content_type=None,\n  content_encoding=None, headers=None, delivery_mode=None,\n  priority=None, correlation_id=None, reply_to=None, expiration=None,\n  message_id=None, timestamp=None, type=None, user_id=None, app_id=None,\n  cluster_id=None)\n\n\nThe code using this feature might look as follows:\n\n```\nchannel.basic_publish(properties=pika.BasicProperties(priority=your_priority),\n                      exchange=...,\n                      routing_key=...,\n                      body=...)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is a NullPointerException, and how do I fix it?\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question's answers are a community effort. Edit existing answers to improve this post. It is not currently accepting new answers or interactions.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n\r\n\r\n    \r\n\r\nWhat are Null Pointer Exceptions (```\njava.lang.NullPointerException```\n) and what causes them?\n\nWhat methods/tools can be used to determine the cause so that you stop the exception from causing the program to terminate prematurely?\n    ", "Answer": "\r\nThere are two overarching types of variables in Java:\n\nPrimitives: variables that contain data. If you want to manipulate the data in a primitive variable you can manipulate that variable directly. By convention primitive types start with a lowercase letter. For example variables of type ```\nint```\n or ```\nchar```\n are primitives.\n\nReferences: variables that contain the memory address of an ```\nObject```\n i.e. variables that refer to an ```\nObject```\n. If you want to manipulate the ```\nObject```\n that a reference variable refers to you must dereference it. Dereferencing usually entails using ```\n.```\n to access a method or field, or using ```\n[```\n to index an array. By convention reference types are usually denoted with a type that starts in uppercase. For example variables of type ```\nObject```\n are references.\n\n\nConsider the following code where you declare a variable of primitive type ```\nint```\n and don't initialize it:\n```\nint x;\nint y = x + x;\n```\n\nThese two lines will crash the program because no value is specified for ```\nx```\n and we are trying to use ```\nx```\n's value to specify ```\ny```\n. All primitives have to be initialized to a usable value before they are manipulated.\nNow here is where things get interesting. Reference variables can be set to ```\nnull```\n which means \"I am referencing nothing\". You can get a ```\nnull```\n value in a reference variable if you explicitly set it that way, or a reference variable is uninitialized and the compiler does not catch it (Java will automatically set the variable to ```\nnull```\n).\nIf a reference variable is set to null either explicitly by you or through Java automatically, and you attempt to dereference it you get a ```\nNullPointerException```\n.\nThe ```\nNullPointerException```\n (NPE) typically occurs when you declare a variable but did not create an object and assign it to the variable before trying to use the contents of the variable. So you have a reference to something that does not actually exist.\nTake the following code:\n```\nInteger num;\nnum = new Integer(10);\n```\n\nThe first line declares a variable named ```\nnum```\n, but it does not actually contain a reference value yet. Since you have not yet said what to point to, Java sets it to ```\nnull```\n.\nIn the second line, the ```\nnew```\n keyword is used to instantiate (or create) an object of type ```\nInteger```\n, and the reference variable ```\nnum```\n is assigned to that ```\nInteger```\n object.\nIf you attempt to dereference ```\nnum```\n before creating the object you get a ```\nNullPointerException```\n. In the most trivial cases, the compiler will catch the problem and let you know that \"```\nnum may not have been initialized```\n,\" but sometimes you may write code that does not directly create the object.\nFor instance, you may have a method as follows:\n```\npublic void doSomething(SomeObject obj) {\n   // Do something to obj, assumes obj is not null\n   obj.myMethod();\n}\n```\n\nIn which case, you are not creating the object ```\nobj```\n, but rather assuming that it was created before the ```\ndoSomething()```\n method was called. Note, it is possible to call the method like this:\n```\ndoSomething(null);\n```\n\nIn which case, ```\nobj```\n is ```\nnull```\n, and the statement ```\nobj.myMethod()```\n will throw a ```\nNullPointerException```\n.\nIf the method is intended to do something to the passed-in object as the above method does, it is appropriate to throw the ```\nNullPointerException```\n because it's a programmer error and the programmer will need that information for debugging purposes.\nIn addition to ```\nNullPointerException```\ns thrown as a result of the method's logic, you can also check the method arguments for ```\nnull```\n values and throw NPEs explicitly by adding something like the following near the beginning of a method:\n```\n// Throws an NPE with a custom error message if obj is null\nObjects.requireNonNull(obj, \"obj must not be null\");\n```\n\nNote that it's helpful to say in your error message clearly which object cannot be ```\nnull```\n. The advantage of validating this is that 1) you can return your own clearer error messages and 2) for the rest of the method you know that unless ```\nobj```\n is reassigned, it is not null and can be dereferenced safely.\nAlternatively, there may be cases where the purpose of the method is not solely to operate on the passed in object, and therefore a null parameter may be acceptable. In this case, you would need to check for a null parameter and behave differently. You should also explain this in the documentation. For example, ```\ndoSomething()```\n could be written as:\n```\n/**\n  * @param obj An optional foo for ____. May be null, in which case\n  *  the result will be ____.\n  */\npublic void doSomething(SomeObject obj) {\n    if(obj == null) {\n       // Do something\n    } else {\n       // Do something else\n    }\n}\n```\n\nFinally, How to pinpoint the exception & cause using Stack Trace\n\nWhat methods/tools can be used to determine the cause so that you stop\nthe exception from causing the program to terminate prematurely?\n\nSonar with find bugs can detect NPE.\nCan sonar catch null pointer exceptions caused by JVM Dynamically\nNow Java 14 has added a new language feature to show the root cause of NullPointerException. This language feature has been part of SAP commercial JVM since 2006.\nIn Java 14, the following is a sample NullPointerException Exception message:\n\nin thread \"main\" java.lang.NullPointerException: Cannot invoke \"java.util.List.size()\" because \"list\" is null\n\nList of situations that cause a ```\nNullPointerException```\n to occur\nHere are all the situations in which a ```\nNullPointerException```\n occurs, that are directly* mentioned by the Java Language Specification:\n\nAccessing (i.e. getting or setting) an instance field of a null reference. (static fields don't count!)\nCalling an instance method of a null reference. (static methods don't count!)\n```\nthrow null;```\n\nAccessing elements of a null array.\nSynchronising on null - ```\nsynchronized (someNullReference) { ... }```\n\nAny integer/floating point operator can throw a ```\nNullPointerException```\n if one of its operands is a boxed null reference\nAn unboxing conversion throws a ```\nNullPointerException```\n if the boxed value is null.\nCalling ```\nsuper```\n on a null reference throws a ```\nNullPointerException```\n. If you are confused, this is talking about qualified superclass constructor invocations:\n\n```\nclass Outer {\n    class Inner {}\n}\nclass ChildOfInner extends Outer.Inner {\n    ChildOfInner(Outer o) { \n        o.super(); // if o is null, NPE gets thrown\n    }\n}\n```\n\n\nUsing a ```\nfor (element : iterable)```\n loop to loop through a null collection/array.\n\n```\nswitch (foo) { ... }```\n (whether its an expression or statement) can throw a ```\nNullPointerException```\n when ```\nfoo```\n is null.\n\n```\nfoo.new SomeInnerClass()```\n throws a ```\nNullPointerException```\n when ```\nfoo```\n is null.\n\nMethod references of the form ```\nname1::name2```\n or ```\nprimaryExpression::name```\n throws a ```\nNullPointerException```\n when evaluated when ```\nname1```\n or ```\nprimaryExpression```\n evaluates to null.\na note from the JLS here says that, ```\nsomeInstance.someStaticMethod()```\n doesn't throw an NPE, because ```\nsomeStaticMethod```\n is static, but ```\nsomeInstance::someStaticMethod```\n still throw an NPE!\n\n\n* Note that the JLS probably also says a lot about NPEs indirectly.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "If priority queue is the implementation of min-heap, how does priority queue produces same result all the time\r\n                \r\nThe min-heap of 2,1,3 is either 1,2,3 or 1,3,2.\nWhich means priority queue should result any of them...\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "LRU cache implementation in Python using priority queue\r\n                \r\nI have the following code for implementing LRU cache.\n```\nfrom __future__ import annotations\n\nfrom time import time\n\nimport heapq\n\nfrom typing import List, Dict, TypeVar, Generic, Optional, Tuple\n\n# LRU Cache\nT = TypeVar('T')\n\n\nclass Element:\n    def __init__(self, key: str) -> None:\n        self.key = key\n        self.unixtime = time()\n\n    def __lt__(self, other: Element) -> bool:\n        return self.unixtime < other.unixtime\n\n    def __eq__(self, other: Element) -> bool:\n        return self.unixtime == other.unixtime\n\n    def __gt__(self, other: Element) -> bool:\n        return (not self.unixtime < other.unixtime) and self.unixtime != other.unixtime\n\n    def __repr__(self) -> str:\n        return f'({self.key}, {self.unixtime})'\n\n\nclass PriorityQueue(Generic[T], list):\n    def __init__(self) -> None:\n        self._data: List[Optional[T]] = []\n        super().__init__()\n\n    @property\n    def is_empty(self) -> bool:\n        return not self._data\n\n    def push(self, v: T) -> None:\n        heapq.heappush(self._data, v)\n\n    def popq(self) -> Optional[T]:\n        if not self.is_empty:\n            return heapq.heappop(self._data)\n        else:\n            return None\n\n    def __repr__(self) -> str:\n        return repr(self._data)\n\n\nclass LRUCache:\n    def __init__(self, limit: int) -> None:\n        self._data: Dict[str, int] = {}\n        self.limit = limit\n        self._keyqueue: PriorityQueue[Element] = PriorityQueue()\n\n    def put(self, key: str, value: T) -> None:\n        if len(self._data) < self.limit:    # there is still room in the cache\n            if key not in self._data:\n                self._keyqueue.push(Element(key))\n            else:\n                correct_key = [item for item in self._keyqueue._data if item.key == key][0]\n                ind = self._keyqueue._data.index(correct_key)\n                self._keyqueue._data[ind].unixtime = time()\n            self._data[key] = value\n        else:                               # cache is full\n            if key not in self._data:\n                out_key = self._keyqueue.popq()\n                self._data.pop(out_key.key)\n                self._keyqueue.push(Element(key))\n            else:\n                correct_key = [item for item in self._keyqueue._data if item.key == key][0]\n                ind = self._keyqueue._data.index(correct_key)\n                self._keyqueue._data[ind].unixtime = time()\n            self._data[key] = value\n\n    def get(self, key: str) -> Optional[T]:\n        if key in self._data:\n            correct_key = [item for item in self._keyqueue._data if item.key == key][0]\n            ind = self._keyqueue._data.index(correct_key)\n            self._keyqueue._data[ind].unixtime = time()\n            return self._data[key]\n        else:\n            raise KeyError('Key not found in cache')\n\n    def __repr__(self) -> str:\n        return repr(self._data)\n\ncache = LRUCache(3)\ncache.put('owen', 45)\ncache.put('john', 32)\ncache.put('box', 4556)\n\ncache.get('owen')\ncache.get('owen')\n\ncache.put('new', 9)\ncache\n```\n\nI use the ```\nunixtime```\n attribute of the ```\nElement```\n class to decide the priority. I am using the ```\nheapq```\n module together with a list to implement the priority queue. Maybe it is not the most efficient way to implement LRU cache in Python but this is what I came up with.\nMy problem is that after I access the ```\nowen```\n key twice with ```\n.get()```\n and then issue ```\ncache.put('new', 9)```\n - It should remove ```\njohn```\n because it is the least recently used. Instead it removes ```\nowen```\n.\nI have checked ```\n_keyqueue```\n and ```\nowen```\n has the highest ```\nunixtime```\n and ```\njohn```\n has the lowest, and as I understand, the ```\nheapq```\n module in Python uses ```\nmin_heap```\n so the ```\njohn```\n record should be replaced by the new value. What am I missing here?\n    ", "Answer": "\r\nI finally discovered what was the problem:\nWhenever updating the times, we need to call ```\nheapq.heapify()```\n on the heap data after the update.\nI have also written a slightly more efficient implementation, if anyone needs it:\n```\nfrom typing import List, Optional, TypeVar, Tuple, Dict, Generic\n\nfrom time import time\n\nimport heapq\n\nT = TypeVar('T')\n\n\nclass LRUTuple(tuple):\n    def __init__(self, key: Tuple[str]) -> None:\n        self.key = key\n        self.time = time()\n\n    def __lt__(self, other) -> bool:\n        return self.time < other.time\n\n    def __gt__(self, other) -> bool:\n        return not self.time < other.time\n\n\n# test class\na = LRUTuple(('owen',))\nb = LRUTuple(('aheek',))\nassert b > a\nassert a < b\n\n\nclass PriorityQueue(Generic[T]):\n    def __init__(self) -> None:\n        self._data: List[T] = []\n\n    @property\n    def is_empty(self) -> bool:\n        return not self._data\n\n    def add(self, v: T) -> None:\n        heapq.heappush(self._data, v)\n\n    def pop_queue(self) -> Optional[T]:\n        if not self.is_empty:\n            return heapq.heappop(self._data)\n        else:\n            print('Empty Queue')\n            return None\n\n    def _heapify(self) -> None:\n        heapq.heapify(self._data)\n\n    def peek(self) -> Optional[T]:\n        if not self.is_empty:\n            return self._data[0]\n        else:\n            print('Empty Queue')\n            return None\n\n    def __repr__(self) -> str:\n        return repr(self._data)\n\n\nclass LRUCache:\n    def __init__(self, limit: int) -> None:\n        self._data: Dict[str, T] = {}\n        self.limit = limit\n        self._keyqueue: PriorityQueue[LRUTuple] = PriorityQueue()\n\n    def _update_key_time(self, key: str) -> None:\n        self._keyqueue._data[self._keyqueue._data.index((key,))].time = time()\n        self._keyqueue._heapify()\n\n    def put(self, key: str, value: T) -> None:\n        if len(self._keyqueue._data) < self.limit:\n            if key not in self._data:\n                self._data[key] = value\n                self._keyqueue.add(LRUTuple((key,)))\n            else:\n                self._data[key] = value\n                self._update_key_time(key)\n        else:\n            # remove lru key\n            poped_key = self._keyqueue.pop_queue()\n            self._data.pop(poped_key[0])\n            self.put(key, value)\n\n    def get(self, key: str) -> Optional[T]:\n        if key in self._data:\n            self._update_key_time(key)\n            return self._data[key]\n        else:\n            print('KeyError: key not found')\n            return None\n\n    def __repr__(self) -> str:\n        return repr([(k[0], k.time) for k in self._keyqueue._data])\n\n\n# test LRUCache usage\nlr = LRUCache(3)\nlr.put('owen', 54)\nlr.put('arwen', 4)\nlr.put('jiji', 98)\nlr._keyqueue.peek()\nlr.get('owen')\nlr._keyqueue.peek()\nlr\nlr.put('bone', 7)   # should replace arwen!\nlr\nlr._keyqueue.peek()\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing simple priority queue using vector in C++\r\n                \r\nThe following gives an error for the code mentioned below.\nWhere I have gone wrong ? \n\n```\nerror: ‘function’ is not a member of ‘std’\n```\n\n\nI want to make priority queue using C++ std lib queue, and min the queue is that IceCream which takes least time to prep. I have tried implementing this -> declaring a priority_queue in c++ with a custom comparator\n\n```\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <iterator>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n\nclass IceCream\n{\n public:\n   int time_to_prep;\n    IceCream(int flav) {\n          time_to_prep = flav;\n       }\n};\n\nbool Compare(IceCream a, IceCream b)\n{\n    return a.time_to_prep > b.time_to_prep;\n}\n\nint main()\n{\n    priority_queue<IceCream, vector<IceCream>, std::function<bool(IceCream a, IceCream b)> > my_pq(Compare);\n    my_pq.push(IceCream(4));\n    my_pq.push(IceCream(33));\n    my_pq.push(IceCream(9));\n    cout << my_pq.top() << endl;\n    return 0;\n}\n```\n\n    ", "Answer": "\r\n```\n#include <functional>\n```\n\n\nYou need this include to get access to ```\nstd::function```\n\n\nSee: http://en.cppreference.com/w/cpp/utility/functional/function\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a distributed priority queue without using Zookeeper?\r\n                \r\nI want to implement a distributed priority queue without using Zookeeper?\n    ", "Answer": "\r\nIf you know how to communicate between client and server (e.g. with TCP sockets) it should be straightforward. The server contains a thread safe implementation of the Priority Queue, hence providing an \"interface\". Clients connect to the server and uses this \"interface\".\n\nServer\n\nThe server must provide a priority queue interface (i.e. supporting ```\nadd```\n, ```\npeek```\n, ```\npoll```\n, ...). Important is that these methods must be thread safe ! So we will use ```\nPriorityBlockingQueue```\n (which is synchronized) instead of ```\nPriorityQueue```\n.\n\n```\npublic class Server {\n    private static ServerSocket server_skt;\n    public PriorityBlockingQueue<Integer> pq;\n\n    // Constructor\n    Server(int port, int pq_size) {\n        server_skt = new ServerSocket(port);\n        this.pq = new PriorityBlockingQueue<Integer>(pq_size);\n    }\n\n    public static void main(String argv[]) {\n        Server server = new Server(5555, 20); // Make server instance\n\n        while(true) {\n            // Always wait for new clients to connect\n            try {\n                System.out.println(\"Waiting for a client to connect...\");\n                // Spawn new thread for communication with client \n                new CommunicationThread(server_skt.accept(), server.pq).start();\n            } catch(IOException e) {\n                System.out.println(\"Exception occured :\" + e.getStackTrace());\n            }\n        }\n    }\n}\n```\n\n\nAnd this is how ```\nCommunicationThread```\n class would look like\n\n```\npublic class CommunicationThread extends Thread {\n    private Socket client_socket;\n    private InputStream client_in;\n    private OutputStream client_out;\n    private PriorityBlockingQueue<Integer> pq;\n\n    public CommunicationThread(Socket socket, PriorityBlockingQueue<Integer> pq) {\n        try {\n            this.client_socket = socket;\n            this.client_in = client_socket.getInputStream();\n            this.client_out = client_socket.getOutputStream(); \n            this.pq = pq;\n\n            System.out.println(\"Client connected : \" + client_socket.getInetAddress().toString());\n        } catch(IOException e) {\n            System.out.println(\"Could not initialize communication properly. -- CommunicationThread.\\n\");\n        }\n    }\n\n    @Override\n    public void run() {\n        boolean active = true;\n        while(active) {\n            int message_number = client_in.read(); // Listen for next integer --> dispatch to correct method\n\n            switch(message_number) {\n            case -1: case 0: \n                // Will stop the communication between client and server\n                active = false;\n                break;\n            case 1:\n                // Add\n                int element_to_add = client_in.read(); // read element to add to the priority queue\n                pq.add(element_to_add); // Note that a real implementation would send the answer back to the client\n                break;\n            case 2:\n                // Poll (no extra argument to read)\n                int res = pq.poll();\n\n                // Write result to client\n                client_out.write(res);\n                client_out.flush();\n                break;\n\n            /*\n             * IMPLEMENT REST OF INTERFACE (don't worry about synchronization, PriorityBlockingQueue methods are already thread safe)\n             */\n\n            }\n        }\n\n        client_in.close();\n        client_out.close();\n    }\n}\n```\n\n\nThis class is listening to what the client is sending.\nAccording to what the client sent, the server knows what to do, hence there is a mini protocol. That protocol is : when the client wants to invoke a method of the distributed priority queue, he sends an integer (e.g. 2 = ```\npoll()```\n). The server reads that integer and knows which method to invoke.\n\nNote that sometimes sending one integer is enough (see ```\npoll()```\n example), but not always. Think for example of ```\nadd()```\n which has to specify an argument. The server will receive ```\n1```\n from the client (i.e. ```\nadd()```\n) and will read a second integer (or any other object that has to be stored in the distributed priority queue).\n\nClient\n\nBased on the protocol, the server is offering the client an interface (e.g. 0 = stop communication, 1 = ```\nadd()```\n , ...). The client only has to connect to the server and send messages (respecting the procotol!) to it.\n\nA client example :\n\n```\npublic class PQ_Client {\n    private static Socket skt;\n    private InputStream in;\n    private OutputStream out;\n\n    private final int _STOP_ = 0, _ADD_ = 1, _POLL_ = 2; // By convention (protocol)\n\n    PQ_Client(String ip, int port) {\n        try {\n            this.skt = new Socket(ip, port);\n            this.in = skt.getInputStream();\n            this.out = skt.getOutputStream();\n\n            System.out.println(\"Connected to distributed priority queue.\");\n        } catch(IOException e) {\n            System.out.println(\"Could not connect with the distributed priority queue : \" + e.getStackTrace());\n        }\n    }\n\n    // Sort of stub functions\n    public void stop() {\n        out.write(_STOP_);\n        out.flush();\n        out.close();\n    }\n\n    public void add(Integer el) {\n        out.write(_ADD_); // Send wanted operation\n        out.write(el);    // Send argument element\n\n        // Real implementation would listen for result here\n\n        out.flush();\n    }\n\n    public int poll() {\n        out.write(_POLL_);\n        out.flush();\n\n        // Listen for answer\n        return in.read();\n    }\n\n    /*\n     * Rest of implementation\n     */\n}\n```\n\n\nNote that thanks to these self made \"stub functions\" we can make a ```\nPQ_Client```\n object and use it as if it was a priority queue (the client/server communication is hidden behind the stubs).\n\n```\nString ip = \"...\";\nint port = 5555;\n\nPQ_Client pq = new PQ_Client(ip , port);    \npq.add(5);\npq.add(2);\npq.add(4);\n\nint res = pq.poll();\n```\n\n\nNote that by using RPC (Remote Procedure Call) it could be easier (stub function generated automatically, ...).\nIn fact what we implemented above is a little RPC-like mechanism, as it does nothing else then sending a message to call a procedure (e.g. ```\nadd()```\n) on the server, serializing the result (not needed for integers), send it back to the client.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Trying to implement priority queue for nearest neighbor search\r\n                \r\nSo to give a bit of background:\n\n\nI am trying to implement a k-d tree with nearest neighbor search.\nTo implement the NN search, I needed to create a priority queue.\nThe priority queue has to have the point coordinates and the distance.\nSo I decided to group those two into a Tuple.\n\n\nTurns out C# is a bit different than the other languages I'm used to. \n\nHere's the error message I get when I do this:\n\n```\nPriorityQueue<Tuple<Point, double>> pq = new PriorityQueue<Tuple<Point, double>>();\n```\n\n\n\n  error CS0311: The type ```\nSystem.Tuple<Tree.Point,double>' cannot be\n  used as type parameter```\nT' in the generic type or method\n  ```\nPriorityQueue.PriorityQueue<T>'. There is no implicit reference\n  conversion from```\nSystem.Tuple' to\n  `System.IComparable>'\n\n\nI researched this for quite some time and since I'm new to C#, I can't quite understand why this is happening. I guess programming in Python makes life very easy.\n\n\n\nMy priority queue class looks like this:\n\n```\npublic class PriorityQueue<T> where T : IComparable<T>\n{\n    private List<T> dataHeap;\n\n    public PriorityQueue()\n    {\n        this.dataHeap = new List<T>();\n    }\n\n    public void Enqueue(T value)\n    {\n        this.dataHeap.Add(value);\n        BubbleUp();\n    }\n\n    public T Dequeue()\n    {\n        if (this.dataHeap.Count <= 0)\n        {\n            throw new InvalidOperationException(\"Cannot Dequeue from empty queue!\");\n        }\n\n        T result = dataHeap[0];\n        int count = this.dataHeap.Count - 1;\n        dataHeap[0] = dataHeap[count];\n        dataHeap.RemoveAt(count);\n        ShiftDown();\n\n        return result;\n    }\n\n    private void BubbleUp()\n    {\n        int childIndex = dataHeap.Count - 1;\n\n        while (childIndex > 0)\n        {\n            int parentIndex = (childIndex - 1) / 2;\n\n            if (dataHeap[childIndex].CompareTo(dataHeap[parentIndex]) >= 0)\n            {\n                break;\n            }\n\n            SwapAt(childIndex, parentIndex);\n            childIndex = parentIndex;\n        }\n    }\n\n    private void ShiftDown()\n    {\n        int count = this.dataHeap.Count - 1;\n        int parentIndex = 0;\n\n        while (true)\n        {\n            int childIndex = parentIndex * 2 + 1;\n            if (childIndex > count)\n            {\n                break;\n            }\n\n            int rightChild = childIndex + 1;\n            if (rightChild <= count && dataHeap[rightChild].CompareTo(dataHeap[childIndex]) < 0)\n            {\n                childIndex = rightChild;\n            }\n            if (dataHeap[parentIndex].CompareTo(dataHeap[childIndex]) <= 0)\n            {\n                break;\n            }\n\n            SwapAt(parentIndex, childIndex);\n            parentIndex = childIndex;\n        }\n    }\n\n    public T Peek()\n    {\n        if (this.dataHeap.Count == 0)\n        {\n            throw new InvalidOperationException(\"Queue is empty.\");\n        }\n\n        T frontItem = dataHeap[0];\n        return frontItem;\n    }\n\n    public int Count()\n    {\n        return dataHeap.Count;\n    }\n\n    /// <summary>Removes all elements from the queue.</summary>\n    public void Clear()\n    {\n        this.dataHeap.Clear();\n    }\n\n    public void CopyToArray(T[] array, int index)\n    {\n        if (array == null)\n        {\n            throw new ArgumentNullException(\"Array\");\n        }\n\n        int length = array.Length;\n        if (index < 0 || index >= length)\n        {\n            throw new IndexOutOfRangeException(\"Index must be between zero and array length.\");\n        }\n        if (length - index < this.dataHeap.Count-1)\n        {\n            throw new ArgumentException(\"Queue is bigger than array\");\n        }\n\n        T[] data = this.dataHeap.ToArray();\n        Array.Copy(data, 0, array, index, data.Length);\n    }\n\n    public bool IsConsistent()\n    {\n        if (dataHeap.Count == 0)\n        {\n            return true;\n        }\n\n        int lastIndex = dataHeap.Count - 1; \n        for (int parentIndex = 0; parentIndex < dataHeap.Count; ++parentIndex) \n        {\n            int leftChildIndex = 2 * parentIndex + 1; \n            int rightChildIndex = 2 * parentIndex + 2;\n\n            if (leftChildIndex <= lastIndex && dataHeap[parentIndex].CompareTo(dataHeap[leftChildIndex]) > 0)\n            {\n                return false;\n            }\n            if (rightChildIndex <= lastIndex && dataHeap[parentIndex].CompareTo(dataHeap[rightChildIndex]) > 0)\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private void SwapAt(int first,int second)\n    {\n        T value = dataHeap[first];\n        dataHeap[first] = dataHeap[second];\n        dataHeap[second] = value;\n    }\n\n    public override string ToString()\n    {\n        string queueString = string.Join(\" \", dataHeap.ToArray());\n        return queueString;\n    }\n}\n```\n\n\nMy Point class:\n\n```\nclass Point : IComparable\n{\n    private double x;\n    private double y;\n\n    public Point(double xCoord, double yCoord)\n    {\n        SetPoint(xCoord, yCoord);\n    }\n\n    ~Point() {}\n\n    public int CompareTo(object obj) \n    {\n        if (obj == null) return 1;\n\n        Point p = obj as Point;\n        if (p != null) \n            return (this.x.CompareTo(p.x) & this.y.CompareTo(p.y));\n        else \n           throw new ArgumentException(\"Object is not a Point\");\n    }\n\n    public static bool operator ==(Point a, Point b)\n    {\n        if (ReferenceEquals(a, null) || ReferenceEquals(b, null)) return true;\n        if (a[0] == b[0] && a[1] == b[1]) return true;\n        else return false;\n    }\n\n    public static bool operator !=(Point a, Point b)\n    {\n        if (ReferenceEquals(a, null) || ReferenceEquals(b, null)) return true;\n        if (a[0] != b[0] || a[1] != b[1]) return true;\n        else return false;\n    }\n\n    public double this[int index]\n    {\n        get\n        {\n            if (index == 0) return x;\n            else if (index == 1) return y;\n            else throw new System.IndexOutOfRangeException(\"index \" + index + \" is out of range\");\n        }\n        set\n        {\n            if (index == 0) x = value;\n            else if (index == 1) y = value;\n            else throw new System.IndexOutOfRangeException(\"index \" + index + \" is out of range\");\n        }\n\n    }\n\n    public void SetPoint(double xCoord, double yCoord)\n    {\n        x = xCoord;\n        y = yCoord;\n    }\n\n    public override string ToString()\n    {\n        return \"(\" + x + \", \" + y + \")\";\n    }\n}\n```\n\n    ", "Answer": "\r\nI suggest you remove the constraint on ```\nT```\n and then take an explicit ```\nIComparer<T>```\n in the constructor for ```\nPriorityQueue```\n. Your existing constructor can provide ```\nComparer<T>.Default```\n as the comparer if none is provided.\n\nYou then need to change ```\nobj.CompareTo(other)```\n to ```\ncomp.Compare(obj, other)```\n throughout ```\nPriorityQueue```\n.\n\n```\npublic class PriorityQueue<T>\n{\n    private List<T> dataHeap;\n    private readonly IComparer<T> comp;\n\n    public PriorityQueue() : this(Comparer<T>.Default) {}\n\n    public PriorityQueue(IComparer<T> comp)\n    {\n        this.dataHeap = new List<T>();\n        this.comp = comp;\n    }\n    ...\n    private void BubbleUp() {\n        if (this.comp.Compare(dataHeap[childIndex], dataHeap[parentIndex]) >= 0)\n   }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "min priority queue insertion implementation with sorted arraylist\r\n                \r\nI am trying to implement a min priority queue with a sorted arraylist. However I am facing trouble for the insertion method. I am getting null pointer exception error. I don't know how to fix it. I have a getKey() and compare method in my AbstractPriorityQueue class. Any help will be really appreciated. I've been stuck with this problem for a long time.\nMy class:\n```\nimport java.util.ArrayList;\n\npublic class SortedListPQ<K,V> extends AbstractPriorityQueue<K,V>  {\n    \n    private ArrayList<Entry<K,V>> list;\n    private Comparator<K> comp;\n    \n      /**\n       *  Constructor\n       */\n      public SortedListPQ() {\n        list = new ArrayList<Entry<K,V>>();\n      }\n      \n      /**\n       * to check if the queue is empty\n       */\n      public boolean isEmpty() {\n            return list.size() == 0;\n          }\n      \n      /**\n       * inserting an element in the sorted list (right position)\n       */\n      public Entry<K,V> insert(K key, V value) {\n          checkKey(key); \n          Entry<K,V> newest = new PQEntry<>(key, value);\n          \n          //if the list is empty, then add the entry to the list\n          if(list.isEmpty()) {\n              list.add(0,newest);         \n              }\n          \n          else {\n              \n          \n          //if the new key is the smallest, add it to the beginning\n          Entry<K,V>start=list.get(0); \n          if (comp.compare(start.getKey(),newest.getKey())>0) {\n              list.add(0,newest);\n          }\n          \n          //if the key is largest, we'll add it to the end\n          Entry<K,V>last=list.get(list.size()-1);\n          if(comp.compare(last.getKey(), newest.getKey())<0) {\n              list.add(list.size()-1,newest);\n          }\n          \n          //to add the key between two keys\n          int p=1;\n          while (p!=list.size()-1) {\n              Entry<K,V> before = list.get(p);\n              Entry<K,V> after = list.get(p+1);\n              \n              if ((comp.compare(before.getKey(),newest.getKey())<0) && \n (comp.compare(after.getKey(),newest.getKey())>0)) {\n                  list.add(p+1,newest);\n              }\n              p++;\n          }\n          }\n          return newest;\n          \n      }\n      public Entry<K,V> min() {\n            if (list.size() == 0)\n              return null;\n            else\n              return list.get(0);   // the first element is smallest\n          }\n      \n      public Entry<K,V> removeMin() {\n            if (list.size() == 0)\n              return null;\n            else                                  // shrink the size\n              return list.remove(0);  // and return the smallest element\n          }\n\n}\n```\n\nI also have this compare method in my AbstractPriorityQueue class\n```\nprotected int compare(Entry<K,V> a, Entry<K,V> b) {\n        return comp.compare(a.getKey( ), b.getKey( ));\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing a priority queue with a min heap\r\n                \r\nI am attempting to implement a priority queue using a minheap, but my objects are coming out of the queue in the wrong order. My intuition tells me the issue is with my methods for sifting up or down in the queue, but I can't see where the issue is. Could someone look at my algorithms and see if there's anything wrong that is immediately apparent? Thank you in advance.\n\nHere is the method for sifting down:\n\n```\nprivate void walkDown(int i) {\n\n    if (outOfBounds(i))\n    {\n        throw new IndexOutOfBoundsException(\"Index not in heap : \" + i);\n    }\n\n    int current = i;\n    boolean right;\n    Customer temp = this.heap[i];\n\n    while (current < (this.size >>> 1)) \n    {\n\n        right = false;\n\n        if (right(current) < this.size && \n                 this.comparator.compare(this.heap[left(current)],\n                        this.heap[right(current)]) > 0)\n        {\n            right = true;\n        }\n\n\n        if (this.comparator.compare(temp, right ? this.heap[right(current)] \n                : this.heap[left(current)]) < 0)\n        {\n            break;\n        }\n\n        current = right ? right(current) : left(current);\n        this.heap[parent(current)] = this.heap[current];\n\n    } \n\n    this.heap[current] = temp;\n\n}\n```\n\n\nAnd the method for sifting up:\n\n```\nprivate void walkUp(int i) {\n\n    if (outOfBounds(i))\n    {\n        throw new IndexOutOfBoundsException(\"Index not in heap : \" + i);\n    }\n\n    int current = i;\n    Customer temp = this.heap[i];\n\n    while (current > 0) \n    {           \n        if (this.comparator.compare(this.heap[current],\n                    this.heap[parent(current)]) >= 0)\n        {\n            break;\n        }\n\n        this.heap[current] = this.heap[parent(current)];\n        current = parent(current);\n\n    }\n\n    this.heap[current] = temp;\n\n}\n```\n\n\nEDIT:\n\nThe compare method is defined as follows:\n\n```\n        @Override\n        public int compare(Customer cust1, Customer cust2) {\n\n            return cust1.priority() - cust2.priority();\n\n        }\n```\n\n    ", "Answer": "\r\nI ended up writing a method which executes the method above on every element in the heap, and that worked. It's not an elegant solution, but it gets the job done.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority queue with unordered linkedlist\r\n                \r\nI have the idea to implement priority queue with unordered linkedlist.\n\n```\n    public class UnorderedLinkedListMaxPQ<Key extends Comparable<Key>> {\n    private Node first;\n    private int n;                                        //number of elements\n    private class Node{\n        Key key;                                          //elements\n       Node next;   \n    }\n\n    public boolean isEmpty()               {return first==null;}\n    public int size()                      {return n;}\n    public void insert(Key key){\n        Node oldfirst=first;\n        first=new Node();\n        first.key=key;\n        first.next=oldfirst;\n        n++;\n    }\n\n    public Key delMax(){\n        Node node=first;\n        if(node==null) {return null;}\n        Key max=node.key;\n        while(node.next!=null){\n            Key data=node.next.key;\n            if(data.compareTo(max)>0){\n                max=data;\n            }\n            node=node.next;\n        }\n         first=first.next;\n          n--;\n        return max;\n    }\n\n    //Test Routine\n    public static void main(String[] args) {\n        UnorderedLInkedListMaxPQ<String> pq=new UnorderedLInkedListMaxPQ<String>();\n        pq.insert(\"this\");\n        pq.insert(\"is\");\n        pq.insert(\"a\");\n        pq.insert(\"test\");\n\n        for(int j=0;j<pq.n;j++){\n            StdOut.print(pq.delMax());\n            StdOut.println();\n\n        }\n    }\n}\n```\n\n\nI search the max element in the linkedlist,then return the maxest element.\nBut when I test,the output is ```\nthis this```\n which I suppose is ```\nthis test is a```\n.\n\nThere is something wrong with my implements?Any suggestions?\n    ", "Answer": "\r\nPerformance wise,this is not the best approach to implement a priority queue. I would recommend to keep an ordered list while inserting. By doing that way,you just have to delete the first to retrieve the max and not scan through the entire linked list.\n\nBut in case you want to stick with the current approach, modify the delMax() as follows:\n\n```\npublic Key delMax(){\n\n    if(first==null) \n        return null;\n    else if(n==1)\n        return first.key;\n    Node max=first,maxPrev=null,curr = max.next,prev = first;\n    while(curr!=null){\n        Key currMax = max.key;\n        Key nextKey = curr.key;\n        if(nextKey.compareTo(currMax)>0){\n            max = curr;\n            maxPrev = prev;\n        }\n        prev = curr;\n        curr = curr.next;\n    }\n    if(maxPrev!=null)\n        maxPrev.next=max.next;\n    else\n        first = max.next;\n    n--;\n    return max.key;\n}\n```\n\n\nAlso modify the following:\n\n```\nint k = pq.n;\nfor(int j=0;j<k;j++){\n    StdOut.print(pq.delMax());\n    StdOut.println();\n}\n```\n\n\nThis should return your desired output of ```\nthis test is a```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Constructing a priority queue of vectors\r\n                \r\nI am looking for a simple STL implementation of a priority queue of vectors. Each vector has exactly 4 elements. I want to sort my priority queue on the basis of the 3rd element of each vector. The vector with the lowest 3rd element should come at the top(min priority queue of vectors).\n\nHow to implement this in C++?\n\nAlso, if anybody has the actually STL implementation of default priority queue, please provide a link. Like the official implementation inside the STL.\n    ", "Answer": "\r\nYou have to create your own comparator to compare elements of the ```\npriority_queue```\n. \n\nSomething like this:\n\n```\n// How to compare elements\nstruct my_comparator\n{\n    // queue elements are vectors so we need to compare those\n    bool operator()(std::vector<int> const& a, std::vector<int> const& b) const\n    {\n        // sanity checks\n        assert(a.size() == 4);\n        assert(b.size() == 4);\n\n        // reverse sort puts the lowest value at the top    \n        return a[2] > b[2];\n    }\n};\n\n// for usability wrap this up in a type alias:\nusing my_priority_queue = std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, my_comparator>;\n\nint main()\n{\n    my_priority_queue mpq;\n\n    mpq.push({1, 2, 1, 4});\n    mpq.push({1, 2, 2, 4});\n    mpq.push({1, 2, 3, 4});\n\n    // etc ...\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Implementation in STL\r\n                \r\nI was looking at a piece of code, where I came across:\n\n```\npriority_queue<trainer, vector<trainer>, function<bool(trainer,trainer)> > p(comp);\n```\n\n\nhere, trainer is a user-defined struct and comp is a comparator function. I am having trouble understanding what the 3rd argument ```\nfunction<bool(trainer,trainer)>```\n mean and why is the comparator function in parantheses. \n\nFrom the documentation: Isn't the third parameter supposed to contain the comparator and the parantheses is supposed to pass a range of something?\n    ", "Answer": "\r\n```\npriority_queue```\n has three template parameters. A type, a container, and a comparison function.\n\nIn your example, the type is ```\ntrainer```\n, the container is ```\nvector<trainer>```\n, and the type of the comparison object is ```\nfunction<bool(trainer,trainer)>```\n.\n\nWhen you instantiate one of these things, you need to pass it a specific comparison function, and in this case that is ```\ncomp```\n. \n\nIf ```\ncomp```\n is just a function pointer, then it will be (implicitly) converted to a ```\nstd::function<bool(trainer, trainer)>```\n object, which will be used by the ```\npriority_queue```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Find minimum in array of numbers using Verilog for Priority Queue implementation\r\n                \r\nI'm quite a novice to Verilog, but I have an array of 16-elements (each element is 16-bits long) and I wish to find the minimum entry the array, return the minimum, and re-arrange all the entries in the array that come after the minimum so that the array is one contiguous block of entries. I know I have to use a comparator, but I really have no idea where to start with regards to comparing a large group of numbers and determining the minimum. \n\nEDIT: What I'm actually making is a priority queue. I have the queue functionality implemented, but instead of returning what's at the head of the queue, I want to return the entry with the smallest value, and keep the storage contiguous. \n\n```\ne.g. {2,3,4,1,5,6,-,-} \nmin is 1 --> {2,3,4,-,5,6,-,-} \nRearrange so everything following the returned min is moved to the index preceding it-->\n{2,3,4,5,6,-,-,-}\n```\n\n    ", "Answer": "\r\nA simple approach, if you don't have pressure to reduce the number of gates or LUTs, is to implement a tree-type structure.\n\nIf the entries in the queue are A0, A1, ... A7, do the following steps:\n\n\ncompute B0 = min (A0, A1), B1 = min (A2, A3), B2 = min (A4, A5), B3 = min (A6, A7)\ncompute C0 = min (B0, B1), C1 = min (B2, B3)\ncompute D = min (C0, C1)\n\n\nAt each step, also pass along the index of whichever entry is smaller.\n\nThis requires access to all the data simultaneously, so it implies the entire storage is in flip-flops, rather than RAM.\n\nGiven that all the data is in flip-flops, repacking isn't too hard, just create some logic to conditionally load each entry from the next higher entry in the storage, and decode the index of the element being removed into a vector enabling the shift-down for each entry above the element being removed.\n\nOne variable to play with if you want to make it more efficient is whether the comparison is done at enqueue or dequeue time. You may also want to consider whether repacking after each dequeue is really necessary.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do I priority Queue implementation using circular queue in C++?\r\n                \r\nGetting element value in the queue with the highest priority should be preferred.\n    ", "Answer": "\r\nYou can make a priority queue implemented as a binary min heap.  The keys of each entry could represent its \"priority\" and the lower the key, the more priority it has.  Thus, removing the root entry will return the entry with the highest priority.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Trying to Implement a priority queue in a different way\r\n                \r\nI am trying to implement a priority queue which functions a little bit different than normal priority queue.Here,the idea is to support fast insert, but slower access to the highest priority item. Insert method in this case places the new item wherever it is convenient;remove and peek methods must thus search through the entire queue for the highest priority item.\n\n```\npublic class MinPriorityQueue {\n\n/** Constructs a new MinPriorityQueue with capacity cap and size 0.\n * \n * @param cap Capacity of the new queue.\n */\npublic MinPriorityQueue(int cap) {         \n\n    this.queue = (Comparable []) new Comparable[cap];\n    this.size = 0;\n    this.cap = cap;\n}\n\nint size() {\n   return this.size;\n}\n\nint capacity() {\n   return this.cap;\n}\n\n boolean isEmpty() {\n   return this.size==0;\n}\n\nboolean isFull() {\n    return this.size == cap;       \n}\n\nvoid insert(Comparable e) {\n    if (this.size == cap) {\n        throw new IllegalStateException();\n    }\n    queue[size] = e;\n    size++;\n\n\n\nComparable remove() {\n\n    if (this.size == 0) {\n        throw new IllegalStateException();\n    }\n    int maxIndex = 0;\n    for (int i=1; i<size; i++) { \n        if (queue[i].compareTo (queue[maxIndex]) < 0) { \n            maxIndex = i; \n        } \n    } \n    Comparable result = queue[maxIndex]; \n    size--; \n    queue[maxIndex] = queue[size]; \n    return result;\n    }\n\n\n /** Returns, but does not remove, the lowest-priority item in the\n * queue.\n * \n * Complexity: O(n)\n * @return Lowest priority item.\n * @throws IllegalStateException if the queue is empty.\n */\nComparable top()  {\n           if (this.size == 0) {\n        throw new IllegalStateException();\n    }\n         /*  int i;\n           for (i=0; i < size; i++) {\n        if (queue[i].compareTo (size-1) < 0) {\n            break;\n        }\n    }\n           return queue[size - 1];*/\n    return  queue[size-1]; \n  }\n\n\n\nComparable[] queue; // Contents of the queue\n\nprivate  int cap;\nprivate int size;    \n\n}\n```\n\n\n//// Test File\n\n```\n /**\n     * Test of remove method, of class MinPriorityQueue.\n     */\n    @Test\n    public void testRemove() {\n    System.out.println(\"remove\");\n    MinPriorityQueue q = new MinPriorityQueue(10);\n\n    boolean throws_exception = false;\n    try {\n        q.remove();\n    } catch (IllegalStateException e) {\n        throws_exception = true;\n    } catch (Throwable e) {\n\n    }\n    assertTrue(\"remove throws an exception when empty\", throws_exception);\n\n    // Permutation of 0...9\n    int[] input = {0, 5, 9, 2, 3, 1, 6, 8, 7, 4};\n\n    for (int i : input) {\n        q.insert(i);\n    }\n\n    assertTrue(q.isFull());\n\n    for (int i = 10; i > 0; --i) {\n        assertEquals(q.size(), i);\n        Integer x = (Integer) q.remove();\n        assertEquals(x, new Integer(10 - i)); // Items are removed in correct order            \n    }\n\n    assertTrue(q.isEmpty());\n}\n\n/**\n * Test of top method, of class MinPriorityQueue.\n */\n@Test\npublic void testTop() {\n    System.out.println(\"top\");\n    MinPriorityQueue q = new MinPriorityQueue(10);\n\n    boolean throws_exception = false;\n    try {\n        q.top();\n    } catch (IllegalStateException x) {\n        throws_exception = true;\n    } catch (Throwable x) {\n\n    }\n    assertTrue(\"top throws an exception when empty\", throws_exception);\n\n    int[] input = {0, 5, 9, 2, 3, 1, 6, 8, 7, 4};\n    int smallest = 10;\n    for (int i : input) {\n        q.insert(i);\n        if (i < smallest) {\n            smallest = i;\n        }\n\n        assertEquals(q.top(), smallest);\n    }\n\n    for (int i = 0; i < 10; ++i) {\n        assertEquals(q.top(), i);\n        q.remove();\n    }\n}    \n```\n\n\nI have been able to implement all methods except remove and peek because i am unable to get the logic right to implement the methods.I am unable to figure out how we can search the entire queue to find the highest priority item.For this,i believe for loop should be used,but just not getting the logic right\n\nEDIT : I am able to get the logic right for remove() method,just need to get the pop() method to work\n    ", "Answer": "\r\nThe easiest way to achieve this is to use a ```\njava.util.List```\n instead of an ```\narray```\n. So the ```\nList```\n will keep the elements in the queue and handle the positioning of them without sorting them (so it still uses a fast insert). If you use the implementation ```\njava.util.ArrayList```\n for the ```\nList```\n interface it uses an ```\narray```\n internally so it's almost exactly what you were trying but easier, because someone else has already done most of the work...\n\nSo you could implement the class ```\nMinPriorityQueue```\n like this:\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\n//use a generic type argument T here that extends comparable so you can only store objects of a specific type that are comparable to each other\npublic class MinPriorityQueue<T extends Comparable<T>> {\n\n    private List<T> queue; // Contents of the queue\n\n    private int cap;\n    //private int size;\n\n    /**\n     * Constructs a new MinPriorityQueue with capacity cap and size 0.\n     * \n     * @param cap\n     *        Capacity of the new queue.\n     */\n    public MinPriorityQueue(int cap) {\n        this.queue = new ArrayList<T>(cap);\n        //this.size = 0;\n        this.cap = cap;\n    }\n\n    public int size() {\n        //return this.size;\n        return queue.size();\n    }\n\n    public int capacity() {\n        return this.cap;\n    }\n\n    public boolean isEmpty() {\n        //return this.size == 0;\n        return queue.isEmpty();\n    }\n\n    public boolean isFull() {\n        //return this.size == cap;\n        return queue.size() == cap;\n    }\n\n    public void insert(T e) {\n        if (queue.size() == cap) {\n            throw new IllegalStateException();\n        }\n        //queue[size] = e;\n        //size++;\n        queue.add(e);\n    }\n\n    /**\n     * Removes and returns the lowest-priority item from the queue.\n     * \n     * Complexity: O(n)\n     * \n     * @return Lowest priority item that was in the queue.\n     * @throws IllegalStateException\n     *         if the queue is empty.\n     */\n    public Comparable<T> remove() {\n        if (queue.size() == 0) {\n            throw new IllegalStateException();\n        }\n\n        /*for (int i = 0; i < this.size; i++) {\n            if (this.queue[i] == queue[size]) {\n                return i;\n            }\n        }\n        return queue[--size];*/\n\n        //initialize the lowest priority item with the first one in the list\n        int lowestPriorityIndex = 0;\n\n        //search every other item in the list to see whether it has a lower priority than the current lowest priority \n        for (int i = 1; i < queue.size(); i++) {\n            if (queue.get(i).compareTo(queue.get(lowestPriorityIndex)) < 0) {\n                lowestPriorityIndex = i;\n            }\n        }\n\n        //return and remove the lowest priority item\n        return queue.remove(lowestPriorityIndex);\n    }\n\n    /**\n     * Returns, but does not remove, the lowest-priority item in the queue.\n     * \n     * Complexity: O(n)\n     * \n     * @return Lowest priority item.\n     * @throws IllegalStateException\n     *         if the queue is empty.\n     */\n    public Comparable<T> top() {\n        if (queue.size() == 0) {\n            throw new IllegalStateException();\n        }\n        /*  int i;\n          for (i=0; i < size; i++) {\n        if (queue[i].compareTo (size-1) < 0) {\n           break;\n        }\n        }\n          return queue[size - 1];*/\n\n\n        //initialize the lowest priority item with the first one in the list\n        int lowestPriorityIndex = 0;\n\n        //search every other item in the list to see whether it has a lower priority than the current lowest priority \n        for (int i = 1; i < queue.size(); i++) {\n            if (queue.get(i).compareTo(queue.get(lowestPriorityIndex)) < 0) {\n                lowestPriorityIndex = i;\n            }\n        }\n\n        //return (but not remove) the lowest priority item\n        return queue.get(lowestPriorityIndex);\n    }\n}\n```\n\n\nThis code passes all of the test cases you provided in your question.\n\nI also added a generic type argument in the example code (therefore the class declaration is now ```\nMinPriorityQueue<T extends Comparable<T>>```\n), because it was needed to actually compare the elements. You can check about generic types here.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Dijkstra with a Priority Queue (Python)\r\n                \r\nI have been trying to use Dijkstra's algorithm with an implementation of a priority queue and a distance table, in Python.\nThis is the priority queue implementation:\n```\nfrom heapq import heapify, heappush, heappop\n\nclass priority_dict(dict):\n\n    def __init__(self, *args, **kwargs):\n        super(priority_dict, self).__init__(*args, **kwargs)\n        self._rebuild_heap()\n\n    def _rebuild_heap(self):\n        self._heap = [(v, k) for k, v in self.items()]\n        heapify(self._heap)\n\n    def smallest(self):\n        heap = self._heap\n        v, k = heap[0]\n        while k not in self or self[k] != v:\n            heappop(heap)\n            v, k = heap[0]\n        return k\n\n    def pop_smallest(self):\n        heap = self._heap\n        v, k = heappop(heap)\n        while k not in self or self[k] != v:\n            v, k = heappop(heap)\n        del self[k]\n        return k\n\n    def __setitem__(self, key, val):\n        super(priority_dict, self).__setitem__(key, val)\n        \n        if len(self._heap) < 2 * len(self):\n            heappush(self._heap, (val, key))\n        else:\n            self._rebuild_heap()\n\n    def setdefault(self, key, val):\n        if key not in self:\n            self[key] = val\n            return val\n        return self[key]\n\n    def update(self, *args, **kwargs):\n        super(priority_dict, self).update(*args, **kwargs)\n        self._rebuild_heap()\n\n    def sorted_iter(self):\n        while self:\n            yield self.pop_smallest()\n```\n\nAnd this is the Dijkstra implementation:\n```\nimport priority_dict\n\nfrom graph import *\n\ndef build_distance_table(graph, source):\n    distance_table = {}\n\n    for i in range(graph.numVertices):\n        distance_table[i] = (None, None)\n\n    distance_table[source] = (0, source)\n\n    priority_queue = priority_dict.priority_dict()\n\n    priority_queue[source] = 0\n\n    while len(priority_queue.keys()) > 0:\n        current_vertex = priority_queue.pop_smallest()\n\n        current_distance = distance_table[current_vertex][0]\n\n        for neighbor in graph.get_adjacent_vertices(current_vertex):\n            distance = current_distance + g.get_edge_weight(current_vertex, neighbor)\n\n            neighbor_distance = distance_table[neighbor][0]\n\n            if neighbor_distance is None or neighbor_distance > distance:\n                distance_table[neighbor] = (distance, current_vertex)\n\n                priority_queue = distance\n\n    return distance_table\n\ndef shortest_path(graph, source, destination):\n    distance_table = build_distance_table(graph, source)\n\n    path = [destination]\n\n    previous_vertex = distance_table[destination][1]\n\n    while previous_vertex and previous_vertex is not source:\n        path = [previous_vertex] + path\n\n        previous_vertex = distance_table[previous_vertex][1]\n    \n    if previous_vertex is None:\n        print(\"There is no path from %d to %d\" % (source, destination))\n    else:\n        path: [source] + path\n        print(\"Shortest path is: \", path)\n```\n\nThis is the result:\n```\nTraceback (most recent call last):\n  File \"dijkstra.py\", line 76, in <module>\n    shortest_path(g, 0, 6)\n  File \"dijkstra.py\", line 46, in shortest_path\n    distance_table = build_distance_table(graph, source)\n  File \"dijkstra.py\", line 23, in build_distance_table\n    while len(priority_queue.keys()) > 0:\nAttributeError: 'numpy.float64' object has no attribute 'keys'\n```\n\nI am using Python 3.7. I have searched online and though it had to do with the Python version. Can't figure why it doesn't see the attribute. Could you please tell me what am I missing?\n    ", "Answer": "\r\n```\npriority_queue = distance```\n\nShould have been:\n```\npriority_queue[neighbor] = distance```\n\nSolved it, thank you.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue implemented with a ConcurrentSkipListMap, unsure how to make consumers block on it\r\n                \r\nI have a priority queue implemented with a ConcurrentSkipListMap, using 16 different priorities.\n\n```\nclass ConcurrentPriorityQueue {\n\n    ConcurrentSkipListMap<Long, Message> queue = new ConcurrentSkipListMap<>();\n\n    AtomicLong counter16 = new AtomicLong(Long.MAX_VALUE);\n    AtomicLong counter15 = new AtomicLong(Long.MAX_VALUE / 8 * 7);\n    AtomicLong counter14 = new AtomicLong(Long.MAX_VALUE / 4 * 3);\n    // etc\n    AtomicLong counter1 = new AtomicLong(Long.MIN_VALUE / 8 * 7);\n\n    void addPriority16(Message message) {\n        queue.put(counter16.getAndDecrement(), message);\n    }\n\n    void addPriority15(Message message) {\n        queue.put(counter15.getAndDecrement(), message);\n    }\n\n    // and so on\n}\n```\n\n\nThis isn't exactly how the class is organized (e.g. I've got the AtomicLongs in an array), but I figured this code would be clearer.  There's also a DelayQueue to remove old messages or to raise the priority on old messages (depending on the message type).\n\nMy problem is that I've got several consumers that are using ```\npollLastEntry()```\n in order to remove the highest priority message from the queue and then sleeping if the queue is empty, but the thing is that queue activity goes in bursts - it will go an hour without containing more than a few messages, and then in the next hour it will never empty.  As such I'd like to use a blocking method to remove messages from the queue so that I don't waste resources on repeatedly sleeping threads (I'd use exponential backoff to make them sleep longer when there's less activity, but this would make them unresponsive when the queue starts up again), but am unclear as to the best way to go about implementing this - I have plenty of experience with using blocking queues, but zero experience with implementing them.  My first thought was to implement exponential backoff in the sleeping consumers and then interrupt them when queue activity starts up again, but I first wanted to see if there was a better way to do this.\n    ", "Answer": "\r\nI would implement a wrapper \n\n```\nclass Wrapper implements Comparable<Wrapper> {\n    long priority;\n    Message message;\n\n    Wrapper(long priority, Message message) {\n        this.priority = priority;\n        this.message = message;\n    }\n\n    @Override\n    public int compareTo(Wrapper w) {\n        return Long.compare(priority, w.priority);\n    }\n}\n```\n\n\nand used PriorityBlockingQueue instead of ConcurrentSkipListMap\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue with dynamic item priorities\r\n                \r\nI need to implement a priority queue where the priority of an item in the queue can change and the queue adjusts itself so that items are always removed in the correct order. I have some ideas of how I could implement this but I'm sure this is quite a common data structure so I'm hoping I can use an implementation by someone smarter than me as a base. \n\nCan anyone tell me the name of this type of priority queue so I know what to search for or, even better, point me to an implementation?\n    ", "Answer": "\r\nPriority queues such as this are typically implemented using a binary heap data structure as someone else suggested, which usually is represented using an array but could also use a binary tree. It actually is not hard to increase or decrease the priority of an element in the heap. If you know you are changing the priority of many elements before the next element is popped from the queue you can temporarily turn off dynamic reordering, insert all of the elements at the end of the heap, and then reorder the entire heap (at a cost of O(n)) just before the element needs to be popped. The important thing about heaps is that it only costs O(n) to put an array into heap order but O(n log n) to sort it.\n\nI have used this approach successfully in a large project with dynamic priorities.\n\nHere is my implementation of a parameterized priority queue implementation in the Curl programming language. \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I create priority queue that contains my class implementation?\r\n                \r\nI got task class that I implemented, I want to insert all my tasks into priority queue, there is one in python? Do I need to implement some func inside my class to make it comparable?\n\nEach class got priority number.\n    ", "Answer": "\r\nThere is indeed a priority queue in Python, see here: https://docs.python.org/3/library/queue.html#Queue.PriorityQueue\n\nHere is a simple example:\n\n```\nfrom queue import PriorityQueue\n\nq = PriorityQueue()\n\nq.put((2, 'code'))\nq.put((1, 'eat'))\nq.put((3, 'sleep'))\n\nwhile not q.empty():\n    next_item = q.get()\n    print(next_item)\n\n# Result:\n#   (1, 'eat')\n#   (2, 'code')\n#   (3, 'sleep')\n```\n\n\nYou can also use heapq as well. \n\nCan't comment on your implementation without knowing more information...\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java implement priority queue using binary heap errors\r\n                \r\nI have a homework problem as follows:\n\nCreated HeapPriorityQueue that will implement Priority queue\n\n```\nimport java.util.Arrays;  \n\npublic class HeapPriorityQueue<K,V extends Comparable<K>> implements PriorityQueue<K, V> {  \n    private static final int DEFAULT_CAPACITY = 10;  \n    protected K[] array;  \n    protected int size;  \n\n    /** \n     * Constructs a new BinaryHeap. \n     */  \n    @SuppressWarnings(\"unchecked\")  \n    public HeapPriorityQueue() {  \n        // Java doesn't allow construction of arrays of placeholder data types   \n        array = (K[])new Comparable[DEFAULT_CAPACITY];    \n        size = 0;  \n    }  \n\n\n    /** \n     * Adds a value to the min-heap. \n     */  \n    public void add(K value) {  \n        // grow array if needed  \n        if (size >= array.length - 1) {  \n            array = this.resize();  \n        }          \n\n        // place element into heap at bottom  \n        size++;  \n        int index = size;  \n        array[index] = value;  \n\n        bubbleUp();  \n    }  \n\n    /** \n     * Returns true if the heap has no elements; false otherwise. \n     */  \n    public boolean isEmpty() {  \n        return size == 0;  \n    }  \n\n\n    /** \n     * Returns (but does not remove) the minimum element in the heap. \n     */  \n    public K peek() {  \n        if (this.isEmpty()) {  \n            throw new InvalidKeyException(\"Invalid Key\");  \n        }  \n\n        return array[1];  \n    }  \n\n\n    /** \n     * Removes and returns the minimum element in the heap. \n     */  \n    public K remove() {  \n        // what do want return?  \n        K result = peek();  \n\n        // get rid of the last leaf/decrement  \n        array[1] = array[size];  \n        array[size] = null;  \n        size--;  \n\n        bubbleDown();  \n\n        return result;  \n    }  \n\n\n    /** \n     * Returns a String representation of BinaryHeap with values stored with  \n     * heap structure and order properties. \n     */  \n    public String toString() {  \n        return Arrays.toString(array);  \n    }  \n\n\n    /** \n     * Performs the \"bubble down\" operation to place the element that is at the  \n     * root of the heap in its correct place so that the heap maintains the  \n     * min-heap order property. \n     */  \n    protected void bubbleDown() {  \n        int index = 1;  \n\n        // bubble down  \n        while (hasLeftChild(index)) {  \n            // which of my children is smaller?  \n            int smallerChild = leftIndex(index);  \n\n            // bubble with the smaller child, if I have a smaller child  \n            if (hasRightChild(index)  \n                && array[leftIndex(index)].compareTo(array[rightIndex(index)]) > 0) {  \n                smallerChild = rightIndex(index);  \n            }   \n\n            if (array[index].compareTo(array[smallerChild]) > 0) {  \n                swap(index, smallerChild);  \n            } else {  \n                // otherwise, get outta here!  \n                break;  \n            }  \n\n            // make sure to update loop counter/index of where last el is put  \n            index = smallerChild;  \n        }          \n    }  \n\n\n    /** \n     * Performs the \"bubble up\" operation to place a newly inserted element  \n     * (i.e. the element that is at the size index) in its correct place so  \n     * that the heap maintains the min-heap order property. \n     */  \n    protected void bubbleUp() {  \n        int index = this.size;  \n\n        while (hasParent(index)  \n                && (parent(index).compareTo(array[index]) > 0)) {  \n            // parent/child are out of order; swap them  \n            swap(index, parentIndex(index));  \n            index = parentIndex(index);  \n        }          \n    }  \n\n\n    protected boolean hasParent(int i) {  \n        return i > 1;  \n    }  \n\n\n    protected int leftIndex(int i) {  \n        return i * 2;  \n    }  \n\n\n    protected int rightIndex(int i) {  \n        return i * 2 + 1;  \n    }  \n\n\n    protected boolean hasLeftChild(int i) {  \n        return leftIndex(i) <= size;  \n    }  \n\n\n    protected boolean hasRightChild(int i) {  \n        return rightIndex(i) <= size;  \n    }  \n\n\n    protected K parent(int i) {  \n        return array[parentIndex(i)];  \n    }  \n\n\n    protected int parentIndex(int i) {  \n        return i / 2;  \n    }  \n\n\n    protected K[] resize() {  \n        return Arrays.copyOf(array, array.length * 2);  \n    }  \n\n\n    protected void swap(int index1, int index2) {  \n        K tmp = array[index1];  \n        array[index1] = array[index2];  \n        array[index2] = tmp;          \n    }  \n\n    @Override  \n    public int size() {  \n        // TODO Auto-generated method stub  \n        return 0;  \n    }  \n\n    @Override  \n    public Entry<K, V> max() throws EmptyPriorityQueueException {  \n        // TODO Auto-generated method stub  \n        return null;  \n    }  \n\n    @Override  \n    public Entry<K, V> insert(K key, V value) throws InvalidKeyException {  \n        // TODO Auto-generated method stub  \n        return null;  \n    }  \n\n    @Override  \n    public Entry<K, V> extractMax() throws EmptyPriorityQueueException {  \n        // TODO Auto-generated method stub  \n        return null;  \n    }  \n\n}  \n```\n\n\nthis should implement this PriorityQueue\n\n```\n/** \n * Interface for the priority queue ADT \n *  \n * K is the key of the entry stored in the priority queue and denotes the priority of the entry. \n *  \n * V is the auxillary data of the entry \n * @author bryann \n * \n */  \npublic interface PriorityQueue<K extends Comparable<K>,V> {  \n    /** \n     * Returns the number of items in the priority queue \n     *  \n     * @return number of items in the priority queue \n     */  \n    public int size();  \n\n    /** \n     * Returns whether the priority queue is empty. \n     *  \n     * @return true if the priority queue is empty. Otherwise, false. \n     */  \n    public boolean isEmpty();  \n\n    /** \n     * Returns but does not remove an entry with maximum priority key \n     *   \n     * @return entry that has the highest priority key \n     * @throws EmptyPriorityQueueException \n     */  \n    public Entry<K,V> max() throws EmptyPriorityQueueException;  \n\n    /** \n     * Inserts a key-value pair and returns the entry created. \n     *  \n     * @param key priority key of the entry to be inserted \n     * @param value value of the entry to be inserted \n     * @return entry that was inserted into the priority queue \n     * @throws InvalidKeyException \n     */  \n    public Entry<K,V> insert(K key, V value) throws InvalidKeyException;  \n\n    /** \n     * Removes and returns an entry with maximum priority key \n     *  \n     * @return entry that has the highest priority key \n     * @throws EmptyPriorityQueueException \n     */  \n    public Entry<K,V> extractMax() throws EmptyPriorityQueueException;  \n}  \n```\n\n\nwhile the Driver class is this\n\n```\npublic class HeapPriorityQueueDriver {  \n\n    public static void main(String[] args) {  \n        PriorityQueue<Integer, String> queue = new HeapPriorityQueue<Integer, String>();  \n        queue.insert(0, \"Zero\");  \n        queue.insert(10, \"Ten\");  \n        queue.insert(1, \"One\");  \n        queue.insert(5, \"Five\");  \n        queue.insert(3, \"Three\");  \n        queue.insert(7, \"Seven\");  \n        queue.insert(9, \"Nine\");  \n\n        while(!queue.isEmpty()) {  \n            System.out.println(queue.extractMax());  \n        } // end while  \n    } // end main  \n}  \n```\n\n\nthe problems I get are\n\n```\nBound mismatch: The type String is not a valid substitute for the bounded parameter <V extends Comparable<K>> of the type HeapPriorityQueue<K,V> HeapPriorityQueueDriver.java   /MP7/src/simon/mp7  line 6  \nJava Problem \nBound mismatch: The type K is not a valid substitute for the bounded parameter <K extends Comparable<K>> of the type Entry<K,V> HeapPriorityQueue.java /MP7/src/simon/mp7   line 199    \nJava Problem \nBound mismatch: The type K is not a valid substitute for the bounded parameter <K extends Comparable<K>> of the type Entry<K,V> HeapPriorityQueue.java /MP7/src/simon/mp7   line 193    \nJava Problem \nBound mismatch: The type K is not a valid substitute for the bounded parameter <K extends Comparable<K>> of the type Entry<K,V> HeapPriorityQueue.java /MP7/src/simon/mp7   line 187    \nJava Problem \nThe method compareTo(K) is undefined for the type K HeapPriorityQueue.java  /MP7/src/simon/mp7  line 126    \nJava Problem \nThe method compareTo(K) is undefined for the type K HeapPriorityQueue.java  /MP7/src/simon/mp7  line 104    \nJava Problem \nThe method compareTo(K) is undefined for the type K HeapPriorityQueue.java  /MP7/src/simon/mp7  line 100    \nJava Problem \nBound mismatch: The type K is not a valid substitute for the bounded parameter <K extends Comparable<K>> of the type PriorityQueue<K,V> HeapPriorityQueue.java  /MP7/src/simon/mp7  line 5  \n\nthe message in the console is:\nException in thread \"main\" java.lang.Error: Unresolved compilation problem: \nBound mismatch: The type String is not a valid substitute for the bounded parameter <V extends Comparable<K>> of the type HeapPriorityQueue<K,V> \n\nat simon.mp7.HeapPriorityQueueDriver.main(HeapPriorityQueueDriver.java:6) \n```\n\n    ", "Answer": "\r\nYou declare ```\nHeapPriorityQueue<K,V extends Comparable<K>>```\n, but you try to use it as:\n\n```\nPriorityQueue<Integer, String> queue = new HeapPriorityQueue<Integer, String>();\n```\n\n\nBut ```\nString```\n doesn't ```\nextends Comparable<Integer>```\n so it gives you compilation error.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Limit size of the priority queue for Go's heap interface implementation\r\n                \r\nIn Java there is a PriorityQueue with size attribute. I'm expecting the same here (if I'm not wrong).\n\nUse case: Read millions of data one by one and send it to a priority queue. I want only the top 5 calculated elements so I want a heap/priority queue of size 5 only. \n\nI'm trying to use heap interface to achieve  this. As to what I see golang does dynamic array increase but this is not feasible in my case. \n\nI am referring to https://play.golang.org/p/wE413xwmxE\n\nHow can I achieve this?\n    ", "Answer": "\r\nIf you just want top M smallest elements from N elements then use the heap that would give you the biggest element and prune the heap whenever its size goes over value M. Then take elements from the heap in reverse order.\n\n```\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n    \"math/rand\"\n)\n\ntype IntHeap []int\n\nfunc (h IntHeap) Len() int           { return len(h) }\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *IntHeap) Push(x interface{}) {\n    *h = append(*h, x.(int))\n}\n\nfunc (h *IntHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nconst (\n    n = 1000000\n    m = 5\n)\n\nfunc main() {\n    h := &IntHeap{}\n    heap.Init(h)\n\n    for i := 0; i < n; i++ {\n        x := rand.Intn(n)\n        heap.Push(h,x)\n        if h.Len() > m {\n            heap.Pop(h)\n        }\n    }\n\n    r := make([]int, h.Len())\n    for i := len(r) - 1; i >= 0; i-- {\n        r[i] = heap.Pop(h).(int)\n    }\n    fmt.Printf(\"%v\\n\", r)\n}\n```\n\n\nThis algorithm has memory complexity of M and time complexity of N + N * log M + M * log M.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "implement a Linked List Priority Queue in C\r\n                \r\nHow would you go about implementing a priority queue using a linked list in C?\n\nThe typical linked list consists of ```\nhead```\n pointing to an element which points to another element(s), which eventually ends by ```\nNULL```\n or the linked list's tail. Example:\n\n```\n(Linked List | Head) ----> (Element | Next) ----> (Element | Next) ----> Null\n```\n\n\nIn the basic scenario, new elements are added to the list by using the First-In First-Out (add to the end of the list, remove from the front of the list) FIFO approach.\n\nIn my case however, a priority value must be taken into consideration. More specifically, each element can be assigned priority of 1, 2 or 3. Elements with the highest priority are added towards the front of the list while those with lower priority are added towards the back. Insertions into the list maintain the FIFO order of each priority.\n\nSo, if one is to enqueue the following elements one at a time:\n\n```\na 3, b 1, c 2, d 3, e 2\n```\n\n\nThe output should be: ```\na 3, d 3, c 2, e 2, b 1```\n (ordered by priority as well as the order of being added instead of the standard First-In First-Out approach which disregards the priority).\n\nHere is what I have, but it DOES NOT feature priority. How would you go about implementing a priority queue?\n\nhttp://codepad.org/BMeuSgNBxd\n\nOne way would be to use a sorting/priority algorithm. Besides the algorithm, some of the major unknowns/confusion for me is how and where the priority would be stored, would it be within the actual element such as:\n\n(Linked List | Head) ----> (a | 1 | Next) ----> (b | 2 | Next) ----> Null\n\nor \n\n```\n  q_enqueue(&q, \"a\", \"1\");\n  q_enqueue(&q, \"b\", \"2\");\n```\n\n\nand how would I go about comparing the priorities while working with the pointers to create the sorting algorithm.\n    ", "Answer": "\r\nIf you have  only three values of priority (or in more general - fixed range of priorities) why can't you implement three separate queues and write a wrapper functions that depending on the priority add/remove the element to certain queue?\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queues - Array based implementation\r\n                \r\nI am learning about stacks, queues, lists & hash tables from the book Data Structures using C and C++ by Tenenbaum. I am also spending time to take in OOPs essentials, to ensure they sink in well, so that I don't learn by osmosis/need-be basis in the future, and there are no knowledge gaps. \n\nThe author of the book suggests, that an array based implementation of the ascending & descending priority queues can be realized using circular, ordered arrays. The author leaves the implementation of the routines ```\ninsert()```\n and ```\nremove()```\n, as an exercise to the reader.\n\nI built a PriorityQueue class. My implementation of insert() and remove() routines is very cryptic. I produce the code verbatim for completeness(and not spamming). Could my implementation be better, readable and is it object oriented?\n\nYour tips would be of immense help. \n\n```\n#ifndef PQueue_H\n#define PQueue_H\n\n#include <cmath>\n#include <iostream>\n\nconst int maxsize = 5;\n\ntemplate <class T>\nclass PQueue\n{\n    T items[maxsize];\n    int front, rear,n;\n\npublic:\n    PQueue(T val);\n    PQueue(const PQueue<T>& q);\n    ~PQueue();\n    void insert(T x, int& overflow);\n    int search_position(T x);\n    T remove(int& underflow);\n    T first(int& underflow) const;\n    T last(int& underflow) const;\n    int size() const;\n    bool empty() const;\n    void print () const;\n    void increment(int& i);\n    void decrement(int& i);\n};\n\ntemplate <class T>\nPQueue<T>::PQueue(T val)\n{\n    for (int i = 0; i < maxsize; i++)\n        items[i] = val;\n\n    front = rear = maxsize - 1;\n    n = 0;\n}\n\ntemplate <class T>\nPQueue<T>::PQueue(const PQueue<T>& q)\n{\n    for (int i = 0; i < q.n; i++)\n    {\n        items[i] = q.items[i];\n    }\n    front = rear = maxsize - 1;\n    n = 0;\n}\n\ntemplate <class T>\nPQueue<T>::~PQueue() {};\n\ntemplate <class T>\nint PQueue<T>::search_position(T x)\n{\n    int low = front, high = rear;\n    int i;\n\n    if (empty()) {\n        return (rear+1)%maxsize;\n    }\n\n\n    for (i = (front+1)%maxsize; i != (rear+1)%maxsize; increment(i))\n    {   \n        if (items[i] > x)\n            break;\n    }\n    return i;\n}\n\ntemplate <class T>\nvoid PQueue<T>::insert(T x, int& overflow)\n{\n    overflow = 0;\n    if ((rear + 1) % maxsize == front)\n    {\n        overflow = 1;\n        return;\n    }\n    else\n    {\n        int index = search_position(x);\n        std::cout << \"\\nInserting item \" << x << \" at position \" << index;\n\n        increment(rear);\n\n        //If index matches the updated value of rear,\n        //there must be nothing to shift.\n        if(index!=rear)\n        {\n            int i = rear - 1, j = rear;\n            i += maxsize; i %= maxsize;\n            j += maxsize; j %= maxsize;\n\n            do\n            {\n                //Shift all elements 1 position to \n                //the right in item[index...rear]\n                items[j] = items[i];\n                std::cout << \"\\nShifting item \" << items[i] << \" from index \"\n                    << i << \" to \" << j;\n                decrement(i); \n                decrement(j);\n\n            } while (j != index);\n        }\n        n++;\n        items[index] = x;\n    }\n}\n\ntemplate <class T>\nT PQueue<T>::remove(int& underflow)\n{\n    underflow = 0;\n    if (empty())\n    {\n        underflow = 1;\n        return -1;\n    }\n    else\n    {\n        increment(front);\n\n        std::cout << \"\\nRemoving item \" << items[front] << \" from the front\";\n        n--;\n        return items[front];\n    }\n}\n\ntemplate <class T>\nT PQueue<T>::first(int& underflow) const\n{\n    if (empty())\n    {\n        underflow = 1;\n        return -1;\n    }\n    else\n    {\n        return items[(front + 1) % maxsize];\n    }\n}\n\ntemplate <class T>\nT PQueue<T>::last(int& underflow) const\n{\n    if (empty())\n    {\n        underflow = 1;\n        return -1;\n    }\n    else\n    {\n        return items[rear];\n    }\n}\n\ntemplate <class T>\nint PQueue<T>::size() const\n{\n    return n;\n}\n\ntemplate <class T>\nbool PQueue<T>::empty() const\n{\n    if (front == rear)\n        return true;\n    else\n        return false;\n}\n\ntemplate <class T>\nvoid PQueue<T>::print() const\n{\n    std::cout << \"\\nQueue items : \";\n    for (int i = (front + 1) % maxsize; i != (rear+1)%maxsize; i=(++i)%maxsize)\n    {\n        std::cout << \"items[\" << i << \"] = \" << items[i] << \"\\t\";\n    }\n}\n\ntemplate <class T>\nvoid PQueue<T>::increment(int& i)\n{\n    ++i;\n    i %= maxsize;\n}\n\ntemplate <class T>\nvoid PQueue<T>::decrement(int& i)\n{\n    --i;\n    i += maxsize; i %= maxsize;\n}\n\n\n#endif // !PriorityQueue_H\n```\n\n\nThanks,\n\nQuasar.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "why are priority queues implemented as binary heap?\r\n                \r\nWhy do people stress that heaps are used to implement priority queues because time complexity of peeking at max/min value is O(1) . \nCan't this be easily implented on a bst too , by using pointer to point at right most/left most node.  \n    ", "Answer": "\r\nGiven the fact that you propose a priority queue based on BST, I will try to explain you why a heap is better than a BST.\n\nA heap is a complete tree; it is a perfectly balanced tree. Its height is ```\nlog_2(n+1)```\n.\n\nA BST approach is worthwhile if this one is balanced. The best-known technique for maintaining a BST balanced is an AVL tree. This kind of tree  has a height bound of ```\n1.44 log_2(n+2) - 0.33```\n. \n\nFor the consultation of minimum you have a cost of ```\nO(log(n))```\n for a BST versus ```\nO(1)```\n for a heap. So for this operation the heap clearly is better.\n\nFor insertion and deletion the costs are asymptotically equivalent. But the BST tends to be more expensive because its height tends to be higher than a perfectly balanced tree. In addition, an AVL tree consumes more constant time than a heap. In the AVL (and also in other balancing approaches, red-black tree, treaps, splays, etc) you perform rotations, while with the heap you perform swaps, which are cheaper than rotations.\n\nDeletion on BST is a complicated and constantly expensive operation and could take ```\nO(log(n))```\n rotations. With a heap is ```\nO(log(n))```\n swaps, which recall are cheaper that rotations.\n\nEventually, in the case of an insertion, you could perform ```\nO(log(n))```\n swaps for the heap and at the most two rotations for the AVL. But with the insertion into an AVL you need to perform an unsuccessful search, while the heap you can directly insert the new key before starting to swap. I think that only with the insertion a BST could sometimes beat a heap. However, take in account that very probably you would use a priority queue for consultations and deletions; so, If this is the case, then surely you will recover the time you could lose when you made the insertions.\n\nIn addition, a heap is by far much easier to implement than a BST if you use an array which stores the level traversal of complete tree. In this case, you do not need pointers\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java - How to implement functions in a heap-based priority queue\r\n                \r\nFor a programming assignment, I have been working on creating a program that reads an input file and sorts the data inside using a self-made max heap priority queue. The data file has lines that either read \"insert [a name] [a number]\", or \"remove\". For this priority queue, we need to make a function for inserting and removing objects. Each object in the queue contains the name as a string, and the priority as a integer. I have to implement this heap based on an array with a size of 255.\n\nMy question is, I'm having difficulty implementing my insert and remove functions to work as specified. I'll provide 1) how they need to work, 2) pseudocode I've made, and 3) the actual Java code I've implemented. Both of my functions do not work exactly as I intend for them to, so I could use some direction from more experienced programmers.\n\n1) insert(name, priority): this function should take a name of type string and a priority of type integer, and inserts them into the priority queue.\n   remove(): this function should remove the object with the highest priority value and return the name string from the object.\n\n2) As background, I have three classes for this program: First, the \"main\" class containing implementation for reading the file and using the functions. Second, the \"name\" class, which creates the name object containing the name string and priority int , a constructor, and a compareTo method for comparing the priority values of two objects. Third, the \"priorityqueue\" class, contains the insert and remove functions. Now, here is the pseudocode I made for those two functions:\n\ninsert: \n\n\nCheck if the array is full (when num = 255), throw if true\nCreate the object from the input file with a name string and priority int\nInsert the object at num\nUse a while loop to swap the two objects at insertion\nUpdate num (num++)\n\n\nremove:\n\n\nSave the first object\nMove the last object to the first\nUpdate num (num--)\nUse a while loop to determine the larger child and return it.\n\n\n3) Here is the code I have so far. I'll provide my name and priority queue classes, in case my name class is what's giving me trouble.\n\nPriority Queue class:\n\n```\npublic class PriorityQueue \n{\nint num; //amount of things in array \nint idx; //index of current name object\nName[] names = new Name[255];\n\npublic void insert(String name, int priority)\n{\n    while (num != 255)\n    {\n        Name addName = new Name(name, priority);\n        names[num] = addName;\n        num++;\n\n        while(idx != 0 || names[idx].CompareTo(names[(idx-1)/2]))\n        {\n            Name temp = names[idx];\n            names[idx] = names[(idx-1)/2];\n            names[(idx-1)/2] = temp;\n\n            idx = (idx-1)/2;\n        }\n    }\n}\n\npublic Name remove()\n{\n    Name temp2 = names[0];\n    //Save first element\n\n    names[0] = names[idx];\n    //Move last element to first\n\n    num--;\n    while(idx < Math.max(2*idx+1,2*idx+2))\n    {\n        if(names[idx].CompareTo(names[(idx-1)/2]))\n                {\n                    Name temp3 = names[idx];\n                    names[idx] = names[(idx-1)/2];\n                    names[(idx-1)/2] = temp3;\n                }\n    }\n    return temp2;\n}\n```\n\n\n}\n\nName class:\n\n```\npublic class Name implements Comparable\n{\nString name;\nint priority;\n\npublic Name(String n, int i)\n{\n    name = n;\n    priority = i;\n}\n\npublic boolean CompareTo(Name obj)\n{\n    if(priority < obj.priority)\n    {\n        return false;\n    }\n\n    else if(priority > obj.priority)\n    {\n        return true;\n    }\n\n    return true;\n}\n}\n```\n\n\nI appreciate any help. Thanks!\n    ", "Answer": "\r\nSeveral problems. First, in your ```\ninsert```\n method:\n\n```\npublic void insert(String name, int priority)\n{\n    while (num != 255)\n    {\n        Name addName = new Name(name, priority);\n        names[num] = addName;\n        num++;\n\n        while(idx != 0 || names[idx].CompareTo(names[(idx-1)/2]))\n        {\n            Name temp = names[idx];\n            names[idx] = names[(idx-1)/2];\n            names[(idx-1)/2] = temp;\n\n            idx = (idx-1)/2;\n        }\n    }\n}\n```\n\n\nThe ```\nwhile (num != 255)```\n shouldn't be there. You should check to see if ```\nnum == 255```\n, and throw an exception if it is.\n\nThen, you need to initialize ```\nidx```\n. That is:\n\n```\n        Name addName = new Name(name, priority);\n        names[num] = addName;\n        idx = num;\n        num++;\n```\n\n\nAnd your ```\nwhile```\n condition should use ```\n&&```\n rather than ```\n||```\n. Otherwise you'll do the swap every time ```\nidx```\n is not equal to 0.\n\nIn your ```\nremove```\n method:\n\n```\npublic Name remove()\n{\n    Name temp2 = names[0];\n    //Save first element\n\n    names[0] = names[idx];\n    //Move last element to first\n\n    num--;\n    while(idx < Math.max(2*idx+1,2*idx+2))\n    {\n        if(names[idx].CompareTo(names[(idx-1)/2]) > 0)\n                {\n                    Name temp3 = names[idx];\n                    names[idx] = names[(idx-1)/2];\n                    names[(idx-1)/2] = temp3;\n                }\n    }\n    return temp2;\n}\n```\n\n\nYou don't want ```\nnames[idx]```\n there, because you don't know what ```\nidx```\n is. You want:\n\n```\nnames[0] = names[num-1]; // get last item in the heap\n```\n\n\nYour ```\nwhile```\n condition here is goofy. ```\nMath.max(2*idx+1,2*idx+2)```\n will always return ```\n2*idx+2```\n, unless ```\nidx```\n is negative. And, again, you haven't even initialized ```\nidx```\n. What you want here is:\n\n```\nidx = 0;\nwhile (idx < num)\n```\n\n\nNow, what you're trying to do is see if ```\nnames[idx]```\n is smaller than either of its children. And, if so, select the largest of the two children to swap it with. So:\n\n```\nwhile (idx < num)\n{\n    int largestChild = idx*2+1;\n    if (largestChild >= num) break; // idx is at a leaf level\n    if (largestChild+1 < num)\n    {\n        // compare the two children\n        if (names[largestChild].compareTo(names[largestChild+1]) < 0)\n        {\n            largestChild = largestChild+1;\n        }\n    }\n    if (names[idx] < names[largestChild])\n    {\n        // swap, moving the item down\n        temp = names[idx];\n        names[idx] = names[largestChild];\n        names[largestChild] = temp;\n        idx = largestChild;\n    }\n    else\n    {\n        // item is in the proper place\n        break;\n    }\n}\n```\n\n\nI would suggest making ```\nidx```\n a method-scoped variable in both methods. There's no need for it to be a global, and making it local to the methods forces you to initialize it before you use it, rather than potentially (as in your existing code) using a stale value.\n\nI think you need to change your ```\nName```\n class's ```\nCompareTo```\n function. The Comparable ```\ncompareTo```\n function must return:\n\n\n  a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\n\n\nSo you should have:\n\n```\npublic boolean CompareTo(Name obj)\n{\n    if(priority < obj.priority)\n    {\n        return -1;\n    }\n\n    if (priority > obj.priority)\n    {\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "using a priority queue\r\n                \r\nYou are developing the help desk application of a company. Request of issues will be stored to be served on a priority basis. For each issue, the name of the employee and the description will be stored. Make sure to add an integer to save priority. Insert issues and make the lowest priority be at the beginning of the queue. Implement a priority queue using C++ for issues. Create a menu with the options to add a new issue, service the issue with minimum priority number and any other relevant options. Use a priority queue for this.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority queue with redis\r\n                \r\nNow I have such a requirement, publish tasks to the task queue, and then take tasks from the task queue one by one and execute them. When the tasks are taken from the queue, they are taken according to the priority size, and the tasks with the larger priority are taken out first. If the priorities are the same, the ones that join the queue earlier are taken out first compared with the time they join the queue.\nThis can be done in java through priorityQueue:\n```\nPriorityQueue: new PriorityQueue<>((t1, t2) ->! t1.getPriority().equals(t2.getPriority()) ?  t2.getPriority() - t1.getPriority() :(t1.getTime() - t2.getTme())); \n```\n\nBut I want you to implement it in redis\nThis is the way I do it now, but it's a little crude and not very accurate\nenter image description here\n    ", "Answer": "\r\nYou solution is not thread-safe. You can try the following Lua script to implement the push part:\n```\n-- push.lua\n\nredis.replicate_commands()\n\nlocal key = KEYS[1]\nlocal task_id = ARGV[1]\nlocal priority = ARGV[2]\n\nlocal t = redis.call(\"time\")\nlocal time_s = t[1]\n\n-- original wrong answer: local score = priority * 10000000000 + time_s\nlocal score = priority * 10000000000 + (10000000000 - time_s)\n\nredis.call(\"zadd\", key, score, task_id)\n```\n\nPush some items into the priority queue:\n```\nredis-cli --eval push.lua queue , task-id priority\n```\n\nPop an item:\n```\nredis-cli zpopmax queue\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Implementation using arrays\r\n                \r\nPlease help me to understand the below-highlighted code block.\n```\npublic class PriorityQueue {\n    \n    int[] items = new int[10];\n    \n    int count;\n\n    public void enqueue(int i) {\n\n            int j;\n            \n            for(j= count-1;j >= 0; j--)\n            {\n                \n                \n                if(items[j] > i  )\n                {\n                    items[j+1] =items[j];\n                }\n                else\n                break;\n\n            }\n\n            System.out.println(\"J Value-->\"+j); \n            **items[j+1] = i;**\n        \n            count++;\n            \n            System.out.println(Arrays.toString(items));\n            System.out.println(count);\n\n    }\n}\n```\n\nAfter for loop how the value of 'J' is getting calculated.\n    ", "Answer": "\r\nThe code does not compile because you have some ```\n**```\n characters...\nBut ```\nj```\n starts at ```\ncount - 1```\n and decreases by 1 in every loop iteration. You only use ```\nj + 1```\n however.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Using heapsort vs js object to implement priority queue in javascript?\r\n                \r\nTrying to figure out which one is more optimal to use and implement.\n\nOne efficient way to implement a priority queue is heapsort O(n logn).\nEfficient way to implement Priority Queue in Javascript?\n\n\nAnother way I was thinking was to use js object. By inserting the priority value (integer/number) as the key in the js object.\nGiven that when going enumerating a js object in ES6 we can get keys that are integer indices (if applicable), in ascending order. Does ES6 introduce a well-defined order of enumeration for object properties?\nWe can possible use the js object with integer being keys as priority queue and end up with a runtime of O(n). Object.keys() complexity?\n\r\n\r\n```\nconst priorityQueue = {3:1,20:1,10:1,15:1,};\nconsole.log(Object.keys(priorityQueue));\npriorityQueue[5]=1;\nconsole.log(Reflect.ownKeys(priorityQueue));```\n\r\n\r\n\r\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Removing tail element of priority queue\r\n                \r\nHow can I remove the tail element of a priority queue? I am trying to implement beam search using a priority queue and once the priority queue is full, I want to remove the last element(the element with the least priority).\n\nThanks!\n    ", "Answer": "\r\nNo easy way. Copy elements from original to new except the last.\n```\nPriorityQueue removelast(PriorityQueue pq)\n{\n\n    PriorityQueue pqnew = new PriorityQueue();\n\n    while(pq.size() > 1)\n    {\n        pqnew.add(pq.poll());\n    }\n\n    pq.clear();\n    return pqnew;\n}\n```\n\ncalled as\n```\npq = removelast(pq);\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue reordering when editing elements\r\n                \r\nI'm trying to implement Dijkstra's algorithm for finding shortest paths using a priority queue. In each step of the algorithm, I remove the vertex with the shortest distance from the priority queue, and then update the distances for each of its neighbors in the priority queue. Now I read that a Priority Queue in Java won't reorder when you edit the elements in it (the elements that determine the ordering), so I tried to force it to reorder by inserting and removing a dummy vertex. But this doesn't seem to be working, and I'm stuck trying to figure it out. \n\nThis is the code for the vertex object and the comparator\n\n```\nclass vertex {\n    int v, d;\n    public vertex(int num, int dis) {\n        v=num;\n        d=dis;\n    }\n}\n\nclass VertexComparator implements Comparator {\n    public int compare (Object a, Object b) {\n        vertex v1 = (vertex)a;\n        vertex v2 = (vertex)b;\n        return v1.d-v2.d;\n    }\n }\n```\n\n\nHere is then where I run the algorithm:\n\n```\n    int[] distances=new int[p];\n    Comparator<vertex> comparator = new VertexComparator();\n    PriorityQueue<vertex> queue = new PriorityQueue<vertex>(p, comparator);\n    for(int i=0; i<p; i++) {\n        if(i!=v) {\n            distances[i]=MAX;\n        }\n        else {\n            distances[i]=0;\n        }\n        queue.add(new vertex(i, distances[i]));\n    }\n    // run dijkstra\n    for(int i=0; i<p; i++) {\n        vertex cur=queue.poll();\n        Iterator itr = queue.iterator();\n        while(itr.hasNext()) {\n            vertex test = (vertex)(itr.next());\n            if(graph[cur.v][test.v]!=-1) {\n                test.d=Math.min(test.d, cur.d+graph[cur.v][test.v]);\n                distances[test.v]=test.d;\n            }\n        }\n        // force the PQ to resort by adding and then removing a dummy vertex\n        vertex resort = new vertex(-1, -1);\n        queue.add(resort);\n        queue.remove(resort);\n    }\n```\n\n\nI've run several text cases, and I know that the priority queue isn't reordering correctly each time I go through and update the distances for vertices, but I don't know why. Did I make an error somewhere?\n    ", "Answer": "\r\nAs you discovered, a priority queue does not resort all elements whenever an element is added or removed. Doing that would be too expensive (remember the n log n lower bound for comparison sort), while any reasonable priority queue implementation (including ```\nPriorityQueue```\n) promises to add/remove nodes in O(log n). \n\nIn fact, it doesn't sort its elements at all (that's why its iterator can not promise to iterate elements in sorted order).\n\n```\nPriorityQueue```\n does not offer an api to inform it about a changed node, as that would require it to provide efficient node lookup, which its underlying algorithm does not support. Implementing a priority queue that does is quite involved. The Wikipedia article on PriorityQueues might be a good starting point for reading about that. I am not certain such an implementation would be faster, though.\n\nA straightforward idea is to remove and then add the changed node. Do not do that as ```\nremove()```\n takes O(n). Instead, insert another entry for the same node into the PriorityQueue, and ignore duplicates when polling the queue, i.e. do something like:\n\n```\nPriorityQueue<Step> queue = new PriorityQueue();\n\nvoid findShortestPath(Node start) {\n    start.distance = 0;\n    queue.addAll(start.steps());\n\n    Step step;\n    while ((step = queue.poll()) != null) {\n        Node node = step.target;\n        if (!node.reached) {\n            node.reached = true;\n            node.distance = step.distance;\n            queue.addAll(node.steps());\n        }\n    }\n\n}\n```\n\n\nEdit: It is not advisable to change the priorities of elements in the PQ, hence the need to insert ```\nStep```\ns instead of ```\nNode```\ns.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Insertion into a priority queue implemented by doubly linked list with sentinels\r\n                \r\nI am writing a priority queue using doubly linked list with sentinels\n\n```\nclass Node {\n    protected Node next;\n    protected Node prev;\n    protected int value;\n    public Node() {\n    }\n    public Node(int value) {\n        this.value = value;\n    }\n}\n```\n\n\nThis is my node class where I have set a condition that the Value lies between 0 and 11111 for ease in sorting.\n\n```\npublic class someName {\n    protected Node firstSentinel;\n    protected Node lastSentinel;\n\n    public someName() {\n        firstSentinel = new Node();\n        lastSentinel = new Node();\n        firstSentinel.value = 11111;\n        lastSentinel.value = 0;\n        firstSentinel.prev = null;\n        firstSentinel.next = lastSentinel;\n        lastSentinel.prev = firstSentinel;\n        lastSentinel.next = null;\n    }\n\n    public void enQueue(Node x) {\n        if (firstSentinel.next == lastSentinel)// list is empty\n        {\n            firstSentinel.next = x;\n            x.prev = firstSentinel;\n            x.next = lastSentinel;\n            lastSentinel.prev = x;\n        } else {\n            Node temp = x;\n            Node curr = firstSentinel.next;\n            while (curr != lastSentinel && temp.value <= curr.value) {\n                curr = curr.next;\n            }\n            Node tempCurr = curr;\n            temp.next = tempCurr;\n            temp.prev = tempCurr.prev;\n            tempCurr.prev = temp;\n            tempCurr.prev.next = temp;\n        }\n    }\n\n    public Node deQueue() {\n        if (firstSentinel.next == lastSentinel) {\n            return null;\n        } else {\n            Node temp = new Node();\n            temp = firstSentinel.next;\n            firstSentinel.next = temp.next;\n            temp.next.prev = firstSentinel;\n            return temp;\n        }\n    }\n\n    public void printt() {\n        Node temp = new Node();\n        temp = firstSentinel.next;\n        while (temp != lastSentinel) {\n            System.out.println(temp.value);\n            temp = temp.next;\n        }\n    }\n\n    public static void main(String[] args) {\n        someName PQ = new someName();\n        Node a = new Node(2);\n        PQ.enQueue(a);\n        PQ.printt();\n        Node aa = new Node(456);\n        PQ.enQueue(aa);\n        Node aaa = new Node(123);\n        PQ.enQueue(aaa);\n        PQ.printt();\n        Node aaaa = new Node(6);\n        PQ.enQueue(aaaa);\n        PQ.printt();\n        Node aaaaa = new Node(1123);\n        PQ.enQueue(aaaaa);\n        PQ.printt();\n    }\n}\n```\n\n\nWhen the program is run it just outputs twos. Which makes be believe that only 1 node(first node especially) is getting inserted. In this priority queue i am interested in descending order and as such the first sentinel value is being set to 11111 and last's is being set to 0. I think I am doing something stupid in enqueue. I will be glad if someone points me in the right direction. \n    ", "Answer": "\r\nYour ```\nenQueue```\n method appears to be flawed:\n\n```\npublic void enQueue(Node x) {\n    if (firstSentinel.next == lastSentinel)// list is empty\n    {\n        firstSentinel.next = x;\n        x.prev = firstSentinel;\n        x.next = lastSentinel;\n        lastSentinel.prev = x;\n    } else {\n        Node temp = x;\n        Node curr = firstSentinel.next;\n        while (curr != lastSentinel && temp.value <= curr.value) {\n            curr = curr.next;\n        }\n        Node tempCurr = curr;\n        temp.next = tempCurr;\n        temp.prev = tempCurr.prev;\n        tempCurr.prev = temp;\n        // Think very carefully what this next line does.\n        // You've just overwritten tempCurr.prev with temp.\n        // This means you've now assigned temp.next = temp\n        // That's going to create a cycle.\n        tempCurr.prev.next = temp;\n    }\n}\n```\n\n\nIf you simply reorder that line to above the assignment, then it may work as you intend:\n\n```\npublic void enQueue(Node x) {\n    if (firstSentinel.next == lastSentinel)// list is empty\n    {\n        firstSentinel.next = x;\n        x.prev = firstSentinel;\n        x.next = lastSentinel;\n        lastSentinel.prev = x;\n    } else {\n        Node temp = x;\n        Node curr = firstSentinel.next;\n        while (curr != lastSentinel && temp.value <= curr.value) {\n            curr = curr.next;\n        }\n        Node tempCurr = curr;\n        temp.next = tempCurr;\n        temp.prev = tempCurr.prev;\n        tempCurr.prev.next = temp;\n        // Note here that the assignment to tempCurr.prev happens\n        // after the assignment to tempCurr.prev.next\n        tempCurr.prev = temp;\n    }\n}\n```\n\n\nNote that you can also simplify your logic in ```\nenQueue```\n dramatically by dropping the ```\nif```\n entirely. Your current ```\nelse```\n case can handle both the empty and non-empty cases (at least once you've fixed the bug I've pointed out.) You also don't need the ```\ntemp```\n variable.\n\n```\npublic void enQueue(Node x) {\n    Node curr = firstSentinel.next;\n    while (curr != lastSentinel && x.value <= curr.value) {\n        curr = curr.next;\n    }\n    Node tempCurr = curr;\n    x.next = tempCurr;\n    x.prev = tempCurr.prev;\n    tempCurr.prev.next = x;\n    tempCurr.prev = x;\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Heap implementation of priority queue?\r\n                \r\nI'm trying to implement a queue of patients using a heap (with root smaller than children) but when I print the queue, the queue of patients doesn't look prioritized. \n\nInsertion method works fine but it's the ```\nenqueue```\n that doesn't prioritize items?\n\n```\n// Heap class\n.....some code\n\n//insertion: inserts patients into minimum heap using an array.\n//expand array as needed and reorder heap to maintain its properties\n\npublic void insert(ER_Patient patient) {\n    if(heapArray.length==count)\n        expand();\n    heapArray[count] = patient;\n    count++;\n    if(count>1)\n        reorder();\n}\n\n// Priority Queue class\n.......some code\n\npublic void enqueue(ER_Patient patient) {\n    try {\n        heap.insert(patient);\n    } catch (NoSuchCategoryException exception) {\n        System.out.println(\"Can't enqueue\");\n    }\n\n}\n\n// copy content of original's array to a new larger array\nprivate void expand(){\n    ER_Patient[] tempArray = new ER_Patient[heapArray.length * 8];\n    for(int i=0;i<=heapArray.length-1;i++)\n        tempArray[i]=heapArray[i];\n    heapArray = tempArray;\n}\n\n// maintain heap property by keeping roots smaller than children\nprivate void reorder(){\n    ER_Patient temp;\n    int next = count -1;\n    temp = heapArray[next];\n    while((next!=0) && temp.compareTo(heapArray[(next-1)/2])<0){\n        heapArray[next] = heapArray[(next-1)/2];\n        next = (next-1)/2;\n    }\n    heapArray[next] = temp;\n}\n```\n\n    ", "Answer": "\r\n\n  This is how I print:\n\n\n```\npublic void display(Heap h)\n{\n    for(int i=0;i<h.count;i++)\n        System.out.println(heapArray[i]);\n}\n```\n\n\nWrong.\n\nUnless you successively remove the first item and print it, you won't get an ordered listing. The heap array itself isn't sequential.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "how to implement string priority queue with checking message priority\r\n                \r\nMessenger is used to send or receive text\nmessages. When someone is offline a messenger\nmaintains a buffer of messages which is delivered\nto the receiver when he gets online.\nThe phenomena take place on simple\ntimestamp phenomena, the message delivered\nearlier will be sent to the receiver first and the\nmessage received late will be delivered after it.\nSometime a message in the buffer may have higher\npriority so it should be delivered earlier on the\nhigher priority. Some of the messages are to be\ndelivered on a particular day or a date are also in\nthe same buffer. Your task is to select a suitable\ndata structure (Heap or Priority Queue) and\nimplement the requirements mentioned above.\nYou need to implement program which\nshows a user to be offline, display the messages,\nwith a click or a key stroke make the user online\nand deliver/display the messages according to the\nmentioned criteria.\nI dont understand how to check priority\n    ", "Answer": "\r\nSounds to me like your code that orders the heap has to check two things when assigning priority. It checks the ```\npriority```\n flag (the one that signals that a message must be delivered sooner than normal), and the timestamp.\nSo your comparison function looks something like:\n```\n// returns -1, 0, 1 to indicate if msg1 is less than, equal to,\n// or greater than msg2.\nint compare(msg1, msg2)\n{\n    if (msg1.priority == true)\n    {\n        if (msg2.priority == false)\n            return -1; // msg1 has priority flag set and msg2 doesn't\n    }\n    else if (msg2.priority == true)\n        return 1; // msg2 has priority flag set and msg1 doesn't\n    // At this point, we know that the priority flag is the same\n    // for both messages.\n    // So compare timestamps.\n    if (msg1.timestamp < msg2.timestamp)\n        return -1;\n    if (msg1.timestamp == msg2.timestamp)\n        return 0;\n    return 1;\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ What's the best way to implement a Priority Queue with varying priority functions?\r\n                \r\nThe accepted answer  I've seen for swapping out a priority queue comparator is to overload the operator in a new compare class.\n```\nclass Foo\n{\n\n};\n\nclass Compare\n{\npublic:\n    bool operator() (Foo, Foo)\n    {\n        return true;\n    }\n};\n\nint main()\n{\n    std::priority_queue<Foo, std::vector<Foo>, Compare> pq;\n    return 0;\n}\n```\n\nHowever, I want to implement several (10+) different compare functions for queue and choose one at run time when pq is created in main(). Do I have to make 10 different compare classes or is there an easier way to do this?\n    ", "Answer": "\r\n\nDo I have to make 10 different compare classes or is there an easier way to do this?\n\nYou don't have to. The priority_queue requires that the comparator taking a ```\nFoo```\n and return ```\nbool```\n - with the default one is ```\nstd::less```\n\n```\ntemplate<\n    class T,\n    class Container = std::vector<T>,\n    class Compare = std::less<typename Container::value_type>\n> class priority_queue;\n```\n\nIn your case, you may use a lambda, or a pointer to function for that purpose. For example,\n```\nusing cmp1 = bool(*)(const Foo&, const Foo&);\nbool FooCmp1(const Foo& f1, const Foo& f2)\n{\n     // do real comparison..\n     return true;\n}\n\npriority_queue<Foo, std::vector<Foo>, cmp1> pq(FooCmp1);\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Event driven simulation using priority queue implemented with binary heap\r\n                \r\nI need to simulate the execution of a set of tasks that are given. \nThis means that you need to keep track of which tasks are active at any given point in time, and remove them from the active list as they finish.\n\nI need to use priority queue for this problem, to be implemented using binary heap. \n\nThe input consists of a set of tasks given in increasing order of start time, and each task has a certain duration associated. \nThe first line is number of tasks, for example\n\n```\n3\n2 5\n4 23\n7 4\n```\n\n\nThis means that there are 3 tasks. The first one starts at time 2, and ends at 7 (2+5). Second starts at 4, ends at 27. Third starts at 7, ends at 11.\n\nWe can keep track of number of active tasks:\n\n```\nTime       #tasks\n0 - 2        0\n2 - 4        1\n4 - 11       2\n11 - 27      1\n```\n\n\nI need to find: \n\n\nMax number of active tasks at any given time (2 in this case) and \nAverage number of active tasks over the entire duration computed here as :\n\n\n[ 0*(2-0) + 1*(4-2) + 2*(11-4) + 1*(27-11) ] / 27\n\nI've written the following code to read in the time values into a structure:\n\n```\n#include \"stdio.h\"\n#include \"stdlib.h\"\n\ntypedef struct\n{\n    long int start;\n    long int end;\n    int dur;\n} task;\n\nint main()\n{\n    long int num_tasks;\n    scanf(\"%ld\",&num_tasks);\n    task *t = new task[num_tasks];\n    for (int i=0;i<num_tasks;i++)\n    {\n        scanf(\"%ld %d\",&t[i].start,&t[i].dur);\n        t[i].end = t[i].start + t[i].dur;\n    }\n}\n```\n\n\nI would like to understand how this can be implemented as a heap priority queue and to obtain the necessary outputs from the heap.\n    ", "Answer": "\r\nSince you said pseudocode would be sufficient for you, I'm taking you at your word. The following is implemented in Ruby, which is like runnable pseudo-code.  I've also commented it fairly extensively.\n\nThe approach outlined here only needs one priority queue.  Your model conceptually revolves around two events - when a task starts, and when it ends.  A very flexible discrete-event implementation mechanism is to use a priority queue to store event notices, ordered by the time the event will fire.  Each event is implemented as a separate method/function which does whatever state transitions are associated with the event, and can schedule further events by putting their event notices on the priority queue.  You then need an executive loop which keeps pulling event notices off the priority queue, updates the clock to the current event's time, and invokes the corresponding event method.  For more information on this approach, see this paper.  The paper implements these concepts in Java, but they can be (and are) implemented in lots of other languages.\n\nWithout further ado, here's a working implementation for your case:\n\n```\n# User needs to type \"gem install simplekit\" on the command line to\n# snag a copy of this library from the public gem repository\nrequire 'simplekit' # contains a PriorityQueue implementation\n\n# define an \"event notice\" structure which stores the tag for an event method,\n# the time the event should occur, and what arguments are to be passed to it.\nEVENT_NOTICE = Struct.new(:event, :time, :args) {\n  include Comparable\n  def <=>(other)    # define a comparison ordering based on my time vs other's time\n    return time - other.time  # comparison of two times is positive, zero, or negative\n  end\n}\n\n@pq = PriorityQueue.new    # @ makes globally shared (not really, but close enough for illustration purposes)\n@num_tasks = 0      # number of tasks currently active\n@clock = 0          # current time in the simulation\n\n# define a report method\ndef report()\n  puts \"#{@clock}: #{@num_tasks}\"  # print current simulation time & num_tasks\nend\n\n# define an event for starting a task, that increments the @num_tasks counter\n# and uses the @clock and task duration to schedule when this task will end\n# by pushing a suitable EVENT_NOTICE onto the priority queue.\ndef start_task(current_task)\n  @num_tasks += 1\n  @pq.push(EVENT_NOTICE.new(:end_task, @clock + current_task.duration, nil))\n  report()\nend\n\n# define an event for ending a task, which decrements the counter\ndef end_task(_)   # _ means ignore any argument\n  @num_tasks -= 1\n  report()\nend\n\n# define a task as a suitable structure containing start time and duration\ntask = Struct.new(:start, :duration)\n\n# Create a set of three tasks.  I've wired them in, but they could\n# be read in or generated dynamically.\ntask_set = [task.new(2, 5), task.new(4, 23), task.new(7, 4)]\n\n# Add each of the task's start_task event to the priority queue, ordered\n# by time of occurrence (as specified in EVENT_NOTICE)\nfor t in task_set\n  @pq.push(EVENT_NOTICE.new(:start_task, t.start, t))\nend\n\nreport()\n# Keep popping EVENT_NOTICE's off the priority queue until you run out. For\n# each notice, update the @clock and invoke the event contained in the notice\nuntil @pq.empty?\n  current_event = @pq.pop\n  @clock = current_event.time\n  send(current_event.event, current_event.args)\nend\n```\n\n\nI used Ruby because while it looks like pseudocode, this actually runs and produces the following output:\n\n```\n0: 0\n2: 1\n4: 2\n7: 1\n7: 2\n11: 1\n27: 0\n```\n\n\n\n\n\n\nC IMPLEMENTATION\n\nI finally broke loose some time to brush up on twenty year old skills and implement this in C.  The structure is very similar to that of Ruby, but there are a lot more details that need to be managed.  I've factored this into the model, the simulation engine, and the heap to show that the executive loop is distinct from the specifics of any particular model. Here is the model implementation itself, which illustrates the \"events are functions\" orientation of building a model.\n\nmodel.c\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include \"sim_engine.h\"\n\n// define a task as a suitable structure containing start time and duration\ntypedef struct {\n  double start;\n  double duration;\n} task;\n\n// stamp out new tasks on demand\ntask* new_task(double start, double duration) {\n  task* t = (task*) calloc(1, sizeof(task));\n  t->start = start;\n  t->duration = duration;\n  return t;\n}\n\n// create state variables\nstatic int num_tasks;\n\n// provide reporting\nvoid report() {\n  // print current simulation time & num_tasks\n  printf(\"%8.3lf: %d\\n\", sim_time(), num_tasks);\n}\n\n// define an event for ending a task, which decrements the counter\nvoid end_task(void* current_task) {\n  --num_tasks;\n  free(current_task);\n  report();\n}\n\n// define an event for starting a task, that increments the num_tasks counter\n// and uses the task duration to schedule when this task will end.\nvoid start_task(void* current_task) {\n  ++num_tasks;\n  schedule(end_task, ((task*) current_task)->duration, current_task);\n  report();\n}\n\n// all event graphs must supply an initialize event to kickstart the process.\nvoid initialize() {\n  num_tasks = 0;      // number of tasks currently active\n  // Create an initial set of three tasks.  I've wired them in, but they could\n  // be read in or generated dynamically.\n  task* task_set[] = {\n    new_task(2.0, 5.0), new_task(4.0, 23.0), new_task(7.0, 4.0)\n  };\n  // Add each of the task's start_task event to the priority queue, ordered\n  // by time of occurrence.  In general, though, events can be scheduled\n  // dynamically from trigger events.\n  for(int i = 0; i < 3; ++i) {\n    schedule(start_task, task_set[i]->start, task_set[i]);\n  }\n  report();\n}\n\nint main() {\n  run_sim();\n  return 0;\n}\n```\n\n\nNote the strong similarity in layout to the Ruby implementation.  Other than having floating point time, the output is identical to the Ruby version.  (Ruby would have given decimal places as well if they were needed, but with the trial tasks given by OP that wasn't necessary.)\n\nNext are the simulation engine headers and implementation.  Note that this is designed to isolate the model builder from direct use of the priority queue.  The details are handled by a ```\nschedule()```\n front-end to put things into the event list, and the executive loop to extract and run things at the correct point in time.\n\nsim_engine.h\n\n```\ntypedef void (*event_p)(void*);\n\nvoid initialize();\nvoid schedule(event_p event, double delay, void* args);\nvoid run_sim();\ndouble sim_time();\n```\n\n\nsim_engine.c\n\n```\n#include <stdlib.h>\n#include \"sim_engine.h\"\n#include \"heap.h\"\n\ntypedef struct {\n  double time;\n  event_p event;\n  void* args;\n} event_notice;\n\nstatic heap_t *event_list;\nstatic double sim_clock;\n\n// return the current simulated time on demand\ndouble sim_time() {\n  return sim_clock;\n}\n\n// schedule the specified event to occur after the specified delay, with args\nvoid schedule(event_p event, double delay, void* args) {\n  event_notice* en = (event_notice*) calloc(1, sizeof(event_notice));\n  en->time = sim_clock + delay;\n  en->event = event;\n  en->args = args;\n  push(event_list, en->time, en);\n}\n\n// simulation executive loop.\nvoid run_sim() {\n  event_list = (heap_t *) calloc(1, sizeof(heap_t));\n  sim_clock = 0.0;     // initialize time in the simulation\n\n  initialize();\n\n  // Keep popping event_notice's off the priority queue until you run out. For\n  // each notice, update the clock, invoke the event contained in the notice,\n  // and cleanup.\n  while(event_list->len > 0) {\n    event_notice* current_event = pop(event_list);\n    sim_clock = current_event->time;\n    current_event->event(current_event->args);\n    free(current_event);\n  }\n}\n```\n\n\nAnd finally, the priority queue implementation lifted whole-hog from Rosetta Code, refactored, and switched to use ```\nvoid*```\n for the data payload rather than strings.\n\nheap.h\n\n```\ntypedef struct {\n    double priority;\n    void *data;\n} node_t;\n\ntypedef struct {\n    node_t *nodes;\n    int len;\n    int size;\n} heap_t;\n\nvoid push(heap_t *h, double priority, void *data);\nvoid *pop(heap_t *h);\n```\n\n\nheap.c\n\n```\n#include <stdlib.h>\n#include \"heap.h\"\n\nvoid push(heap_t *h, double priority, void *data) {\n    if (h->len + 1 >= h->size) {\n        h->size = h->size ? h->size * 2 : 4;\n        h->nodes = (node_t *)realloc(h->nodes, h->size * sizeof (node_t));\n    }\n    int i = h->len + 1;\n    int j = i / 2;\n    while (i > 1 && h->nodes[j].priority > priority) {\n        h->nodes[i] = h->nodes[j];\n        i = j;\n        j = j / 2;\n    }\n    h->nodes[i].priority = priority;\n    h->nodes[i].data = data;\n    h->len++;\n}\n\nvoid *pop(heap_t *h) {\n    int i, j, k;\n    if (!h->len) {\n        return NULL;\n    }\n    void *data = h->nodes[1].data;\n\n    h->nodes[1] = h->nodes[h->len];\n\n    h->len--;\n\n    i = 1;\n    while (i!=h->len+1) {\n        k = h->len+1;\n        j = 2 * i;\n        if (j <= h->len && h->nodes[j].priority < h->nodes[k].priority) {\n            k = j;\n        }\n        if (j + 1 <= h->len && h->nodes[j + 1].priority < h->nodes[k].priority) {\n            k = j + 1;\n        }\n        h->nodes[i] = h->nodes[k];\n        i = k;\n    }\n    return data;\n}\n```\n\n\nBottom line: This event scheduling approach is extremely flexible, and pretty straightforward to implement given implementations for a priority queue and the simulation engine.  As you can see, the engine is actually pretty trivial.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Advanced priority queue\r\n                \r\nI'm looking for an implementation of priority queue in C++.\nBesides the basic functionality in STL priority queue, it requires the following methods:\n\n\nIt can remove all same elements (determined by a function) when pushing (Similar to a set)\nIt can filter out some elements (determined by another function).\n\n\nDo you have some suggestions on how to implement it?\n    ", "Answer": "\r\nYou can use ```\nstd::set```\n as a priority queue without duplicates. The ```\ntop```\n element can be found through ```\nrbegin()```\n. Asymptotic complexity is the same as for a binary heap: O(1) ```\ntop```\n per the Standard requirements for ```\nrbegin```\n, O(lg n) ```\npush```\n and O(lg n) ```\npop```\n. The constants will be higher, though.\n\nAs for the filter, I suggest you wrap ```\nstd::set```\n in a class with a custom ```\npush```\n method (which is a good idea anyway) that runs the filtering predicate for you.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Single Source Shortest Path implementation: priority vs. FIFO queue\r\n                \r\nDepending on the problem specifics, two algorithms generally mentioned in the context of the single source shortest path problem is Dijkstra's algorithm and the Bellman-Ford algorithm.\nDijkstra's algorithm works with positive edge weights, whereas the Bellman-Ford algorithm is a generalization also allowing for negative edge weights.\n\nAs implemented in Sedgewick's book \"Algorithms\" (4th ed.), Dijkstra's algorithm is based on a priority queue, whereas the Bellman-Ford algorithm is based on a plain FIFO queue. \nHowever, to me it doesn't look like either choice of the two queue types would be necessary for implementing the algorithms. One could just as well implement Dijkstra's algorithm with a FIFO queue and the Bellman-Ford algorithm with a priority queue.\n\nWhat is the reason why Dijkstra's algorithm is usually implemented with a priority queue, Bellman-Ford on the other hand with a FIFO queue? Is there a functional reason, or is it for runtime optimization?\n    ", "Answer": "\r\n\n  Dijkstra's algorithm is based on a priority queue\n\n\nNot necessarily. You can also implement dijkstra's algorithm without a priority queue. But in that case you have to pick the lowest value after searching from your array of node list you are currently processing.\n\n\n  Bellman-Ford algorithm is based on a plain FIFO queue\n\n\nWithout any sort of queue you can easily implement Bellman-ford algorithm. here is an example implementation. https://kt48.wordpress.com/2015/06/16/bellman-ford-algorithm-c-implementation/ \n\n\n  What is the reason why Dijkstra's algorithm is usually implemented\n  with a priority queue, Bellman-Ford on the other hand with a FIFO\n  queue? Is there a functional reason, or is it for runtime\n  optimization?\n\n\nYes, it is runtime optimization.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "CUDA on Thrust: how to implement priority queue\r\n                \r\nmy plan is to calculate a distance matrix using Pearsons's correlation and get q- nearest neighbors for each nodes (q=ln(n)) from the distance matrix and put them in a result vector. I did it in C++ using STL priority queue inside the loop of correlation function.\n\nBut do you think, there is any way to do it in GPU? \n\n\nCan anyone help me, how can I do the same in GPU (probably Thrust will be easier for me!)\nHow to implement priority queue in GPU?\n\n\nHere is my CPU(C++ STL) code:\n\nFor example,\n\n\n      distance matrix\n-----------------------\n 0 3 2 4\n 3 0 4 5\n 2 4 0 6\n .....\n\noutput in a object vector\n=================\n\n    source  target  weight\n--------------------------------\n0 2 2\n0 1 3  ....    (sorted by Edge weight)\n\n1 0 3\n1 2 4\n\n2 0 2\n.....\n\n\ncalculatePearsonCorrelation(float  vector1[], float vector2[], int m) {\n               // float distancePearson(vector vector1, vector vector2){\n\n                            int i;\n                            float a=0,b=0,c=0,d=0, e = 0, sumX=0, sumY=0;\n\n                            //m = vector1.size();\n\n                            for(i=0;iq){\n                        MIN=pqx.top().get_corr();\n                        if(corr::iterator it = qNNVector.begin(); it!=qNNVector.end(); ++it) {\n            fout \n\n    ", "Answer": "\r\nHave you tried using Thrust's sort? You can just read out the first q elements. If there are enough elements, you'll likely see a decent speedup.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to preserve the order of elements of the same priority in a priority queue implemented as binary heap?\r\n                \r\nI have created a binary heap, which represents a priority queue. It's just classical well known algorithm. This heap schedules  a chronological sequence of different events ( the sort key is time ). \n\nIt supports 2 operation: Insert and Remove. Each node's key of the heap is greater than or equal to each of its children. However, adding events with the same key doesn't preserve the order they were added, because each time after Remove or Insert were called, the heap-up and the heap-down procedures break the order. \n\nMy question is: what should be changed in a classical algorithm to preserve the order of the nodes with the same priority?\n    ", "Answer": "\r\nOne solution is to add time of insertion attribute to the inserted element. That may be just a simple counter incremented each time a new element is inserted into the heap. Then when two elements are equal by priority, compare the time of insertion.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Dequeue a Priority Queue\r\n                \r\nElements dequeued from a priority queue follow the rule that:\n\nPriority[i] >= Priority[i - 1]\n\nBut if many elements have the same priority, in what order should they be dequeued?\nShould the element that was enqueued first be dequeued first or doesn't it matter?\nI know this most likely depends on implementation and usage, but I'm looking for the textbook priority queue answer.\n    ", "Answer": "\r\nA queue should definitely be FIFO, that is its nature. The priority queue changes the queue aspect slightly in that it lets higher priority items through in preference to lower ones, but that shouldn't change the basic nature of the queue.\n\nI've seen implementations that profess to be queues but do not follow the FIFO rules. I prefer a different name for them to better specify the behaviour (such as priority bags).\n\nIn a queue (even a priority one), items with the same priority should be extracted in the same order they were inserted.\n\nIn other words, inserting ```\nA2 B2 C2 D1```\n (number is priority) should result in the processing as ```\nD1 A2 B2 C2```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Matching function arguments in generic priority queue type\r\n                \r\nI use an external library which provides a generic priority queue type implementation.\nPriority queue's class (declared in a header file, call it priorityQueue.h) is\n\n```\ntemplate <typename KeyType, typename DataType, template <typename datatype> class   StorageType>\nclass PriorityQueue {...};\n```\n\n\nwhich contains an insert function:\n\n```\n//Insert a key-value pair to the priority queue\nvoid insert( const KeyType& key, const DataType& data, const DescriptorType ptr = 0)\n```\n\n\nI need this priority queue to store items of the struct below into:\n\n```\n struct certificate\n {\n    float tfail;\n    typename GraphType::NodeIterator n;\n    unsigned int ne, citem; \n };\n```\n\n\nso i've implemented this function:\n\n```\nvoid storeCertificates(const NodeIterator& u, int node_or_edge)\n{\n//representation: (ne, idn, tfail), for a node identified by idn if we have a min cert (ne= 0), or a tail of an edge identified by idn if we have a pr cert (ne=1)\ncertificate cert;\n\nint ne;\nif(node_or_edge == 0) //min certificate\n    ne = 0;\nelse              //prim certificate\n    ne = 1;\n\ncert.ne = ne;\ncert.n = u;\ncert.tfail = u->tfail;\ncert.citem = 0;\n\nc.insert( cert.tfail, cert, cert.citem); //<=========\n}\n```\n\n\nwhich stores a cert item into a priority queue defined as:\n\n```\n typedef PriorityQueue< WeightType, NodeIterator, HeapStorage>   PriorityQueueType;\n PriorityQueueType c;\n```\n\n\nIn compile time, i get the following error:\n\n```\ntd_dijkstra_and_os.h:680:2: error: function does not match call to  \n‘PriorityQueue<float, std::_List_iterator<ALNode<node, edge> >, HeapStorage>::insert(float&, TD_Dijkstra_OS<DynamicGraph<AdjacencyListImpl, node, edge> >::certificate&, unsigned int&)’\ntd_dijkstra_and_os.h:680:2: note: candidate is:\n/home/danuser/eCOMPASS/pgl/include/Structs/Trees/priorityQueue.h:132:10: σημείωση: void PriorityQueue<KeyType, DataType, StorageType>::insert(const KeyType&, const DataType&, PriorityQueue<KeyType, DataType, StorageType>::DescriptorType) [with KeyType = float, DataType = std::_List_iterator<ALNode<node, edge> >, StorageType = HeapStorage, PriorityQueue<KeyType, DataType, StorageType>::DescriptorType = unsigned int*, PQSizeType = unsigned int]\n/home/danuser/eCOMPASS/pgl/include/Structs/Trees/priorityQueue.h:132:10: σημείωση:   no known conversion for argument 2 from ‘TD_Dijkstra_OS<DynamicGraph<AdjacencyListImpl, node, edge> >::certificate’ to ‘const std::_List_iterator<ALNode<node, edge> >&’\n```\n\n\nPlease, provide a correct way to use this insertion function for my implementation.\n\nEDIT: Can someone provide an implementation of this by using std::priority_queue or, even better boost's priority queue?\n    ", "Answer": "\r\n```\nDataType```\n of the queue is ```\nNodeIterator```\n, but you are trying to insert ```\ncertificate```\n. \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing Priority Queue\r\n                \r\nI am attempting to implement insertion, find minimum, and delete minimum functions for a primary queue. I also have tests to ensure that my code is working properly by checking it alongside another queue. For some reason, when utilizing the find minimum and delete minimum functions, it is coming with different values from the other queue. How can I fix this?\n\n```\n#include \"pQueue.h\"\n#include <iostream>\nusing namespace tom;\n\nstatus pQueue::insert(int insertInt)\n{\n\n    if (q[0] == NULL)\n    {\n        q[0] = insertInt;\n        minimum = insertInt;\n    }\n    else if (q[0] != NULL)\n    {\n        q[count] = insertInt;\n    }\n    else\n    {\n        return FAILURE;\n    }\n\n    if (insertInt < minimum)\n    {\n        minimum = insertInt;\n    }\n    return SUCCESS;\n    count++;\n\n}\n\nstatus pQueue::findMin(int &minElement)\n{\n\n    minElement = minimum;\n\n    if (minElement == NULL)\n    {\n        return FAILURE;\n    }\n    return SUCCESS;\n}\n\nstatus pQueue::deleteMin()\n{\n\n    for (int i = 0; i <= count; i++)\n    {\n        if (q[i] = minimum)\n        {\n            q[i] = 0;\n        }\n        if (q[i] != 0)\n        {\n            return FAILURE;\n        }\n\n    }\n}\n```\n\n    ", "Answer": "\r\nThe general idea for an unsorted priority queue is, assuming you're storing it in an array, is:\n\nInsertion:\n\n\nAdd item as the last item in the array.\nIncrement ```\ncount```\n.\n\n\nRemoval:\n\n\nScan the array to find the index of the smallest item.\nCopy the value from that index to a variable called ```\nresult```\n\nCopy the last value in the array to that location\nDecrement ```\ncount```\n.\nReturn ```\nresult```\n\n\n\nSo insert becomes (in pseudo-code)\n\n```\ninsert(value)\n    a[count] = value\n    count = count + 1\n```\n\n\ndeleteMin is:\n\n```\ndeleteMin()\n    minIndex = findMinIndex()\n    result = a[minIndex]\n    a[minIndex] = a[count-1]\n    count = count - 1\n    return result\n```\n\n\nfindMinIndex is:\n\n```\nfindMinIndex()\n    if (count < 1) then error\n    minIndex = 0\n    for (i = 1; i < count; ++i)\n        if (a[i] < a[minIndex])\n            minIndex = i\n    return minIndex\n```\n\n\nAnd findMin is:\n\n```\nfindMinIndex()\n    return a[findMinIndex()]\n```\n\n\nI'll leave the C++ implementation to you.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Starvation free Priority Queue C# [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 12 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI am looking for an implementation of a priority queue that prevents starvation.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Can I use Priority Queue in Java without implementing a comparator?\r\n                \r\nIf I want to create priority queue of nodes, and each node has only one field (i.e. ```\nint val```\n) do I have to write a comparator for the priority queue? \n    ", "Answer": "\r\nThe elements of the priority queue are ordered according to their natural ordering, or by a Comparator . If you don't want to use Comparator then implement Comparable in your Node class. \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I implement a numba jitted priority queue?\r\n                \r\nI am failing to implement a numba jitted priority queue.\nHeavily plagiarized from the python docs, I am fairly happy with this class.\n```\nimport itertools\n\nimport numba as nb\nfrom numba.experimental import jitclass\nfrom typing import List, Tuple, Dict\nfrom heapq import heappush, heappop\n\n\nclass PurePythonPriorityQueue:\n    def __init__(self):\n        self.pq = [] # list of entries arranged in a heap\n        self.entry_finder = {}  # mapping of indices to entries\n        self.REMOVED = -1 # placeholder for a removed item\n        self.counter = itertools.count() # unique sequence count\n\n    def put(self, item: Tuple[int, int], priority: float = 0.0):\n        \"\"\"Add a new item or update the priority of an existing item\"\"\"\n        if item in self.entry_finder:\n            self.remove_item(item)\n        count = next(self.counter)\n        entry = [priority, count, item]\n        self.entry_finder[item] = entry\n        heappush(self.pq, entry)\n\n    def remove_item(self, item: Tuple[int, int]):\n        \"\"\"Mark an existing item as REMOVED.  Raise KeyError if not found.\"\"\"\n        entry = self.entry_finder.pop(item)\n        entry[-1] = self.REMOVED\n\n    def pop(self):\n        \"\"\"Remove and return the lowest priority item. Raise KeyError if empty.\"\"\"\n        while self.pq:\n            priority, count, item = heappop(self.pq)\n            if item is not self.REMOVED:\n                del self.entry_finder[item]\n                return item\n        raise KeyError(\"pop from an empty priority queue\")\n```\n\nNow I would like to call this from a numba jitted function doing heavy numerical work, so I tried to make this a numba jitclass. Since entries are heterogeneous list in the vanilla python implementation, I figured I should implement other jitclasses as well. However, I am getting a ```\nFailed in nopython mode pipeline (step: nopython frontend)```\n (full trace below).\nHere is my attempt:\n```\n@jitclass\nclass Item:\n    i: int\n    j: int\n\n    def __init__(self, i, j):\n        self.i = i\n        self.j = j\n\n\n@jitclass\nclass Entry:\n    priority: float\n    count: int\n    item: Item\n    removed: bool\n\n    def __init__(self, p: float, c: int, i: Item):\n        self.priority = p\n        self.count = c\n        self.item = i\n        self.removed = False\n\n\n@jitclass\nclass PriorityQueue:\n    pq: List[Entry]\n    entry_finder: Dict[Item, Entry]\n    counter: int\n\n    def __init__(self):\n        self.pq = nb.typed.List.empty_list(Entry(0.0, 0, Item(0, 0)))\n        self.entry_finder = nb.typed.Dict.empty(Item(0, 0), Entry(0, 0, Item(0, 0)))\n        self.counter = 0\n\n    def put(self, item: Item, priority: float = 0.0):\n        \"\"\"Add a new item or update the priority of an existing item\"\"\"\n        if item in self.entry_finder:\n            self.remove_item(item)\n        self.counter += 1\n        entry = Entry(priority, self.counter, item)\n        self.entry_finder[item] = entry\n        heappush(self.pq, entry)\n\n    def remove_item(self, item: Item):\n        \"\"\"Mark an existing item as REMOVED.  Raise KeyError if not found.\"\"\"\n        entry = self.entry_finder.pop(item)\n        entry.removed = True\n\n    def pop(self):\n        \"\"\"Remove and return the lowest priority item. Raise KeyError if empty.\"\"\"\n        while self.pq:\n            priority, count, item = heappop(self.pq)\n            entry = heappop(self.pq)\n            if not entry.removed:\n                del self.entry_finder[entry.item]\n                return item\n        raise KeyError(\"pop from an empty priority queue\")\n\n\nif __name__ == \"__main__\":\n    queue1 = PurePythonPriorityQueue()\n    queue1.put((4, 5), 5.4)\n    queue1.put((5, 6), 1.0)\n    print(queue1.pop())  # Yay this works!\n\n    queue2 = PriorityQueue()  # Nope\n    queue2.put(Item(4, 5), 5.4)\n    queue2.put(Item(5, 6), 1.0)\n    print(queue2.pop())\n```\n\nIs this type of data structure implementable with numba? What is wrong with my current implementation?\nFull trace:\n```\n(5, 6)\nTraceback (most recent call last):\n  File \"/home/nicoco/src/work/work-research/scripts/thickness/priorityqueue.py\", line 106, in <module>\n    queue2 = PriorityQueue()  # Nope\n  File \"/home/nicoco/.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/experimental/jitclass/base.py\", line 122, in __call__\n    return cls._ctor(*bind.args[1:], **bind.kwargs)\n  File \"/home/nicoco/.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/core/dispatcher.py\", line 420, in _compile_for_args\n    error_rewrite(e, 'typing')\n  File \"/home/nicoco/.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/core/dispatcher.py\", line 361, in error_rewrite\n    raise e.with_traceback(None)\nnumba.core.errors.TypingError: Failed in nopython mode pipeline (step: nopython frontend)\nFailed in nopython mode pipeline (step: nopython frontend)\n- Resolution failure for literal arguments:\nNo implementation of function Function(<function typeddict_empty at 0x7fead8c3f8b0>) found for signature:\n\n >>> typeddict_empty(typeref[<class 'numba.core.types.containers.DictType'>], instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>, instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>)\n\nThere are 2 candidate implementations:\n  - Of which 2 did not match due to:\n  Overload in function 'typeddict_empty': File: numba/typed/typeddict.py: Line 213.\n    With argument(s): '(typeref[<class 'numba.core.types.containers.DictType'>], instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>, instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>)':\n   Rejected as the implementation raised a specific error:\n     TypingError: Failed in nopython mode pipeline (step: nopython frontend)\n   No implementation of function Function(<function new_dict at 0x7fead9002a60>) found for signature:\n\n    >>> new_dict(instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>, instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>)\n\n   There are 2 candidate implementations:\n         - Of which 2 did not match due to:\n         Overload in function 'impl_new_dict': File: numba/typed/dictobject.py: Line 639.\n           With argument(s): '(instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>, instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>)':\n          Rejected as the implementation raised a specific error:\n            TypingError: Failed in nopython mode pipeline (step: nopython mode backend)\n          No implementation of function Function(<built-in function eq>) found for signature:\n\n           >>> eq(instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>, instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>)\n\n          There are 30 candidate implementations:\n                - Of which 28 did not match due to:\n                Overload of function 'eq': File: <numerous>: Line N/A.\n                  With argument(s): '(instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>, instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>)':\n                 No match.\n                - Of which 2 did not match due to:\n                Operator Overload in function 'eq': File: unknown: Line unknown.\n                  With argument(s): '(instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>, instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>)':\n                 No match for registered cases:\n                  * (bool, bool) -> bool\n                  * (int8, int8) -> bool\n                  * (int16, int16) -> bool\n                  * (int32, int32) -> bool\n                  * (int64, int64) -> bool\n                  * (uint8, uint8) -> bool\n                  * (uint16, uint16) -> bool\n                  * (uint32, uint32) -> bool\n                  * (uint64, uint64) -> bool\n                  * (float32, float32) -> bool\n                  * (float64, float64) -> bool\n                  * (complex64, complex64) -> bool\n                  * (complex128, complex128) -> bool\n\n          During: lowering \"$20call_function.8 = call $12load_global.4(dp, $16load_deref.6, $18load_deref.7, func=$12load_global.4, args=[Var(dp, dictobject.py:653), Var($16load_deref.6, dictobject.py:654), Var($18load_deref.7, dictobject.py:654)], kws=(), vararg=None)\" at /home/nicoco/.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/typed/dictobject.py (654)\n     raised from /home/nicoco/.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/core/types/functions.py:229\n\n   During: resolving callee type: Function(<function new_dict at 0x7fead9002a60>)\n   During: typing of call at /home/nicoco/.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/typed/typeddict.py (219)\n\n\n   File \"../../../../../.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/typed/typeddict.py\", line 219:\n       def impl(cls, key_type, value_type):\n           return dictobject.new_dict(key_type, value_type)\n           ^\n\n  raised from /home/nicoco/.cache/pypoetry/virtualenvs/work-research-r4deHn84-py3.8/lib/python3.8/site-packages/numba/core/typeinfer.py:1071\n\n- Resolution failure for non-literal arguments:\nNone\n\nDuring: resolving callee type: BoundFunction((<class 'numba.core.types.abstract.TypeRef'>, 'empty') for typeref[<class 'numba.core.types.containers.DictType'>])\nDuring: typing of call at /home/nicoco/src/work/work-research/scripts/thickness/priorityqueue.py (72)\n\n\nFile \"priorityqueue.py\", line 72:\n    def __init__(self):\n        <source elided>\n        self.pq = nb.typed.List.empty_list(Entry(0.0, 0, Item(0, 0)))\n        self.entry_finder = nb.typed.Dict.empty(Item(0, 0), Entry(0, 0, Item(0, 0)))\n        ^\n\nDuring: resolving callee type: jitclass.PriorityQueue#7fead8ba2b20<pq:ListType[instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>],entry_finder:DictType[instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>]<iv=None>,counter:int64>\nDuring: typing of call at <string> (3)\n\nDuring: resolving callee type: jitclass.PriorityQueue#7fead8ba2b20<pq:ListType[instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>],entry_finder:DictType[instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,instance.jitclass.Entry#7feb3119d3d0<priority:float64,count:int64,item:instance.jitclass.Item#7fead907c1f0<i:int64,j:int64>,removed:bool>]<iv=None>,counter:int64>\nDuring: typing of call at <string> (3)\n\n\nFile \"<string>\", line 3:\n<source missing, REPL/exec in use?>\n\n\nProcess finished with exit code 1\n```\n\n    ", "Answer": "\r\nThis was not possible due to several issues in numba, but should be fixed for the next release (0.55) if I understood correctly. As a workaround for now, I could get it working by compiling llvmlite 0.38.0dev0 and the master branch of numba. I do not use conda but it is apparently easier to get pre-releases of llvmlite and numba this way.\nHere is my implementation:\n```\nfrom heapq import heappush, heappop\nfrom typing import List, Tuple, Dict, Any\n\nimport numba as nb\nimport numpy as np\nfrom numba.experimental import jitclass\n\n\nclass UpdatablePriorityQueueEntry:\n    def __init__(self, p: float, i: Any):\n        self.priority = p\n        self.item = i\n\n    def __lt__(self, other: \"UpdatablePriorityQueueEntry\"):\n        return self.priority < other.priority\n\n\nclass UpdatablePriorityQueue:\n    def __init__(self):\n        self.pq = []\n        self.entries_priority = {}\n\n    def put(self, item: Any, priority: float = 0.0):\n        entry = UpdatablePriorityQueueEntry(priority, item)\n        self.entries_priority[item] = priority\n        heappush(self.pq, entry)\n\n    def pop(self) -> Any:\n        while self.pq:\n            entry = heappop(self.pq)\n            if entry.priority == self.entries_priority[entry.item]:\n                self.entries_priority[entry.item] = np.inf\n                return entry.item\n        raise KeyError(\"pop from an empty priority queue\")\n\n    def clear(self):\n        self.pq.clear()\n        self.entries_priority.clear()\n\n\n@jitclass\nclass PriorityQueueEntry(UpdatablePriorityQueueEntry):\n    priority: float\n    item: Tuple[int, int]\n\n    def __init__(self, p: float, i: Tuple[int, int]):\n        self.priority = p\n        self.item = i\n\n\n@jitclass\nclass UpdatablePriorityQueue(UpdatablePriorityQueue):\n    pq: List[PriorityQueueEntry2d]\n    entries_priority: Dict[Tuple[int, int], float]\n\n    def __init__(self):\n        self.pq = nb.typed.List.empty_list(PriorityQueueEntry2d(0.0, (0, 0)))\n        self.entries_priority = nb.typed.Dict.empty((0, 0), 0.0)\n\n    def put(self, item: Tuple[int, int], priority: float = 0.0):\n        entry = PriorityQueueEntry2d(priority, item)\n        self.entries_priority[item] = priority\n        heappush(self.pq, entry)\n\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can we implement Priority Queue instead of Queue to Breadth-First Traversal?\r\n                \r\nWe know that for Breadth First Traversal we should use 'Queue'.\nExample:\n\nFor this graph, if we start from '0', the visit order will be like this : 0 1 3 8 7 2 4 5 6.\nWhat would be the visit order if we use a priority queue?\nEdit: Priority Queue will be min-heap.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Efficient implementation of BPE using priority queue\r\n                \r\nI think that it is not strictly BPE (byte pair encoding), but there is a similar idea applied to strings.\n\nSuppose there are three Chinese words in the dictionary (I will use a huge dictionary like CEDICT for practical use.)\n\n\n我\n喜欢\n水果\n\n\nThen take an input like this below.\n\n我喜欢水果 (I like fruit)\n\nSince Chinese texts are not splitted by white spaces, it's difficult to process.\n\nWe can decompose the input string into multiple single characters.\n\n我 喜 欢 水 果\n\nThen lookup new symbol pair at [left, right] and combine them. If the combined word is in the dictionary, we can replace the combined word with a new symbol.\n\n\n我喜\n喜欢 <- in the dic\n欢水\n水果 <- in the dic\n\n\nWe found two new symbols, so the input text becomes \n\n我 喜欢 水果\n\nWe should iterate until we cannot find any combined word in the dictionary. In this case, we cannot find a new symbol in the dictionary.\n\n\n我喜欢 水果\n喜欢水果\n\n\nIt's not difficult to implement this naively but we need to scan adjoining two words many times. Some said we can implement BPE efficiently with a priority queue. I'm not familiar with compression algorithms. I would be grateful if someone could tell me the implementation or useful documentations.\n\nIn this method, out of vocabulary words are decomposed into single characters, so we can avoid unknown words problems.\n\nBest regards,\n\nReference: Neural Machine Translation of Rare Words with Subword Units He had to start with pre-tokenized words because of computational complexity.\n    ", "Answer": "\r\nI would suggest storing the dictionary as a trie using hash lookups at each level.  This replaces your scans with hash lookups, which are ```\nO(1)```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Concurrent mutable priority queue\r\n                \r\nIs there a concurrent mutable priority queue? Ideally, I'm looking for a C++ implementation, but, for starters, a pointer to an algorithm would be very helpful.\n\nTo be clear, I'm looking for a priority queue where I can adjust the priorities of the elements. In particular, TBB's ```\nconcurrent_priority_queue```\n doesn't provide the necessary functionality. (For that matter, neither does STL's ```\npriority_queue```\n, even if we ignore the concurrency.) Boost.Heap library provides serial functionality that I want, but without concurrency. Naturally, I'm looking for something finer grained than just locking the entire queue on every operation.\n    ", "Answer": "\r\nA concurrent priority queue is often implemented using a skiplist, so Facebook's ConcurrentSkipList may fit your requirements.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Trying to implement a priority queue with an ordered linked list\r\n                \r\nSo what I'm trying to do is implement a priority queue using an ordered linked list. I feel like I am fairly close but I can't seem to resolve the error in the while statement within the insert function. Here's what I have so far:\n\n```\nclass OrderedLinkedListMaxPQ<Item> {\n\nprivate class PQNode {\n    Object data; \n    PQNode next;\n\n    public PQNode(Object value) {\n        data = value;\n        next = null;\n    }\n}\n\nPQNode head;\n\npublic void PriorityQueue() { \n    this.head = null; \n}\n\npublic boolean isEmpty() { return this.head == null; }\n\npublic void insert(Object item) {\n\n   PQNode prev = null;\n   PQNode current = this.head;\n   while (current != null && current.data >= item.data) {\n       prev = current;\n       current = current.next;\n   }\n\n   PQNode temp = new PQNode(item);\n   if (prev == null) {\n       temp.next = this.head;\n       this.head = temp;\n   } else {\n       temp.next = current;\n       prev.next = temp;\n   }   \n}\n\npublic Object delete() {\n   Object temp = this.head.data;\n   this.head = this.head.next;\n   return temp;\n}\n\npublic static void main(String[] args) {\n    OrderedLinkedListMaxPQ<Integer> pq = new OrderedLinkedListMaxPQ<Integer>();\n    pq.insert(7);\n    pq.insert(6);\n    pq.insert(3);\n    pq.insert(2);\n    while (!pq.isEmpty())\n        StdOut.println(pq.delete());\n   }\n}\n```\n\n    ", "Answer": "\r\n```\ncurrent.data >= item.data```\n makes no sense. The ```\ndata```\n is an Object reference and you cannot compare them. Perhaps, if the dat avalues are ```\nComparable```\n you can use the compareTo(...) method. Otherwise you will need to write your own mechanism to compare them. Also, ```\nitem```\n is passed in as an Object, but you references it as a ```\nPNode```\n ... this is a problem too.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can we implement Priority Queue using HashMap(using key-value approach) in Rust\r\n                \r\nHow can we implement Priority Queue using HashMap in Rust?\n```\npub trait PRQ<Element> {\n    fn new() -> Self;\n    fn insert(&mut self, element: Element, p: u64);\n    fn peek(&self) -> Option<Element>;\n    fn pop(&mut self) -> Option<Element>;\n}\n\npub struct PRQImpl(HashMap<Vec<u8>, Vec<u8>>);\n\nimpl PRQ<Vec<u8>> for PRQImpl {\n    fn new() -> Self {\n        Self(HashMap::new())\n    }\n\n    fn insert(&mut self, element: Vec<u8>, p: u64) {\n        //\n    }\n\n    fn pop(&mut self) -> Option<Vec<u8>> {\n        //\n    }\n\n    fn peek(&self) -> Option<Vec<u8>> {\n        //\n    }\n}\n```\n\n```\n////Tests\n\nlet mut q = PRQImpl::new();\n\nq.insert(vec![1], 10);\nq.insert(vec![2], 8);\nq.insert(vec![3], 4);\nq.insert(vec![4], 7);\nassert_eq!(q.pop(), Some(vec![1]));\n```\n\nI can not change ```\nPRQImpl```\n definition neither the method definition. I know HashMap is not ordered and this is not the right approach to implement Priority Queue.\nCan someone please guide me on how I can implement Priority Queue with the above definition?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "why Find-Minimum operation in priority queue implemented in unsorted array take only complexity = O(1) ? <steven skiena's the algorithm design manual>\r\n                \r\nIn steven skiena's the algorithm design manual (page 85), \n\nThe author show in a table that priority queue implemented in unsorted array only take O(1) for both insertion and find minimum operation.\n\n\nFor my understanding unsorted array wasn't able get the minimum item in O(1) , because it has to search through the whole array to get the minimum.\n\nis there any details i missed out in priority queue ?\n    ", "Answer": "\r\nIt's (mostly) written there under the table:\n\n\n  The trick is using an extra variable to store a pointer/index to the minimum ...\n\n\nPresumably, the next word is \"value\", meaning it's a simple ```\nO(1)```\n dereference to get the minimum.\n\nWhen inserting an item, you just append it to the end and, if it's less than the current minimum, update that pointer/index. That means ```\nO(1)```\n for the insert.\n\nThe only \"expensive\" operation is then delete-minimum. You know where it is due to the pointer/index but it will take ```\nO(n)```\n operations to shuffle the array elements beyond it down one.\n\nAnd, since the cost is already ```\nO(n)```\n, you may as well take the opportunity to search the array for the new minimum and store its position in the pointer/index.\n\n\n\nThe pseudo-code for those operations be something along the lines of (first up, initialisation and insertion, and assuming zero-based indexes):\n\n```\nclass prioQ:\n    array = []      # Empty queue.\n    lowIndex = 0    # Index of lowest value (for non-empty queue).\n\n    def insert(item):\n        # Add to end, quick calc if array empty beforehand.\n\n        array.append(item)\n        if len(array) == 1:\n            lowIndex = 0\n            return\n\n        # Adjust low-index only if inserted value smaller than current.\n\n        if array[lowIndex] > item:\n            lowIndex = len(array) - 1\n```\n\n\nThen a function to find the actual minimum value:\n\n```\n    def findMin():\n        # Empty array means no minimum. Otherwise, return minimum.\n\n        if len(array) == 0: return None\n        return array[lowIndex]\n```\n\n\nAnd, finally, to extract the minimum value (remove it from the queue and return it):\n\n```\n    def extractMin():\n        # Empty array means no minimum. Otherwise save lowest value.\n\n        if len(array) == 0: return None\n        retVal = array[lowIndex]\n\n        # Shuffle down all following elements to delete lowest one\n\n        for index = lowIndex to len(array) - 2 inclusive:\n            array[index] = array[index + 1]\n\n        # Remove final element (it's already been shuffled).\n\n        delete array[len(array) - 1]\n\n        # Find lowest element and store.\n\n        if len(array) > 0:\n            lowIndex = len(array) - 1\n            for index = len(array) - 2 to 0 inclusive:\n                if array[index] <= array[lowIndex]:\n                    lowIndex = index\n\n        # Return saved value.\n\n        return retVal\n```\n\n\nAs an aside, the two loops in the ```\nextractMin```\n function could be combined in to one for efficiency. I've left it as two separate loops for readability.\n\n\n\nOne thing you should keep in mind, there are actually variations of the priority queue that preserve insertion order (within a priority level) and variations that do not care about that order.\n\nFor the latter case, you don't have to shuffle all the elements to remove an extracted one, you can simply move the last one in the array over the extracted one. This may result in some time savings if you don't actually need to preserve insertion order - you still have to scan the entire array looking for the new highest-priority item but at least the number of shuffle assignments will be reduced.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How To Implement Correct Sorting Algorithm in Priority Queue?\r\n                \r\nI need your help with implementing the correct sorting algorithm for Priority Queue. Apparently I've done this wrong as it creates a duplicate node. I'm stumped on this, any help would be greatly appreciated. I need to get this right as I will use this on both increase() and decrease() methods.\n\nCheck my sort() method below in the code.\n\nHere is my code:\n\n```\npublic class PriorityQueueIntegers implements PriorityQueueInterface {\n\n    // number of elements\n    private int numberOfElements;\n\n    // element\n    private int element;\n\n    // priority\n    private int priority;\n\n    // Node\n    Node head = null, tail = null;\n\n    // returns true if the queue is empty (no items in queue)\n    // false if queue is (has at least one or more items in queue)\n    public boolean isEmpty()\n    {\n        return ( numberOfElements == 0 );\n    }\n\n    // returns the value of the item currently at front of queue\n    public int peek_frontValue()\n    {\n        return head.getValue();  // return the value in the head node\n    }\n\n    // returns the priority of the item currently at front of queue\n    public int peek_frontPriority()\n    {\n        return head.getPriority();\n    }\n\n    // clear the queue\n    public void clear()\n    {\n        head = null;\n        tail = null;\n        numberOfElements = 0;\n    }\n\n    // insert the item with element and priority\n    public void insert(int newElement, int newPriority)\n    {\n        // if head node is null, make head and tail node contain the first node\n        if (head == null)\n        {\n            head = new Node(newElement, newPriority);\n            tail=head; // when first item is enqueued, head and tail are the same\n        }\n        else\n        {\n            Node newNode = new Node(newElement, newPriority);\n            tail.setNext(newNode);\n            tail=newNode;            \n        }\n        sort(newElement, newPriority);\n\n        numberOfElements++;\n    }\n\n    public void increase(int findElement, int priority_delta)\n    {\n        Node current = head;\n\n        if (numberOfElements > 0)\n        {\n            while (current != null)\n            {\n                if (current.getValue() == findElement)\n                {\n                    int newPriority = current.getPriority() + priority_delta;\n                    current.setIncreasePriority(newPriority);\n                }\n                current = current.getNext();\n            }\n        } else throw new UnsupportedOperationException(\"Empty Queue - increase failed\");\n    }\n\n    public void decrease(int findElement, int priority_delta)\n    {\n        Node current = head;\n\n        if (numberOfElements > 0)\n        {\n            while (current != null)\n            {\n                if (current.getValue() == findElement)\n                {\n                    int newPriority = current.getPriority() - priority_delta;\n                    if (newPriority < 0)\n                    {\n                        throw new UnsupportedOperationException(\"Can't be a negative number\");\n                    }\n                    current.setDecreasePriority(newPriority);\n                }\n                current = current.getNext();\n            }\n        } else throw new UnsupportedOperationException(\"Empty Queue - increase failed\");\n    }\n\n    private void sort(int value, int priority)\n    {\n        Node current = head;\n        int v = value;\n        int p = priority;\n\n        Node temp = new Node(v, p);\n\n        if (numberOfElements > 0)\n        {\n            while (current != null && current.getNext().getPriority() < p)\n            {\n                current = current.getNext();\n            }\n            temp._next = current._next;\n            current._next = temp;\n        }\n    }\n\n    public int remove_maximum()\n    {\n        int headDataValue = 0;\n        if ( numberOfElements > 0 )\n        {\n            headDataValue = head.getValue();\n            Node oldHead=head;\n            head=head.getNext();\n            oldHead.setNext(null);                     \n            this.numberOfElements--;\n        }\n        else throw new UnsupportedOperationException(\"Empty Queue - dequeue failed\");\n        return headDataValue;  // returns the data value from the popped head, null if queue empty\n    }\n\n    public String display()\n    {\n        Node current = head;\n        String result = \"\";\n\n        if ( current == null )\n        {\n            result = \"[Empty Queue]\";\n        }\n        else\n        {\n            while ( current != null )\n            {\n                result = result + \"[\" + current.getValue() + \",\" + current.getPriority() + \"] \";\n                current = current.getNext();\n            }\n        }\n\n        return result;\n    }\n\n    //////////////////////////////////////////////////////////////\n\n    // Inner Node Class\n    private class Node\n    {\n        private int value;\n        private int priority;\n        private Node _next;\n\n        public Node (int element, int priority_delta)\n        {\n            this.value = element;\n            this.priority = priority_delta;\n            _next = null;\n        }\n\n        protected Node(int element, int priority_delta, Node nextNode)\n        {\n            this.value = element;\n            this.priority = priority_delta;\n            _next = nextNode;\n        }\n\n        public Node getNext()\n        {\n            return _next;\n        }\n\n        public int getValue()\n        {\n            return this.value;\n        }\n\n        public int getPriority()\n        {\n            return this.priority;\n        }\n\n        public void setIncreasePriority(int newPriority)\n        {\n            this.priority = newPriority;\n        }\n\n        public void setDecreasePriority(int newPriority)\n        {\n            this.priority = newPriority;\n        }\n\n        public void setNext(Node newNextNode)\n        {\n            _next = newNextNode;\n        }\n\n    }\n}\n```\n\n    ", "Answer": "\r\nYou are correct that your code currently creates duplicate nodes. Your ```\ninsert```\n method creates a node:\n\n```\n    if (head == null) {\n        head = new Node(newElement, newPriority);\n        tail=head; // when first item is enqueued, head and tail are the same\n    } else {\n        Node newNode = new Node(newElement, newPriority);\n        tail.setNext(newNode);\n        tail=newNode;            \n    }\n```\n\n\nThis method then calls ```\nsort```\n that also creates a node:\n\n```\n    Node temp = new Node(v, p);\n    if (numberOfElements > 0) {\n        while (current != null && current.getNext().getPriority() < p) {\n            current = current.getNext();\n        }\n        temp._next = current._next;\n        current._next = temp;\n    }\n```\n\n\nIt does not make a lot of sense to me that a ```\nsort```\n method would create a new node. You should either insert the node in the right position in ```\ninsert```\n or the ```\nsort```\n method should move it to the correct position. If you take the first approach then you'll need to change you ```\nincrease```\n and ```\ndecrease```\n methods.\n\nA potential method to move a node to the correct position, in pseduocode, would be:\n\n```\nmove node:\n    walk through queue and find both\n        node that's next points to the one you are moving (from)\n        last node that has higher priority than the one you are moving (to)\n    set from.next to node.next\n    set node.next to to.next\n    set to.next to node\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing priority queue using max heap vs balanced BST\r\n                \r\nBalanced BST and max heap both perform insert and delete in ```\nO(logn)```\n. However, finding max value in a max heap is ```\nO(1)```\n but this is ```\nO(logn)```\n in balanced BST.\nIf we remove the max value in a max heap it takes ```\nO(logn)```\n because it is a delete operation.\nIn balanced BST, deleting the max element  = finding max value + delete; it equals logn + logn reduces to ```\nO(logn)```\n. So even deleting the max value in balanced BST is ```\nO(logn)```\n.\nI have read one such application of max heap is a priority queue and its primary purpose is to remove the max value for every dequeue operation. If deleting max element is ```\nO(logn)```\n for both max heap and balanced BST, I have the following questions\n\nWhat is the purpose of a max heap in the priority queue just because it is easy to implement rather than using full searchable balanced BST?\n\nSince there is no balancing factor calculation, the max heap can be called an unbalanced binary tree?\n\nEvery balanced BST can be used as a priority queue and which is also searchable in ```\nO(logn)```\n however max heap search is ```\nO(n)```\n correct?\n\n\nAll the time complexities are calculated for worst-case. Any help is greatly appreciated.\n    ", "Answer": "\r\n\nWhat is the purpose of a max heap in the priority queue just because it is easy to implement rather than using full searchable balanced BST?\n\nSome advantages of a heap are:\n\nGiven an unsorted input array, a heap can still be built in O(n) time, while a BST needs O(nlogn) time.\n\nIf the initial input is an array, that same array can serve as heap, meaning no extra memory is needed for it. Although one could think of ways to create a BST using the data in-place in the array, it would be quite odd (for primitive types) and give more processing overhead. A BST is usually created from scratch, copying the data into the nodes as they are created.\nInteresting fact: a sorted array is also a heap, so if it is known that the input is sorted, nothing needs to be done to build the heap.\n\nA heap can be stored as an array without the need of storing cross references, while a BST usually consists of nodes with left & right references. This has at least two consequences:\n\nThe memory used for a BST is about 3 times greater than for a heap.\nAlthough several operations have the same time complexity for both heap and BST, the overhead for adapting a BST is much greater, so that the actual time spent on these operations is a (constant) factor greater in the BST case.\n\n\n\n\nSince there is no balancing factor calculation, the max heap can be called an unbalanced binary tree?\n\nA heap is in fact a complete binary tree, so it is always as balanced as it can be: the leaves will always be positioned in the last or one-but-last level. A self-balancing BST (like AVL, red-black,...) cannot beat that high level of balancing, where you will often have leaves occurring at three levels or even more.\n\nEvery balanced BST can be used as a priority queue and which is also searchable in O(logn) however max heap search is O(n) correct?\n\nYes, this is true. So if the application needs the search feature, then a BST is superior.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why would a min-heap be preferable to a max-heap to implement a priority queue?\r\n                \r\nIn a book I am using to study about algorithms and data structures it is stated that a min-heap is preferable to a max-heap to implement a priority queue. Why is that the case?\n\nAnd why is it a good idea to use a heap to implement a priority queue?\n    ", "Answer": "\r\nMin-heap is required for more algorithms, such as Dijkstra's. But in reality min-heap and max-heap are equivalent if you just negate all the elements.\n\nA heap is a simple and efficient way to implement a priority queue, since (by nature of the heap) it keeps itself \"sorted\" as you add/remove from it, therefore giving you fast insertion and removal of the minimum element (if a min-heap). These are precisely the operations a priority queue needs, so a heap is a good fit.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Issue Implementing A* in C++ with Priority Queues\r\n                \r\nI'm currently working on a homework assignment to implement A* for the sliding brick puzzle. I have previously implemented BFS and DFS for this puzzle, but an now having problems. I attempted to write my A* code by adapting the BFS code I already had working using a priority queue and Manhattan distance as the heuristic. In order to have the program open the node with the lowest f value (g+h), I had to override the operator for the priority queue, as it contains a defined structure. When I compile the code, no errors arise, but when I run it the program just crashed. My guess is that it is getting stuck in a loop somewhere. Maybe I implemented the operator override incorrectly. Can anyone help me figure out what is going wrong? I have pasted my code below. \n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cstring>\n#include <list>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <time.h>\n\nusing namespace std;\n\nstruct move //creates structure for a move containing a pice number and direction to move\n{\n    int piece;\n    char direction;\n};\n\nstruct parentmove\n{\n    vector< vector<int> > par;\n    move mo;\n};\n\nstruct position\n{\n    int row;\n    int column;\n};\n\nstruct node\n{\n    vector< vector<int> > par;\n    vector< vector<int> > state;\n    position pos;\n    int g;\n    int h;\n    int f;\n};\n\nbool operator<(const node& a, const node& b)\n{\n    return a.f > b.f;\n}\n\nvoid SBP::Astar(vector <vector<int> > st)\n{\n    position goalpos = getposition(st, -1);\n    node stnode;\n    stnode.state = st;\n    stnode.g = 0;\n    position stpos = getposition(st, 2);\n    stnode.h = abs(goalpos.row - stpos.row) + abs(goalpos.column - stpos.column);\n    stnode.f = stnode.g + stnode.h;\n    stnode.pos = stpos;\n    list<move> allm;\n    priority_queue< node > unexplored, explored;\n    set< vector <vector<int> > > closedset; //contains explored states in a set, \n    map < vector <vector<int> >, parentmove > pathdict;\n    allm = (*this).allmoves(st);\n    list<move>::iterator it = allm.begin();\n    for (int i = 0; i < allm.size(); i++)\n    {\n        move m;\n        m.piece = (*it).piece;\n        m.direction = (*it).direction;\n        vector< vector<int> > newst = (*this).applyMove(st, m);\n        newst = (*this).normalization(newst);\n        node newnode;\n        newnode.par = st;\n        newnode.state = newst;\n        newnode.g = 1;\n        position newpos = getposition(newst, 2);\n        newnode.h = abs(goalpos.row - newpos.row) + abs(goalpos.column - newpos.column);\n        newnode.f = newnode.h + newnode.g;\n        newnode.pos = newpos;\n        unexplored.push(newnode);\n\n        parentmove pm = { st,m };\n        pathdict[newst] = pm;\n        ++it;\n    }\n    explored.push(stnode);\n    closedset.insert(st);\n    while (!unexplored.empty())\n    {\n        node currentnode = unexplored.top();\n        vector< vector<int> > currentst = currentnode.state;\n        unexplored.pop();\n        bool iscomplete = (*this).complete(currentst);\n        if (iscomplete)\n        {\n            explored.push(currentnode);\n            closedset.insert(currentst);\n            list<move> path = (*this).constructpath(currentst, pathdict, st);\n            (*this).display(currentst);\n            printf(\"A* explored %i nodes\\n\", explored.size());\n            printf(\"The length of the path solution is %i moves\\n\", path.size());\n            return;\n        }\n        else\n        {\n            set< vector< vector<int> > >::iterator ite = closedset.find(currentst);\n            if (ite == closedset.end()) //does not already exist in queue\n            {\n                list<move> possm;\n                possm = (*this).allmoves(currentst);\n                list<move>::iterator iter = possm.begin();\n                for (int j = 0; j < possm.size(); j++)\n                {\n                    move m;\n                    m.piece = (*iter).piece;\n                    m.direction = (*iter).direction;\n                    vector< vector<int> > newst = (*this).applyMove(currentst, m);\n                    vector< vector<int> > normst = (*this).normalization(newst);;\n                    node normnode;\n                    normnode.state = normst;\n                    normnode.par = currentst;\n                    normnode.g = currentnode.g + 1;\n                    position p = getposition(normst, 2);\n                    normnode.h = abs(goalpos.row - p.row) + abs(goalpos.column - p.column);\n                    normnode.f = normnode.g + normnode.h;\n                    normnode.pos = p;\n                    unexplored.push(normnode);\n                    if (pathdict.find(normst) == pathdict.end())\n                    {\n                        parentmove pm = { currentst,m };\n                        pathdict[normst] = pm;\n                    }\n                    ++iter;\n                }\n                explored.push(currentnode);\n                closedset.insert(currentst);\n            }\n        }\n    }\n\n    return;\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Not Comparing Correctly C++\r\n                \r\nI am trying to create a priority queue consisting of pairs of int, char that gives me the pair with the greater int, but my code is not working properly. What am I doing wrong?\n\nThis is my comparator class:\n\n```\nclass Compare\n{\npublic:\n    bool operator() (pair<int, char>a, pair<int, char>b)\n    {\n        return a.first > b.first;\n    }\n};\n```\n\n\nAnd this is my priority queue:\n\n```\npriority_queue<pair<int, char>, vector<pair<int, char>>, Compare> party;\n```\n\n\nBut if I execute the code:\n\n```\nparty.push(make_pair(2, 'A'));\nparty.push(make_pair(3, 'B'));\ncout<<party.top().first;\n```\n\n\nIt returns 2, instead of 3. How do I fix my implementation of the priority queue?\n    ", "Answer": "\r\nThe same fix that Geordi La Forge would use: reverse the polarity:\n\n```\nbool operator() (const pair<int, char> &a, const pair<int, char> &b) const\n{\n    return a.first < b.first;\n}\n```\n\n\nThe comparison function always implements strict weak ordering, a.k.a. the logical ```\n<```\n operation. But ```\npriority_queue```\n, by definition, gives you the largest value in the priority queue, first:\n\n\n  ... provides constant time lookup of the largest (by default) element,\n\n\nBut the comparison function is still strict weak ordering:\n\n\n  A Compare type providing a strict weak ordering.\n\n\nSlightly counter-intuitive, but after a while, it does make sense...\n\nP.S.: The comparison function should be a ```\nconst```\n function, and take ```\nconst```\n parameters, for efficiency, as shown in my example; but that's an additional detail.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Not Comparing Correctly C++\r\n                \r\nI am trying to create a priority queue consisting of pairs of int, char that gives me the pair with the greater int, but my code is not working properly. What am I doing wrong?\n\nThis is my comparator class:\n\n```\nclass Compare\n{\npublic:\n    bool operator() (pair<int, char>a, pair<int, char>b)\n    {\n        return a.first > b.first;\n    }\n};\n```\n\n\nAnd this is my priority queue:\n\n```\npriority_queue<pair<int, char>, vector<pair<int, char>>, Compare> party;\n```\n\n\nBut if I execute the code:\n\n```\nparty.push(make_pair(2, 'A'));\nparty.push(make_pair(3, 'B'));\ncout<<party.top().first;\n```\n\n\nIt returns 2, instead of 3. How do I fix my implementation of the priority queue?\n    ", "Answer": "\r\nThe same fix that Geordi La Forge would use: reverse the polarity:\n\n```\nbool operator() (const pair<int, char> &a, const pair<int, char> &b) const\n{\n    return a.first < b.first;\n}\n```\n\n\nThe comparison function always implements strict weak ordering, a.k.a. the logical ```\n<```\n operation. But ```\npriority_queue```\n, by definition, gives you the largest value in the priority queue, first:\n\n\n  ... provides constant time lookup of the largest (by default) element,\n\n\nBut the comparison function is still strict weak ordering:\n\n\n  A Compare type providing a strict weak ordering.\n\n\nSlightly counter-intuitive, but after a while, it does make sense...\n\nP.S.: The comparison function should be a ```\nconst```\n function, and take ```\nconst```\n parameters, for efficiency, as shown in my example; but that's an additional detail.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why use heap instead of binary tree when implementing priority queue?\r\n                \r\nIt seems to me that the only advantage of heap over binary tree is to find the smallest item in the heap in complexity of O(1) instead of O(log(2)n) in binary tree.\n\nWhen implementing priority queue you need to delete the smallest item each from the data structre. deleting the smallest item from a tree and both heap done in complexity of O(log(2)n). Althogh deleting item from a tree may be more complex. Deleting item with no childrens acctually very simple.\n\nMy question is why use heap instead of binary tree(which is simpler in this case) when implementing priority queue?\n    ", "Answer": "\r\nWorst case complexity in case of binary tree will be O(n) when binary tree converges to an array while in heap it remains O(log(n)). you can use balanced binary trees like red black or AVl but then it wud become more complex and would require more memory.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement a priority queue using a Stack as the base data type\r\n                \r\nSerious help needed. I need to make a stack the base data type and use that to implement the priority queue. It must also include an insert method and a removeMin method. Thanks, any help is appreciated\n\n'\n\n```\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack\n\npublic class Problem2 {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n\n        PriorityQueue<Entry> pq = new PriorityQueue<Entry>();\n\n        for (int i = 0; i<5; i++)\n        {\n            int a = scn.nextInt();\n            String b = scn.next();\n            pq.add(new Entry(a, b));\n        }\n        System.out.println(\"The output from the priority queue:\");\n\n        for(int i = 0, c = pq.size(); i<c; i++)\n        {\n            System.out.println(pq.remove());\n        }\n    }\n\n    static class Entry implements Comparable<Entry> {\n        int k;\n        String v;\n\n        public Entry() \n        {\n        }\n        public Entry(int key, String value) {\n            k = key;\n            v = value;\n        }\n        public String toString() {\n            return (\"Key \" + k + \" value \" + v);\n        }\n        public int compareTo(Entry b) {\n            return Integer.compare(this.k, b.k);\n        }\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing a Priority queue with a Condition Variable in C\r\n                \r\nMy current understanding of condition variables is that all blocked (waiting) threads are inserted into a basic FIFO queue, the first item of which is awakened when signal() is called.\n\nIs there any way to modify this queue (or create a new structure) to perform as a priority queue instead?  I've been thinking about it for a while, but most solutions I have end up being hampered by the existing queue structure inherent to C.V.'s and mutexes.\n\nThanks!\n    ", "Answer": "\r\nI think you should rethink what you're trying to do.  If you're trying to optimize your performance, you're probably barking up the wrong tree.\n\n```\npthread_cond_signal()```\n isn't even guaranteed to unblock exactly one thread -- it's guaranteed to unblock at least one thread, so your code better be able to handle the situation where multiple threads are unblocked simultaneously.  The typical way to do this is for each thread to re-check the condition after becoming unblocked, and, if false, return to waiting again.\n\nYou could implement some sort of scheme where you kept your own priority queue of threads waiting, and each thread added itself to that queue immediately before it was to begin waiting, and then it would check the queue when unblocking, but this would add a lot of complexity and a lot of potential for serious problems (race conditions, deadlocks, etc.).  It was also add a non-trivial amount of overhead.\n\nAlso, what happens if a higher-priority thread starts waiting on a condition variable at the same moment that condition variable is being signalled?  Who gets unblocked, the newly arrived high-priority thread or the former highest priority thread?\n\nThe order that threads get unblocked in is entirely dependent on the kernel's thread scheduler, so you are at its mercy.  I wouldn't even assume FIFO ordering, either.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Increase priority in priority queue\r\n                \r\nI want to decrease the priority of an element in a priority queue? How do I achieve that in logarithmic time?\n\nI know priority queues are implemented as max heaps. But if I modify any element in the queue and then call make_heap on it, it will take linear time in the number of elements.\n\nReference: http://www.cplusplus.com/reference/queue/priority_queue/\n    ", "Answer": "\r\nThe only way to perform updating with logarithmic complexity is to implement the priority queue yourself, so you can use well-known algorithms.\n\nThe implementation of ```\nstd::priority_queue```\n is not specified by the standard (for example it can well be d-ary heap), so you can't portably update the priority without rebuilding the queue. For the same reason you can't use ```\nstd::make_heap```\n and related functions.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing Priority Queue in Kannel\r\n                \r\nI would like someone experience with kannel to enlighten me please.\n\nI currently run a little site that revolves around sending and receiving SMS. I am using Kannel as SMS Gateway, One feature that I like to have in it is Priority based Queuing of my SMS to be sent. \n\nThe work around that me and my colleague have come up with is to write an intermediary program, to which we will send our SMS to be sent, it will manage it's own queue and will in turn handle them to kannel Priority wise. \n\nIt will store SMS to MySQL database for persistence and would be done in PHP.\n\nI just want to be sure that this is a good way to solve our problem and I want to open source it so other peoples can benefit.\n\nMany thanks.\n    ", "Answer": "\r\nKannel itself does not support message priority in internal queue.\n\nHowever you can use sqlbox addon (included in Kannel 1.5.0 release - see \"addons/sqlbox\" catalog).\n\nThis case you can make simple changes in the following way:\n\n\nAdd \"my_prio\" field to table structure.\nChange original fetching SQL query to order messages by this field (SELECT ... ORDER BY my_prio).\nInsert MT messages with appropriate value of this \"my_prio\" field.\n\n\nAll mentioned changes may be done in \"addons/sqlbox/gw/sqlbox_mysql.h\" file.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Understanding time complexity of Dijkstra priority queue vs set implementation\r\n                \r\nConsider the following two implementations of dijkstra's algorithm:\nUsing set:\n```\n// V - total number of vertices\n// S - source node\nvoid dijkstra(int V, vector<vector<int>> edge[], int S)\n{\n    vector<int> dist(V, 1e9);\n    dist[S] = 0;\n    \n    set<pair<int, int>> s;\n    for (int  i=0; i<V; i++)\n        s.insert({dist[i], i});    // log(V) time\n    \n    while (!s.empty())    // exactly V times\n    {\n        auto top = *(s.begin());    // constant time\n        int dis = top.first;\n        int node = top.second;\n        s.erase(top);               // amortised constant time\n\n        for (auto it: edge[node])    // For all the iterations of outer while loop this will sum up to E, where E is the total number of edges in the graph\n        {\n            int nb = it[0];\n            int edge_weight = it[1];\n            \n            if (dist[nb] > dis + edge_weight)\n            {\n                s.erase({dist[nb], nb});    // log(V) time\n                dist[nb] = dis + edge_weight;\n                s.insert({dist[nb], nb});    // log(V) time\n            }\n        }\n    }\n}\n```\n\nUsing priority queue:\n```\n// V - total number of vertices\n// S - source node\nvoid dijkstra(int V, vector<vector<int>> edge[], int S)\n{\n    vector<int> dist(V, 1e9);\n    dist[S] = 0;\n    \n    priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({dist[S], S});\n    \n    while (!pq.empty())    // Can be more than V times, let's call this heap_size times\n    {\n        int node = pq.top().second;    // O(1) time\n        pq.pop();                      // log(heap_size) time\n        \n        for (int i=0; i<edge[node].size(); i++)    // Can be approximated to (E/V), where E is the total number of edges in the graph\n        {\n            int nb = edge[node][i][0];\n            int edge_weight = edge[node][i][1];\n\n            if (dist[nb] > dist[node] + edge_weight) {\n                dist[nb] = dist[node] + edge_weight;\n                pq.push({dist[nb], nb});    // log(heap_size) time\n            }\n        }\n    }\n    return dist;\n}\n```\n\nFinding the time complexity using set based approach is easy as the number of elements in set is exactly ```\nV```\n(number of vertices) and the inner for loop runs for every edge, so it's time complexity is ```\nO(V*log(V) + V + E*log(V))```\n which is equivalent to ```\nO(E*log(V))```\n (reason: What's the time complexity of Dijkstra's Algorithm)\nBut I have trouble in understanding the time complexity of the priority_queue approach. Here the same node can be present multiple times in the priority_queue with different distances. How do I calculate the upper bound on the number of nodes that are added to the heap?\nI also want to decide which implementation to use based on the nature of the graph(sparse vs dense), are both these implementations equivalent for any type of graph?\n    ", "Answer": "\r\nYour ```\npriority_queue```\n version isn't quite right.\nYour while loop should start like this:\n```\n    auto nextPair = pq.top();\n    pq.pop();\n    if (dist[nextPair.second] != nextPair.first) {\n        continue;\n    }\n    int node = nextPair.second;\n```\n\nThis ensures that each vertex is processed only once, when its current record is popped from the priority queue.\nThe complexity analysis then becomes easy, since each edge will then be processed at most once, and there are then at most |E| inserts into the priority queue.\nTotal complexity is then O(E log E), and since E < V2, that's the same as O(E log V).\nThe major disadvantage of the priority queue method is that it can consume O(E) space.  This is usually OK, since it's on par with the space consumed by the graph itself.  Since the ```\npriority_queue```\n is a lot faster than ```\nset```\n, the ```\npriority_queue```\n version is the way that it is commonly done in practice.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Thread-safe Priority Queue for Delphi?\r\n                \r\nI'm looking for a priority queue implemented in Delphi that would work well in a multi-threaded environment.\n\nIdeally lock-free, or designed for multi-threaded inserts/deletes with something better than a locked wrapper around a single-threaded implementation (which I already have).\n\nThe specificity is that in normal operation, there would be only adds, deletes, and notifications when the top (highest priority item) changes, while \"pop\" operations of the highest priority item should be very infrequent.\n\nIt would be used for a watchdog/timeout thread monitoring tasks, being executed in other threads, those task are expected to terminate normally most of the time, so they would just be added/removed from the queue. The timeout thread would essentially be waiting on the next timeout event, hence the need for notifications when the top-priority event changes.\n\nThe tasks are handled by scripts, which can be safely terminated at any time.\n\nIf there are better algorithms for this than a priority queue, they could be good answers too!\n\nEdit: following a remark by Martin James, another specificity is that there are relatively few different timeout values, and for each timeout value, the problem becomes that of a FIFO queue.\n    ", "Answer": "\r\nJulian Bucknall (Author of \"Tomes of Delphi: Algorithms and Data Structures\" ) has recently announced the release of a Delphi XE version of EZDSL(a Delphi Structures Library) in his Blog.\n\nUnfortunately TThreadsafePriorityQueue (implemented in EZDSLPQu.PAS) is lock based.\n\nI can't help sharing the good news and my other intent is a call for his contribution in answering the question.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Defining priority queue\r\n                \r\nConsider the following declaration of the priority class ```\nclass PriorityQueue<E extends Comparable<E>> extends Queue<E> {```\n in contrast to the one provided in the Java packages, which  has a comparator as an attribute to compare. This instead forces the object for which the priority queue is maintained to have its comparable implementation.  Are there any pros and cons of this approach?\nMy Thoughts: \nOne thing I can think of is that this will force the priority queue to use the object comparators and won't provide the ability to implement its custom comparator as the user  of the class may want to build the queue based on some different comparator.\n    ", "Answer": "\r\n\nConsider the following declaration of the priority class class PriorityQueue<E extends Comparable> extends Queue {}\n\nWhat if you want to put an object in the queue, and this object does not implement the ```\nComparable```\n interface.\nThere is no need to restrict the placed object must implement the ```\nComparable```\n interface, which is more flexible.\nFor the same object, the logic of comparison may be inconsistent in different scenarios, so a ```\ncomparator```\n needs to be passed in from the outside, and the object itself does not need to implement a ```\ncomparator```\n.\n(Above are my personal thoughts)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Resources for pagoda priority queue?\r\n                \r\nI recently heard about a type of priority queue called a \"pagoda\" that allegedly has excellent runtime guarantees.  In fact, some of the references I've found on it have suggested that it's one of the fastest priority queue implementations available.  Surprisingly, though, I can't seem to find a single good resource on this data structure anywhere on Google or Bing.\n\nDoes anyone know of any good resources (analysis, source code, etc.) on this data structure?\n    ", "Answer": "\r\nPagodas: pg 174 of the \"Handbook of Algorithms and Data Structures\" by G.H. Gonnet (published 1984). Contains psuedocode and analysis.\n\nThere is a more recent version of this book here.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Complexity of inserting into priority queue\r\n                \r\nConsider the following code that pops the first 2 elements from priority queue, adds them and inserts the sum back to priority queue.\n\n```\nwhile (pq.size() > 1)\n{\n    // Extract shortest two ropes from pq\n    int first = pq.top();\n    pq.pop();\n    int second = pq.top();\n    pq.pop();\n\n    // Connect the ropes: update result and\n    // insert the new rope to pq\n    res += first + second;\n    pq.push(first + second);\n}\n```\n\n\nIt is known that inserting into priority queue for n elements is O(nlogn) operation. But lets say priority queue is implemented as an array.\nWon't it become O(N*N) operation.\nOr what will be the complexity for the above code for n elements.\n    ", "Answer": "\r\nA well-implemented priority queue will insert elements in O (log n) amortised steps per insertion. A well-implemented priority queue is quite likely to use an array, with the array elements arranged according to the heapsort algorithm. \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do you use a binary heap to implement a priority queue?\r\n                \r\nDespite the fact that I've got a BS in Computer Science (and this was covered in the university), I've never been able to understand the relationship between binary heaps and priority queues. It just... doesn't click. I completely understand what a binary heap is and I know how to implement one in an array. I also know what a priority queue is. But how do the two of them fit together?\n\nA quick google query shows a lot of articles like this one. Which kind of explains it, yet I'm left more questions:\n\n\nA priority queue needs to ensure that if two items with the same priority are added, then they will be removed in the same order that they were added. How does a binary heap ensure this? (In fact, if I'm not mistaken, then the border case where ALL the items have the same priority would produce a heap which would violate this rule).\nWhat happens when you remove the root from the heap, then put in the last element in place of the root, and then need to swap it with one of the children - but both children have the same value. How do you pick which one to swap with? (Holding in mind the FIFO rule of same-priority items)\n\n\nWhat am I missing here?\n    ", "Answer": "\r\nA priority queue is an abstract data type like \"stack\" or \"associative array.\" There can are many different ways to implement a priority queue - you can use binary heaps, binomial heaps, Fibonacci heaps, pairing heaps, etc.\n\nI don't believe that there is any intrinsic requirement that a priority queue be \"stable\" and require that elements with equal priorities be dequeued in the same relative order in which they were added, much in the same way that there's no instrinsic requirement that a sorting algorithm be stable (though many are). It's a nice property to have, but usually it's not guaranteed. This is why, for example, a standard heapsort isn't a stable sort.\n\nFortunately, it's not too hard to adjust binary heaps to be stable. Keep a counter associated with the binary heap. Whenever you add an element to the heap, tag it with the current value of the counter and increment the counter. When doing heap operations, use the counter as a tiebreaker to determine which value is smaller if two values compare equal. Essentially, this changes the comparison to a lexicographical comparison first on the real value and then on the insertion order.\n\nHope this helps!\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Change priority of items in a priority queue\r\n                \r\nUsing Scala 2.9 to implement a kind of Dijkstra algorithm (pseudo code)\n\n```\nval queue = new PriorityQueue\nqueue.insert(...)\nwhile (!queue.isEmpty) {\n  val u = queue.extractMin\n  queue.foreach { v =>\n    if (condition(u, v))\n      queue.decreaseKey(v, newPriority)\n  }\n}\n```\n\n\nI'd like to change priority of an item in Scala's ```\ncollection.mutable.PriorityQueue```\n.\n\nTherefore tried to\n\n\nremove item\nchange priority\nreinsert into queue.\n\n\nBut I can't find a method to either update priority or remove a specific item (not\nnecessarily head element) like ```\njava.util.PriorityQueue#remove(Object)```\n as apposed in\nRemoving an item from a priority queue.\n\n\nHow this task can be done with ```\nscala.collection.mutable.PriorityQueue```\n\nor do I have to use ```\njava.util.PriorityQueue```\n instead?\nDoes anyone know whether lack of such a method is by design and it would be recommended\nto rebuild the queue after changing priority of some items (maybe take a look at discussion about Priority queue with dynamic item priorities)?\n\n    ", "Answer": "\r\nDefining a case class for the PriorityQueue type to use with var for priority allows you to find it and mutate the priority. The PriorityQueue then has this new value. To get the ordering correct I had to clone it which reorders/forces the ordering. There might be a better way to do this without cloning.\n\n```\ncase class Elem(var priority: Int, i: Int)\n\ndef MyOrdering = new Ordering[Elem] {\n  def compare(a : Elem, b : Elem) = a.priority.compare(b.priority)\n}\n\nval pq = new scala.collection.mutable.PriorityQueue[Elem]()(MyOrdering)  ++ List(Elem(1,1), Elem(0,0), Elem(2,2))\n\npq.find(x => x.priority == 0) match {\n  case Some(elem: Elem) => elem.priority = 3\n  case None => println(\"Not found\")\n}\n\nval pq2 = pq.clone\nprintln(pq2)\nprintln(pq2.dequeue)\nprintln(pq2.dequeue)\nprintln(pq2.dequeue)\n\n\n\n:load SO.scala\nLoading SO.scala...\ndefined class Elem\nPileOrdering: java.lang.Object with Ordering[Elem]\npq: scala.collection.mutable.PriorityQueue[Elem] = PriorityQueue(Elem(2,2), Elem(0,0), Elem(1,1))\npq2: scala.collection.mutable.PriorityQueue[Elem] = PriorityQueue(Elem(3,0), Elem(2,2), Elem(1,1))\nPriorityQueue(Elem(3,0), Elem(2,2), Elem(1,1))\nElem(3,0)\nElem(2,2)\nElem(1,1)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "High-performance priority queue to merge many sorted runs\r\n                \r\nI have an application to do merging of > 10,000 sorted runs on a single thread and I am currently using the C++ 11 STL::priority_queue to do the work. I wonder whether there exists some open-source priority queue code (or some other  data structure/implementation that can do merging of sorted  runs) that can outperform STL::priority_queue in a single-threaded environment (for example, designed with better cache aware). Or some report on benchmarking different priority queue implementations. \n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "When would it be preferred to implement a priority queue with a Singly Linked List over a Heap?\r\n                \r\nI recently just started up a project with some code that has been already written. I decided to look into his implementation and found that he implemented a Priority Queue with a Singly Linked List. \n\nMy understanding of SLLs is that since you may have to iterate over the entire list, it's inefficient to implement it as such, which is why Heaps are preferred. However, perhaps I am missing some sort of reasoning behind it and was wondering if anyone has ever chosen an SLL over a Heap for a Priority Queue?\n    ", "Answer": "\r\nThere are situations where a SLL is better than a heap for implementing a priority queue. For example:\n\n\nWhen removing from the queue needs to be as fast as possible. Removing from an SLL is O(1) (from the front of the list/queue) while removing from a heap is O(log n). I actually ran into this while writing a version of the ```\nalarm()```\n syscall for a simple OS. I simply could not afford the O(log n) lookup time. Related to this is when you need to remove multiple elements at a time. Removing k elements from an SLL takes O(k) time while it takes O(k log n) time for a heap.\nMemory issues. The traditional implementation of a min or max heap involves an array, which needs to be resized as the heap grows. If you can't afford the time it takes to do a large ```\nrealloc```\n then this strategy is out. If you implement the heap as a binary tree, then you need two pointers instead of one for an SLL.\nWhen you have to maintain multiple priorities. It is relatively easy to keep track of the same nodes in different linked lists. Doing this with heaps is much more complicated.\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Running times of priority queue ADT [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nWhat are the running times of each of the functions of the (standard) priority\nqueue ADT if we implement it by adapting the STL priority queue?\n    ", "Answer": "\r\nComplexity guarantees can be found in section 25.4.6 of the c++ standard. (Search for n3242.pdf; I'm sure you'll find one.) Alternatively, look at each heap operation listed here.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Clarify \"Insertion-sort if the priority-queue implemented with an ordered array\", why 'ordered\" required?\r\n                \r\nInsertion-sort works also on unordered array, like the example here shows. This statement in the title (or here) for some odd reason requires that you have an ordered array to implement priority-queue for the insertion sort, why does it have such requirement? What does this Wikipedia -thing here actually mean (the below screenshot)?\n\n\n    ", "Answer": "\r\nThe article relates the usage of priority queue for sorting and how different implementations of priority queue correspond with familiar sorting algorithms.\n\nLet us consider ADT priority queue with operation ```\npop()```\n which takes out the \"smallest\" element as defined by a comparison function and ```\npush()```\n which put a new element in the priority queue. Then sorting can be done by calling ```\npush()```\n to push all elements in the unsorted array into the priority queue and calling ```\npop()```\n until the priority queue is empty and put the popped out element into an array (well, you can define a method ```\nempty()```\n to check whether the ADT is empty).\n\nPsuedocode:\n\n```\nunsorted[]\nsorted[]\npriority_queue q\n\nforeach element in unsorted\n    q.push(element)\n\ni = 0\nwhile !q.empty()\n    sorted[i] = q.pop()\n    i = i + 1\n```\n\n\nThen we talk about how to implement the priority queue. Typically, it is efficiently implemented with heap. However, it is not necessary to be heap - you can implement it in less efficient ways, which is with unordered array or ordered array as mentioned in Wikipedia article. As long as the implementation satisfy the requirement for the ```\npush()```\n and ```\npop()```\n operations then it is fine.\n\nFor unordered array, you can ```\npush()```\n by placing the element directly just after the last element - since it is unordered. When you ```\npop()```\n, since the array is unordered, you need to search through the whole array and pick out the largest element. (Removal can be done easily, by swapping the last element in the unordered array to the position of the element being popped out). It is similar to selection sort, since you are essentially go through the list of unsorted elements (which is in the priority queue) and pick out the largest element to put into sorted portion.\n\nYou can see that insertion operation in insertion sort is being done in the ```\npush()```\n operation here.\n\nFor ordered array, you can ```\npop()```\n by just taking out the first element (removal can be done easily by maintaining a starting index). But ```\npush()```\n will require you to find out where to place the element to maintain the order (since it is an ordered array). This is the part where it closely resembles insertion sort, since you are trying to insert the current element to the sorted portion (the priority queue implemented as ordered array).\n\nYou can see that selection operation in selection sort is being done in the ```\npop()```\n operation here.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Python: NoneType AttributeError when implementing priority queue with linked nodes\r\n                \r\n```\nclass Node:\n    def __init__(self, data=None, priority='L', next=None):\n        self.data = data\n        self.priority = priority\n        self.next = next\n\n    def  __str__(self):\n        return str(self.data)\n\nclass P_Queue:\n    def __init__(self, head=None):\n        self.head = head\n        self.length = 0\n\n    def enqueue(self, node):\n        newNode = Node(node.data, node.priority)\n        if (self.head == None):\n            self.head = newNode\n        elif (self.head and self.head.priority == 'L' and newNode.priority == 'H'):\n            newNode.next = self.head\n            self.head = newNode\n        elif (self.head and self.head.priority == 'H' and newNode.priority == 'H'):\n            last = self.head\n            while (last.next and last.next.priority == 'H'):\n                last = last.next\n            if (last.next and last.next.next):\n                newNode.next = last.next.next\n            last.next = newNode\n        else:\n            last = self.head\n            while last.next:\n                last = last.next\n            last.next = newNode\n        self.length += 1\n\n    def dequeue(self):\n        node = self.head\n        print(\"next head: \")\n        print(self.head.next)\n        self.head = self.head.next\n        self.length = self.length - 1\n        return node\n\n    def is_empty(self):\n        return self.length==0\n\ndef main():\n    node0 = Node(0, 'L')\n    node1 = Node(1, 'H')\n    node2 = Node(2, 'H')\n\n    queue = P_Queue()\n\n    queue.enqueue(node0)\n    queue.enqueue(node1)\n    queue.enqueue(node2)\n\n    print(queue.dequeue())\n    print(queue.dequeue())\n    print(queue.dequeue())\n\nmain()\n```\n\n\nThe problem occurs for the last line of the displayed code at the while statement in queue(), I get the error \"'Nontype' object has no attribute property.\", but only for queue(node1)\n\nHowever, according to my print statements (output: H) for node0 = Node(0, 'H'), I clearly have a value of 'H' for that attribute (priority) and it does not contain a 'None' value so it's just mindboggling to me.\n\nPlease help... and if anyone has a good resource for learning how to implement a priority queue with a linked list for beginners that would be great too. Thank-you so much I'm dying here.\n\nTraceback below:\n\n```\nnext head: 2\n1\nnext head: None\n2\nnext head:\nTraceback (most recent call last):\n  File \"assignment1_3 queues.py\", line 62, in <module>\n    main()\n  File \"assignment1_3 queues.py\", line 60, in main\n    print(queue.dequeue())\n  File \"assignment1_3 queues.py\", line 39, in dequeue\n    print(self.head.next)\nAttributeError: 'NoneType' object has no attribute 'next'\n\n\n------------------\n(program exited with code: 1)\n\nPress any key to continue . . .\n```\n\n    ", "Answer": "\r\nYour while loop works. You keep forwarding your ```\nlast = last.next```\n until you reach ```\nNoneType```\n. Before you progressing your ```\nlast```\n to ```\nlast.next```\n, verify there is a node there. I've modified this part of your code:\n\n```\n    elif (self.head.priority == 'H' and newNode.priority == 'H'):\n        last = self.head\n        print(self.head.priority)\n        print(last.priority)\n        while last.priority == 'H' and last.next:  # <-- check last.next \n                                                         exists before pointing to it\n            last = last.next\n        if last.next and last.next.next:  # <-- same thing here\n            newNode.next = last.next.next\n        last.next = newNode\n```\n\n\nand this is the output:\n\n```\n>>> main()\nH\nH\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue with Worker Pod AutoScaler\r\n                \r\nI have a simple AWS SQS FIFO queue implemented with worker pod autoscaler WPA, now i want to make that queue a priority queue, one option would be using amazon MQ but its costly and its purpose is actually different, another option would be to create multiple N queues where N is the priority of the queue, now the actual problem is how will the worker Pod Autoscaler work, how will it select the queue and how will it autoscale.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue in opencl\r\n                \r\nI am trying to implement the A-Star search algorithm on OpenCL an can't figure out a way to implement the priority queue for it. Here is the general idea of what I'm trying to do in my .cl file\n\n```\n//HOW TO IMPLEMENT THESE??\nvoid extractFromPriorityQueue();\nvoid insertIntoPriorityQueue();\n//HOW TO IMPLEMENT THESE??\n\n__kernel void startAStar(//necessary inputs) {\n int id = get_global_id(0);\n int currentNode = extractFromPriorityQueue(priorityQueueArray,id);\n  if(currentNode==0){\n    return;\n  }\n int earliest_edge = vertexArray[currentNode-1];\n int next_vertex_edge = vertexArray[currentNode];\n for(int i=earliest_edge;i<next_vertex_edge;i++){\n    int child = edgeArray[i];\n    float weight = weightArray[i];\n    gCostArray[child-1] = gCostArray[currentNode] + weight;\n    hCostArray[child-1] = computeHeuristic(currentNode,child,coordinateArray);\n    fCostArray[child-1] = gCostArray[child-1] + hCostArray[child-1];\n    insertIntoPriorityQueue(priorityQueueArray,child);\n }\n}\n```\n\n\nAlso, does the priority queue have to be synchronized in this case?\n    ", "Answer": "\r\nBelow are links to the paper, pptx and source for various lock free GPU data structures including a skip list and priority queue. However the source code is CUDA. The CUDA code  is close enough to OpenCL that you can get the gist of how to implement this in OpenCL.\n\nThe priority queue is synchronized using atomic operations.   Queue nodes  are allocated on  the host and passed in as a global array of nodes to the functions. A new node is obtained by using an atomic increment of the array counter.\n\nNodes are inserted into the queue using atomic compare and swap (exchange) calls.  The paper and ppx\nexplain the workings  and concurrency issues.\n\nhttp://www.cse.iitk.ac.in/users/mainakc/projects.html\n\nSee the entry in the above page\n\nParallel programming/Run-time supports\n[ICPADS 2012][PDF][Source code][Talk slides (PPTX)]\nPrabhakar Misra and Mainak Chaudhuri. Performance Evaluation of Concurrent Lock-free Data Structures on GPUs. In Proceedings of the 18th IEEE International Conference on Parallel and Distributed Systems, pages 53-60, December 2012.\n\nThe source code link is  http://www.cse.iitk.ac.in/users/mainakc/lockfree.html\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Non-blocking Updatable Priority Queue\r\n                \r\nIt is common knowledge to use a heap to implement a priority queue and use a lookup hash table to support priority update. \n\nIn parallel settings, the heap-based implementation of a PQ requires a lock on every operation.\n\nIf the following operations of a non-blocking PQ are required:\n\n\nPop: pops the head item of the PQ\nPeek: returns the pointer of the head item of the PQ\nUpdate: updates an item with a given priority\n\n\nHow to implement a non-blocking updatable priority queue?\n\nLiterature always avoids the Update operation and only discusses the Push and Pop operation, eg:\n\n\nLindén, Jonatan, and Bengt Jonsson. \"A skiplist-based concurrent priority queue with minimal memory contention.\" International Conference On Principles Of Distributed Systems. Springer, Cham, 2013. \nShavit, Nir, and Itay Lotan. \"Skiplist-based concurrent priority queues.\" Proceedings 14th International Parallel and Distributed Processing Symposium. IPDPS 2000. IEEE, 2000.\nDragicevic, Kristijan, and Daniel Bauer. \"A survey of concurrent priority queue algorithms.\" 2008 IEEE International Symposium on Parallel and Distributed Processing. IEEE, 2008.\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C# Priority Queue\r\n                \r\nI'm looking for a priority queue with an interface like this:\n\n```\nclass PriorityQueue<T>\n{\n    public void Enqueue(T item, int priority)\n    {\n    }\n\n    public T Dequeue()\n    {\n    }\n}\n```\n\n\nAll the implementations I've seen assume that ```\nitem```\n is an ```\nIComparable```\n but I don't like this approach; I want to specify the priority when I'm pushing it onto the queue.\n\nIf a ready-made implementation doesn't exist, what's the best way to go about doing this myself? What underlying data structure should I use? Some sort of self-balancing tree, or what? A standard C#.net structure would be nice.\n    ", "Answer": "\r\nIf you have an existing priority queue implementation based on IComparable, you can easily use that to build the structure you need:\n\n```\npublic class CustomPriorityQueue<T>  // where T need NOT be IComparable\n{\n  private class PriorityQueueItem : IComparable<PriorityQueueItem>\n  {\n    private readonly T _item;\n    private readonly int _priority:\n\n    // obvious constructor, CompareTo implementation and Item accessor\n  }\n\n  // the existing PQ implementation where the item *does* need to be IComparable\n  private readonly PriorityQueue<PriorityQueueItem> _inner = new PriorityQueue<PriorityQueueItem>();\n\n  public void Enqueue(T item, int priority)\n  {\n    _inner.Enqueue(new PriorityQueueItem(item, priority));\n  }\n\n  public T Dequeue()\n  {\n    return _inner.Dequeue().Item;\n  }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Using a container/heap to implement a priority queue\r\n                \r\nIn the big picture, I'm trying to implement Dijkstra's algorithm using a priority queue. \n\nAccording to members of golang-nuts, the idiomatic way to do this in Go is to use the heap interface with a custom underlying data structure. So I have created Node.go and PQueue.go like so:\n\n```\n//Node.go\npackage pqueue\n\ntype Node struct {\n    row    int\n    col    int\n    myVal  int\n    sumVal int\n}\n\nfunc (n *Node) Init(r, c, mv, sv int) {\n    n.row = r\n    n.col = c\n    n.myVal = mv\n    n.sumVal = sv\n}\n\nfunc (n *Node) Equals(o *Node) bool {\n    return n.row == o.row && n.col == o.col\n}\n```\n\n\nAnd PQueue.go: \n\n```\n// PQueue.go\npackage pqueue\n\nimport \"container/vector\"\nimport \"container/heap\"\n\ntype PQueue struct {\n    data vector.Vector\n    size int\n}\n\nfunc (pq *PQueue) Init() {\n    heap.Init(pq)\n}\n\nfunc (pq *PQueue) IsEmpty() bool {\n    return pq.size == 0\n}\n\nfunc (pq *PQueue) Push(i interface{}) {\n    heap.Push(pq, i)\n    pq.size++\n}\n\nfunc (pq *PQueue) Pop() interface{} {\n    pq.size--\n    return heap.Pop(pq)\n}\n\nfunc (pq *PQueue) Len() int {\n    return pq.size\n}\n\nfunc (pq *PQueue) Less(i, j int) bool {\n    I := pq.data.At(i).(Node)\n    J := pq.data.At(j).(Node)\n    return (I.sumVal + I.myVal) < (J.sumVal + J.myVal)\n}\n\nfunc (pq *PQueue) Swap(i, j int) {\n    temp := pq.data.At(i).(Node)\n    pq.data.Set(i, pq.data.At(j).(Node))\n    pq.data.Set(j, temp)\n}\n```\n\n\nAnd main.go: (the action is in SolveMatrix)\n\n```\n// Euler 81\n\npackage main\n\nimport \"fmt\"\nimport \"io/ioutil\"\nimport \"strings\"\nimport \"strconv\"\nimport \"./pqueue\"\n\nconst MATSIZE = 5\nconst MATNAME = \"matrix_small.txt\"\n\nfunc main() {\n    var matrix [MATSIZE][MATSIZE]int\n    contents, err := ioutil.ReadFile(MATNAME)\n    if err != nil {\n        panic(\"FILE IO ERROR!\")\n    }\n    inFileStr := string(contents)\n    byrows := strings.Split(inFileStr, \"\\n\", -1)\n\n    for row := 0; row < MATSIZE; row++ {\n        byrows[row] = (byrows[row])[0 : len(byrows[row])-1]\n        bycols := strings.Split(byrows[row], \",\", -1)\n        for col := 0; col < MATSIZE; col++ {\n            matrix[row][col], _ = strconv.Atoi(bycols[col])\n        }\n    }\n\n    PrintMatrix(matrix)\n    sum, len := SolveMatrix(matrix)\n    fmt.Printf(\"len: %d, sum: %d\\n\", len, sum)\n}\n\nfunc PrintMatrix(mat [MATSIZE][MATSIZE]int) {\n    for r := 0; r < MATSIZE; r++ {\n        for c := 0; c < MATSIZE; c++ {\n            fmt.Printf(\"%d \", mat[r][c])\n        }\n        fmt.Print(\"\\n\")\n    }\n}\n\nfunc SolveMatrix(mat [MATSIZE][MATSIZE]int) (int, int) {\n    var PQ pqueue.PQueue\n    var firstNode pqueue.Node\n    var endNode pqueue.Node\n    msm1 := MATSIZE - 1\n\n    firstNode.Init(0, 0, mat[0][0], 0)\n    endNode.Init(msm1, msm1, mat[msm1][msm1], 0)\n\n    if PQ.IsEmpty() { // make compiler stfu about unused variable\n        fmt.Print(\"empty\")\n    }\n\n    PQ.Push(firstNode) // problem\n\n\n    return 0, 0\n}\n```\n\n\nThe problem is, upon compiling i get the error message:\n\n```\n[~/Code/Euler/81] $ make\n6g -o pqueue.6 Node.go PQueue.go\n6g main.go\nmain.go:58: implicit assignment of unexported field 'row' of pqueue.Node in function argument\nmake: *** [all] Error 1\n```\n\n\nAnd commenting out the line PQ.Push(firstNode) does satisfy the compiler. But I don't understand why I'm getting the error message in the first place. Push doesn't modify the argument in any way. \n\n\n\nUPDATE:\nFor the sake of those who come across this in searches in the future, the code above is chock full of gross misconceptions. Take a look below for a much more useful template to work off of:\nNode.go:\n\n```\n// Node.go\npackage pqueue\n\nimport \"fmt\"\n\ntype Node struct {\n    row    int\n    col    int\n    myVal  int\n    sumVal int\n    parent *Node\n}\n\nfunc NewNode(r, c, mv, sv int, n *Node) *Node {\n    return &Node{r, c, mv, sv, n}\n}\n\nfunc (n *Node) Eq(o *Node) bool {\n    return n.row == o.row && n.col == o.col\n}\n\nfunc (n *Node) String() string {\n    return fmt.Sprintf(\"{%d, %d, %d, %d}\", n.row, n.col, n.myVal, n.sumVal)\n}\n\nfunc (n *Node) Row() int {\n    return n.row\n}\n\nfunc (n *Node) Col() int {\n    return n.col\n}\n\nfunc (n *Node) SetParent(p *Node) {\n    n.parent = p\n}\n\nfunc (n *Node) Parent() *Node {\n    return n.parent\n}\n\nfunc (n *Node) MyVal() int {\n    return n.myVal\n}\n\nfunc (n *Node) SumVal() int {\n    return n.sumVal\n}\n\nfunc (n *Node) SetSumVal(sv int) {\n    n.sumVal = sv\n}\n```\n\n\nPQueue.go:\n\n```\n// PQueue.go\npackage pqueue\n\ntype PQueue []*Node\n\nfunc (pq *PQueue) IsEmpty() bool {\n    return len(*pq) == 0\n}\n\nfunc (pq *PQueue) Push(i interface{}) {\n    a := *pq\n    n := len(a)\n    a = a[0 : n+1]\n    r := i.(*Node)\n    a[n] = r\n    *pq = a\n}\n\nfunc (pq *PQueue) Pop() interface{} {\n    a := *pq\n    *pq = a[0 : len(a)-1]\n    r := a[len(a)-1]\n    return r\n}\n\nfunc (pq *PQueue) Len() int {\n    return len(*pq)\n}\n\n// post: true iff is i less than j\nfunc (pq *PQueue) Less(i, j int) bool {\n    I := (*pq)[i]\n    J := (*pq)[j]\n    return (I.sumVal + I.myVal) < (J.sumVal + J.myVal)\n}\n\nfunc (pq *PQueue) Swap(i, j int) {\n    (*pq)[i], (*pq)[j] = (*pq)[j], (*pq)[i]\n}\n\nfunc (pq *PQueue) String() string {\n    var build string = \"{\"\n    for _, v := range *pq {\n        build += v.String()\n    }\n    build += \"}\"\n    return build\n}\n```\n\n    ", "Answer": "\r\n```\npackage main\nvar PQ pqueue.PQueue\nvar firstNode pqueue.Node\nPQ.Push(firstNode)\n```\n\n\nThe variable ```\nfirstNode```\n is passed by value which means that there is an implicit assignment of the argument to the parameter in the function call ```\nPQ.Push(firstNode)```\n. The type ```\npqueue.Node```\n contains private fields such as ```\nrow```\n which are not exported from ```\npackage pqueue```\n to ```\npackage main```\n: \"implicit assignment of unexported field 'row' of pqueue.Node in function argument.\"\n\nIn ```\nNode.go```\n, add this function to ```\npackage pqueue```\n:\n\n```\nfunc NewNode() *Node {\n    return &Node{}\n}\n```\n\n\nIn ```\nPQueue.go```\n, add this function to ```\npackage pqueue```\n:\n\n```\nfunc NewPQueue() *PQueue {\n    return &PQueue{}\n}\n```\n\n\nThen. in ```\npackage main```\n, you can write:\n\n```\nPQ := pqueue.NewPQueue()\nfirstNode := pqueue.NewNode()\nPQ.Push(firstNode)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue vs linked list java\r\n                \r\nI was solving ```\nBFS```\n problem. I used PriorityQueue but I was getting wrong answer, then I used ```\nLinkedList```\n, I got right ans. I'm unable to find the difference between them. Here are both the codes. Why both the answers are different?\n\n```\nCode1:    \n        LinkedList q=new LinkedList();\n        q.add(src);\n        dist[src]=0;\n        visited[src]=1;\n        while(!q.isEmpty()){\n            u=(int)(Integer) q.remove(0);\n            for (int k = 0; k < n; k++) {\n                if(a[u][k]==1 && visited[k]==0)\n                {\n                    dist[k]=dist[u]+1;\n                    q.add(k);\n                    visited[k]=1;\n                }   \n            }\n        }\n\nCode 2: \n    PriorityQueue<Integer> q= new PriorityQueue<>();\n        q.add(src);            \n        dist[src]=0;\n        visited[src]=1;\n        while(!q.isEmpty()){\n            u=q.remove();               \n            for (int k = 0; k < n; k++) {\n                if(a[u][k]==1 && visited[k]==0)\n                {\n                    dist[k]=dist[u]+1;\n                    q.add(k);\n                    visited[k]=1;\n                }   \n            }\n        }\n```\n\n\nAlso when I used Adjacency List instead of Adjacency matrix, Priority Queue implementation gave right ans.\n    ", "Answer": "\r\nAs the documentation says:\n\n\n  An unbounded priority queue based on a priority heap. The elements of\n  the priority queue are ordered according to their natural ordering, or\n  by a Comparator provided at queue construction time, depending on\n  which constructor is used.\n\n\nLinkedList preserves the insertion order, PriorityQueue does not. So your iteration order changes, which makes your implementation that uses PriorityQueue something other than BFS.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue remove function not working\r\n                \r\nfor this class, remove function of priority queue is not working properly\nwhen implementing dijkstra's Algo. This is the class I created to \nsort elements in Priority Queue.Though the priority queue is removing\nthe min element correctly,it's  remove(object o) method is not \nremoving the elements properly \n\n```\npublic class IntegerArray implements Comparable<IntegerArray> {\n\npublic double[] a;\n\nIntegerArray(double x,double y){\n\n    a= new double[2];\n    a[0]=x;\n    a[1]=y;\n\n}\n\npublic boolean equals(IntegerArray x){\n    if(this.a[0]==x.a[0] & this.a[1] ==x.a[1]){\n        return true;\n    }\n    else return false;\n}\n\npublic int compareTo(IntegerArray x){\n    if(this.a[1] > x.a[1]){\n        return 1;\n    }\n    else if(this.a[1] < x.a[1]){\n        return -1;\n    }\n    else return 0;\n}\n```\n\n\n///////this is the code for Dijsktra's algorithm where  priority queue is used\n\n```\nfor (int i = 0; i < graph.get((int) node).size(); i++) {\n  alt = (int) (dist[(int) node] + graph.get((int)      node).get(i).weight);\n   if (alt < dist[ graph.get((int) node).get(i).vertex]) {\n     temp1.a[0]=graph.get(node).get(i).vertex;\n     temp1.a[1]=dist[graph.get(node).get(i).vertex];\n     System.out.println(\"temp1\" +\" \"+ temp1.a[0]+ \" \"+ temp1.a[1]);\n     Q.remove(temp1);   //it is not removing though the object   instance is present in the queue\n    dist[graph.get(node).get(i).vertex] = alt;\n   pred[graph.get(node).get(i).vertex] = node;\n   temp1.a[1]=dist[graph.get(node).get(i).vertex]; \n   System.out.println(\"temp1\" +\" \"+ temp1.a[0]+ \" \"+ temp1.a[1]);\n   Q.add(temp1);\n\n}\n```\n\n    ", "Answer": "\r\nYour method ```\nequals```\n is incorrect. The correct method has signature ```\npublic boolean equals(Object o)```\n, whereas yours has ```\npublic boolean equals(IntegerArray x)```\n (the type of the argument being different, the methods are distinct).\n\nIn ```\nPriorityQueue.remove```\n, it is the ```\nequals(Object)```\n that is called, and because you do not define it, the default implementation is called (comparison by identity).\n\nTry this instead:\n\n```\npublic boolean equals(Object o){\n    IntegerArray x = (IntegerArray)o;\n    return this.a[0] == x.a[0] && this.a[1] == x.a[1];\n}\n```\n\n\n[Update] code redundancy reduced.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue implemented as singly linked failing to update pointer refrence on insert\r\n                \r\nQuestion Edited: How can I insert into my linked list while keeping pointer references as arguments? My updated code is as follows: \n\nNote: I have a copy of the queue which was used in inserting a given node into the correct spot however I'm not seeing anyway to update the original queue as there no way to link the previous nodes. \n\nResolved: Working priority queue (FIFO) - Needs cleaning\n\n```\n#define QUEUE_HEAD_INDICATOR 0.0\n\nnamespace\n{\n    pq* create_node(float priority = 0, const string & text = \"\")\n    {\n        pq* q = new pq;\n        q->priority = priority;\n        q->text = text;\n        q->next = nullptr;\n        return q;\n    }\n}\n\npq* init_priority_queue() {\n    return create_node(QUEUE_HEAD_INDICATOR);\n}\n\n\nvoid insert(pq* &queue, string text, float priority) {\n    if (!queue) return;\n\n    pq* prev = queue;\n    pq* cursor = queue->next;\n    int offset = 0;\n\n    if(prev->priority == 0.0 && prev->text == \"\") {\n        prev->priority = priority;\n        prev->text = text;\n        return;\n    }\n    if(!cursor) {\n        if(prev->priority > priority) {\n            pq* node = create_node(priority, text);\n            node->next = prev;\n            prev = node;\n        } else {\n            pq* node = create_node(priority, text);\n            prev->next = node;\n        }\n    } else {\n        while(cursor && cursor->priority < priority) {\n            prev = cursor;\n            cursor = cursor->next;\n            offset++;\n        }\n        pq* node = create_node(priority, text);\n        if(offset == 0) {\n            if(cursor->priority == (int)node->priority) {\n                node->next = prev->next;\n                prev->next = node;\n                queue = prev;\n            } else {\n                node->next = prev;\n                prev = node;\n                queue = prev;\n            }\n        } else if(!cursor) {\n            prev->next = node;\n        } else {\n            node->next = prev->next;\n            prev->next = node;\n        }\n        return;\n    }\n}\n\n\nstring remove(pq* &queue) {\n    pq* prev = queue;\n    pq* cursor = queue->next;\n\n    if(!queue->next) {\n        string text = queue->text;\n        prev = NULL;\n        return text;\n    }\n\n    while(cursor->next) {\n        prev = cursor;\n        cursor = cursor->next;\n    }\n\n    prev->next = NULL;\n    string text = cursor->text;\n    return text;\n}\n```\n\n\nHere is what the struct looks like\n\n```\nstruct pq {\n    float priority;\n    string text;\n    pq* next;\n};\n```\n\n    ", "Answer": "\r\nI need to make an assumption here: ```\nqueue```\n is a reference to a pointer to the head node of a linked list. This seems a reasonable assumption because of the way it is used in the ```\nif(queue->next == NULL)```\n case.\n\nThe following code will overwrite the pointer to the head node, and subsequently every other node, leaking it.\n\n```\nwhile(queue->next && queue->next->key < priority) {\n    queue = queue->next; // bam! previous node leaked back at the caller\n}\n```\n\n\nYou could use a copy of the head node, but... There are much better ways to handle this.\n\nMy recommendation is to not pass pointer to a root node. Pass a pointer to the pointer to it. This handles the head case by making the head look exactly like every other node and eliminates most of the code. Since we're always keeping a pointer to the previous node's ```\nnext```\n we have easy access to the insertion point for a new node and the next node.\n\nYou cannot do this trick with a reference because a reference cannot be reassigned.\n\nExample:\n\n```\n#include <string>\n#include <iostream>\n\n// my best guess at what pq looks like\nstruct pq\n{\n    pq* next;\n    std::string text;\n    float key;\n};\n\nvoid insert(pq ** queue, // cannot reseat ref, so pointer required\n            const std::string &text, // ref eliminates copy.\n                                     // const because we don't want to change\n            float priority) {\n    while((*queue) && // search while more queues\n            (*queue)->key < priority) // and priority is low\n    {\n        queue = &(*queue)->next;\n    }\n    *queue = new pq{*queue, // if queue is null, end of list, if not inserted in middle\n                    text, \n                    priority}; \n}\n\n// Demo\nint main()\n{\n    pq * queue = NULL;\n\n    insert(&queue, \"c\", 5);\n    insert(&queue, \"a\", 1);\n    insert(&queue, \"b\", 2.5);\n    insert(&queue, \"e\", 10);\n    insert(&queue, \"d\", 7.5);\n\n    // print and clean-up.\n    while (queue)\n    {\n        std::cout << queue->text << std::endl;\n        pq * temp = queue; // temp so we don't lose queue\n        queue = queue->next;\n        delete temp; // release node\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "deallocating array of struct pointers in c implementation of priority queue\r\n                \r\nI have an issue freeing my array of struct pointers for a priority queue that I am implementing. I create two dynamic arrays of node pointers with a fixed size from client c program. The array heapMap contains node pointers that map to each created node with a specific ID integer value and the array heap is the heap array that contains the nodes with respect to their current values.\n\nEverything seems to work, however, my pq_free function seems to cause errors or doesn't properly deallocate the arrays. Any help would be appreciated\n\nStructures\n\n```\ntypedef struct node_struct{\n  int ID;\n  double val;\n}NODE;\n\nstruct pq_struct {\n  char heapType;\n  int max;\n  int inUse;\n  NODE ** heap;  //BOTH have a specific capacity\n  NODE **heapMap; //array of pointers to each \n};\n```\n\n\nThis is the function I use to allocate memory for the structure.\n\n```\n    PQ * pq_create(int capacity, int min_heap){\n\n\n  PQ * newQueue = (PQ*) malloc(sizeof(PQ)); //Allocate memory for a new heap\n  newQueue->max = capacity;\n  newQueue->inUse = 0;\n  int inUse = 1;//1 in use by default, the 0th point in the array is left alone intentionally\n\n  //If min_heap == 0, it it is a max heap, any other value is a min heap.\n  if(min_heap != 0){\n    newQueue->heapType = 'm';\n  }else{\n    newQueue->heapType = 'M';\n  }\n\n  //Allocate memory for heapMap and heap..\n\n  newQueue->heap = (NODE**) malloc(sizeof(NODE*)*capacity); //array of nodes, the heap\n\n\n  newQueue->heapMap = (NODE**) malloc(sizeof(NODE*) * capacity);//array of node pointers, the HEAPMAP\n  int i = 0;\n  for (i = 0; i < capacity + 1;i++) {\n      newQueue->heapMap[i] = NULL;\n  }\n\n  //return PQ pointer\n\n  return newQueue;\n}\n```\n\n\nThis is my pq_free function that doesn't seem to work properly. Thanks for help in advance.\n\n```\n void pq_free(PQ * pq){\n //free all nodes\n\n NODE * temp;\n NODE ** temp2;\n int i;\n for (i = 0; i < pq->inUse; i++) {\n     if (pq->heapMap[i] != NULL) {\n         temp = pq->heapMap[i];\n         free(temp);\n\n     }\n }\n //pq->heapMap = NULL;\n free(pq->heap);\n free(pq->heapMap);\n free(pq);\n\n\n}\n```\n\n    ", "Answer": "\r\nAs I was once railed on this site for doing this, I feel obligated to do the same to you. You shouldn't cast malloc because it is automatically cast to the assigned data type and can lead to some bad situations.\n\nOther than that how are the individual nodes allocated? What errors specifically are given? I think you are also walking off your heapMap as you allocate capacity but iterate over capacity + 1 elements.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why doesn't the .Net framework have a priority queue class?\r\n                \r\nThere are some threads on Stack Overflow dealing with implementing priority queues in .Net and C#.\n\nMy issue is of a more basic nature: Why isn't there a priority queue out of the box in the .Net framework? Even the C++ Standard Library has one.\n    ", "Answer": "\r\nThere was a question a while ago (why C# does allow non-member functions like C++) which prompted Eric Lippert to write a blog post about the reasons why. In it, he explains:\n\n\n  I am asked \"why doesn't C# implement feature X?\" all the time. The answer is always the same: because no one ever designed, specified, implemented, tested, documented and shipped that feature. All six of those things are necessary to make a feature happen. All of them cost huge amounts of time, effort and money. Features are not cheap, and we try very hard to make sure that we are only shipping those features which give the best possible benefits to our users given our constrained time, effort and money budgets.\n\n\nI suspect that is probably the answer to why .Net does not ship with a priority queue - there was just not enough time, effort, money, demand(?) to implement one.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "deallocating array of struct pointers in c implementation of priority queue\r\n                \r\nI have an issue freeing my array of struct pointers for a priority queue that I am implementing. I create two dynamic arrays of node pointers with a fixed size from client c program. The array heapMap contains node pointers that map to each created node with a specific ID integer value and the array heap is the heap array that contains the nodes with respect to their current values.\n\nEverything seems to work, however, my pq_free function seems to cause errors or doesn't properly deallocate the arrays. Any help would be appreciated\n\nStructures\n\n```\ntypedef struct node_struct{\n  int ID;\n  double val;\n}NODE;\n\nstruct pq_struct {\n  char heapType;\n  int max;\n  int inUse;\n  NODE ** heap;  //BOTH have a specific capacity\n  NODE **heapMap; //array of pointers to each \n};\n```\n\n\nThis is the function I use to allocate memory for the structure.\n\n```\n    PQ * pq_create(int capacity, int min_heap){\n\n\n  PQ * newQueue = (PQ*) malloc(sizeof(PQ)); //Allocate memory for a new heap\n  newQueue->max = capacity;\n  newQueue->inUse = 0;\n  int inUse = 1;//1 in use by default, the 0th point in the array is left alone intentionally\n\n  //If min_heap == 0, it it is a max heap, any other value is a min heap.\n  if(min_heap != 0){\n    newQueue->heapType = 'm';\n  }else{\n    newQueue->heapType = 'M';\n  }\n\n  //Allocate memory for heapMap and heap..\n\n  newQueue->heap = (NODE**) malloc(sizeof(NODE*)*capacity); //array of nodes, the heap\n\n\n  newQueue->heapMap = (NODE**) malloc(sizeof(NODE*) * capacity);//array of node pointers, the HEAPMAP\n  int i = 0;\n  for (i = 0; i < capacity + 1;i++) {\n      newQueue->heapMap[i] = NULL;\n  }\n\n  //return PQ pointer\n\n  return newQueue;\n}\n```\n\n\nThis is my pq_free function that doesn't seem to work properly. Thanks for help in advance.\n\n```\n void pq_free(PQ * pq){\n //free all nodes\n\n NODE * temp;\n NODE ** temp2;\n int i;\n for (i = 0; i < pq->inUse; i++) {\n     if (pq->heapMap[i] != NULL) {\n         temp = pq->heapMap[i];\n         free(temp);\n\n     }\n }\n //pq->heapMap = NULL;\n free(pq->heap);\n free(pq->heapMap);\n free(pq);\n\n\n}\n```\n\n    ", "Answer": "\r\nAs I was once railed on this site for doing this, I feel obligated to do the same to you. You shouldn't cast malloc because it is automatically cast to the assigned data type and can lead to some bad situations.\n\nOther than that how are the individual nodes allocated? What errors specifically are given? I think you are also walking off your heapMap as you allocate capacity but iterate over capacity + 1 elements.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How cna I implement a priority queue for edges in a graph?\r\n                \r\nI want to implement my own Priority Queue in C# using the naive approach. I need to use PQ for edges in a graph to implement Prims algorithm. Here is what I've done so far:\n\n```\npublic class Edge\n        {\n            private int v;         // one vertex\n            private int w;         // the other vertex\n            private int weight;    // edge weight\n\n            public Edge(int v0, int w0, int weight0)\n              {\n                  v = v0;\n                  w = w0;\n                  weight = weight0;\n              }\n\n           public Edge()\n            {\n                v = 0;\n                w = 0;\n                weight = 0;\n            } \n\n            public int get_weight()\n            {\n                return weight;\n            }\n\n            public int either()\n            {\n                return v;\n            }\n\n            public int the_other(int vertex)\n            {\n                if (vertex == v) return w;\n                else return v;\n            }\n\n            public int compareTo(Edge that)\n            {\n                if (this.get_weight() < that.get_weight()) return -1;\n                if (this.get_weight() < that.get_weight()) return 1;\n                else return 0;\n            }\n\n            public string to_str()\n            {\n                string s = v.ToString() + \" \" + weight.ToString() + \" \" + w.ToString() + '\\n';\n                return s;\n            }\n        }\n\n public class MyPriorityQueue_Edge\n        {\n            private List<Edge> q = new List<Edge>();\n            int size;\n            public MyPriorityQueue_Edge() \n            {\n                size = 0;\n            }\n\n            public void insert(Edge e)\n            {\n                q.Add(e);\n                size++;\n            }\n\n            Edge Min()\n            {\n                int min_weight = 1000;\n                Edge min_edge = new Edge();\n                foreach(Edge e in q)\n                    if(e.get_weight()< min_weight)\n                        min_edge = e;\n                return min_edge;\n            }\n\n            public Edge delmin()\n            {\n                Edge e  = q.Min();\n                q.Remove(e);\n                size--;\n                return e;\n            }\n\n          public bool is_empty()\n            {\n                if (size == 0) return true;\n                else return false;\n            }\n        }\n```\n\n\nWhen I compile it the compiler points to this line:\n\n```\nEdge e  = q.Min();\n```\n\n\nAnd says that I did not work on the exception \"System.Argument.Exception\". How can I fix this?\n    ", "Answer": "\r\nFrom MSDN ```\nEnumerable.Min<TSource> Method (IEnumerable<TSource>)```\n\n\n\n  If type TSource implements ```\nIComparable<T>```\n, this method uses that implementation to compare values. Otherwise, if type TSource implements ```\nIComparable```\n, that implementation is used to compare values. \n\n\nYou need to implement IComparable interface in your Edge class. \n\n```\npublic class Edge : IComparable```\n\n\nThen add a CompareTo() method. Something like\n\n```\npublic int CompareTo(object obj)\n{\n    if (obj is Edge)\n    {\n        Edge other = (Edge)obj;\n        return this.compareTo(other); // you already implemented this in your Edge class\n    }\n    else\n    {\n        throw new InvalidOperationException();\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I modify this Binary Search Tree ADT to implement Priority Queue ADT?\r\n                \r\nIncluded every file I got just in case, but the BinarySearchTree.h is at the end. I know priority queue needs to queue() which needs an int to give priority, dequeue() which will remove the top data, peek() will show data that was first in (FIFO way), but how will Implement a Priority Queue using this BinarySearchADT? I don't expect a full answer, but at least point me in the right direction.\nEdit: Added Prio_Queue ADT that uses the BinarySerachTree.h at the end. Still a bit clueless.\n```\n#pragma once\n\n#ifndef _BINARY_TREE_INTERFACE \n#define _BINARY_TREE_INTERFACE \n#include \"NotFoundException.h\"\ntemplate< class ItemType>\nclass BinaryTreeInterface\n{\npublic:\n\n    virtual bool isEmpty() const = 0;\n    virtual int getHeight() const = 0;\n    virtual int getNumberOfNodes() const = 0;\n    virtual ItemType getRootData() const = 0;\n    virtual void setRootData(const ItemType& newData) = 0;\n    virtual bool add(const ItemType & newData) = 0;\n    virtual bool remove(const ItemType & data) = 0;\n    virtual void clear() = 0;\n    virtual ItemType getEntry(const ItemType & anEntry) const throw(NotFoundException) = 0;\n    virtual bool contains(const ItemType & anEntry) const = 0;\n    virtual void preorderTraverse(void visit(ItemType&)) const = 0;\n    virtual void inorderTraverse(void visit(ItemType&)) const = 0;\n    virtual void postorderTraverse(void visit(ItemType&)) const = 0;\n}; \n#endif \n\n#pragma once\n#ifndef _BINARY_NODE \n#define _BINARY_NODE \ntemplate< class ItemType>\nclass BinaryNode\n{\nprivate:\n    ItemType item;\n    BinaryNode<ItemType>* leftChildPtr; \n    BinaryNode<ItemType>* rightChildPtr; \n\npublic:\n    BinaryNode();\n    BinaryNode(const ItemType& anItem);\n    BinaryNode(const ItemType& anItem,\n        BinaryNode<ItemType>* leftPtr,\n        BinaryNode<ItemType>* rightPtr);\n    void setItem(const ItemType& anItem);\n    ItemType getItem() const;\n    ItemType getCon() const;\n    bool isLeaf() const;\n    BinaryNode<ItemType>* getLeftChildPtr() const;\n    BinaryNode<ItemType>* getRightChildPtr() const;\n    void setLeftChildPtr(BinaryNode<ItemType>* leftPtr);\n    void setRightChildPtr(BinaryNode<ItemType>* rightPtr);\n};\n#endif \n\ntemplate<class ItemType> \nBinaryNode<ItemType>::BinaryNode():item(nullptr), leftChildPtr(nullptr), rightChildPtr(nullptr)\n{\n\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>::BinaryNode(const ItemType& anItem) :item(NULL), leftChildPtr(nullptr), rightChildPtr(nullptr)\n{\n\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>::BinaryNode(const ItemType& anItem, BinaryNode* leftPtr, BinaryNode* rightPtr) :item(anItem), leftChildPtr(nullptr), rightChildPtr(nullptr)\n{\n\n}\n\ntemplate<class ItemType>\nvoid BinaryNode<ItemType>::setItem(const ItemType& anItem)\n{\n    item = anItem;\n}\n\ntemplate<class ItemType>\nItemType BinaryNode<ItemType>::getItem() const\n{\n    return item;\n}\n\ntemplate<class ItemType>\nItemType BinaryNode<ItemType>::getCon() const\n{\n    return con;\n}\n\ntemplate<class ItemType>\nbool BinaryNode<ItemType>::isLeaf() const\n{\n    return ((leftChildPtr == nullptr) && (rightChildPtr == nullptr));\n}\n\ntemplate<class ItemType>\nvoid BinaryNode<ItemType>::setLeftChildPtr(BinaryNode* leftPtr) \n{\n    leftChildPtr = leftPtr;\n}\n\ntemplate<class ItemType>\nvoid BinaryNode<ItemType>::setRightChildPtr(BinaryNode* rightPtr)\n{\n    rightChildPtr = rightPtr;\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinaryNode<ItemType>::getLeftChildPtr() const\n{\n    return leftChildPtr;\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinaryNode<ItemType>::getRightChildPtr() const\n{\n    return  rightChildPtr;\n}\n\n\n#pragma once\n#ifndef _BINARY_NODE_TREE \n#define _BINARY_NODE_TREE \n#include \"BinaryTreeInterface.h\" \n#include \"BinaryNode.h\" \n#include \"PrecondViolatedExcep.h\" \n#include \"NotFoundException.h\" \n\ntemplate< class ItemType>\nclass BinaryNodeTree : public BinaryTreeInterface<ItemType>\n{\nprivate:\n BinaryNode<ItemType>* rootPtr;\nprotected:\n    // Recursive methods\n    int getHeightHelper(BinaryNode<ItemType>* subTreePtr) const;\n    int getNumberOfNodesHelper(BinaryNode<ItemType>* subTreePtr) const; \n    \n    void destroyTree(BinaryNode<ItemType>* subTreePtr);\n\n    BinaryNode<ItemType>* balancedAdd(BinaryNode<ItemType>* subTreePtr, BinaryNode<ItemType>* newNodePtr);\n    BinaryNode<ItemType>* removeValue(BinaryNode<ItemType>* subTreePtr, const ItemType target, bool& success);\n    BinaryNode<ItemType>* moveValuesUpTree(BinaryNode<ItemType>* subTreePtr);\n    BinaryNode<ItemType>* findNode(BinaryNode<ItemType>* treePtr, const ItemType& target, bool& success) const;\n    BinaryNode<ItemType>* copyTree(const BinaryNode<ItemType>* treePtr) const;\n\n    \n    void preorder(void visit(ItemType&), BinaryNode<ItemType>* treePtr) const;\n    void inorder(void visit(ItemType&), BinaryNode<ItemType>* treePtr) const;\n    void postorder(void visit(ItemType&), BinaryNode<ItemType>* treePtr) const;\npublic:\n    BinaryNodeTree();\n    BinaryNodeTree(const ItemType& rootItem);\n    BinaryNodeTree(const ItemType& rootItem, const BinaryNodeTree<ItemType>* leftTreePtr, const BinaryNodeTree<ItemType>* rightTreePtr);\n    BinaryNodeTree(const BinaryNodeTree<ItemType>& tree);\n    virtual ~BinaryNodeTree();\n    \n    bool isEmpty() const;\n    int getHeight() const;\n    int getNumberOfNodes() const;\n    ItemType getRootData() const throw(PrecondViolatedExcep);\n\n    void setRootData(const ItemType& newData);\n\n    bool add(const ItemType& newData); \n    bool remove(const ItemType& data); \n    void clear();\n    ItemType getEntry(const ItemType& anEntry) const throw(NotFoundException);\n    bool contains(const ItemType& anEntry) const;\n\n    void preorderTraverse(void visit(ItemType&)) const;\n    void inorderTraverse(void visit(ItemType&)) const;\n    void postorderTraverse(void visit(ItemType&)) const;\n\n    BinaryNodeTree& operator=(const BinaryNodeTree& rightHandSide);\n}; \n \n#endif \n\ntemplate<class ItemType>\nint BinaryNodeTree<ItemType>::getHeightHelper(BinaryNode<ItemType>* subTreePtr)const\n{\n    if (subTreePtr == nullptr)\n        return 0;\n    else\n        return 1 + max(getHeightHelper(subTreePtr->getLeftChildPtr()), getHeightHelper(subTreePtr->getRightChildPtr()));\n}\n\ntemplate<class ItemType>\nint BinaryNodeTree<ItemType>::getNumberOfNodesHelper(BinaryNode<ItemType>* subTreePtr)const\n{\n    if (subTreePtr == nullptr)\n        return 0;\n    else\n        return 1 + getNumberOfNodesHelper(subTreePtr->getLeftChildPtr())+ getNumberOfNodesHelper(subTreePtr->getRightChildPtr());\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinaryNodeTree<ItemType>::balancedAdd(BinaryNode<ItemType>* subTreePtr, BinaryNode<ItemType>* newNodePtr)\n{\n    if (subTreePtr == nullptr)\n        return newNodePtr;\n    else\n    {\n        BinaryNode<ItemType>* leftPtr = subTreePtr->getLeftChildPtr();\n        BinaryNode<ItemType>* rightPtr = subTreePtr->getRightChildPtr();\n        if (getHeightHelper(leftPtr) > getHeightHelper(rightPtr))\n        {\n            rightPtr = balancedAdd(rightPtr, newNodePtr);\n            subTreePtr->setRightChildPtr(rightPtr);\n        }\n        else\n        {\n            leftPtr = balancedAdd(leftPtr, newNodePtr);\n            subTreePtr->setLeftChildPtr(leftPtr);\n        }\n        return subTreePtr;\n    }\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinaryNodeTree<ItemType>::moveValuesUpTree(BinaryNode<ItemType>* subTreePtr)\n{\n    BinaryNode<ItemType>* leftPtr = subTreePtr->getLeftChildPtr();\n    BinaryNode<ItemType>* rightPtr = subTreePtr->getRightChildPtr();\n    int leftHeight = getHeightHelper(leftPtr);\n    int rightHeight = getHeightHelper(rightPtr);\n\n    if (leftHeight > rightHeight)\n    {\n        subTreePtr->setItem(leftPtr->getItem());\n        leftPtr = moveValuesUpTree(leftPtr);\n        subTreePtr->setLeftChildPtr(leftPtr);\n        return subTreePtr;\n    }\n    else\n    {\n        if (rightPtr != nullptr)\n        {\n            subTreePtr->setItem(rightPtr->getItem());\n            rightPtr = moveValuesUpTree(rightPtr);\n            subTreePtr->setRightChildPtr(rightPtr);\n            return subTreePtr;\n        }\n        else\n        {\n            delete subTreePtr;\n            return nullptr;\n        }\n    }\n\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinaryNodeTree<ItemType>::removeValue(BinaryNode<ItemType>* subTreePtr, const ItemType target, bool& success)\n{\n    if (subTreePtr == nullptr)\n        return nullptr;\n    if (subTreePtr->getItem() == target)\n    {\n        subTreePtr = moveValuesUpTree(subTreePtr);\n        success = true;\n        return subTreePtr;\n    }\n    else\n    {\n        BinaryNode<ItemType>* targetNodePtr = removeValue(subTreePtr->getLeftChildPtr(), target, success);\n        subTreePtr->setLeftChildPtr(targetNodePtr);\n        if (!success)\n        {\n            targetNodePtr = removeValue(subTreePtr->getRightChildPtr(), target, success);\n            subTreePtr->setRightChildPtr(targetNodePtr);\n        }\n        return subTreePtr;\n    }\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinaryNodeTree<ItemType>::findNode(BinaryNode<ItemType>* treePtr, const ItemType& target, bool& success) const\n{\n    if (treePtr == nullptr)\n        return nullptr;\n\n    if (treePtr->getItem() == target)\n    {\n        success = true;\n        return treePtr;\n    }\n    else\n    {\n        BinaryNode<ItemType>* targetNodePtr = findNode(treePtr->getLeftChildPtr(), target, success);\n        if (!success)\n        {\n            targetNodePtr = findNode(treePtr->getRightChildPtr(), target, success);\n        }\n        return targetNodePtr;\n    }\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinaryNodeTree<ItemType>::copyTree(const BinaryNode<ItemType>* treePtr) const\n{\n    BinaryNode* newTreePtr = nullptr;\n\n    if (treePtr != nullptr)\n    {\n        newTreePtr = new BinaryNode(treePtr->getItem(), nullptr, nullptr);\n        newTreePtr->setLeftChildPtr(copyTree(treePtr->getLeftChildPtr()));\n        newTreePtr->setRightChildPtr(copyTree(treePtr->getRightChildPtr()));\n    }\n    return newTreePtr;\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::destroyTree(BinaryNode<ItemType>* subTreePtr)\n{\n    if (subTreePtr != nullptr)\n    {\n        destroyTree(subTreePtr->getLeftChildPtr());\n        destroyTree(subTreePtr->getRightChildPtr());\n        delete subTreePtr;\n    }\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::preorder(void visit(ItemType&), BinaryNode<ItemType>* treePtr) const\n{\n    if (treePtr != nullptr)\n    {\n        ItemType theItem = treePtr->getItem();\n        visit(theItem);\n        preorder(visit, treePtr->getLeftChildPtr());\n        preorder(visit, treePtr->getRightChildPtr());\n    }\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::inorder(void visit(ItemType&), BinaryNode<ItemType>* treePtr) const\n{\n    if (treePtr != nullptr)\n    {\n        inorder(visit, treePtr->getLeftChildPtr());\n        ItemType theItem = treePtr->getItem();\n        visit(theItem);\n        inorder(visit, treePtr->getRightChildPtr());\n    }\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::postorder(void visit(ItemType&), BinaryNode<ItemType>* treePtr) const\n{\n    if (treePtr != nullptr)\n    {\n        postorder(visit, treePtr->getLeftChildPtr());\n        postorder(visit, treePtr->getRightChildPtr());\n        ItemType theItem = treePtr->getItem();\n        visit(theItem);\n\n    }\n}\ntemplate<class ItemType>\nBinaryNodeTree<ItemType>::BinaryNodeTree() : rootPtr(nullptr)\n{\n\n}\n\ntemplate<class ItemType>\nBinaryNodeTree<ItemType>::BinaryNodeTree(const ItemType& rootItem) \n{\n    rootPtr = new BinaryNode(rootItem, nullptr, nullptr);\n}\n\ntemplate<class ItemType>\nBinaryNodeTree<ItemType>::BinaryNodeTree(const ItemType& rootItem, const BinaryNodeTree* leftTreePtr, const BinaryNodeTree* rightTreePtr)\n{\n    rootPtr = new BinaryNode(rootItem, copyTree(leftTreePtr->rootPtr), copyTree(rightTreePtr->rootPtr));\n}\n\ntemplate<class ItemType>\nBinaryNodeTree<ItemType>::BinaryNodeTree(const BinaryNodeTree& treeItem)\n{\n    rootPtr = copyTree(treeItem.rootPtr);\n}\n\ntemplate<class ItemType>\nBinaryNodeTree<ItemType>::~BinaryNodeTree()\n{\n    destroyTree(rootPtr);\n}\n\ntemplate<class ItemType>\nbool BinaryNodeTree<ItemType>::isEmpty() const\n{\n    return rootPtr == nullptr;\n}\n\ntemplate<class ItemType>\nint BinaryNodeTree<ItemType>::getHeight() const\n{\n    return getHeightHelper(rootPtr);\n}\n\n\ntemplate<class ItemType>\nint BinaryNodeTree<ItemType>::getNumberOfNodes() const\n{\n    return getNumberOfNodesHelper(rootPtr);\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::clear() \n{\n    destroyTree(rootPtr);\n    rootPtr = nullptr;\n}\n\ntemplate<class ItemType>\nItemType BinaryNodeTree<ItemType>::getRootData()const throw (PrecondViolatedExcep)\n{\n    if (isEmpty())\n        throw PrecondViolatedExcep(\"getRootData() called with empty tree\");\n\n    return rootPtr->getItem();\n}\n\n//setRootData definition\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::setRootData(const ItemType& newItem)\n{\n    if (isEmpty())\n        rootPtr = new BinaryNode<ItemType>(newItem, nullptr, nullptr);\n    else\n        rootPtr->setItem(newItem);\n}\n\ntemplate<class ItemType>\nbool BinaryNodeTree<ItemType>::add(const ItemType& newData)\n{\n    BinaryNode<ItemType>* newNodePtr = new BinaryNode<ItemType>(newData);\n    rootPtr = balancedAdd(rootPtr, newNodePtr);\n\n    return true;\n}\n\n\ntemplate<class ItemType>\nbool BinaryNodeTree<ItemType>::remove(const ItemType& target)\n{\n    bool isSuccessful = false;\n    rootPtr = removeValue(rootPtr, target, isSuccessful);\n\n    return isSuccessful;\n}\n\ntemplate<class ItemType>\nItemType BinaryNodeTree<ItemType>::getEntry(const ItemType& anEntry) const throw (NotFoundException) \n{\n    bool isSuccessful = false;\n    BinaryNode<ItemType>* binaryNodePtr = findNode(rootPtr, anEntry, isSuccessful);\n\n    if (isSuccessful)\n        return binaryNodePtr->getItem();\n    else\n        throw PrecondViolatedExcep(\"Entry Not found in tree\");\n\n    \n}\n\ntemplate<class ItemType>\nbool BinaryNodeTree<ItemType>::contains(const ItemType& anEntry) const\n{\n    bool isSuccessful = false;\n    findNode(rootPtr, anEntry, isSuccessful);\n    return isSuccessful;\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::preorderTraverse(void visit(ItemType&))const\n{\n\n    preorder(visit, rootPtr);\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::inorderTraverse(void visit(ItemType&))const\n{\n\n    inorder(visit, rootPtr);\n}\n\ntemplate<class ItemType>\nvoid BinaryNodeTree<ItemType>::postorderTraverse(void visit(ItemType&))const\n{\n\n    postorder(visit, rootPtr);\n}\n\ntemplate<class ItemType>\nBinaryNodeTree<ItemType>& BinaryNodeTree<ItemType>::operator=(const BinaryNodeTree& rightHandSide)\n{\n    if (!isEmpty())\n        clear();\n    this = copyTree(&rightHandSide);\n\n    return *this;\n}\n\n#pragma once\n#define _NOT_FOUND_EXCEPTION\nusing namespace std;\n#include \"PrecondViolatedExcep.h\"\n#include <iostream>\n#include <string>\n#include <stdexcept> \nclass NotFoundException : public logic_error\n{\npublic:\n    NotFoundException(const string& message = \"\");\n\n};\n\n\nNotFoundException::NotFoundException(const string& message) : logic_error(\"Precondition Violated Exception: \" + message)\n{\n\n}\n\n#pragma once\n\n#ifndef _PRECOND_VIOLATED_EXCEP \n#define _PRECOND_VIOLATED_EXCEP \n#include <stdexcept> \n#include <string> \nusing namespace std;\nclass PrecondViolatedExcep : public logic_error\n{\npublic:\n    PrecondViolatedExcep(const string& message = \"\");\n}; \n\nPrecondViolatedExcep::PrecondViolatedExcep(const string & message) :\n    logic_error(\"Precondition Violated Exception: \" + message)\n{\n} \n#endif \n\n#pragma once\n#ifndef _BINARY_SEARCH_TREE\n#define _BINARY_SEARCH_TREE\n#include \"BinaryTreeInterface.h\"\n#include \"BinaryNodeTree.h\"\n#include \"NotFoundException.h\"\n#include \"PrecondViolatedExcep.h\"\ntemplate<class ItemType>\nclass BinarySearchTree : public BinaryNodeTree<ItemType>\n{\nprivate:\n    BinaryNode<ItemType>* rootPtr;\n\nprotected:\n    //------------------------------------------------------------\n    // Protected Utility Methods Section:\n    // Recursive helper methods for the public methods.\n    //------------------------------------------------------------\n    // Recursively finds where the given node should be placed and\n    // inserts it in a leaf at that point.\n    BinaryNode<ItemType>* insertInorder(BinaryNode<ItemType>* subTreePtr, BinaryNode<ItemType>* newNode);\n\n    BinaryNode<ItemType>* removeValue(BinaryNode<ItemType>* subTreePtr,const ItemType target,bool& success);\n\n    BinaryNode<ItemType>* removeNode(BinaryNode<ItemType>* nodePtr);\n\n    BinaryNode<ItemType>* removeLeftmostNode(BinaryNode<ItemType>* subTreePtr, ItemType& inorderSuccessor);\n\n    BinaryNode<ItemType>* findNode(BinaryNode<ItemType>* treePtr, const ItemType& target) const;\n\npublic:\n    //------------------------------------------------------------\n    // Constructor and Destructor Section.\n    //------------------------------------------------------------\n    BinarySearchTree();\n    BinarySearchTree(const ItemType& rootItem);\n    BinarySearchTree(const BinarySearchTree<ItemType>& tree);\n    virtual ~BinarySearchTree();\n\n    //------------------------------------------------------------\n    // Public Methods Section.\n    //------------------------------------------------------------\n    bool isEmpty() const;\n    int getHeight() const;\n    int getNumberOfNodes() const;\n    ItemType getRootData() const throw(PrecondViolatedExcep);\n    void setRootData(const ItemType& newData) const throw(PrecondViolatedExcep);\n    bool add(const ItemType& newEntry);\n    bool remove(const ItemType& anEntry);\n    void clear();\n    ItemType getEntry(const ItemType& anEntry) const throw(NotFoundException);\n    bool contains(const ItemType& anEntry) const;\n\n    //------------------------------------------------------------\n    // Public Traversals Section.\n    //------------------------------------------------------------\n    void preorderTraverse(void visit(ItemType&)) const;\n    void inorderTraverse(void visit(ItemType&)) const;\n    void postorderTraverse(void visit(ItemType&)) const;\n    //------------------------------------------------------------\n    // Overloaded Operator Section.\n    //------------------------------------------------------------\n    BinarySearchTree<ItemType>& operator=(const BinarySearchTree<ItemType>&\n        rightHandSide);\n}; \n#endif\n\n#include <iostream>\n\ntemplate<class ItemType>\nBinaryNode<ItemType>*BinarySearchTree<ItemType>::insertInorder(BinaryNode<ItemType>*subTreePtr, BinaryNode<ItemType>*newNodePtr)\n{\n    if (subTreePtr == nullptr)\n        return newNodePtr;\n    else\n    {\n        if (subTreePtr->getItem() > newNodePtr->getItem())\n            subTreePtr->setLeftChildPtr(insertInorder(subTreePtr -> getLeftChildPtr(), newNodePtr));\n        else\n            subTreePtr->setRightChildPtr(insertInorder(subTreePtr -> getRightChildPtr(), newNodePtr));\n        return subTreePtr;\n    }\n}\n\n\ntemplate<class ItemType>\nBinaryNode<ItemType>*\nBinarySearchTree<ItemType>::removeValue(BinaryNode<ItemType>*subTreePtr,\n    const ItemType target,\n    bool& success)\n{\n    if (subTreePtr == nullptr)\n    {\n        success = false;\n        return nullptr;\n    }\n    if (subTreePtr->getItem() == target)\n    {\n        subTreePtr = removeNode(subTreePtr);\n        success = true;\n        return subTreePtr;\n    }\n    else\n    {\n        if (subTreePtr->getItem() > target)\n            subTreePtr->setLeftChildPtr(removeValue(subTreePtr->getLeftChildPtr(), target, success));\n        else\n            subTreePtr->setRightChildPtr(removeValue(subTreePtr->getRightChildPtr(), target, success));\n        return subTreePtr;\n    }\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>*\nBinarySearchTree<ItemType>::removeNode(BinaryNode<ItemType>* nodePtr)\n{\n    if (nodePtr->isLeaf())\n    {\n        delete nodePtr;\n        return (nodePtr = nullptr);\n    }\n    else if (nodePtr->getLeftChildPtr() == nullptr)\n    {\n        BinaryNode<ItemType>* nodeToConnectPtr = nodePtr->getRightChildPtr();\n        delete nodePtr;\n        nodePtr = nullptr;\n        return nodeToConnectPtr;\n    }\n    else if (nodePtr->getRightChildPtr() == nullptr)\n    {\n        BinaryNode<ItemType>* nodeToConnectPtr = nodePtr->getLeftChildPtr();\n        delete nodePtr;\n        nodePtr = nullptr;\n        return nodeToConnectPtr;\n    }\n    else\n    {\n        ItemType newNodeValue;\n        nodePtr->setRightChildPtr(removeLeftmostNode(nodePtr-> getRightChildPtr(), newNodeValue));\n        nodePtr->setItem(newNodeValue);\n        return nodePtr;\n    }\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>*\nBinarySearchTree<ItemType>::removeLeftmostNode(BinaryNode<ItemType>* nodePtr,\n    ItemType& inorderSuccessor)\n{\n    if (nodePtr->getLeftChildPtr() == nullptr)\n    {\n        inorderSuccessor = nodePtr->getItem();\n        return removeNode(nodePtr);\n    }\n    else\n    {\n        nodePtr->setLeftChildPtr(removeLeftmostNode(nodePtr-> getLeftChildPtr(), inorderSuccessor));\n        return nodePtr;\n    }\n}\n\ntemplate<class ItemType>\nBinaryNode<ItemType>* BinarySearchTree<ItemType>::findNode(BinaryNode<ItemType>*subTreePtr, const ItemType& target) const\n{\n    if (subTreePtr == nullptr)\n        return nullptr;\n    else if (subTreePtr->getItem() == target)\n        return subTreePtr;\n    else if (subTreePtr->getItem() > target)\n        return findNode(subTreePtr->getLeftChildPtr(), target);\n    else\n        return findNode(subTreePtr->getRightChildPtr(), target);\n}\n\ntemplate<class ItemType>\nBinarySearchTree<ItemType>::BinarySearchTree() : rootPtr(nullptr)\n{\n} \ntemplate<class ItemType>\nBinarySearchTree<ItemType>::BinarySearchTree(const ItemType& rootItem)\n{\n    rootPtr = new BinaryNode<ItemType>(rootItem, nullptr, nullptr);\n}\ntemplate<class ItemType>\nBinarySearchTree<ItemType>::BinarySearchTree(const BinarySearchTree<ItemType>&\n    treePtr)\n{\n    rootPtr = this->copyTree(treePtr.rootPtr);\n} \n\ntemplate<class ItemType>\nBinarySearchTree<ItemType>::~BinarySearchTree()\n{\n    this->destroyTree(rootPtr);\n}\n\ntemplate<class ItemType>\nbool BinarySearchTree<ItemType>::isEmpty() const\n{\n    return rootPtr == nullptr;\n}\ntemplate<class ItemType>\nint BinarySearchTree<ItemType>::getHeight() const\n{\n    return this->getHeightHelper(rootPtr);\n}\ntemplate<class ItemType>\nint BinarySearchTree<ItemType>::getNumberOfNodes() const\n{\n    return this->getNumberOfNodesHelper(rootPtr);\n}\ntemplate<class ItemType>\nvoid BinarySearchTree<ItemType>::clear()\n{\n    this->destroyTree(rootPtr);\n    rootPtr = nullptr;\n}\ntemplate<class ItemType>\nItemType BinarySearchTree<ItemType>::getRootData() const\nthrow(PrecondViolatedExcep)\n{\n    if (isEmpty())\n        throw PrecondViolatedExcep(\"getRootData() called with empty tree.\");\n    return rootPtr->getItem();\n}\ntemplate<class ItemType>\nbool BinarySearchTree<ItemType>::add(const ItemType& newData)\n{\n    BinaryNode<ItemType>* newNodePtr = new BinaryNode<ItemType>(newData);\n    rootPtr = insertInorder(rootPtr, newNodePtr);\n    return true;\n}\ntemplate<class ItemType>\nbool BinarySearchTree<ItemType>::remove(const ItemType& target)\n{\n    bool isSuccessful = false;\n    rootPtr = removeValue(rootPtr, target, isSuccessful);\n    return isSuccessful;\n}\n\ntemplate<class ItemType>\nItemType BinarySearchTree<ItemType>::getEntry(const ItemType& anEntry) const\nthrow(NotFoundException)\n{\n    BinaryNode<ItemType>* nodeWithEntry = findNode(rootPtr, anEntry);\n    if (nodeWithEntry == nullptr)\n        throw NotFoundException(\"Entry not found in tree.\");\n    else\n        return nodeWithEntry->getItem();\n}\n\ntemplate<class ItemType>\nbool BinarySearchTree<ItemType>::contains(const ItemType& anEntry) const\n{\n    return findNode(rootPtr, anEntry);\n}\n\ntemplate<class ItemType>\nvoid BinarySearchTree<ItemType>::preorderTraverse(void visit(ItemType&)) const\n{\n    this->preorder(visit, rootPtr);\n} \n\ntemplate<class ItemType>\nvoid BinarySearchTree<ItemType>::inorderTraverse(void visit(ItemType&)) const\n{\n    this->inorder(visit, rootPtr);\n} \n\ntemplate<class ItemType>\nvoid BinarySearchTree<ItemType>::postorderTraverse(void visit(ItemType&)) const\n{\n    this->postorder(visit, rootPtr);\n} \n\n\ntemplate<class ItemType>\nBinarySearchTree<ItemType>& BinarySearchTree<ItemType>::\noperator=(const BinarySearchTree<ItemType>& rightHandSide)\n{\n    if (!isEmpty())\n        clear();\n    this = copyTree(&rightHandSide);\n    return *this;\n} \n\n#pragma\n#include \"BinarySearchTree.h\"\n\n\ntemplate<class ItemType>\nclass Prio_Queue : public BinarySearchTree<ItemType>\n{\n    BinarySearchTree<ItemType> BST;\n\npublic:\n    Prio_Queue();\n    void Enqueue(ItemType);\n    void Dequeue(ItemType);\n    void Peek();\n};\n\ntemplate<class ItemType>\nPrio_Queue<ItemType>::Prio_Queue()\n{\n}\n\ntemplate<class ItemType>\nvoid Prio_Queue<ItemType>::Enqueue(ItemType entry)\n{\n    if (BST.isEmpty())\n    {\n        BST.setRootData(entry);\n    }\n    else\n        BST.add(entry);\n}\n\ntemplate<class ItemType>\nvoid Prio_Queue<ItemType>::Dequeue(ItemType entry)\n{\n    BST.remove(entry);\n}\n\ntemplate<class ItemType>\nvoid Prio_Queue<ItemType>::Peek()\n{\n    cout << BST.getRootData();\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "RabbitMQ: Priority queue with changing priority\r\n                \r\nI want to implement a priority work queue, in which the priority of a group of messages can change once they are in the queue. Since it is a work queue with variable processing time, the messages are not assigned using round-robin algorithm, but are pulled from the queue when a resource is free (using per-consumer limit).\n\nI came up with 2 ideas for implementation:\n\n\nUse priority queue from RabbitMQ, and when a request for priority change comes, read messages with this priority from the queue and re-send them with different priority. (I am not sure this is a good approach, given the O(n) complexity.)\nUse several queues with distinct names for each group of messages, and use a separate queue to communicate the current priority list (ordered list of queue names) to workers. (Using this approach, I am not sure how to make the list of priorities \"persistent\", so that newly joined worker knows what is the current priority list.)\n\n\nHow would you implement it? Is RabbitMQ viable option for this use case?\n    ", "Answer": "\r\nyour idea \"priority of a message can change once they are in the queue\" IMO is not possible with rabbitmq because rabbitmq only allows you to get messages from the head of a queue.\nfor example:\n\nyou have N queues each used for a different priority\neach queue has 100+ messages\nyour idea requires you to reach into the middle of a queue to get a specific message but this is not possible with rabbitmq so the thought experiment stops here because you can only get messages at the head of a queue\n\nyour idea IMO would require using something else besides rabbitmq.\na quick and dirty idea that would work with rabbitmq now and is similar to your idea:\n\ncreate one rabbitmq queue with N priorities\nsubmit a message with priority ```\nx```\n\nif you need to change the priority to higher priority like priority y then you could send the same message again but with a new higher priority ```\ny```\n\nthis would ensure the new message is processed faster\nthe side effect is that you may process the same request twice\n\nyou could fix the side effect in your design by having a some sort of database for synchronization to keep track of what jobs are completed and then this could avoid processing the job twice\nthere are many other details that would need to be addressed like keeping the original message around somehow outside of rabbitmq, concurrency, etc, etc,\n\n\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Objective-c Priority Queue\r\n                \r\nI've started using Objective-c for iOS programming. I switched over from Java, and I wanted to know if there were any existing libraries like the Java Collections Framework for Obj-c, more specifically a priority queue implementation. I've done some searches, but have been unable to come up with anything.\n\nUPDATE: I found this, but would have no idea how to use it myself: http://www.ohloh.net/p/pqlib\n    ", "Answer": "\r\nI was unable to find an implementation of a priority queue, so I went ahead and made my own. I'm not sure how robust it is, but I hope it might point others in the right direction.\n\nPriorityQueue.h\n\n```\n//\n//  PriorityQueue.h\n//\n\n#import <Foundation/Foundation.h>\n#import \"comparable.h\"\n\n//Implements a priority queue. All objects in queue must implement the comparable protocol and must be all of the same type. The queue can be explicity typed at initialization, otherwise the type of the first object entered will be the type of the queue\n@interface PriorityQueue : NSObject{\n    NSMutableArray *queue;\n    Class type;\n}\n\n- (id)init;\n- (id)initWithObjects:(NSSet *)objects;\n- (id)initWithCapacity:(int)capacity;\n- (id)initWithCapacity:(int)capacity andType:(Class)oType; //Queue will reject objects not of that type\n\n#pragma mark - Useful information\n- (BOOL)isEmpty;\n- (BOOL)contains:(id<comparable, NSObject>)object;\n- (Class)typeOfAllowedObjects; //Returns the type of objects allowed to be stored in the queue\n- (int) size;\n\n#pragma mark - Mutation\n- (void)clear;\n- (BOOL)add:(id<comparable, NSObject>)object;\n- (void)remove:(id<comparable, NSObject>)object;\n\n#pragma mark - Getting things out\n- (id)peek;\n- (id)poll;\n- (id)objectMatchingObject:(id<comparable, NSObject>)object;\n- (NSArray *)toArray;\n\n#pragma mark -\n- (void)print;\n\n@end\n```\n\n\nPriorityQueue.m\n\n```\n//\n//  PriorityQueue.m\n//\n\n#import \"PriorityQueue.h\"\n\n#define INITIAL_CAPACITY 50\n@implementation PriorityQueue\n\n#pragma mark - Initialization\n- (id)init{\n    return [self initWithCapacity:INITIAL_CAPACITY andType:nil];\n}\n\n- (id)initWithObjects:(NSSet *)objects{\n    self = [self initWithCapacity:INITIAL_CAPACITY andType:nil];\n    for (id<comparable, NSObject>object in objects){\n        [self add:object];\n    }\n    return self;\n}\n\n- (id)initWithCapacity:(int)capacity{\n    return [self initWithCapacity:capacity andType:nil];\n}\n\n- (id)initWithCapacity:(int)capacity andType:(Class)oType{\n    self = [super init];\n    if(self){\n        queue = [[NSMutableArray alloc] init];\n        type = oType;\n    }\n    return self;\n}\n\n#pragma mark - Useful information\n- (BOOL)isEmpty{\n    if(queue.count == 0){\n        return YES;\n    }\n    else{ return NO;}\n}\n\n- (BOOL)contains:(id<comparable, NSObject>)object{\n    //Search the array to see if the object is already there\n    for(id<comparable> o in queue){\n        if([o isEqual:object]){\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (Class)typeOfAllowedObjects{\n    NSLog(@\"Allowed Types: %@\", type);\n    return type;\n}\n\n- (int) size{\n    return [queue count];\n}\n\n#pragma mark - Mutation\n//Mutation\n- (void)clear{\n    [queue removeAllObjects];\n}\n\n//A \"greater\" object (compareTo returns 1) is at the end of the queue.\n- (BOOL)add:(id<comparable, NSObject>)object{\n    //Make sure the object's type is the same as the type of the queue\n    if(type == nil){\n//        NSLog(@\"Type is nil\");\n        type = [object class];\n    }\n    if([object class] != type){\n        NSLog(@\"ERROR: Trying to add incorrect object\");\n        return NO;\n    }\n\n    if([queue count] == 0){\n        [queue addObject:object];\n        return YES;\n    }\n    for(int i = 0; i < [queue count]; i++){\n        if([object compareTo:queue[i]] < 0){\n            [queue insertObject:object atIndex:i];\n            return YES;\n        }\n    }\n    [queue addObject:object];\n    return YES;\n}\n\n- (void)remove:(id<comparable, NSObject>)object{\n    [queue removeObject:object];\n}\n\n#pragma mark - Getting things out\n- (id)peek{\n    return queue[0];\n}\n\n- (id)poll{\n    //Get the object at the front\n    id head = queue[0];\n\n    //Remove and return that object\n    [queue removeObject:head];\n    return head;\n}\n\n- (id)objectMatchingObject:(id<comparable, NSObject>)object{\n    //Search the array to see if the object is already there\n    for(id<comparable> o in queue){\n        if([o isEqual:object]){\n            return o;\n        }\n    }\n    return nil;\n}\n\n- (NSArray *)toArray{\n    return [[NSArray alloc] initWithArray:queue];\n}\n\n#pragma mark -\n- (NSString *)description{\n    return [NSString stringWithFormat:@\"PriorityQueue: %@ allows objects of type %@\", queue, type];\n}\n\n- (void)print{\n    NSLog(@\"%@\", [self description]);\n}\n\n@end\n```\n\n\nComparable.h\n\n```\n//\n//  comparable.h\n//\n\n#import <Foundation/Foundation.h>\n\n\n//NOTE: Class must check to make sure it is the same class as whatever is passed in\n@protocol comparable\n\n- (int)compareTo:(id<comparable, NSObject>)object;\n- (BOOL)isEqual:(id<comparable, NSObject>)object;\n\n@end\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing a priority queue that can be iterated over in C++\r\n                \r\nI need to implement a priority queue for a project, but the STL's ```\npriority_queue```\n is not indicated since we need to iterate over all elements and remove them randomly.\n\nWe are thinking about using the STL's ```\nset```\n for this, wrapping it in a class to make it an ADT.\n\nIs there a smarter solution for this?\n\nHow can we make it so some of ```\nset```\n's public member functions can be used publicly? We're interested in iterators, etc.\n\nApparently deriving the STL is unwise because of the lack of virtual destructors :/\n\n\n\nNew code:\n\n```\n#ifndef PRIORITYQUEUE_H_\n#define PRIORITYQUEUE_H_\n\n#include <set>\n\ntemplate<typename T, template<typename X> class impl_type = std::set>\nclass PriorityQueue {\n    typedef impl_type<T> set_type;\n    typedef typename set_type::iterator iterator;\npublic:\n    void push(const T& x) {\n        insert(x);\n\n    }\n\n    void pop() {\n        erase(begin());\n    }\n\n    const T& top() const {\n        return *begin();\n    }\n};\n\n#endif /* PRIORITYQUEUE_H_ */\n```\n\n\nSo, we currently have this. The compiler doesn't complain about insert, but it does complain about ```\nerase(begin())```\n and ```\nreturn *begin()```\n:\n\n```\nthere are no arguments to 'begin' that depend on a template parameter, so a declaration of 'begin' must be available```\n\n\nWhy is this?\n    ", "Answer": "\r\nDo you really need a priority queue ?\n\nYou need iterate over all items and remove randomly -> linked list\n\nIf you need to keep the list sorted, sort it at the beginning and then, when inserting new item, use insertion sort (insert new item on right place).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queues(heaps) implementation for parallel processing\r\n                \r\nGiven \"n\" threads and \"m\" jobs of varying time taken to complete. If there is a free thread, it immediately takes the next job from the list. If a thread has started processing a job, it doesn’t interrupt or stop until it finishes processing the job. If several threads try to take jobs from the list simultaneously, the thread with a smaller index takes the job.\nDetermine for each job which thread will process it and when will it start processing.\nInput :\n```\n2 5 # n m\n1 2 3 4 5 # 𝑚 integers 𝑡𝑖 — the times in seconds it takes any thread to process the 𝑖-the job.\n```\n\nOutput :\n```\n0 0  # worker starting_time\n1 0\n0 1\n1 2\n0 4\n```\n\nMy code :\n```\nfrom collections import namedtuple\n\nAssignedJob = namedtuple(\"AssignedJob\", [\"worker\", \"started_at\"])\n\ndef heapify(arr, i=0):# MIN HEAP\n\n  #  0 --> time, 1 --> worker\n\n  smallest = i\n  l = 2*i + 1 # left child of node i\n  r = 2*i + 2 # right child of node i\n\n  if l < len(arr)  and arr[l][0] < arr[smallest][0]:\n    smallest = l\n\n  if r < len(arr)  and arr[r][0] < arr[smallest][0]:\n    smallest = r\n  \n  if smallest != i:\n\n    arr[i], arr[smallest] = arr[smallest], arr[i]\n    heapify(arr, smallest)\n\n  return arr[0][1] # worker whose time is lowest (top of min-heap)\n\n\ndef assign_jobs(n_workers, jobs):\n\n    result = []\n    next_free_time = [0] * n_workers\n\n    for job in jobs:\n\n        zip_time_workers = list(zip(next_free_time, [i for i in range(n_workers)]))\n        #list of tuples --> (time, worker)\n\n        next_worker = heapify(zip_time_workers)\n        # get worker with highest priority\n\n        result.append(AssignedJob(next_worker, next_free_time[next_worker]))\n        next_free_time[next_worker] += job\n\n    return result\n\n\ndef main():\n    n_workers, n_jobs = map(int, input().split())\n    jobs = list(map(int, input().split()))\n    assert len(jobs) == n_jobs\n\n    assigned_jobs = assign_jobs(n_workers, jobs)\n\n    for job in assigned_jobs:\n        print(job.worker, job.started_at)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nIt passes the sample case mentioned above but fails on others.\nFailing Test case input :\n```\n4 20\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n```\n\nExpected Output:\n```\n0 0\n1 0\n2 0\n3 0\n0 1\n1 1\n2 1\n3 1\n0 2\n1 2\n2 2\n3 2\n0 3\n1 3\n2 3\n3 3\n0 4\n1 4\n2 4\n3 4\n```\n\nWhat am I doing wrong? a better implementation is also welcomed, thanks!\nEDIT: cannot use python's pre-defined functions for priority queues (need underlying logic/approach)\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "difference between binary queue and sorted queue\r\n                \r\nI'm trying to understand the difference between binary queues and sorted queues. I know that the sorted priority queue implements the priority queue interface by maintaining a sorted vector. But what exactly does a binary queue do?\n\nSo for example, if i were trying to code this what would be the difference?\n\n```\n//Assumes that all elements in the priority queue are out of order.\n//             Reorder the data so that the PQ invariant is restored.\n//Runtime: O(n log n)\ntemplate<typename TYPE, typename COMP_FUNCTOR>\nvoid SortedPQ<TYPE, COMP_FUNCTOR>::updatePriorities() {\n    //Implementation here\n}\n\n//Assumes that all elements in the priority queue are out of order.\n//             Reorder the data so that the PQ invariant is restored.\n //Runtime: O(n)\ntemplate<typename TYPE, typename COMP_FUNCTOR>\nvoid BinaryPQ<TYPE, COMP_FUNCTOR>::updatePriorities() {\n    //Implementation here\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "compare objects in priority queue\r\n                \r\nI implemented a priority queue with linked list like this,when for first time I make an object from seller class and add it to priority queue, it works, but when I make second object from seller to\nadd it to priority queue,it gives an error, I know that my comparator makes this error, but I don't \nknow, how can I compare objects, please help me!\n\n```\nimport java.util.Comparator;\n\npublic class PQueueTest {\n\n    public static void main(String [] args) {\n\n        DefaultComparator<Seller> o = new DefaultComparator<>();\n        Seller s = new Seller(\"ali\", 125, 200);\n        Seller s1 = new Seller(\"hasan\", 50, 100);\n        PriorityQueue<Seller> p = new PriorityQueue<>(o);\n\n        p.add(s);\n        p.add(s1);\n\n        System.out.println(p.removeMin());\n        System.out.println(p.removeMin());\n    }\n\n}\n\nclass Node<E> {\n\n    private E element;\n    private Node<E> next;\n\n    public Node(E element, Node<E> next) {\n        this.element = element;\n        this.next = next;\n    }\n\n    public void setNext(Node<E> next) {\n        this.next = next;\n    }\n\n    public void setElement(E element) {\n        this.element = element;\n    }\n\n    public Node<E> getNext() {\n        return next;\n    }\n\n    public E getElement() {\n        return element;\n    }\n}\n\nclass DefaultComparator<E> implements Comparator<E> {\n\n    @Override\n    public int compare(E a, E b) {\n        return ((Comparable<E>) a).compareTo(b);\n    }\n}\n\nclass PriorityQueue<E> {\n\n    private int size;\n    private Node<E> front;\n    private DefaultComparator<E> c;\n\n    public PriorityQueue(Comparator<? super E> o) {\n        size = 0;\n        front = null;\n        c = (DefaultComparator<E>) o;\n\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public void add(E element) {\n        Node<E> v = new Node<>(element, null);\n        if (isEmpty()) {\n            front = v;\n        }\n\n        if (size >= 1) {\n            Node<E> temp = front;\n\n            int comp = c.compare(element, temp.getElement());\n            while (comp >= 0 && temp.getNext() != null) {\n                temp = temp.getNext();\n                comp = c.compare(element, temp.getElement());\n            }\n\n            if (comp < 0) {\n                // E x = temp.getElement();\n                v.setNext(temp);\n                if (temp == front)\n                    front = v;\n                else {\n                    Node<E> tmp = front;\n                    while (tmp.getNext() != temp) {\n                        tmp = tmp.getNext();\n                    }\n                    tmp.setNext(v);\n                }\n            }\n\n            if (comp >= 0)\n                temp.setNext(v);\n        }\n        size++;\n    }\n\n    public E removeMin() {\n        E remove = front.getElement();\n        front = front.getNext();\n        size--;\n        return remove;\n    }\n\n    public E removeMax() {\n        Node<E> tmp = front;\n        while (tmp.getNext().getNext() != null) {\n            tmp = tmp.getNext();\n        }\n        E remove = tmp.getNext().getElement();\n        tmp.setNext(null);\n        size--;\n        return remove;\n\n    }\n\n    public E peekMin() {\n        E remove = front.getElement();\n        return remove;\n    }\n\n    public E peekMax() {\n        Node<E> tmp = front;\n        while (tmp.getNext().getNext() != null) {\n            tmp = tmp.getNext();\n        }\n        E remove = tmp.getNext().getElement();\n        return remove;\n    }\n\n}\n\nclass Seller {\n\n    private String name;\n    private long price;\n    private int stock;\n\n    public Seller(String name, long price, int stock) {\n        this.name = name;\n        this.price = price;\n        this.stock = stock;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setPrice(long price) {\n        this.price = price;\n    }\n\n    public void setStock(int stock) {\n        this.stock = stock;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public long getPrice() {\n        return price;\n    }\n\n    public int getStock() {\n        return stock;\n    }\n\n}\n\nclass Buyer {\n\n    private String name;\n    private long price;\n    private int stock;\n\n    public Buyer(String name, long price, int stock) {\n        this.name = name;\n        this.price = price;\n        this.stock = stock;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setPrice(long price) {\n        this.price = price;\n    }\n\n    public void setStock(int stock) {\n        this.stock = stock;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public long getPrice() {\n        return price;\n    }\n\n    public int getStock() {\n        return stock;\n    }\n\n}\n```\n\n    ", "Answer": "\r\nFirst of all: The error is that the cast to Comparable fails. I.e., this line of code:\n\n```\nreturn ((Comparable<E>)a).compareTo(b);\n```\n\n\nThe reason for that is, that ```\na```\n  (in your case, an instance of ```\nSeller```\n) does not implement the Comparable interface. You want to compare instances of ```\nSeller```\n, so ```\nSeller```\n needs to implement the interface (and the corresponding methods):\n\n```\nclass  Seller implements Comparable<Seller> {\n```\n\n\nHowever you should be aware that Comparator and Comparable are usually two opposing concepts. While the implementation of Comparable allows instances of a class to compare themselves with other instances of that class, with a Comparator this comparison is encapsuled inside another class. Combining those concept usually makes no sense.\n\nSo you should\n\n\nUnderstand what, why and how you should compare\nDecide on one of the two concepts (Comparable or Comparator). Googling this should bring up good results.\nIf it's the Comparator, assert that only those types can be passed to your Comparator that can be handled by it (hint: take a look at the generic parameter)\n\n\nAnd last but not least: Take a look at the warnings your IDE gives you about type safety. Understand them and you will find the major flaw in your code.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Scheduler using Thread Pool & Priority Queue?\r\n                \r\nI'm gonna implement a scheduler using thread pool & priority queue in Java and I want to ask whether anybody knows any existing implementations or not, so I don't have spend time on it :-)...\n\nBasically, the ScheduledThreadPoolExecutor in java.util.concurrent package provides almost functions I need except the \"priority queue\". As I roughly checked the built-in java libraries, I couldn't find any priority queue which supports modifying & updating \"priority\" value of an element externally after it has been put to the queue.\n\nI need this kind of priority queue to be used in a downloader-liked project. I want to allow users to modify the priority of each download on-the-fly and its position in the queue is automatically updated. The PriorityQueue is not implemented in this way, in order to get correct priority, each time we change its priority value we have to remove & submit it again...\n\nDid anybody work on this before?\n    ", "Answer": "\r\nYou can check PriorityQueue or PriorityBlockingQueue. I don't think either of them allow you to modify the priority. But you can always remove an element and add it back with modified priority.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing priority queue in C++\r\n                \r\nI am trying to implement a queue using a circular array.  My code is supposed to be able to remove the lowest number from the queue.  I created test code that should output 1 2 3 4 5 as the lowest values being removed but my actual output is 3 2 1 8 7.  I am not sure if my problem is that my code for finding the lowest value is incorrect or there is a problem with how i am coding the actual queue.  I suspect both but I'd appreciate any suggestions or tips to finding the problems in my code.\n\n```\n#include <iostream>\nusing namespace std;\n\nclass priorityQueue\n{\nprivate:\n    int front;\n    int rear;\n    int size;\n    int *array;\n\npublic:\n    priorityQueue();\n    ~priorityQueue();\n    void insert(int x);\n    //remove and return the smallest item currently in the priority queue\n    int extractMin();\n    bool empty();\n};\n\npriorityQueue::priorityQueue()\n{\n    front = rear = -1;\n    size = 10;\n    array = new int[size];\n}\n\npriorityQueue::~priorityQueue()\n{\n    delete[] array;\n}\n\nvoid priorityQueue::insert(int x)\n{\n    //if queue is full\n    if ( (rear + 1)% size == front ){\n        return;\n    }\n\n    //else if queue is empty\n    else if ( empty() ){\n        rear = front = 0;\n    }\n\n    else\n    {\n        rear = (rear + 1) % size;\n    }\n\n    array[rear] = x;\n}\n\n//extract and return smallest value in queue\nint priorityQueue::extractMin()\n{\n    int minValue = array[front];\n\n    if ( empty() ){\n        return -1;\n    }\n\n    else if (front == rear){\n        front = rear = -1;\n        }\n\n    else\n    {\n        front = (front + 1) % size;\n    }\n\n    //find smallest value\n    for (int i = front; i <= rear; i++){\n        if (array[i] < minValue)\n            minValue = array[i];\n    }\n\n    //return smallest value\n    return array[front];\n}\n\nbool priorityQueue::empty()\n{\n    if ( (front == -1) && (rear == -1) )\n        return true;\n    else\n        return false;\n}\n\nint main()\n{\n    priorityQueue myqueue;\n\n    myqueue.insert(4);\n    myqueue.insert(3);\n    myqueue.insert(2);\n    myqueue.insert(1);\n\n    cout << myqueue.extractMin() << endl;\n    cout << myqueue.extractMin() << endl;\n\n    myqueue.insert(8);\n    myqueue.insert(7);\n    myqueue.insert(6);\n    myqueue.insert(5);\n\n    cout << myqueue.extractMin() << endl;\n    cout << myqueue.extractMin() << endl;\n    cout << myqueue.extractMin() << endl;\n\n    system(\"pause\");\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYou do find the smallest value however it is not the value that you return when you extract min:\n\n```\n//find smallest value\nfor (int i = front; i <= rear; i++){\n    if (array[i] < minValue)\n        minValue = array[i];\n}\n\n//return smallest value\nreturn array[front]; //Not equal to the smallest value\n```\n\n\nI think that what you want to do is find the smallest number then remove it from the array and return it.\n\nThis is maybe not the most clean solution but it will solve your problem:\n\n```\nint minIndex = front;\n\n//find smallest value\nfor (int i = front; i <= rear; i++){\n    if (array[i] < minValue)\n    {\n        minIndex = i;\n        minValue = array[i];\n    }\n}\n\narray[minIndex] = array[front];\n\n//return smallest value\nreturn minValue;\n```\n\n\nIf i were to implement a priority queue i would ensure to allways put the smallest value at front and make sure that the array is sorted when i do insert.\n\n```\nint index = rear;\n\nfor(int i = front ; i <= rear ; i++)\n{\n    if(x < array[i])\n    {\n        for(int j = rear ; j >= i ; j--)\n        {\n            array[j] = array[j-1];\n        }\n        index = i;\n        break;\n    }\n}\n\narray[index] = x;\n```\n\n\nAdding this to your insert would sort of work however first time when the following snippet is run front will be set to one. which means you will skip the first value in the queue.\n\n```\nelse\n{\n    front = (front+1) % size;\n}\n```\n\n\nI would suggest making the above change in insert and change your extractmin to something like this:\n\n```\n//extract and return smallest value in queue\nint priorityQueue::extractMin()\n{\n    //Handle circulation.\n\n    //return smallest value\n    return array[front++];\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is there a Fibonacci heap based priority queue for Haskell?\r\n                \r\nIs there a Fibonacci heap/priority queue available for Haskell? (Or even an asymptotically better one?) I found a list of various priority queue implementations in this question, but I couldn't find if any of them satisfies the amortized running time of Fibonacci heaps:\n\n\nFind-minimum is O(1) amortized time.\nOperations insert, decrease key, and merge (union) work are O(1) amortized time.\nOperations delete and delete minimum are O(log n) amortized time.\n\n\nSee the comparison of theoretic bounds.\n    ", "Answer": "\r\nNot a Fibonacci Heap, but just as good: heaps by Edward Kmett based on the Brodal/Okasaki persistent variant of Brodal heaps.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I implement an optimal, purely functional, double-ended priority queue?\r\n                \r\nOkasaki shows how to write purely functional priority queues with ```\nO(1)```\n ```\ninsert```\n and ```\nO(log n)```\n ```\nminView```\n (some versions also offer ```\nO(log n)```\n or even ```\nO(1)```\n ```\nmerge```\n. Can any of these ideas be extended to double-ended priority queues? Khoong and Leong (in a paper I don't have access to) offer an ephemeral implementation based on binomial heaps, but from what I can see of their paper, that approach doesn't seem easy to make persistent, as it uses parent and sibling pointers.\n    ", "Answer": "\r\nAs leftaroundabout points out, this can be done with a 2–3 finger tree. In particular, one annotated with the semigroup\n```\ndata MinMax k = MinMax\n  { smallest :: !k\n  , largest :: !k }\n\ninstance Ord k => Semigroup (MinMax k) where\n  MinMax min1 max1 <> MinMax min2 max2 = MinMax (min min1 min2) (max max1 max2)\n```\n\nSuch an annotated finger tree can be made a double-ended priority queue in basically the same way that the ```\nfingertree```\n package defines priority queues (but adjusted slightly to avoid needing a ```\nMonoid```\n). ```\nminView```\n and ```\nmaxView```\n can be improved using the same implementation technique as ```\nData.Sequence.deleteAt```\n.\nWhy use a ```\nSemigroup```\n and not add a neutral element to make it a ```\nMonoid```\n? This way, we can unpack ```\nMinMax```\n annotations into tree nodes and avoid an extra indirection at every step, along with extra allocation.\nPerformance bounds\n\n```\ninsert```\n: Amortized O(1) (note: this bound will hold up even in the face of persistence, thanks to careful use of laziness). Worst-case O(log n). Note that the ```\nfingertree```\n package only claims O(log n) for insertion; this is a documentation bug which I have reported and which will be corrected in the next version.\n```\nminView```\n/```\nmaxView```\n: Worst-case O(1) to see the minimum/maximum; worst-case O(log n) to remove it.\n```\nmeld```\n: Worst-case O(log (min (m, n)), where ```\nm```\n and ```\nn```\n are the sizes of the queues.\n\n\nHinze-Paterson style 2–3 finger trees are actually a bit more than necessary. A one-fingered version will do the trick, with fewer digit sizes.\n```\n{-# options_ghc -funbox-strict-fields #-}\n\ndata Node k a\n  = Node2 !(MinMax k) !a !a\n  | Node3 !(MinMax k) !a !a !a\n\ndata Tree k a\n  = Empty\n    -- the child of a Zero node may\n    -- not be empty\n  | Zero !(MinMax k) (Tree k (Node k a))\n  | One !(MinMax k) !a (Tree k (Node k a))\n```\n\nI've been working on fleshing this out for the last few days. Fortunately, it's mostly quite straightforward. Unfortunately, it requires an awful lot of code. The fundamental challenge is that deletion in 2–3 trees is fairly involved. The version for finger trees adds another layer of complexity. And then the whole thing has to be written twice to deal with both ```\nminView```\n and ```\nmaxView```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is the best way to implement a double-ended priority queue?\r\n                \r\nI would like to implement a double-ended priority queue with the following constraints:\n\n\nneeds to be implemented in a fixed size array..say 100 elements..if new elements need to be added after the array is full, the oldest needs to be removed\nneed maximum and minimum in O(1)\nif possible insert in O(1)\nif possible remove minimum in O(1)\nclear to empty/init state in O(1) if possible\ncount of number of elements in array at the moment in O(1)\n\n\nI would like O(1) for all the above 5 operations but its not possible to have O(1) on all of them in the same implementation. Atleast O(1) on 3 operations and O(log(n)) on the other 2 operations should suffice.\n\nWill appreciate if any pointers can be provided to such an implementation.\n    ", "Answer": "\r\nThere are many specialized data structures for this.  One simple data structure is the min-max heap, which is implemented as a binary heap where the layers alternate between \"min layers\" (each node is less than or equal to its descendants) and \"max layers\" (each node is greater than or equal to its descendants.)  The minimum and maximum can be found in time O(1), and, as in a standard binary heap, enqueues and dequeues can be done in time O(log n) time each.\n\nYou can also use the interval heap data structure, which is another specialized priority queue for the task.\n\nAlternatively, you can use two priority queues - one storing elements in ascending order and one in descending order.  Whenever you insert a value, you can then insert elements into both priority queues and have each store a pointer to the other.  Then, whenever you dequeue the min or max, you can remove the corresponding element from the other heap.\n\nAs yet another option, you could use a balanced binary search tree to store the elements.  The minimum and maximum can then be found in time O(log n) (or O(1) if you cache the results) and insertions and deletions can be done in time O(log n).  If you're using C++, you can just use ```\nstd::map```\n for this and then use ```\nbegin()```\n and ```\nrbegin()```\n to get the minimum and maximum values, respectively.\n\nHope this helps!\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Can you use one method to add items to 3 different implementations of a Priority Queue?\r\n                \r\nI am doing an assignment for University which involves custom implementations of a Priority Queue. Each item in the queue will be a ```\nNode<E>```\n storing the element and its priority (E, p). The overall field is meant to be of type ```\nArrayList<Node<?>>```\n and the 3 Implementations will be an -\n\n\nunsorted queue with items being added on the end, and removed by the highest priority which has been on the queue for longest - type ```\nArrayList<Node<String>>```\n\nsorted queue with items being removed from the front of the queue and added before the first item of the next lowest priority - so something of priority 2 will be added between the items of priority 1 and 3. -  type ```\nArrayList<Node<String>>```\n\nA sorted queue of Queues where each Node element is an array list of items with the same priority  -  type ```\nArrayList<Node<ArrayList<String>>>```\n\n\n\nEach with their own enqueue, dequeue etc methods. \n\nI was wondering if I could define a single method which will work with all three implementations of the Priority Queue as they correspond to the same field in the Application, and the respective enqueue methods of the queue types being called depending on the definition of the field. \n    ", "Answer": "\r\nDefine an interface for the methods of a priorityQueue and than make three implementations of the interface.\n\n```\ninterface PrioQueue{\n  void enqueue(Node node);\n  Node dequeue();\n}\n\nclass PrioQueueVersion1 implements PrioQueue{\n   ....\n}\n\nclass PrioQueueVersion2 implements PrioQueue{\n   ....\n}\n\nclass PrioQueueVersion3 implements PrioQueue{\n   ....\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is the best way to implement a double-ended priority queue?\r\n                \r\nI would like to implement a double-ended priority queue with the following constraints:\n\n\nneeds to be implemented in a fixed size array..say 100 elements..if new elements need to be added after the array is full, the oldest needs to be removed\nneed maximum and minimum in O(1)\nif possible insert in O(1)\nif possible remove minimum in O(1)\nclear to empty/init state in O(1) if possible\ncount of number of elements in array at the moment in O(1)\n\n\nI would like O(1) for all the above 5 operations but its not possible to have O(1) on all of them in the same implementation. Atleast O(1) on 3 operations and O(log(n)) on the other 2 operations should suffice.\n\nWill appreciate if any pointers can be provided to such an implementation.\n    ", "Answer": "\r\nThere are many specialized data structures for this.  One simple data structure is the min-max heap, which is implemented as a binary heap where the layers alternate between \"min layers\" (each node is less than or equal to its descendants) and \"max layers\" (each node is greater than or equal to its descendants.)  The minimum and maximum can be found in time O(1), and, as in a standard binary heap, enqueues and dequeues can be done in time O(log n) time each.\n\nYou can also use the interval heap data structure, which is another specialized priority queue for the task.\n\nAlternatively, you can use two priority queues - one storing elements in ascending order and one in descending order.  Whenever you insert a value, you can then insert elements into both priority queues and have each store a pointer to the other.  Then, whenever you dequeue the min or max, you can remove the corresponding element from the other heap.\n\nAs yet another option, you could use a balanced binary search tree to store the elements.  The minimum and maximum can then be found in time O(log n) (or O(1) if you cache the results) and insertions and deletions can be done in time O(log n).  If you're using C++, you can just use ```\nstd::map```\n for this and then use ```\nbegin()```\n and ```\nrbegin()```\n to get the minimum and maximum values, respectively.\n\nHope this helps!\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Implementation, Priority Queue\r\n                \r\nI have a hard time to figure out one error after assigning\n\n```\nint evaluationNode = getMinDistances();\n\nsettled.add(evaluationNode);\n\ncheckNeighbours(evaluationNode);\n```\n\n\nThe error show type mismatch: connot convert from Node to int. I am appreciated if anyone can help me this. Below is a complete code.\n\nimport java.util.HashSet;\n\n```\nimport java.util.InputMismatchException;\n\nimport java.util.PriorityQueue;\n\nimport java.util.Scanner;\n\nimport java.util.Set;\nimport java.util.Comparator;\n\n\n\n\npublic class DijkstraPriorityQueue\n\n{\n\n    private int distances[];\n\n    private Set<Integer> settled;\n\n\n    private PriorityQueue<Node> priorityQueue;\n\n    private int number_of_nodes;\n\n    private int adjacencyMatrix[][];\n\n\n    public  DijkstraPriorityQueue(int number_of_nodes)\n    {\n\n        this.number_of_nodes = number_of_nodes;\n\n        distances = new int[number_of_nodes + 1];\n\n        settled = new HashSet<Integer>();\n\n        priorityQueue = new PriorityQueue<Node>(number_of_nodes,new Node());\n\n        adjacencyMatrix = new int[number_of_nodes + 1][number_of_nodes + 1];\n\n    }\n\n    public void dijkstra_algorithm(int adjacency_matrix[][], int source)\n    {\n\n        int evaluationNode;\n\n        for (int i = 1; i <= number_of_nodes; i++)\n\n            for (int j = 1; j <= number_of_nodes; j++)\n\n                adjacencyMatrix[i][j] = adjacency_matrix[i][j];\n\n\n        for (int i = 1; i <= number_of_nodes; i++)\n        {\n            distances[i] = Integer.MAX_VALUE;\n        }\n\n        priorityQueue.add(new Node(source, 0));\n\n        distances[source] = 0;\n\n        while (!priorityQueue.isEmpty())\n        {\n\n            evaluationNode = getMinDistances();\n\n            settled.add(evaluationNode);\n\n            evaluateNeighbours(evaluationNode);\n\n        }\n\n    } \n\n    private int getMinDistances()\n    {\n\n        int node = priorityQueue.remove();\n\n        return node;\n\n    }\n\n    private void checkNeighbours(int evaluationNode)\n    {\n\n        int edgeDistance = -1;\n\n        int newDistance = -1;\n\n\n        for (int destinationNode = 1; destinationNode <= number_of_nodes; destinationNode++)\n        {\n            if (!settled.contains(destinationNode))\n            {\n                if (adjacencyMatrix[evaluationNode][destinationNode] != Integer.MAX_VALUE)\n                {\n\n                    edgeDistance = adjacencyMatrix[evaluationNode][destinationNode];\n\n                    newDistance = distances[evaluationNode] + edgeDistance;\n\n                    if (newDistance < distances[destinationNode])\n                    {\n                        distances[destinationNode] = newDistance;\n                    }\n\n                    priorityQueue.add(new Node(destinationNode,distances[destinationNode]));\n                }   \n            }\n        }\n    }\n```\n\n\npublic static void main(String[] args)\n\n```\n    {\n\n        int adjacency_matrix[][];\n\n        int number_of_vertices;\n\n        int source = 0;\n\n        Scanner scan = new Scanner(System.in);\n\n        try\n\n        {\n\n            System.out.println(\"Enter the number of vertices\");\n\n            number_of_vertices = scan.nextInt();\n\n            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];\n\n\n\n            System.out.println(\"Enter the Weighted Matrix for the graph\");\n\n            for (int i = 1; i <= number_of_vertices; i++)\n\n            {\n\n                for (int j = 1; j <= number_of_vertices; j++)\n\n                {\n\n                    adjacency_matrix[i][j] = scan.nextInt();\n\n                    if (i == j)\n\n                    {\n\n                        adjacency_matrix[i][j] = 0;\n\n                        continue;\n\n                    }\n\n                    if (adjacency_matrix[i][j] == 0)\n\n                    {\n\n                        adjacency_matrix[i][j] =  Integer.MAX_VALUE;\n\n                    }\n\n                }\n\n            }\n\n\n\n            System.out.println(\"Enter the source \");\n\n            source = scan.nextInt();\n\n\n\n            DijkstraPriorityQueue dijkstrasPriorityQueue = new DijkstraPriorityQueue(number_of_vertices);\n\n            dijkstrasPriorityQueue.dijkstra_algorithm(adjacency_matrix, source);\n\n\n\n            System.out.println(\"The Shorted Path to all nodes are \");\n\n            for (int i = 1; i <= dijkstrasPriorityQueue.distances.length - 1; i++)\n\n            {\n\n                System.out.println(source + \" to \" + i + \" is \" + dijkstrasPriorityQueue.distances[i]);\n\n            }\n\n        } catch (InputMismatchException inputMismatch)\n\n        {\n\n            System.out.println(\"Wrong Input Format\");\n\n        }\n\n        scan.close();\n\n    } \n\n}\n\nclass Node implements Comparator<Node>\n\n{\n\n    public int node;\n\n    public int cost;\n\n\n\n    public Node()\n\n    {\n\n    }\n\n\n\n    public Node(int node, int cost)\n\n    {\n\n        this.node = node;\n\n        this.cost = cost;\n\n    }\n\n\n\n    @Override\n\n    public int compare(Node node1, Node node2)\n\n    {\n\n        if (node1.cost < node2.cost)\n\n            return -1;\n\n        if (node1.cost > node2.cost)\n\n            return 1;\n\n        return 0;\n\n    }\n\n}\n```\n\n    ", "Answer": "\r\nIn the ```\ngetMinDistances```\n method you are calling\n\n```\nint node = priorityQueue.remove();\n```\n\n\nBut the priority queue contains ```\nNode```\n objects, and not ```\nint```\n values.\n\nMaybe you wanted something like\n\n```\nprivate int getMinDistances()\n{\n    Node node = priorityQueue.remove();\n    return node.getDistance();\n}\n```\n\n\nbut this is something that can not be answered by the debugging cloud (aka stackoverflow).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a method to find the smallest child in a D-heap Priority Queue\r\n                \r\nI have a remove method in a Priority Queue class I created from scratch for an assignment. The priority queue I created is held in an array, with the index starting at 0. I keep track of size which is equal to the arrays length. The remove method uses a helper method entitled:\n\n```\npublic int findSmallest(int parent)\n```\n\n\nwhere parent is the position in the array that the parent is stored at, and I am looking to return its smallest child. Order is simply the number of children each node that is not a leaf has. The code for my findSmallest:\n\n```\npublic int findSmallest(int parent) {\n    int child = parent * order + 1;\n    int smallest = child;\n    for (int i = child; i < order + child; ++i) {\n        if (size >= i) {\n            return child;\n        }\n        if (queue[i].priority <= queue[smallest].priority) {\n            smallest = child;\n        }\n    }\n    return child;\n}\n```\n\n\nIt is currently an array out of bounds exception\nComplete implementation of PriorityQueue Class I created:\n\n```\nimport java.util.*;\n\npublic class PriorityQueue {\n\n    private class Item {\n        private int priority;\n        private Object data;\n\n        private Item(int p, Object d) {\n            priority = p;\n            data = d;\n        }\n    }\n\n    private Item queue[];\n    private int order;\n    private int size;\n\n    public PriorityQueue(int ord, int s) {\n        queue = new Item[s];\n        order = ord;\n        size = 0;\n    }\n\n    public int getPriority() {\n        if (size > 0) {\n            return queue[0].priority;\n        }\n\n        // -55 signifies that the queue is empty\n\n        return -55;\n    }\n\n    public Object getData() {\n        if (size > 0) {\n            return queue[0].priority;\n        }\n        return null;\n    }\n\n    public void remove() {\n\n        if (empty() == true) {\n            System.out.println(\"Queue is empty, there is nothing to remove.\");\n            return;\n        }\n\n        Item x = queue[size - 1];\n        size--;\n        int child = 1;\n        int parent = 0;\n\n        while (child <= size) {\n            child = findSmallest(parent);\n            for (int i = order * parent + 1; i < child + order; i++) {\n                if (child < size && queue[i].priority < queue[child].priority)\n                    child = i;\n            }\n            if (x.priority < queue[child].priority)\n                break;\n            else {\n                parent = child;\n                queue[(child - 1) / order] = queue[child];\n                child = order * child + 1;\n            }\n        }\n        queue[(child - 1) / order] = x;\n    }\n\n    public int findSmallest(int parent) {\n        int child = parent * order + 1;\n        int smallest = child;\n        for (int i = child; i < order + child; ++i) {\n            if (size >= i) {\n                return child;\n            }\n            if (queue[i].priority <= queue[smallest].priority) {\n                smallest = child;\n            }\n        }\n        return child;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public boolean full() {\n        return size == queue.length;\n    }\n\n    public boolean empty() {\n        if (size > 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public void insert(int p, Object d) {\n        // 1. Create a new Item and add it to queue[size]\n            // Somewhere store new node created as TEMP\n        // 2. while loop\n        // 3. check if node has parent\n            // 4. if it does --> check if parent.priority > child.priority\n                // 5. if yes, swap\n\n        if (full() == true) {\n            System.out.println(\"Queue is full, cannot add new node.\");\n            return;\n        }\n\n        queue[size] = new Item(p, d);\n        sort();\n        size++;\n\n    }\n\n    // Sort() swaps new child node with parents if child.priority < parent.priority\n\n    public void sort() {\n\n        int child = size;\n        Item temp = queue[child];\n        while ( child > 0 && queue[child].priority < queue[(child-1)/(order)].priority) {\n            queue[child] = queue[(child-1)/order];\n            queue[(child-1)/order] = temp;\n            child = ((child - 1) / order);\n        }\n        queue[child] = temp;\n    }\n\n\n\n    public static void main(String[] args) {\n            PriorityQueue p1 = new PriorityQueue(5, 100);\n            PriorityQueue p2 = new PriorityQueue(6, 100);\n            PriorityQueue p3 = new PriorityQueue(7, 100);\n\n            int p = -1; //pointless initialization to keep the compiler happy\n            p1.insert(0, new Integer(0));\n            System.out.println(\"First insert\");\n\n            for (int i = 1; i < 100; i++)\n                p1.insert(i, new Integer(i));\n\n            for (int i = 0; i < 100; i++)\n                p2.insert(i, new Integer(i));\n\n            for (int i = 0; i < 100; i++)\n                p3.insert(i, new Integer(i));\n\n            System.out.println(\"First insert tests\");\n\n            System.out.print(p1.getPriority()+\",\");\n            while (!p1.empty()) {\n                p = p1.getPriority();\n                Object d = p1.getData();\n                p1.remove();\n            }\n            System.out.println(p);\n\n            System.out.print(p2.getPriority()+\",\");\n\n            while (!p2.empty()) {\n                p = p2.getPriority();\n                Object d = p2.getData();\n                p2.remove();\n            }\n            System.out.println(p);\n\n            System.out.print(p3.getPriority()+\",\");\n\n            while (!p3.empty()) {\n                p = p3.getPriority();\n                Object d = p3.getData();\n                p3.remove();\n            }\n            System.out.println(p);\n            System.out.println(\"First Remove Test\");\n\n            for (int i = 100; i > 0 ; i--)\n                p1.insert(i, new Integer(i));\n\n            for (int i = 100; i > 0 ; i--)\n                p2.insert(i, new Integer(i));\n\n            for (int i = 100; i > 0 ; i--)\n                p3.insert(i, new Integer(i));\n\n            System.out.println(\"Second insert tests\");\n\n            System.out.print(p1.getPriority()+\",\");\n            while (!p1.empty()) {\n                p = p1.getPriority();\n                Object d = p1.getData();\n                p1.remove();\n            }\n            System.out.println(p);\n\n            System.out.print(p2.getPriority()+\",\");\n\n            while (!p2.empty()) {\n                p = p2.getPriority();\n                Object d = p2.getData();\n                p2.remove();\n            }\n            System.out.println(p);\n\n            System.out.print(p3.getPriority()+\",\");\n\n            while (!p3.empty()) {\n                p = p3.getPriority();\n                Object d = p3.getData();\n                p3.remove();\n            }\n            System.out.println(p);\n            System.out.println(\"Second Remove Test\");\n\n            Random r1 = new Random(1000);\n            while (!p3.full()) {\n                p = r1.nextInt(200);\n                System.out.print(p+\",\");\n                p3.insert(p, new Integer(p));\n            }\n            System.out.println();\n\n            while (!p3.empty()) {\n                System.out.print(p3.getPriority()+\",\");\n                Object d = p3.getData();\n                p3.remove();\n            }\n            System.out.println();\n            System.out.println(\"Third Remove Test\");\n    }\n}\n```\n\n\nMain includes 3 different ways I am testing my code.\n    ", "Answer": "\r\nIf your problem is just with the ```\nfindSmallest```\n method, here is the solution:\n\n```\npublic int findSmallest( int parent ) {\n\n    int smallestChild = -1;\n\n    int firstChild = parent * order + 1;\n    int lastChild = parent * order + order;\n\n    int currentSmallestChild = firstChild;\n\n    for ( int i = firstChild + 1; i <= lastChild; i++ ) {\n        if ( i > size || queue[i] == null ) {\n            break;\n        }\n        if ( queue[currentSmallestChild].priority > queue[i].priority ) {\n            currentSmallestChild = i;\n            smallestChild = i;\n        }\n    }\n\n    return smallestChild;\n\n}\n```\n\n\nIt will return -1 if there is not a smallest child. This code can be improved, I let it this way because I think it is easier to understand. Let me know if it works.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How is remove min on a sorted array implementation of a priority Queue constant time?\r\n                \r\nAs per this lecture from uc BerkleyCS61B lecture 16, if a priority queue is implemented as a sorted array, the remove min is constant time.\n\nIf you just remove the element at the zeroth index, then wouldn't you have to move all the items over to the left? In which case wouldnt it be theta of n? Else find min will not be constant time.\n    ", "Answer": "\r\nIf you implement a priority queue as a sorted array, there are two different ways to ensure that removeMin is an O(1) operation.\nIf the array is sorted in ascending order, then the smallest element is at the front of the array. In this case you maintain an index that tells you where the beginning of the queue is. When you first build it, then of course the index is at the front of the array (```\na[0]```\n or ```\na[1]```\n, depending on your choice of language). When you want to remove the smallest element, you return the item at ```\na[idx]```\n, and then increment ```\nidx```\n.\nAny time you insert an item you write the code to move everything up to the front of the array again and reset ```\nidx```\n to 0 (or 1, as appropriate).\nThe other way is to maintain the array in descending order. The smallest element is the last element of the array. You already have to keep track of how many elements are in the array. So you have an index, call it ```\nixEnd```\n. When you want to remove the smallest element, you return ```\na[ixEnd]```\n, and subtract 1 from ```\nixEnd```\n.\nEither way, insertion is O(n) and ```\nremoveMin```\n is O(1).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing insert and delete function on priority queue without array?\r\n                \r\nI need to implement a priority queue without using array. \nI was trying to make it using a binary heap (Min heap), but I'm getting trouble when inserting a new element. Using array I just need to append the new element at the end of array and headpfy it, but without array I have to take care where I will insert it, because the binary tree can get very unbalanced.\n\nI would like to know a solution for this binary heap without array or other data structure to use as min heap.\n\nI will need to implement functions to insert and delete (can be the min element or other in the middle of the heap).\n\nSame question, but not answered : MinMax Heap implementation without an array\n\nThanks\n    ", "Answer": "\r\nThe common data structures used for this task are a Fibonacci heap, or a binomial heap:\n\nhttps://en.wikipedia.org/wiki/Fibonacci_heap\n\nhttps://en.wikipedia.org/wiki/Binomial_heap\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "position index for binary heap priority queues?\r\n                \r\nSo let's say I have a priority queue of N items with priorities, where N is in the thousands, using a priority queue implemented with a binary heap. I understand the ```\nEXTRACT-MIN```\n and ```\nINSERT```\n primitives (see Cormen, Leiserson, Rivest which uses ```\n-MAX```\n rather than ```\n-MIN```\n). \n\nBut ```\nDELETE```\n and ```\nDECREASE-KEY```\n both seem to require the priority queue to be able to find an item's index in the heap given the item itself (alternatively, that index needs to be given by consumers of the priority queue, but this seems like an abstraction violation).... which looks like an oversight. Is there a way to do this efficiently without having to add a hashtable on top of the heap?\n    ", "Answer": "\r\nRight, I think the point here is that for the implementation of the priority queue you may use a binary heap who's API takes an index (i) for its HEAP-INCREASE-KEY(A, i, key), but the interface to the priority queue may be allowed to take an arbitrary key.  You're free to have the priority queue encapsulate the details of key->index maps. If you need your PQ-INCREASE-KEY(A, old, new) to to work in O(log n) then you'd better have a O(log n) or better key to index lookup that you keep up to date. That could be a hash table or other fast lookup structure.\n\nSo, to answer your question:  I think it's inevitable that the data structure be augmented some how.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Can you impove Dijkstra's time complexity by not filling completely the priority queue?\r\n                \r\nCan you impove Dijkstra's time complexity by not filling completely the priority queue?\nI have found two diferent aproaches to Dijkstra's priority queue.\nShouldn't the time complexities be different?\nNormal implementation of Dijkstra with priority queue\nThe implementation you usually find for Dijkstra's shortest path starts filling the priority queue with ALL vertices:\n\n(From wikipedia's pseudocode:)\n```\nfor each vertex v in Graph:            \n    dist[v] ← INFINITY                 \n    prev[v] ← UNDEFINED                \n    add v to Q                     \n    dist[source] ← 0\n[...]\n```\n\nHowever, as said in The Big O on the Dijkstra Fibonacci-heap solution, the complexity of Dijkstra's shortest path algorithm is:\n```\nO(|E| |decrease-key(Q)| + |V| |extract-min(Q)|)\n```\n\nUsing a binary heap as priority queue that is equal to: ```\nO((E + V)log(Q))```\n as decrease-key(Q) and extract-min(Q) are both ```\nO(log(|Q|))```\n\n\nOr if you fill the queue with all vertices: ```\nO((E+V)log(V))```\n\nFaster? implementation of Dijkstra with priority queue\nThe implementation found in python's networkx package, however, doesn't fill the priority queue with all vertices. It starts only with the source vertex and continues to insert other vertices as they are discovered.\nSomething like:\n```\nQ = priority queue\nseen = provisional distances to every 'seen' vertex\n\nadd source to Q                     \nseen[source] ← 0\n\nwhile Q not empty:\n    v = pop(Q)\n\n    if v == target -> path found!\n\n    for neig in neighbours of v:\n        if neig not in seen:\n            add neig to Q\n        ...\n        [normal Dijksta algorithm]\n\n```\n\nThis way the priority queue never even comes close to having |V| elements (in a relatively sparce graph at least). It will have at any given point all vertices in the boundary between explored and unseen vertices. Comparing with the \"normal\" implementation of the queue (Q1) this queue's (Q2) size will be: ```\n|Q2| = |Q1 where cost != inf|```\n\n\nMy question\nWouldn't that mean the time complexity of this implementation is lower than ```\nO((E+V)log(V))```\n?\nAm I missing something?\nI have tested it in a road network graph and indeed it takes less time to compute a shortest path this way. Even excluding the time spent in filling the queue initialy in the \"normal\" case.\n    ", "Answer": "\r\nThe log function grows slowly. Even with a road network, where you might have on the order of n1/3 to n1/2 nodes on the frontier, the log factor is still at least log n1/3 = (1/3) log n = Θ(log n), so you're not seeing an asymptotic savings.\nFor road networks specifically, there are improvements that are way more consequential, e.g., reach and contraction hierarchies.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue using just array and binary search\r\n                \r\nSo I have come across priority queue data structure, the implementation is usually with heaps or binary tree. \n\nWhy can't a priority queue just use a simple array and use binary search for insertion, it would still be O(logn) with retrieval time of O(1).\n\n```\nwhile true {\n    // We will eventually reach the search with only two or less elements remaining.\n    // The insert can be in front of (first element index), between (second element index)\n    // or behind of the two element (second element index + 1).\n    //\n    // The lowerBound is the first element index if the first element (aka middle) has a \n    // higher priority than the insert priority (last call is upperBound = middle - 1 so \n    // lowerBound unchange)\n    //\n    // The lowerBound will be the second element index if the first element (aka middle) \n    // has a lower priority than the insert priority (last call is lowerBound = middle + 1)\n    //\n    if lowerBound >= upperBound {\n        // We still need to check if lowerBound is now in the second element, in which it can also \n        // be greater than priority of the second element. If so, we need to add 1 to the index \n        // (lowerBound)\n        return array[lowerBound].priority > insert.priority ? lowerBound : lowerBound + 1\n    }\n\n    var middle = (lowerBound + upperBound) / 2\n    let middleValue = array[middle]\n\n    if middleValue.priority > insert.priority {\n        upperBound = middle - 1\n    } else { // treat equal as less than so it put the same priority in order of insertion\n        lowerBound = middle + 1\n    }\n}\n```\n\n    ", "Answer": "\r\nYour loop, the binary search, only finds the index at which the new item should be inserted to maintain sorted order. Actually inserting it there is the hard part. Simply put, this takes linear time and there's nothing we can do about that. A sorted array is very fast for retrieval, but pretty slow for insertion. Binary heaps are fast (logarithmic) for both insertion and retrieval.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue Not working as intended\r\n                \r\nI have a ```\nNodeWeightWrapper```\n wrapper to wrap ```\nNode```\n object and its associated ```\nweight```\n. Below is the code for wrapper. I have implemented ```\nComparable```\n and overridden ```\ncompareTo```\n method on ```\nweight```\n, so I can use wrapper objects in a Priority Queue.\n\n```\n public class NodeWeightWrapper implements Comparable<NodeWeightWrapper> {\n\nprivate final Node node;\nprivate int weight;\n\npublic NodeWeightWrapper(Node node, int weight) {\n    this.node = node;\n    this.weight = weight;\n}\n\npublic Node getNode() {\n    return node;\n}\n\npublic int getWeight() {\n    return weight;\n}\n\npublic void setWeight(int weight) {\n    this.weight = weight;\n}\n\n@Override\npublic int compareTo(NodeWeightWrapper o) {\n    return Integer.compare(this.getWeight(), o.getWeight());\n}\n\n}\n```\n\n\nAdding objects to Priority Queue\n\n```\n    PriorityQueue<NodeWeightWrapper> freeNodes = new PriorityQueue<>();\n    freeNodes.add(new NodeWeightWrapper(nodeA, 20));\n    freeNodes.add(new NodeWeightWrapper(nodeB, 15));\n    freeNodes.add(new NodeWeightWrapper(nodeC, 10));\n```\n\n\nHere is the problem, If I update ```\nweight```\n of an object in Priority Queue as shown below. The same is not reflected next time I ```\npoll```\n an object out of the Priority Queue. Which means Priority Queue sorts elements only when a new insertion takes place. So I tried removing the original wrapper object and inserted a new wrapper object with updated value but that throws ConcurrentModificationException as we are in a ```\nforeach```\n loop. Any suggestion who can I make weight updation be reflected in Priority Queue.\n\n```\nfor (NodeWeightWrapper nww : freeNodes) {\n     if (nww.getWeight() > value) {\n         nww.setWeight(value);\n     }\n}\n```\n\n    ", "Answer": "\r\n```\nPriorityQueue<NodeWeightWrapper> modified = new PriorityQueue<>();\nfor (NodeWeightWrapper nww : freeNodes) {\n if (nww.getWeight() > value) {\n     nww.setWeight(value);\n }\n modified.add(mww)\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why does operator< need to be overloaded when implementing class-based priority queues in c++?\r\n                \r\nnote, I am not asking for answers.  I simply am curious regarding why things work\n\nI need to implement a priority queue for a printer simulator for a class assignment.  After looking at examples on the internet, I noticed that operator< was being overloaded in order to arrange the priority queue correctly.\n\ncode in question: java2s priority queue example\n\nWhy does operator< need to be overloaded?  Where is '<' even used to make the comparison?  Does implementing the operator overload change the way the queue STL works?  \n\nThis implementation doesn't seem intuitive to me at all: why isn't operator> being overloaded instead?  How is one supposed to learn that operator< needs to be overloaded in order for the priority_queue to work correctly?\n    ", "Answer": "\r\nSTL containers use operator< by default to order the contents, for those containers that order the contents.\n\nYou can override this by passing in a comparison functor to the constructor of the container, which allows you to decouple the sorting/ordering from the container object.\n\nOperator> could have been chosen, but one had to be picked and that was operator<, and is then used everywhere for consistency.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "have a problem sorting priority queue integers [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 1 year ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nhello i wonder what's wrong with my code:\nIt should have an output like this:\n\nin this problem  I need to implement different queue operations  by adding element, removing element, size of priority queue, print the queue and top element of queue\nInput Format\nThe first line of input contains an integer T denoting the no of test cases. For each test case, the first line of input contains an integer Q denoting the no of queries followed by Q space separated queries. A query can be of the following types:\n1.x (Adding x to the priority queue and print the queue)\n2.(Removing the element from the top of the priority queue and printing that element )\n3.(Get the element at the top of the priority queue)\n4.(Get the size of the priority queue)\n5.(Print the priority queue)\n```\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Solution {\n\n    public static void main(String args[]) {\n        Scanner scanner= new Scanner(System.in);\n        int T=scanner.nextInt();\n        int i=0;\n        int Q=scanner.nextInt();\n        System.out.println();\n        PriorityQueue<Integer>pq=new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2.compareTo(o1);\n            }\n        });\n        while (i<T){\n            for (int j = 0; j < Q; j++) {\n\n\n                int query=scanner.nextInt();\n\n                switch (query){\n                    case 1:\n\n                        pq.add(scanner.nextInt());\n                        System.out.println(pq.toString().replace(\"[\",\"\").replace(\"]\",\"\").replace(\",\",\"\"));\n                        break;\n                    case 2:\n                        System.out.println(pq.poll());\n                        break;\n                    case 3:\n\n                        System.out.println(pq.peek());\n                        break;\n                    case 4:\n                        System.out.println(pq.size());\n                        break;\n                    case 5:\n                        System.out.println(pq.toString().replace(\"[\",\"\").replace(\"]\",\"\").replace(\",\",\"\"));\n                    default:\n                        break;\n                }}\n            i++;\n        }}\n}\n\n```\n\nbut when I'm running my code it gives me  output like this:\n\n    ", "Answer": "\r\nYour queue printing code have some problems, try this code instead:\n```\npublic static void printQueue(PriorityQueue<Integer> p1)\n{\n    PriorityQueue<Integer> p2 = new PriorityQueue<>(p1);\n\n    while (!p2.isEmpty())\n    {\n        System.out.print(p2.poll() + \" \");\n    }\n\n    System.out.println();\n}\n```\n\nYou can find the explanation here:\nPriorityQueue.toString wrong element order\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Prim Algorithm Priority Queue\r\n                \r\nI am trying to implement Prim's algorithm in Java with a priority queue.\n\nI can't find my mistake. :/ I just recognize that the queue doesn't order the nodes correctly. \n\nexample for a graph:\n\n```\n0 4 7 5\n4 0 2 3\n7 2 0 1\n5 3 1 0\n```\n\n\nIt always takes the node 4 as the second one. So it orders the queue like [node1, node4, node2, node3] and not [node1,node2, node3, node4]. \nWhat did I do wrong with the priority queue? \n\nGreetings\n\n```\n    public class PrimAlgorithm {\n\n        private static int[] par; // parent\n        private static int[] key; // value\n        private static int sum;\n\n\n        public static void prim(Graph g){\n\n            Node[] nodes = g.getNodes();\n            key = new int[g.getMatrix().length];\n            par = new int[g.getMatrix().length];\n\n\n                    PriorityQueue<Node> queue = new PriorityQueue<Node>(42, new Comparator<Node>(){\n                        public int compare(Node v1, Node v2){\n                            return Integer.valueOf(key[v1.getId()-1]).compareTo(Integer.valueOf(key[v2.getId()-1]));\n\n\n\n            for (Node n : nodes) {\n                int x = n.getId()-1;\n                key[x] = 1000;\n                par[x] = 0; \n                queue.add(n);\n            }\n\n            key[0] = 0;\n\n\n            while(!queue.isEmpty()) {\n                Node n = queue.poll();\n\n                List<Node> neighbours = n.getNeighbors();\n\n                for (Node m : neighbours){\n                    if ( queue.contains(m) && g.getEdge(n, m).getWeight() !=0 && g.getEdge(n, m).getWeight() < key[m.getId()-1]){\n\n                        par[m.getId()-1] = n.getId();\n                        key[m.getId()-1] = g.getEdge(n, m).getWeight();\n\n                    }\n                }\n            }\n\n            for (int i=0; i < key.length; i++){\n                sum += key[i];\n              }\n\n            System.out.println(\"Das Gewicht des minimalen Spannbaumes lautet: \" + sum);\n            System.out.println(\"Der Spannbaum ergibt sich wie folgt: \" );\n            //fängt ab 1 an sonst, hätten wir immer noch einen Nullknoten\n            for(int i=0; i <par.length; i++){\n                System.out.println(\"Der Vorgänger von Knoten: \"  + \" \"+ (i+1) + \"-> \"  +  par[i] + \" Gewicht \" \n                        + key[i]);\n            }\n\n        }\n\n        public static void main(String[] args) {\n            System.out.println(\"Prim Algorithmus zu Berechnung des minimalen Spannbaums.\");\n            Graph g = new Graph();\n\n            prim(g);\n        }\n\n}\n```\n\n    ", "Answer": "\r\nA few things:\n\n\nThe default implementation of PriorityQueue cannot re-order items within the queue dynamically. In other words, when you change the key after adding items in, it won't cause the items already in the queue to change their ordering.\nWhen you first add nodes into the PriorityQueue, they are all of the same priority. Therefore, according to the API for PriorityQueue, \n\n\n\n  If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily.\n\n\nSo there is no guarantee of the initial order of the nodes.\n\n\nIf you want an efficient implementation of Prim's, you should not use PriorityQueue's contains() method to check inside the queue as this is an O(N) operation. Instead, use a boolean array to keep track of which items are in the queue or not which is O(1) lookup.\n\n\nFor an efficient method of re-ordering the queue, note that an add operation is O(log(n)) which is efficient, while a remove from anywhere but the front of the queue is O(n) which should be avoided. So, a good trick would be to keep a boolean visited[] array, where visited[i] is true if Node i has already been processed. Then, you can add the same node multiple times, knowing that the one with the lowest key will be retrieved first. If when you poll the queue for a node, visited[node.id] is already true, then simply skip it.\n\nOf course, in order for this to work, the Node must be comparable based on some value it contains rather than an external array, so that you can have two nodes with the same id in the queue but with different key.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Refer to node into a priority queue (iterator)\r\n                \r\nI'm trying to implement Dijkstra's algorithm with a priority_queue (since I need to keep track of the closest node to the source node).\n\nThe problem is: when exploring a node, it might happen that it is linked to another node not yet discovered in the priority queue (i.e. to an element of the priority queue).\n\nIt seems priority queue doesn't support iterators, how can I refer to a priority queue element when discovering the node associated with it?\n    ", "Answer": "\r\n```\nstd::priority_queue<T>```\n neither supports iterators nor an interface to decrease/increase the priority of a node: merely changing an element's priority wouldn't update the data structure. What you'd need is a node-based version of ```\nstd::priority_queue<T>```\n. There are priority queues for that purpose in Boost.\n\nAlthough it wouldn't get the complexity quite right, you can use ```\nstd::priority_queue<T>```\n for Dijkstra's algorithm: instead of storing nodes you'd store edges from visited nodes to possibly unvisited nodes with the priority being the distance of the target node when using the given edge. When popping an element you'd need to check if the node was visited before. The Complexity would be ```\nO(m log m)```\n instead of ```\nO(m log n)```\n, though (```\nn```\n being number of nodes and ```\nm```\n being number of edges).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is there a maintained immutable priority queue in Scala?\r\n                \r\nI am looking for an implementation of an immutable priority queue for at least Scala 2.8, but preferably more current. Is there a good implementation somewhere?\n    ", "Answer": "\r\nSome links here: http://www.scala-lang.org/old/node/10374\n\nIn particular, see https://github.com/scalaz/scalaz/blob/master/core/src/main/scala/scalaz/FingerTree.scala and https://github.com/Sciss/FingerTree\n\nI think you can trust the code in scalaz to be sound. If you want a lighter-weight library, you can examine the source code from Sciss and see what you think.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue modification in Python\r\n                \r\nI would like to implement a derivative of a priority queue like in the following. A traditional priority queue a la ```\nfrom queue import PriorityQueue```\n stores the data as the following (assuming tuples of the form ```\n(priority, value)```\n\n\n```\n#pseudocode\nqueue = ((1, obj1), (1, obj2), (2, obj3), (3, obj4) ...)\n```\n\n\nIf I have many workers processing the objects in the queue e.g. 10 workers running ```\nfunc(obj)```\n then I think there's a possibility that a worker will start processing ```\nobj3```\n before ```\nobj2```\n finishes completing\n\nHowever, ```\nfunc(obj)```\n may place more objects into the priority queue but only at the same priority of the object the function is currently processing. Is there any way to ensure that all objects of priority N are completed before moving on to objects of priority > N?\n\nFor example ```\nfunc(obj2)```\n may insert another object into the queue ```\n(1, obj2_1)```\n but if another worker picks up ```\nobj3```\n before ```\nobj2```\n finishes processing then ```\nobj2_1```\n with priority 1 may finish processing after ```\nobj3```\n which has priority 2 - I would like to ensure that all objects of priority 1 are processed before priority 2 etc\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Unexpected behaviour of self implemented priority queue using min heap\r\n                \r\nI implemented a priority queue using a min heap in c++;\nhere I use zero based indexing in the vector used;\nso for example the left and right nodes of index 5 would be (2 * 5 + 1) and (2 * 5 + 2);\nI use recursive functions like swim and sink (typical);\nhere's the c++ code:\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate <class t>\nclass priorityqueue\n{\nprivate:\n    vector<t> vec;\n\n    inline static void swap(t *x, t *y)\n    {\n        t temp = *x;\n        *x = *y;\n        *y = temp;\n    }\n\n    inline static size_t left(size_t i) { return (i << 1) + 1; }\n\n    inline static size_t right(size_t i) { return (i << 1) + 2; }\n\n    inline static size_t up(size_t i) { return (i - 1) >> 1; }\n\n    inline bool validindex(size_t i) { return i < vec.size(); }\n\n    inline void swim(size_t i)\n    {\n        if (i == 0)\n            return;\n        size_t up_ = up(i);\n        if (vec[i] < vec[up_])\n        {\n            swap(&vec[i], &vec[up_]);\n            swim(up_);\n        }\n    }\n\n    inline void sink(size_t i)\n    {\n        size_t left_ = left(i), right_ = right(i);\n        if (!validindex(left_))\n        {\n            return;\n        }\n        if (!validindex(right_))\n        {\n            if (vec[i] > vec[left_])\n            {\n                swap(&vec[i], &vec[left_]);\n                sink(left_);\n            }\n            return;\n        }\n        if (vec[i] < vec[left_])\n        {\n            if (vec[i] < vec[right_])\n            {\n                return;\n            }\n            swap(&vec[i], &vec[right_]);\n            sink(right_);\n        }\n        else\n        {\n            if (vec[i] < vec[right_])\n            {\n                swap(&vec[i], &vec[left_]);\n                sink(left_);\n            }\n            else\n            {\n                if (vec[left_] < vec[right_])\n                {\n                    swap(&vec[i], &vec[left_]);\n                    sink(left_);\n                }\n                else\n                {\n                    swap(&vec[i], &vec[right_]);\n                    sink(right_);\n                }\n            }\n        }\n    }\n\npublic:\n    size_t size() { return vec.size(); }\n\n    bool empty() { return size() == 0; }\n\n    void push(t elem)\n    {\n        vec.push_back(elem);\n        swim(vec.size() - 1);\n    }\n\n    t peek()\n    {\n        return vec[0];\n    }\n\n    t pop()\n    {\n        t elem = vec[0];\n        t last = vec[vec.size() - 1];\n        swap(&last, &elem);\n        vec.pop_back();\n        sink(0);\n        return elem;\n    }\n};\n\nint main()\n{\n    priorityqueue<int> pq;\n    pq.push(3);\n    pq.push(1);\n    pq.push(4);\n    pq.push(1);\n    pq.push(5);\n    pq.push(9);\n    pq.push(2);\n    pq.push(6);\n    pq.push(5);\n    pq.push(3);\n    while (!pq.empty())\n    {\n        cout << pq.pop() << \" \";\n    }\n}\n```\n\nthe result it gives is :\n```\n(base) miglanigursimar@Miglanis-MacBook-Pro priorityqueue % ./a.out \n5 5 6 4 9 3 3 2 1 1 %\n```\n\nwhereas it should print the first ten digits of pi in ascending order.\n    ", "Answer": "\r\nOne big issue is in the ```\npop```\n function.\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate <class t>\nclass priorityqueue\n{\nprivate:\n    vector<t> vec;\n\n    inline static void swap(t *x, t *y)   // Why? Use std::swap instead.\n    {\n        t temp = *x;\n        *x = *y;\n        *y = temp;\n    }\n\n// [...]\n  \n    t pop()\n    {\n        t elem = vec[0];\n        t last = vec[vec.size() - 1];\n        swap(&last, &elem);             // <---------\n        vec.pop_back();\n        sink(0);\n        return elem;\n    }\n};\n// [...]\n```\n\nThere, ```\nlast```\n and ```\nelem```\n are local copies of the two elements of the vector, swapping them doesn't change the original ones.\nThe OP should either declare those as references or copy the first and then directly swap the elements of the vector.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ priority queue with two comparators\r\n                \r\nis it possible in C++ to implement priority queue with two comparators?\n\nHere is example:\n\n```\nstruct Task\n{\n  int r,p,q;\n  int task_number;\n};\n\n\nstruct Greater_r\n{\n  bool operator()(const Task& task_a, const Task& task_b) const\n  {\n      return task_a.r >= task_b.r;\n  }\n};\n```\n\n\nI'd like to sort not only by \"r\" but also by \"task_number\", because when for two tasks r has same value, priority queue will sort it randomly.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Does Go has out of the box priority queue?\r\n                \r\nDoes Go has out of the box priority queue (the one that I can just import from some module and start using like python's priority queue)?\n\nI know that priority queues are often implemented using heap data structure and go has a heap package, which also suggests how to use it to implement a queue (in Example (PriorityQueue) ), which I can easily grab and use.\n\nMy question is this a recommended way to do this, or there is an out of the box Priority Queue package that I failed to find?\n    ", "Answer": "\r\nQuoting Wikipedia:\n\n\n  a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a \"priority\" associated with it. [...] While priority queues are often implemented with heaps, they are conceptually distinct from heaps. A priority queue is an abstract concept like \"a list\" or \"a map\";\n\n\nGo provides some basic data structures that are used in most applications but leave the implementation of more specialized data structures to the programmer. For example, the go map can be used to trivially implement a set.\n\nThe example you link to uses a slice ```\n[]*Item```\n to represent the more abstract type ```\nheap.Interface```\n and also the (even more abstract) type ```\nPriorityQueue```\n. Go is about composition and I would say that implementing ```\nPriorityQueue```\n in terms of heap operations is good practice.\n\nThis gives you control as a programmer. If you want thread safety, use the composition of ```\nPriorityQueue```\n and ```\nsync.Mutex```\n to make it thread safe. If you want a different implementation than a heap, make ```\nPriorityQueue```\n an interface and you can implement it however you want.\n\nOf course there's a trade-off. In this case, the implementation was ~25 lines of code. If the implementation was  hundreds of lines you'd probably want to find a package that has done this already.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue for objects that may change: what is the best method for implementing them?\r\n                \r\nI need to store objects in a heap/priority queue. However, the objects may change so that their ordering changes, so fixUp or fixDown may need to be called on them. These methods are private and Java PriorityQueue wont let me do this. My options are:\n\n\nuse java PriorityQueue and remove and reinsert the object. Seems pretty inefficient, double the work.\nImplement my own priority queue and maintain code that duplicates functionality in the Java standard library.\n\n\nWhich would be preferred method/best practice for doing this ?\nThis sort of operations are needed to implement many graph algorithms eg. A*, so it is surprising Java does not let you do that.\n    ", "Answer": "\r\n\n  Seems pretty inefficient, double the work.\n\n\nBut still O(lg n) with any half-decent priority queue implementation. Have to tried this and measured it? I'd only start implementing my own PQ if the one in the library is really too slow. But if you do go that way, why not fork the one in OpenJDK and \"publicize\" some of its methods?\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Performance Metrics for a Priority Queue in DynamoDB\r\n                \r\nWe're considering using DynamoDB to implement a priority queue, and trying to understand the trade-offs between it and a Redis backed implementation (sorted set). In a similar system on a sister team, we see ~5-10ms dequeues from Redis.\nDoes anyone have run time experience using DynamoDB for a priority queue? Specifically the time to de-queue an item, ideally with a few percentiles. My assumption is that Redis will be much, much faster, but come with some care and feeding that DynamoDB will not have. Slower than 20-30ms would probably push us towards Redis, and I'm concerned the locking DynamoDB will need to do will slow it down quite a bit.\nDetails on a DynamoDB Priority Queue in case anyone's interested:\nhttps://aws.amazon.com/blogs/database/implementing-priority-queueing-with-amazon-dynamodb/\nThanks!\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue with limited space: looking for a good algorithm\r\n                \r\nThis is not a homework.\n\nI'm using a small \"priority queue\" (implemented as array at the moment) for storing last N items with smallest value. This is a bit slow - O(N) item insertion time. Current implementation keeps track of largest item in array and discards any items that wouldn't fit into array, but I still would like to reduce number of operations further.\n\nlooking for a priority queue algorithm that matches following requirements:\n\n\nqueue can be implemented as array, which has fixed size and _cannot_ grow. Dynamic memory allocation during any queue operation is strictly forbidden. \n Anything that doesn't fit into array is discarded, but queue keeps all smallest elements ever encountered.\n O(log(N)) insertion time (i.e. adding element into queue should take up to O(log(N))).\n (optional) O(1) access for *largest* item in queue (queue stores *smallest* items, so the largest item will be discarded first and I'll need them to reduce number of operations)\n Easy to implement/understand. Ideally - something similar to binary search - once you understand it, you remember it forever.\n Elements need not to be sorted in any way. I just need to keep N smallest value ever encountered. When I'll need them, I'll access all of them at once. So technically it doesn't have to be a queue, I just need N last smallest values to be stored.\n\n\nI initially thought about using binary heaps (they can be easily implemented via arrays), but apparently they don't behave well when array can't grow anymore. Linked lists and arrays will require extra time for moving things around. stl priority queue grows and uses dynamic allocation (I may be wrong about it, though).\n\nSo, any other ideas?\n\n--EDIT--\nI'm not interested in STL implementation. STL implementation (suggested by a few people) works a bit slower than currently used linear array due to high number of function calls.\n\nI'm interested in priority queue algorithms, not implemnetations.\n    ", "Answer": "\r\nArray based heaps seem ideal for your purpose. I am not sure why you rejected them.\n\nYou use a max-heap.\n\nSay you have an N element heap (implemented as an array) which contains the N smallest elements seen so far.\n\nWhen an element comes in you check against the max (O(1) time), and reject if it is greater.\n\nIf the value coming in is lower, you modify the root to be the new value and sift-down this changed value - worst case O(log N) time.\n\nThe sift-down process is simple: Starting at root, at each step you exchange this value with it's larger child until the max-heap property is restored.\n\nSo, you will not have to do any deletes  which you probably will have to, if you use std::priority_queue. Depending on the implementation of std::priority_queue, this could cause memory allocation/deallocation.\n\nSo you can have the code as follows:\n\n\nAllocated Array of size N.\nFill it up with the first N elements you see.\nheapify (you should find this in standard text books, it uses sift-down). This is O(N).\nNow any new element you get, you either reject it in O(1) time or insert by sifting-down in worst case O(logN) time.\n\n\nOn an average, though, you probably will not have to sift-down the new value all the way down and might get better than O(logn) average insert time (though I haven't tried proving it).\n\nYou only allocate size N array once and any insertion is done by exchanging elements of the array, so there is no dynamic memory allocation after that.\n\nCheck out the wiki page which has pseudo code for heapify and sift-down: http://en.wikipedia.org/wiki/Heapsort\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Objective-C++?\r\n                \r\nI'm working on a path finding algorithm and want to implement a priority queue to speed it up. \n\nI'm adding my ```\nNode```\n Object to the queue based on the property ```\nfScore```\n. With the smallest ```\nfScore```\n always added to the top of the queue.\n\nWhat are my options for this? Would it best to implement a c++ priority queue using stl? If so how would I set this up to take in my objective-c object ```\nNode```\n and how would I specify what the list is being ordered on (```\nNode.fScore```\n).\n\nThanks\n    ", "Answer": "\r\nFor ```\nstd:: priority_queue```\n, if you are using ARC you should be 90% of the way there. STL container will automatically store strong references. WIN!\nYou will need to create a custom compare class.\n```\ntypedef std::priority_queue<MyClass *, std::vector<MyClass *>, MyClassCompare> MyPriorityQueue;\n```\n\nI'm not exactly sure how you will want to implement your compare class. It will look something like:\n```\nclass MyClassCompare {\n    bool operator()(MyClass *lhs, MyClass *rhs) const {\n        // magic!!! Be sure to return a bool.\n    }\n};\n```\n\n\nExample Wrapper Class\nMyClassQueue.h\n```\n@interface MyClassQueue : NSObject\n@property (nonatomic, readonly) MyClass *topObject;\n@property (nonatomic, readonly) NSUInteger count;\n- (void)pushObject:(MyClass *)myObject;\n- (void)popObject;\n- (void)popAllObjects;\n@end\n```\n\nMyClassQueue.mm\n```\n#import \"MyClassQueue.h\"\n#include <queue>\n#import \"MyClass.h\"\n\nclass MyClassCompare {\n    bool operator()(MyClass *lhs, MyClass *rhs) const {\n        // magic!!! Be sure to return a bool.\n    }\n};\n\ntypedef std::priority_queue<MyClass *, std::vector<MyClass *>, MyClassCompare> MyPriorityQueue;\n\n@interface MyClassQueue ()\n@property (nonatomic) MyPriorityQueue *queue;\n@end\n@implementation MyClassQueue\n\n- (MyClass *)topObject {\n    return !self.queue->empty() ? self.queue->top() : nil;\n}\n\n- (NSUInteger)count {\n    return (NSUInteger)self.queue->size();\n}\n\n- (void)pushObject:(MyClass *)myObject {\n    self.queue->push(myObject);\n}\n\n- (void)popObject {\n    if (!self.queue->empty()) {\n        self.queue->pop();\n    }\n}\n\n- (void)popAllObjects {\n    if (!self.queue->empty()) {\n        delete _queue;\n        _queue = new MyPriorityQueue();\n    }\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (self != nil) {\n        _queue = new MyPriorityQueue();\n    }\n    return self;\n}\n\n- (void)dealloc {\n    delete _queue;\n    _queue = NULL;\n}    \n@end\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue random access\r\n                \r\nI have priority queue which sorts elements by some value(lets name it rating). I need to take elements from queue by rating. So i need to implement function queue_get(rating). This function also increases rating which is okay with priority heap.\n\nBut problem is that each level of the heap is not ordered by rating. Elements of each level only satisfy the heap property. So I could not surely return N-th element by rating.\n\nAre there any implementations of priority queue with such functionality?\nShould I use another data structure?\n    ", "Answer": "\r\nThe simplest solution is to use a binary search tree that is self-balancing, e.g. AVL tree, splay tree or red-black tree. It allows you to access elements by their key in O(log n) time and iterate through the objects in their order in O(log n + k) where k is the number of elements iterated.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Reprioritizing priority queue (efficient manner)\r\n                \r\nI'm looking for a more efficient way to reprioritize items in a priority queue. I have a (quite naive) priority queue implementation based on ```\nheapq```\n. The relevant parts are like:\n\n```\nfrom heapq import heapify, heappop\n\nclass pq(object):\n    def __init__(self, init= None):\n        self.inner, self.item_f= [], {}\n        if not None is init:\n            self.inner= [[priority, item] for item, priority in enumerate(init)]\n            heapify(self.inner)\n            self.item_f= {pi[1]: pi for pi in self.inner}\n\n    def top_one(self):\n        if not len(self.inner): return None\n        priority, item= heappop(self.inner)\n        del self.item_f[item]\n        return item, priority\n\n    def re_prioritize(self, items, prioritizer= lambda x: x+ 1):\n        for item in items:\n            if not item in self.item_f: continue\n            entry= self.item_f[item]\n            entry[0]= prioritizer(entry[0])\n        heapify(self.inner)\n```\n\n\nAnd here is a simple co-routine to just demonstrate the reprioritize characteristics in my real application.\n\n```\ndef fecther(priorities, prioritizer= lambda x: x+ 1):\n    q= pq(priorities)\n    for k in xrange(len(priorities)+ 1):\n        items= (yield k, q.top_one())\n        if not None is items:\n            q.re_prioritize(items, prioritizer)\n```\n\n\nWith testing\n\n```\nif __name__ == '__main__':\n    def gen_tst(n= 3):\n        priorities= range(n)\n        priorities.reverse()\n        priorities= priorities+ range(n)\n        def tst():\n            result, f= range(2* n), fecther(priorities)\n            k, item_t= f.next()\n            while not None is item_t:\n                result[k]= item_t[0]\n                k, item_t= f.send(range(item_t[0]))\n            return result\n        return tst\n```\n\n\nproducing:\n\n```\nIn []: gen_tst()()\nOut[]: [2, 3, 4, 5, 1, 0]\nIn []: t= gen_tst(123)\nIn []: %timeit t()\n10 loops, best of 3: 26 ms per loop\n```\n\n\nNow, my question is, does there exist any data-structure which would avoid calls to ```\nheapify(.)```\n, when repriorizating the priority queue? I'm here willing to trade memory for speed, but it should be possible to implement it in pure Python (obviously with much more better timings than my naive implementation).\n\nUpdate:\nIn order to let you to understand more on the specific case, lets assume that no items are added to the queue after initial (batch) pushes and then every fetch (pop) from the queue will generate number of repriorizations roughly like this scheme:\n\n\n0* ```\nn```\n, very seldom  \n0.05* ```\nn```\n, typically\n```\nn```\n, very seldom  \n\n\nwhere ```\nn```\n is the current number of ```\nitems```\nin queue. Thus, in any round, there are more or less only relative few items to repriorizate. So I'm hoping that there could exist a data-structure that would be able to exploit this pattern and therefore outperforming the cost of doing mandatory ```\nheapify(.)```\n in every round (in order to satisfy the heap invariant).  \n\nUpdate 2:\nSo far it seems that the ```\nheapify(.)```\n approach is quite efficient (relatively speaking) indeed. All the alternatives I have been able to figure out, needs to utilize ```\nheappush(.)```\n and it seems to be more expensive what I originally anticipated. (Anyway, if the state of issue remains like this, I'm forced to find a better solution out of the ```\npython```\n realm).\n    ", "Answer": "\r\nSince the new prioritization function may have no relationship to the previous one, you have to pay the cost to get the new ordering (and it's at minimum O(n) just to find the minimum element in the new ordering).  If you have a small, fixed number of prioritization functions and switch frequently between them, then you could benefit from keeping a separate heap going for each function (although not with heapq, because it doesn't support cheaply locating and removing and object from the middle of a heap).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Assertion error on priority queue with custom class pointers\r\n                \r\nI'm implementing a A* search algorithm but I keep running into problems with the priority queue. I have implemented a custom comparator for the priority queue according to this article\nThis is the relevant code:\n```\nclass CNode;\n\nstruct CompareNode : public binary_function<CNode*, CNode*, bool> {\n    bool operator()(const CNode* lhs, const CNode* rhs) const {\n        return lhs->m_costFromStart+lhs->m_heuristic > rhs->m_costFromStart+rhs->m_heuristic;\n    }\n};\n\n\nbool AStarSearch(CNode* start, CNode* end) {\n    priority_queue<CNode*, vector<CNode*>, CompareNode> open;\n    ...\n}\n```\n\nCall stack:\n```\nstd::_Debug_heap ...\nstd::pop_heap ...\nstd::priority_queue<CNode *,std::vector<CNode *,std::allocator<CNode *> >,CompareNode>::pop()\nAStarSearch(CNode * start=0x0f9a23b8, CNode * end=0x0f9a24e8)\n```\n\nGreater then was used as I needed a min heap for this algorithm.\nThe implementation seems to work fine and the problem goes away when it is run in release mode but the priority queue occasionally throws \"Invalid heap\" assertion failures in debug mode when the priority queue is pop()ed.\nI'm not familiar with binary_function in stl but the problem seems to lie with the comparator. Removing the comparator or changing the sign to less then removes the error but that would give me a max heap. Is there something I'm missing?\n    ", "Answer": "\r\nThanks for the help. Turns out I did not rebuild the heap after changing the cost of nodes in the priority queue. Calling \n\n```\nmake_heap(const_cast<CNode**>(&open.top()), const_cast<CNode**>(&open.top()) + open.size(), \nCompareNode());\n```\n\n\nafter every modification to the pq solved the problem.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue of doubles using vector C++\r\n                \r\nI need to write the code for a priority queue using an STL vector\n\nI have been assigned the task of implementing a priority queue of doubles using vector\npreviously I had implemented a queue using list, this was very straight forward as list provided me with all the functions I needed.\nUnless I'm missing something that's not the case with a priority queue?\n\nThe reference for a Priority Queue on cplusplus.com notes: One call to push_back on the underlying container(vector) and one call to push_heap (I assume algorithm), I'm not sure how to implement push_heap and pop_heap or whether I need to at all.\n\nThe assignment specifically asks for vector\n\nI'm looking for a good implementation/explanation of this.\n\nThis is mo code so far:\n\n.cpp\n\n```\n#include\"PriorityQueue.h\"\n#include <algorithm>\n\nPriorityQueue::PriorityQueue(){\n\n}\nvoid PriorityQueue::push(double val){\n    s.push_back(val);\n\n}\nvoid PriorityQueue::pop(){\n\n\n}\ndouble PriorityQueue::front() const{\n    return s.front();\n}\ndouble PriorityQueue::back() const{\n    return s.back();\n}\n```\n\n\n.h\n\n```\n#ifndef PRIORITYQUEUE_H\n#define PRIORITYQUEUE_H\n#include <vector>\nusing std::vector;\nclass PriorityQueue{\npublic:\n    PriorityQueue();\n    void push(double val);\n    void pop();\n    double front() const;\n    double back() const;\nprivate:\n    vector<double> s;\n};\n#endif // !PRIORITYQUEUE_H\n```\n\n\nIf I need to write the code to keep track of the top and bottom indexes, I may be missing essential functions, I'm just kinda stuck and don't have the time to waste trying loads of different solutions.  \n    ", "Answer": "\r\nYou can simply use a ```\nstd::vector```\n and add items to it using ```\npush_back```\n combined with ```\nstd::push_heap```\n from the ```\nalgorithm```\n header.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementation of Double Ended Priority Queue using Binary Search Tree/Linked List\r\n                \r\nI have to implement a Doubly Ended Priority Queue using both Doubly Linked list as well as Binary search Tree.\n\nMain functions should be getMin() and getMax() \n\n\nUsing Doubly Linked List:\nThe idea to get minimum and maximum element in O(1) is to insert small elements at one side of list and greater elements on other side, but there will be problem in insertion of elements everytime(It will not be O(1) then)\nIs there any better way to implement it ?\nUsing BST:\nI couldn't understand how will I be able to implement the getMin() and getMax() in BST. \n\n    ", "Answer": "\r\nNormal priority queues are usually implemented using heap so we can get the top value easily in O(1) and insert new elements in O(logn). I doubt there is a way to implement a priority queue using doubly linked lists that gets the same asymtoptical complexity, let alone a double-ended priority queue (i can be wrong though). Using a BST we can do both operations in O(logn):\n\n\nInsertions and deletions are the same as in your usual BST\nTo get the min value, start a traversal at the root and to all the way to the left until the current node has no left child. The last node you visited contains the min value\nTo get the max value, start a traversal at the root and go all the way to the right until the current node has no right child. The last node you visited contains the max value\n\n\nOf course, getMin and getMax will only be O(logn) if the BST is balanced, otherwise it can degenerate to O(n)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Min-Heap Implementing Priority Queue - Iteration\r\n                \r\nI'm trying to use this code to implement a Priority Queue. There are a number of questions regarding this implementation on the site, but given how many different ways you can write code to do essentially the same thing I am still at a loss after looking through a handful of other examples. \n\nThere are some missing lines in this code, but I am limited to editing only the four marked lines and so I find myself stuck on one particular aspect. I can't seem to understand how 'quantity' is incremented. \n\nFrom my understanding main creates a new object of maxSize = 5. Then calls the insertItem method passing the value of 130. This should be placed into the root (I had put queArray[quantity] = item; into the first blank) at which point the insertItem method exits and is then called again with the next value. So at what point is 'quantity' incremented? Maybe I am missing something incredibly simple, or maybe there is another way of solving this that may not be apparent or known to beginners like me?\n\nI would think you would want to increment quantity under the initial if statement, but that doesn't seem to be an option, so as far as I can tell the else statement can never be executed as quantity doesn't change. I know I am incorrect, but I don't know how, some help would be greatly appreciated.\n\n```\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    // array in sorted order, from max at 0 to min at size-1\n    private int maxSize;\n    private long[] queArray;\n    private int quantity;\n\n    public Main(int s) {\n        maxSize = s;\n        queArray = new long[maxSize];\n        quantity = 0;\n    }\n\n    public void insertItem(long item) {\n        int i;\n\n        if (quantity == 0)\n            __________; // insert at 0\n        else\n        {\n            for (i = quantity - 1; i >= 0; i--) // start at end,\n            {\n                if (item > queArray[i]) // if new item larger,\n                    __________; // shift upward\n                else\n                    // if smaller,\n                    break; // done shifting\n            }\n            __________; // insert it\n            __________;\n        } // end else (quantity > 0)\n    }\n\n    public boolean PQEmpty(){\n        return (quantity == 0);\n    }\n\n    public long removeItemPQ(){\n        return queArray[--quantity];\n    }\n\n    public long peekMin(){\n        return queArray[quantity - 1];\n    }\n\n    public static void main(String[] args) {\n        Main thePQ = new Main(5);\n        thePQ.insertItem(130);\n        thePQ.insertItem(450);\n        thePQ.insertItem(110);\n        thePQ.insertItem(430);\n        thePQ.insertItem(280);\n\n        while (!thePQ.PQEmpty()) {\n            long item = thePQ.removeItemPQ();\n            System.out.print(item + \" \");\n        }\n        System.out.println(\"\");\n    }\n}\n```\n\n    ", "Answer": "\r\nIt isn't a style I'd recommend, but you could use ```\nqueArray[quantity++] = item;```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Bounded concurrent priority queue\r\n                \r\nI need a version of priority queue which is bounded and thread safe. In Java we have ```\nLinkedBlockingQueue```\n which is optionally-bounded, but does not support prioritization. ```\nPriorityBlockingQueue```\n in turn is unbounded.\nIs there an out-of-the-box implementation of concurrent bounded blocking queue in Scala?\nI can imagine a hand-crafted implementation using ```\nSemaphore```\n, but would like to avoid reinventing a wheel.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue, where to insert?\r\n                \r\nso I am having trouble implementing priority queue. For a priority queue, I need to find the first place where it is empty...that's where the element go, we will swap later..but I am having trouble figuring out the algorithm to find it.\n\nHere's what I have so far:\n\n```\nvoid pq_insert(struct tnode* p)\n{\n    struct tnode* curr=NULL;\n    struct tnode* prev=NULL;\n   printf(\"inserting:%c,%f\\n\",p->symbol,p->freq);\n   if(qhead==NULL) /*qhead is null*/\n   {\n    qhead = p;\n        /*TODO: write code to insert when queue is empty*/\n   }\n   /*TODO: write code to find correct position to insert*/\n    curr = qhead;\n    while (curr != NULL){//I think this is wrong\n        if ((curr -> left) == NULL){\n            curr = curr -> right;\n        }\n        else{\n            curr = curr -> left;\n        }   \n    }\n\n   if(curr==qhead)\n   {\n        /*TODO: write code to insert before the current start*/\n\n   }\n   else /*insert between prev and next*/\n   {\n        /*TODO: write code to insert in between*/\n   }\n}\n```\n\n    ", "Answer": "\r\nYes, the code you think is wrong:\n\n```\nwhile (curr != NULL){//I think this is wrong\n    if ((curr -> left) == NULL){\n        curr = curr -> right;\n    }\n    else{\n        curr = curr -> left;\n    }   \n}\n```\n\n\nis wrong.  You are navigating curr to some part of your tree regardless of your current node.\n\nYou probably want to change your inner if to something like:\n\n```\nif (p->freq < curr->freq)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Standard library Priority Queue push method\r\n                \r\nThe code snippet below is the library implementation of the push methods for a priority queue. I am wondering why the line with the code ```\na = a[0 : n+1]```\n does not throw an out of bounds errors. \n\n```\n func (pq *PriorityQueue) Push(x interface{}) {\n    // Push and Pop use pointer receivers because they modify the slice's length,\n    // not just its contents.\n    // To simplify indexing expressions in these methods, we save a copy of the\n    // slice object. We could instead write (*pq)[i].\n    a := *pq\n    n := len(a)\n    a = a[0 : n+1]\n    item := x.(*Item)\n    item.index = n\n    a[n] = item\n    *pq = a\n}\n```\n\n    ", "Answer": "\r\na slice is not an array; it is a view onto an existing array.  The slice in question is backed by an array larger than itself.  When you define a slice of an existing slice, you're actually slicing the underlying array, but the indexes referenced are relative to the source slice.  \n\nThat's a mouthful.  Let's prove this in the following way:  we'll create a slice of zero length, but we'll force the underlying array to be larger.  When creating a slice with ```\nmake```\n, the third parameter will set the size of the underlying array.  The expression ```\nmake([]int, 0, 2)```\n will allocate an array of size 2, but it evaluates to a size-zero slice. \n\n```\npackage main\n\nimport (\"fmt\")\n\nfunc main() {\n    // create a zero-width slice over an initial array of size 2\n    a := make([]int, 0, 2)\n    fmt.Println(a)\n\n    // expand the slice.  Since we're not beyond the size of the initial\n    // array, this isn't out of bounds.\n    a = a[0:len(a)+1]\n\n    a[0] = 1\n    fmt.Println(a)\n    fmt.Println(a[0:len(a)+1])\n}\n```\n\n\nsee here.  You can use the ```\ncap```\n keyword to reference the size of the array that backs a given slice.  \n\nThe specific code that you asked about loops over ```\ncap(pq)```\n in the calling context (container/heap/example_test.go line 90).  If you modify the code at the call site and attempt to push another item into the queue, it will panic like you expect.  I ... probably wouldn't suggest writing code like this.  Although the code in the standard library executes, I would be very sour if I found that in my codebase.  It's generally safer to use the ```\nappend```\n keyword.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue without insertion block\r\n                \r\nAssuming I have a custom class for which I would like to have a priority queue (having a fixed size, say 100 objects). But the problem with the standard ```\nqueue.PriorityQueue```\n is that having a maximum size blocks the insertion after the queue is full.\nI would like the buffer to still allow for insertions by removing the least priority elements (as decided by my ```\n__cmp__(self, other)```\n function implementation) from the queue. Does there exist any built-in implementations of the same?\n    ", "Answer": "\r\nNo, there is no built-in feature for that.\nWhat's more, a priory queue is designed to identify the top priority entry fast, but is not designed to quickly identify which is the item with the least priority. If you would add logic to find it, it would kill the performance of the queue.\nI would suggest implementing a so-called min-max heap, which can identify both the least and greatest element in an efficient manner.\nOn the other hand, if you are only targetting a maximum size of 100 elements, you should probably just work with a list and keep it sorted. For such small lists that will be fast enough, and it is easy to clip the list when it exceeds the maximum size.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "a double- ended priority queue implemention with two priority queues,if i delete max in maxPQ, how to delete the same data in the minPQ in O(logn)\r\n                \r\nHere is my code:\n\n```\n public DoubleEndedPriorityQueue(){\n     max = new MaxPQ<Element>();\n     min = new MinPQ<Element>();\n }\n public void insert(Key item){\n     Element thisElement = new Element(item);\n     Element thatElement = new Element(item);\n     thisElement.element = thatElement;\n     thatElement.element = thisElement;\n     max.insert(thisElement);\n     min.insert(thatElement);\n }\n private class Element{\n     Key item;\n     Element element;\n     private Element(){}\n     private Element(Key item){\n         this(item,null);\n     }\n     private Element(Key item,Element element){\n         this.item = item;\n         this.element = element;\n     }\n }\n```\n\n\n}\n\ni create a data-structure to store a key and the reference pointing to the element which  stored the same key in another array(the priority queue is implemented by the array),the problem is:if i find a element in an array ,i want to find the element with the same key in another array in o(1) which means  i can know its index in O(1), how can i do it?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Can the stl c++ priority queue be used with stl set?\r\n                \r\nMy question is identical to Is there a Queue (PriorityQueue) implementation which is also a Set? except that this one is about c++ and stl. \n\nIs it possible to use the stl priority queue with the stl set as the container class? If not, is there an alternative container class that I can use with the priority queue to also make it a set? \n    ", "Answer": "\r\nThe specification of ```\nstd::priority_queue```\n does not allow \"unique membership\". If you want unique membership in your priority queues, then you don't want ```\nstd::priority_queue```\n.\n\nIf you want a priority queue implementation with unique membership, then ```\nstd::set```\n already does that, because it keeps its members in sorted order.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue O(1) insertion and removal\r\n                \r\nIs it possible for a priority queue to have both O(1) insertion and removal? \n\nPriority queues can be implemented using heaps and looking at the run times for Fibonacci heaps it appears that it is not possible to get a run time better than O(logN) per removal.\n\nI am trying to implement a data structure where given N items I will have half in a max-priority queue and half in a min-priority queue. I am then to remove all N items sequentially.\n\nI can insert all N elements in O(N) time but removing all N items will take O(N*logN) so I am wondering if another approach would be more suitable.\n    ", "Answer": "\r\nIf you could construct a priority queue with O(1) insertion and O(1) removal, you could use that to sort a list of n items in O(n) time. As explained in this answer, you can't sort in O(n) in the general case, so it will be impossible to construct a priory queue with O(1) insertion and O(1) removal without making more assumptions on the input.\n\nFor example, a priority queue that has O(1) insertion and O(k) (k is the maximum element that could be inserted) removal can be constructed. Keep a table of k linked lists. Insertion of ```\nx```\n just prepends an item to the front of the ```\nx```\nth list. Removal has to scan through the table to find the first non-empty list (then remove the first item of the list and return the index of that list). There are only k lists, so removal takes O(k) time. If k is a constant, that works out to O(1) removal.\n\nIn practice, using a table of counts would work out better. Incrementing a variable-length integer isn't constant time unless you use amortized analysis (which is why I didn't use it in the previous paragraph), but in practice you wouldn't need variable-length counts anyway. Also, in practice it would be bad for large k, even if k is a constant - you'd run out of memory quickly and scanning for the first non-zero element could take a while.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue with ArrayList Parameters\r\n                \r\nI am trying to implement a Priority Queue of two ArrayLists in Java. I want each in the queue to return (String, Integer) and I have an ArrayList of Strings and a separate ArrayList of Integers.\n\nI know I can make two separate Priority Queues, but I want to make one that will take both parameters. Is this possible?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue using Binary Search Tree not producing correct output\r\n                \r\nI implemented a Priority Queue using a BST.  Its output is not correct.\n\nOutput:\n\n\nEnter number of elements: 9\nEnter number 1 of 9: 8\nEnter number 2 of 9: 10\nEnter number 3 of 9: 14\nEnter number 4 of 9: 13\nEnter number 5 of 9: 3\nEnter number 6 of 9: 6\nEnter number 7 of 9: 7\nEnter number 8 of 9: 4\nEnter number 9 of 9: 1\nOutputting number 1 of 9: 14\nOutputting number 2 of 9: 13\nOutputting number 3 of 9: 10\nOutputting number 4 of 9: 3\nOutputting number 5 of 9: 3\nOutputting number 6 of 9: 3\nOutputting number 7 of 9: 3\nOutputting number 8 of 9: 3\nOutputting number 9 of 9: 3\nPress any key to continue . . .\n\n\nTest.cpp\n\n```\n//Arkadiy Vasilkovskiy 832a1\n#include <iostream>\n#include \"CTree.h\"\n#include \"PriorityQueueBST.h\"\nusing namespace std;\n\nint main()\n{\n\n    int num, input, output;\n    cout << \"Enter number of elements: \";\n    cin >> num;\n    PriorityQueueBST p;\n    for (int x = 0; x < num; x++)\n    {\n        cout << \"Enter number \" << x + 1  \n            << \" of \" << num << \": \";\n        cin >> input;\n        p.Enqueue(input);\n    }\n\n    for (int y = 0; y < num; y++)\n    {\n        cout << \"Outputting number \" << y + 1  \n            << \" of \" << num << \": \";\n        if(p.IsEmpty())\n        {\n            break; //we are done (this is an error!)\n        }\n\n        output = p.Dequeue();\n        cout << output << endl;\n    }\n\n    system(\"pause\");\n    return 0;\n    //CTree* tr = new CTree();\n    //\n    //for (int i = 0; i < 3; i++)\n    //  tr->Add();\n\n    //tr->View();\n    //system(\"pause\");\n\n\n    //return 0;\n}\n```\n\n\nBST Declaration File\n\n```\nstruct TreeNode\n{\n    int info;\n    TreeNode* leftLink;\n    TreeNode* rightLink;\n};\n\n\nclass CTree\n{\npublic:\n    CTree();\n    ~CTree();\n    void Add(int);\n    void View();\n    bool IsEmpty();\n    int popLargest(TreeNode*);\n    TreeNode *tree;\n\n\nprivate:    \n    void AddItem( TreeNode*&, TreeNode*);\n    void DisplayTree(TreeNode*);\n    void Retrieve(TreeNode*&, TreeNode*,bool&);\n    void Destroy(TreeNode*&);\n};\n```\n\n\nBST Implementation FIle\n\n```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#include \"CTree.h\"\n\nCTree::CTree()\n{\n    tree = NULL;\n}\n\nCTree::~CTree()\n{\n    Destroy(tree);\n}\n\nvoid CTree::Destroy(TreeNode*& tree)\n{\n    if (tree != NULL)\n    {\n    Destroy(tree->leftLink);\n    Destroy(tree->rightLink);\n    delete tree;\n    }\n}\n\n\nbool CTree::IsEmpty()\n{\n    if(tree == NULL) \n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nvoid CTree::Add(int dataToEnter)\n{\n    TreeNode* newPerson = new TreeNode();\n    /*cout << \"Enter the person's name: \";\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n    cin.getline(newPerson->name, 20);*/\n    //cout << \"Enter the person's contribution: \";\n    //cin >> newPerson->info;\n    /*bool found = false;*/\n\n    newPerson->info = dataToEnter;\n    newPerson->leftLink = NULL;\n    newPerson->rightLink = NULL;\n\n    /*Retrieve(tree, newPerson, found);\n     if (found)\n         cout << \"info allready entered\\n\";\n     else*/\n         AddItem(tree, newPerson);\n}\n\nvoid CTree::View()\n{\n    if (IsEmpty())\n    {\n        cout<<\"The list is empy\";\n    }\n    else\n    {\n        DisplayTree(tree);\n\n    }\n\n};\n\nvoid CTree::AddItem( TreeNode*& ptr, TreeNode* newPer )\n{\n        if (ptr == NULL)\n        {\n            ptr = newPer;\n        }\n        else if ( newPer->info < ptr->info)\n            AddItem(ptr->leftLink, newPer); \n        else\n            AddItem(ptr->rightLink, newPer); \n}\nvoid CTree::DisplayTree(TreeNode* ptr)\n{\n    if (ptr == NULL)\n                    return;\n    DisplayTree(ptr->rightLink);\n    cout << ptr->info << endl; //cout<<ptr->name<<\" \"<<\"$\"<<ptr->info <<endl;\n    DisplayTree(ptr->leftLink); \n}\nvoid CTree::Retrieve(TreeNode*& ptr, TreeNode* newPer, bool& found)\n{\n    {\n        if (ptr == NULL)\n        {\n            found = false; // item is not found.\n        }\n        else if ( newPer->info < ptr->info)\n        {\n            Retrieve(ptr->leftLink, newPer, found);\n        }\n             // Search left subtree.\n        else if (newPer->info > ptr->info)\n        {\n            Retrieve(ptr->rightLink, newPer, found);// Search right subtree.\n        }   \n        else\n        {\n            //newPer.info = ptr->info; // item is found.\n            found = true;\n        }\n    }\n}\n\nint CTree::popLargest(TreeNode* tr)\n{\n    //Failed Attempt at returning one value at a time and deleting that node\n    int largest; // = tr->info;\n    TreeNode* prev = NULL;\n    TreeNode* cur = tr;\n\n    if(tr != NULL)\n        largest = tr->info;\n\n    while (cur->rightLink != NULL)\n    {\n        prev = cur;\n        cur = cur->rightLink;\n        largest = cur->info;\n        //DeleteAttemptTwo(tr, largest);//DeleteItem(largest);  \n\n    }\n\n    /*if (prev != NULL)\n    {\n        prev->rightLink = cur->leftLink;\n    }*/\n\n    if(prev != NULL)\n    {\n        if (cur->leftLink != NULL)\n        {\n            prev->rightLink = cur->leftLink;\n        }\n        else \n        {\n            prev->rightLink = NULL;\n        }\n    }\n    else if (cur->leftLink != NULL)\n    {\n        largest = cur->leftLink->info;\n    }\n\n    return largest;\n}\n```\n\n\nPriority Queue Declaration File\n\n```\n#ifndef PRIORITYQUEUESLL__H\n#define PRIORITYQUEUESLL__H\n\nclass PriorityQueueBST\n{\n    public:\n        PriorityQueueBST();\n        ~PriorityQueueBST();\n        void Enqueue(int);\n        int Dequeue();\n        bool IsEmpty();\n\n    private:\n        CTree* ourTree;\n};\n\n#endif\n```\n\n\nPriority Queue Implementation File\n\n```\n#include <iostream>\nusing namespace std;\n#include \"CTree.h\"\n#include \"PriorityQueueBST.h\"\n\nPriorityQueueBST::PriorityQueueBST()\n{\n    ourTree = new CTree();\n    //head = NULL;\n}\n\nPriorityQueueBST::~PriorityQueueBST()\n{\n\n}\n\nvoid PriorityQueueBST::Enqueue(int dataToEnter)\n{\n    ourTree->Add(dataToEnter);\n}\n\nint PriorityQueueBST::Dequeue()\n{\n    int largest = ourTree->popLargest(ourTree->tree);\n    return largest;\n}\n\nbool PriorityQueueBST::IsEmpty()\n{\n    return ourTree->IsEmpty();\n\n}\n```\n\n    ", "Answer": "\r\nI ran your code and looked at what was happening in the debugger. As it turns out your tree is being corrupted when you pop the numbers out of it. I didn't look into exactly how it was happening but basically. Before the first few calls to pop largest your tree looked like:\n\n```\n           8\n    3            10\n1      6              14\n     4   7         13\n```\n\n\nAnd after you pop 14, 13, 10 it became:\n\n```\n           8\n    3\n1      6\n     4   7\n```\n\n\nNow if I understood your code correctly the error in logic is here:\n\n```\nif(prev != NULL)\n{\n    if (cur->leftLink != NULL)\n    {\n        prev->rightLink = cur->leftLink;\n    }\n    else \n    {\n        prev->rightLink = NULL;\n    }\n}\nelse if (cur->leftLink != NULL)\n{\n    largest = cur->leftLink->info;\n}\n```\n\n\nNow if you notice in the case that the highest number is the root of the tree (meaning prev == NULL), in this case 8, you return the wrong value. You say the highest value is the left link but it isn't it's the root node's value. Wost, you never take it out of the tree, so you're stuck giving the same answer all the time.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queues in GO\r\n                \r\nCan anyone explain this to me:\nI want to implement a priority queue in GO (interface implementation got from link, but for the lowest priority)\n\nMy code: \n\n```\npq := make(PriorityQueue, 0)\n\npq.Push(&Item{value: 0, priority: 0})\n\nheap.Init(&pq)\n\nfmt.Println(heap.Pop(&pq).(*Item))\n\nitem := &Item{value: 1, priority: 10}\npq.Push(item)\nitem = &Item{value: 2, priority: 20}\npq.Push(item)\nitem = &Item{value: 3, priority: 5}\npq.Push(item)\n\nfmt.Println(heap.Pop(&pq).(*Item))\nfmt.Println(heap.Pop(&pq).(*Item))\nfmt.Println(heap.Pop(&pq).(*Item))\n\n// Output:\n&{0 0 -1}\n&{1 10 -1}\n&{3 5 -1}\n&{2 20 -1}\n```\n\n\nWhy it not outputs:\n\n```\n&{0 0 -1}\n&{3 5 -1} \n...\n```\n\n    ", "Answer": "\r\nTLDR use ```\nheap.Push(...)```\n and ```\nheap.Pop(...)```\n to add and remove from your queue and preserve order.\n\nThe problem is in your setup. You should not directly push or pop from your queue and expect it to be ordered. Calling ```\nheap.Init(&pq)```\n will sort the entire heap, so you can load in stuff and order everything at once.\n\nFor your use case, you should be using the heap utilities for push and pop. When you are adding to the queue, use ```\nheap.Push(...)```\n rather than ```\npq.Push(...)```\n\n\n```\npq := make(PriorityQueue, 0)\n\nheap.Push(&pq, &Item{value: \"0\", priority: 0, index: 0})\nitem := &Item{value: \"1\", priority: 10, index: 1}\nheap.Push(&pq, item)\nitem = &Item{value: \"2\", priority: 20, index: 2}\nheap.Push(&pq, item)\nitem = &Item{value: \"3\", priority: 5, index: 3}\nheap.Push(&pq, item)\n\nfmt.Println(heap.Pop(&pq).(*Item))\nfmt.Println(heap.Pop(&pq).(*Item))\nfmt.Println(heap.Pop(&pq).(*Item))\nfmt.Println(heap.Pop(&pq).(*Item))\n```\n\n\nSubsequent push and pops will always be ordered this way. Since every item is ordered on insertion, you don't need to call ```\nheap.Init(&pq)```\n. This is closer to an implementation that would be used in a production environment where pushes and pops are interspersed.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why priority queue is implemented using heaps when we can implement it using just vector more efficiently\r\n                \r\nWhy is ```\npriority_queue```\n implemented using heaps when without using heaps too we can implement it with just vectors.\n\nSuppose we use vector as a queue and keep the elements in decreasing order. \nWe can use this as priority queue.\n\nFor insertion: We can use binary search. ```\nComplexity O(logN)```\n \n\nFor deletion: Here also we can use binary search. ```\nComplexity O(logN)```\n \n\nFor top element: ```\nO(1)```\n\n\nIn addition, we can have access kth maximum element in just ```\nO(1)```\n time which is not the case with heaps. \n\nThen, why do we use heaps for implementing priority queues?\n    ", "Answer": "\r\n\nFor insertion : We can use binary search . Complexity O(logN)\nFor deltion : Here also we can use binary search. Complexity O(logN)\n\nNo, you can't. By using a sorted array/vector you can only search for the correct index on ```\nO(log N)```\n but to do the actual insert or delete you have to shift other elements which is ```\nO(N)```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Go - wait for next item in a priority queue if empty\r\n                \r\nI am trying to implement a priority queue to send json objects through a network socket based on priority. I am using the ```\ncontainer/heap```\n package to implement the queue. I came up with something like this:\n\n```\nfor {\n    if pq.Len() > 0 {\n        item := heap.Pop(&pq).(*Item)\n        jsonEncoder.Encode(&item)\n    } else {\n        time.Sleep(10 * time.Millisecond)\n    }\n}\n```\n\n\nAre there better ways to wait for a new item than just polling the priority queue?\n    ", "Answer": "\r\nI'd probably use a couple a queuing goroutine. Starting with the data structures in the PriorityQueue example, I'd build a function like this:\n\nhttp://play.golang.org/p/hcNFX8ehBW\n\n```\nfunc queue(in <-chan *Item, out chan<- *Item) {\n    // Make us a queue!\n    pq := make(PriorityQueue, 0)\n    heap.Init(&pq)\n\n    var currentItem *Item       // Our item \"in hand\"\n    var currentIn = in          // Current input channel (may be nil sometimes)\n    var currentOut chan<- *Item // Current output channel (starts nil until we have something)\n\n    defer close(out)\n\n    for {\n        select {\n        // Read from the input\n        case item, ok := <-currentIn:\n            if !ok {\n                // The input has been closed. Don't keep trying to read it\n                currentIn = nil\n                // If there's nothing pending to write, we're done\n                if currentItem == nil {\n                    return\n                }\n                continue\n            }\n\n            // Were we holding something to write? Put it back.\n            if currentItem != nil {\n                heap.Push(&pq, currentItem)\n            }\n\n            // Put our new thing on the queue\n            heap.Push(&pq, item)\n\n            // Turn on the output queue if it's not turned on\n            currentOut = out\n\n            // Grab our best item. We know there's at least one. We just put it there.\n            currentItem = heap.Pop(&pq).(*Item)\n\n            // Write to the output\n        case currentOut <- currentItem:\n            // OK, we wrote. Is there anything else?\n            if len(pq) > 0 {\n                // Hold onto it for next time\n                currentItem = heap.Pop(&pq).(*Item)\n            } else {\n                // Oh well, nothing to write. Is the input stream done?\n                if currentIn == nil {\n                    // Then we're done\n                    return\n                }\n\n                // Otherwise, turn off the output stream for now.\n                currentItem = nil\n                currentOut = nil\n            }\n        }\n    }\n}\n```\n\n\nHere's an example of using it:\n\n```\nfunc main() {\n    // Some items and their priorities.\n    items := map[string]int{\n        \"banana\": 3, \"apple\": 2, \"pear\": 4,\n    }\n\n    in := make(chan *Item, 10) // Big input buffer and unbuffered output should give best sort ordering.\n    out := make(chan *Item)    // But the system will \"work\" for any particular values\n\n    // Start the queuing engine!\n    go queue(in, out)\n\n    // Stick some stuff on in another goroutine\n    go func() {\n        i := 0\n        for value, priority := range items {\n            in <- &Item{\n                value:    value,\n                priority: priority,\n                index:    i,\n            }\n            i++\n        }\n        close(in)\n    }()\n\n    // Read the results\n    for item := range out {\n        fmt.Printf(\"%.2d:%s \", item.priority, item.value)\n    }\n    fmt.Println()\n}\n```\n\n\nNote that if you run this example, the order will be a little different every time. That's of course expected. It depends on exactly how fast the input and output channels run.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ Boost Priority Queue Behavior\r\n                \r\nI tried to find out exactly how the boost priority queue is implemented and I am confused.\nHeader file (main.hpp):\n```\n#ifndef MAIN_HPP\n#define MAIN_HPP\n\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n\n#include <boost/heap/priority_queue.hpp>\n\ntypedef std::int32_t int32_t;\n\ntypedef struct st {\n    int32_t num;\n    int32_t f;\n\n    st() {\n        std::cout << \"DEFAULT\" << std::endl;\n        this->f = 0;\n    }\n\n    st(int32_t num) {\n        std::cout << \"creation\\t\" << num << std::endl;\n        this->num = num;\n        this->f = 0;\n    }\n\n    ~st() {\n        std::cout << \"del\\t\" << num << std::endl;\n        f = 1;\n    }\n} st;\n\ntypedef struct st_c0 {\n    bool operator()(const st& st0, const st& st1) const {\n        return (st0.num > st1.num);\n    }\n} st_c0;\n\ntypedef struct st_c1 {\n    bool operator()(const st* st0, const st* st1) const {\n        return (st0->num > st1->num);\n    }\n} st_c1;\n\n#endif\n```\n\n```\n#include \"main.hpp\"\n\nint main() {\n    boost::heap::priority_queue<st, boost::heap::compare<st_c0>> q0;\n    boost::heap::priority_queue<st*, boost::heap::compare<st_c1>> q1;\n    st y = st(5);\n    q0.push(st(44));\n    q0.push(y);\n    q0.empty();\n    std::cout << y.f << std::endl;\n    return 0;\n}\n```\n\nThe output I get is:\n```\ncreation        5\ncreation        44\ndel     44\ndel     44\ndel     44\ndel     44\ndel     44\ndel     5\ndel     5\ndel     5\n0\ndel     5\ndel     5\ndel     44\n```\n\nThe order of object creation and deletion does not make sense. How do the internals of the priority queue work, and what is the best practice for them (storing pointers vs storing objects)?\n    ", "Answer": "\r\nYou aren't accounting for the copy-constructor that will automatically be created for your class.\nIn your case you wouldn't automatically get a move-constructor, but it's still nice to see where the compiler could do a move instead of a copy.\nIf you change your ```\nst```\n to e.g.:\n```\n\nstruct st {\n    int32_t num;\n    int32_t f;\n\n    st() {\n        std::cout << this << \"\\tctor default\" << std::endl;\n        this->f = 0;\n    }\n\n    st(int32_t num) : num(num), f(0) {\n        std::cout << this << \"\\tctor num\\t\" << num << std::endl;\n    }\n\n    st(st const& other) : num(other.num), f(other.f) {\n        std::cout << this << \"\\tctor copy\\t\" << num << \"\\t (from \" << &other << \")\" << std::endl; \n    }\n\n    st(st&& other): num(other.num), f(other.f) {\n        std::cout << this << \"\\tctor move\\t\" << num << \"\\t (from \" << &other << \")\" << std::endl;\n    }\n\n    st& operator=(st const& other) {\n        num = other.num;\n        f = other.f;\n        std::cout << this << \"\\tassign copy\\t\" << num << \"\\t (from \" << &other << \")\" << std::endl;\n        return *this;\n    }\n\n    st& operator=(st&& other) {\n        num = other.num;\n        f = other.f;\n        std::cout << this << \"\\tassign move\\t\" << num << \"\\t (from \" << &other << \")\" << std::endl;\n        return *this;\n    }\n\n    ~st() {\n        std::cout << this << \"\\tdtor\\t\\t\" << num << std::endl;\n    }\n};\n```\n\ngodbolt example\nyou'll get a better picture of what's going on:\n```\n// construct y\n0x7fffd8f3b1e8  ctor num    5\n// call to push(st(44))\n0x7fffd8f3b238  ctor num    44\n0x7fffd8f3b1b4  ctor copy   44   (from 0x7fffd8f3b238)\n0x97cec0        ctor move   44   (from 0x7fffd8f3b1b4)\n0x7fffd8f3b1b4  dtor        44\n0x7fffd8f3b164  ctor move   44   (from 0x97cec0)\n0x7fffd8f3b178  ctor move   44   (from 0x7fffd8f3b164)\n0x97cec0        assign move 44   (from 0x7fffd8f3b178)\n0x7fffd8f3b178  dtor        44\n0x7fffd8f3b164  dtor        44\n0x7fffd8f3b238  dtor        44\n// call to push(y)\n0x7fffd8f3b1b4  ctor copy   5    (from 0x7fffd8f3b1e8)\n0x97cee8        ctor move   5    (from 0x7fffd8f3b1b4)\n0x97cee0        ctor copy   44   (from 0x97cec0)\n0x97cec0        dtor        44\n0x7fffd8f3b1b4  dtor        5\n0x7fffd8f3b164  ctor move   5    (from 0x97cee8)\n0x7fffd8f3b178  ctor move   5    (from 0x7fffd8f3b164)\n0x97cee8        assign move 44   (from 0x97cee0)\n0x97cee0        assign move 5    (from 0x7fffd8f3b178)\n0x7fffd8f3b178  dtor        5\n0x7fffd8f3b164  dtor        5\n// after main()\n0x7fffd8f3b1e8  dtor        5\n0x97cee0        dtor        5\n0x97cee8        dtor        44\n```\n\nSo to break it down:\n\n\n\npushing the first element\n\n\nyour ```\nst```\n is constructed and after that copied & moved a few times.\nit finally ends up in ```\n0x97cec0```\n (the allocated storage from the heap)\n\n\n\n\npushing the second element\n\n\nthe second call triggers a resize, so the 44 must be moved to a new allocation\nthe 5 also gets copied & moved a bit\nthe 5 & 44 are swaped into place, so the priority queue is correctly sorted\n\n\n\n\n```\nempty()```\n\n\n\ndoes nothing (would return true, because the container contains elements)\nif you want to delete all elements use ```\nclear()```\n.\n\n\n\n\nafter main returns\n\n\ny gets destructed\nthe priority queue gets destructed and calls the destructor for both ```\nst```\n's\n\n\n\nThere are no guarantees though how many copies / moves the implementation of ```\nboost::heap::priority_queue<st, boost::heap::compare<st_c0>>```\n does, so this might change at any time.\n\nPointers vs Objects\nIn general you would use objects whenever they are small and easy to copy / move.\nIf you use pointers your object won't be copied or moved at all, only the pointer to it, so this would be better if your objects are large and / or expensive to copy / move.\nBut with bare pointers you also need to ```\ndelete```\n them manually, if possible i would recommend to use smart pointers instead, e.g.:\n```\nboost::heap::priority_queue<boost::shared_ptr<st>, boost::heap::compare<TODO>> q0;\n```\n\nthat way your ``st`'s autmatically get freed & you don't have to manually delete them.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "The confusion of the index priority queue\r\n                \r\nI have got the idea of the priority queue.But when it comes to  the index priority queue, I'm a little confused with the implemention of some method such as change(int k, Item item) and delete(int i) .\n\nchange(int k, Item item) is to change the item associated with k to item\ndelete(int i) is to remove k and its associated item\n\n```\npublic void changeKey(int i, Key key) {\n        if (i < 0 || i >= maxN) throw new IndexOutOfBoundsException();\n        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n        keys[i] = key;\n        swim(qp[i]);\n        sink(qp[i]);\n    }\n\npublic void delete(int i) {\n        if (i < 0 || i >= maxN) throw new IndexOutOfBoundsException();\n        if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n        int index = qp[i];\n        exch(index, n--);\n        swim(index);\n        sink(index);\n        keys[i] = null;\n        qp[i] = -1;\n    }\n\nprivate void swim(int k) {\n        while (k > 1 && greater(k/2, k)) {\n            exch(k, k/2);\n            k = k/2;\n        }\n    }\n\n    private void sink(int k) {\n        while (2*k <= n) {\n            int j = 2*k;\n            if (j < n && greater(j, j+1)) j++;\n            if (!greater(k, j)) break;\n            exch(k, j);\n            k = j;\n        }\n    }\n\n\nprivate int maxN;        // maximum number of elements on PQ\nprivate int n;           // number of elements on PQ\nprivate int[] pq;        // binary heap using 1-based indexing\nprivate int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i\nprivate Key[] keys;      // keys[i] = priority of i\n```\n\nI understand the operation of sink and swim.But why in the method delete(int i) and changeKey(int i,Key key) have the statements ```\nswim(qp[i]/index);```\n and ```\nsink(qp[i]/index);```\nwhat on earth happens?\nAnd I also want to know the elements construction style between priority queue and index priority queue and what is stored in the binary heap on the index priority queue?index or elements?\n    ", "Answer": "\r\nThose are operations on a binary heap that need to be performed when you change a key. Every 'node' in priority queue is kept in the binary heap. When you add an item, that item needs to be positioned in a right place, so the 'rules of binary heap' are not broken.\n\nThe same happens with changing the key, you need to change item's position in the priority heap so the rules are not broken (the children of that item are not bigger than it, and parent of that item is not smaller).\n\nThis priority queue is implemented with a binary heap, that means that it's based on binary tree, that's why you can see division by 2 in those methods, because it needs to take item up/down level by level and that is achieved by that division (first level has one node, second level has two nodes, third level has four nodes etc., number of nodes is multiplied by 2 each level).\n\nThis post is just an introduction to a huge and wide topic, I suggest reading more about it (especially 'heapify' sections): check this out.\n\nGenerally, the point is you have only 1 method for changing key and it invokes both ```\nswim```\n and ```\nsink```\n, because the previous key may be higher or lower. It's usually done with 2 methods: ```\ndecreaseKey```\n and ```\nincreaseKey```\n, and each of those methods calls only one - ```\nsink```\n or ```\nswim```\n, accordingly. Your code has those 2 methods combined into 1, that's why it calls both ```\nsink```\n and ```\nswim```\n. When the new key is higher than the old key that means it needs to go up in a heap (```\nswim```\n) and when the new key is lower than the old key it needs to go down (```\nsink```\n).\n\nBTW my whole post is assuming we are working with maximum heap - that means that the root node has maximum value and his children have smaller value etc. There is also a minimum heap which is an exact opposite.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Multiway using priority queue\r\n                \r\nThis is an example in Sedgewick; Wayne: Algorithms 4th edition. But I can't figure it out. Please Help!\n\nHere is the code:\n\n```\npackage algorithm2_4;\n\nimport chap1.*;\n\npublic class Multiway {\nprivate Multiway() {\n}\n\nprivate static void merge(In[] streams) {\n    int n = streams.length;\n    IndexMinPQ<String> pq = new IndexMinPQ<String>(n);\n    for (int i = 0; i < n; i++)\n        if (!streams[i].isEmpty())\n            pq.insert(i, streams[i].readString());\n    while (!pq.isEmpty()) {\n        StdOut.print(pq.minKey() + \" \");\n        int i = pq.delMin();\n        if (!streams[i].isEmpty())\n            pq.insert(i, streams[i].readString());\n    }\n    StdOut.println();\n}\n\n/**\n * Reads sorted text files specified as command-line arguments; merges them\n * together into a sorted output; and writes the results to standard output.\n * Note: this client does not check that the input files are sorted.\n *\n * @param args\n *            the command-line arguments\n */\npublic static void main(String[] args) {\n    int n = args.length;\n    In[] streams = new In[n];\n    for (int i = 0; i < n; i++)\n        streams[i] = new In(args[i]);\n    merge(streams);\n}\n}\n```\n\n\nif\n%more m1.txt\nA C D E\n%more m2.txt\nB S Z\nthen\n%java Multiway m1.txt m2.txt\nA B C D E S Z\n\nBy the way, ```\nIndexMinPQ```\n is a heap-based implementation of the ```\nIndexMinPQ```\n API below.\nI don't quite understand why the code above can merge several sorted lists to one.\nCan someone explain it to me?\n\n\n  ```\n   class IndexMinPQ<Item extends Comparable<Item>>```\n  \n  \n  \n  \n  ```\n         IndexMinPQ(int maxN)     ```\ncreate a priority queue of capacity ```\nmaxN```\n\n  ```\n                                  ```\nwith possible indices between ```\n0```\n and ```\nmaxN-1```\n\n  ```\n    void insert(int k, Item item) ```\ninsert ```\nitem```\n; associate it with ```\nk```\n\n  ```\n    void change(int k, Item item) ```\nchange the item associated with ```\nk```\n to ```\nitem```\n\n  ```\n boolean contains(int k)          ```\nis ```\nk```\n associated with some item?\n  ```\n    void delete(int k)            ```\nremove ```\nk```\n and its associated item\n  ```\n    Item min()                    ```\nreturn a minimal item\n  ```\n     int minIndex()               ```\nreturn a minimal item's index\n  ```\n     int delMin()                 ```\nremove a minimal item and return its index\n  ```\n boolean isEmpty()                ```\nis the priority queue empty?\n  ```\n     int size()                   ```\nnumber of items in the priority queue  \n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Doesn't Recognize __cmp__ Function In Python\r\n                \r\nI am attempting to implement a priority queue in Python. I am following an example that I found online. The ```\nSkill```\n class overrides the ```\n__cmp__```\n method so that the priority queue can order itself. I am getting a error when I run:\n\n```\nTypeError: unorderable types: Skill() < Skill()\n```\n\n\nI've found several examples online that say as long as you overload the ```\n__cmp__()```\n method the priority queue should be good.\n\n```\ntry:\n    import Queue as Q  # ver. < 3.0\nexcept ImportError:\n    import queue as Q\n\nclass Skill(object):\n    def __init__(self, priority, description):\n        self.priority = priority\n        self.description = description\n        print ('New Level:', description)\n        return\n    def __cmp__(self, other):\n        return cmp(self.priority, other.priority)\n\nq = Q.PriorityQueue()\n\nq.put(Skill(5, 'Proficient'))\nq.put(Skill(10, 'Expert'))\nq.put(Skill(1, 'Novice'))\n\nwhile not q.empty():\n    next_level = q.get()\n    print ('Processing level:', next_level.description)\n```\n\n\nI'm currently running Python 3.4.1 on my computer.\n    ", "Answer": "\r\n```\n__cmp__```\n was removed in Python3, you should use the rich comparison dunder methods instead ```\n__lt__```\n, ```\n__le__```\n, ```\n__eq__```\n, ```\n__ne__```\n, ```\n__gt__```\n, ```\n__ge__```\n.\n\nThey work as follows:\n\n```\na < b  # a.__lt__(b)\na <= b # a.__le__(b)\na == b # a.__eq__(b)\na != b # a.__ne__(b)\na > b  # a.__gt__(b)\na >= b # a.__ge__(b)\n```\n\n\nYou can also use the the class decorator ```\nfunctools.total_ordering```\n which allows you to specify ```\n__eq__```\n and any one of ```\n__lt__, __le__, __gt__, __ge__```\n and it will infer the rest of the rich comparison methods.\n\n```\nimport functools\n\n@functools.total_ordering\nclass NewNumber(object):\n    def __init__(self, num):\n        self.num = num\n    def __lt__(self, other):\n        return self.num < getattr(other, 'num', other)\n        # fancy way of doing self.num < other.num if other.num exists,\n        #   else to do self.num < other\n    def __eq__(self, other):\n        return self.num == getattr(other, 'num', other)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "A lock-free priority queue in C#\r\n                \r\nI have been searching lately for information on how to construct a lock-free priority queue in C#. I have yet to even find an implementation in any language, or a decent paper on the matter. I have found several papers which appear to be copies or at least referencing one particular paper which is not actually a paper on lock free priority queues, despite its name; it is in fact a paper on a priority queue which uses fine grained locks.\n\nThe responses I have been receiving from elsewhere include \"use a single thread\" and \"you do not need it to be lock free\" and \"it is impossible\". All three of these responses are incorrect.\n\nIf someone has some information on this, I would greatly appreciate it.\n    ", "Answer": "\r\nGenerally, it's a bad idea to write this kind of code yourself.\nHowever, if you really want to write this kind of code, I say take a page from Eric Lippert's book (or blog, as it were) (web archive link), where basically, you would implement the queue but instead of having all the functions that make modifications on the queue modify the instance you call the method on, the methods return completely new instances of the queue.\nThis is semantically similar to the pattern that ```\nSystem.String```\n uses to maintain immutability; all operations return a new ```\nSystem.String```\n, the original is not modified.\nThe result of this is that you are forced to reassign the reference returned on every call.  Because the assignments of references are atomic operations, there is no concern about thread-safety; you are guaranteed that the reads/writes will be atomic.\nHowever, this will result in a last-in-wins situation; it's possible that multiple modifications are being made to the queue, but only the last assignment will hold, losing the other insertions into the queue.\nThis might be acceptable; if not, you have to use synchronization around the assignment and reading of the reference.  You will still have a lock-free-priority queue, but if you have concerns about thread-safety and maintaining the integrity of the operations, you have done nothing but move the concern about synchronization outside of the data structure (which is almost all cases, is a good thing, as it gives you fine-grained explicit control).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Not Sorting\r\n                \r\nIm trying to implement my own Huffman Coding algorithm and the priority queue for the C++ STL does not seem to be working correctly. I am taking characters from a string and inserting them into a priority queue by order of their frequency in the string. The code compiles and runs without error, the only thing is the tree seems to not be sorting correctly. Here is the code, \n\n```\nclass Node {\n public:\n  int freq;\n  char data;\n  Node(int &f, char &d) { freq=f; data=d; }\n  bool operator<(const Node* &n) const { return n->freq < this->freq; }\n};\n\nvoid Init(priority_queue<Node*> &tree, string input) {\n map<char,int> probability;\n for(int i=0 ; i<input.size() ; i++) {\n   probability[input[i]]++;\n }\n map<char,int>::iterator it = probability.begin();\n for(it ; it != probability.end() ; it++) {\n   Node* blah = new Node(it->second, (char&) it->first);\n   tree.push(blah);\n }\n```\n\n\n}\n\nwhat am I doing wrong?\n\nThanks\n    ", "Answer": "\r\nYou are storing pointers in the ```\npriority_queue```\n, so the elements are sorted by pointer value, not using your ```\noperator<```\n overload.\n\nYou either need to store ```\nNode```\n objects in the priority queue, or you need to write a custom comparison function for the priority queue that dereferences the stored pointers and compares the ```\nNode```\n objects they point to.\n\nSince you ask \"what am I doing wrong?,\" here are some other suggestions:\n\n\nYour ```\noperator<```\n overload should take a const reference, not a reference to a pointer.\nYour ```\nNode```\n constructor should take its parameters by value, or at the very least by const reference.  The cast ```\n(char&)it->first```\n is not good.  Let ```\nconst```\n help you write good code, don't fight against it.\nYou probably should store ```\nNode```\n objects directly in the priority queue, not pointers.\nYou are using ```\nusing namespace std```\n somewhere; you should remove this and spell out ```\nstd::```\n wherever you need to.  \n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a priority queue using the field of a class in java\r\n                \r\nI have a java class called ```\nMeterReading```\n with two fields ```\nString MeterName```\n and ```\nint MeterLevel```\n.\n\nNow, if the ```\nMeterLevel```\n is between 0 and 3, that is Low, when between 3 and 6, Medium and from 6 above is High. How would I pass in that class ```\nMeterReading```\n to a priority queue? Is this possible?\n    ", "Answer": "\r\nYou have to implements ```\nComparable```\n interface of your class. The trick is adding a method to get the ```\nlevelClass```\n (LOW, MEDIUM, HIGH) that is used in the ```\ncompareTo```\n method.\n\n```\npublic class MeterReading implements Comparable {\n    public static final int LOW = 0;\n    public static final int MEDIUM = 1;\n    public static final int HIGH = 2;\n\n    private String name;\n    private double level;\n\n    ... // Constructor, getter setter and business logic methods\n\n    public int getLevelClass() {\n        if (level < 3) {\n            return LOW;\n        } else if (level < 6) {\n            return MEDIUM;\n        } else {\n            return HIGH;\n        }\n    }\n\n    public int compareTo(MeterReading m2) {\n        return getLevelClass() - m2.getLevelClass();\n    }\n}\n```\n\n\nThe implementation of ```\ncompareTo```\n can be also the following if you need the opposite priority. \n\n```\npublic int compareTo(MeterReading m2) {\n    return m2.getLevelClass() - getLevelClass();\n}\n```\n\n\nTo add a ```\nMeterReading```\n to a ```\nPriorityQueue```\n only add it\n\n```\nMeterReading mr = ....;\nPriorityQueue pq = ....;\n....\npq.add(mr);\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why do priority queues mostly use 0 as the most important priority?\r\n                \r\nWhy are most priority/heap queues implemented as 0 being the highest priority? I'm assuming I'm missing out some key mathematical principle. As I was implementing my own priority queue recently it seemed easier to write the insert function if priority went up with the integer value, but apparently people smarter than me think it should go the other way.\n\nAny ideas?\n    ", "Answer": "\r\nMost priority queues are implemented as a fibonacci heap or something similar. That data structure supports extracting the minimum in constant time, which makes it natural to make 0 the highest priority, and take elements out of the queue by extracting the minimum.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "In Java Priority Queue implementation remove at method, why it does a sift up after a sift down?\r\n                \r\nI have been reading Java collection API, the priority queue part, which is implemented by Josh Bloch and Doug Lea, the two maestros' work.\n\nThe Java ```\nPriorityQueue```\n is implemented with array heap. \n\nThe code snippets are here , from ```\nPriorityQueue.java```\n, Line 600：\n\n```\n/**\n * Removes the ith element from queue.\n *\n * Normally this method leaves the elements at up to i-1,\n * inclusive, untouched.  Under these circumstances, it returns\n * null.  Occasionally, in order to maintain the heap invariant,\n * it must swap a later element of the list with one earlier than\n * i.  Under these circumstances, this method returns the element\n * that was previously at the end of the list and is now at some\n * position before i. This fact is used by iterator.remove so as to\n * avoid missing traversing elements.\n*/\n\nprivate E removeAt(int i) {\n        // assert i >= 0 && i < size;\n        modCount++;\n        int s = --size;\n       if (s == i) // removed last element\n            queue[i] = null;\n        else {\n            E moved = (E) queue[s];\n            queue[s] = null;\n            siftDown(i, moved);\n            //the code I am asking is below:\n            if (queue[i] == moved) {\n               siftUp(i, moved);\n                if (queue[i] != moved)\n                    return moved;\n            }\n        }\n        return null;\n    }\n```\n\n\nWhat I am wondered is that, the moved element, which used to be at the bottom of the heap, should be a large one of the sub tree from ```\ni```\n. The ```\nsiftDown```\n method is reasonable, after a ```\nsiftDown```\n, the smallest of the subtree will be lifted to the position ```\ni```\n.\n\nThe question is, if the ```\ni```\n does not change, i.e. the moved is still there after ```\nsiftDown```\n, it seems to me that the sub tree has already been heapified, it does not need to be ```\nsiftUp```\n again. \n\nWhy Josh lift them up again to the top?\n\nHope those who has read the code helps!\n    ", "Answer": "\r\nThe problem is that the moved item (the item at ```\nqueue[size-1]```\n) might not be in the same subtree as the item that was removed. Consider this heap:\n\n```\n      0\n  4       1\n5   6   2   3\n```\n\n\nNow if you remove the node 5 you have:\n\n```\n      0\n  4       1\n    6   2   3\n```\n\n\nYou take the last node in the heap, 3, and put it in the place where 5 was:\n\n```\n      0\n  4       1\n3   6   2   \n```\n\n\nYou sift 3 down, but it's already a leaf. It's potentially out of place. You have to sift it up to obtain:\n\n```\n      0\n  3       1\n4   6   2   \n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Two different definitions of a priority queue?\r\n                \r\nI don't understand if both of the following definitions of a priority queue are correct:\n\n1.\n\n-ascending priority queue - elements are inserted arbitrarily, but after deletion, the smallest element is removed (assuming that data is an integer).\n\n-descending priority queue - elements are inserted arbitrarily, but after deletion, the largest element is removed (assuming that data is an integer).\n\nExamples for each:\n\n```\n5 15 10 -> after dequeue() -> 15 10\n15 5 10 -> after dequeue() -> 5 10\n```\n\n\n2.\n\nEvery element of priority queue has a priority by which deletion is done.\nThere can be two cases. First, element with the highest priority is removed. Second, element with the lowest priority is removed.\n\nClearly, this is different from the first definition. If we assign priorities ```\n6,3,12```\n to numbers ```\n15, 10, 5```\n, then after ```\ndequeue()```\n operation there are two cases. If element with the lowest priority is removed, then the queue is ```\n15,5 (10 is removed)```\n.  If element with the highest priority is removed, then the queue is ```\n15,10 (5 is removed)```\n. \n\nAlso, if element of a queue aren't numbers (strings, for example), then the first definition is useless.\n\nIs that correct?\n\nQuestion: Are both definitions correct? It seems to me that the first is only usable for numbers but even then it violates the priority from the second definition. Could someone explain this?\n\nHere are two implementations for both definitions in C:\n\n```\n           //1. DEFINITION//\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#define MAX 6\n\nint intArray[MAX];\nint itemCount = 0;\n\nint peek(){\n   return intArray[itemCount - 1];\n}\n\nbool isEmpty(){\n   return itemCount == 0;\n}\n\nbool isFull(){\n   return itemCount == MAX;\n}\n\nint size(){\n   return itemCount;\n}\n\nvoid insert(int data){\n   int i = 0;\n\n   if(!isFull()){\n      // if queue is empty, insert the data\n      if(itemCount == 0){\n         intArray[itemCount++] = data;\n      }else{\n         // start from the right end of the queue\n\n         for(i = itemCount - 1; i >= 0; i-- ){\n            // if data is larger, shift existing item to right end\n            if(data > intArray[i]){\n               intArray[i+1] = intArray[i];\n            }else{\n               break;\n            }\n         }\n\n         // insert the data\n         intArray[i+1] = data;\n         itemCount++;\n      }\n   }\n}\n\nint removeData(){\n   return intArray[--itemCount];\n}\n\nint main() {\n\n   insert(3);\n   insert(5);\n   insert(9);\n   insert(1);\n   insert(12);\n\n   int num = removeData();\n   printf(\"Element removed: %d\\n\",num);\n\n   return 0; \n}\n\n             //2. DEFINITION//\n\n#include<stdio.h>\n#include<stdlib.h>\n#define SIZE 5            /* Size of Queue */\nint f=0,r=-1;       /* Global declarations */\ntypedef struct PRQ\n{\n    int ele;\n    int pr;\n}PriorityQ;\n\nPriorityQ PQ[SIZE];\n\nPQinsert(int elem, int pre)\n{\n    int i;       /* Function for Insert operation */\n    if( Qfull()) printf(\"\\n\\n Overflow!!!!\\n\\n\");\n    else\n    {\n        i=r;\n        ++r;\n        while(PQ[i].pr >= pre && i >= 0) /* Find location for new elem */\n        {\n            PQ[i+1]=PQ[i];\n            i--;\n        }\n        PQ[i+1].ele=elem;\n        PQ[i+1].pr=pre;\n    }\n}\n\nPriorityQ PQdelete()\n{                      /* Function for Delete operation */\n    PriorityQ p;\n    if(Qempty()){ printf(\"\\n\\nUnderflow!!!!\\n\\n\");\n    p.ele=-1;p.pr=-1;\n    return(p); }\n    else\n    {\n        p=PQ[f];\n        f=f+1;\n        return(p);\n    }\n}\nint Qfull()\n{                     /* Function to Check Queue Full */\n    if(r==SIZE-1) return 1;\n    return 0;\n}\n\nint Qempty()\n{                    /* Function to Check Queue Empty */\n    if(f > r) return 1;\n    return 0;\n}\n\ndisplay()\n{                  /* Function to display status of Queue */\n    int i;\n    if(Qempty()) printf(\" \\n Empty Queue\\n\");\n    else\n    {\n        printf(\"Front->\");\n        for(i=f;i<=r;i++)\n            printf(\"[%d,%d] \",PQ[i].ele,PQ[i].pr);\n        printf(\"<-Rear\");\n    }\n}\n\nmain()\n{                         /* Main Program */\n    int opn;\n    PriorityQ p;\n    do\n    {\n        printf(\"\\n ### Priority Queue Operations(DSC order) ### \\n\\n\");\n        printf(\"\\n Press 1-Insert, 2-Delete,3-Display,4-Exit\\n\");\n        printf(\"\\n Your option ? \");\n        scanf(\"%d\",&opn);\n        switch(opn)\n        {\n        case 1: printf(\"\\n\\nRead the element and its Priority?\");\n            scanf(\"%d%d\",&p.ele,&p.pr);\n            PQinsert(p.ele,p.pr); break;\n        case 2: p=PQdelete();\n            if( p.ele != -1)\n                printf(\"\\n\\nDeleted Element is %d \\n\",p.ele);\n            break;\n        case 3: printf(\"\\n\\nStatus of Queue\\n\\n\");\n            display(); break;\n        case 4: printf(\"\\n\\n Terminating \\n\\n\"); break;\n        default: printf(\"\\n\\nInvalid Option !!! Try Again !! \\n\\n\");\n            break;\n        }\n        printf(\"\\n\\n\\n\\n  Press a Key to Continue . . . \");\n        getch();\n    }while(opn != 4);\n}\n```\n\n    ", "Answer": "\r\nA priority queue is a data structure holding elements (like any data structure) as well as their priority. This is your second definition.\n\nHowever, in some cases, the elements actually represent their own priority. This is your first definition : sometimes, you just need to store a bunch of unordered numbers and retrieve them in order. Note that in this case, elements are not necessarily numbers. Other data types might have a property that can be used as priority.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Sorted Array Priority Queue\r\n                \r\nI am implementing a sorted array priority queue and sorting upon insert. For some reason, the queue is not coming out completely sorted. Am I implementing it correctly so far and how can i fix it from here?\n\n```\nvoid insertInt(int numToIns)\n{\n    if (total == 0)\n    {\n        q[0] = numToIns;\n        minimum = numToIns;\n    }\n    else if (total != 0)\n    {\n        if (numToIns <= minimum)\n        {\n            minimum = numToIns;\n            for (int move = total; move >= 0; --move)\n            {\n                q[move + 1] = q[move];\n            }\n            q[0] = numToIns;\n        }\n        else if (numToIns < q[total])\n        {\n            bool numFound = false;\n            for (int j = 0; numFound != true; ++j)\n            {\n                if (numToIns <= q[j])\n                {\n                    numFound = true;\n                    for (int move = total; move >= j; --move)\n                    {\n                        q[move + 1] = q[move];\n                    }\n                    q[j] = numToIns;\n                }\n            }\n\n        }\n        else if (numToIns >= q[total - 1])\n        {\n            q[total] = numToIns;\n        }\n    }\n    ++total;\n}\n```\n\n    ", "Answer": "\r\nNot sure what your current code looks like, but that should do it:\n```\n#include <ctime>\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n\nstd::size_t total;\nint q[100];\nint minimum;\n\nvoid print()\n{\n    for (std::size_t i{}; i < total; ++i)\n        std::cout << q[i] << ' ';\n    std::cout.put('\\n');\n}\n\nvoid insertInt(int numToIns)\n{\n    if (total == 0)\n    {\n        q[0] = numToIns;\n        minimum = numToIns;\n    }\n    else if (total != 0)\n    {\n        if (numToIns <= minimum)\n        {\n            minimum = numToIns;\n            for (std::size_t move{ total }; move >= 0; --move)\n            {\n                q[move + 1] = q[move];\n            }\n            q[0] = numToIns;\n        }\n        else if (numToIns < q[total - 1])\n        {\n            bool numFound = false;\n            for (std::size_t j{}; !numFound; ++j)\n            {\n                if (numToIns <= q[j])\n                {\n                    numFound = true;\n                    for (std::size_t move{ total - 1 }; move >= j; --move)\n                    {\n                        q[move + 1] = q[move];\n                    }\n                    q[j] = numToIns;\n                }\n            }\n\n        }\n        else if (numToIns >= q[total - 1])\n        {\n            q[total] = numToIns;\n        }\n    }\n    ++total;\n}\n\nint main()\n{\n    std::srand(static_cast<unsigned>(std::time(nullptr)));\n\n    for (int i{}; i < 20; ++i) {\n        insertInt(std::rand() % 20 + 1);\n        print();\n    }\n}\n```\n\nNote that three kitties died because of me writing that code :(\nNo bs version:\n```\nvoid insertInt(int num)\n{\n    std::size_t pos{};\n    while (pos < total && num > q[pos])\n        ++pos;\n\n    for (std::size_t k{ total }; k > pos; --k)\n        q[k] = q[k - 1];\n\n    q[pos] = num;\n    ++total;\n}\n```\n\nTo avoid going through the array if the number to be inserted is bigger than the last element one could add one special case:\n```\nvoid insertInt(int num)\n{\n    if (num > q[total - 1]) {\n        q[total++] = num;\n        return;\n    }\n\n    std::size_t pos{};\n    while (pos < total && num > q[pos])\n        ++pos;\n\n    for (std::size_t k{ total }; k > pos; --k)\n        q[k] = q[k - 1];\n\n    q[pos] = num;\n    ++total;\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "c++ ordered(stable) priority queue\r\n                \r\nI am implementing a toy scheduler which reads a input file of process specifications such as arrival time, total run time and then schedules the process based on random io/cpu bursts.\nThe file is of the format\n\nArrival time, total CPU time, CPU burst, IO Burst.\n\nNow, when there are two process with same arrival time, the scheduler have to schedule the process first the process which is mentioned first in the file.\nI am keeping the entries in the file in a priority queue.\n```\nstruct EventComparator{\n  bool operator()(const Event* event1, const Event* event2){\n    return event1->getTimestamp() >= event2->getTimestamp();\n  }   \n};  \npriority_queue<Event*, vector<Event*>, EventComparator> eventQueue;\n```\n\nwhere Event is just an object encapsulating the process parameters.\nMy problem is, the priority queue is not stable.  By stable I mean that the order of the process gets reversed.\nSuppose the input file has\n\n60 200  5   20\n60  20  10  10\n40 100  10  40\n0  200  40  90\n\nIf i pop from the priority queue, I expect Line4, line 3, Line1 and then Line2.  But I get Line4, Line3, Line2, Line1.\nMy question is, what can I do to get a stable priority queue?\n    ", "Answer": "\r\n\nYour comparator is incorrect. The documentation for the ```\nstd::priority_queue```\n states that it should provide a strict weak ordering(that is, it should ```\nevent1->getTimestamp() > event2->getTimestamp()```\n, not ```\n>=```\n).\nTo make it stable, you can just store the line number inside the ```\nEvent```\n and compare it if ```\nevent1->getTimestamp() == event2->getTimestamp()```\n.\n\n\nSomething like this:\n\n```\nstruct EventComparator {\n  bool operator()(const Event* event1, const Event* event2) {\n    if (event1->getTimestamp() != event2->getTimestamp()) {\n      return event1->getTimestamp() > event2->getTimestamp();\n    }\n    return event1->getLineNumber() > event2->getLineNumber();\n  }   \n};  \n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Random access priority queue\r\n                \r\nContinuing List to priority queue\n\nI'm implementing a improved priority_queue with random access.\n\n```\ntemplate <class T, class Container = std::vector<T> >\nclass Heap {\npublic:\n    Heap() {}\n\n    Heap(const Container& container) {\n        container_ = container;\n        std::make_heap(container_.begin(), container_.end());\n    }\n\n    Heap<T, Container>& operator=(const Heap<T, Container>& heap) {\n        if (this != &heap)\n            container_ = heap.container_;\n\n        return *this;\n    }\n\n    void push(const T& x) {\n        container_.push_back(x);\n        std::push_heap(container_.begin(), container_.end());\n    }\n\n    void pop() {\n        std::pop_heap(container_.begin(), container_.end());\n        container_.pop_back();\n    }\n\n    const T& top() {\n        return container_.front();\n    }\n\n    const Container& getContainer() const {\n        return container_;\n    }\n\n    T& operator[](size_t n) {\n        return container_[n];\n    }\n\n    typename Container::const_iterator begin() const {\n        return container_.begin();\n    }\n\n    typename Container::const_iterator end() const {\n        return container_.end();\n    }\n\n    size_t size() const {\n        return container_.size();\n    }\n\n    T& base() {\n        return container_.back();\n    }\n\n    Container::iterator erase(Container::iterator position) {\n        return container_.erase(position);\n    }\n\nprivate:\n    Container container_;\n};\n```\n\n\nAm I taking the right way?\n\n\nFixed the unary constructor.\nImproved code.\n\n    ", "Answer": "\r\nDoesn't look that great to me:\n\n\nThe unary constructor should take argument by const reference.\nThe assignment operator doesn't check for self-assignment.\nThe ```\ngetContainer()```\n method shows a lack of clarity in the interface - why would you simply expose the implementation detail like that?\nMost importantly: why do you want a \"random access priority queue\"?\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement Unmonopoly game using priority queues?\r\n                \r\nA group of children wants to play a game, called UnMonopoly , wherein each turn the player with the most money must give half of his/her money to the player with the least amount of money. After the turns are completed announce the person with the highest money as WINNER. Implement this game by taking the number of turns and players. (Hint: Use Priority queues)\n\nSample Input:\n\nNumber of players: n\n\nNumber of turns: m\n\nEnter each player details and money\n\nOutput:\n\nWinner is: Player Name\n\nThis is my question, I have written a code. Is this a correct way to implement or are there any flaws in it. Is there a better implementation with smaller time complexity?\n\nHere is my code,\n\n```\nimport java.util.*;\n\nclass Player implements Comparator<Player> {\n\n    String name;\n    int money;\n    Player(String name, int m) {\n        this.name = name;\n        money = m;\n    }\n    public Player() {\n        this.money = 0;\n        this.name = null;\n    }\n\n    public String toString() {\n        return \"NAME: \"+name+\"\\nMONEY: \"+money;\n    }\n\n    public int compare(Player p1, Player p2) {\n        return p2.money - p1.money;\n    }\n}\n\npublic class Unmonopoly {\n\n    public static void main(String[] args) {\n\n        Player pl = new Player();\n        Stack<Player> pla = new Stack<Player>();\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter the number of players: \");\n        int n = sc.nextInt();\n\n        PriorityQueue<Player> play = new PriorityQueue<Player>(n,pl);\n        System.out.println(\"Enter player details: \");\n\n        for(int i = 0; i < n; i++) {\n            Player p = new Player(sc.next(),sc.nextInt());\n            play.add(p);\n        }\n\n        for(Player p: play) {\n            System.out.println(\"Name: \"+p.name+\"\\nMoney: \"+p.money);\n        }\n\n        System.out.println(\"\\nEnter the number of turns: \");\n        int turns = sc.nextInt();\n        for(int i = 0; i < turns; i++) {\n            Player max = play.peek();\n            max.money = max.money / 2;\n            while(!play.isEmpty()) {\n                pla.push(play.peek());\n                play.remove();\n            }\n            Player min = pla.pop();\n            pla.push(min);\n            System.out.println(\"Player with min money is: \\n\"+min);\n            min.money = min.money + max.money;\n            while(!pla.isEmpty()) {\n                play.add(pla.peek());\n                pla.pop();\n            }\n        }\n        sc.close();\n        System.out.println(\"**************WINNER************** \\n\\n\\tNAME:   \"+play.peek().name+\"\\n\\tMONEY:  \"+play.peek().money);\n    }\n}\n```\n\n    ", "Answer": "\r\nYour complexity is O(N * M * log(N)), because you recreate the priority queue each turn. \n\nNot sure how valid the hint is, as you need both the minimum and the maximum player each turn, so a better data structure might be a TreeSet - it allows you to get straight to both the minimum and maximum. The complexity would then be O(M * log(N))..\n\nThe main loop in such a case would simply be:\n\n```\nfor (int i = 0; i < turns; i++) {\n    Player min = players.pollFirst();\n    Player max = players.pollLast();\n\n    min.money += max.money / 2;\n    max.money -= max.money / 2;\n\n    players.add(min);\n    players.add(max);\n}\n```\n\n\nBoth ```\npoll```\n operations as well as ```\nadd```\n are O(log(N))..\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is it possible to implement a min-priority queue with a heap, or is binary heap needed?\r\n                \r\nFor my assignment, I have been working on a satnav system and I am using an adjacency list to store all of the mapping data.\n\nI therefor want to implement dijkstras algorithm for my path planning functions but I need to first implement a min-priority queue. Is is possible to do this using a regular heap, or is a binary one needed?\n    ", "Answer": "\r\nIt seems you mean ```\nregular heap```\n as memory region used for dynamic memory allocation. This term has no relation to the term ```\nheap```\n as data structure (binary heap is particular case), which represents a set of values, ordered in specific manner\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing \"idle\" and \"normal\" priority queues for long-running tasks in Celery\r\n                \r\nI'm attempting to implement a following scenario with Celery: two queues of (same) long-running tasks, one for \"normal\" and the other for \"idle\" priority.\n\nI'd make the workers monitor both queues and take tasks from the \"normal\" priority queue first and if it's empty, it'd take tasks from the \"idle\" priority.\n\nMy question is: Is it possible to guarantee the order in which the workers will check their tasks queues? Also, is this the right approach for implementing priorities?\n\nBackground: The tasks are running ffmpeg transcoding jobs. The \"normal\" priority ones would be new videos coming in (which have to be transcoded ASAP) and the \"idle\" priority would be the tasks to re-transcode old (40.000+ video) archive to updated format settings. I do not have several servers available to do multi-server task dispatching.\n    ", "Answer": "\r\nUnder the theory that idle workers are not consuming much system resources, I have implemented two priorities with a second exchange, a second set of queues, and a second set of workers. I don't have such intensive work processes so I don't make my second set of workers throttle themselves when the first set is active, but possible the UNIX renice command would work for this.\n\nYou could probably also do something with a control queue so that it is not sufficient for workers to receive a work request, they also need to get a token from a control queue. Then you spit out a small number of tokens to the idle control queue but a larger number of tokens to the normal control queue.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "concurrent priority queue using message passing?\r\n                \r\nIs there any concurrent algorithms that implement a priority queue using message passing? The functionality of priority queue is naturally sequential, in order to enable it across multiple processors, one has to take care of the entity locks during insert/delete operations. That said, the insert/delete queries are coming from different processors, and they are feed to the same priority queue. To my knowledge, a classical algorithm to do this is using Skip_list [1], which requires shared memory in the hindsight. \n\nHowever, I am particularly interested to see if there are any message passing solutions to concurrent priority queue. \n\n[1]  Pugh, W. (1990). \"Skip lists: A probabilistic alternative to balanced trees\". Communications of the ACM 33 (6): 668. doi:10.1145/78973.78977\nftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Change the priority in a custom priority queue\r\n                \r\nI followed the directions given in this question (the answer by Jason) in order to write my ```\nPriorityQueue<T>```\n using a ```\nSortedList```\n. I understand that the ```\ncount```\n field within this class is used to ensure unique priorities and to preserve the enqueue order among the same priority.\n\nHowever, when ```\ncount```\n reaches its maximum value and I sum 1 to it, the latter will starts again from 0, so the priority of the subsequent items would be higher than the priority of the previous items. Using this approach I could need for a way to \"securely\" reset the counter ```\ncount```\n... In fact, suppose to have the following queue state (in the format priority | count | item):\n\n0 | 123 | A\n 0 | 345 | B\n 1 | 234 | C\n 2 | 200 | D   \n\nNow suppose the counter limit has reached, so I have to reset it to 0: as a consequence, the next inserted item will have counter 0: for example, if I insert an element with priority equal to 1, it will be wrongly inserted before 1 | 234 | D\n\n0 | 123 | A\n 0 | 345 | B\n 1 | 000 | new element\n 1 | 234 | C\n 2 | 200 | D   \n\nThe problem of the priority can be solved by implementing an heap: I created an ```\nHeap```\n class, then I used ```\nHeap<KeyValuePair<TPriority, TElement>```\n and a custom ```\nPriorityComparer```\n in order to sort elements by ```\nTPriority```\n.\nGiven TPriority as an ```\nint```\n and TElement as a ```\nstring```\n, the ```\nPriorityComparer```\n is as follows:\n\n```\npublic class MyComparer : IComparer<KeyValuePair<int, string>>\n{\n    public int Compare(KeyValuePair<int, string> x, KeyValuePair<int, string> y)\n    {\n        return x.Key.CompareTo(y.Key);\n    }\n}\n\n...\n\nint capacity = 10;\nHeap<KeyValuePair<int, string>> queue;\nqueue = new Heap<KeyValuePair<int, string>>(capacity, new PriorityComparer());\n\n...\n```\n\n\nUPDATE\nIn this way (using the ```\nPriorityComparer```\n), I have succeeded to implement a priority queue.\nNow I'd like to add support to modify its behavior at runtime, ie switch from FIFO to priority sorting and vice-versa. Since my implementation of priority queue has an ```\nIComparer```\n field, I think it is sufficient to add a ```\nComparer```\n property to edit this field, like as follows:\n\n```\npublic IComparer\n{\n    set\n    {\n        this._comparer = value;\n    }\n}\n```\n\n\nIn the meantime I thought I'd take a different approach: instead of using a binary heap to manage priorities, I could wrap different queues (each queue refers to a given priority) as follows.\n\n```\npublic class PriorityQueue<T, int>\n{\n    private Queue<T> _defaultQueue;\n    private bool _priority;\n    private SortedList<int, Queue<T>> _priorityQueues;\n\n    public PriorityQueue(int capacity)\n    {\n        this._defaultQueue = new Queue<T>(capacity);\n        this._priority = false;\n        this._priorityQueues = new SortedList<int, Queue<T>>(0);\n    }\n\n    public void PriorityEnable()\n    {\n        this._priority = true;\n    }\n\n    public void PriorityDisable()\n    {\n\n        this._priority = false;\n    }\n\n    public void Enqueue(T item)\n    {\n        if (this._priority)\n        {\n            // enqueue to one of the queues\n            // with associated priority\n            // ...\n        }\n        else this._defaultQueue.Enqueue(item);\n    }\n\n    public T Dequeue()\n    {\n        if (this._priority)\n        {\n            // dequeue from one of the queues\n            // with associated priority and\n            // return\n            // ...\n        }\n        return this._defaultQueue.Dequeue();\n    }\n}\n```\n\n\n\nHow to manage the transition from FIFO mode to priority mode when there are still elements in the default queue? I could copy them in the priority queues based on the item priority... Other better solutions?\nHow to manage the transition from priority mode to FIFO mode? In this case, I would have several priority queues, which may contain elements, but no longer have to manage them according to priority and not even know the original order of arrival...\nHow can I manage the capacity of the different queues?\nWhat about the performances of the above two solutions? Which does use more memory?\n\n    ", "Answer": "\r\nYou could \"cheat\" and use BigInteger so you never \"run out of numbers\". This of course leads to gradual deterioration of performance over time, but probably not significant enough to matter.\n\nCombine that with a heap-based priority queue and you are set!\n\n\n\nDon't try to \"switch from FIFO to priority sorting and vice-versa\" - simply put elements in both data structures appropriate for the task (Queue and priority queue).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a Dart priority queue (in descending order)\r\n                \r\nIn Dart, I would like to implement two priority queues, one in ascending order and one in descending order.\n\nThe SDK class ```\nSplayTreeMap```\n conveniently solves the ascending order case, i.e. I can use ```\nstm.values```\n to get the values in ascending order. Is there a way to get ```\nSplayTreeMap```\n to return the values in descending order? (apart from the obvious solution of sorting the values afterwards on every access). For example, is there a way to override the compare function of the value types?\n\nThanks in advance for any suggestions.\n    ", "Answer": "\r\nAnswering my own question, just passing 'inverse' keys solved the problem (at least for my use case).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Bounded Priority Queue Inheritance vs Composition\r\n                \r\nI want to write a Bounded Priority Queue class. This is essentially a priority queue but has a bound on the number of elements that can be there in the queue. So, if I insert a new element and the queue is full, then I see if the element is greater than the top of the queue. If yes, then I discard the new element. If no, then I remove the top element and insert this new element (and the queue gets automatically reorganized). I have currently implemented BoundedPriorityQueue as derived from PriorityQueue having a \"maxCount\" member and I have overridden the add method and added the functionality I described above. I am wondering if I should consider doing it the composition way rather than the inheritance way. My current approach seems simple though.\n\nIf I were to go for composition, then I have to derive from the AbstractQueue class, implement the methods and then compose the priority queue with it.\n\nThanks,\n\nVenk\n    ", "Answer": "\r\nin my opinion it is better to use composition. because, inheritance this way is the violation of Liskov substitution principle. derived types shouldn't replace base types' functionality.\nthis link will be useful: prefer composition over inheritance\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "concurrent priority queue using message passing?\r\n                \r\nIs there any concurrent algorithms that implement a priority queue using message passing? The functionality of priority queue is naturally sequential, in order to enable it across multiple processors, one has to take care of the entity locks during insert/delete operations. That said, the insert/delete queries are coming from different processors, and they are feed to the same priority queue. To my knowledge, a classical algorithm to do this is using Skip_list [1], which requires shared memory in the hindsight. \n\nHowever, I am particularly interested to see if there are any message passing solutions to concurrent priority queue. \n\n[1]  Pugh, W. (1990). \"Skip lists: A probabilistic alternative to balanced trees\". Communications of the ACM 33 (6): 668. doi:10.1145/78973.78977\nftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is there a way to check the priority in a priority queue in java?\r\n                \r\nI implemented various methods in a queue and then wanted to do the same for a priority queue, but is there a way to reach the attribute ```\npriority```\n?\nFor example in the method ```\nisInQueue```\n, this method should return true if the value and the priority received as argument are available is the priority queue.\n```\npublic boolean isInQueue(int value) {\n        PriorityQ q = new PriorityQ();\n        \n        if(this.isEmpty())\n            return false;\n        \n        while(!this.isEmpty()) {\n            if(this.queueFront() == value)\n                return true;\n            q.add(this.queueFront());\n            this.remove();\n            \n        }\n        \n        while(!q.isEmpty()) {\n            this.add(q.queueFront());\n            q.remove();\n        }\n        return false;\n    }\n```\n\nThis is the whole class:\n```\n\npublic class PriorityQ {\n    \n    class Element {\n        int data; // ELEMENT'S DATA\n        int priority; // ELEMENT’S PRIORITY\n        Element next; // REFERENCE TO THE NEXT ELEMENT\n        final static int DEFAULT_PRIORITY = 0;\n        \n        Element(int value, int priority) {\n            this.data = value;\n            this.priority = priority;\n            this.next = this;\n        }\n        \n        Element(int value) {\n        this(value, DEFAULT_PRIORITY);\n        }\n        \n    }\n    \n    \n    private Element queue = null;\n    \n    \n    public PriorityQ() {\n        this.queue = null;\n    }\n    \n    \n    public boolean isEmpty() {\n        return this.queue == null;\n    }\n    \n    \n    public void remove() {\n        if (this.isEmpty())\n            System.exit(0);\n        \n        if (this.queue.next == this.queue)\n            this.queue = null;\n        else\n            this.queue.next = this.queue.next.next;\n    }\n    \n    public int queueFront() {\n        if (this.isEmpty())\n            System.exit(0);\n        return this.queue.next.data;\n    }\n    \n    \n    public void add(int value, int priority) {\n        Element tmp = new Element(value, priority);\n        \n        // special case 1: Empty queue\n        if (this.isEmpty())\n            this.queue = tmp;\n        \n        // Special case 2: insert a high priority element\n        else if (tmp.priority > this.queue.priority) {\n            tmp.next = this.queue.next;\n            this.queue.next = tmp;\n            this.queue = tmp;\n        }\n        \n        // Special case 3: insert a low priority element\n        else if (tmp.priority <= this.queue.next.priority) {\n            tmp.next = this.queue.next;\n            this.queue.next = tmp;\n        }\n        \n        else { // insertion according to the priority\n            Element cur = queue.next;\n            \n        while (cur.next.priority < tmp.priority)\n            cur = cur.next;\n        tmp.next = cur.next;\n        cur.next = tmp;\n        if (cur == this.queue)\n            this.queue = this.queue.next;\n        }\n    }\n    \n    \n    public void add(int value) {\n        this.add(value, Element.DEFAULT_PRIORITY);\n    }\n    \n    \n    @Override\n    public String toString() {\n        String s = \" \";\n        if(this.isEmpty())\n            return\"Empty list\";\n        \n        Element cur = this.queue;\n        s = \" | \" + cur.data +  \" | \";\n        cur = cur.next;\n        while(cur != this.queue) {\n            s+= cur.data + \", \" + cur.priority + \" | \";\n            cur = cur.next;\n        }\n        return s;\n    }\n    \n    \n    public int search(int value, int p) {\n        PriorityQ q1 = new PriorityQ();\n        int index = -1;\n        int c = 0; //counter\n        \n        if(this.isEmpty()) {\n            System.out.println(\"the queue is empty\");\n            return -1;\n        }\n        \n        while(!this.isEmpty() && index == -1) {\n            if(this.queueFront() == value)\n                index = c;\n            q1.add(this.queueFront(), p);\n            this.remove();\n            c++;\n        }\n        \n        while(!q1.isEmpty()) {\n            this.add(q1.queueFront(), p);\n            q1.remove();\n        }\n        return index;\n    }\n    \n    \n    public boolean isInQueue(int value) {\n        PriorityQ q = new PriorityQ();\n        \n        if(this.isEmpty())\n            return false;\n        \n        while(!this.isEmpty()) {\n            if(this.queueFront() == value)\n                return true;\n            q.add(this.queueFront());\n            this.remove();\n            \n        }\n        \n        while(!q.isEmpty()) {\n            this.add(q.queueFront());\n            q.remove();\n        }\n        return false;\n    }\n        \n    \n\n    public static void main(String[] args) {\n        PriorityQ q = new PriorityQ();\n        \n        q.add(1, 1);\n        q.add(3, 4);\n        q.add(3, 3);\n        q.add(4, 1);\n        q.add(5, 0);\n        q.add(6, 8);\n        System.out.println(q);\n        \n        System.out.println(q.search(1, 1));\n        \n        System.out.println(q.queueFront());\n        \n        System.out.println(q.isInQueue(3));\n        \n    }\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Python heapq Priority Queue Maxheap\r\n                \r\nI understand that priority queues using heapq are implemented as a minheap. I need to make a priority queue implemented as a maxheap that sorts elements by an AWS datetime string. I want elements with the most recent datetime to be popped off of the queue first when I call the heapq.heappop() method. Everything online seems to point towards just using the minheap but making your values negative during input so that greater values are pushed to the top instead of the bottom. However, I can't seem to find any way to actually apply this to a datetime string like this '2021-06-03T16:11:14.206650Z'. Is there a way that I can make that string 'negative' or somehow make it so that more recent dates are popped from the heap first?\n    ", "Answer": "\r\nThere are several ways to approach this.\nOne is to convert the date/time to an ordinal, and negate that\n```\n-dateutil.parser.parse('2021-06-03T16:11:14.206650Z').toordinal()\n```\n\nIf you want to retain the original date string, then put this number in a tuple together with the date string.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is implicit data structure? And is heap an implicit data structure to implement priority queue?\r\n                \r\nMy question might seem childish but I really don't understand this question as I am just a newbie to data structures course. I do know how max and min heap work, but I am not sure that whether heap is implicit data structure to implement priority queue.\n    ", "Answer": "\r\nWikipedia is back up :D\n\nFrom the article:\n\n\n  In computer science, an implicit data structure is a data structure that uses very little memory besides the actual data elements...\n\n\nSo yes, a heap would fit the bill because it can be implemented as a simple array.  A heap that is implementing a priority queue would be an implicit data structure, but not because it's implementing a priority queue.  It's because heaps don't use anything special to keep track of its elements, only the array location.\n\nAlso, I completely disagree with your friend's interpretation.  There is no \"natural\" data structure for any problem, only ones that happen to be very convenient under the circumstances.  \n\nComputing and data structures are abstract ideas that can be implemented in many different ways.  A linked list can be implemented on the heap, on the hard drive, over the internet, and in the form of a bunch of people with sticky notes and the next person's phone number.  Calling the whole set of them a \"natural\" data structure to use for some particular problem is wrong.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue not inserting things by Priority\r\n                \r\nI'm trying to implement a Priority Queue with an Array-Based heap. So far my heap class looks like this\n\n```\npublic class ArrayHeap<E> \n{\n    private Node<E>[] data; //Array to hold nodes\n    private int capacity; //Length to make the array\n    private int dataCount; //Current number of elements\n\n    /**\n     * Constructor for heap\n     * @param passedCapacity\n     */\n    public ArrayHeap(int passedCapacity)\n    {\n        this.capacity = passedCapacity;\n        this.dataCount = 0;\n        data = new Node[capacity];\n    }\n\n    public void insert(Node<E> value) \n    {\n        data[dataCount] = value;\n        trickleUp(dataCount++);\n    }    \n\n    /**\n     * Method to slide inserted data to correct position.\n     * Based on Data Structures & Algorithms in Java, 2nd Edition (pg. 593)\n     */\n    private void trickleUp(int index)\n    {\n        int parent = index-1 / 2;\n        Node<E> bottom = data[index];\n        while(index > 0 && data[parent].getPriority() < bottom.getPriority())\n        {\n            data[index] = data[parent];\n            index = parent;\n            parent = (parent-1) / 2;\n        }\n        data[index] = bottom;\n    }\n\n    public E remove()\n    {\n        return null;\n    }\n\n    public void print()\n    {\n        for(int i = 0; i < dataCount; i++)\n        {\n            System.out.println(data[i].getPriority() + \": \" + data[i].getData());\n        }\n        System.out.println(\"Total nodes: \" + dataCount);\n    }\n}\n```\n\n\nand my priority queue looks like this\n\n```\npublic class PriorityQueue<E> implements PriQue<E>\n{\n    private ArrayHeap<E> data;\n\n    public PriorityQueue()\n    {\n        this.data = new ArrayHeap<E>(1000);\n    }\n\n    @Override\n    public void insert(int pri, E dataToInsert) {\n        Node<E> nodeToInsert = new Node<E>(pri, dataToInsert);\n        data.insert(nodeToInsert);\n    }\n\n    public void print()\n    {\n        data.print();\n    }\n}\n```\n\n\nHowever, when I insert a series of Nodes into the queue and spit them back out with my print statement they just come out in the same order they were inserted. I feel like something is wrong with my trickleUp method but cannot figure out what it is. \n    ", "Answer": "\r\nThe data in the array isn't supposed to be sorted. It's a heap. You have to successively remove an element and re-heapify one at a time to get a total ordering.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "I want to iterate through my priority queue in C#\r\n                \r\nI am implementing a generic priority queue in C# i used SortedDictionary for the priority keys and Queue for the values.\nNow i want to iterate through it with a foreach loop with a condition to skip over queue items with priority 0.\n\nThis is my priority queue class\n\n```\n      public class PQ<Tpriority, Titem>\n{\n    readonly SortedDictionary<Tpriority, Queue<Titem>> value;\n    public PQ(IComparer<Tpriority> priorityComparer)\n    {\n\n        value = new SortedDictionary<Tpriority, Queue<Titem>>(priorityComparer);\n\n\n    }\n    public PQ() : this(Comparer<Tpriority>.Default) { }\n\n    public bool Check{ get { return value.Any(); }}\n\n    public int Count\n    {\n        get { return value.Sum(q => q.Value.Count); }\n    }\n\n    public void Add(Tpriority priority, Titem item)\n    {\n        if (!value.ContainsKey(priority))\n        {\n            AddQueueOfPriority(priority);\n        }\n        value[priority].Enqueue(item);\n    }\n\n\n    private void AddQueueOfPriority(Tpriority priority)\n    {\n        value.Add(priority, new Queue<Titem>());\n    }\n\n    public Titem Next()\n    {\n        if (value.Any())\n            return Next_FHP();\n        else\n            throw new InvalidOperationException(\"The queue is empty\");\n    }\n\n    private Titem Next_FHP()\n    {\n        KeyValuePair<Tpriority, Queue<Titem>> first = value.First();\n        Titem nextItem = first.Value.Dequeue();\n        if (!first.Value.Any())\n        {\n            value.Remove(first.Key);\n        }\n        return nextItem;\n    }\n\n    public SortedDictionary<Tpriority, Queue<Titem>>.Enumerator GetEnumerator()\n    {\n        return value.GetEnumerator();\n    }\n}\n\npublic interface IEnumerator<Tpriority, Titem>{}\n```\n\n\nAnd this is my main program\nI was able to get all my needed actions to work fine just this\n\n```\n    static\n    void Main(string[] args)\n    {\n        var first = new PQ<int, string>();\n        first.Add(1, \"random1\");\n        first.Add(0, \"random2\");\n        first.Add(2, \"random3\");\n\n        while (first.Check)\n        {\n            Console.WriteLine(first.Next());\n        }\n        Console.WriteLine(first.Check);\n\n\n        /*it gives the error \"Can not convert\n        type 'System.Collections.Generic.KeyValuePair<int,System.Collections.Generic.Queue<string>>'\n        to exam.PQ<int, string>\"*/\n\n        foreach (PQ<int, string> h in first)\n        {\n\n        }\n    }\n```\n\n\nThank you.\n    ", "Answer": "\r\nOne way to do it would be to add your own method on your PQ class, that returns a collection of Queue items that pass your (any) validation check.\n\nSo something like this on your PQ class\n\n```\n public IEnumerable<Queue<Titem>> GetItems(Tpriority priority)\n {\n     var validKeys = value.Keys.Where(x => !x.Equals(priority) );\n     return value.Where(x => validKeys.Contains(x.Key)).Select(x => x.Value);\n }\n```\n\n\nThen you can iterate over it like this\n\n```\nforeach (var h in first.GetItems(0))\n{\n\n}\n```\n\n\nYou might want a better name for the method though, which clearly states what it's going to do.\n\nUpdate...\n\nTo just print out the values, you could do something like this.\n\n```\npublic IEnumerable<Titem> GetItems(Tpriority priority)\n{\n    var validKeys = value.Keys.Where(x => !x.Equals(priority) );\n    return value\n        .Where(x => validKeys.Contains(x.Key))\n        .SelectMany(x => x.Value);\n}\n```\n\n\nAnd here it is broken up into bits with a few comments\n\n```\npublic IEnumerable<Titem> GetItems(Tpriority priority)\n    {\n        // Find all the keys in the dictionary which do not match the supplied value\n        var validKeys = value.Keys.Where(x => !x.Equals(priority) );\n\n        // Find all the values in the dictionary where the key is in the valid keys list\n        var validItems = value\n            .Where(x => validKeys.Contains(x.Key));\n\n        // Because an individual queue item is actually a collection of items,\n        // SelectMany flattens them all into one collection\n        var result = validItems.SelectMany(x => x.Value);\n\n        return result;\n    }\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do you use a custom comparator for priority queues?\r\n                \r\nI'm trying to implement a priority queue that compares Nodes that have a \"cost\" value. I have tried 3 implementations of comparators and none of them have worked.\nNode def:\n```\npublic class Node implements Comparable<Node>{\n    int[][] data;\n    int x, y;\n    int cost;\n    Node parent;\n    Node (int[][] data, int x, int y, int newX, int newY, Node parent) {\n        this.parent = parent;\n            \n        //SWAPS VALUE\n        int temp = data[newX][newY];\n        data[newX][newY] = data[x][y];\n        data[x][y] = temp;\n            \n        this.cost = Integer.MAX_VALUE;\n            \n        this.x = newX;\n        this.y = newY;\n    }\n        \n    public int compareTo(Node otherNode) {\n        if (this.cost < otherNode.cost) {\n            return -1;\n        } else if (this.cost > otherNode.cost) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }   \n}\n```\n\nFirst Comparator:\n```\nComparator<Node> CustomComp = new Comparator<Node>() {\n    @Override\n    public int compare(Node lhs, Node rhs) {\n        return lhs.compareTo(rhs);\n    }\n};\n```\n\nSecond Comparator:\n```\nComparator<Node> CustomComp2 = (Node lhs, Node rhs) -> {\n    return lhs.compareTo(rhs);\n};\n```\n\nThird Comparator:\n```\npublic class NodeComparator implements Comparator<Node> {\n    @Override\n    public int compare(Node lhs, Node rhs) {\n        if (lhs.cost < rhs.cost) {\n            return -1;\n        } else if (lhs.cost > rhs.cost) {\n                return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n```\n\nPriority Queue Implementation:\n```\nPriorityQueue<Node> pq = new PriorityQueue<Node>(11, comp);\n```\n\nthis implementation was after attempting to use the last one\nThis is also my first question here, and thanks in advance!\nEDIT:\nThis is the error it gives for ```\nnew PriorityQueue<Node>(11, comp)```\n\nThe constructor PriorityQueue<main.Node>(int, main.Comparator<main.Node>) is undefined\nThere is no output currently but it should store nodes for later use in a tree.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Prim's MST implementation with priority queue error\r\n                \r\nMy algorithm calculated the correct distances between points, but then updated some of the values to a smaller value in the nested for loop for the test case below.\nI suspect there's an error in the implementation of my nested for loop?\n```\n5\n0 0\n0 2\n1 1\n3 0\n3 2\n```\n\nThe answer should be 7.064495102 (i got 7.650281540)\n```\ndef minimum_distance(x, y):\n    result = 0.\n    distance = {}\n    for i in range(len(x)):\n        j=i+1\n        while j<len(x):\n            distance[i, j] = calc_distance(x[i], y[i], x[j],y[j])\n            # distance.append([i, j, calc_distance(x[i], y[i], x[j],y[j])])\n            j+=1\n            \n    cost = []\n    parent = []\n    for k in range(len(x)):\n        cost.append([float('inf'), k])\n        parent.append([None, k]) \n    \n    # [cost, vertex]\n    cost[0] = [0,0]\n    parent[0] = [-1,0]\n\n    pq = min_heap(cost)\n    cost_pq = pq.heapify()\n    \n    while len(cost_pq) != 0:\n        v, cost_pq = pq.extract_min(cost_pq)\n        min_cost, min_current_node = v[0], v[1]\n        result += min_cost\n        for edge in distance:\n            for vertex in cost_pq:\n                # check if cost_pq contains vertex edge[1]\n                if vertex[1] == edge[1]:\n                    vertex_index = cost_pq.index(vertex)\n                    if cost_pq[vertex_index][0] > distance[edge[0], edge[1]]:\n                        cost_pq[vertex_index][0] = distance[edge[0], edge[1]]\n                        parent[edge[1]][0] = edge[0]\n                        pq.heapify() \n            \n    return result\n```\n\n    ", "Answer": "\r\nTo illustrate the comment, this is what should look like:\n```\nfrom itertools import combinations\nimport heapq\n\ndef distance(x1, y1, x2, y2):\n    return ((x1-x2)**2 + (y1-y2)**2)**0.5\n\ndef MST(xs, ys):\n    n = len(xs)\n    # heap of tuples (distance, node1, node2)\n    q = [(distance(xs[i], ys[i], xs[j], ys[j]), i, j) \n         for i, j in combinations(range(n), 2)]\n    heapq.heapify(q)\n    # each node is its own parent in the beginning\n    parents = list(range(n))\n    # naive parent implementation - should include depth to balance for better performance\n    def parent(i):\n        while parents[i] != i:\n            i = parents[i]\n        return i\n\n    total_distance = 0\n    while q:\n        d, i, j = heapq.heappop(q)\n        parent1, parent2 = parent(i), parent(j)\n        if parent1 != parent2:\n            total_distance += d\n            parents[parent1] = j\n    return total_distance\n```\n\n```\nMST([0, 0, 1, 3, 3], [0, 2, 1, 0, 2])```\n returns 7.06449510224598\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing a priority queue in matlab in order to solve optimization problems using BRANCH AND BOUND\r\n                \r\nI'm trying to code a priority queue in MATLAB, I know there is the SIMULINK toolbox for priority queue, but I'm trying to code it in MATLAB. I have a pseudo code that uses priority queue for a method called BEST First Search with Branch and Bound. The branch and bound algorithm design strategy is a state space tree and it is used to solve optimization problems. simple explanation of what is branch and bound\nI have read chapter 5: Branch and Bound from a book called 'FOUNDATIONS OF ALGORITHMS', it's the 4th edition by Richard Neapolitan and Kumarss Naimipour , and the text is about designing algorithms, complexity analysis of algorithms, and computational complexity (analysis of problems), very interesting book, and I came across this pseudocode:\n\n\n\n```\nVoid BeFS( state_space_tree T, number& best)\n\n{\n\npriority _queue-of_node PQ; \n\nnode(u,v); \n\ninitialize (PQ)   % initialize PQ to be empty\n\nu=root of T;\n\nbest=value(v);\n\ninsert(PQ,v)      insert(PQ,v) is a procedure that adds v to the priority queue PQ \n\n  while(!empty(PQ){   % remove node with best bound\n\n     remove(PQ,v); \n```\n\n\n\n\n```\nremove(PQ,v) is a procedure that removes the node with the best bound and it assigns    its value to v    \n```\n\n\n\n\n```\n   if(bound(v) is better than best) % check if node is still promising\n\n     for (each child of u of v){ \n\n     if (value (u) is better than best)\n\n    (best=value(u);\n\n     if (bound(u) is better than best)\n\n    insert(PQ,u)\n       }\n      }\n     }\n```\n\n\n\n\nI don't know how to code it in matlab, and branch and bound is an interesting  general algorithm for finding optimal solutions of various optimization problems, especially in discrete and combinatorial optimization, instead of using heuristics to find an optimal solution, since branch and bound reduces calculation time and finds the optimal solution faster.\n\nEDIT:\n\nI have checked everywhere whether a solution already has been implemented , before posting a question here. And I came here to get ideas of how I can get started to implement this code\n    ", "Answer": "\r\nI have included this in your post so people can know better what you expect of them. However, 'ideas to get started to implement' is still not much more specific than 'how to write code in matlab'. \n\nHowever, I will still try to answer:\n\n\nMake the structure of the code, write the basic loops and fill them with comments of what you want to do\nPick (the easiest or first) one of those comments, and see whether you can make it happen in a few lines, you can test it by generating some dummy input for that piece of code\nKeep repeating step 2 untill all comments have the required code\n\n\nIf you get stuck in one of the blocks, and have searched but not found the answer to a specific question. Then this is not a bad place to ask.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Thread Safe Bounded Priority Queue in java\r\n                \r\nis there any library that implements a thread safe bounded priority queue in java?\nI need something like quava's MinMaxPriorityQueue except being thread safe.\nif the queue is full it should remove the element with the lowest priority and add the new element except when new element is the one with the lowest priority.\n    ", "Answer": "\r\nYou can make MinMaxPriorityQueue synchronized\n\n```\n Queue<E> queue = Queues.synchronizedQueue(MinMaxPriorityQueue.<E>create());\n```\n\n\nQueues is part of com.google.common.collect package.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "RabbitMQ implementation of priority queues does not work as intended\r\n                \r\nI am facing the following problem, which probably is due to my poor understanding of RabbitMQ. I am sorry if I don't use terminology for RabbitMQ experts.\nIn a few words, I want to publish to a queue a number of messages with different priorities, and I want a consumer to treat the higher priorities first.\nI have declared my queue as:\n```\nconnection = pika.BlockingConnection(parameters) \n\nchannel = connection.channel() \n\nchannel.basic_qos(prefetch_count=1)\n\nchannel.queue_declare(queue=JOBS_PENDING, durable=True, arguments={\"x-max-priority\": 1})\n```\n\nI use the following command to publish in that queue let's say 10 messages, the first 9 have priority 1 and the 10th has a higher priority let's say 2.\n```\npika_props = pika.BasicProperties(delivery_mode=2, priority=1 or 2)\nchannel.basic_publish(exchange='', routing_key=JOBS_PENDING, body=message, properties=pika_props)\n```\n\nI have a separate service that consumes messages from the above queue.\n```\nchannel.basic_consume(queue=JOBS_PENDING, on_message_callback=_encapsulate_callback(callback), arguments={\"x-max-priority\": 1})\n```\n\nTo my understanding, doing this, the first message consumed should be the 10th because it has a priority higher than the maximum, which is 1.\nInstead, what i see is that messages are consumed with the order of which they were published, i.e., the first 9 with priority 1 and the 10th last.\n    ", "Answer": "\r\nI think your problem is when you declared the queue, you've defined that the message's max priority is 1.\nIn this case all of your messages will be treated the same, since your messages with priority two exceed the maximum value of priority, defined by you in the queue.\nSet the maximum priority to any number larger than 1, for example 10. The messages with larger number will be prioritized first.\nCheck the Documentation for more details\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What operations would you use for implementing a priority queue PQ with enqueue and dequeue?\r\n                \r\nAssume that you are implementing a priority queue PQ that returns the max element on dequeue operation.\nIf we use a max heap to implement the PQ, enqueue is O(______) operation, and dequeue is O(_____) operation\n\nCould someone please answer/explain how you got it...I am thinking log n for both but not sure?\n    ", "Answer": "\r\nThink of how a binary heap works.\n\nWhen you insert an item, you add it as the last node of the heap and then sift it up into its proper place. Since a heap that contains n items has a height of log(n), and you might have to sift the item all the way to the top, the worst case is O(log n).\n\nWhen you remove an item, you replace the root note with the last node in the heap, and then you sift it down. Worst case, you'll have to sift it all the way back down to the bottom of the heap: a move of log(n) levels. Therefore, O(log n).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C - How to implement priority queue using binary heap with tie-breaker?\r\n                \r\nI have to implement a priority queue using binary heap in C for the university assignment. Program should get the n values from input, when value is 0, it should print the ID number(so, if task that was added as 5th element has the highest priority 7, print \"5\") and remove the highest-priority task from queue, and when value>0 it should add new node. To implement ID's and priority, I used arrays of structs.\n\nThe task would be quite simple, if not the fact that it should also print lower ID's if the priority of elements are the same...\nI've done my research, but the only advice that I've managed to found is to modify the fragments of typical heap functions (insertkey, heapify) to also look for elements' ID. I've tried to do this, but I have no idea what went wrong - elements are still not sorted in the way I want them to be. I would be grateful for any piece of advice and tips!\n\nCode:\n\n```\n#include <stdio.h>\n\n#define SIZE 99999\n\nint heapsize = 0;\nint count = 0;\n\nstruct pqueue\n{\n    int priority;\n    int id;\n};\n\nstruct pqueue A[SIZE];\n\n\nvoid swap(int *x, int *y)\n{\n    int temp = *x;\n    *x = *y;\n    *y = temp;\n}\n\n\nvoid initializearray()\n{\n    for(int i=0; i<SIZE; i++)\n    {\n        A[i].priority = 0;\n        A[i].id = 0;\n    }\n}\n\nvoid printheap(); //prototype of debugging function\n\n\n\nint left(int i)\n{\n    return (i * 2) + 1;\n}\n\n\n\nint right(int i)\n{\n    return (i * 2) + 2;\n}\n\nint parent(int i)\n{\n    return ((i - 1) / 2);\n}\n\n\nvoid insertkey(int z)\n{\n    heapsize++;\n    int i = heapsize - 1;\n    A[i].priority = z;\n    count++;\n    A[i].id = count;\n\n    while (i != 0 && A[parent(i)].priority < A[i].priority)\n    {\n        swap(&A[i].priority, &A[parent(i)].priority);\n        swap(&A[i].id, &A[parent(i)].id);\n        i = parent(i);\n    }\n\n\n    i = heapsize-1;\n    while(i != 0 && A[parent(i)].priority == A[i].priority && A[parent(i)].id > A[i].id )\n        {\n        swap(&A[i].priority, &A[parent(i)].priority);\n        swap(&A[i].id, &A[parent(i)].id);\n        i = parent(i);\n        }\n\n     //   printheap();\n}\n\n\n\nvoid maxheapify(int i)\n{\n    int l = left(i);\n    int r = right(i);\n    int largest;\n\n    if (l <= heapsize && A[l].priority >= A[i].priority)\n    {\n        largest = l;\n\n        if(A[l].priority == A[i].priority)\n        {\n            if(A[l].id < A[i].id)\n            {\n                largest = l;\n            }\n\n            else\n            {\n                largest = i;\n            }\n        }\n\n    }\n\n    else\n    {\n        largest = i;\n    }\n\n    if (r <= heapsize && A[r].priority >= A[largest].priority)\n    {\n        largest = r;\n\n        if(A[r].priority == A[largest].priority)\n        {\n            if(A[r].id < A[largest].id)\n            {\n                largest = r;\n            }\n        }\n    }\n\n    if (largest != i)\n    {\n        swap(&A[i].priority, &A[largest].priority);\n        swap(&A[i].id, &A[largest].id);\n        maxheapify(largest);\n    }\n}\n\nint extractmax()\n{\n    int max = A[0].id;\n    A[0].priority = A[heapsize-1].priority;\n    A[0].id = A[heapsize-1].id;\n    heapsize--;\n    //printheap();\n    maxheapify(0);\n    return max;\n}\n\nvoid printheap() // debug function\n{\n    for(int i = 0; i < heapsize; i++)\n    {\n        printf(\"prio %d id %d \\n\", A[i].priority, A[i].id);\n    }\n}\n\n\nint main()\n{\n    int n;\n    int z;\n\n    initializearray();\n    scanf(\"%d\", &n);\n\n    for(int i=0; i<n; i++)\n    {\n        scanf(\"%d\", &z);\n\n        if(z != 0)\n        {\n            insertkey(z);\n        }\n\n        else\n        {\n            int local = extractmax();\n\n            if(local != 0 && heapsize+1 != 0)\n            {\n                printf(\"%d\\n\", local);\n                // printheap();\n            }\n        }\n    }\n\n    return 0;\n}\n```\n\n\nExample input:\n\n\n  7\n  \n  3 0 0 2 8 8 0\n\n\nOutput:\n\n\n  1\n  \n  3\n\n\nExample input (here comes the problem:)\n\n\n  10\n  \n  1 1 1 1 2 0 0 0 0 0\n\n\nOutput:\n\n\n  5\n  \n  3\n  \n  2\n  \n  4\n  \n  1\n\n\nExpected output:\n\n\n  5\n  \n  1\n  \n  2\n  \n  3\n  \n  4\n\n\nThank you for your time!\n    ", "Answer": "\r\nInstead of incorporating the logic directly into the heap implementation, write a comparison function that considers the id if the priorities are the same:\n\n```\nint pqless(const struct pqueue *a, const struct pqueue *b)\n{\n    if (a->priority < b->priority) return 1;\n    if (a->priority > b->priority) return 0;\n\n    return (a->id > b->id);\n}\n```\n\n\nThis function returns true if ```\na```\n's priority is less than ```\nb```\n's. If both priorities are equal, it returns true if ```\na```\n's  id is smaller than ```\nb```\n's.\n\nNow update your heap code. Wherever you compare the priorities in the original code, now just call the function:\n\n```\nvoid insertkey(int z)\n{\n    int i = heapsize++;\n\n    A[i].priority = z;\n    A[i].id = ++count;\n\n    while (i != 0 && pqless(&A[parent(i)], &A[i])) {\n        swap(&A[i].priority, &A[parent(i)].priority);\n        swap(&A[i].id, &A[parent(i)].id);\n        i = parent(i);\n    }\n}\n\nvoid maxheapify(int i)\n{\n    int l = left(i);\n    int r = right(i);\n    int largest = i;\n\n    if (l <= heapsize && !pqless(&A[l], &A[i])) largest = l;\n    if (r <= heapsize && !pqless(&A[r], &A[largest]))largest = r;\n\n    if (largest != i) {\n        swap(&A[i].priority, &A[largest].priority);\n        swap(&A[i].id, &A[largest].id);\n        maxheapify(largest);\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Asymptotic complexity of binary heaps implemented with sets vs. priority queues\r\n                \r\nI'm reviewing for a final and have stumbled upon the following problem:\n\nBinary heaps have priority queue semantics by default:If we insert some element n times, we need to remove it n times before it “disappears.” Imagine you want to implement binary heaps with set semantics instead. How fast can the insert and remove operations be in this case? \n\n(a) insert: O(n) remove: O(logn) \n\n(b) insert: O(log n) remove: O(n)\n\n(c) insert: O(log n) remove: O(log n)\n\n(d) insert: O(1) remove: O(n2) \n\n(e) None of the above. \n\nTo insert into a heap implemented with priority queue semantics, it will be O(logn), and so will the removal. But with sets, insertions and removals depend on many factors of the set itself. What do you think the answer should be?\n    ", "Answer": "\r\nI would say insert: O(n) remove: O(log n). In a set duplicated item is not allowed and attempt to insert a duplicate item should be ignored and since a heap is a binary tree that is completely filled, (with a exception of the bottom) ,   If you want to insert to a set you search(item) if you find it you do nothing else insert so insertion may take O(n) for both find and insert (you may percolate up at most log n times). deleteMin has o(log n) time complexity \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Custom Compare Function for Priority Queue\r\n                \r\nI was implementing a custom compare function for priority queue and saw a difference between the compare function of sort and priority queue STL.\nSuppose, we have couple of points(x, y) and for those points we have a user defined class.\n```\nclass Point\n{\n   int x;\n   int y;\npublic:\n   Point(int _x, int _y)\n   {\n      x = _x;\n      y = _y;\n   }\n   int getX() const { return x; }\n   int getY() const { return y; }\n};\n```\n\nAnd the custom compare function:\n```\nclass myComparator\n{\npublic:\n    int operator() (const Point& p1, const Point& p2)\n    {\n        return p1.getX() > p2.getX();\n    }\n};\n```\n\nNow, if we pass the compare function to sort STL, then it will sort the points in descending order of x co-ordinate.\n```\nint main ()\n{\n    vector<Point>v;\n\n    v.push_back(Point(10, 1));\n    v.push_back(Point(1, 5));\n    v.push_back(Point(2, 1));\n\n    sort(v.begin(), v.end(), myComparator());\n\n    for(auto p: v)\n    {\n        cout << \"(\" << p.getX() << \", \" << p.getY() << \")\"<<endl;\n    }\n\n    return 0;\n}\n```\n\nOutput:\n\n(10, 1)  (2, 1)  (1, 5)\n\nNow, if I apply the same compare function for priority queue, it will have the points in descending order. Basically, it is working as min heap.\n```\nint main ()\n{\n    priority_queue <Point, vector<Point>, myComparator > pq;\n\n    pq.push(Point(10, 2));\n    pq.push(Point(2, 1));\n    pq.push(Point(1, 5));\n\n    while (pq.empty() == false)\n    {\n        Point p = pq.top();\n        cout << \"(\" << p.getX() << \", \" << p.getY() << \")\";\n        cout << endl;\n        pq.pop();\n    }\n\n    return 0;\n}\n```\n\nOutput:\n\n(1, 5)  (2, 1)  (10, 2)\n\nI was expecting that the points will be ordered like the sort function as in the custom compare function I have written like below:\n```\np1.getX() > p2.getX()\n```\n\nWhy the compare function works differently in priority queue?\n    ", "Answer": "\r\n```\nstd::priority_queue```\n\n\nNote that the Compare parameter is defined such that it returns true\nif its first argument comes before its second argument in a weak\nordering. But because the priority queue outputs largest elements\nfirst, the elements that \"come before\" are actually output last. That\nis, the front of the queue contains the \"last\" element according to\nthe weak ordering imposed by Compare.\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Pop the highest value from a priority queue while removing some related nodes\r\n                \r\nSuppose we have a priority queue of ```\nn```\n nodes of a graph. Each node is assigned a key, and all nodes are sorted in the priority queue based on the key value.\n\nWith the right implementation, popping the head key (the node with the highest key value) from this queue takes ```\nO(log(n))```\n time. \n\nBut what if it is also required to remove all fanout and fanins of the head node from the priority queue? The obvious implementation would be to search all nodes in the queue and if they were on fanin or fanout of the head, remove them. This will make the run time for POP to be  ```\nO(nlog(n))```\n. \n\nCan we do any better? Is there any better data structure that can provide a better runtime?\n    ", "Answer": "\r\nBasically, what you need is a priority queue with an additional delete operation. In order to make it in an efficient way (that is if you want to remove k nodes from the queue, it would take O(k*log n)), you need a handle on the nodes.\n\nA usual way to do that is to have an array which associates a vertex's id to the node in the priority queue. Then, the deletion algorithm depends of which priority queue is implemented.\n\nI don't think you can do any better in terms of performance, because the other solution consisting in maintaining a sorted array is more expensive (have to maintain the array sorted for each modification).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "is this the right way to implement a simple priority queue using double pointer?\r\n                \r\nim trying to apply linus torvald's idea of \"good taste\" when he showed an example of removing an entry a singly-linked list using double pointers to eliminate an if statement. I want to know the best way to enqueue and dequeue in a priority queue applying the same idea. \n\n```\n    #include <stdlib.h>\n    #include <stdio.h>\n\n    typedef struct node node;\n    struct node{\n        int val;\n        node *prev;\n    };\n\n    node *head = NULL;\n\n    void enqueue(int val){\n        node **focus = &head;\n        while((*focus) != NULL && (*focus)->val <= val)\n            focus = & (*focus)->prev;\n        node *tmp = *focus;                      //is there a way to remove this line\n        *focus  = (node*)malloc(sizeof(node));\n        **focus = (node){ .val = val, .prev = tmp };\n    }\n\n    int dequeue(){\n        int ret = head->val;\n        node *tmp = head;  \n        head = head->prev;\n        free(tmp);\n        return ret;\n    }\n\n    int main(){\n        enqueue(20);\n        enqueue(11);\n        enqueue(4);\n        enqueue(6);\n        enqueue(9);\n        enqueue(8);\n        enqueue(27);\n        enqueue(44);\n        printf(\"dequeue: %d\\n\",dequeue());\n        printf(\"dequeue: %d\\n\",dequeue());\n        printf(\"dequeue: %d\\n\",dequeue());\n        printf(\"dequeue: %d\\n\",dequeue());\n        printf(\"dequeue: %d\\n\",dequeue());\n        printf(\"dequeue: %d\\n\",dequeue());\n        printf(\"dequeue: %d\\n\",dequeue());\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Dequeue in a priority queue\r\n                \r\nI have implemented a priority queue with array (school work), and it looks like below:\n\n```\nint dequeue(int a[], int n){\n\n    int i, numberToDequeue;\n    numberToDequeue = a[0];\n\n    for(i = 0; i < n; i++){\n        a[i] = a[i+1];\n    }\n    return numberToDequeue;\n}\n```\n\n\nDequeue in a priority queue should take O(1) time.\n\nHowever, in my code, it takes O(1) time to dequeue and \n\nO(n) time to shift all the elements to front by 1 index.\n\nI was wondering if there's any better solution that has the time complexity of O(1).\n\nAll form of reply will be greatly appreciated.\n    ", "Answer": "\r\n```\nint dequeue(int a[], int n){ //provided that the numbers are in ascending order\n\n    int numberToDequeue;\n    numberToDequeue = a[n - 1];\n    n--;\n    return numberToDequeue;\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue based on the time in queue and on a priority\r\n                \r\nIs there any data structures in python that would enable me to implement a priority queue based on a basic priority and the time passed in queue ?\nIt would help me avoid that some element in this queue starve.\nFrom what I know the object Queue is only based on the time element enter in it, and the object PriorityQueue is only based on a priority so it will possibly lead to starving element.\n    ", "Answer": "\r\nAs I couldn't find what I wanted, I created this little class to meet my needs.\n```\nclass PriorityQueue(object):\n    \"\"\"\n        PriorityQueue supportant des objets de type dict.\n\n        Cette Queue base sa priorité sur deux éléments.\n        Le premier est une priorité de base.\n        Le second est une priorité qui se contruit au fur et à mesure du temps passé\n        dans la queue.\n    \"\"\"\n    import time\n\n    def __init__(self, seconde_pour_augmenter_priorite:int = 5):\n        \"\"\"\n        param :\n            seconde_pour_augmenter_priorite :\n                Variable qui permet de savoir le nombre de seconde nécessaire passé \n                dans la queue pour augmenter le niveau de priorité\n        \"\"\"\n        self.queue = []\n\n        self.spap = seconde_pour_augmenter_priorite\n\n    def __str__(self):\n        \"\"\"\n        toString\n        \"\"\"\n        return ' '.join([str(i) for i in self.queue])\n\n    def sizeq(self):\n        return len(self.queue)\n\n    def isEmpty(self):\n        \"\"\"\n        Vérifier si la queue est vide\n        \"\"\"\n        return len(self.queue) == 0\n\n    def insert(self, data):\n        \"\"\"\n        Insérer un élément dans la queue\n        \"\"\"\n        data[\"temps-entre-queue\"] = self.time.time()\n        self.queue.append(data)\n\n    def __calculer_priorite(self, data:dict, temps:float):\n        return data[\"priorite\"] + (temps - data[\"temps-entre-queue\"]) / self.spap\n\n    def pop(self):\n        \"\"\"\n        Pour retirer de la file d'attente l'élément avec la plus haute priorité\n        \"\"\"\n        try:\n            temps = self.time.time()\n            max_val = 0\n            for i in range(len(self.queue)):\n                if self.__calculer_priorite(self.queue[i], temps) > self.__calculer_priorite(self.queue[max_val], temps):\n                    max_val = i\n            item = self.queue[max_val]\n            del self.queue[max_val]\n            return item\n        except IndexError:\n            print()\n            exit()\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a Priority Queue in numba where one element of the item is a list of tuples?\r\n                \r\nI am trying to create the PriorityQueue in numba for a very specific task. To achieve that, I need the nodes to have an element which is list of tuples. However, when I try to do that, it raises an error that I don't understand.\n(Most of the implementation of PriorityQueue taken from How can I implement a numba jitted priority queue?)\n```\nimport typing\nfrom heapq import heappush, heappop\nimport numba as nb\nfrom numba.experimental import jitclass\n\n\nitemType = nb.typed.List.empty_list(nb.types.Tuple((nb.types.int64, nb.types.int64)))\nentry_def = (0.0, 0, nb.typed.List([(0,0)]))\nentry_type = nb.typeof(entry_def)\n\n@jitclass\nclass PriorityQueue:\n    pq: typing.List[entry_type]\n    id: int\n    entry: entry_type\n\n    def __init__(self):\n        self.pq = nb.typed.List.empty_list((0.0, 0, nb.typed.List([(0,0)])))\n\n    def put(self, priority: float, id: int, item: itemType):\n        entry = (priority, id, item)\n        heappush(self.pq, entry)\n\n    def pop(self):\n        if self.pq:\n            priority, id, item = heappop(self.pq)\n            return priority, id, item\n        raise KeyError(\"pop from an empty priority queue\")\n```\n\nThe functionality that I need to achieve:\n```\n>>> q = PriorityQueue() \n>>> q.put(5.0, 1, [(0,1)])\n>>> q.put(2.0, 2, [(0,1), (1,2)])\n>>> q.put(3.0, 3, [(0,1), (0,1), (1,1)])\n>>> node = q.pop()\n>>> node\n(2.0, 2, [(0, 1), (1, 2)])\n```\n\nHere is the error that I am getting:\n```\nTraceback (most recent call last):\n  File \"C:\\VS Code\\myproject.py\", line 34, in <module>\n    q.put(5.0, 1, [(0,1)])\n  File \"C:\\Users\\Me\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\numba\\experimental\\jitclass\\boxing.py\", line 61, in wrapper\n    return method(*args, **kwargs)\n  File \"C:\\Users\\Me\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\numba\\core\\dispatcher.py\", line 468, in _compile_for_args\n    error_rewrite(e, 'typing')\n  File \"C:\\Users\\Me\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\numba\\core\\dispatcher.py\", line 409, in error_rewrite\n    raise e.with_traceback(None)\nnumba.core.errors.TypingError: Failed in nopython mode pipeline (step: nopython frontend)\n- Resolution failure for literal arguments:\nFailed in nopython mode pipeline (step: nopython frontend)\nNo implementation of function Function(<built-in function heappush>) found for signature:\n\n >>> heappush(ListType[Tuple(float64, int64, ListType[UniTuple(int64 x 2)])], Tuple(float64, int64, reflected list(UniTuple(int64 x 2))<iv=None>))\n\nThere are 2 candidate implementations:\n  - Of which 2 did not match due to:\n  Overload in function 'heappush': File: numba\\cpython\\heapq.py: Line 150.\n    With argument(s): '(ListType[Tuple(float64, int64, ListType[UniTuple(int64 x 2)])], Tuple(float64, int64, reflected list(UniTuple(int64 x 2))<iv=None>))':\n   Rejected as the implementation raised a specific error:\n     TypingError: heap type must be the same as item type\n  raised from C:\\Users\\Me\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\numba\\cpython\\heapq.py:119\n\nDuring: resolving callee type: Function(<built-in function heappush>)\nDuring: typing of call at C:\\VS Code\\myproject.py (24)\n\n\nFile \"myproject.py\", line 24:\n    def put(self, priority: float, id: int, item: itemType):\n        <source elided>\n        entry = (priority, id, item)\n        heappush(self.pq, entry)\n        ^\n\n- Resolution failure for non-literal arguments:\nNone\n\nDuring: resolving callee type: BoundFunction((<class 'numba.core.types.misc.ClassInstanceType'>, 'put') for instance.jitclass.PriorityQueue#228d8eebd30<pq:ListType[Tuple(float64, int64, ListType[UniTuple(int64 x 2)])],id:int64,entry:Tuple(float64, int64, ListType[UniTuple(int64 x 2)])>)\nDuring: typing of call at <string> (3)\n\n\nFile \"<string>\", line 3:\n<source missing, REPL/exec in use?>\n```\n\n    ", "Answer": "\r\nThe problem is that the inferred type for a Python list is a reflected list, but your lists are Numba typed lists. If you do:\n```\nq.put(5.0, 1, nb.typed.List([(0, 1)]))\nq.put(2.0, 2, nb.typed.List([(0, 1), (1, 2)]))\nq.put(3.0, 3, nb.typed.List([(0, 1), (0, 1), (1, 1)]))\n```\n\nthen your code runs to completion and produces:\n```\n(2.0, 2, ListType[UniTuple(int64 x 2)]([(0, 1), (1, 2)]))\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Issue with implementing the compare function in a priority queue\r\n                \r\nSo I'm building a huffman compressor/decompressor and I'm having an issue with how the symbols, frequencies, and their corresponding code are printing out. I coded a nodecompare function for the priority queue that will first compare frequencies, then symbols, and as a last resort then the nodeID's (giving priority to the newly created node). Though my output is not what is expected and I can't seem to figure out where exactly the issue in my code is. Please help.\n```\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Node\n{\n    char symbol;\n    int frequency;\n    Node *left;\n    Node *right;\n    int nodeID;\n\n   Node(char s, int f) : symbol(s), frequency(f), left(nullptr), right(nullptr) {}\n};\n\nstruct NodeCompare\n{\n    bool operator()(Node *n1, Node *n2)\n    {\n        if (n1->frequency == n2->frequency) {\n            if (n1->symbol == n2->symbol) {\n                return n1->nodeID > n2->nodeID;\n            }\n            return n1->symbol > n2->symbol;\n        }\n        else return n1->frequency > n2->frequency;\n    }\n};\n\nvoid buildHuffmanTree(priority_queue<Node *, vector<Node *>, NodeCompare> &pq)\n{\n    static int nodeCounter = 0;\n\n    while (pq.size() > 1)\n    {\n        Node *left = pq.top();\n        pq.pop();\n        Node *right = pq.top();\n        pq.pop();\n        Node *parent = new Node('$', left->frequency + right->frequency);\n        parent->nodeID = ++nodeCounter;\n        parent->left = left;\n        parent->right = right;\n        pq.push(parent);\n    }\n}\n\nvoid printCodes(Node *root, string code)\n{\n    if (root == nullptr)\n    {\n        return;\n    }\n    if (root->symbol != '$')\n    {\n        cout << \"Symbol: \" << root->symbol << \", Frequency: \" << root->frequency << \", Code: \" << code << endl;\n    }\n    printCodes(root->left, code + \"0\");\n    printCodes(root->right, code + \"1\");\n}\n\nint main() {\n    string input_file = \"input_file.txt\";\n    //cin >> input_file;\n\n    ifstream infile(input_file);\n\n    vector<Node *> symbols;\n    char symbol;\n    int frequency;\n    priority_queue<Node *, vector<Node *>, NodeCompare> pq;\n\n    string inputline;\n\n    while (getline(infile, inputline)){\n        istringstream ss(inputline);\n        ss >> std::noskipws >> symbol;\n        ss >> std::skipws >> frequency;\n\n        Node *node = new Node(symbol, frequency);\n        symbols.push_back(node);\n        pq.push(node);\n    }\n\n    buildHuffmanTree(pq);\n    Node *root = pq.top();\n    printCodes(root, \"\");\n}\n```\n\nactual output:\n\nSymbol: 0, Frequency: 2, Code: 000\nSymbol: 2, Frequency: 2, Code: 001\nSymbol: C, Frequency: 2, Code: 010\nSymbol: S, Frequency: 2, Code: 011\nSymbol:  , Frequency: 3, Code: 100\nSymbol: R, Frequency: 1, Code: 1010\nSymbol: 6, Frequency: 1, Code: 10110\nSymbol: G, Frequency: 1, Code: 10111\nSymbol: 3, Frequency: 3, Code: 110\nSymbol: I, Frequency: 1, Code: 11100\nSymbol: N, Frequency: 1, Code: 11101\nSymbol: O, Frequency: 1, Code: 11110\nSymbol: P, Frequency: 1, Code: 11111\n\nexpected output:\n\nSymbol: 0, Frequency: 2, Code: 000\nSymbol: 2, Frequency: 2, Code: 001\nSymbol: I, Frequency: 1, Code: 0100\nSymbol: N, Frequency: 1, Code: 0101\nSymbol: 6, Frequency: 1, Code: 0110\nSymbol: G, Frequency: 1, Code: 0111\nSymbol: R, Frequency: 1, Code: 1000\nSymbol: O, Frequency: 1, Code: 10010\nSymbol: P, Frequency: 1, Code: 10011\nSymbol:  , Frequency: 3, Code: 101\nSymbol: 3, Frequency: 3, Code: 110\nSymbol: C, Frequency: 2, Code: 1110\nSymbol: S, Frequency: 2, Code: 1111\n\n    ", "Answer": "\r\nI'd normally suggest using ```\nstd::tie```\n for creating comparators, but in this case, I'll settle for two minor changes.\n\nYou need to treat the parent nodes, the ```\n$```\n symbols, separately. A non-parent node should come after a parent node in the queue given that they have the same frequency.\nYou need to swap the priority order of the ```\nnodeID```\ns.\n\n```\nstruct NodeCompare {\n    bool operator()(const Node *n1, const Node *n2) const {\n        if (n1->frequency == n2->frequency) {\n            if (n1->symbol == n2->symbol) {\n                return n1->nodeID < n2->nodeID;\n//                               ^^^ swapped\n            }\n            if (n1->symbol != '$' && n2->symbol == '$') return true;\n// if `n1` is _not_ a parent node but `n2` is, then return true\n            return n1->symbol > n2->symbol;\n        } else\n            return n1->frequency > n2->frequency;\n    }\n};\n```\n\nDemo\n\nAn easier way would be to use a different \"parent\" character and instead use one that would be sorted in the correct order naturally. That would be the character with the smallest value.\n```\n#include <limits>\n\nconstexpr char Parent = std::numeric_limits<char>::min(); // -128 probably\n```\n\nThen use ```\nParent```\n everywhere where you now use ```\n'$'```\n.\nWith that, you don't need to treat the parent nodes separately and can use the much easier to implement comparator using ```\nstd::tie```\n:\n```\n#include <tuple>\n\nstruct NodeCompare {\n    bool operator()(const Node *n1, const Node *n2) const {\n        return std::tie(n1->frequency, n1->symbol, n2->nodeID) >\n               std::tie(n2->frequency, n2->symbol, n1->nodeID);\n               // note that the ordering of `nodeID` still needs to be swapped\n    };\n};\n```\n\nDemo\n\nIf you don't like the idea of having a different ordering rule for ```\nnodeID```\n, but rather have ...\n```\nstruct NodeCompare {\n    bool operator()(const Node *n1, const Node *n2) const {\n        return std::tie(n1->frequency, n1->symbol, n1->nodeID) >\n               std::tie(n2->frequency, n2->symbol, n2->nodeID);\n    };\n};\n```\n\n... you only need to use a decreasing counter instead of an increasing one:\n```\nparent->nodeID = --nodeCounter; // was parent->nodeID = ++nodeCounter;\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue in swift\r\n                \r\nI'm trying to implement a version of Dijkstra Algorithm to find the shortest route for a bus to take from start to end. Unfortunately, I cannot seem to find a library or other way that swift provides a type of priority queue so it seems I will have to code my own.\n\nThis being said, can anyone point me in the right direction to do this?\n\nCurrently my thinking is as follows:\n\nWrite a class which will hold the priority array. In this class there will be a method which receives a value, adds it to the priority array and then sorts it according to priority (In this case, distance). There will also be a get function which returns the highest priority item from the array.\n\nI would like to know if I'm close or still way off in my understanding of a priority queue.\n\nThank you.\n\nEDIT :\n\nThis is my code so far. Seems too short and brutal... I must be missing something in terms of the concept.\n\n```\nvar priorityQueue = Dictionary<String, Int>()\nvar firstElement: String = \"\"\n\nfunc push(name: String, distance: Int)\n{\n    priorityQueue[name] = distance\n    var myArr = Array(priorityQueue.keys)\n    var sortedKeys = sort(myArr) {\n        var obj1 = self.priorityQueue[$0] // get obj associated w/ key 1\n        var obj2 = self.priorityQueue[$1] // get obj associated w/ key 2\n        return obj1 > obj2\n    }\n\n    firstElement = myArr[0]\n    var tempPriorityQueue = Dictionary<String, Int>()\n    for val in myArr\n    {\n        tempPriorityQueue[val] = priorityQueue[val]\n    }\n\n    priorityQueue = tempPriorityQueue\n}\n\nfunc pop() -> String\n{\n    priorityQueue.removeValueForKey(firstElement)\n}\n```\n\n    ", "Answer": "\r\nYou should use heap sort for the priority. I think this is optimal! Try it out in playground!\n\n```\nimport Foundation\ntypealias PriorityDefinition<P> = (_ p1: P, _ p2: P) -> (Bool)\nclass PriorityQueue<E, P: Hashable> {\n    var priDef: PriorityDefinition<P>!\n    var elemments = [P: [E]]()\n    var priority = [P]()\n    init(_ priDef: @escaping PriorityDefinition<P>) {\n        self.priDef = priDef\n    }\n    func enqueue(_ element: E!, _ priorityValue: P!) {\n        if let _ = elemments[priorityValue] {\n            elemments[priorityValue]!.append(element)\n        } else {\n            elemments[priorityValue] = [element]\n        }\n        if !priority.contains(priorityValue) {\n            priority.append(priorityValue)\n            let lastIndex = priority.count - 1\n            siftUp(0, lastIndex, lastIndex)\n        }\n    }\n    func dequeue() -> E? {\n        var result: E? = nil\n        if priority.count > 0 {\n            var p = priority.first!\n            if elemments[p]!.count == 1 {\n                if priority.count > 1 {\n                    let _temp = priority[0]\n                    priority[0] = priority[priority.count - 1]\n                    priority[priority.count - 1] = _temp\n                    p = priority.last!\n                    siftDown(0, priority.count - 2)\n                }\n                result = elemments[p]!.removeFirst()\n                elemments[p] = nil\n                priority.remove(at: priority.index(of: p)!)\n            } else {\n                result = elemments[p]!.removeFirst()\n            }\n        }\n        return result\n    }\n    func siftDown(_ start: Int, _ end: Int) {\n        let iLeftChild = 2 * start + 1\n        if iLeftChild <= end {\n            var largestChild = priDef(priority[iLeftChild], priority[start]) ? iLeftChild : start\n            let iRightChild = 2 * start + 2\n            if iRightChild <= end {\n                if priDef(priority[iRightChild], priority[iLeftChild]) {\n                    largestChild = iRightChild\n                }\n            }\n            if largestChild == start {\n                return\n            } else {\n                let _temp = priority[start]\n                priority[start] = priority[largestChild]\n                priority[largestChild] = _temp\n                siftDown(largestChild, end)\n            }\n        }\n    }\n    func siftUp(_ start: Int, _ end: Int, _ nodeIndex: Int) {\n        let parent = (nodeIndex - 1) / 2\n        if parent >= start {\n            if priDef(priority[nodeIndex], priority[parent]) {\n                let _temp = priority[nodeIndex]\n                priority[nodeIndex] = priority[parent]\n                priority[parent] = _temp\n                siftUp(start, end, parent)\n            } else {\n                return\n            }\n        }\n    }\n    func isEmpty() -> Bool {\n        return priority.count == 0\n    }\n}\nlet Q = PriorityQueue<Int, Int> { (p1: Int, p2: Int) -> (Bool) in\n    return p1 > p2\n}\nlet n = 999\nfor i in 0...n - 1 {\n    let start = NSDate().timeIntervalSince1970\n    Q.enqueue(i, i)\n    let end = NSDate().timeIntervalSince1970\n    print(end - start)\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Dijkstra's algorithm implementation for undirected cyclic graphs without priority queues\r\n                \r\nHow can i implement the Dijkstra using only queues instead of priority queues \n.Is this possible ? if not,why ? This is My Code in java.. whats my mistake ?\n\"S\" is the starting node \"W\" is the weight \"N\" is the size of the matrix. I added 1 to the length of the adj matrix since the first node is \"1\". \n\nThis is a problem from HackerRank Link :https://www.hackerrank.com/challenges/dijkstrashortreach\n\n```\n  import java.io.*;\n  import java.util.*;\n\npublic class Solution {\n\npublic static void main(String[] args) {\n\n    Scanner in = new Scanner (System.in);\n    int cases = in.nextInt();\n\n    for(int i=0; i<cases; i++){\n        int N = in.nextInt();\n        int M = in.nextInt();\n        int adj[][] = new int[N+1][N+1];\n\n        for(int j=0; j<N+1; j++){\n            for(int k=0; k<N+1; k++){\n                adj[j][k] = 0;\n            }\n        }\n\n        for(int j=0; j<M; j++){\n            int A = in.nextInt();\n            int B = in.nextInt();\n            int W = in.nextInt();\n\n            adj[A][B] = W;\n            adj[B][A] = W;\n        }\n\n        int S  = in.nextInt();\n\n        Queue<Integer> que = new  LinkedList<Integer>();\n        que.add(S);\n\n        int dist[] = new int[N+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        boolean vis[] = new boolean[N+1];\n\n        dist[S] = 0;\n        vis[S] = true;\n\n        while(!que.isEmpty()){\n            int q = que.poll();\n\n            for(int j=1; j<=N; j++){\n                if(!vis[j]&&q!=j && adj[q][j]!=0){\n\n                    if(dist[j]>dist[q]+adj[q][j]){\n                      dist[j] = dist[q]+adj[q][j];\n                        que.add(j);\n                    } \n                }\n            }\n            vis[q] = true;\n        }\n\n        for(int j=1; j<=N; j++){\n            if(dist[j]!=0)\n            System.out.print(dist[j]+\" \");\n        }\n    }\n\n}\n```\n\n\n}\n    ", "Answer": "\r\nYes, it is possible to implement it like that but it's less than optimal.\nBecause you use queues instead of priority queues you may have to expand the same portion of the graph multiple times. Because of that you replace the logN with something like N^2 (if i'm not mistaking).\n\nIf you don't expand a node multiple times (like you do in your code) then it's wrong because you use a cost that is higher than the minimum. Imagine that you have 2 nodes with a direct link of cost 20 or an indirect link through a third node with cost 1 on both edges. You would expact the second node assuming minimum distance is 20 (because it arrived first in the queue) but if you waited you would find a path with cost 2. Add more nodes to the indirect path if this is not already obvious.\n\nAt least do a linear search to find the minimum to bring it back to N (overall complexity O(N^2) with your setup). The best implementation has complexity O((N+M)logN).\n\nAnother mistake in your code is in reading the data:\n\n```\n for(int j=0; j<M; j++){\n        int A = in.nextInt();\n        int B = in.nextInt();\n        int W = in.nextInt();\n\n        adj[A][B] = W;\n        adj[B][A] = W;\n    }\n```\n\n\nAccording to the problem statement you can have multiple edges between two nodes. You only use the last one. Switch to take the minimum and you should be good.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "When to use a Binary Heap based Priority Queue vs a Linked List based Priority Queue?\r\n                \r\nYou can implement a Priority Queue using Binary Heaps or using Linked Lists. I believe the Linked List implementation allows for O(n) insertions and O(1) removals, whereas the Binary Heap implementation allows for O(log n) insertions and O(log n) removals.\nThe only advantage of the Linked List implementation (that I can tell) is that you can remove items from the Priority Queue quickly (in constant time). However, in order to remove items, you must first add items, meaning that we need to consider the time to add as well.\nTherefore, would that not mean that the Binary Heap implementation is ALWAYS better than the Linked List implementation, since O(n + 1) is slower than O(log n + log n)?\nThanks!\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java: a comparator always return 1 doesn't make a priority queue into a queue? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Java: strange order of queue made from priority queue  \n\n\n\n\nI tired to turn a priority queue into a queue by implementing the following comparator:\n\n\nHack: The QueueComparator makes a PriorityQueue behaves like queue\n        (FIFO) by always return 1\nSince the \"natural ordering\" of a priority queue has the least \n        element at the head and a conventional comparator returns -1 when \n        the first is less than the second, the hacked comparator always \n        return 1 so that the current (last) square will be placed at the \n        tail (recursively)\n\n\nHere is the code:\n\n```\nimport java.util.Comparator;\npublic class QueueComparator implements Comparator<Square>{\n    public int compare(Square square1, Square square2)\n    {\n        return 1;\n    }\n}\n```\n\n\nBut the resulting \"queue\" does not keep things in order(FIFO). Why?\n    ", "Answer": "\r\nThe question is why should it?\n\nFirst your Comparator is completely broken, since it violates the basic constraint that \n\n```\nsign(compare(a,b)) = - sign(compare(b,a))\n```\n\n\nand \n\n```\ncompare(a,a) == 0\n```\n\n\nSo anything using it might come up with all kinds of results like loosing entries, running in an endless loop, throwing a stackoverflow ...\n\nIf you want to implement a ```\nIDontGiveAShitComparator```\n it should return 0 all the time. Everything depending on a Comparator should be able to handle that.\n\nWhat order results is still up to the implementation. If it stores elements in a list FIFO or LIFO are kind of probable, If it stores in a balanced tree, it will probably add elements always on one side, causing rebalancing of the tree, which will pretty much mix everything up.\n\nMaybe it uses something based on hashes, in which case all elements with the same priority might come out ordered by their hash values.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue contains method always returns false though elemenet exist in priority queue\r\n                \r\nPriority Queue contains method always returns false though element exist in priority queue. I am not getting to know how and where to override the compare method. This is the program for Dijkstra algorithm using adjacency List.\nHow to implement @Override compare method in this code.\n\n```\n import java.util.*;\nclass dijkstra{\nclass AdjListNode{\n    private int vertex,weight;\n    AdjListNode(int v,int w){vertex=v;weight=w;}\n    int getv(){return vertex;}\n    int getw(){return weight;}        \n@Override\n    public boolean equals(AdjListNode obj){\n        return (obj.getv() == this.vertex && obj.getw()==this.weight);\n    }\n}\nclass Graph{\n    private int V;\n    private LinkedList<AdjListNode> adj[];\n    Graph(int v){\n        V=v;\n        adj=new LinkedList[v];\n        for(int i=0;i<V;i++){\n            adj[i]=new LinkedList<AdjListNode>();\n        }\n    }\n    void addEdge(int u,int v,int w){\n        //undirected graph so edges are added bothways\n        AdjListNode node1=new AdjListNode(v,w);\n        adj[u].add(node1);\n    }\n    void print(){\n        for(int i=0;i<V;i++){\n            Iterator<AdjListNode> itr=adj[i].listIterator();\n            System.out.print(i+\"==>\");\n            while(itr.hasNext()){\n                AdjListNode node=itr.next();\n                System.out.print(\"(\"+node.getv()+\",\"+node.getw()+\") \");\n            }\n            System.out.println();\n        }\n    }\n    void sssp(int src){\n        PriorityQueue<AdjListNode> q = new PriorityQueue<AdjListNode>(V, new Comparator<AdjListNode>() {\n              @Override\n              public int compare(AdjListNode node1, AdjListNode node2) {\n                  return Integer.compare(node1.getw(), node2.getw());\n              }\n        });\n        q.add(new AdjListNode(0,0));\n        int dist[]=new int[V];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[src]=0;\n        while(q.size()!=0){\n            AdjListNode node=q.peek();\n            Iterator<AdjListNode> itr=adj[node.getv()].listIterator();\n            q.poll();\n            while(itr.hasNext()){\n                AdjListNode temp=itr.next();\n                if(dist[temp.getv()]>dist[node.getv()]+temp.getw()){\n                    int oldweight=dist[temp.getv()];\n                    dist[temp.getv()]=dist[node.getv()]+temp.getw();\n                    //System.out.println(node.getv()+\" \"+temp.getv()+\" \"+oldweight+\" \"+q.contains(new AdjListNode(temp.getv(),oldweight)));\n                    if(q.contains(new AdjListNode(temp.getv(),oldweight))){\n                        System.out.println(\"yes\");\n                        q.remove(new AdjListNode(temp.getv(),oldweight));\n                        q.add(new AdjListNode(temp.getv(),dist[temp.getv()]));\n                    }                           \n                    else{\n                        q.add(new AdjListNode(temp.getv(),dist[temp.getv()]));\n                        //System.out.println(q.contains(new AdjListNode(temp.getv(),dist[temp.getv()])));\n                    }\n                }\n            }\n        }\n        for(int i=0;i<V;i++)\n            System.out.print(dist[i]+\" \");\n    }\n\n}\nGraph newGraph(int vertices){\n    return new Graph(vertices);\n}\npublic static void main(String[] args){\n    dijkstra d=new dijkstra();\n    Graph g=d.newGraph(6);\n    g.addEdge(0,1,2);\n    g.addEdge(0,3,30);\n    g.addEdge(0,5,40);\n    g.addEdge(0,4,5);\n    g.addEdge(0,2,60);\n    g.addEdge(1,4,11);\n    g.addEdge(1,3,5);\n    g.addEdge(1,2,2);\n    g.addEdge(1,5,4);\n    g.addEdge(2,1,3);\n    g.addEdge(2,3,1);\n    g.addEdge(2,4,3);\n    g.addEdge(3,4,3);\n    g.addEdge(3,5,11);\n    g.addEdge(4,3,2);\n    g.addEdge(4,5,12);\n    g.print();\n    g.sssp(0);\n}\n```\n\n\n}\n\nThe output is not showing any error and returning the correct result but there is some error going on and contains method is not working. Please suggest the correct approach.\n    ", "Answer": "\r\nYou should override the ```\nequals```\n method in ```\nAdjListNode```\n (and ```\nhashCode```\n as well, in a way that is consistent with your ```\nequals```\n implementation, though in this particular case I believe the method isn't called directly, but it's a good practice that will prevent lots of problems in the future).\n\nThe contains method requires this method to check if two objects in the queue are identical, and the default implementation in Object only checks if they are the exact same instance, which is not the case in your algorithm (at a quick glance)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue with change priority feature, which keeps elements ordered\r\n                \r\nI'm looking for a way to schedule threads by priorities and First-Come-First Serve (FCFS) if two threads have the same priority. I was thinking about using a heap of queues or something like that. The problem is that, even if I implement my own priority queue, the ability to change priorities ruins the order of the insertion to this queue.\n\nTo solve this problem I can save the insertion time of each thread, and sort the priority queue also by the insertion time (as a secondary parameter to the primary Priority parameter), but I believe that there is a combination of data structures which can solve the problem without usage of the insertion time.\n\nThe complexity should be ```\nO(logN)```\n (there are some naive solutions with ```\nO(N)```\n complexity, such as having a regular queue, and iterating the queue whenever we have to pop a thread).\n    ", "Answer": "\r\nMay be I didn't get your problem correctly but you could have a separate list for each priority.\nSo each thread is added to the corresponding list based on its priority. And since you always add at the end of the list and remove from the head you would have a FCFS behavior.  \n\nYou could also create a Priority Queue to retrieve the next thread with the lowest priority (O(1) to get next thread and O(logN) to insert. For comparison you could use a combination of priority and insert time of each node.  \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue with 2 Priority parameters\r\n                \r\nI have a class Person which implements Comparable as shown below because I want to put objects of Person in a priority queue.\n\n```\npublic class Student implements Comparable{\n    private String fullName;\n    private Date registrationDate;\n\npublic Person(String fullName){\n    this.fullName = fullName;\n}\n\npublic String getFullName() {\n    return fullName;\n}\n\npublic void setFullName(String fullName) {\n    this.fullName = fullName;\n}\n\npublic Date getRegistrationDate() {\n        return registrationDate;\n    }\n    public void setRegistrationDate(Date registrationDate) {\n        this.registrationDate = registrationDate;\n    }\n\n@Override\n    public int compareTo(Object obj) {\n        Person person = (Person) obj;\n\n        if(person instanceof Staff){\n            return 1; \n        }else if(person instanceof Student){\n            return -1;\n        }\n        else if(getRegistrationDate().before(person.getRegistrationDate())){\n            return 1;\n        }else if(getRegistrationDate().after(person.getRegistrationDate())){\n            return -1;\n        }\n        return 0;\n    }\n}\n```\n\n\nI have two classes that extend Person as follows\n\n```\npublic class Staff extends Person{\n    public Staff(String fullName){\n        this.fullName = fullName;\n     }\n}\n\npublic class Student extends Member{\n    public Student(String fullName){\n        this.fullName = fullName;\n     }\n}\n```\n\n\nIn the main method, I am creating objects of Staff and objects of Students, setting a registration date of the objects and putting them in a priority queue\n\n```\npublic class School {\n\n    public static void main(String args[]) {\n\n        //list of students\n        Student student1 = new Student(\"John Kent\");\n        Date dateStudent1Joined = new GregorianCalendar(2014, Calendar.JULY, 1).getTime();\n        student1.setRegistrationDate(dateStudent1Joined);\n\n        Student student2 = new Student(\"Peter Tush\");\n        Date dateStudent2Joined = new GregorianCalendar(2014, Calendar.JULY, 2).getTime();\n        student2.setRegistrationDate(dateStudent2Joined);\n\n        Student student3 = new Student(\"Mike Monroe\");\n        Date dateStudent3Joined = new GregorianCalendar(2014, Calendar.JULY, 3).getTime();\n        student3.setRegistrationDate(dateStudent3Joined);\n\n        Student student4 = new Student(\"Tom Johnson\");\n        Date dateStudent4Joined = new GregorianCalendar(2014, Calendar.JULY, 4).getTime();\n        student4.setRegistrationDate(dateStudent4Joined);\n\n        Student student5 = new Student(\"Tony Spencer\");\n        Date dateStudent5Joined = new GregorianCalendar(2014, Calendar.JULY, 5).getTime();\n        student5.setRegistrationDate(dateStudent5Joined);\n\n        //list of staff\n        Staff staff1 = new Staff(\"Luke Clint\");\n        Date dateStaff1Joined = new GregorianCalendar(2014, Calendar.JULY, 6).getTime();\n        staff1.setRegistrationDate(dateStaff1Joined);\n\n        Staff staff2 = new Staff(\"Ron West\");\n        Date dateStaff2Joined = new GregorianCalendar(2014, Calendar.JULY, 7).getTime();\n        staff2.setRegistrationDate(dateStaff2Joined);\n\n        Staff staff3 = new Staff(\"Jim Gary\");\n        Date dateStaff3Joined = new GregorianCalendar(2014, Calendar.JULY, 8).getTime();\n        staff3.setRegistrationDate(dateStaff3Joined);\n\n\n        //create a queue data structure to hold Persons in school\n        PriorityQueue<Person> schoolQueue = new PriorityQueue<Person>();\n        //add students to queue\n        schoolQueue.offer(student1);\n        schoolQueue.offer(student2);\n        schoolQueue.offer(student3);\n        schoolQueue.offer(student4);\n        schoolQueue.offer(student5);\n        //add staff to queue\n        schoolQueue.offer(staff1);\n        schoolQueue.offer(staff2);\n        schoolQueue.offer(staff3);\n\n        //print names of people in queue\n        for(Member member : clubQueue){\n            String memberName = member.getFullName();\n            System.out.println(memberName);\n        }\n\n    }\n}\n```\n\n\nMy priority queue should follow 3 rules\n1.Staff objects should have a higher priority than student objects\n2.Staff with an earlier registration date should have a higher priority than staff with a later registration date\n3.Students with an earlier registration date should have a higher priority than students with a later registration date.\n\nThe output I am getting does not yield the desired results at the moment. The staff objects have higher priority than the student objects but the priorities according to date is not working. I understand that the rules in my compareTo method is where the issue lies, how might I improve it?\nThis is it again for convenience\n\n```\n@Override\n        public int compareTo(Object obj) {\n            Person person = (Person) obj;\n\n            if(person instanceof Staff){\n                return 1; \n            }else if(person instanceof Student){\n                return -1;\n            }\n            else if(getRegistrationDate().before(person.getRegistrationDate())){\n                return 1;\n            }else if(getRegistrationDate().after(person.getRegistrationDate())){\n                return -1;\n            }\n            return 0;\n        }\n```\n\n    ", "Answer": "\r\nLet's start by making your Person class use generic types instead of raw types:\n\n```\npublic class Person extends Comparable<Person>\n```\n\n\nThen let's assign a priority to classes. You didn't tell how \"bare\" persons, which are neither staff nor student, should compare with other ones. I'll thus assume that \"bare\" persons shouldn't exist, and that your ```\nPerson```\n class should thus be abstract:\n\n```\npublic abstract class Person extends Comparable<Person>\n```\n\n\nThen you want each class to have a priority. So let's implement that, instead of relying on ugly ```\ninstanceof```\n:\n\n```\nprotected abstract int getPriority();\n```\n\n\nA Staff should come before a Student, so in Staff:\n\n```\n@Override\nprotected int getPriority() {\n    return 0;\n}\n```\n\n\nand in Student:\n\n```\n@Override\nprotected int getPriority() {\n    return 1000;\n}\n```\n\n\nNow let's implement the compareTo method:\n\n```\npublic int compareTo(Person other) {\n    int result = Integer.compare(this.getPriority(), other.getPriority());\n    if (result == 0) {\n        result = this.getRegistrationDate().compareTo(other.getRegistrationDate())\n    }\n    return result;\n}\n```\n\n\nNote that adding another kind of Person is trivial. You just need to return the appropriate value in getPriority, and the comparison code won't have to be changed.\n\nAlso notice that compareTo now takes a Person as argument, and that the compiler will now prevent you from doing silly things like ```\nperson.compareTo(\"foo\")```\n, because of the correct generic type.\n\nIf using Java 8, your compareTo method could be even simpler:\n\n```\nprivate static final Comparator<Person> COMPARATOR = \n    Comparator.comparingInt(Person::getPriority) \n              .thenComparing(Person::getRegistrationDate);\n\n@Override\npublic int compareTo(Person other) {\n    return COMPARATOR.compare(this, other);\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue using a Max-Heap Data Structure\r\n                \r\nI am implementing a priority queue using a max-heap data structure in Python. I'm using several names that have numbers associated with them as their priority (9 being the highest and 1 being the lowest). The issue I am facing is that when I dequeue an item from the priority queue, it does not dequeue the item with highest priority. I assume this means there is a problem with my enqueue and it is not inserting the items into the correct position in the heap based on their priority. If anyone could help me fix this, it would be greatly appreciated.\n\nMy priority queue code:\n\n```\nfrom Heap import Heap\n\nclass priorityQ(object):\n    def __init__(self):\n        self.PQ = Heap()\n\n    def enqueue(self, priority, item):\n        self.PQ.insert((priority, item))\n\n    def dequeue(self):\n        if self.PQ.size() == 0:\n            raise ValueError(\"Empty Queue\")\n        return self.PQ.delete_max()\n\n    def first(self):\n        return self.PQ.get_max()\n\n    def size(self):\n        return self.PQ.size()\n\ndef main():\n    myHeap = priorityQ()\n    print(myHeap.size())\n    myHeap.enqueue(8, \"Kaneda\")\n    myHeap.enqueue(6, \"Masaru\")\n    myHeap.enqueue(9, \"Akira\")\n    myHeap.enqueue(4, \" Kei\")\n    myHeap.enqueue(5, \"Takashi\")\n    myHeap.enqueue(2, \"Shikishima\")\n    myHeap.enqueue(3, \"Kiyoko\")\n    myHeap.enqueue(1, \"Yamagata\")\n    myHeap.enqueue(7, \"Tetsuo\")\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n    myHeap.dequeue()\n    print(myHeap.first())\n    print(myHeap.size())\n```\n\n\nOutput after I run the code and call main:\n\n```\n0\n(9, 'Akira')\n9\n(7, 'Tetsuo')\n8\n(5, 'Takashi')\n7\n(4, 'Kei')\n6\n(3, 'Kiyoko')\n5\n(2, 'Shikishima')\n4\n(1, 'Yamagata')\n3\n(1, 'Yamagata')\n2\n(1, 'Yamagata')\n1\nNone\n0\n```\n\n\nMax-heap code (provided by textbook):\n\n```\n# Heap.py\nclass Heap(object):\n\n    #------------------------------------------------------------\n\n    def __init__(self, items=None):\n\n        '''post: a heap is created with specified items'''\n\n        self.heap = [None]\n        if items is None:\n            self.heap_size = 0\n        else:\n            self.heap += items\n            self.heap_size = len(items)\n            self._build_heap()\n\n    #------------------------------------------------------------\n\n    def size(self):\n\n        '''post: returns number of items in the heap'''\n\n        return self.heap_size\n\n    #------------------------------------------------------------\n\n    def _heapify(self, position):\n\n        '''pre: items from 0 to position - 1 satisfy the heap property\n        post: heap property is satisfied for the entire heap'''\n\n        item = self.heap[position]\n        while position * 2 <= self.heap_size:\n            child = position * 2\n            # if right child, determine maximum of two children\n            if (child != self.heap_size and \n                self.heap[child+1] > self.heap[child]):\n                child += 1\n            if self.heap[child] > item:\n                self.heap[position] = self.heap[child]\n                position = child\n            else:\n                break\n        self.heap[position] = item\n\n    #------------------------------------------------------------\n\n    def delete_max(self):\n\n        '''pre: heap property is satisfied\n        post: maximum element in heap is removed and returned'''\n\n        if self.heap_size > 0:\n            max_item = self.heap[1]\n            self.heap[1] = self.heap[self.heap_size]\n            self.heap_size -= 1\n            self.heap.pop()\n            if self.heap_size > 0:\n                self._heapify(1)\n            return max_item\n\n    def get_max(self):\n        if self.heap_size > 0:\n            max_item = self.heap[1]\n            self.heap[1] = self.heap[self.heap_size]\n            if self.heap_size > 0:\n                self._heapify(1)\n            return max_item\n\n    #------------------------------------------------------------\n\n    def insert(self, item):\n\n        '''pre: heap property is satisfied\n        post: item is inserted in proper location in heap'''\n\n        self.heap_size += 1\n        # extend the length of the list\n        self.heap.append(None)\n        position = self.heap_size\n        parent = position // 2\n        while parent > 0 and self.heap[parent] < item:\n            # move item down\n            self.heap[position] = self.heap[parent]\n            position = parent\n            parent = position // 2\n        # put new item in correct spot\n        self.heap[position] = item\n\n    #------------------------------------------------------------\n\n    def _build_heap(self):\n\n        '''pre: self.heap has values in 1 to self.heap_size \n        post: heap property is satisfied for entire heap'''\n\n        # 1 through self.heap_size\n        for i in range(self.heap_size // 2, 0, -1): # stops at 1\n            self._heapify(i)\n\n    #------------------------------------------------------------\n\n    def heapsort(self):\n\n        '''pre: heap property is satisfied\n        post: items are sorted in self.heap[1:self.sorted_size]'''\n\n        sorted_size = self.heap_size\n        for i in range(0, sorted_size - 1):\n            # Since delete_max calls pop to remove an item, we need \n            # to append a dummy value to avoid an illegal index.\n            self.heap.append(None)\n            item = self.delete_max()\n            self.heap[sorted_size - i] = item\n```\n\n    ", "Answer": "\r\nYour problem seems to be in your enqueue.\n\n```\ndef enqueue(self, item, priority):\n        self.PQ.insert(item)\n```\n\n\nThe priority parameter is not used at all. Instead, your heap is using string comparisons. \n\nThis is the state of your heap before any dequeue:\n\n```\n[None, 'Yamagata', 'Tetsuo', 'Shikishima', 'Takashi', 'Masaru', 'Akira', 'Kiyoko', 'Kei', 'Kaneda']\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Unsorted doubly linked list for priority queue of strings in C++\r\n                \r\nI am trying to implement a \"priority\" queue of strings with an unsorted doubly linked list but I am totally stuck on the dequeue method (at the bottom of the code / there might be issues before however). By priority queue I mean a queue in which the first element to be dequeued is the minimum element.\n\nWould you mind having a look at my code and give me few hints on where I am wrong?\n\nThanks a lot for your help.\n\nmatt\n\n```\n/*************************************************************\n * File: pqueue-doublylinkedlist.cpp\n *\n * Implementation file for the DoublyLinkedListPriorityQueue\n * class.\n */\n\n#include \"pqueue-doublylinkedlist.h\"\n#include \"error.h\"\n\n/* Implementation notes: DoublyLinkedListPriorityQueue constructor\n * ----------------------------------------------------------------\n * This function initializes an empty priority queue represented as a doubly \n * linked-list.\n */\n\nDoublyLinkedListPriorityQueue::DoublyLinkedListPriorityQueue() {\n    listHead = new Cell;\n    listHead = NULL;\n    count = 0;\n}\n\n/* Implementation notes: DoublyLinkedListPriorityQueue destructor\n * --------------------------------------------------------------\n * This function deletes every cell in the priority queue.\n */\n\nDoublyLinkedListPriorityQueue::~DoublyLinkedListPriorityQueue() {\n    Cell *temp, *link;\n    temp = link = new Cell;\n\n    temp = listHead;\n    while (temp != NULL) {\n        link = temp->next;\n        delete temp;\n        temp = link;\n    }\n    count = 0;\n}\n\n/* Implementation notes: DoublyLinkedListPriorityQueue size\n * --------------------------------------------------------\n * Returns the size of the priority queue.\n */\n\nint DoublyLinkedListPriorityQueue::size() {\n    return count;\n}\n\n/* Implementation notes: DoublyLinkedListPriorityQueue isEmpty\n * -----------------------------------------------------------\n * Returns true if there is no cell within the list.\n */\n\nbool DoublyLinkedListPriorityQueue::isEmpty() {\n    return (count == 0);\n}\n\n/* Implementation notes: DoublyLinkedListPriorityQueue enqueue\n * -----------------------------------------------------------\n * Enqueues the new Cell into the chain just after the head Cell.\n */\n\nvoid DoublyLinkedListPriorityQueue::enqueue(string value) {\n\n    Cell *newOne = new Cell;\n    newOne->str = value;\n    newOne->prev = NULL;\n\n    newOne->next = listHead;\n    listHead = newOne;\n\n    count++;\n}\n\n/* Implementation notes: DoublyLinkedListPriorityQueue peek\n * --------------------------------------------------------\n * Returns the string value of the next node to be dequeued.\n */\n\nstring DoublyLinkedListPriorityQueue::peek() {\n    if (isEmpty()) error(\"peek an empty list\");\n\n    curr = new Cell;\n\n    curr = listHead;\n    string result = listHead->str;\n\n    for (curr = listHead; curr != NULL; curr = curr->next) {\n        if (curr->str != \"\" && curr->str < result) {\n            result = curr->str;\n        }\n    }\n\n    return result;\n}\n\n/* Implementation notes: DoublyLinkedListPriorityQueue dequeueMin\n * --------------------------------------------------------------\n * Deletes the node with the smallest string and returns this string value.\n */\n\nstring DoublyLinkedListPriorityQueue::dequeueMin() {\n    if (isEmpty()) error(\"dequeueMin an empty list\");\n\n    Cell *temp;\n    temp = curr = new Cell;\n    temp = curr = NULL;\n\n    string result = listHead->str;\n\n    // find the node to delete and store a pointer on it\n    for (curr = listHead; curr != NULL; curr = curr->next) {\n        if (curr->str != \"\" && curr->str < result) {\n            result = curr->str;\n            temp = curr;\n        }\n    }\n\n    // first position (if: node to delete prev == NULL)\n    if (temp->prev == NULL) {\n        temp = listHead->next;\n        delete listHead;\n        listHead = temp;\n\n    // delete from last position (else if: node to delete next == NULL)\n    } else if (temp->next == NULL) {\n        curr = temp->prev;\n        curr->next = NULL;\n        delete temp;\n\n    // other position (else)\n    } else {\n        temp->prev->next = temp->next;\n        temp->next->prev = temp->prev;\n        delete temp;\n    }\n\n    count--;\n\n    return result;\n}\n```\n\n    ", "Answer": "\r\nImplementing a priority queue as a doubly-linked list (or, indeed, implementing one at all) is pretty unusual, since there's an STL implementation available to use:\n\n```\n#include <iostream>\n#include <queue>\n#include <functional>\n\nint main(void) {\n    std::priority_queue<std::string, std::vector<std::string>,\n            std::greater<std::string> > pq;\n\n    pq.push(\"foo\");\n    pq.push(\"bar\");\n    pq.push(\"quux\");\n\n    while( !pq.empty() ) {\n        std::cout << pq.top() << std::endl;\n        pq.pop();\n    }\n\n    return 0;\n}\n```\n\n\nI'm posting this on the assumption that, perhaps, you simply didn't know that this functionality was available, rather than there there is a real reason why you want to do your own implementation and do it in a rather odd way.\n\nIf I'm wrong, and the above pointer is no use to you, I'd recommend adapting your implementation to the interface of the standard version (as much as you can) and explaining why you don't want to use the STL version, as these steps will increase the familiarity of your code for StackOverflow users (both those who might answer your question better than I can, and future users with similar questions).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue Rearranging Itself After Poll Method is Called\r\n                \r\nI have a class Student which implements Comparable as shown below because I want to put objects of Student in a priority queue and have students who have an earlier registration date to have a higher priority.\n\n```\npublic class Student implements Comparable{\n    private String fullName;\n    private Date registrationDate;\n\npublic Student(String fullname){\n    this.fullName = fullName;\n}\n\n\n\npublic String getFullName() {\n    return fullName;\n}\n\npublic void setFullName(String fullName) {\n    this.fullName = fullName;\n}\n\npublic Date getRegistrationDate() {\n        return registrationDate;\n    }\n    public void setRegistrationDate(Date registrationDate) {\n        this.registrationDate = registrationDate;\n    }\n\n@Override\n    public int compareTo(Object obj) {\n        Student student = (Student) obj;\n\n        if(getRegistrationDate().before(student.getRegistrationDate())){\n            return 1;\n        }else if(getRegistrationDate().after(student.getRegistrationDate())){\n            return -1;\n        }\n        return 0;\n    }\n}\n```\n\n\nIn the main method, I am creating objects of students, setting a registration date and putting them in a priority queue\n\n```\npublic class School {\n\n    public static void main(String args[]) {\n\n        //list of students\n        Student student1 = new Student(\"John Doe\");\n        Date dateStudent1Joined = new GregorianCalendar(2014, Calendar.JULY, 1).getTime();\n        student1.setRegistrationDate(dateStudent1Joined);\n\n        Student student2 = new Student(\"Mary Penn\");\n        Date dateStudent2Joined = new GregorianCalendar(2014, Calendar.JULY, 2).getTime();\n        student2.setRegistrationDate(dateStudent2Joined);\n\n        Student student3 = new Student(\"George Coats\");\n        Date dateStudent3Joined = new GregorianCalendar(2014, Calendar.JULY, 3).getTime();\n        student3.setRegistrationDate(dateStudent3Joined);\n\n        Student student4 = new Student(\"Tony Case\");\n        Date dateStudent4Joined = new GregorianCalendar(2014, Calendar.JULY, 4).getTime();\n        student4.setRegistrationDate(dateStudent4Joined);\n\n        Student student5 = new Student(\"Ben Thomas\");\n        Date dateStudent5Joined = new GregorianCalendar(2014, Calendar.JULY, 5).getTime();\n        student5.setRegistrationDate(dateStudent5Joined);\n\n        //create a queue data structure to hold students\n        PriorityQueue<Student> studentQueue = new PriorityQueue<Student>();\n        //add students to queue\n        studentQueue.offer(student1);\n        studentQueue.offer(student2);\n        studentQueue.offer(student3);\n        studentQueue.offer(student4);\n        studentQueue.offer(student5);\n\n        //print names of people in queue\n        for(Student student : studentQueue){\n            String studentName = student.getFullName();\n            System.out.println(studentName);\n            System.out.println(\"\");\n\n        }\n\n            studentQueue.poll();    \n\n        for(Student student : studentQueue){\n            String studentName = student.getFullName();\n            System.out.println(studentName);\n        }\n    }\n}\n```\n\n\nIn the first for loop inside School.java, I print out the names of all the students on the queue to ensure they are in the correct priority, which is that student with the earlier registration dates are in front of the queue. The result here is what I expect because John Doe joined first and Ben Thomas joins last.\n\n```\nJohn Doe\nMary Penn\nGeorge Coats\nTony Case\nBen Thomas\n```\n\n\nHowever, when I call the poll() method on the priority queue, John Doe is removed but the order of the priority queue no longer makes sense, the output from the second for loop is\n\n```\nMary Penn\nTony Case\nGeorge Coats\nBen Thomas\n```\n\n\nMary Penn is in the right position but George Coats should come before Tony Case if the order in the previous priority queue still holds sway, what am I doing wrong here?\n    ", "Answer": "\r\nLook at this. The iteration order of a ```\nPriorityQueue```\n is not guaranteed to be sorted. When you call ```\npoll()```\n several more times, you will find the order is actually correct.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Changing Java PriorityQueue to a Max PQ [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Change priorityQueue to max priorityqueue\r\n                            \r\n                                (20 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nThe Priority Queue implementation in the Java standard library appears to be a min Priority Queue which I found somewhat confusing. In order to turn it into a max one I created a custom comparator object.\n\n```\nComparator<Integer> cmp = new Comparator<Integer>()\n{\n    public int compare( Integer x, Integer y )\n    {\n        return y - x;\n    }\n};\n```\n\n\nI was wondering if there was a more elegant solution. Essentially I wan't a generic priority queue that could be used to implement Dijkstras etc. I didn't even realise there would be ones which operated in reverse :/\n    ", "Answer": "\r\nHere is a code snippet using ```\nCollections.reverseOrder()```\n-\n\n```\n    PriorityQueue<Integer> maxPQ = new PriorityQueue<Integer>(20,Collections.reverseOrder());\n```\n\n\nYou also need to provide the initial capacity of the Priority Queue (20 here) along with the Comparator.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I make a unique value priority queue in Python?\r\n                \r\nPython has Queue.PriorityQueue, but I cannot see a way to make each value in it unique as there is no method for checking if a value already exists (like find(name) or similar). Moreover, PriorityQueue needs the priority to remain within the value, so I could not even search for my value, as I would also have to know the priority. You would use (0.5, myvalue) as value in PriorityQueue and then it would be sorted by the first element of the tuple.\n\nThe collections.deque class on the other hand does offer a function for checking if a value already exists and is even more natural in usage (without locking, but still atomic), but it does not offer a way to sort by priority.\n\nThere are some other implementations on stackoverflow with heapq, but heapq also uses priority within the value (e.g. at the first position of a tuple), so it seems not be great for comparison of already existing values.\n\nCreating a python priority Queue\n\nhttps://stackoverflow.com/questions/3306179/priority-queue-problem-in-python\n\nWhat is the best way of creating a atomic priority queue (=can be used from multiple threads) with unique values?\n\nExample what I’d like to add:\n\n\nPriority: 0.2, Value: value1\nPriority: 0.3, Value: value2\nPriority: 0.1, Value: value3 (shall be retrieved first automatically)\nPriority: 0.4, Value: value1 (shall not be added again, even though it has different priority)\n\n    ", "Answer": "\r\nYou could combine a priority queue with a set:\n```\nimport heapq\n\nclass PrioritySet(object):\n    def __init__(self):\n        self.heap = []\n        self.set = set()\n\n    def add(self, d, pri):\n        if not d in self.set:\n            heapq.heappush(self.heap, (pri, d))\n            self.set.add(d)\n\n    def pop(self):\n        pri, d = heapq.heappop(self.heap)\n        self.set.remove(d)\n        return d\n```\n\nThis uses the priority queue specified in one of your linked questions. I don't know if this is what you want, but it's rather easy to add a set to any kind of queue this way.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "All purpose of binary heap\r\n                \r\n\nDefinition:\nA priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a \"priority\" associated with it. In a priority queue, an element with high priority is served before an element with low priority. If two elements have the same priority, they are served according to their order in the queue.\nImplementation:\nTo implement Priority queue, unsorted array, sorted array and binary heap data structure are the 3 implementation strategies .\nTo be specific, binary heap implementation strategy can be represented using array of keys,\n\nor\neach key as binary node having two children.\n\n\n\nQuestion:\nApart from priority queue implementation, Are their any other applications of using binary heap data structure?\n    ", "Answer": "\r\nA binary heap can be used to extract (max or min) element in O(logn) time. This property can be exploited to be used in many algorithms to get better run-time.\n\nFor example, once I used it in k-merge sort algorithm to increase time efficiency of sorting step of the k-merge sort. In brief, it made binary heaps of the k-subarrays, and the sorting can be achieved in linear time which is better than usual sorting step of a merge sort.\n\nIt is also used in  Dijkstra's algorithm, Prim's algorithm to decrease their run time. \n\nYou can also take a look here\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Python Priority Queue for node\r\n                \r\nSo I found the heapq implementation, but that does not seem to work for my purposes. I need a priority queue where the priority is given by a function manhattan_distance(node, end_node) that stores the node. Heapq seems to only work for integers and gives no way to store the nodes?\n\nWhat is my best option for implementing this without having to write my own class?\n\nAny advice would be greatly appreciated.\n    ", "Answer": "\r\nActually I figured it out. I can use PriorityQueue from the Queue class. I didn't realize you could put tuples into it. \n\nSorry!\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Does Fortran have a priority queue?\r\n                \r\nI've used a number of computer languages and have grown used to common data structures being provided via standard libraries for the programmer. I'm 1337 enough to implement these myself, but recognize that having a single, standardized data structure implementation improves code readability and portability, while reducing the chance of bugs.\n\nNow I'm working with Fortran, and I'm looking for such a library. Googling for \"priority queue\" coupled with C++ or Python brings up nice documentation of nice libraries. Doing the same with Fortran brings up RosettaCode and some site from 1997 as the top two results.\n\nDoes Fortran have a priority queue? Or any library of standard data structures?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Having issues implementing remove within my Binary Heap/Priority Queue implementation\r\n                \r\nI'm trying to implement a remove method for my binary heap implementation. \n\n```\nclass Node {\n  constructor(priority) {\n    this.priority = priority;\n  }\n}\n\nclass PriorityQueue {\n  constructor() {\n    this.heap = [null];\n  }\n\nremove() {\n\n  const toRemove = this.heap[1];\n  this.heap[1] = this.heap.pop();  \n  let currentIdx = 1;\n  let [left, right] = [2*currentIdx, 2*currentIdx + 1]; \n  let currentChildIdx = this.heap[right] && this.heap[right].priority >= this.heap[left].priority ? right : left; //Assess which child node has higher priority\n\n  while (this.heap[currentChildIdx] && this.heap[currentIdx].priority <= this.heap[currentChildIdx].priority) { \n    let currentNode = this.heap[currentIdx]\n    let currentChildNode = this.heap[currentChildIdx];\n    this.heap[currentChildIdx] = currentNode;\n    this.heap[currentIdx] = currentChildNode;\n    currentIdx = this.heap.indexOf(currentNode);\n  }\n  return toRemove;\n}\n\n\n}\n```\n\n\nHowever, I'm not sure how to properly update the value of currentIdx and currentChildIdx when I'm running my while loop. In fact, the code seems to stop working when I try to update the value of currentIdx\n\n```\ncurrentIdx = this.heap.indexOf(currentNode);\n```\n\n\nAny tips on what I'm doing wrong?\n\nFull code here: https://repl.it/@Stylebender/Binary-Heap-Naive\n    ", "Answer": "\r\nIn the loop, once you swap the values for ```\ncurrentIdx```\n and ```\ncurrentChildIdx```\n, then you should assign ```\ncurrentIdx = currentChildIdx```\n.\n\nAnd once you change ```\ncurrentIdx```\n, you need to recompute the left and right child indexes and a new ```\ncurrentChildIdx```\n.\n\nThe basic idea is:\n\n```\nwhile currentIdx < heap_length\n    currentChildIdx = index of largest child\n    if (heap[currentIdx] >= heap[currentChildIdx])\n        break; // node is now in the right place\n    swap(heapCurrentIdx, heap[currentChildIdx)\n    currentIdx = currentChildIdx\n```\n\n\nMy suggestion is that you build that basic structure, and then single-step it in the debugger to make sure it's working as expected.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "can we use character value in priority queue? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                It's difficult to tell what is being asked here. This question is ambiguous, vague, incomplete, overly broad, or rhetorical and  cannot be reasonably answered in its current form. For help clarifying this question so that it can be reopened,  visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nCan we use character priorities like 'h' for high or 'l' for low in this case and use it to implement a priority queue?\n\n```\nstruct node {\nint data;\nchar c;\nstruct node *next;\n};\n```\n\n    ", "Answer": "\r\nWhile you can do that. I assume you simply want to use meaningful names for the priorities rather than magic numbers.\n\nYou may want to consider using an enum:\n\n```\nenum QueuePriority \n{\n  HIGH,\n  MEDUIM,\n  LOW\n};\n\nstruct node\n{\n  int data;\n  enum QueuePriority priority;\n  struct node *next;\n};\n```\n\n\nThis has the benefit of not having to create a custom comparison function/operator. Since the built-in will do as long as the enum values are in the right order.\n(I have them with ```\nHIGH == 0```\n as is the convention in some systems, but you can easily reverse that).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ using a priority queue of objects\r\n                \r\nI want to make a priority queue of objects, Specifically pair of (int, int). The queue should contain pairs with a priority assigned to them. \n\n```\n#include <iostream>\n#include <queue>\n\nusing namespace std;    \n\nclass saPair{\npublic:\n    int s;\n    int a;\n    double priority;\n    saPair(int s, int a, double priority){\n        this->s = s;\n        this->a = a;\n        this->priority = priority;\n    }\n};\n\n// the priority menmber variable determines the priority in the queue\n// highest priority pair of (int, int) stays on the top\nbool operator< (const saPair& x, const saPair& y) {\n    return x.priority < y.priority;\n}\n\n\nint main()\n{\n    priority_queue<saPair> pq;\n    pq.push(saPair(0,0, 0.3));\n    pq.push(saPair(0,1, 0.1));\n    pq.push(saPair(0,3, 0.5));\n    pq.push(saPair(0,3, 5));\n\n    cout << pq.top().a << endl;\n    pq.pop();\n    cout << pq.top().a << endl;\n    pq.pop();\n    cout << pq.top().a << endl;\n\n\n}\n```\n\n\nAs you can see, the pair (0,3) has highest priority so it stays on the top. But the problem with my implementation is that, if I add (0,3) pair again with different priority, I add a new element to the queue, instead of replacing the priority of the already existing (0,3) pair. \n\nI feel like I choose the wrong data structure for my requirement. I tried map taking key value, by defining a new saPair(int, int) class with operating overload for < operator. But even that doesn't seem to work properly.. \n\nAny suggestions on how to proceed? or modify \n    ", "Answer": "\r\nIt seems like you need a multi-key access to your container: you want to sort it by priority (or at least have a binary heap by priority as in ```\npriority_queue```\n), and you want the pair values to be unique, so you'll need a pair value lookup too.   \n\nThere is no default solution for that in standard library, but it shouldn't be too hard to craft your own.  \n\nI'd suggest simply storing an additional ```\nstd::set<saPair>```\n to check if the pair is already in your container. This way you can keep your ```\npriority_queue```\n the way it is, and it won't take too much effort to implement.  \n\nDon't forget to add ```\noperator<```\n to ```\nsaPair```\n though (or replace it by ```\nstd::pair```\n), otherwise ```\nstd::set```\n would not be able to work with it.\n\nAnother option is just manually check your ```\npriority_queue```\n for a pair every time you add it. While asymptotically worse than ```\nstd::set```\n solution, this might very well be faster in practice, and it will save you some space. However I think the code would be much cleaner if you go with ```\nstd::set```\n.  \n\nYet another solution is ```\nboost::multi_index```\n, which allows you to easily construct any multi-indexed container you want. However I don't think it'll let you capitalize on the fact that you don't need a strong ordering by priority, so it won't have a linear contiguous layout like ```\npriority_queue```\n does.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority queue in matlab\r\n                \r\nIs there any library in matlab that provides the functionality of min priorityqueue\n\n```\nimport java.util.PriorityQueue;\nimport java.util.*;\n\npublic class MyQueue {\n  Comparator<Double> c;\n  PriorityQueue<Double> PQ;\n\n  public MyQueue() {\n    c = new Comparator<Double>(){\n            public int compare(Double o1, Double o2){\n              if(o2 > o1) {\n                return -1;\n              } else if(o1 > o2) {\n                return 1;\n              } else {\n                return 0;\n              }\n            }\n        };\n    PQ = new PriorityQueue<Double>(1000,c);\n  }\n\n  public void addElement(double d) {\n    PQ.add(d);\n  }\n\n  public double removeElement() {\n    return(PQ.remove());\n  }\n}\n```\n\n\nI have implemented this priorty queue in java. I can call it from matlab. However, I need to associate each cost with an index. I mean it's not only cost of the node that i need to store but also its index. How can I accomplish this. I need to pass the index from matlab\n    ", "Answer": "\r\nYou can use Java's default ```\nPriorityQueue```\n like so: \n\n```\n>> q=java.util.PriorityQueue;\n>> q.add({value,index});\n```\n\n\nThis is available since Java ≥ 1.5, which is pre-bundled in all MATLAB releases since 7.0.4 (R14).  \n\nOtherwise, you can use the one from the file exchange, which you'll have to compile. \n\nThere's also a Simulink block for it, but I doubt that's what you're after.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a dequeue function for a node-based priority queue?\r\n                \r\nA PQ where the ```\nenqueue```\n method always adds an item to the end of the list, and the ```\ndequeue```\n method searches the list for the highest-priority item and removes it from wherever it is. If you remove a node from the middle or end of the list, you will need to make sure to adjust the pointers to the nodes around it so the list doesn’t break.\n```\n  def dequeue(self):\n        #searches the list for the highest-priority item and removes it from wherever it is\n        if self._length > 0: #returns None if there is nothing in the queue\n            \n            temp=self._front\n            temp2=self._front.get_next()\n\n            while temp2!=self._rear: \n                if temp.get_data()>temp2.get_data(): #switch signs\n                    temp=temp.get_next()\n                    temp2=temp2.get_next()\n                    #what do i need to do when it finds the highest priority item?????\n            self._length-=1 #subtract one from the length\n        return None\n```\n\nI know how to implement a regular linked queue, but I'm not sure what to do once it finds the highest priority item. Thank you!\n    ", "Answer": "\r\nI would do it by something like that:\n```\n def dequeue(self):\n    #searches the list for the highest-priority item and removes it from wherever it is\n    if self._length > 0: #returns None if there is nothing in the queue\n        \n        best=self._front\n        prev=None\n        temp=self._front.get_next()\n\n        while temp!=self._rear: \n            if temp.get_next().get_data()>best.get_data(): \n                best=temp.get_next() # set new best item\n                prev=temp # set it's predecesor\n            temp=temp.get_next()\n        prev._next=best.get_next()  # I assume that '_next' is a name for field with reference to the next item, we want to replace it from best (which we will delete) to the next one\n        self._length-=1 #subtract one from the length\n        return best\n    return None\n```\n\nAdditionally I think it could be more clear and also easier to organise your queue while inserting elements instead of searching for the pritity much (but I understand that it is the matter of preference and specific case)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ priority queue does not sort\r\n                \r\nI tried to implement a priority queue in C++ with a custom Class and Compare struct, but whenever I push a new element the queue doesn´t sort itself.\n\nIn Header:\n\n```\nprivate:\n    std::priority_queue<Node*, std::vector<Node*>, NodeCompare> queue;\n```\n\n\nStruct:\n\n```\nstruct NodeCompare\n{\n    bool operator()(Node* n1, Node* n2) \n    {\n        int val1 = n1->getValue();\n        int val2 = n2->getValue();\n        return val1 < val2;\n    }\n};\n```\n\n\nIn Class:\n\n```\nNode* node = new Node(nrInTree, value);\nqueue.push_back(node);\n```\n\n\nAny ideas?\n    ", "Answer": "\r\nYour code is correct. But I think you have a misunderstanding here.\nBecause priority_queue is implemented using data structure heap.\nAs we know, heap is not sorted. It only has the property that the maximum element\nis at the front. Every time, you insert an element into a heap, heap will use O(lgN)\ntime to push the maximum into the front.\nAnd every time you pop an element, the largest element will be obtained.\nBut heap is not sorted at all.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Zookeeper priority queue \r\n                \r\nMy problem description is follows:\nI have n state based database infinite crawlers:\nCurrently how it is happening:\n\n\nWe are using single machine for crawling.\nWe have three level of priority queue. High, Medium and LOW.\nAt starting all Database job are put into lower level queue.\nWorker reads a job from queue and do operation.\nAfter finishing job it reschedule it with a delay of 5 minutes.\n\n\nSolution I found\n\nFor Priority Queue I can use:\n\n-\n   http://zookeeper.apache.org/doc/r3.2.2/recipes.html#sc_recipes_priorityQueues\n\nProblem solution I am still searching are:\n\n\nHow to reschedule a job in queue with future schedule time. Is there\na way to do that in zookeeper ?\nCanceling a already started job. Suppose user change his database\nauthentication details. I want to stop already running job for that\ndatabase and restart with new details.\n What I thought is while starting a worker It will subscribe for that\nit's znode changes and if something happen, It will stop that job and\nreschedule it.\nInfinite Queue\nWhat I thought is that after finishing it will remove it from queue and\nreadd it with future schdule time. (It implementation depend on point 1)\n\n\nIs it correct way of doing this task infinite task?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue with Doubly Linked List Insertion\r\n                \r\nI am implementing a priority queue waitlist using a doubly linked list. My method creates a new node (priority and student id). Depending on the node priority the method will sort the node into the queue.\n\n```\nwhat I get is                                what I should get\n\nWaitlisted:             109 in 2123      |   Waitlisted:             109 in 2123\nCurrent waitlist:       109              |   Current waitlist:       109\n                                         |\nWaitlisted:             105 in 2123      |   Waitlisted:             105 in 2123\nCurrent waitlist:       105              |   Current waitlist:       105 109\n                                         |\nWaitlisted:             108 in 2123      |   Waitlisted:             108 in 2123\nCurrent waitlist:       109 105          |   Current waitlist:       105 108 109\n                                         |\nWaitlisted:             106 in 2123      |   Waitlisted:             106 in 2123\nCurrent waitlist:       106              |   Current waitlist:       105 106 108 109\n                                         |\nWaitlisted:             107 in 2123      |   Waitlisted:             107 in 2123\nCurrent waitlist:       109 106          |   Current waitlist:       105 106 107 108 109\n```\n\n\nI am able to insert a new node when the queue is empty on the first loop. Starting from the 2nd run the return values of the queue are wrong.\n\nCode\n\n```\nvoid enqueue( PQNode** ppFront, WaitlistEntry info ){\n    /* create a new node to store the info */\n    PQNode *temp = (PQNode*)malloc(sizeof(PQNode)); //create a new node to store the info\n    temp->info = info;\n    temp->pNext = NULL;\n    temp->pPrev = NULL;\n\n    /* check if the LL is empty and add the new node to the front if it is */\n    if(*ppFront == NULL){\n        *ppFront = temp;\n        return;\n    }\n\n    /* check if the new node should come before the first node in the LL */\n    if(temp->info.iPriority > (*ppFront)->info.iPriority){\n        temp->pNext = *ppFront;\n        (*ppFront)->pPrev = temp;\n        *ppFront = temp;\n        return;\n    }   \n\n    /* walk back through the previous nodes in the LL until the correct insertion point is found */\n    /* remember to also check whether the previous node is NULL */\n    while((*ppFront)->pNext != NULL && temp->info.iPriority <= (*ppFront)->info.iPriority){\n        *ppFront = (*ppFront)->pNext;\n    }\n\n    /* insert the new node into the place you found with your loop */\n    /* note you may need a special case for when the previous node is NULL */\n    if((*ppFront)->pNext == NULL){\n        (*ppFront)->pNext = temp;\n        temp->pPrev = *ppFront;\n        return;\n    }\n    temp->pPrev = *ppFront;\n    temp->pNext = (*ppFront)->pNext;\n    (*ppFront)->pNext->pPrev = temp;\n    (*ppFront)->pNext = temp;\n    return;\n}\n```\n\n\nStructs\n\n```\ntypedef struct{\n    int iPriority;          /* Priority of the student to be enrolled */\n    int iStudentID;         /* ID of the student */\n} WaitlistEntry;\n\ntypedef struct PQNode {\n    WaitlistEntry info;     /* WaitlistEntry stored in the node (sorted with largest priority first) */\n    struct PQNode* pNext;   /* Pointer to next node in the LL */\n    struct PQNode* pPrev;   /* Pointer to previous node in the LL */\n} PQNode;\n\ntypedef struct{\n    int iCourseNumber;      /* Course number of the course */\n    int* iStudentIDs;       /* Array of IDs of students enrolled in the course */\n    int iNumEnrolled;       /* Number of Students currently enrolled in course */\n    int iMaxEnrolled;       /* Max number of Students that can enroll in the course */\n    PQNode* pFront;         /* Priority queue representing the waitlist for the course */\n} Course;\n```\n\n\nI've managed to fix up the code some, but I'm still stuck.\n    ", "Answer": "\r\nAs BLUEPIXY mentioned, the last bit of the function is a bit wrong (//edit you've changed your code in the meantime, I'm referring to your original code). When you go through the list in the ```\nwhile```\n block, and then you realize that ```\ncurr```\n is the tail, you fail to check whether you got there because either ```\ntemp```\ns priority is greater than the tail's or you've reached the end of the list and ```\ntemp```\n should become the new tail.\n\nAlso, the very last part you are inserting ```\ntemp```\n at the wrong side.\n\nThe last part of your code should like this\n\n// edit posting the whole code, I only changed the last bit of your function, and the parameters for ```\nenqueue```\n, much easier to write test code for this.\n\n```\nvoid print_queue(PQNode *queue)\n{\n    if(queue == NULL)\n    {\n        puts(\"empty queue\");\n        return;\n    }\n\n    for(;;)\n    {\n        printf(\"%d (priority %d)\", queue->info.iStudentID, queue->info.iPriority);\n        queue = queue->pNext;\n\n        if(queue == NULL)\n        {\n            puts(\"\");\n            return;\n        }\n\n        printf(\" <--> \");\n    }\n}\n\n\nvoid enqueue( PQNode** ppFront, int id, int prio ){\n    /* create a new node to store the info */\n    PQNode *temp = (PQNode*)malloc(sizeof(PQNode)); //create a new node to store the info\n    temp->info.iStudentID = id;\n    temp->info.iPriority = prio;\n    temp->pNext = NULL;\n    temp->pPrev = NULL;\n    PQNode *curr = *ppFront;\n\n\n    /* check if the LL is empty and add the new node to the front if it is */\n    if(curr == NULL){\n        *ppFront = temp;\n        return;\n    }\n\n    /* check if the new node should come before the first node in the LL */\n    if(temp->info.iPriority > curr->info.iPriority){\n        temp->pNext = *ppFront;\n        (*ppFront)->pPrev = temp;\n        *ppFront = temp;\n        return;\n    }   \n\n    /* walk back through the previous nodes in the LL until the correct insertion point is found */\n    /* remember to also check whether the previous node is NULL */\n    while(curr->pNext != NULL && temp->info.iPriority <= curr->info.iPriority){\n        curr = curr->pNext;\n    }\n\n\n\n    /* insert the new node into the place you found with your loop */\n    /* note you may need a special case for when the previous node is NULL */\n    if(curr->pNext == NULL){\n        // we don't know whether the while stopped because it reached the\n        // final node or the priority was greater, we have to check it\n        if(temp->info.iPriority <= curr->info.iPriority)\n        {\n            // the priority is smaller, temp should be the tail\n            curr->pNext = temp;\n            temp->pPrev = curr;\n            return;\n        } else {\n            // the priority is bigger, curr should the the tail\n            // this case is handled by the next section\n        }\n    }\n\n    temp->pPrev = curr->pPrev;\n    temp->pNext = curr;\n    curr->pPrev->pNext = temp;\n    curr->pPrev = temp;\n}\n\nint main(void)\n{\n    PQNode *queue = NULL;\n\n    enqueue(&queue, 109, 10);\n    enqueue(&queue, 105, 40);\n    enqueue(&queue, 108, 20);\n    enqueue(&queue, 110, 30);\n    enqueue(&queue, 911, 11);\n    enqueue(&queue, 219, 25);\n\n    print_queue(queue);\n\n    return 0;\n}\n```\n\n\nI get\n\n```\n105 (priority 40) <--> 110 (priority 30) <--> 219 (priority 25) <--> 108 (priority 20) <--> 911 (priority 11) <--> 109 (priority 10)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why is using a std::multiset as a priority queue faster than using a std::priority_queue?\r\n                \r\nI try to replace std::multiset with std::priority_queue. But I was dissapointed with the speed results. Running time of the algorithm increase by 50%...\n\nHere are the corresponding commands:\n\n```\ntop() = begin();\npop() = erase(knn.begin());\npush() = insert();\n```\n\n\nI am surprised with the speed of priority_queue implementation, I expected different results (better for PQ)... Conceptually, the multiset is being used as a priority queue. Why are the priority queue and the multiset have such different performance, even with ```\n-O2```\n?\n\nAverage of ten results, MSVS 2010, Win XP, 32 bit, method findAllKNN2 () (see bellow, please)\n\n```\nMS\nN           time [s]\n100 000     0.5\n1 000 000   8\n\nPQ\nN           time [s]\n100 000     0.8\n1 000 000   12\n```\n\n\nWhat could cause these results? No other changes of the source code have been made... Thanks for your help...\n\nMS Implementation:\n\n```\ntemplate <typename Point>\nstruct TKDNodePriority\n{\n    KDNode <Point> *node;\n    typename Point::Type priority;\n\n    TKDNodePriority() : node ( NULL ), priority ( 0 ) {}\n    TKDNodePriority ( KDNode <Point> *node_, typename Point::Type priority_ ) : node ( node_ ), priority ( priority_ ) {}\n\n    bool operator < ( const TKDNodePriority <Point> &n1 ) const\n    {\n            return priority > n1.priority;\n    }\n};\n\ntemplate <typename Point>\nstruct TNNeighboursList\n{\n    typedef std::multiset < TKDNodePriority <Point> > Type;\n};\n```\n\n\nMethod:\n\n```\ntemplate <typename Point>\ntemplate <typename Point2>\nvoid KDTree2D <Point>::findAllKNN2 ( const Point2 * point, typename TNNeighboursList <Point>::Type & knn, unsigned int k, KDNode <Point> *node, const unsigned int depth ) const\n{\n    if ( node == NULL )\n    {\n            return;\n    }\n\n    if ( point->getCoordinate ( depth % 2 ) <= node->getData()->getCoordinate ( depth % 2 ) )\n    {\n    findAllKNN2 ( point, knn, k, node->getLeft(), depth + 1 );\n    }\n\n    else \n    {\n            findAllKNN2 ( point, knn, k, node->getRight(), depth + 1 );\n    }\n\ntypename Point::Type dist_q_node = ( node->getData()->getX() - point->getX() ) * ( node->getData()->getX() - point->getX() ) +\n                             ( node->getData()->getY() - point->getY() ) * ( node->getData()->getY() - point->getY() );\n\nif (knn.size() == k)\n{\n    if (dist_q_node < knn.begin()->priority )\n    {\n        knn.erase(knn.begin());\n        knn.insert ( TKDNodePriority <Point> ( node,  dist_q_node ) );\n    }\n}\n\nelse\n{\n    knn.insert ( TKDNodePriority <Point> ( node,  dist_q_node ) );\n}\n\ntypename Point::Type dist_q_node_straight = ( point->getCoordinate ( node->getDepth() % 2 ) - node->getData()->getCoordinate ( node->getDepth() % 2 ) ) *\n                                                ( point->getCoordinate ( node->getDepth() % 2 ) - node->getData()->getCoordinate ( node->getDepth() % 2 ) ) ;\n\ntypename Point::Type top_priority =  knn.begin()->priority;\nif ( knn.size() < k ||  dist_q_node_straight <  top_priority )\n{\n            if ( point->getCoordinate ( node->getDepth() % 2 ) < node->getData()->getCoordinate ( node->getDepth() % 2 ) )\n            {\n        findAllKNN2 ( point, knn, k, node->getRight(), depth + 1 );\n    }\n\n    else\n    {\n        findAllKNN2 ( point, knn, k, node->getLeft(), depth + 1 );\n    }\n}\n}\n```\n\n\nPQ implementation (slower, why?)\n\n```\ntemplate <typename Point>\nstruct TKDNodePriority\n{\n    KDNode <Point> *node;\n    typename Point::Type priority;\n\n    TKDNodePriority() : node ( NULL ), priority ( 0 ) {}\n    TKDNodePriority ( KDNode <Point> *node_, typename Point::Type priority_ ) : node ( node_ ), priority ( priority_ ) {}\n\n    bool operator < ( const TKDNodePriority <Point> &n1 ) const\n    {\n            return priority > n1.priority;\n    }\n};\n\n\ntemplate <typename Point>\nstruct TNNeighboursList\n{ \n    typedef std::priority_queue< TKDNodePriority <Point> > Type;\n};\n```\n\n\nMethod:\n\n```\ntemplate <typename Point>\ntemplate <typename Point2>\nvoid KDTree2D <Point>::findAllKNN2 ( const Point2 * point, typename TNNeighboursList <Point>::Type & knn, unsigned int k, KDNode <Point> *node, const unsigned int depth ) const\n{\n\n    if ( node == NULL )\n    {\n            return;\n    }\n\n    if ( point->getCoordinate ( depth % 2 ) <= node->getData()->getCoordinate ( depth % 2 ) )\n    {\n    findAllKNN2 ( point, knn, k, node->getLeft(), depth + 1 );\n    }\n\n    else \n    {\n            findAllKNN2 ( point, knn, k, node->getRight(), depth + 1 );\n    }\n\ntypename Point::Type dist_q_node = ( node->getData()->getX() - point->getX() ) * ( node->getData()->getX() - point->getX() ) +\n                             ( node->getData()->getY() - point->getY() ) * ( node->getData()->getY() - point->getY() );\n\nif (knn.size() == k)\n{\n    if (dist_q_node < knn.top().priority )\n    {\n        knn.pop();\n\n        knn.push ( TKDNodePriority <Point> ( node,  dist_q_node ) );\n    }\n}\n\nelse\n{\n    knn.push ( TKDNodePriority <Point> ( node,  dist_q_node ) );\n}\n\ntypename Point::Type dist_q_node_straight = ( point->getCoordinate ( node->getDepth() % 2 ) - node->getData()->getCoordinate ( node->getDepth() % 2 ) ) *\n                                                ( point->getCoordinate ( node->getDepth() % 2 ) - node->getData()->getCoordinate ( node->getDepth() % 2 ) ) ;\n\ntypename Point::Type top_priority =  knn.top().priority;\nif ( knn.size() < k ||  dist_q_node_straight <  top_priority )\n{\n            if ( point->getCoordinate ( node->getDepth() % 2 ) < node->getData()->getCoordinate ( node->getDepth() % 2 ) )\n            {\n        findAllKNN2 ( point, knn, k, node->getRight(), depth + 1 );\n    }\n\n    else\n    {\n        findAllKNN2 ( point, knn, k, node->getLeft(), depth + 1 );\n    }\n}\n}\n```\n\n    ", "Answer": "\r\nFirst of all, author didn't provide minimal example of code that leads to mentioned performance drop.\nSecond, the question was asked 8 years ago, I'm sure compilers made a huge boost on performance.\n\nI've made a benchmark example where I take 1st element in the queue then push in back with another priority (simulating push of new element without creating one), doing that by count of elements in array ```\nkNodesCount```\n in a loop with ```\nkRunsCount```\n iterations. I'm comparing ```\npriority_queue```\n with ```\nmultiset```\n and ```\nmultimap```\n. I've decided include ```\nmultimap```\n for more precise comparsion. It's simple test is very close to author use case, also I've tried to reproduce structs he used in the code samples.\n\n```\n#include <set>\n#include <type_traits>\n#include <vector>\n#include <chrono>\n#include <queue>\n#include <map>\n#include <iostream>\n\ntemplate<typename T>\nstruct Point {\n    static_assert(std::is_integral<T>::value || std::is_floating_point<T>::value, \"Incompatible type\");\n    using Type = T;\n\n    T x;\n    T y;\n};\n\ntemplate<typename T>\nstruct Node {\n    using Type = T;\n\n    Node<T> * left;\n    Node<T> * right;\n    T data;\n};\n\ntemplate <typename T>\nstruct NodePriority {\n    using Type = T;\n    using DataType = typename T::Type;\n\n    Node<T> * node = nullptr;\n    DataType priority = static_cast<DataType>(0);\n\n    bool operator < (const NodePriority<T> & n1) const noexcept {\n        return priority > n1.priority;\n    }\n\n    bool operator > (const NodePriority<T> & n1) const noexcept {\n        return priority < n1.priority;\n    }\n};\n\n// descending order by default\ntemplate <typename T>\nusing PriorityQueueList = std::priority_queue<T>;\n\n// greater used because of ascending order by default\ntemplate <typename T>\nusing MultisetList = std::multiset<T, std::greater<T>>;\n\n// greater used because of ascending order by default\ntemplate <typename T>\nusing MultimapList = std::multimap<typename T::DataType, T, std::greater<typename T::DataType>>;\n\nstruct Inner {\n    template<template <typename> class C, typename T>\n    static void Operate(C<T> & list, std::size_t priority);\n\n    template<typename T>\n    static void Operate(PriorityQueueList<T> & list, std::size_t priority) {\n        if (list.size() % 2 == 0) {\n            auto el = std::move(list.top());\n            el.priority = priority;\n            list.push(std::move(el));\n        }\n        else {\n            list.pop();\n        }\n    }\n\n    template<typename T>\n    static void Operate(MultisetList<T> & list, std::size_t priority) {\n        if (list.size() % 2 == 0) {\n            auto el = std::move(*list.begin());\n            el.priority = priority;\n            list.insert(std::move(el));\n        }\n        else {\n            list.erase(list.begin());\n        }\n    }\n\n    template<typename T>\n    static void Operate(MultimapList<T> & list, std::size_t priority) {\n        if (list.size() % 2 == 0) {\n            auto el = std::move(*list.begin());\n            auto & elFirst = const_cast<int&>(el.first);\n            elFirst = priority;\n            el.second.priority = priority;\n            list.insert(std::move(el));\n        }\n        else {\n            list.erase(list.begin());\n        }\n    }\n};\n\ntemplate<typename T>\nvoid doOperationOnPriorityList(T & list) {\n    for (std::size_t pos = 0, len = list.size(); pos < len; ++pos) {\n        // move top element and update priority\n        auto priority = std::rand() % 10;\n        Inner::Operate(list, priority);\n    }\n}\n\ntemplate<typename T>\nvoid measureOperationTime(T & list, std::size_t runsCount) {\n    std::chrono::system_clock::time_point t1, t2;\n    std::uint64_t totalTime(0);\n    for (std::size_t i = 0; i < runsCount; ++i) {\n        t1 = std::chrono::system_clock::now();\n        doOperationOnPriorityList(list);\n        t2 = std::chrono::system_clock::now();\n        auto castedTime = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count();\n        std::cout << \"Run \" << i << \" time: \" << castedTime << \"\\n\";\n        totalTime += castedTime;\n    }\n\n    std::cout << \"Average time is: \" << totalTime / runsCount << \" ms\" << std::endl;\n}\n\nint main() {\n    // consts\n    const int kNodesCount = 10'000'000;\n    const int kRunsCount = 10;\n\n    // prepare data\n    PriorityQueueList<NodePriority<Point<int>>> neighboursList1;\n    MultisetList<NodePriority<Point<int>>> neighboursList2;\n    MultimapList<NodePriority<Point<int>>> neighboursList3;\n    std::vector<Node<Point<int>>> nodes;\n    nodes.reserve(kNodesCount);\n    for (auto i = 0; i < kNodesCount; ++i) {\n        nodes.emplace_back(decltype(nodes)::value_type{ nullptr, nullptr, { 0,0 } });\n        auto priority = std::rand() % 10;\n        neighboursList1.emplace(decltype(neighboursList1)::value_type{ &nodes.back(), priority });\n        neighboursList2.emplace(decltype(neighboursList2)::value_type{ &nodes.back(), priority });\n        neighboursList3.emplace(decltype(neighboursList3)::value_type{ priority, { &nodes.back(), priority } });\n    }\n\n    // do operation on data\n    std::cout << \"\\nPriority queue\\n\";\n    measureOperationTime(neighboursList1, kRunsCount);\n    std::cout << \"\\nMultiset\\n\";\n    measureOperationTime(neighboursList2, kRunsCount);\n    std::cout << \"\\nMultimap\\n\";\n    measureOperationTime(neighboursList3, kRunsCount);\n\n    return 0;\n}\n```\n\n\nI've made release build with /Ox using VS v15.8.9. Take a look on results for 10'000'000 items in 10 runs:\n\n```\nPriority queue\nRun 0 time: 764\nRun 1 time: 933\nRun 2 time: 920\nRun 3 time: 813\nRun 4 time: 991\nRun 5 time: 862\nRun 6 time: 902\nRun 7 time: 1277\nRun 8 time: 774\nRun 9 time: 771\nAverage time is: 900 ms\n\nMultiset\nRun 0 time: 2235\nRun 1 time: 1811\nRun 2 time: 1755\nRun 3 time: 1535\nRun 4 time: 1475\nRun 5 time: 1388\nRun 6 time: 1482\nRun 7 time: 1431\nRun 8 time: 1347\nRun 9 time: 1347\nAverage time is: 1580 ms\n\nMultimap\nRun 0 time: 2197\nRun 1 time: 1885\nRun 2 time: 1725\nRun 3 time: 1671\nRun 4 time: 1500\nRun 5 time: 1403\nRun 6 time: 1411\nRun 7 time: 1420\nRun 8 time: 1409\nRun 9 time: 1362\nAverage time is: 1598 ms\n```\n\n\nHmhmh, as you see ```\nmultiset```\n is just the same performance as ```\nmultimap```\n and ```\npriority_queue```\n is the most fastest (around 43% faster). So why is that happen?\n\nLet's start from ```\npriority_queue```\n, C++ standard doesn't tell us how to implement one or another container or structure, but in most cases it's based on a binary heap (look for msvc and gcc implementation)! In case of ```\npriority_queue```\n you have no access to any element except top, you can't iterate through them, get by index, or even take last element (it makes some space for optimization). Average insert for binary heap is O(1) and only the worst case is O(log n) and deletion is O(log n) since we taking element from the bottom then searching next high priority.\n\nWhat about ```\nmultimap```\n and ```\nmultiset```\n. They both usually implemented on red-black binary tree (look for msvc and gcc implementation), where average insert is O(log n) and deletion O(log n) either.\n\nFrom this point of view ```\npriority_queue```\n NEVER can be slower of ```\nmultiset```\n or ```\nmultimap```\n. So, back to your question, ```\nmultiset```\n as priority queue is NOT faster than ```\npriority_queue```\n itself. There might be plenty of reasons, including raw ```\npriority_queue```\n implementation on old compiler or wrong usage of this structure (the question doesn't contain minimal workable example), besides author did't mentioned compile flags or compiler version, sometimes optimization makes significant changes.\n\nUPDATE 1 upon @noɥʇʎԀʎzɐɹƆ request\n\nUnfortunately I don't have access to linux environment right now, but I have mingw-w64 installed, version info: g++.exe (x86_64-posix-seh, Built by strawberryperl.com project) 8.3.0. Used processor just the same as for visual studio: Processor Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz, 2001 Mhz, 4 Core(s), 8 Logical Processor(s).\n\nSo results for ```\ng++ -O2```\n is:\n\n```\nPriority queue\nRun 0 time: 775\nRun 1 time: 995\nRun 2 time: 901\nRun 3 time: 807\nRun 4 time: 930\nRun 5 time: 765\nRun 6 time: 799\nRun 7 time: 1151\nRun 8 time: 760\nRun 9 time: 780\nAverage time is: 866 ms\n\nMultiset\nRun 0 time: 2280\nRun 1 time: 1942\nRun 2 time: 1607\nRun 3 time: 1344\nRun 4 time: 1319\nRun 5 time: 1210\nRun 6 time: 1129\nRun 7 time: 1156\nRun 8 time: 1244\nRun 9 time: 992\nAverage time is: 1422 ms\n\nMultimap\nRun 0 time: 2530\nRun 1 time: 1958\nRun 2 time: 1670\nRun 3 time: 1390\nRun 4 time: 1391\nRun 5 time: 1235\nRun 6 time: 1088\nRun 7 time: 1198\nRun 8 time: 1071\nRun 9 time: 963\nAverage time is: 1449 ms\n```\n\n\nYou may notice it's almost the same picture as for msvc.\n\nUPDATE 2 thanks to @JorgeBellon\n\nA quick-bench.com online benchmark link, check it yourself!\n\nWould like to see any additions to my post, cheers!\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue - Skip List vs. Fibonacci Heap\r\n                \r\nI am interested in implementing a priority queue to enable an efficient Astar implementation that is also relatively simple (the priority queue is simple I mean). \n\nIt seems that because a Skip List offers a simple O(1) extract-Min operation and an insert operation that is O(Log N) it may be competitive with the more difficult to implement Fibonacci Heap which has O(log N) extract-Min and an O(1) insert. I suppose that the Skip-List would be better for a graph with sparse nodes whereas a Fibonacci heap would be better for an environment with more densely connected nodes. \n\nThis would probably make the Fibonacci Heap usually better, but am I correct in assuming that Big-Oh wise these would be similar?\n    ", "Answer": "\r\nThe raison d'etre of the Fibonacci heap is the O(1) decrease-key operation, enabling Dijkstra's algorithm to run in time O(|V| log |V| + |E|). In practice, however, if I needed an efficient decrease-key operation, I'd use a pairing heap, since the Fibonacci heap has awful constants. If your keys are small integers, it may be even better just to use bins.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "RabbitMQ in spring boot with priority queue\r\n                \r\nMy problem because I try to implement priority queue with rabbitMQ but its always random. Even when I set priority @RabbitListener(queues = QUEUE_MESSAGES, priority = \"10\").\nI send 100 messages to two queus :\n```\npublic void sendRequest() {\n        for (int i = 0; i < 100; i++) {\n            try {\n                rabbitTemplate.convertAndSend(ProducerConfig.QUEUE_MESSAGES2,\n                        new MessageDTO(\"Subject Two\", \"content2\"), message -> {\n                            message.getMessageProperties().setPriority(Integer.valueOf(10));\n                            return message;\n                        });\n\n\n                rabbitTemplate.convertAndSend(ProducerConfig.QUEUE_MESSAGES,\n                        new MessageDTO(\"Subject One\", \"content1\"), message -> {\n                            message.getMessageProperties().setPriority(Integer.valueOf(1));\n                            return message;\n                        });\n                System.out.println(\"messages has been send\");\n            } catch (AmqpException ex) {\n                System.out.println(ex.getMessage());\n            }\n        }\n    }\n```\n\nSo I have two listeners :\n```\n    @RabbitListener(queues = QUEUE_MESSAGES, priority = \"1\")\n    public void receiveMessage(MessageDTO message) throws BusinessException, InterruptedException {\n        try {\n            System.out.println(message.getSubject());\n        } catch (Exception ex) {\n            System.out.println(\"exception\" + ex.getMessage());\n        }\n    }\n\n    @RabbitListener(queues = QUEUE_MESSAGES2, priority = \"10\")\n    public void receiveMessage2(MessageDTO message) throws BusinessException, InterruptedException {\n        try {\n            System.out.println(message.getSubject());\n        } catch (Exception ex) {\n            System.out.println(\"exception\" + ex.getMessage());\n        }\n    }\n```\n\nMy output is random like this :\n```\nSubject One\nSubject Two\nSubject One\nSubject Two\nSubject One\nSubject Two\nSubject One\nSubject Two\nSubject One\nSubject Two\nSubject One\nSubject Two\nSubject One\nSubject Two\nSubject One\n```\n\nI need to receive all messages from first queue then receive messages from seconds queue. Can anybody help ?\nI already even try with this in application.properties :\n```\nspring.rabbitmq.listener.simple.prefetch=1\n```\n\nMy version is : RabbitMQ 3.8.12 Erlang 23.2.6\n#EDIT\nI set priority in producer config to queue and in sending request priority to messages but it deosnt helps\nProducer config :\n```\n@Bean\n    public Declarables fanoutBindings() {\n        Queue messageQueue = QueueBuilder.durable(QUEUE_MESSAGES)\n                .withArgument(\"x-dead-letter-exchange\", DLX_EXCHANGE_MESSAGES)\n                .withArgument(\"x-priority\", Integer.valueOf(1))\n                .build();\n        Queue messageQueue2 = QueueBuilder.durable(QUEUE_MESSAGES2)\n                .withArgument(\"x-dead-letter-exchange\", DLX_EXCHANGE_MESSAGES)\n                .withArgument(\"x-priority\", Integer.valueOf(10))\n                .build();\n        Queue deadLetterQueue = QueueBuilder.durable(QUEUE_MESSAGES_DLQ).build();\n        Queue parkingLotQueue = QueueBuilder.durable(QUEUE_PARKING_LOT).build();\n        FanoutExchange deadLetterExchange = new FanoutExchange(DLX_EXCHANGE_MESSAGES);\n\n        return new Declarables(\n                messageQueue,\n                parkingLotQueue,\n                deadLetterQueue,\n                messageQueue2,\n                deadLetterExchange,\n                BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange));\n    }\n```\n\n    ", "Answer": "\r\nThe ```\npriority```\n property on ```\n@RabbitListener```\n is the consumer priority. Consumers with higher priority will receive messages when they are active, while lower priority consumers will only get messages when higher priority consumers block. This assumes those consumers are consuming from the same queue, which is not your case.\nIf you want to implement priority messages, you need to define a Priority Queue with a max priority and set the priority property when sending the message (messages without priority will be treated as 0 priority).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement a priority queue using stack\r\n                \r\nMy idea is to add data into an ArrayList, sort it and then return the data to the Stack. It sounds circuitous but do you guys have better implementation?\n\n```\nclass MyPriorityQueue {\n  private Stack<Integer> st;\n  private ArrayList<Integer> list;\n\n  public MyPriorityQueue() { // The constructor\n    st = new Stack<Integer>();\n    list = new ArrayList<Integer>();\n  }\n\n  public void add(int e) { // To add one more item\n    list.add(e);\n\n  }\n\n  public int poll() { // To remove one item\n    if(!list.isEmpty())\n      sortListAndTransferToStack();\n    System.out.println(\"st.peek(): \" + st.peek());\n    return st.pop();\n\n  }\n\n  private void sortListAndTransferToStack() {\n    Collections.sort(list, Collections.reverseOrder());\n    st.clear();\n    for(int i=0; i<list.size(); i++) {\n      st.push(list.get(i));\n    }\n    list.clear();\n  }\n\n  public boolean isEmpty() { // To check whether the priority queue is empty.  Don't modify this method\n    return st.isEmpty();\n  }\n}\n```\n\n    ", "Answer": "\r\nYou could use 2 stacks instead of a list and a stack for a very simple implementation.\n\n1 Stack is just temporary. The other stack is the queue and the element you pop represents the next element in the queue.\n\nWhenever you add an element you could pop the stack until you've found the correct place to push the new element. Every popped element goes onto the temporary stack. Once you've pushed the newly added element you start to pop from the temporary stack and push the elements back onto the real stack.\n\nThis approach works better for a priority queue than for a simple queue since the correct place to add the new item is not always the very end of the stack. There are probably far more efficient implementations though.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue is not maintaining sorting order\r\n                \r\nPriority queue is not maintaining sorting order\nAm i implementing Comparable not properly?\nWrong sorting order is coming as output?\n\n```\nimport java.util.PriorityQueue;\n\n    class A implements Comparable \n    {\n        int i;\n        A(int i)\n        {\n            this.i =  i;\n\n        }\n        public int compareTo(Object obj)\n        {\n            return i - ((A)obj).i;\n        }\n        public String toString()\n        {\n            return Integer.toString(i);\n        }\n\n    }\n    class Manager11\n    {\n        public static void main(String[] args) \n        {\n            PriorityQueue pq =  new PriorityQueue();\n            pq.add(new A(9));\n            pq.add(new A(5));\n            pq.add(new A(8));\n            pq.add(new A(19));\n            pq.add(new A(1));\n\n            System.out.println(pq);\n        }\n}\n```\n\n\nOutput :\n[1, 5, 8, 19, 9]\n    ", "Answer": "\r\nIn a priority queue, the only guarantee you have is that the head is the lowest (or greatest, depending on your comparison). The internal structure is not necessarily a sorted list. Actually, in Java, it's a heap:\n\n\n  PriorityQueue\n  \n  An unbounded priority queue based on a priority heap.\n\n\nHowever, if you do a loop that ```\npoll()```\n the first item, then print it, again and again until the priority queue is empty. The elements should be printed from the lowest to the greatest element.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Creating a STL min heap priority queue?\r\n                \r\nMy task is to implement a min heap priority queue sorting each queue object with the m_time member variable.\nMy problem is that I can't manage the queue to sort smallest first instead of largest.\n\nI have a struct in the .h file called Event that includes three variables:\n\n```\nstruct Event\n{ \n Event(int time=-1, int grind=-1, bool val=false) \n { m_time=time;m_grindNr=grind; m_value=val;}\n\n    int  m_time;\n    int  m_grindNr;\n    bool m_value;\n};\n```\n\n\nThe code below is what's inside the .cpp file:\n\n```\nstruct compare\n{\n    bool operator()(const Event& a, const Event& b)\n    {\n        return a.m_time < b.m_time;\n    }\n};\n\n\nvoid main()\n{\n    priority_queue <Event,vector<Event>, compare> Que;\n\n    Event firstEvent;\n    firstEvent.m_time = 2;\n    firstEvent.m_grindNr = 0;\n    firstEvent.m_value = 0;\n    Que.push(firstEvent);\n\n    Event secondEvent;\n    secondEvent.m_time = 5;\n    secondEvent.m_grindNr = 0;\n    secondEvent.m_value = 0;\n    Que.push(secondEvent);\n\n    Event tempEvent = Que.top(); //Takes the top value\n    Que.pop();\n    cout << tempEvent.m_time << \" \"; //Should print number 2, but prints 5\n\n    tempEvent = Que.top(); //Takes the top value\n    Que.pop();\n    cout << tempEvent.m_time << endl; //Should print number 5, but prints 2\n}\n```\n\n\nI have also tried using the std::less in the priority queue parameter but its the same result.\n\nI hope you understand my question, thanks in advance.\n    ", "Answer": "\r\nYou have to use ```\ngreater```\n, as priority_queue take largest first.\n\nSo change your compare to\n\n```\nreturn b.m_time < a.m_time;\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "classCastException over Priority Queue; Java\r\n                \r\nI am implementing a priority queue of 5 processes.Each process has identical fields with different values. I have 3 classes. One is a template for the process, a second one for the actual algorithm that I will be implementing regarding those processes and one Test. I am trying to print out all the arrive_time attributes of the processes in my priority queue. Those fields are all integers, but the actual processes are of type Process, which crashes the PriorityQueue class. I need help here.\n\nfirst class:\n\n```\npackage SPN;\n\npublic class Process {\n\n    public int arrive_time= 0;\n    private int burst_time = 0;\n    private int remain_time = 0;\n\n    public Process (int arr_time, int bur_time) {\n\n        this.arrive_time = arr_time;\n        this.burst_time = bur_time;\n    }\n\n    //public int getArrTime() {return arrive_time;}\n    public int getBurTime() {return burst_time;}\n    public int getRemTime() {return remain_time;}\n}\n```\n\n\nsecond class:\n\n```\npackage SPN;\n\nimport java.util.*;\n\npublic class SPN {\n\n    private Process p1, p2, p3, p4, p5;\n\n    //Priority Queue of the processes\n    PriorityQueue<Process> prq = new PriorityQueue<Process>();\n\n    public SPN() {\n\n        p1 = new Process(0, 10);\n        prq.add(p1);\n\n        p2 = new Process(1, 8);\n        prq.add(p2);\n\n        p3 = new Process(2, 11);\n        prq.add(p3);\n\n        p4 = new Process(5, 6);\n        prq.add(p4);\n\n        p5 = new Process(7, 7);\n        prq.add(p5);\n    }\n\n    public void test() {\n\n        // create iterator from the queue\n        Iterator<Process> it = prq.iterator();\n\n        System.out.println(\"Values of queue: \" + it.next());\n    }\n}\n```\n\n\nthird class:\n\n```\npackage SPN;\n\npublic class Test {\n\n    public static void main(String[] args) {\n\n        SPN spn = new SPN();\n        spn.test();\n    }\n}\n```\n\n    ", "Answer": "\r\nIn order for PriorityQueue to be able to priorotize your objects (Process objects), it needs to be a Comparable object.\n\n```\npublic class Process implements Comparable<Process> {\n\n    //your existing code here\n\n    @Override\n    public int compareTo(Process proc) {\n        //implement this\n        return 0;\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How is the Java priority Queue supposed to work? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Why does PriorityQueue.toString return the wrong element order? [duplicate]\r\n                            \r\n                                (4 answers)\r\n                            \r\n                    \r\n                Closed 7 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nShort story, I'm implementing a graph and now I'm working on the Kruskal, I need a priority queue. My definition of a priority queue is that the element with the smallest key would come first? Is this wrong? Because when I insert the weighted edges(or numbers) in the queue they don't end up sorted. \n\n```\nPriorityQueue<Integer> tja = new PriorityQueue<Integer>(); \ntja.add(55);\ntja.add(99); \ntja.add(1); \ntja.add(102);\ntja.add(54);\ntja.add(51);\nSystem.out.println(tja);\n```\n\n\nThat would print out this; [1, 54, 51, 102, 99, 55]. This is not sorted like I want them to be! And yes I made a comperator that goes into the priority queue that extracts the number from the edge object and compares based on that int. So this should work, or have I just completely misunderstood the entire concept of how this data structure works? \n    ", "Answer": "\r\nSystem.out.println is invoking the toString() method, which is using the iterator, which is not guaranteed to respect the natural ordering. From the docs: \"The Iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order.\"\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Changing a LinkedList into a Priority Queue\r\n                \r\nI currently have a class that has 3 linkedlists of strings or ints that I use as a stack via a trio of ```\naddFirst```\n and ```\nremoveFirst```\n commands. (Class reproduced below)\n\nI want to add the ability to use the class as a priority queue instead. I know what a priority queue is, so I'm looking for a simple way to add ```\ninsertWithPriority```\n and ```\nremoveNext```\n.\n\nThe intuitive option is to switch from a class of 3 linkedLists to 3 priorityQueues instead, but I'm a little confused how to use the priority queues in java. Specifically, I need priority for all 3 to function identically such that removeNext will remove the same 3 elements that were added by ```\ninsertWithPriority```\n.\n\nCould someone shed some light on how to implement a proper priorityQueue?\n\n```\nclass ThreeList{\n    public LinkedList foo;\n    public LinkedList bar;\n    public LinkedList etal;\n\n    public ThreeList(){\n        foo= new LinkedList();\n        bar= new LinkedList();\n        etal= new LinkedList();\n    }\n\n    public void addLast(String foo, int bar, int etal){\n        foo.addLast(foo);\n        bar.addLast(bar);\n        etal.addLast(etal);\n    }\n\n    public void addFirst(String foo, int bar, int etal){\n        foo.addFirst(foo);\n        bar.addFirst(bar);\n        etal.addFirst(etal);\n    }\n\n    public void removeFirst(){\n        foo.removeFirst();\n        bar.removeFirst();\n        etal.removeFirst();\n    }\n\n    public void removeLast(){\n        foo.removeLast();\n        bar.removeLast();\n        etal.removeLast();\n    }   \n}\n```\n\n    ", "Answer": "\r\n```\nPriorityQueue```\n offers priorization by use of Comparable or Comparator, i.e. you only use add.\n\nIn your case it would be best to use a simple static inner class to capture foo, bar and etal into one object.\n\n```\nstatic class FooBar implements Comparable<FooBar> {\n   String foo;\n   int bar, etal;\n\n   int compareTo(FooBar other) {\n     ... comparison logic here...\n   }\n\n}\n```\n\n\nIf the values foo,bar,etal don't implicitly contain a priority, you need to add another field to FooBar and use that in ```\ncompareTo```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java: strange order of queue made from priority queue\r\n                \r\nI wrote a maze solving program which is supposed to support DFS, BFS, A*, Dijkstra's, and greedy algorithm. Anyway, I chose PriorityQueue for my frontier data structure since I thought a priority can behave like a queue, stack, or priority queue depends on the implementation of the comparator. \n\nThis is how I implemented my comparator to turn the priority queue into a queue:\n\n/Since the \"natural ordering\" of a priority queue has the least element at the head and a conventional comparator returns -1 when the first is less than the second, the hacked comparator always return 1 so that the current (last) square will be placed at the tail (this should work recursively)/\n\n```\npublic int compare(Square square1, Square square2)\n{\n    return 1;\n}\n```\n\n\nHowever, my solution for the maze was not optimal after I did a BFS. \n\nThe maze starts at top right corner with coordinate (35,1) and my program checks the left, then up, then down, then right neighbour.\nHere are the println I did:\n\npolled out (35,1)\n\nadded (34,1)\n\nadded (35,2)\n\npolled out (34,1)\n\nadded (33,1)\n\nadded (34,2)\n\npolled out (35,2)\n\nadded (35,3)\n\npolled out (33,1)\n\nadded (32,1)\n\nadded (33,2)\n\npolled out (34,2)\n\nadd (34,3)\n\npoll out (32,1)\n\n......\n\nNotice in a BFS (35,3) should be polled out before (32,1) since the former is added into the queue before the latter. What really confused me is that the data structure behaved like a queue--all new members were added from the back--until I added (32,1), which was placed at the head of the queue.\n\nI thought my comparator should force the priority queue to put new comers in the back. What is even stranger to me is that the data structure changed its nature from a queue to a stack in the middle.\n\nMany thanks to you guys ahead and sorry about my poor English,\nSincerely,\nSean\n    ", "Answer": "\r\nThe way you've implemented ```\ncompare```\n is wrong, and would only work if it's called only in a very specific way that you're assuming.  However, you have no idea in what context the ```\nPriorityQueue```\n actually calls ```\ncompare```\n.  The ```\ncompare```\n function might well be called on an existing element inside the data structure, instead of the new one, or vice versa.\n\n(Even if you did read the source code and traced it and found that this particular implementation works in a certain way, you shouldn't depend on that if you want your code to be maintainable.  At the least, you'd be making yourself more work by having to explain why it works.)\n\nYou could just use some sort of counter and assign it as the value for each added item, then implement ```\ncompare```\n correctly based on the value.\n\nA correct implementation of ```\ncompare```\n might look like this:\n\n```\nint compare(Object x, Object y){\n    return x.getSomeProperty() - y.getSomeProperty();\n}\n```\n\n\nNote that if you switch the order of the parameters, the answer will change as well.  No, the int returned does not necessarily have to come from {-1, 0, 1}.  The spec calls for 0, or a negative or positive integer.  You can use any one you wish, so long as it's the correct sign.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is asyncio.PriorityQueue's default priority?\r\n                \r\nDoes ```\nasyncio.PriorityQueue```\n have a default priority? If I do not give a priority value with an entry, will it default to FIFO? Apologies if this is a duplicate, I have been searching for this answer everywhere and haven't found it yet.\nI have a discord music bot that currently uses ```\nasyncio.Queue```\n to hold song info, and am debating switching to a priority queue to add a \"play next\" option. I have struggled to find detailed descriptions of ```\nasyncio```\n's priority queue implementation.\n    ", "Answer": "\r\nWhile the regular ```\nasyncio.Queue```\n uses a ```\ndeque```\n to store the items under the hood, the ```\nasyncio.PriorityQueue```\n uses a ```\nlist```\n with the heap queue implementation from the standard library. (source)\nThe ```\nheapq```\n documentation should give you all the info you need to know about how this works, but in short there is no \"default\" priority configured anywhere. The heap methods will simply use the rich comparison operators (```\n<=```\n, ```\n>=```\n etc.) on the items to maintain invariance.\nThat is why the ```\nPriorityQueue```\n docs suggest using 2-tuple items with the first element ensuring the ordering.\nTuples support rich comparison by proxy of their elements. And that comparison is lazy. That means, when comparing two tuples ```\ntup1```\n and ```\ntup2```\n, the first check compares ```\ntup1[0]```\n and ```\ntup2[0]```\n. And if that check returns a clear order, the other elements are not even checked.\nTry this:\n```\nfrom asyncio import PriorityQueue\n\nclass Foo:\n    pass\n\nq = PriorityQueue()\nq.put_nowait(Foo())\nq.put_nowait(Foo())  # error\nitem = q.get_nowait()\nprint(item)\n```\n\nYou will get an error as soon as you try to add a second ```\nFoo```\n instance because there is no way to order objects of the class ```\nFoo```\n.\nBut do this instead:\n```\n...\nq = PriorityQueue()\nq.put_nowait((2, Foo()))\nq.put_nowait((1, Foo()))\nitem = q.get_nowait()\nprint(item)  # (1, <__main__.Foo object at 0x...>)\n```\n\nThis will work and get you the tuple with the ```\n1```\n as the first element because ```\n1 < 2```\n.\nIf you make the first elements ambiguous, you will again get an error:\n```\n...\nq = PriorityQueue()\nq.put_nowait((1, Foo()))\nq.put_nowait((1, Foo()))  # error again\n```\n\nBut as soon as you add a ```\n__lt__```\n method to ```\nFoo```\n, the priority queue will accept multiple instances just fine (because the ```\nheapq```\n functions will) and set up their priority corresponding to their ordering with the ```\n<```\n operator:\n```\nfrom asyncio import PriorityQueue\n\n\nclass Foo:\n    def __init__(self, value: int) -> None:\n        self.value = value\n\n    def __str__(self) -> str:  # just for easier demonstration\n        return f\"Foo({self.value})\"\n\n    def __lt__(self, other: object) -> bool:\n        if not isinstance(other, Foo):\n            raise NotImplementedError\n        return self.value < other.value\n\n\nq = PriorityQueue()\nq.put_nowait(Foo(2))\nq.put_nowait(Foo(1))\nitem = q.get_nowait()\nprint(item)  # Foo(1)\n```\n\nSo in short, you simply need to ensure that whatever items you put into the ```\nPriorityQueue```\n can be ordered and that their order reflects the priority you want to establish.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Am I implementing a heap-based priority queue correctly? Is downheap necessary?\r\n                \r\nI believe I just correctly completed the following assignment:\n\n\n  Implement a heap ­based priority queue class using the vector representation, containing characters.\n\n\nMy program compiles and when implemented for the remainder of the assignment I achieved all of the desired outputs. My question is whether I actually implemented the heap correctly. My teacher identified three key methods for a heap-based queue: downheap, upheap, and extractMin.\n\n```\npublic static void upheap(int j)\n    {\n\n            int p = parent(j);\n            if(heap.get(j) < heap.get(p)) { swap(j,p); }\n            if (j == 0) return;\n            upheap(p);\n    }\npublic static char extractRoot()\n    {\n            if (heap.size() == 0)\n                    return 0;\n            char root = heap.get(0);\n            heap.set(0,heap.get(heap.size() - 1));\n            heap.remove(heap.size() - 1);\n            downheap(0);\n            return root;\n    }\npublic static void downheap(int j)\n    {\n            if(hasLeft(j))\n            {\n                    int smallerIndex = left(j);\n                    if(hasRight(j) && heap.get(right(j)) < heap.get(left(j)))\n                            smallerIndex = right(j);\n                    if(heap.get(j) > heap.get(smallerIndex))\n                    {\n                            swap(j, smallerIndex);\n                    }\n                    upheap(j);\n                    downheap(smallerIndex);\n            }\n    }\n```\n\n\nHowever, I feel like my downheap function is just piggybacking off of upheap, and actually entirely unnecessary. I have the function: \n\n```\npublic static void add(char c)\n{\n    heap.add(c);\n    upheap(heap.size() - 1);\n}\n```\n\n\n(where heap is an ArrayList) and that automatically makes sure that every new entry follows the heap-order property. I never actually end up using downheap to sort anything - so is there any point to even keep it in the class? When would I use it?\n\nIf anyone wants to see the rest of the methods in the class I'll post\n    ", "Answer": "\r\nActually you can remove the call to upheap() in your downheap() method. \nAs you know the root in a priority queue heap is highest priority element.\nThe downheap method comes into picture only when the highest priority element is removed i.e. the root element is swapped with the last element. In your case the extractRoot() method. Once you extractRoot() all the the other elements in the heap would satisfy the heap property except the one on root. \nAlso when you are moving the root element down you are swapping with the smaller value i.e swap(j, smallerIndex). Hence there would never be a case when you would need to move an element up the heap in case of downheap().\n\nTo answer your question, when you call add() downHeap() is useless but when you call extractMin() downheap() is necessary.\n\nHeap Image\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue of pairs in reverse order\r\n                \r\nI'm wanting to do something like this:\n\n```\npriority_queue< pair<int, int>, vector<int>, greater<int> > Q;\n```\n\n\nThis works fine if the type I'm comparing is ```\nint```\n, i.e.:\n\n```\npriority_queue< int, vector<int>, greater<int> > Q;\n```\n\n\nhowever, obviously with the ```\npair<int, int>```\n, there is no way of comparing the pairs in the queue with the standard ```\n>```\n. I was wondering what I should do? How would I implement an overloaded ```\n>```\n or is there another way I can create a priority queue of pairs with the smallest ```\npair.second```\n being at the top of the queue?\n    ", "Answer": "\r\nHave you tried this?\n\n```\ntypedef pair<int, int> P;\npriority_queue< P, vector<P>, greater<P> > Q;\n```\n\n\nThis will give the reverse ordering of the normal ```\noperator<```\n for ```\npair<int, int>```\n, which will start with the smallest ```\nfirst```\n tie-broken with smallest ```\nsecond```\n.\n\nIf you want to sort by smallest ```\nsecond```\n first and ```\nfirst```\n second (!) then you'll need a new sorting functor:\n\n```\nstruct Order\n{\n    bool operator()(P const& a, P const& b) const\n    {\n        return a.second < b.second || a.second == b.second && a.first < b.first;\n    }\n}\n```\n\n\nThen use:\n\n```\npriority_queue< P, vector<P>, Order > Q;\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What heap structure does C++ STL priority queue use?\r\n                \r\nSpecifically, what heap variant does the STL priority queue container adaptor use? I'm benchmarking it vs my own hand rolled binary heap and double bucket structure implementations, so just wondering.  Bonus points for any interesting implementation knowledge!\n    ", "Answer": "\r\nThis question is tagged C++ (as opposed to asking for implementation-specific details on a particular compiler), so I've checked the standard for any information. In various sections of 23.6.4 we learn that the ```\npriority_queue```\n simply behaves as-if it uses ```\nmake_heap```\n, ```\npush_heap```\n, and ```\npop_heap```\n. Then these functions are documented (in ```\n25.4.6```\n sections) as having complexity ```\nAt most 3 * (last - first) comparisons.```\n, ```\nAt most log(last - first) comparisons.```\n, and ```\nAt most 2 * log(last - first) comparisons.```\n respectively. So certain heap implementations may be indicated by these characteristics, but no specific heap is called out.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a cQueue as a priority Queue in Omnet++?\r\n                \r\nI want to use the Omnet++ based container ```\ncQueue```\n as a priority Queue.\nAs it is explained in the API reference and in the manual - I need to define it\nas follows:\n```\ncQueue queue(\"Name of queue\", someCompareFunc)```\n  \n\nWhen ```\nsomeCompareFunc```\n is of type ```\nCompareFunc```\n which is defined by omnet as:\n```\ntypedef int (*CompareFunc)(cObject *a, cObject *b);```\n  \n\nSo, I wanted to implement this comparative function, but didn't manage to write something that will compile.\nI admit I didn't work with function pointers for some time now, but after a small research, I think I do understand and did write some test codes with eclipse IDE (c++).\n\nI'm trying to write the code at a ```\nsimpleModule```\n file.cc.\nSo for every function I declare at the header file in the \"regular way\", in the .cc file I need to add the module name with \"::\" before the function's name.\nSo in my header file I declared:\n```\nint compareByNodes (cObject *a, cObject *b);```\n\n\nAnd in the .cc file:  \n\n```\nint JobScheduler::compareByNodes (cObject *a, cObject *b){\n       return 1;\n    };\n```\n\n\nMy first try to define the cQueue was:  \n\n```\ncQueue queue(\"job_Buffer\",&compareByNodes);\n```\n\n\nBut I received a compilation error of: 'compareByNodes' was not declared in this scope.\nSo I figured it must have something to do with the 'JobScheduler::' that is missing.\nThe second try was:\n\n```\nCompareFunc tmp = (CompareFunc)&JobScheduler::compareByNodes;\ncQueue queue(\"job_Buffer\",tmp);\n```\n\n\nThis time my errors were:\n\"Multiple markers at this line\n    - within this context\n    - converting from ‘int (JobScheduler::)(omnetpp::cObject, omnetpp::cObject*)’ to ‘omnetpp::CompareFunc {aka int ()\n     (omnetpp::cObject, omnetpp::cObject*)}’ [-Wpmf-conversions]\"    \n\nAdding parenthesis after the 'ampersand' didn't help either.  \n\nIt would really help if I could use this method of Omnet and I guess I'm missing something since it's a well defined \"feature\" of the software.\nI also tried to google these subjects, searched in the google groups section, and didn't find any answers.\nWould appreciate any help\n    ", "Answer": "\r\nTry to declare a compare method as static.\nFor example:\n\n```\n//...\nclass Txc1 : public cSimpleModule {\n  protected:\n    virtual void initialize() override;\n    virtual void handleMessage(cMessage *msg) override;\n\n  public:\n    static int MyCompareFunc (cObject *a, cObject *b);\n};\n\nDefine_Module(Txc1);\n\nint Txc1::MyCompareFunc (cObject *a, cObject *b) {\n    return 1;\n}\n\nvoid Txc1::initialize() {\n    cQueue q1(\"queue1\", MyCompareFunc);\n    // ...\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I delete element in log(n) from priority queue implemented through heapq in python?\r\n                \r\nI have implemented priority queue from heapq data structure in python. Now I want to delete a particular element (by value) from the heap maintaining the heap invariant.\nI know it can be done by removing the element and heapify() again but that is O(n), and might be very slow since I have a very large heap.\n\nThe other thing that I am trying is, if I had known index I could have replaced it with last element and done _shiftup().\nBut since I don't know the index, I'll have to search, which again is linear time.\n\nCan I keep a parallel dict to point to location and use it? How can I update such dict with every insert to queue?\n\nEDIT:\n\nActually I need above to implement decreaseKey() in O(log n) time. If there's a better method to directly do that, that's also equivalently good.\n    ", "Answer": "\r\nYou may have read this already, but you could use the approach the the ```\nheapq```\n docs suggest, which is to just mark the element as removed, without actually removing it from the heap:\n\n\n  The remaining challenges revolve around finding a pending task and\n  making changes to its priority or removing it entirely. Finding a task\n  can be done with a dictionary pointing to an entry in the queue.\n  \n  Removing the entry or changing its priority is more difficult because\n  it would break the heap structure invariants. So, a possible solution\n  is to mark the existing entry as removed and add a new entry with the\n  revised priority:\n  \n  ```\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>'      # placeholder for a removed task\ncounter = itertools.count()     # unique sequence count\n\ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\n```\n\n\n\nThis way the removal is just a ```\nO(1)```\n lookup in a dict. And the removed item will just be ignored when it's popped from the queue later (at a cost of an extra ```\nO(log n)```\n on the ```\npop_task```\n operation). The drawback of course, is that if a client is not actually popping items from the queue, the size of the heap will grow, even though it  items are being \"removed\" according to the API.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Building a priority queue with a minHeap\r\n                \r\nThis is my first time implementing a priority queue and I have a question.\nFor this implementation:\n```\n#pragma once\n#include <vector>\n#include <algorithm>\n\ntemplate <typename T>\nstruct PriorityQueue\n{\n    std::vector<T> heapMin;\n    \n    PriorityQueue();\n    PriorityQueue(std::vector<T>);\n    void minHeapfy(int);\n    void buildMinHeap();\n    void insertElement();\n    T priorityMax();\n    T priorityExtractMax();\n};\n\ntemplate<typename T>\nPriorityQueue<T>::PriorityQueue()\n{\n}\n\ntemplate<typename T>\nPriorityQueue<T>::PriorityQueue(std::vector<T> init) : heapMin(init)\n{\n}\n\ntemplate <typename T>\nvoid PriorityQueue<T>::minHeapfy(int pos)\n{\n    int st = pos * 2 + 1, dr = pos * 2 + 2;\n    int imin = pos;\n    if (st < heapMin.size() && heapMin.at(st) < heapMin.at(imin))\n    {\n        imin = st;\n    }\n    if (dr < heapMin.size() && heapMin.at(dr) < heapMin.at(imin))\n    {\n        imin = dr;\n    }\n    if (imin != pos)\n    {\n        std::swap(heapMin.at(pos), heapMin.at(imin));\n        minHeapfy(imin);\n    }\n}\n\ntemplate<typename T>\nvoid PriorityQueue<T>::buildMinHeap()\n{\n    for (int i = heapMin.size() / 2 - 1; i >= 0 ; i--)\n    {\n        minHeapfy(i);\n    }\n}\n```\n\nif I do something like this in main()\n```\n    PriorityQueue<int> test(std::vector<int> {6, 5, 4, 3, 2, 1});\n    test.buildMinHeap();\n    for (int var : test.heapMin)\n    {\n        std::cout << var << \" \";\n    }\n```\n\nI will get\n```\n1 2 4 3 5 6\n```\n\nit is correct, because it follows the rules of a min Heap - each parent is lower than its children.\nBut if I use a tree visualisator, such as:\nhttps://www.cs.usfca.edu/~galles/visualization/Heap.html\nI will get another min heap, probably because the heap is built differently (re-doing the heap each time a new node is inserted)\n\nIs there any problem with my approach vs inserting each node at a time, as the tree visualisator does?\nIs my Priority Queue still valid?\n    ", "Answer": "\r\nA heap is a partially sorted structure. A min heap requires only the parent to be smaller than the current node, but puts no restriction on the order of sibling nodes. This means there are many ways to organize the same data in a heap.\nThe following are both correct min heaps for values 1, 2, 3:\n```\n    1          1\n   / \\        / \\\n  2   3      3   2\n```\n\nWe can verify correctness by plugging the results into ```\nstd::is_heap```\n:\n```\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> x { 1, 2, 4, 3, 5, 6 };\n    vector<int> y { 1, 3, 2, 6, 4, 5 };\n    cout << is_heap(begin(x), end(x), [](auto a, auto b) { return a > b; }) << endl;\n    cout << is_heap(begin(y), end(y), [](auto a, auto b) { return a > b; }) << endl;\n}\n```\n\nPrints:\n```\n1\n1\n```\n\nHence both your result and the online version are correct.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue with update ability\r\n                \r\nI am trying to implement a queue of employees in an efficient complexity.\n\nWhen I insert an employee to the queue I provide its ID number and its score.\nI want to maintain a queue ordered by the employees' scores in ascending order.\n\nSo far the problem can be solved using a priority queue implemented by a binary heap, but I need to be able to remove employees from the queue and update an employee by its ID number.\nAs far as I know binary heap does not support an efficient way of removing or updating an element.\n\nUpdate - O(n) for searching the element + O(1) for updating it.\n\nRemove - O(n) for searching the element + O(nlg(n)) for rebuilding the heap.\n\nIs there a more appropriate data structure for the problem?\n    ", "Answer": "\r\nYou can do it fairly easy with some extra memory.\n\nThe easiest way: Just add duplicate IDs to the tree. Then keep a hash-set (or bitmap if the IDs are ordered) to know if you've already returned a certain ID (to skip the duplicates that come out later).\n\nA bit harder: Keep a hash-map from IDs to locations in the heap. You need to update the hash-map every-time you touch the heap. Since you know where the element is you can update it's score in O(1) then push or pop the node to restore the heap (this should be O(logN)).\n\nAnother simple alternative: If the scores only decrease (assuming you have a max-heap), then you don't do anything for the update. When you want to pop the top you recompute the score, if it should be changed you push the node down. If it's still at the top you can remove it, if not, you go back to recomputing the score of the top element. The updates are still O(logN), but you incur the cost when you try take the top element.  \n\nAlso for removing an arbitrary element the complexity should be O(logN). You swap it with the last element, then call push the position.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Should I use Power Collection's OrderedMultiDictionary as a priority queue?\r\n                \r\nC# does not provide a native implementation of a priority queue.\n\nOn Stackoverflow, a common answer to this kind of problem is to use the Power Collections.\n\nShould I go ahead with that, or are there any downsides?\n    ", "Answer": "\r\nThe Power Collections indeed provide some excellent implementations of commonly used data structures that are not (yet) present in the .NET framework. While going with that option would not be terrible, I would like to point out an important flaw with this approach.\n\nThe OrderedMultiDictionary (as well as all other Power Collection classes) uses a red-black tree to create an ordered bag of key-value pairs. For an priority queue, RB trees tend to be an inferior data structure. I'm making the assumption that the priority value is hashable into an integer.\n\nThe reason is simple - a Dictionary can jump to a specific priority value right away in O(1), where is can use a specialized data structure to store the values of that priority (i.e. a queue).\n\nTest\n\nTo check my claims, I wrote a simple benchmark that compares priority queue structures based on 3 different ideas:\n\n\nPower Collections OrderedMultiDictionary\nSortedDictionary\nDictionary\n\n\nThe second option uses a SortedDictionary, which internally is implemented as a BST. The third option uses a simple Dictionary with O(1) lookup.\n\nI tested with a varying number of elements, shown in the Y-axis, and a varying number of distinct values, shown as the X-axis. The results for a particular combination is shown as a 3x3 matrix of values. The first line refers to option 1 (OrdererdMultiDictionary, the second to the SortedDictionary and the third to the Dictionary. The first value in each of these 3 lines shows the time taken to enqueue the respective number of values, the second the time taken to enumerate over all values, the third the time to dequeue all values again.\n\nAll times are log 2. A value of 10 indicates 2^10ms = 1s, though the absolute value is of low importance. The number of elements is doubled, which means that, if the structure behaves O(n)-like, time should increase by 1 each time.\n\nHorizontally, the number of distinct values is multiplied by 32 per column. Thus, the first column (with just the same value being inserted over and over) shows the performance of the internal data structure holding the values.\n\nThe machine used is an i7 with 16 GB plus SSD.\n\n```\n          |           1        |          32        |        1024        |       32768        |     1048576        |\n\n       128\n          | -4.9 / -4.3 /  n/a | -4.7 / -4.1 /  n/a | -4.8 / -2.9 /  n/a | -4.9 / -2.9 /  n/a | -4.9 / -2.9 /  n/a |\n          | -7.5 / -6.1 / -5.3 | -6.5 / -5.7 / -5.1 | -4.7 / -4.9 / -4.3 | -4.6 / -4.7 / -4.2 | -4.6 / -4.8 / -4.2 |\n          | -7.5 / -7.6 / -6.6 | -6.8 / -7.3 / -6.3 | -5.9 / -5.9 / -3.0 | -6.2 / -6.4 / -2.8 | -6.2 / -6.3 / -2.8 |\n\n\n       256\n          | -3.8 / -3.2 /  n/a | -3.7 / -3.1 /  n/a | -3.7 / -2.2 /  n/a | -3.8 / -1.8 /  n/a | -3.7 / -1.8 /  n/a |\n          | -6.8 / -5.5 / -4.4 | -5.8 / -5.4 / -4.2 | -3.8 / -4.3 / -3.4 | -3.5 / -4.1 / -3.2 | -3.5 / -4.1 / -3.1 |\n          | -6.6 / -6.9 / -5.7 | -6.1 / -6.7 / -5.7 | -5.5 / -5.3 / -1.8 | -5.3 / -5.0 / -0.9 | -5.3 / -5.6 / -1.0 |\n\n\n       512\n          | -2.7 / -2.1 /  n/a | -2.5 / -2.1 /  n/a | -2.5 / -1.5 /  n/a | -2.6 / -0.7 /  n/a | -2.6 / -0.7 /  n/a |\n          | -5.9 / -5.2 / -3.4 | -4.9 / -5.0 / -3.3 | -3.2 / -4.2 / -2.6 | -2.4 / -3.2 / -2.1 | -2.3 / -3.2 / -2.0 |\n          | -5.7 / -6.1 / -4.9 | -5.2 / -6.1 / -4.8 | -4.8 / -5.0 / -1.7 | -4.3 / -4.0 /  1.0 | -4.4 / -4.7 /  1.0 |\n\n\n      1024\n          | -1.6 / -1.0 /  n/a | -1.4 / -1.0 /  n/a | -1.4 / -0.7 /  n/a | -1.5 /  0.4 /  n/a | -1.5 /  0.3 /  n/a |\n          | -4.9 / -4.7 / -2.4 | -4.1 / -4.5 / -2.3 | -2.6 / -4.0 / -1.8 | -1.2 / -2.3 / -1.0 | -1.2 / -2.3 / -0.9 |\n          | -4.7 / -5.4 / -3.9 | -4.4 / -5.3 / -3.8 | -4.1 / -4.6 / -1.6 | -3.3 / -3.0 /  2.9 | -3.5 / -3.8 /  3.0 |\n\n\n      2048\n          | -0.4 /  0.1 /  n/a | -0.3 /  0.1 /  n/a | -0.3 /  0.3 /  n/a | -0.3 /  1.5 /  n/a | -0.5 /  1.4 /  n/a |\n          | -4.0 / -4.1 / -1.4 | -3.2 / -4.0 / -1.3 | -1.7 / -3.5 / -0.9 | -0.2 / -1.4 /  0.1 | -0.2 / -1.3 /  0.1 |\n          | -3.8 / -4.5 / -2.9 | -3.5 / -4.4 / -2.9 | -3.2 / -3.9 / -1.0 | -2.5 / -2.0 /  4.9 | -2.4 / -2.1 /  4.9 |\n\n\n      4096\n          |  0.7 /  1.2 /  n/a |  0.8 /  1.2 /  n/a |  0.9 /  1.3 /  n/a |  0.8 /  2.8 /  n/a |  0.6 /  2.9 /  n/a |\n          | -3.0 / -3.2 / -0.4 | -2.2 / -3.3 / -0.3 | -0.8 / -3.0 /  0.1 |  0.9 / -0.4 /  1.1 |  0.9 / -0.2 /  1.2 |\n          | -2.9 / -3.5 / -1.9 | -2.6 / -3.5 / -1.9 | -2.3 / -3.2 / -0.9 | -1.6 / -1.1 /  6.6 | -1.3 / -1.1 /  6.9 |\n\n\n      8192\n          |  1.8 /  2.8 /  n/a |  1.9 /  3.0 /  n/a |  2.0 /  3.0 /  n/a |  1.9 /  4.0 /  n/a |  1.8 /  4.1 /  n/a |\n          | -2.0 / -2.4 /  0.6 | -1.3 / -2.4 /  0.7 |  0.1 / -2.2 /  1.1 |  1.8 /  0.4 /  2.1 |  2.1 /  0.9 /  2.3 |\n          | -1.9 / -2.6 / -1.0 | -1.6 / -2.5 / -0.9 | -1.4 / -2.4 / -0.3 | -0.6 / -0.3 /  8.0 | -0.5 /  0.1 /  8.9 |\n\n\n     16384\n          |  2.9 /  3.7 /  n/a |  3.0 /  3.6 /  n/a |  3.1 /  3.8 /  n/a |  3.1 /  4.6 /  n/a |  3.0 /  5.2 /  n/a |\n          | -1.0 / -1.5 /  1.6 | -0.3 / -1.5 /  1.7 |  1.1 / -1.4 /  2.0 |  2.4 /  0.7 /  2.9 |  3.2 /  1.9 /  3.6 |\n          | -0.9 / -1.6 /  0.0 | -0.6 / -1.6 /  0.1 | -0.5 / -1.5 /  0.4 |  0.0 / -0.1 /  8.0 |  0.6 /  1.2 / 10.9 |\n\n\n     32768\n          |  4.0 /  5.0 /  n/a |  4.1 /  5.0 /  n/a |  4.3 /  5.0 /  n/a |  4.2 /  5.5 /  n/a |  4.1 /  6.4 /  n/a |\n          | -0.1 / -0.5 /  2.6 |  0.7 / -0.5 /  2.7 |  2.0 / -0.5 /  3.1 |  3.1 /  0.9 /  3.8 |  4.3 /  3.0 /  4.8 |\n          |  0.1 / -0.6 /  1.0 |  0.4 / -0.6 /  1.1 |  0.5 / -0.5 /  1.3 |  0.9 /  0.4 /  8.0 |  1.6 /  2.3 / 12.9 |\n\n\n     65536\n          |  5.2 /  6.6 /  n/a |  5.4 /  6.4 /  n/a |  5.5 /  6.4 /  n/a |  5.5 /  6.8 /  n/a |  5.4 /  7.4 /  n/a |\n          |  1.0 /  0.4 /  3.6 |  1.8 /  0.5 /  3.7 |  3.0 /  0.4 /  4.1 |  4.2 /  1.9 /  4.9 |  5.5 /  4.2 /  6.0 |\n          |  1.1 /  0.4 /  2.0 |  1.4 /  0.4 /  2.1 |  1.5 /  0.5 /  2.4 |  2.0 /  1.4 /  9.8 |  3.2 /  3.4 / 14.8 |\n\n\n    131072\n          |  6.5 /  7.8 /  n/a |  6.6 /  7.6 /  n/a |  6.8 /  7.4 /  n/a |  6.9 /  7.7 /  n/a |  6.8 /  8.6 /  n/a |\n          |  2.0 /  1.4 /  4.6 |  2.9 /  1.4 /  4.8 |  4.1 /  1.5 /  5.2 |  5.2 /  2.4 /  5.8 |  6.8 /  5.4 /  7.0 |\n          |  2.1 /  1.4 /  3.1 |  2.4 /  1.4 /  3.1 |  2.5 /  1.5 /  3.3 |  3.0 /  2.0 /  9.9 |  4.4 /  4.6 / 16.6 |\n\n\n    262144\n          |  7.5 /  8.9 /  n/a |  7.6 /  8.9 /  n/a |  7.8 /  8.6 /  n/a |  8.0 /  8.8 /  n/a |  8.2 /  9.6 /  n/a |\n          |  3.0 /  2.4 /  5.6 |  3.9 /  2.4 /  5.7 |  5.1 /  2.4 /  6.1 |  6.1 /  2.9 /  6.7 |  8.1 /  6.4 /  8.1 |\n          |  3.1 /  2.5 /  4.1 |  3.3 /  2.4 /  4.1 |  3.5 /  2.4 /  4.2 |  4.7 /  3.6 /  9.9 |  5.7 /  5.8 / 18.2 |\n\n\n    524288\n          |  8.6 / 10.0 /  n/a |  8.8 / 10.0 /  n/a |  9.0 /  9.6 /  n/a |  9.4 /  9.7 /  n/a |  9.3 / 10.4 /  n/a |\n          |  4.0 /  3.4 /  6.6 |  4.9 /  3.4 /  6.7 |  6.1 /  3.4 /  7.1 |  7.0 /  3.7 /  7.6 |  8.9 /  7.0 /  8.8 |\n          |  4.1 /  3.5 /  5.0 |  4.4 /  3.4 /  5.1 |  4.5 /  3.4 /  5.2 |  4.9 /  3.6 /  9.9 |  6.8 /  6.5 / 19.2 |\n\n\n   1048576\n          |  9.7 / 11.0 /  n/a |  9.9 / 11.1 /  n/a | 10.2 / 10.7 /  n/a | 10.7 / 10.7 /  n/a | 10.7 / 11.2 /  n/a |\n          |  5.0 /  4.4 /  7.5 |  5.9 /  4.4 /  7.7 |  7.1 /  4.4 /  8.1 |  8.0 /  4.6 /  8.5 |  9.7 /  7.3 /  9.8 |\n          |  5.1 /  4.4 /  n/a |  5.3 /  4.4 /  n/a |  5.5 /  4.4 /  n/a |  5.9 /  4.6 /  n/a |  7.7 /  6.8 /  n/a |\n\n\n   2097152\n          | 10.8 / 12.0 /  n/a | 11.0 / 12.1 /  n/a | 11.3 / 11.8 /  n/a | 12.1 / 11.8 /  n/a | 12.0 / 12.1 /  n/a |\n          |  6.0 /  5.4 /  8.5 |  7.0 /  5.4 /  8.7 |  8.1 /  5.4 /  9.1 |  9.0 /  5.6 /  9.5 | 10.6 /  7.6 / 10.3 |\n          |  6.1 /  5.4 /  n/a |  6.4 /  5.4 /  n/a |  6.6 /  5.4 /  n/a |  6.9 /  5.6 /  n/a |  8.8 /  7.2 /  n/a |\n\n\n   4194304\n          | 11.9 / 13.0 /  n/a | 12.0 / 13.1 /  n/a | 12.5 / 12.9 /  n/a | 13.3 / 12.8 /  n/a | 13.2 / 13.0 /  n/a |\n          |  7.0 /  6.4 /  9.5 |  8.0 /  6.4 /  9.7 |  9.2 /  6.4 / 10.1 | 10.1 /  6.5 / 10.5 | 11.6 /  8.0 / 11.1 |\n          |  7.1 /  6.4 /  n/a |  7.3 /  6.4 /  n/a |  7.6 /  6.4 /  n/a |  8.0 /  6.5 /  n/a |  9.9 /  7.7 /  n/a |\n\n\n   8388608\n          |  n/a /  n/a /  n/a |  n/a /  n/a /  n/a | 13.7 / 14.1 /  n/a | 14.5 / 13.8 /  n/a | 14.4 / 13.9 /  n/a |\n          |  8.0 /  7.4 / 10.5 |  9.0 /  7.4 / 10.7 | 10.2 /  7.4 / 11.1 | 11.1 /  7.5 / 11.5 | 12.6 /  8.5 / 12.0 |\n          |  8.1 /  7.4 /  n/a |  8.4 /  7.4 /  n/a |  8.6 /  7.4 /  n/a |  9.1 /  7.5 /  n/a | 10.8 /  8.3 /  n/a |\n\n\n 16777216\n         |  n/a /  n/a /  n/a |  n/a /  n/a /  n/a |  n/a /  n/a /  n/a |  n/a /  n/a /  n/a |  n/a /  n/a /  n/a |\n         |  9.0 /  8.4 / 11.6 | 10.0 /  8.4 / 11.7 | 11.2 /  8.4 / 12.1 | 12.2 /  8.4 / 12.5 | 13.6 /  9.1 / 12.9 |\n         |  9.1 /  8.4 /  n/a |  9.3 /  8.4 /  n/a |  9.6 /  8.4 /  n/a | 10.1 /  8.4 /  n/a | 11.9 /  9.0 /  n/a |\n```\n\n\nFlaws of the test\n\nAll rows with less than 100 values were not shown, as they are of no practical importance and can instead be thought of as warming-up.\n\nAll tests were performed only once, no smoothing has been done, so spikes in either direction are possible. The tests for values over 10000 were running for a reasonably long time to at least exclude short spikes. I repeated the whole benchmark a few times, and the differences were within 10%.\n\nThe data structures have not been initialized with the proper amount of elements they may expect to hold. This was, partially, due to the memory consumption with larger sets.\n\nThere are no values for OMD Dequeuing, as I found no reasonable approach to implement this yet. I would appreciate any help on this.\n\nResults\n\nThe results are pretty consistent for larger values.\n\n\nFor smaller bucket counts (number of distinct values), both option 2 or 3-based approaches are several times faster than the OMD at enqueuing and even more at enumeration. No comparison exists for dequeuing.\nFor larger bucket counts, the OMD does not slow down, while option 2+3 do (factor 10). Eventually option 2 is slightly worse at enqueueing but still extremely fast at enumerating, option 3 (the simple Dictionary) beats both.\nHowever, option 3 gets terrible at dequeuing for large bucket numbers, to the point of definite non-usability. This is due to the permanent search for the minimum key that does not exist in the SortedDictionary.\n\n\nRegarding memory usage, the OMD used up several times more memory than option 2 and 3, and consistently threw OutOfMemory exceptions for more than 5 million values. Option 3 again used noticably less memory than option 2. After each single test, a complete garbage collection was enforced.\n\nIn conclusion, I recommend to use a SortedDictionary of Queues, as it tends to be as least as fast as the RB-tree approach that was used in the Power Collections while using less memory. The advantage increases if there are few distinct priority values. Of course, this only matters if you're dealing with large amounts of data.\n\nSource code\n\nadding the source code of the SortedDictionary. More can be found at http://pastebin.com/J4snVYzb\n\n```\npublic class PriorityQueue<TK, TV>\n{\n    private readonly SortedDictionary<TK, Queue<TV>> _D = new SortedDictionary<TK, Queue<TV>> ();\n\n    public void Enqueue (TK key, TV value)\n    {\n        Queue<TV> list;\n        if (!_D.TryGetValue (key, out list)) {\n            list = new Queue<TV> ();\n            _D.Add (key, list);\n        }\n        list.Enqueue (value);\n        Count++;\n    }\n\n    public int Count\n    {\n        get;\n        private set;\n    }\n\n    public TV Dequeue ()\n    {\n        var first = _D.First ();\n        var item = first.Value.Dequeue ();\n        if (!first.Value.Any ()) {\n            _D.Remove (first.Key);\n        }\n        return item;\n    }\n\n    public IEnumerable<TV> Values\n    {\n        get\n        {\n            var keys = _D.Keys.ToArray ();\n            foreach (var key in keys) {\n                foreach (var item in _D[key]) {\n                    yield return item;\n                }\n            }\n        }\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Size Limit to Priority Queue\r\n                \r\nadd() or offer()The difference is that offer() will return false if it fails to insert the element on a size restricted Queue, whereas add() will throw an IllegalStateException.\nBut Which Class we have In java which implements Queue and supports size limit? Or Please help me to understand If we can do limit the size Priority Queue.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Creating a priority queue class in PHP\r\n                \r\nI am attempting to create a priority queue class with array object in PHP. I know there is the SplPriorityQueue in PHP, but I am trying to practice object oriented programming here. Priority Queues have data and priority level, so I have a rough MyQueue class that implements these attributes. I am not sure if I am going in the right direction here. I have not worked with arrayObject's in PHP before.\n\n```\npublic class MyQueue{\n    private string data;\n    private int priority;\n\n    myQueue = arrayObject(array(data => priority));\n\n}\n```\n\n    ", "Answer": "\r\nPriority queue class might look like this:\n\n```\nclass MyQueue implements Iterator, Countable {\n    private $data;\n\n    public function __construct() {\n        $this->data = array();\n    }\n\n    function compare($priority1, $priority2) {}\n\n    function count() {\n        return count($this->data);\n    }\n\n    function extract() {\n        $result = $this->current();\n        $this->next();\n        return $result;\n    }\n\n    function current() {\n        return current($this->data). ' - ' .$this->key();\n    }\n\n    function key() {\n        return key($this->data);\n    }\n\n    function next() {\n        return next($this->data);\n    }\n\n    function insert($name, $priority) {\n        $this->data[$name] = $priority;\n        asort($this->data);\n        return $this;\n    }\n\n    function isEmpty() {\n        return empty($this->data);\n    }\n\n    function recoverFromCorruption() {}\n\n    function rewind() {}\n\n    function valid() {\n        return (null === key($this->data)) ? false : true;\n    }\n}\n```\n\n\nUsage:\n\n```\n$items = new MyQueue();\n\n$items ->insert('Charles', 8)\n       ->insert('James', 1)\n       ->insert('Michael', 4)\n       ->insert('John', 2)\n       ->insert('David', 6)\n       ->insert('William', 5)\n       ->insert('Robert', 3)\n       ->insert('Richard', 7);\n\nforeach($items as $item) {\n    echo $item,'<br>';\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java : Priority Queue\r\n                \r\nI have a java program which goes like this \n\npublic class PriorityQueueExample {\n\n```\npublic static void main(String[] args) {\n    PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\n    pq.add(10);\n    pq.add(1);\n    pq.add(9);\n    pq.add(2);\n    pq.add(8);\n    pq.add(3);\n    pq.add(7);\n    pq.add(4);\n    pq.add(6);\n    pq.add(5);\nSystem.out.println(pq);\n\n}\n```\n\n\n}\n\nMy Question is why does not the priority queue sort them. As per the java specs it implements comparable and maintains the sorting order(natural sorting)\n\nMy output of the program is as follows : [1, 2, 3, 4, 5, 9, 7, 10, 6, 8]\n    ", "Answer": "\r\nIt is sorted, but internally the elements are stored in a heap. If you call ```\npeek()```\n, ```\npoll()```\n, or ```\nremove()```\n, you will get the right order (and that's how you access queues).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Dijkstra with Priority Queue, Segmentation fault\r\n                \r\nI'm trying to implement Dijkstra with a Priority Queue, but i keep getting this segmentation fault.\n\nMy implementation looks like this:\n\n```\nvoid dijkstra_pq_routine(Graph &g, int s, vector<int> &prio,vector<int> &pred)\n{\n   std::cout << \"init\" << std::endl;\n   int n = g.size();\n   prio.assign(n,INT_MAX);\n   prio[s] = 0;\n   pred.assign(n,-1);\n   priority_queue<pii,vector<pii>, greater<pii> > q;\n\n   q.push(make_pair(0,s));\n\n   while(!q.empty())\n   {\n       std::cout << \"while\" << std::endl;\n       int d = q.top().first;\n       int u = q.top().second;\n       q.pop();\n       if(d != prio[u])\n       {\n           std::cout << \"if\" << std::endl;\n           //continue;\n       }\n       std::cout << \"before for\" << std::endl;\n       for(int i = 0;i < (int) g[u].size(); i++)\n       {\n           std::cout << \"for\" << std::endl;\n           int v = g[u][i].first;\n           int nprio = prio[u] + g[u][i].second;\n           if(prio[v] > nprio)\n           {\n               prio[v] = nprio;\n               pred[v] = u;\n               q.push(make_pair(nprio,v));\n           }\n      }\n   }\n\n   //int len = returnPathLength(prio,(int)g.size()-1);\n   //return len;\n```\n\n\n}\n\nthe Graph I use looks like this:\n\n```\n typedef pair<int, int> pii;\n typedef vector<vector<pii> > Graph;\n```\n\n\nthis produces the error:\n\n```\nint main()\n{\n     Graph g(2);\n     g[0].push_back(make_pair(1, 3));\n     g[0].push_back(make_pair(1, 1));\n     dijkstra_pq(g);\n}\n```\n\n\nit seems like the Segmentation Fault occurs before the For loop.\nI hope someone can help me.\n\nThanks in advance!\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "A* pathfinding - how to efficiently update node values in openNodes priority queue? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Easiest way of using min priority queue with key update in C++\r\n                            \r\n                                (5 answers)\r\n                            \r\n                    \r\n                Closed 4 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI had a c++ implementation of the A* algorithm and I was using vectors as the data structures in which I stored open nodes. I was sorting the vector after every addition of a new node. That was too inefficient and I was told to start using priority queue to avoid sorting.\n\nThe problem I have with priority queue is that if I find a better path to a node that's already in the openNodes queue, I need to update its F value. The nodes in the queue are sorted by the F value, but when I update it, the node's position in the queue doesn't change. This means that I can end up with a sub-optimal path. \n\nI tried to fix this issue by doing the following pattern whenever I would change the value of a node that's in the openNodes queue:\n\n1) Update the F value of the node.\n\n2) In the priority queue, pop and temporarily store all values that are before the node I'm looking for. Pop and store that node as well.\n\n3) Loop through the temporary vector of nodes and push them back into the priority queue.\n\n```\n //...updated the F value of a node\n std::vector<Node*> temp;\n //the loop condition checks if the current node on top of the queue is the node I'm updating\n while (openNodes.top()->getId() != (*neighbours)[i]->getId()) {    \n    temp.push_back(openNodes.top());\n    openNodes.pop();\n }\n temp.push_back(openNodes.top());\n openNodes.pop();\n for (int k = 0; k < temp.size(); k++) {\n    openNodes.push(temp[k]);\n }\n```\n\n\nThis approach does solve the problem of finding a sub-optimal path, but just like in the beginning, it's too inefficient. Is there a better way of solving this? Should I even use priority queue at all?\n    ", "Answer": "\r\nI don't really understand your code example, but for me it sounds like you should do the following:\n\n\nGet the node your are updating.\nCalculate the new F value.\nDid it change? Nope? Than you are done.\nOh! It did change? Then pop this node from the queue. (Popping the node should not change the fact that your queue is already sorted.)\nWalk through the whole queue looking where the updated node belongs.\nInsert the updated node at the right place. The queue stays sorted.\n\n\nIn case you are not seeing it here, what you need is insertion sort!\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Making a function that counts number of elements in PriorityQueue in C\r\n                \r\nTASK: I am working on a homework for my Structure and Algorithms college class. The task is to implement Priority Queue in C using the heap and form the main so it can support operations such as: INSERT s  (inserts string s in a Priority Queue) DELETE (deletes the element with the lowest priority) NUMBER (returns number of elements in a Priority Queue) We should also print out preorder of the Priority Queue every time we write an operation in the main. We can assume that the heap is implemented with the pointers. So I implemented it in structure that looks like this:\n\n```\ntypedef char* elementtype;\n\ntypedef struct celltag {\n    elementtype zapis;\n    struct celltag *left, *right, *parent;\n}   celltype;\n\ntypedef celltype* node;\ntypedef celltype* PriorityQueue;\n```\n\n\nI also implemented following functions:\n\n```\nvoid PrMakeNull(PriorityQueue *Ap)\nint PrEmpty(PriorityQueue A)\nvoid PrInsert(elementtype x, PriorityQueue *Ap)\nelementtype PrDeleteMin(PriorityQueue *Ap)\nvoid Preorder(PriorityQueue A)\n```\n\n\nQUESTION: \nI should implement \"number function\" with the header like this:\n\n```\nint Number(PriorityQueue P)\n```\n\n\nThe function should not change the Priority Queue A after calling Number(A). Also, the function should be independent on Priority Queue implementation. (I think that means I should only use PrMakeNull, PrEmpty, PrInsert, PrDeleteMin). Is that even possible? How could I do it? How should it look like?\nWHAT HAVE I TRIED:\n1)\n\n```\n//This one is independent on Priority Queue implementation but destroys the Priority Queue. \nint Number(PriorityQueue P){\n    PriorityQueue S;\n    PrMakeNull(&S);\n    int counter=0;\n    while(!PrEmpty(P))\n    {\n        PrInsert(PrDeleteMin(&P), &S);\n        counter++;\n    }\n    while(!PrEmpty(S))\n    {\n        PrInsert(PrDeleteMin(&S), &P);\n    }\n    return counter;\n}\n```\n\n\n2)\n\n```\n//This one is dependent on Priority Queue implementation but doesn't destroy the Priority Queue. \nint Number(PriorityQueue A){\n    int returning_number=1;\n    if (A == NULL)\n        return 0;\n    if(A->left!=NULL)\n        returning_number+=Number(A->left);\n    if(A->right!=NULL)\n        returning_number+=Number(A->right);\n    return returning_number;\n}\n```\n\n    ", "Answer": "\r\nYou can solve this with a recursive algorithm that does not depend on function you list.\nThe code could be like this :\n\n```\nint Number(PriorityQueue A)\n{\n    if(!A) return 0;\n\n    return 1 + Number(A->left) + Number(A->right);\n}\n```\n\n\nThis is the best way to solve this for my opinion.\n\nif you have some trouble on recursion i leave you a useful link:\n\nrecursion\n\nEdit:\n\nI don't think there is a possible to abstract from the struct of priority queue this because the implementation of ```\nPrEmpty```\n, ```\nPrInsert```\n, ```\nPrDeleteMin```\n, and ```\nPreorder```\n already depends on the struct of priority queue. So why search for an implementation that depends only on these function? Also to be generic you can define another function that search for an element without delete them and implement it at the same level of the above function, or better a simple iterator over the priority queue.   \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ Priority Queue Declaration\r\n                \r\nI'm looking at a declaration of a priority queue in C++ but I don't quite understand it.\n\n```\npriority_queue<string, vector<string>,function<bool(string,string)>>\nmin_heap([] (const string& a,const string& b) {return a.size()>=b.size();});\n```\n\n\nWhat is the purpose of the brackets []? Is that part of the function definition?\n\nAlso, would I be able to implement the same thing by using a bool operator?\n    ", "Answer": "\r\nThe entire expression\n\n```\n[] (const string& a,const string& b) {return a.size()>=b.size();}\n```\n\n\nis a lambda expression. It is an object of an unnamed class that can be called with two string arguments, ```\na```\n and ```\nb```\n, and returns ```\nbool```\n.\n\nYou could also write such a class yourself (in that case, it would have a name):\n\n```\nstruct Comp {\n    bool operator()(const string& a, const string& b) {\n        return a.size() > b.size();\n    }\n};\npriority_queue<string, vector<string>, Comp> min_heap;\n// a value of type Comp will be value-initialized\n```\n\n\nNote that the comparator must be a strict weak ordering, so you must use ```\n>```\n instead of ```\n>=```\n.\n\nIf performance matters, it is better to define a named class, because the function call operator can be inlined.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do I implement a priority queue with explicit links (using a triply linked datastructure)?\r\n                \r\nI am trying to implement a priority queue, using a triply linked data structure. I want to understand how to implement sink and swim operations, because when you use an array, you can just compute the index of that array and that's it. Which doesn't make sense when you use a triply-linked DS.\n\nAlso I want to understand how to correctly insert something in the right place, because when you use an array, you can just insert in the end and do a swim operation, which puts everything in the right place, how exactly do I compute that \"end\" in a linked DS?\n\nAnother problem would be removing the element with the biggest priority. To do that, for an array implementation, we just swap the last element with the first (the root) one and then, after removing the last element, we sink down the first one.\n\n(This is a task from Sedgewick).\n    ", "Answer": "\r\nI posted this in case someone gets stuck doing this exercise from Sedgewick, because he doesn’t provide a solution for it.\n\nI have written an implementation for maximum oriented priority queue, which can be modified according for any priority.\n\nWhat I do is assign a size to each subtree of the binary tree, which can be defined recursively as size(x.left) + size(x.right) + 1. I do this do be able to find the last node inserted, to be able to insert and delete maximum in the right order. \n\nHow sink() works:\nSame as in the implementation with an array. We just compare x.left with x.right and see which one is bigger and swap the data in x and max(x.left, x.right), moving down until we bump into a node, whose data is <= x.data or a node that doesn’t have any children.\n\nHow swim() works:\nHere I just go up by doing x = x.parent, and swapping the data in x and x.parent, until x.parent == null, or x.data <= x.parent.\n\nHow max() works:\nIt just returns root.data.\n\nHow delMax() works:\nI keep the last inserted node in a separate field, called lastInserted. So, I first swap root.data with lastInserted.data. Then I remove lastInserted by unhooking a reference to it, from its parent. Then I reset the lastInserted field to a node that was inserted before. Also we must not forget to decrease the size of every node on the path from root to the deleted node by 1. Then I sink the root data down.\n\nHow insert() works:\nI make a new root, if the priority queue is empty. If it’s not empty, I check the sizes of x.left and x.right, if x.left is bigger in size than x.right, I recursively call insert for x.right, else I recursively call insert for x.left. When a null node is reached I return new Node(data, 1). After all the recursive calls are done, I increase the size of all the nodes on the path from root to the newly inserted node.\n\nHere are the pictures for insert():\n\n\n\nAnd here's my java code:\n\n```\npublic class LinkedPQ<Key extends Comparable<Key>>{\n    private class Node{\n        int N;\n        Key data;\n        Node parent, left, right;\n        public Node(Key data, int N){\n            this.data = data; this.N = N;\n        }\n    }\n    // fields\n    private Node root;\n    private Node lastInserted;\n    //helper methods\n    private int size(Node x){\n        if(x == null) return 0;\n        return x.N;\n    }\n    private void swim(Node x){\n        if(x == null) return;\n        if(x.parent == null) return; // we're at root\n        int cmp = x.data.compareTo(x.parent.data);\n        if(cmp > 0){\n            swapNodeData(x, x.parent);\n            swim(x.parent);\n        }\n    }\n    private void sink(Node x){\n        if(x == null) return;\n        Node swapNode;\n        if(x.left == null && x.right == null){\n            return;\n        }\n        else if(x.left == null){\n            swapNode = x.right;\n            int cmp = x.data.compareTo(swapNode.data);\n            if(cmp < 0)\n                swapNodeData(swapNode, x);\n        } else if(x.right == null){\n            swapNode = x.left;\n            int cmp = x.data.compareTo(swapNode.data);\n            if(cmp < 0)\n                swapNodeData(swapNode, x);\n        } else{\n            int cmp = x.left.data.compareTo(x.right.data);\n            if(cmp >= 0){\n                swapNode = x.left;\n            } else{\n                swapNode = x.right;\n            }\n            int cmpParChild = x.data.compareTo(swapNode.data);\n            if(cmpParChild < 0) {\n                swapNodeData(swapNode, x);\n                sink(swapNode);\n            }\n        }\n    }\n    private void swapNodeData(Node x, Node y){\n        Key temp = x.data;\n        x.data = y.data;\n        y.data = temp;\n    }\n    private Node insert(Node x, Key data){\n        if(x == null){\n            lastInserted = new Node(data, 1);\n            return lastInserted;\n        }\n        // compare left and right sizes see where to go\n        int leftSize = size(x.left);\n        int rightSize = size(x.right);\n\n        if(leftSize <= rightSize){\n            // go to left\n            Node inserted = insert(x.left, data);\n            x.left = inserted;\n            inserted.parent = x;\n        } else{\n            // go to right\n            Node inserted = insert(x.right, data);\n            x.right = inserted;\n            inserted.parent = x;\n        }\n        x.N = size(x.left) + size(x.right) + 1;\n        return x;\n    }\n    private Node resetLastInserted(Node x){\n        if(x == null) return null;\n        if(x.left == null && x.right == null) return x;\n        if(size(x.right) < size(x.left))return resetLastInserted(x.left);\n        else                            return resetLastInserted(x.right);\n    }\n    // public methods\n    public void insert(Key data){\n        root = insert(root, data);\n        swim(lastInserted);\n    }\n    public Key max(){\n        if(root == null) return null;\n        return root.data;\n    }\n    public Key delMax(){\n        if(size() == 1){\n            Key ret = root.data;\n            root = null;\n            return ret;\n        }\n        swapNodeData(root, lastInserted);\n        Node lastInsParent = lastInserted.parent;\n        Key lastInsData = lastInserted.data;\n        if(lastInserted == lastInsParent.left){\n            lastInsParent.left = null;\n        } else{\n            lastInsParent.right = null;\n        }\n\n        Node traverser = lastInserted;\n\n        while(traverser != null){\n            traverser.N--;\n            traverser = traverser.parent;\n        }\n\n        lastInserted = resetLastInserted(root);\n\n        sink(root);\n\n        return lastInsData;\n    }\n    public int size(){\n        return size(root);\n    }\n    public boolean isEmpty(){\n        return size() == 0;\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to use a Priority Queue with Spring boot AsyncConfigurer\r\n                \r\nI have a application where I have multiple threads reading messages from a jms destination. The listener thread reads the message, makes some changes to it and calls several other methods of different classes. These methods are annotated with ```\n@Async```\n annotation that all the methods gets executed in parallel using a custom ```\nThreadPoolTaskExecutor```\n.\n\n```\n@Override\npublic Executor getAsyncExecutor() {        \n    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n    executor.setCorePoolSize(corePoolSize);\n    executor.setMaxPoolSize(maxPoolSize);\n    executor.setQueueCapacity(queueCapacity);\n    executor.setKeepAliveSeconds(keepAliveSeconds);\n    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n    executor.setTaskDecorator(new LoggingTaskDecorator());\n    executor.initialize();\n    return executor;\n}\n```\n\n\nUntil now all the messages were considered to be of equal priority everything was fine, as all messages were going into ```\nLinkedBlockingQueue```\n if none of the ```\nExecutor```\n threads left available.\n\nNow, there comes a requirement where a particular type of message read from the queue is expected to be given higher priority than any other message read from the queue. \n\nCurrently, I am using \"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\", which doesn't provide any method where I can set Priority Queue as my Blocking queue implementation. \n\nCould, you please help me solve this scenario? \nOr is that the existing design of the system could not accommodate this change?\nOr what could be the best solution to handle such scenarios?\n\nThanks !\n    ", "Answer": "\r\nBy simply overriding the ```\ncreateQueue```\n method. Also you should use an ```\n@Bean```\n method to create an instance of the bean, that way Spring can properly manage the lifecycle, a small but important thing (else shutdown wouldn't work properly).. \n\n```\n@Override\npublic Executor getAsyncExecutor() {\n  return taskExecutor();\n}        \n\n@Bean    \npublic ThreadPoolTaskExecutor taskExecutor() {        \n  ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor() {\n    protected BlockingQueue<Runnable> createQueue(int queueCapacity) {\n      return new PriorityBlockingQueue<>(queueCapacity);\n    } \n  };\n  executor.setCorePoolSize(corePoolSize);\n  executor.setMaxPoolSize(maxPoolSize);\n  executor.setQueueCapacity(queueCapacity);\n  executor.setKeepAliveSeconds(keepAliveSeconds);\n  executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n  executor.setTaskDecorator(new LoggingTaskDecorator());  \n  return executor;\n}\n```\n\n\nSomething like this should work. The ```\ncreateQueue```\n method now creates a ```\nPriorityBlockingQueue```\n instead of the default ```\nLinkedBlockingQueue```\n. \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue (sink operations)\r\n                \r\nI am practising on priority queue topic from Algorithms book by robert sedgwick. \nIn a question we have to implement ```\nsink()```\n method with out ```\nj < N```\n condition. \n\n```\nprivate void sink(int k){\n    while (2*k <= N){\n         int j = 2*k;\n         if (j < N && less(j, j+1)) j++;\n         if (!less(k, j)) break;\n         exch(k, j);\n         k = j;\n    }\n}\n\nprivate boolean less(int i, int j){ \n    return pq[i].compareTo(pq[j]) < 0;\n}\n\nprivate void exch(int i, int j){ \n    Key t = pq[i]; \n    pq[i] = pq[j]; \n    pq[j] = t;\n}\n```\n\n\nAbove is code from book by Robert sedgwick check page no. 329 and question no 2.4.13\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "PriorityQueue not sorting on add\r\n                \r\nI have a Priority Queue in which I add a Node object to, where the Nodes should be sorted by a value that they contain.  For some reason, the priority queue will not sort the Nodes on add. If anyone can see something wrong with this or has any guidance, I appreciate it. Here is a brief example:\n\n```\nPriorityQueue<Node> PQ = new PriorityQueue<Node>();\n        //for each entry create a node and add it to the PriorityQueue\n        for(Entry<Character,Integer> entry : entries){\n            PQ.add(new Node(entry.getKey(),entry.getValue(), true));\n        }\n```\n\n\nhere is the node's ```\ncompareTo```\n method:\n\n```\n@Override\npublic int compareTo(Node n) {\n  if(n.frequency.intValue() > this.frequency.intValue()) return  -1;\n  else if(n.frequency.intValue() == this.frequency.intValue()) return 0;\n  else return 1;\n}\n```\n\n    ", "Answer": "\r\nI guess you expect ```\nPriorityQueue```\n to return elements in particular order when you iterate it. However, ```\nPriorityQueue```\n doesn't provide such a behaviour, because it's implemented as a priority heap rather than sorted list. From javadoc:\n\n\n  The Iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). \n\n\nThe only guarantee provided by ```\nPriorityQueue```\n is that ```\npoll()```\n, ```\npeek()```\n, etc return the least element. If you need ordered iteration of elements, use some other collection such as ```\nTreeSet```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue and heap\r\n                \r\nI'm trying to implement a priority queue based on the example provided in the documentation.\nDocs: priorityQueue\n\nIn short it looks like this (not everything is included):\n\n```\n    package pq\n\n    type Item struct {\n        container interface{}\n        priority  int\n        index     int\n    }\n\n    type PriorityQueue []*Item\n\n    func NewItem(value interface{}, prio int) *Item {\n        return &Item {container: value, priority: prio}\n    }\n\nfunc (pq PriorityQueue) Len() int {\n    return len(pq)\n}\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority > pq[j].priority\n}\n\nfunc (pq *PriorityQueue) Swap(i, j int) {\n    (*pq)[i], (*pq)[j] = (*pq)[j], (*pq)[i]\n    (*pq)[i].index = i\n    (*pq)[j].index = j\n}\n\n    func (pq PriorityQueue) Push(x interface{}) {\n        fmt.Printf(\"adr: %p\\n\", &pq)\n        n := len(pq)\n        item := x.(*Item)\n        item.index = n\n        pq = append(pq, item)\n    }\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    itm := old[n - 1]\n    itm.index = -1\n    *pq = old[0 : n-1]\n    return itm.container\n}\n```\n\n\nThe ```\nmain.go```\n file:\n\n```\nfunc main() {\n    q := pq.PriorityQueue{}\n    heap.Init(q)\n    fmt.Printf(\"\\nAdr: %p\\n\", &q)\n    q.Push(pq.NewItem(\"h\", 2))\n\n    for i := 0; i < 5; i++ {\n        item := pq.NewItem(\"test\", i * 13 % 7)\n        heap.Push(q, item)\n    }\n\n    for q.Len() > 0 {\n        fmt.Println(\"Item: \" + heap.Pop(q).(string))\n    }\n}\n```\n\n\nAs you can see when comparing to the example I do not use pointers since doing that will give me a compile error telling me that my priority queue does not implement the interface properly.\n\nThis leaves me with the following problem when I do:\n\n```\nheap.Push(q, item)\n```\n\n\nthat the item is not appended to the queue.\n\nI've tried to write out the queues pointer address and it shows different addresses. This explains why it does not work, but souldn't slices not be reference types a long with maps?\n\nAnd more specificly: How do i solve my problem?\n\nHope you can help!\n\nEdit: Added full code and error: cannot use q (type pq.PriorityQueue) as type heap.Interface in function argument:\n    pq.PriorityQueue does not implement heap.Interface (Pop method has pointer receiver)\n    ", "Answer": "\r\nAs the example code shows, the ```\nPush```\n method must have a pointer receiver.\n\nThe trick is that all the calls to ```\nheap.XXX```\n functions, require that you pass your heap in as a pointer (e.g.: ```\nheap.Init(&pq)```\n). This is not the case in the code you posted. Here is a working version of your code. You can run it on the Go playground.\n\nNote that in this code, I explicitly initialize the queue as a pointer: ```\nq := new(PriorityQueue)```\n. And this is what I pass in to all the ```\nheap```\n functions.\n\nThe confusion here arises mostly because you are essentially implementing 2 interfaces.\nThe ```\nheap.Interface```\n and the ```\nsort.Interface```\n (The latter is part of the prior's type definition). But the sort interface is fine with non-pointer receivers, while the other one is not.\n\n```\npackage main\n\nimport \"fmt\"\nimport \"container/heap\"\n\nfunc main() {\n    q := new(PriorityQueue)\n\n    heap.Init(q)\n\n    fmt.Printf(\"\\nAdr: %p\\n\", &q)\n    q.Push(NewItem(\"h\", 2))\n\n    for i := 0; i < 5; i++ {\n        heap.Push(q, NewItem(\"test\", i*13%7))\n    }\n\n    for q.Len() > 0 {\n        fmt.Println(\"Item: \" + heap.Pop(q).(string))\n    }\n}\n\ntype Item struct {\n    container interface{}\n    priority  int\n    index     int\n}\n\ntype PriorityQueue []*Item\n\nfunc NewItem(value interface{}, prio int) *Item {\n    return &Item{container: value, priority: prio}\n}\n\nfunc (pq PriorityQueue) Len() int {\n    return len(pq)\n}\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority > pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index = i\n    pq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    fmt.Printf(\"adr: %p\\n\", pq)\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    itm := old[n-1]\n    itm.index = -1\n    *pq = old[0 : n-1]\n    return itm.container\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "A Priority Queue Implementing 3 Arrays of 5 Items In Java\r\n                \r\nI have 3 arrays of 5 items. Inputting an integer that is less than 99 will place it in the first array, inputting an integer from 101 to 199 will put it into the second and 201-299 will put it into the 3rd array.\n\n```\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class priorityQueue {\n    private int[][] queueArray;\n}\n\npublic priorityQueue() //constructor\n{\n    queueArray = new int[3][5];\n}\n\npublic void printQueue() {\n    System.out.println(Arrays.toString(queueArray));\n}\n\npublic boolean isFull(int[] array){\n    return (array.length-1 == 5);\n}\n\npublic boolean enqueue(int item){\n    //returns true or false if enqueue is not possible\n    //try lower priority queue(s) if necessary\n\n\n} \n```\n\n\nI have no idea how to implement a priority into how integers are inserted, could anyone point me in the right direction?\n    ", "Answer": "\r\nHere's a rudimentary implementation of the requirements, for what it's worth. Note that you can get your index into the first level of ```\nqueueArray```\n by using integer division on your ```\nitem```\n parameter like so: ```\nint whichQueue = item / 100;```\n\n\n\n\n```\nimport java.util.Arrays;\n\npublic class PriorityQueue\n{\n    private int[][] queueArray;\n\n    public PriorityQueue() // constructor\n    {\n        queueArray = new int[3][5];\n    }\n\n    public void printQueue()\n    {\n        System.out.println(Arrays.toString(queueArray));\n    }\n\n    public boolean isFull(int[] array)\n    {\n        return findEmptySlot(array) < 0;\n    }\n\n    public boolean enqueue(int item)\n    {\n        if (item < 1 || item > 299) {\n            throw new IllegalArgumentException(\"item must be between 1 and 299\");\n        }\n        for (int i = item / 100; i < this.queueArray.length; i++) {\n            if (enqueue(item, this.queueArray[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean enqueue(int item, int[] queue) {\n        int emptySlot = findEmptySlot(queue);\n        if (emptySlot >= 0) {\n            queue[emptySlot] = item;\n            return true;\n        }\n        return false;\n    }\n\n    private int findEmptySlot(int[] queue) {\n        for (int i = 0; i < queue.length; i++) {\n            if (queue[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "PriorityQueue not sorting on add\r\n                \r\nI have a Priority Queue in which I add a Node object to, where the Nodes should be sorted by a value that they contain.  For some reason, the priority queue will not sort the Nodes on add. If anyone can see something wrong with this or has any guidance, I appreciate it. Here is a brief example:\n\n```\nPriorityQueue<Node> PQ = new PriorityQueue<Node>();\n        //for each entry create a node and add it to the PriorityQueue\n        for(Entry<Character,Integer> entry : entries){\n            PQ.add(new Node(entry.getKey(),entry.getValue(), true));\n        }\n```\n\n\nhere is the node's ```\ncompareTo```\n method:\n\n```\n@Override\npublic int compareTo(Node n) {\n  if(n.frequency.intValue() > this.frequency.intValue()) return  -1;\n  else if(n.frequency.intValue() == this.frequency.intValue()) return 0;\n  else return 1;\n}\n```\n\n    ", "Answer": "\r\nI guess you expect ```\nPriorityQueue```\n to return elements in particular order when you iterate it. However, ```\nPriorityQueue```\n doesn't provide such a behaviour, because it's implemented as a priority heap rather than sorted list. From javadoc:\n\n\n  The Iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). \n\n\nThe only guarantee provided by ```\nPriorityQueue```\n is that ```\npoll()```\n, ```\npeek()```\n, etc return the least element. If you need ordered iteration of elements, use some other collection such as ```\nTreeSet```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I implement Priority Queue without using any built-in functions?\r\n                \r\nthis is my first question here ever, so formatting and such might be a little off. Please don't hate me :)\n\nSo what I am doing is making a class called PQUEUE and what I have already is: \n\n```\nclass qNode:\n    def __init__(self,data=None, next=None):\n        self.data = data\n        self.next = next\n    def __str__(self):\n        return str(self.data)\n\nclass PQUEUE:\n\n    def __init__(self):\n        self.head = None\n        self.foot = None\n\n    def push(self, value=None, priority=0):\n        #This is what I want to make\n\n    def pop(self):\n        x = self.front.data\n        self.front = self.front.next\n        return x\n\n    def clear(self):\n        self._head = None\n        self._foot = None\n```\n\n\nI am trying to make make a Priority Queue class (as you can see) without using heapq/queue classes or the built-in list methods. \n\nWhat I can't figure out is how I would go on about doing this. I've tried searching everywhere online but everywhere I look people are doing this by either importing or using the built-in list methods. \n\nHelp very appreciated ! :)\n    ", "Answer": "\r\nIt depends on what your definition of priority is, but you're going to have to iterate over your collection yourself, looking for the place to insert the next node:\n\n```\nnode = self.head\nwhile node.next and node.next.priority > priority:\n    node = node.next\n\nif node.next is None:\n    node.next = qNode(value=value, next=None, priority=priority)\n    self.foot = node.next\nelse:\n    new_node = qNode(value=value, next=node.next, priority=priority)\n    node.next = new_node\n```\n\n\nYou'll have to add a ```\npriority```\n to your ```\nqNode```\n, of course, and you may have to adjust exactly where you're going to insert, but this should get you most of the way there.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Issues with insertion function for binary min-heap priority queue\r\n                \r\nI'm currently struggling with an assignment involving the implementation of a priority queue using a binary min-heap. The user inserts values upon startup, and then has the options to insert more values, delete the minimum value, or print the priority queue. I have everything implemented, except that I can't seem to correctly implement my insertion function.\nMy code for the implementation file:\n```\n#include \"PriorityQueue.hpp\"\n#include <iostream>\n\nusing namespace std;\n\nPriorityQueue::PriorityQueue():arrSize(100), currentSize(0){\n  arr = new int[arrSize];\n  for(int i = 0; i <= arrSize; i++){\n    arr[i] = 0;\n  }\n}\n\nbool PriorityQueue::isEmpty(){\n  if (currentSize == 0){\n    return true;\n  }\n  else {\n    return false;\n  }\n}\n\nvoid PriorityQueue::insert(int value){\n  currentSize++;\n  int index = currentSize;\n  arr[index] = value;\n  int parent=(index-1)/2;\n  while(index !=0 && arr[parent]>arr[index]){\n    int temp = arr[index];\n    arr[index]=arr[parent];\n    arr[parent] = temp;\n    index=parent;\n  }\n}\n\nint PriorityQueue::deleteMin(){\n  int min = arr[1];\n  arr[1] = arr[currentSize];\n  currentSize--;\n  percolateDown(1);\n  return min;\n}\n\nvoid PriorityQueue::printQueue(){\n  for (int i = 1; i < currentSize+1; i++){\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n}\n\nvoid PriorityQueue::percolateDown(int hole){\n  int minIndex = hole;\n  int left = (2*hole);\n  int right = (2*hole)+1;\n\n  if (left <= currentSize && arr[left] < arr[minIndex]){\n    minIndex = left;\n  }\n\n  if (right <= currentSize && arr[right] < arr[minIndex]){\n    minIndex = right;\n\n  }\n\n  if(minIndex != hole){\n      int temp = arr[hole];\n      arr[hole] = arr[minIndex];\n      arr[minIndex] = temp;\n    }\n}\n```\n\nFor example, if I insert ```\n100 70 50 125 45 60 10```\n, it will return ```\n50 45 10 125 70 60 100```\n instead of ```\n10 50 45 125 100 70 60```\n. Occasionally, the queue will be correctly ordered. I notice that it almost always fails to put the minimum value in the correct place.\nEdit: Changing the for loop statement in printQueue() to start at 0 instead of 1 doesn't change the output apart from adding an arbitrary 0. I've changed ```\ni <= currentSize```\n to ```\ni < currentSize+1```\n. Currently debugging.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to iterate over a Priority Queue?\r\n                \r\nI'm trying to implement the Uniform-cost search in Python and for that, I need a priority queue, which I'm using queue.py from the standard library. However, the end of the algorithm checks if there is any path with a higher cost in the queue. How can I check if there is any given value in my queue if it's not iterable?\n    ", "Answer": "\r\n```\nqueue.PriorityQueue```\n is actually implemented using a ```\nlist```\n, and the ```\nput```\n/```\nget```\n methods use ```\nheapq.heappush```\n/```\nheapq.heappop```\n to maintain the priority ordering inside that ```\nlist```\n. So, if you wanted to, you could just iterate over the internal list, which is contained in the ```\nqueue```\n attribute:\n\n```\n>>> from queue import PriorityQueue\n>>> q = PriorityQueue()\n>>> q.put((5, \"a\"))\n>>> q.put((3, \"b\"))\n>>> q.put((25, \"c\"))\n>>> q.put((2, \"d\"))\n>>> print(q.queue)\n[(2, 'd'), (3, 'b'), (25, 'c'), (5, 'a')]\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Generic\r\n                \r\nSo I recently learnt about Generics and thought it would be cool to implement them in a Priority Queue. I am having a \"Block\" element which has a firstName and a data variable. The Node for the Priority Queue consists of Block, Next and Prev.\n\nI am attaching the code below. I am almost exclusively getting \"Should be parametrized\" errors/warnings. And an error which says that my \"Data\" element cannot be resolved to a field, which probably means that I am unable to tell that I want Block as my \"element E\" in a Node. Any suggestions will be deeply appreciated\n\n```\npackage QGen;\n\npublic class Block<E> implements Comparable<Block<E>> {\n    protected String firstName;\n    protected int data;\n\n    public Block(String firstName, int data) {\n        super();\n        this.firstName = firstName;\n        this.data = data;\n\n    }\n\n    @Override\n    public int compareTo(Block x) {\n        return (this.data - x.data);\n    }\n}\n\n\npackage QGen;\n\npublic class PriorityQueue<E extends Comparable> {\n    protected Node<E> firstSentinel;\n    protected Node<E> lastSentinel;\n\n    protected class Node<E> {\n        protected Node<E> next;\n        protected Node<E> prev;\n        private E element;\n\n        public Node(E e, Node<E> previous, Node<E> nextt) {\n            element = e;\n            prev = previous;\n            next = nextt;\n        }\n    }\n\n    public PriorityQueue() {\n        firstSentinel = new Node<>(null, null, null);\n        lastSentinel = new Node<>(null, null, null);\n        firstSentinel.data = 11111;\n        lastSentinel.data = 0;\n        firstSentinel.prev = null;\n        firstSentinel.next = lastSentinel;\n        lastSentinel.prev = firstSentinel;\n        lastSentinel.next = null;\n    }\n\n    public void enQueue(E x) {\n        Node<E> newX = new Node<E>(x, null, null);\n        if (firstSentinel.next == lastSentinel)// list is empyty\n        {\n            firstSentinel.next = newX;\n            newX.prev = firstSentinel;\n            newX.next = lastSentinel;\n            lastSentinel.prev = newX;\n        } else {\n            Node<E> temp = newX;\n            Node<E> curr = firstSentinel.next;\n            while (curr != lastSentinel && temp.element.compareTo(curr) <= 0) {// <=comparison\n                // replaced\n                curr = curr.next;\n            }\n            Node<E> tempCurr = curr;\n            temp.next = tempCurr;\n            temp.prev = tempCurr.prev;\n            tempCurr.prev.next = temp;\n            tempCurr.prev = temp;\n\n        }\n    }\n\n    public E deQueue() {\n        if (firstSentinel.next == lastSentinel) {\n            return null;\n        } else {\n            Node<E> temp = new Node<E>(null, null, null);\n            temp = firstSentinel.next;\n            firstSentinel.next = temp.next;\n            temp.next.prev = firstSentinel;\n            return temp.element;\n        }\n    }\n\n    public void printt() {\n        Node<E> temp = new Node<E>(null, null, null);\n        temp = firstSentinel.next;\n        while (temp != lastSentinel) {\n            System.out\n                    .println(temp.element.firstName + \" \" + temp.element.data);\n\n            temp = temp.next;\n        }\n    }\n}\n\npackage QGen;\n\npublic class containsMain<E> {\n\n    public static void main(String[] args) {\n\n        PriorityQueue<Block> example = new PriorityQueue<Block>();\n        Block dequedObject = new Block<>(null, null);\n        Block<Block> incomingName = new Block<>(\"r\", 1);\n        example.enQueue(incomingName);\n        dequedObject = (Block) example.deQueue();\n\n    }\n\n}\n```\n\n\nI am aware that my PriorityQueue might not be the best of implementations and I will improve it. It is the Generics where I am unable to come up with a solution\n\nThanks\n    ", "Answer": "\r\nWithout looking at the logic of your methods, I have several remarks regarding generics:\n\nwhy is Block itself generic? It doesnt hold any generic field so remove it from Block!\n\n```\nnew Node<>(null, null, null);\n// this is a bad idea, change it to new Node<E>(null, null, null)\n\n\nfirstSentinel.data = 11111;\nlastSentinel.data = 0;\n\n//Those two cant work, because firstSentinel is referencing a Node<E> and not a Block! Delete those two rows, as they make no sense in your generic implementation of the Queue\n\nBlock<Block> incomingName = new Block<>(\"r\", 1); \n// This doesnt make sense, should be Block incomingName = new Block(...)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing a Priority Queue with a sorted list [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                This question is unlikely to help any future visitors; it is only relevant to a small geographic area, a specific moment in time,  or an extraordinarily narrow situation that is not generally applicable to the worldwide audience of the internet. For help making  this question more broadly applicable, visit the help center.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nJust finished to write this implementation with a ```\nLinkedList```\n. I know that this is an beginner implementation. There are certainly a lot of mistakes. I just want to know if anyone can tell me the cost of worst case for the ```\ninsert(K key, V value)```\n method. Should I stay in O(n)?\n\nEdited with ```\naddLast()```\n and ```\ngetLast()```\n methods in ```\nLinkedList```\n and using ```\nListIterator```\n instead of ```\nIterator```\n.\n\npublic class SortedListPriorityQueue implements PriorityQueue {\n\n```\nprotected List<Entry<K,V>> entries;\nprotected Comparator<K> c;\n\nprivate static class MyEntry<K,V> implements Entry<K,V>{\n\n    protected K key;\n    protected V value;\n\n    public MyEntry(K key, V value){\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public K getKey() {\n        return this.key;\n    }\n\n    @Override\n    public V getValue() {\n        return this.value;\n    }\n}\n\n\n/**\n * Crea la coda con il comparatore DefaultComparator\n */\npublic SortedListPriorityQueue() {\n    entries = new LinkedList<Entry<K,V>>();\n    c = new DefaultComparator<K>();\n}\n\n/* Utilizza un comparatore specifico\n public SortedListPriorityQueue(Comparator<K> comp) {}\n*/\n\n@Override\npublic int size() {\n    return entries.size();\n}\n\n@Override\npublic boolean isEmpty() {\n    return entries.isEmpty();\n}\n\n@Override\npublic Entry<K, V> min() {\n    if(entries.isEmpty()) throw new RuntimeException(\"Priority queue is empty\");\n    else return entries.get(0);\n}\n\n@Override\npublic Entry<K, V> removeMin() {\n    if(entries.isEmpty()) throw new RuntimeException(\"Priority queue is empty\");\n    else return entries.remove(0);\n\n}\n\n@Override\npublic Entry<K, V> insert(K key, V value) {\n    Entry<K,V> new_entry = new MyEntry<K,V>(key, value);\n\n    insertEntry(new_entry);\n    return new_entry;\n}\n\nprivate void insertEntry(Entry<K, V> e) {\n    //caso base1: lista vuota\n    if(entries.isEmpty()){\n        entries.add(e);\n        return;\n    }\n\n    // caso base2: inserisce alla fine della lista\n    else if(c.compare(e.getKey(), ((LinkedList<Entry<K, V>>) entries).getLast().getKey()) > 0){\n        ((LinkedList<Entry<K,V>>) entries).addLast(e);\n        return;\n    }\n\n    ListIterator<Entry<K,V>> it = entries.listIterator();\n    Entry<K,V> current = null;\n\n    while(it.hasNext()){\n        current = it.next();\n        if(c.compare(e.getKey(), current.getKey()) < 0){\n            it.add(e);\n            return;\n        }\n    }\n}\n```\n\n\n}\n    ", "Answer": "\r\nYes, your worst-case insert time is ```\nO(n)```\n - inserting something that appears near the end of the list.  You spend ```\nO(n)```\n time to find the correct index, then ```\nO(n)```\n time inside ```\nLinkedList.add```\n to insert it.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Prim's algorithm, using a priority queue\r\n                \r\nI'm trying to implement prim's algorithm, using a priority queue. When I call offer() method, it gives me a class cast exception, saying that vertex cannot be cast to comparable. Is there a workaround?  \n\n```\npublic static Collection<Edge> prims(Graph g, int start) {\n            ArrayList<Edge> mst = new ArrayList<Edge>();\n            PriorityQueue<Vertex> vertices = new PriorityQueue<Vertex>();\n            Vertex startVertex;\n\n        for (Vertex vertex : g.getVertices()) {\n            vertices.offer(vertex);\n            if (vertex.getId() == start) {\n                startVertex = vertex;\n            }\n        }\n\n        if (!mst.isEmpty()) {\n            return mst;\n        }\n\n        return null;\n    }\n}\n```\n\n    ", "Answer": "\r\nPrims algorithm uses the weight of the edge to determine the best path. Posting the vertex to the ```\nPriorityQueue```\n will not work.\n\nI am guessing your ```\nEdge```\n class will implement ```\nComparable```\n by comparing their lengths.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Dijkstra's Algorithm Java implementation with Priority Queue\r\n                \r\nHi I am trying to find an minimum possible route in my weighted graph using Dijkstra'a algorithm. I am trying to implement the algorithm below from geeksforgeeks.com :\n\n```\n1) Initialize distances of all vertices as infinite.\n\n2) Create an empty priority_queue pq.  Every item\n   of pq is a pair (weight, vertex). Weight (or \n   distance) is used used as first item  of pair\n   as first item is by default used to compare\n   two pairs\n\n3) Insert source vertex into pq and make its\n   distance as 0.\n\n4) While either pq doesn't become empty\n    a) Extract minimum distance vertex from pq. \n       Let the extracted vertex be u.\n    b) Loop through all adjacent of u and do \n       following for every vertex v.\n\n           // If there is a shorter path to v\n           // through u. \n           If dist[v] > dist[u] + weight(u, v)\n\n               (i) Update distance of v, i.e., do\n                     dist[v] = dist[u] + weight(u, v)\n               (ii) Insert v into the pq (Even if v is\n                    already there)\n\n5) Print distance array dist[] to print all shortest\n   paths. \n```\n\n\nMy main Data Structures are:\n\n```\n // HashMap of Intersections \n    private static HashMap<String, Intersection> intersections;\n    // Edge/Rail List\n    private static ArrayList<Rail> railList;\n```\n\n\nMy function below called route and it first gets source and destination \n vertexes from the commands as String and then i try to implement algorithm above. However i do not know how to store them in final Arraylist so that i  can return the path.Additionally, it is problematic i think:\n\n```\npublic void route(String wholeLine){\n        String[] temp = wholeLine.split(\" |\\\\>\");\n        int vel = Integer.parseInt(temp[3]);\n        double totalpath = 0;\n        int numOfSwitches = 0;\n        // My Source and Destination Nodes\n        Intersection src = intersections.get(temp[1]);\n        Intersection dest = intersections.get(temp[2]);\n        // Start the operation\n        PriorityQueue<Intersection> pq = new PriorityQueue<RailNetwork.Intersection>();\n        // Setting Distance to 0 for Source Node\n        src.setDistanceFromSource(0);\n        pq.add(src);\n        // While Priority Queue not empty\n        while(pq.size() != 0){\n            // Extract the vertex with minimum distance value node from Min Heap. Let the extracted vertex be u.\n            Intersection u = pq.remove();\n            // For every adjacent vertex v of u, check if v is in Min Heap. \n\n            for(Intersection v : u.getNeigbours()){\n                double weight = 0;\n                // Find edgeweight of u and v from rail/edge list\n                for(int i = 0;i<railList.size();i++){\n                    if(railList.get(i).getSrc().getLabel().equals(u.label) && railList.get(i).getDest().getLabel().equals(v.label)){\n                        weight = railList.get(i).getDistance();\n                    }\n                    else if(railList.get(i).getSrc().getLabel().equals(v.label) && railList.get(i).getDest().getLabel().equals(u.label)){\n                        weight = railList.get(i).getDistance();\n                    }\n                }\n                //If v is in Min Heap and distance value is more than weight of u-v plus distance value of u, then update the distance value of v.\n                if(u.getDistanceFromSource() > v.getDistanceFromSource() + weight){\n                    //Update distance of v, i.e., do dist[v] = dist[u] + weight(u, v)\n                    v.setDistanceFromSource(u.getDistanceFromSource() + weight);\n                    System.out.println(v.label + \"\\t\" + v.distanceFromSource);\n                    pq.add(v);\n                }\n            }\n\n        }\n    }\n```\n\n\n**Could someone please help me to find my mistakes in order to implement it correctly?**Any help or hint is appreciated. Thanks in advance stackoverflow family.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ STL priority queue of Node Pointers\r\n                \r\nI'm trying to implement a priority queue of ```\nNode*```\n, where Node is a class I have defined myself.  I realized that having a priority queue of pointers would mean that it would sort based on the address, rather than the value that the Node held, and so I searched through quite a few discussion forums to find a solution that would allow me to specify how to sort the Node objects in the priority queue; most agree that you need to write a struct that contains a function that takes as arguments 2 Node objects and returns the desired comparison.  The following is my Node class (abbreviated) and the struct I wrote to compare 2 Node objects, which are in the same header file:\n\n```\nclass Node {\n\npublic:\n\n  ...\n\n  int fValue() const { cerr << fValue() << endl; return c + h; };\n\n  ...\n\nprivate:\n  ...\n  int c;\n  int h;\n\n  ...\n};                                                                                             \n\nstruct CompareNode : public std::binary_function<Node*, Node*, bool>                                                                                     \n{\n  bool operator()(const Node* lhs, const Node* rhs) const\n  {\n    return lhs->fValue() < rhs->fValue();\n  }\n}\n```\n\n\nI construct the priority queue as a member of another class in a different header file that includes the header file that contains the above definitions.  This class is abbreviated as follows:\n\n```\nclass Astar {\n\npublic:\n\n  ...\n\nprivate:\n\n  ...\n  priority_queue<Node*, vector<Node*>, CompareNode> frontier;\n};\n```\n\n\nWhen I try to compile, I get this error:\n\nastar.h:28: error: multiple types in one declaration\nmake: * [astar.o] Error 1\n\nwhere line 28 of astar.h corresponds to the end of the Astar class (```\n};```\n).\n\nSince this is the solution provided on most forums, I don't understand what's going on here.  Does anyone have any insight for me?\n    ", "Answer": "\r\nThe class before Astar lacks the terminating ;\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java - Sorting in Comparator for use in Priority Queue\r\n                \r\nI am a bit confused on how to determine which way a priority queue sorts based on implementation in the comparator. Here, I want to sort based on descending ```\nFScore```\n, so that means the lowest ```\nFScore```\n would be at the top of the queue. I'm not sure if I did this correctly (I am using this for A * algorithm).\n\n```\nprivate class puzzleStateComparator implements Comparator<PuzzleState> {\n\n    @Override\n    public int compare(PuzzleState o1, PuzzleState o2) {\n        //TODO\n\n        int[] goalState = FastPuzzleSolver.this.initialState.getStateArray();\n\n        int o1GScore = PuzzlePropertyUtility.numBlocksOutOfPlace(o1.getStateArray(), goalState);\n        int o2GScore = PuzzlePropertyUtility.numBlocksOutOfPlace(o2.getStateArray(), goalState);\n\n        int o1HScore = PuzzlePropertyUtility.calcManhattanDistanceSum(o1.getStateArray(), goalState);\n        int o2HScore = PuzzlePropertyUtility.calcManhattanDistanceSum(o2.getStateArray(), goalState);\n\n        int o1FScore = o1GScore + o1HScore;\n        int o2FScore = o2GScore + o2HScore;\n\n        return o1FScore - o2FScore;\n\n\n    }\n```\n\n    ", "Answer": "\r\nOne important thing, the correct way to compare two ints is this:\n\n```\n//ascending order\nreturn Integer.compare( o1Fscore, o2Fscore );\n\n//descending order\nreturn Integer.compare( o2Fscore, o1Fscore );\n```\n\n\nComparing ints with subtraction may lead to over/underflow issues.\n\nIf you're using ```\njava.util.PriorityQueue```\n, then you definitely need the descending version, as the API doc says:\n\n\n  The head of this queue is the least element with respect to the\n  specified ordering. If multiple elements are tied for least value, the\n  head is one of those elements -- ties are broken arbitrarily. The\n  queue retrieval operations poll, remove, peek, and element access the\n  element at the head of the queue.\n\n\nAs a complete aside: if ```\nPuzzleState```\n is immutable (as it probably should be), it's worth calculating the G and H scores only once per state.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "heaps and priority queue with pseudocode\r\n                \r\nI have a question at school that i need to find the kth minimum elements in a min heap. the run time that was required is o(k^2) and i understood how to do that. but if i can get it down to o(k*logk) that i get a bonus. i thought about doing a priority queue from the min heap and then inserting the node of the heap to the queue and then taking it out then doing the same thing with the children of the root of the minimum heap and so on k times. i know that the time complexity of insert and pop operations is o(logk) since The initial size of the priority queue is one, and it increases by at most one at each of the k  steps. Therefore, there are maximum k+1 elements in the priority queue.\ni understand what i need to do but find it complex to implement it in pseudo code any ideas or guidelines would be great.\nThank you\n    ", "Answer": "\r\nYes, your idea sounds good. I will show how to do this in Python.\nBuild heap from array\nSo, first build a min heap on top of your input array:\n```\ndef create_min_heap(array):\n    min_heap = []\n    for value in array:\n        heappush(min_heap, value)\n\n    return min_heap\n```\n\nCount k min elements off the heap\nCreate a helper min-heap that will be used to retrieve all ```\nk```\n minimum elements in O(klogk). At each step, a minimum element will be popped from it, and its ```\n2```\n children nodes will be added (children can be found in the original min-heap). Please note, that it doesn't make sense to add children of other nodes to the helper min-heap because they cannot be smaller than their parents (per heap property).\n```\ndef k_min_elements(min_heap, k):\n    result = list()\n    helper_min_heap = []\n    heappush(helper_min_heap, (min_heap[0],0))\n    while len(result) < k:\n        min_node = heappop(helper_min_heap)\n        value = min_node[0]\n        index = min_node[1]\n\n        left_index = index*2 + 1\n        right_index = left_index + 1\n        if left_index < len(min_heap):\n            heappush(helper_min_heap, (min_heap[left_index], left_index))\n        if right_index < len(min_heap):\n            heappush(helper_min_heap, (min_heap[right_index], right_index))\n\n        result.append(value)\n\n    return result \n```\n\nFull Code\nNow, the full code and sample output.\n```\nfrom heapq import heappop\nfrom heapq import heappush\n\ndef create_min_heap(array):\n    min_heap = []\n    for value in array:\n        heappush(min_heap, value)\n\n    return min_heap\n\ndef k_min_elements(min_heap, k):\n    if k > len(min_heap) or k < 0:\n        raise Exception(\"k is invalid\")\n\n    result = list()\n    helper_min_heap = []\n    heappush(helper_min_heap, (min_heap[0],0))\n    while len(result) < k:\n        min_node = heappop(helper_min_heap)\n        value = min_node[0]\n        index = min_node[1]\n\n        left_index = index*2 + 1\n        right_index = left_index + 1\n        if left_index < len(min_heap):\n            heappush(helper_min_heap, (min_heap[left_index], left_index))\n        if right_index < len(min_heap):\n            heappush(helper_min_heap, (min_heap[right_index], right_index))\n\n        result.append(value)\n\n    return result\n\n\nmin_heap = create_min_heap([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])\nprint (k_min_elements(min_heap, 3))\n```\n\n\n[0, 1, 2]\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "I need an advice for optimal implementation of a program with priority queue and search\r\n                \r\nI have to make a program to read the list of patient of an hospital from a file, every patient have a  priority.\n\nSo i decide to make the priority queue in a binary heap because insert and deletion are O log(n), and obtain the patient to be treated is O(1), good enough for this program. I stored the heap in a dynamic array of pointers to the struct patient. This works fine.\n\nBut also i have to be able to find a patient by his security number, and this is not possible in a heap (so far i know).\n\nSo i was thinking to make a hash table where when i add a patient to the heap hi is going to be added to the hash table too (all this work is with pointers).\n\nThis is a good way to proceed? or i have to rethink the data structures to be use and remake the program using another ADT? (please no).\n\nCode of the structs:\n\n```\ntypedef struct patient {\n  char name[20];\n  char lastName[20];\n  char securityNumber[20];\n  char birthDate[8];\n  int priority;\n}PATIENT;\n\ntypedef struct binary_heap{\n  PAT** patHeap;\n  int n;\n}HEAP;\n```\n\n\nInsert and deletion are good enough in a heap and a hash table. But have more pointers is more memory to be use.\n\nThis is my really first time making this kind of \"real programs\" so i will be very thankful if you people can give any advice. \n\nThanks!\n    ", "Answer": "\r\nquestion: how to select patient via social security number?\n\nIF the social security number is a field in the struct being used to make nodes in the linked list.  The simply start at the head pointer of the linked list, stepping one by one through the linked list.  at each node in the linked list, compare the target social security number with the entry in the node.  When a match is found, then the pointer to that node is pointing to the desired patient.\n\nHowever, learn a bit about social security numbers.  For instance, they are not ###-##-#### but rather ###-##-####c, where the final 'c' (a character) is rarely used these days.\n\n```\nif you had posted the code, \nthen we could post matching code \nfor the function that finds a patient \nvia their social security number.\n\nBTW:\na patients social security number is a bit of sensitive information. \nso the code should encrypt that field.\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Node SQS Priority Queue\r\n                \r\nI need to implement a Priority Queue with ```\nnode.js```\n and ```\nSQS```\n. It's my first time with ```\nSQS```\n so I would like to hear your opinions.\n\nI have 3 priorities for the jobs: p0, p1 and p2, p0 being the highest.\np2 is the most frequent, after that p0 and last p1. In numbers I could roughly say it's:\n\n```\np2 ~= 5p0\np0 >> p1\n```\n\n\nThey are all independent jobs so order of performing them is not important.\n\nI came up with 2 possible solutions (these are just sketches that aren't really running).\n\ncommon to both\n\n```\nvar _ = require('lodash'),\n    Promise = require('bluebird'),\n    sqs = require('some-sqs-module');\n\n...\n\nmodule.exports.getJob = function() {\n    return getJobByQueuePriority(0);\n    // or...\n    return getJobByJobPriority(0);\n}\n```\n\n\nsolution 1\n\nUse 3 queues, one per priority. Sample 1 job from each queue by their priorities\n\n```\nvar Queues = [p0url, p1url, p2url],\n    currentQueueIndex = 0;\n\nfunction getJobByQueuePriority(priority) {\n    return new Promise(function(resolve, reject) {\n\n        var queueUrl = getNextQueue(priority);\n\n        if(!_.isEmpty(queueUrl)){\n            sqs.pullOne(queueUrl)\n                .then(function (job) {\n                    // recursive promises???\n                    return job ? resolve(job) : getJobByQueuePriority(priority + 1);\n                })\n                .catch(function (err) {\n                    reject(err);\n                });\n        }\n    });\n}\n\nfunction getNextQueue(index) {\n    return index >= Queues.length ? '' : Queues[index];\n}\n```\n\n\nsolution 2\n\nUse 1 queue and collect k jobs from it, then select the highest ranking job.\n\n```\nvar QUEUE_URL = 'some/sqs/url', \n    JOBS_TO_PULL = 10;\n\nfunction getJobByJobPriority (priority) {\n    return new Promise(function (resolve, reject) {\n        sqs.pullMultiple(QUEUE_URL, JOBS_TO_PULL)\n            .then(function (jobs) {\n                var job = getHighestPriorityJob(jobs);\n                resolve(job);\n            })\n            .catch(function (err) {\n                reject(err);\n            });\n    });\n}\n\nfunction getHighestPriorityJob(jobs) {\n    var highest = jobs[0];\n\n    _.each(jobs, function (job) {\n        if(job.priority < highest.priority){\n            highest = job;\n        }\n\n        if(highest.priority == HIGHEST_PRIORITY) break;\n    });\n\n    return highest;\n}\n```\n\n\nand here's my wanted consumer\n\n```\nvar pq = require('my-priority-queue');\n\nfunction lookForWork() {\n    pq.getJob()\n        .then(function (job) {\n            job ? work(job) : rest();\n        }); \n}\n\nfunction work(job) {\n    // do your work...\n\n    // search for more work\n    lookForWork();\n}\n\nfunction rest() {\n    (setTimeout(function () {\n        lookForWork();\n    }, TIME_TO_REST))();\n}\n```\n\n\nit's all sketches so never mind small glitches if you see them.\n    ", "Answer": "\r\nA different queue for each priority is the better way to go imo. Its more scalable (for example you could add more consumers that only process the P2 queue for example if you ever needed to).\n\nWith a single queue, every time you pull messages from the queue and don't use them, you are preventing another consumer from seeing those at all until they are returned.\n\nNot sure what your volumes are, and even though SQS is cheap, reading lots of messages and not using them still incurs a charge.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Making a priority queue using a Heap. Without using \"queue\" or \"heapq\"\r\n                \r\nI have made a heap class and I am trying to make a PriorityQueue class as well so both of them can work together. However, I need help on the Priority Queue part of my code. I have already made a working Heap. I tried looking up help on the internet but I keep getting answers with people using either the \"queue\" or \"heapq\" python implementation. Could anyone help me on how to make a working Priority Queue class? I have the basic function names written down but I have no idea on where to go from there. Please I have been stuck on this for awhile and really need some help. Here is my working Heap Code.\n\n```\nclass Heap(object):\n\n    def __init__(self, items=None):\n\n        '''Post: A heap is created with specified items.'''\n\n        self.heap = [None]\n        if items is None:\n            self.heap_size = 0\n        else:\n            self.heap += items\n            self.heap_size = len(items)\n            self._build_heap()\n\n    def size(self):\n\n        '''Post: Returns the number of items in the heap.'''\n\n        return self.heap_size\n\n    def _heapify(self, position):\n\n        '''Pre: Items from 0 to position - 1 satisfy the Heap property.\n       Post: Heap Property is satisfied for the entire heap.'''\n\n        item = self.heap[position]\n        while position * 2 <= self.heap_size:\n            child = position * 2\n            # If the right child, determine the maximum of two children.\n            if (child != self.heap_size and self.heap[child+1] > self.heap[child]):\n                child += 1\n            if self.heap[child] > item:\n                self.heap[position] = self.heap[child]\n                position = child\n            else:\n                break\n        self.heap[position] = item\n\n    def delete_max(self):\n\n        '''Pre: Heap property is satisfied\n       Post: Maximum element in heap is removed and returned. '''\n\n        if self.heap_size > 0:\n            max_item = self.heap[1]\n            self.heap[1] = self.heap[self.heap_size]\n            self.heap_size -= 1\n            self.heap.pop()\n            if self.heap_size > 0:\n                self._heapify(1)\n            return max_item\n\n    def insert(self, item):\n\n        '''Pre: Heap Property is Satisfied.\n       Post: Item is inserted in proper location in heap.'''\n\n        self.heap_size += 1\n        # extend the length of the list.\n        self.heap.append(None)\n        position = self.heap_size\n        parent = position // 2\n        while parent > 0 and self.heap[parent] < item:\n            # Move the item down.\n            self.heap[position] = self.heap[parent]\n            position = parent\n            parent = position // 2\n        # Puts the new item in the correct spot.\n        self.heap[position] = item\n\n    def _build_heap(self):\n\n        ''' Pre: Self.heap has values in 1 to self.heap_size\n           Post: Heap property is satisfied for entire heap. '''\n\n        # 1 through self.heap_size.\n\n        for i in range(self.heap_size // 2, 0, -1): # Stops at 1.\n            self._heapify(i)\n\n    def heapsort(self):\n\n        '''Pre: Heap Property is satisfied.\n           Post: Items are sorted in self.heap[1:self.sorted_size].'''\n\n        sorted_size = self.heap_size\n\n        for i in range(0, sorted_size -1):\n            # Since delete_max calls pop to remove an item, we need to append a dummy value to avoid an illegal index.\n            self.heap.append(None)\n            item = self.delete_max()\n            self.heap[sorted_size - i] = item\n```\n\n\nSo this is working but like I previously stated I am having trouble on how to make a priority queue out of this? I know asking for code is wrong, but I'm desperate could anyone help me out here? I have the basic rundown on what I want my priority code to do..\n\n```\n#PriorityQueue.py\nfrom MyHeap import Heap\n\n\nclass PriorityQueue(object):\n\n    def enqueue(self, item, priority):\n        '''Post: Item is inserted with specified priority in the PQ.'''\n\n    def first(self):\n    '''Post: Returns but does not remove the highest priority item from the PQ.'''\n\n    def dequeue(self):\n    '''Post: Removes and returns the highest priority item from the PQ.'''\n\n    def size(self):\n    '''Post: Returns the number of items in the PQ.'''\n        return Heap.heap_size\n```\n\n    ", "Answer": "\r\nI think the key idea you're missing to implement your ```\nPriorityQueue```\n class is that each ```\nPriorityQueue```\n instance should have a ```\nHeap```\n instance as an attribute. Set it up in ```\n__init__```\n:\n\n```\nclass PriorityQueue(object):\n    def __init__(self)\n        self.heap = Heap()\n```\n\n\nWhen a user makes a call to a ```\nPriorityQueue```\n method, that method will mostly just make a call to a method of ```\nself.heap```\n, with just a little extra work modifying the arguments or the return value. The items to ```\ninsert```\n into the heap should probably be ```\n(priority, value)```\n tuples, since they will compare appropriately (higher priority items comparing higher).\n\nNote that if you compare code written for ```\nheapq```\n with your ```\nHeap```\n, you'll need to modify the logic for the indexes and priorities, since ```\nheapq```\n implements a zero-indexed min-heap, and your code implements a one-indexed max-heap.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "When to use array and priority queue respectively for Prim's algorithm?\r\n                \r\nThis is an old exam question.\n\nUnder what condition on (V, E) should we implement the min-priority queue of Prim's\nalgorithm using an array (indexed by the vertices) rather than a heap (with logarithmic-time\nimplementations of both the Extract-Min and Decrease-Key operations)?\n\nUnder what condition on (V, E) should we implement the min-priority queue of Prim's\nalgorithm using an ordered array?\n    ", "Answer": "\r\nPrim's runs in O(mlog(n)) time with the binary heap implementation and m being the # of edges and n being the # of vertices.  However, when a graph is very dense, m is very large, then Prim's runs in O(n^2log(n)) .  You can create a graph with a large number(n) of vertices and connect all the vertices to each other to convince yourself of this.  so.... (n-1) + (n-2) + (n-3) ...... (n-n+1). \n\nThis can be re written as \n\nn(n+1)/2 which is O(n^2) as documented on\n\nthe priority queue array implementation runs in O(n^2) time which is documented on the wikipedia page here, although I don't have a proof for it.\n\nSo it is better to use the adjacency matrix when m very large.\n\nYou asked for a condition and I would say when m is very large and the same order as n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementation of a locally ordered set or priority queue?\r\n                \r\nI have a rather large set of objects that represent numbers and I want to select such numbers according to a custom ordering. This ordering includes several criteria such as the type of their representation (some numbers are represented by an interval), their integrality and ultimatively their value. These numbers are shared throughout the programs (shared pointers) and there is nothing I can do about this.\n\nHowever, the elements properties can change at any time such that the order changes while I can't notify the container about this. For example, some operations require a refinement of a number that is represented by an interval and during this refinement, the exact value can be found. Thereby, the number changes from the interval representation to a rational number, possibly even an integer. This change, due to the shared instance, immediately propagates to the number in the container and breaks the ordering (and I don't even know which number changed). This totally breaks ```\nstd::set```\n.\n\nSo what I'd like to have is a container that tries to be sorted, but does not rely on this. Whenever an operation detects an incorrect ordering, this ordering should be corrected locally. For example ```\ninsert```\n would insert the element (using binary search) and always check if the ordering of the current element (w.r.t. the neighbors) is correct.\n\nI'd be willing to accept that \"give me the smallest element\" would then be only \"give me a small element\" and that ```\nfind```\n or ```\nremove```\n would have linear complexity: I only need ```\nfront```\n, ```\ninsert```\n and ```\nremove_front```\n to be particularly efficient.\n\nIs there any implementation that does something like this?\nHow would you implement this?\n    ", "Answer": "\r\nIf you are looking for an algorithm in the standard library, you should take a look at:\n\n```\nstd::make_heap\nstd::pop_heap\nstd::push_heap\n```\n\n\nIn ```\n<algorithm>```\n. They might fit your need, and even if they don't I'm quite sure you will find what you are looking for in some kind of heap structure. Which one will probably depend on how your code is structured, and how often you expect a value to change etc.\n\nIn short: \n\nA heap is a data structure in which it is fast to find and extract the smallest (or largest) element. It is also for most heaps possible to create restructure the heap in linear time or better. You could start out from this page on Wikipedia if you want to learn more about heaps.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Efficient ways to find a value stored in a priority queue\r\n                \r\nI'm implementing uniform cost search (UCS) using a priority queue with ```\nstd::vector```\n for its container. UCS occasionally or, at times, frequently, requires me to decrease a value already in the priority queue. \n\n```\nstd::priority_queue```\n doesn't appear to have such capability to (1) search for a pre-existing value already in the queue (2) adjust the value in the queue\n\nI found an older post where someone suggested to create such capability yourself by deriving a new class and writing a linear find function, but that seems inefficient to have to traverse through the entire priority queue to search for a value. \n\nNote that I wrote and am using my own min-max heap data structure using a vector container, but it's based off of the one in STL. \n\nAre there more efficient ways to do this? One way I thought of is to use ```\nstd::map```\n along with the priority queue to keep track of indices. This adds to the memory complexity, but this method is only O(logn) time complexity, I think, where n is the size of the queue. \n    ", "Answer": "\r\nThe standard heap implementation std::priority_queue doesn't provide the capability to change the priority of an item already in the queue.\nYou must remove it (erase) and push it again (push_back+make_heap).\nThis basicly costs ```\nO(n/2)```\n for the removal, and then ```\nO(n*log(n))```\n for reconstructing the heap.\n\nYou may have a look at boost::heap for more specialized heap implementation allowing to change the priority of an existing item.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I iterate over all elements in my generic list List<T> backwards and do the intended operation?\r\n                \r\nI'm trying to create a Priority Queue and implement a function ```\ndeleteMax()```\n that removes the maximum element in the priority Queue. In order to do that, I've utilized the ```\nsink()```\n method of the priority queue implementation and a ```\ncomparator```\n which compares two sets of values.\nHere is my code so far:\n```\npublic class Lecture17<T> {\n    private Comparator<T> cc;\n    private List<T> myQueue;\n\n    public Lecture17(Comparator<T> cc) {\n        this.cc = cc;\n        this.myQueue = new ArrayList<>();\n        this.myQueue.add(0, null);\n    }\n    private boolean Smallerthan(int v, int w) {  // helper method to compare items to one another\n        return (cc.compare(this.myQueue.get(v),this.myQueue.get(w))<0);\n    }\n    private void sink(int z) {\n        while (2*z <=  this.myQueue.size()) {\n            int j = 2*z;\n            if ((j < this.myQueue.size()) && Smallerthan(j,j+1))\n                j++;\n            if (Smallerthan(j,z))\n                break;\n            swap(z,j);\n        }\n    }\n\n    public T deleteMax() { // dequeues the highest priority item\n\n        T highestPriorityItem = this.myQueue.get(1);\n        this.myQueue.set(1,this.myQueue.get(this.myQueue.size()));// moves the last element to the top of the heap\n        this.myQueue.set(this.myQueue.size(), null);              // to prevent loitering\n        size()--;                                                 // update the size instance variable\n        sink(1);                  // when heap order is violated, this will fix it\n\n        return highestPriorityItem\n        }\n  \n```\n\nI'm trying to iterate from the top of the priority queue to the bottom for ```\ndeleteMax()```\n but I'm currently struggling to do so, can anyone please explain what I can do to find the smallest element in the priority Queue\n    ", "Answer": "\r\nYou're building a 1-based binary heap in a language that uses 0-based arrays. Whereas that's possible, you have to be careful about off-by-one errors.\nIn particular, you're using ```\nmyQueue.size()```\n to get the last element in the heap. But that's not the last element. Rather, it's the element after the last element.\nConsider if you added the numbers 1, 2, and 3 to the heap. Your array will have the contents:\n```\n[0] - null\n[1] - 1\n[2] - 2\n[3] - 3\n```\n\nBut ```\nmyQueue.size()```\n is going to return ```\n4```\n. So when this line is executed:\n```\nthis.myQueue.set(1,this.myQueue.get(this.myQueue.size()))\n```\n\nIt does, in effect, ```\nmyQueue[1] = myQueue[4]```\n.\nThat's not what you want. You want:\n```\nthis.myQueue.set(1,this.myQueue.get(this.myQueue.size()-1))\n```\n\nAnd of course you'll need to change ```\nthis.myQueue.size()```\n to ```\nthis.myQueue.size()-1```\n in other places as appropriate.\nOr, you can elect to actually use the 0th element in the queue. You just have to change your parent/child calculations:\n```\nparent index = i\nleft child = (2*i) + 1\nright child = (2*i) + 2\n```\n\nAnd the corresponding:\n```\nparent index = left_child/2\nparent index = (right_child-1)/2\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "I need to make a priority queue with strings that have add() and remove() functions with C++\r\n                \r\nSo I'm in this C++ class, and I don't seem to understand how to go about this problem.\n\nImplement a priority queue for strings. A priority queue is similar to a regular queue except each item added to the queue also has an associated priority. For this problem, make the priority an integer where 0 is the highest priority and larger values are increasingly lower in priority.\n\nThe remove function should return and remove the item that has the highest priority, for example:\n\n```\nq.add(\"X\",10);\nq.add(\"Y\",1);\nq.add(\"Z\",3);\n\ncout << q.remove(); //returns Y\ncout << q.remove(); //returns Z\ncout << q.remove(); //returns X\n```\n\n\n.\n\nHere is what I have so far.\n\nhttp://pastebin.com/AgXL9dfq\n\nBasically, I just need the add() and remove() functions, which I don't understand how to implement. Any help? Thanks in advance. \n    ", "Answer": "\r\nhere's another solution using ```\nstd::map```\n and ```\nstd::vector```\n\n\n```\n#include <iostream>\n#include <map>\n#include <vector>\n\nclass priority_queue {\n    std::map<int, std::vector<std::string>> queue;\npublic:\n    void add(int priority, std::string str) {\n        if(!queue[priority].empty()) {\n            queue[priority].push_back(str);\n        } else {\n            std::vector<std::string> vec;\n            vec.push_back(str);\n            queue[priority] = vec;\n        }\n    }\n    std::string remove() {\n        if(!queue.begin()->second.empty()) {\n            std::string temp = queue.begin()->second[0];\n            queue.begin()->second.erase(queue.begin()->second.begin());\n            if(queue.begin()->second.empty())\n                queue.erase(queue.begin());\n            return temp;\n        }\n        std::cout << \"ERROR: QUEUE EMPTY!\" << std::endl;\n        return \"\";\n    }\n};\n\n\nint main() {\n    priority_queue pq;\n\n    pq.add(10, \"hello\");\n    pq.add(10, \"world\");\n    pq.add(11, \"how\");\n    pq.add(12, \"are\");\n    pq.add(13, \"you?\");\n\n    std::cout << pq.remove() << std::endl;\n    std::cout << pq.remove() << std::endl;\n    std::cout << pq.remove() << std::endl;\n    std::cout << pq.remove() << std::endl;\n    std::cout << pq.remove() << std::endl;\n}\n```\n\n\nit generates the following output:\n\n```\nhello\nworld\nhow\nare\nyou?\n```\n\n\nit works by using a map which has a key value of ```\nint```\n denoting priority, and a ```\nstd::vector<std::string>```\n as it's value, i.e. a collection of values with the same priority. \n\n```\nadd()```\n method checks if there's already a value present in the map with the given priority - if it does, it simply pushes the string value on to the back of the vector, if it does not, it creates a new vector, pushes back the value, and assigns it to ```\nmap[priority]```\n.\n\n```\nremove()```\n method checks if the queue is empty, and if not, it returns the appropriate value by taking it from the front of the value container vector; if the \"popped\" string happens to be the last on in the vector, it means there are no longer values tied to it's priority, and the entire entry is deleted from the map, so as not to cause further problems.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is real world example for priority queue?\r\n                \r\nI'm writing a Lock-Free C library, and I'm going to implement a priority queue. However, the goal of my library is not completeness of the data structures, I just want to implement some typical ones and then write a mirco-benchmark to show that the lock-free ones perform better under some special cases than the lock-based ones. So I want to know if there're some typical applications that the priority queue plays an important roles. (open-source projects are the best.) Then I can use them as a benchmark.\n    ", "Answer": "\r\nA few to be listed:\n```\n1. Dijkstra’s Shortest Path Algorithm\n2. Prim’s algorithm\n3. Huffman codes for Data compression.\n4. Heap sort\n5. Load balancing on servers.```\n\n\nThere are various applocation being pointed out in :\nhttps://www.cdn.geeksforgeeks.org/applications-priority-queue/\n\nAlso, the wiki itself has an extensive list of application and parameters against which you can benchmark your comparision(refer section Summary of running times):\nhttps://en.wikipedia.org/wiki/Priority_queue\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ Floating-Point van Emde Boas (vEB) Priority Queue\r\n                \r\nSo van Emde Boas trees look like they have some very nice properties.\n\nI'd like to try using one as the underlying data structure for a floating-point priority queue.\n\nDoes anyone know if there is a C++ template-based implementation of the vEB?\n    ", "Answer": "\r\nThis sounds unpleasant -- the vEB tree is a mapping from an integer to a value (or from an integer to a present bit).  If you want to index it with a floating point value, you'll have to convert it to an integer in a way that preserves ordering.  This is doable, but not necessarily pleasant -- you have to deal with denormals and signed zeroes.\n\nWhat are you trying to do?  A different data structure might be a win.  vEB trees need to get rather large before they'll outperform simple things like binary heaps.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue with a custom anonymous comparator\r\n                \r\nForgive me if this is a tried question, but I'm having a little difficulty figuring it out.\n\nI currently have a class Node, and each 'node' is a square in a maze. I'm trying to implement the A* algorithm, so each of these nodes will have an f-cost (int) data member inside of it. I was wondering if there's a way that I can create a priority queue of these nodes, and set up the f-cost variable as the comparator?\n\nI've looked at examples online, but all I can find are String priority queues. Can I implement Comparator for the Node class? Would this allow me to access the data member stored inside it?\n\nMany Thanks!\n    ", "Answer": "\r\nAbsolutely.\n\nYou can use a ```\nPriorityQueue```\n based on an anonymous ```\nComparator```\n passed to the constructor:\n\n```\nint initCapacity = 10;\nPriorityQueue<Node> pq = new PriorityQueue<Node>(initCapacity, new Comparator<Node>() {\n    public int compare(Node n1, Node n2) {\n        // compare n1 and n2\n    }\n});\n// use pq as you would use any PriorityQueue\n```\n\n\nIf your ```\nNode```\n class already implements ```\nComparable```\n you don't even need to define a new ```\nComparator```\n, as that order will be used by default. Barring any other method, the natural ordering between objects will be used.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implement Hybrid FCFS + Priority Queue in SQL and PHP\r\n                \r\nI would like to ask if how can the SQL rearrange the database simultaneously after there is an new input.\nSample data:\n\nI want to follow the Hybrid FCFS + Priority where 1:1 ratio, 1 regular and 1 priority simultaneously.\nThe identifier of Priority here is when the Priority = 1 of that input.\nHere the sample PHP script code but I am stucked here, I don't know if I will modify the code in PHP or it is directly statemented in SQL database\n```\n    function save_queueSAMPLE(){\n        extract($_POST);\n\n        if($priority == 1){\n        }\n        else{\n            $sql = \"INSERT INTO `queue_listSAMPLE` (`customer_name`,`priority`) VALUES('{$customer_name}','{$priority}')\";\n            $save = $this->query($sql);\n    \n            if($save) {\n                $resp['status'] = 'success';\n                $resp['id'] = $this->query(\"SELECT last_insert_rowid()\")->fetchArray()[0];\n            } else {\n                $resp['status'] = 'failed';\n                $resp['msg'] = \"An error occured. Error: \".$this->lastErrorMsg();\n            }\n    \n            return json_encode($resp);\n        }\n    }\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queues in Java\r\n                \r\n```\njava.util.PriorityQueue```\n allows a ```\nComparator```\n to be passed at construction time. When inserting elements, they are ordered according to the priority specified by the comparator. \n\nWhat happens when the priority of an element changes after it has been inserted? When does the ```\nPriorityQueue```\n reorder elements? Is it possible to poll an element that does not actually have minimal priority? \n\nAre there good implementations of a priority queue which allow efficient priority updates?\n    ", "Answer": "\r\nYou should remove the element, change it, and re-insert, since ordering occurs when it is inserted. Although it involves several steps, it is efficient might be good enough. (I just noticed the comment about removal being O(n).)\n\nOne problem is that it will also re-order when you remove the element, which is redundant if you are just going to re-insert it a moment later. If you implement your own priority queue from scratch, you could have an update() that skips this step, but extending Java's class won't work because you are still limited to the remove() and add() provided by the base.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is message priority inherently unimportant in message queue systems?\r\n                \r\nIt seems like most of the messaging systems I've looked at have basic, if any, support for priority message queues. For example, the AMQP only specifies a minimum of 2 priorities. RabbitMQ, an AMQP implementation, doesn't support any priorities. ActiveMQ will be getting support for 10 message priorities in version 5.4 in a couple days. 10 priority levels is the specified by the JMS spec.\n\nA priority queue in the non-messaging sense of the word orders its contents based on an arbitrary field with an unconstrained range of priorities. Why does an implementation like this not exist as part of a messaging system? As I asked in the title, is priority an inherently non-messaging concept?\n\nI realize that one answer might be that the concept of priority introduces the possibility of messages infinitely languishing in the queue while higher priority messages are processed. Are there other reasons?\n    ", "Answer": "\r\nBTW ActiveMQ now supports priority messaging in 5.4.x via JMSPriority headers.\n\nRather than getting the message broker to re-order messages within some buffer as they arrive, there are often better techniques to implement priority consumption, such as having a dedicated consumer pool for high priority messages. Then irrespective of how much noise there is from low priority messages, high priority messages will always get though. \n\nGiven the asynchronous nature of messaging its easy to fill up buffers, network pipes and prefetch queues with low priority messages if using things like JMSPriority headers etc.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Default size of priority queue in java\r\n                \r\nI am wondering why the default size of a PriorityQueue in Java is ```\n11```\n. I looked up the implementation and it made things more confusingly for me.\n\nThe priority queue is implemented as a heap. Its capacity is adjusted using this function:\n\n```\n/**\n * Increases the capacity of the array.\n *\n * @param minCapacity the desired minimum capacity\n */\nprivate void grow(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    int oldCapacity = queue.length;\n    // Double size if small; else grow by 50%\n    int newCapacity = ((oldCapacity < 64)?\n                       ((oldCapacity + 1) * 2):\n                       ((oldCapacity / 2) * 3));\n    if (newCapacity < 0) // overflow\n        newCapacity = Integer.MAX_VALUE;\n    if (newCapacity < minCapacity)\n        newCapacity = minCapacity;\n    queue = Arrays.copyOf(queue, newCapacity);\n}\n```\n\n\nI don't understand the initial value ```\n11```\n for the capacity. I think that the capacity should always be ```\n2```\n to the number of levels. Any clarification?\n    ", "Answer": "\r\n11 is probably a number that was chosen more or less arbitrarily, as a trade off between memory consumption (a too large number would consume too much memory for nothing), and CPU consumption (a too low number would need too many resizes of the queue). And they probably benchmarked typical use cases to choose this number and the strategy used to resize the queue.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement a maximum priority queue using a heap-ordered binary tree with a triply-linked Node?\r\n                \r\nI am trying to implement a max priority queue using a heap binary tree with a triple-linked node. This is the code that I currently have yet when I run it and try to print out the tree nothing prints out it is just empty lines. I am using the helped methods sink and swim in order to help me organize the queue as I add different elements. I am also implementing an ADT (MaxPQ) which just has the public methods that need to be implemented. I was wondering if there is anything that I am doing wrong?\n\n```\npublic class LinkedMaxPQ<T extends Comparable<T>> implements MaxPQ<T> {\n\n  // Instance variables\n  Node root;\n  int size;\n  Node lastInserted;\n\n  // Node inner class definition\n\n  // Node class\n  class Node {\n    int N;\n    T info;\n    Node left;\n    Node right;\n    Node parent;\n\n    Node(T info, int N) {\n      this.info = info; this.N = N;\n    }\n  }\n\n  private void swim(Node x){\n    if(x == null) return;\n    if(x.parent == null) return; // we're at root\n    int cmp = x.info.compareTo(x.parent.info);\n    if(cmp > 0){\n      swapNodeData(x, x.parent);\n      swim(x.parent);\n    }\n  }\n  private void swapNodeData(Node x, Node y){\n    T temp = x.info;\n    x.info = y.info;\n    y.info = temp;\n  }\n  private void sink(Node x){\n    if(x == null) return;\n    Node swapNode;\n    if(x.left == null && x.right == null){\n      return;\n    }\n    else if(x.left == null){\n      swapNode = x.right;\n      int cmp = x.info.compareTo(swapNode.info);\n      if(cmp < 0)\n      swapNodeData(swapNode, x);\n    } else if(x.right == null){\n      swapNode = x.left;\n      int cmp = x.info.compareTo(swapNode.info);\n      if(cmp < 0)\n      swapNodeData(swapNode, x);\n    } else{\n      int cmp = x.left.info.compareTo(x.right.info);\n      if(cmp >= 0){\n        swapNode = x.left;\n      } else{\n        swapNode = x.right;\n      }\n      int cmpParChild = x.info.compareTo(swapNode.info);\n      if(cmpParChild < 0) {\n        swapNodeData(swapNode, x);\n        sink(swapNode);\n      }\n    }\n  }\n  String printThisLevel (Node rootnode, int level) {\n    StringBuilder s = new StringBuilder();\n\n    // Base case 1: if the current rootnode is null, return the current string.\n    if (rootnode == null) {\n      return s.toString();\n    }\n\n    // Base case 2: If you're at the first level, append the\n    // info field of the current rootnode.\n    if (level == 1) {\n      s.append( rootnode.info.toString());\n    }\n    // Recursive calls: otherwise call the method on the left\n    // and on the right of the next lower level.\n    else if (level > 1)  {\n      s.append( printThisLevel(rootnode.left, level-1));\n      s.append( printThisLevel(rootnode.right, level-1));\n    }\n    return s.toString();\n  }\n\n  private int size(Node x){\n    if(x == null) return 0;\n    return x.N;\n  }\n\n  private Node insert(Node x, T data){\n    if(x == null){\n      lastInserted = new Node(data, 1);\n      return lastInserted;\n    }\n    // compare left and right sizes see where to go\n    int leftSize = size(x.left);\n    int rightSize = size(x.right);\n\n    if(leftSize <= rightSize){\n      // go to left\n      Node inserted = insert(x.left, data);\n      x.left = inserted;\n      inserted.parent = x;\n    } else{\n      // go to right\n      Node inserted = insert(x.right, data);\n      x.right = inserted;\n      inserted.parent = x;\n    }\n    x.N = size(x.left) + size(x.right) + 1;\n    return x;\n  }\n  private Node resetLastInserted(Node x){\n    if(x == null) return null;\n    if(x.left == null && x.right == null) return x;\n    if(size(x.right) < size(x.left))return resetLastInserted(x.left);\n    else                            return resetLastInserted(x.right);\n  }\n\n  public void insert(T data){\n    root = insert(root, data);\n    swim(lastInserted);\n  }\n  public T getMax(){\n    if(root == null) return null;\n    return root.info;\n  }\n  public T removeMax(){\n    if(size() == 1){\n      T ret = root.info;\n      root = null;\n      return ret;\n    }\n    swapNodeData(root, lastInserted);\n    Node lastInsParent = lastInserted.parent;\n    T lastInsData = lastInserted.info;\n    if(lastInserted == lastInsParent.left){\n      lastInsParent.left = null;\n    } else{\n      lastInsParent.right = null;\n    }\n\n    Node traverser = lastInserted;\n\n    while(traverser != null){\n      traverser.N--;\n      traverser = traverser.parent;\n    }\n\n    lastInserted = resetLastInserted(root);\n\n    sink(root);\n\n    return lastInsData;\n  }\n  public int size(){\n    return size(root);\n  }\n  public boolean isEmpty(){\n    return size() == 0;\n  }\n\n\n  public String toString() {\n    // Create a StringBuilder object to make it more efficient.\n    StringBuilder sb=new StringBuilder();\n\n    // get the height of the tree\n    int height = (int)Math.ceil(Math.log(size+1) / Math.log(2));\n\n    // for each level in the tree, call printThisLevel and\n    // append the output to the StringBuilder\n    for (int i=1; i<=height; i++) {\n      sb.append(\"level \" + i + \": \"+ printThisLevel(this.root, i) + \"\\n\");\n    }\n\n    // Return the string of the StringBuilder object\n    return sb.toString();\n  }\n\n\n  public static void main (String[] args) {\n    LinkedMaxPQ<String> t = new LinkedMaxPQ<String>();\n    t.insert(\"a\");\n    System.out.println(t.toString());\n    t.insert(\"b\");\n    t.insert(\"c\");\n    t.insert(\"d\");\n    t.insert(\"e\");\n    t.insert(\"f\");\n    t.insert(\"g\");\n    t.insert(\"h\");\n    t.insert(\"i\");\n    t.insert(\"j\");\n    t.insert(\"k\");\n    t.size();\n    t.removeMax();\n    t.getMax();\n    t.removeMax();\n    t.insert(\"x\");\n    t.insert(\"y\");\n    t.removeMax();\n    t.getMax();\n    System.out.println(t.toString());\n\n  }\n\n}\n\n```\n\n    ", "Answer": "\r\nIn this line:\n```\nint height = (int)Math.ceil(Math.log(size+1) / Math.log(2));\n```\n\nsize should be size().\n```\nint height = (int)Math.ceil(Math.log(size()+1) / Math.log(2));\n```\n\nAfter this correction, the results are coming out.\nHowever, there is a logic problem, which needs a solution.\nFor test case, testdata = new int[] {3, 5, 2, -7, 9, 4, 7};\nThe result is 9 4 7 -7 3 2 5\nBut correct result should be 9 5 7 -7 3 2 4 (from another array implementation).\nI know the mistake comes from when at the 3rd levle, insert data {9}, its parent should be the 2nd leverl data {3} on the left, not the {2} on the right. Any thought to solve it?\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue ordering of elements\r\n                \r\nHow come the elements of priority queue are ordered according to natural order by default as it doesn't implement comparable interface. \n\nFrom the docs, it says elements are ordered based on natural ordering but I can't find anywhere it talks about equals method nor comparable. Hows it happening internally?\n\n\n  All Implemented Interfaces: Serializable, Iterable, Collection, Queue. \n\n\nIf it implements comparable then why doesn't it say in the above line\n\nExample:\n\n```\n    public static void main(String[] args) {\n        PriorityQueue<String> pq = new PriorityQueue<String>();\n        pq.add(\"2\");\n        pq.add(\"4\");\n        System.out.println(pq); //prints [2, 4]\n        pq.offer(\"1\");\n        System.out.println(pq); // prints [1, 4, 2]\n        pq.add(\"3\");\n        System.out.println(pq); // prints [1, 3, 2, 4]\n    }\n}\n```\n\n\nAlso third print statement prints [1, 3, 2, 4] instead of prints [1, 2, 3, 4]. Why? It should be natural ordering right?\n    ", "Answer": "\r\nActually internal data structure of ```\nPriorityQueue```\n is not ordered, it is a heap. \n\n```\nPriorityQueue```\n doesn't need to be ordered, instead, it focuses on head of data. Insertion is in O(log n) time. Sorting wastes time and useless for a queue.\n\nMoreover, either the element is-a ```\nComparable```\n, or a ```\nComparator```\n is provided. Unfortunately, non-comparable checking is at runtime, rather than compile time. Once second element is added, ```\nClassCastException```\n occurs.\n\nPLUS: My answer to why [1, 3, 2, 4] instead of prints [1, 2, 3, 4]?\n\nAs I mentioned before, it's not ordered, instead it focuses on head ```\nq[0]```\n is minimum, that's it. \nYou could see the [1, 3, 2, 4] as a tree which is NOT linear:\n\n```\n1\n| \\\n3  2\n|\n4\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue printing the wrong element dequeue'd, even though it dequeue's correctly\r\n                \r\nI'm working on following a tutorial on implementing a Priority Queue in C, however when I display my Priority Queue (should sort by student ID from highest to lowest), it prints in a different order.\nThe actual output is:\n```\nOriginal Array: 4 2 6 1 5 3 7 \nDequeued student: 2\nMin-Heap array: 2 5 6 1 7 3 \nDequeued student: 5\nMin-Heap array: 5 1 6 3 7 \nDequeued student: 6\nMin-Heap array: 6 1 7 3 \nMin-Heap array: 6 1 7 3  \n```\n\nThe expected output is:\n```\nOriginal Array: 4 2 6 1 5 3 7 \nDequeued student: 4 <--\nMin-Heap array: 2 5 6 1 7 3 \nDequeued student: 2 <--\nMin-Heap array: 5 1 6 3 7 \nDequeued student: 5 <--\nMin-Heap array: 6 1 7 3 \nMin-Heap array: 6 1 7 3 \n```\n\nIt seems like it's printing the wrong studentID when I am de'queing, even though the heap is updating.\nCode:\n```\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdbool.h>\n\nstruct Student;\nstruct PriorityQueue;\n\n\nvoid swap(struct Student *a, struct Student *b);\nvoid heapify(struct PriorityQueue *pq, int size, int i);\nvoid insert(struct PriorityQueue *pq, struct Student *newStudent);\nvoid deleteRoot(struct PriorityQueue *pq, struct Student *removeStudent);\nvoid printArray(struct PriorityQueue *pq, int size);\nstruct Student *peek(struct PriorityQueue *pq);\n\n\n\nstruct Student {\n    int studentID;\n    int grade;\n};\n\nstruct PriorityQueue {\n    struct Student studentPQ[100];\n    int size;\n};\n\n\nvoid swap(struct Student *a, struct Student *b) {\n  struct Student temp = *b;\n  *b = *a;\n  *a = temp;\n}\n\n// Function to heapify the tree\nvoid heapify(struct PriorityQueue *pq, int size, int i) {\n  if (size == 1) {\n  } else {\n    // Find the lowest grade and swap it with the root. If there are two studentes with the same grade, swap the one with the lowest studentID.\n    int smallest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n    if (left < size && pq->studentPQ[left].grade < pq->studentPQ[smallest].grade) {\n      smallest = left;\n    } else if (left < size && pq->studentPQ[left].grade == pq->studentPQ[smallest].grade) {\n      if (pq->studentPQ[left].studentID < pq->studentPQ[smallest].studentID) {\n        smallest = left;\n      }\n    }\n\n    if (right < size && pq->studentPQ[right].grade < pq->studentPQ[smallest].grade) {\n      smallest = right;\n    } else if (right < size && pq->studentPQ[right].grade == pq->studentPQ[smallest].grade) {\n      if (pq->studentPQ[right].studentID < pq->studentPQ[smallest].studentID) {\n        smallest = right;\n      }\n    }\n\n    // Swap and continue heapifying if root is not largest\n    if (smallest != i) {\n      swap(&pq->studentPQ[i], &pq->studentPQ[smallest]);\n      heapify(pq, size, smallest);\n    }\n  }\n}\n\n// Function to insert an element into the tree\nvoid insert(struct PriorityQueue *pq, struct Student *newStudent) {\n  if (pq->size == 0) {\n    pq->studentPQ[0] = *newStudent;\n    pq->size += 1;\n  } else {\n    pq->studentPQ[pq->size] = *newStudent;\n    pq->size += 1;\n    for (int i = pq->size / 2 - 1; i >= 0; i--) {\n      heapify(pq, pq->size, i);\n    }\n  }\n\n}\n\n// Function to delete an element from the tree\nvoid deleteRoot(struct PriorityQueue *pq, struct Student *removeStudent) {\n  int i;\n  for (i = 0; i < pq->size; i++) {\n    if (removeStudent->studentID == pq->studentPQ[i].studentID)\n      break;\n  }\n\n  swap(&pq->studentPQ[i], &pq->studentPQ[pq->size - 1]);\n  pq->size -= 1;\n  for (int i = pq->size / 2 - 1; i >= 0; i--) {\n    heapify(pq, pq->size, i);\n  }\n}\n\n// Print the array\nvoid printArray(struct PriorityQueue *pq, int size) {\n  for (int i = 0; i < pq->size; ++i)\n    printf(\"%d \", pq->studentPQ[i].studentID);\n  printf(\"\\n\");\n}\n\n// peek the highest priority student\nstruct Student *peek(struct PriorityQueue *pq) {\n  return &pq->studentPQ[0];\n}\n\n// dequeue the highest priority student\nstruct Student *dequeue(struct PriorityQueue *pq) {\n  struct Student *student = &pq->studentPQ[0];\n  deleteRoot(pq, student);\n  return student;\n}\n\n// Driver code\nint main() {\n  struct PriorityQueue *pq = (struct PriorityQueue *)malloc(sizeof(struct PriorityQueue));\n  pq->size = 0;\n    struct Student student1 = {1, 8};\n    struct Student student2 = {2, 2};\n    struct Student student3 = {3, 9};\n    struct Student student4 = {4, 0};\n    struct Student student5 = {5, 5};\n    struct Student student6 = {6, 6};\n    struct Student student7 = {7, 8};\n\n\n    insert(pq, &student1);\n    insert(pq, &student2);\n    insert(pq, &student3);\n    insert(pq, &student4);\n    insert(pq, &student5);\n    insert(pq, &student6);\n    insert(pq, &student7);\n\n    struct Student *dequeueStudent = dequeue(pq);\n    printf(\"Dequeued Student: %d\\n\", dequeueStudent->studentID);\n    printf(\"Min-Heap array: \");\n    printArray(pq, pq->size);\n    \n    *dequeueStudent = *dequeue(pq);\n    printf(\"Dequeued Student: %d\\n\", dequeueStudent->studentID);\n    printf(\"Min-Heap array: \");\n    printArray(pq, pq->size);\n\n    *dequeueStudent = *dequeue(pq);\n    printf(\"Dequeued Student: %d\\n\", dequeueStudent->studentID);\n    printf(\"Min-Heap array: \");\n    printArray(pq, pq->size);\n\n  printf(\"Min-Heap array: \");\n    printArray(pq, pq->size);\n}\n```\n\n    ", "Answer": "\r\n\nIt seems like it's printing the wrong studentID when I am de'queing, even though the heap is updating.\n\nThe problem is that\n\nYour priority queue is providing the actual storage for its elements; and\n\nWhen you dequeue, you are both reporting out pointers to the storage and modifying the contents of the storage.\n\n\nThat is well illustrated by considering this line from your ```\ndequeue()```\n function:\n\n```\n    struct Student *student = &pq->studentPQ[0];\n```\n\n\nNote well that for any given value of ```\npq```\n, the expression ```\n&pq->studentPQ[0]```\n always evaluates to the same pointer.\nThe function then modifies the data at the location to which that pointer points ...\n\n```\n    deleteRoot(pq, student);\n```\n\n\n... and returns the pointer.  So yes, when you examine the data to which the pointer points, you see the item on top of the heap, not the one that was just removed.\nA relatively contained and minimal fix would be to read out and return items by value instead of by address:\n```\n// dequeue the highest priority student\nstruct Student dequeue(struct PriorityQueue *pq) {\n  struct Student student = pq->studentPQ[0];\n  deleteRoot(pq, &student);\n  return student;\n}\n```\n\nYou will of course need to modify the calls to that function appropriately, too.\nNote also that it is strange that your ```\ndeleteRoot()```\n function accepts an argument telling it which element to delete.  Isn't it supposed to delete the root?  At least, that's the only thing you use it for.  You don't need to tell it which node is the root node.  That's inherent in the structure of your heap.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ reverse a priority queue in place\r\n                \r\nHi I was wondering if given a std::priority_queue is there are a way to change the heap order from min heap to max heap and vice versa? And I'm not talking about defining a priority queue with greater, what I mean is we already have a priority_queue with some elements.\nI would basically want to print elements in reversed order from priority queue while popping.\nNow I'm aware that the elements could be loaded up to a stack for example, and then popped from it, that would change the order, but I would like to do it in-place, without using additional memory, or writing my own heap implementation for that matter.\nIs there a way to do it?\nExample:\n```\nstd::priority_queue<int> pq{};\n\npq.push(1);\npq.push(2);\npq.push(3);\n\nwhile(!pq.empty()){\n\n   std::cout << pq.top();\n   pq.pop(); //this would print 321, but I would simply like 123, reversed.\n   //but don't change the declaration of the priority_queue. Reverse it when   it has its elements inside of it.\n\n}\n```\n\n    ", "Answer": "\r\nYou have tagged the question with heap. This a great hint, why don't use it instead of the priority queue?\n```\nstd::vector<int> pq{};\n\npq.push_back(1);\npq.push_back(2);\npq.push_back(3);\n\n// possibly first sort order\nstd::make_heap(pq.begin(), pq.end(), std::less<>{});\n\n// ...\n\n// Reorder\nstd::make_heap(pq.begin(), pq.end(), std::greater<>{});\n\nwhile(!pq.empty()) {\n  std::pop_heap(pq.begin(), pq.end(), std::greater<>{});\n  std::cout << pq.back();\n  pq.pop_back();\n  // The loop will print 123\n}\n```\n\nYou can change a compare function in a heap with remaking it at any time.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue and Prim's Algorithm\r\n                \r\nI have gone through the C++ reference manual and am still unclear on how to use the priorityqueue data structure in STL. \n\nSo, basically I have been trying to implement my own using heaps.\n\nI am doing this for implementing Prim's algorithm.\n\n```\nVector <int, int> pq;\n```\n\n\nThis is my priority queue. The first field is the node and the second field the weight to the existing tree.\n\nI plan to modify the values of weight in pq every time a new node is added to the tree by updating the weights of its neighbour nodes.\n\n\nHow do I access the individual elements of this vector? I also need to be able to delete elements at will.\n\n\nIs this a good way to implement a priority queue? what if I want to add another field to the container, namely \n\n```\nVector<int, int, int> MST\n```\n\n\n\nHow would I access the third element? I want to store the resulting MST this way such that the first two fields represent the vertices forming the edge, and the third the weight. \n\n\nIt would also help if someone could tell me how to assign elements to this vector using push_back. \n\n\nAlso, would the conventional C++ STL priority queue help in this as I need to update the priority values each time a new element is added to the MST? Would it self-correct itself according to the priority when values are modified?\nOne other question, these Vectors, when I pass them to a function, and try to make changes, is it a pass by value or pass by reference - Or, are the changes reflected outside the function?\n\n    ", "Answer": "\r\nIn Prim's algorithm the random access to elements not needed. You just need to skip elements from the queue which connect already connected and pass forward.\n\nSo the algorithm looks as follows:\n\n\nchoose a node ```\nN```\n\nadd all edges from ```\nN```\n to the PQ\npop a minimal cost edge from PQ\n\nif it connects nodes which are already in the tree, skip it\notherwise add this edge to the tree, call the new node ```\nN```\n and go back to point 2.\n\n\n\nAfter adding the node just check if size of the tree is already ```\nsize of graph - 1```\n. If so then finish.\n\nNote that the only operations on PQ are ```\nadd_element```\n and ```\npop_minimum```\n - thus ```\nstd::priority_queue```\n will work.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Which priority queue is faster in practice?\r\n                \r\nMost used operation: FindMin. Less commonly: Insert and ExtractMin. Rarely: DeleteNode. Very rare: Merge.\n\nWhich of the following priority queues is faster in practical terms, under the listed conditions?\n\n\nNaive implementation based on sorted doubly linked list\nSimple heap\nLeftist heap\nBinomial heap\nFibonacci heap\n2-3 heap\nPairing heap\nThin heap\nThick heap\nSkew Binomial Heap\nBrodal-Okasaki queue\n\n    ", "Answer": "\r\nMy experience, based on work I did more than five years ago, is that a 3-heap outperforms a binary heap in the general case. Skip list heaps and pairing heaps slightly outperform a 3-heap, but at a higher memory cost. All three of the above outperformed Fibonacci heap.\n\nBrodal queue is theoretically the most efficient. But, as Brodal himself said, they are \"quite complicated\" and \"[not] applicable in practice.\" https://en.wikipedia.org/wiki/Brodal_queue\n\nA lot of people talk about Fibonacci heap efficiency, and asymptotic analysis says that it should outperform other types of heaps. Empirical data tends not to bear that out. There are definite disadvantages of Fibonacci heap, as described in https://en.wikipedia.org/wiki/Fibonacci_heap#Worst_case.\n\nIf you're looking to implement a heap, I'd suggest starting with a binary heap. Or a 3-heap, which is a simple optimization. My next step, if I needed more performance, would be the Pairing Heap. It's easy to implement and quite efficient. \n\nBeyond that, I don't have any advice. The performance numbers I've seen on the other types of heaps don't show a clear winner.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Simple priority queue in Java\r\n                \r\ncan anyone tell me an easy way to implement a priority queue that only offers extract_min, add, and reduce key without using the build-in one in Java. It is better to be as efficient as possible and not hard to implement. Please give me a sample. Thank you in advance!  \n    ", "Answer": "\r\nIt's rather conceptual problem than implementational one, so I suggest you to have a look at wiki Priority queue or heap pages or dive into some really great books, for instance \"Introduction to algorithms\". When you understand logic behind those data structures (and other algorithms as well) implementing them in any programming language shouldn't be a big deal.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Standard queue package for Haskell? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIs there a standard queue implementation for Haskell? I see several reasonably mature priority queue implementations, but no simple queues. Data.Sequence seems OK, but I assume we could get better performance with a more restricted datatype. Further, restricting the operations (ie, not a deque) can prevent bugs from dequeuing from the wrong end.\n\nEdit:\n\nTo clarify, I was hoping for a mature Haskell implementation, preferably in Haskell Platform or Hackage. \n    ", "Answer": "\r\nOkasaki in his book Purely Functional Data Structures, describes a FIFO queue as a pair of lists, front and back, where the front list contains the front elements of the queue in the correct order, and the back list contains the rear elements of the queue in the reverse order.\n\n```\ndata Queue a = Queue [a] [a]  -- front & back lists\n```\n\n\nThe idea is that new items are inserted to front of the back list, whereas values are popped out from the front list. If the front list becomes empty it is replaced by the reverse of the back list.\n\nThe queue maintains the invariance that the front list can be empty only if the back list is also empty; and performs amortized O(1).\n\n```\n-- helper function to maintain the invariance:\n-- front list can be empty only if the back list is also empty\nfill :: Queue a -> Queue a\nfill (Queue [] b) = Queue (reverse b) []\nfill q = q\n\npush :: a -> Queue a -> Queue a\npush x (Queue f b) = fill $ Queue f (x:b)\n\nfront :: Queue a -> Maybe a\nfront (Queue (x:_) _) = Just x\nfront _               = Nothing\n\npop :: Queue a -> Maybe (Queue a)\npop (Queue (_:xs) b) = Just . fill $ Queue xs b\npop _                = Nothing\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Boost: Priority Queue which supports finding an element in O(log n) time\r\n                \r\nI am curious whether Boost offers Priority Queue implementation which also supports finding an element in time O(log n)?\n\nI could achieve this functionality by using a Boost Fibonacci Heap, and store the handles in a std::map together with their index and update this information upon heap insert, but I was hoping for a heap version which already offers this functionality.\n\nNote: I deleted the previous version of my question because it was too ambiguous. \n    ", "Answer": "\r\nIf you don't mind having (considerable?) overhead in space and insertion time, you can use a multi-index container here.\n\nFor an idea, here's an example that employs Boost Multi-Index to do a priority-queue implementing Active Object pattern on top of Boost Asio:\n\n\nboost::asio and Active Object\n\n\nIt should be noted that Multi-Index let's you specify any number of secondary/auxiliary indices on the same container\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Which Link-List Would be the Best to create a Priority queue in terms of memory and time complexity?\r\n                \r\nIn doubly link list, Singly Link list and circular link list, which can be used for most efficient implementation of priority queue.\n    ", "Answer": "\r\nA priority queue (also called heap) is a totally different data structure compared to a list and therefore none of your candidates is \"the best\".\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "K sorted array using priority queue - C++\r\n                \r\nI am implementing k sorted array using priority queue in C++. In the output, only the first k elements are sorted but rest are not. Please find the problem in the code.\n\nHere is the code:\n\n```\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nvoid kSortedArray(int input[], int n, int k){\n    priority_queue<int> pq;\n    for(int i= 0; i < k; i++){\n        pq.push(input[i]);\n    }\n\n    int j = 0;\n    for(int i = k; i < n; i++){\n        int ans = pq.top();\n        pq.pop();\n        input[j] = ans;\n        pq.push(input[i]);\n        j++;\n    }\n\n    while(pq.size() != 0){\n        input[j] = pq.top();\n        pq.pop();\n    }\n}\n\n\n\n\n\nint main() {\n    int input[] = {10, 12, 6, 7, 9};\n    int k = 3;\n    kSortedArray(input, 5, k);\n    for(int i = 0; i < 5; i++){\n        cout << input[i] << \" \";\n    }\n}\n```\n\n    ", "Answer": "\r\nCorrect this part (you forgot to increment ```\nj```\n):\n\n```\n    while(pq.size() != 0){\n        input[j++] = pq.top(); // <-- this line\n        pq.pop();\n    }\n```\n\n\nAlso your code sorts in decreasing order. If you want to sort in an increasing order, use a minheap:\n\n```\npriority_queue<int,vector<int>, greater<int>> pq;\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Distinct elements in priority queue\r\n                \r\nI am using this implementation of a bounded priority queue, https://gist.github.com/ryanlecompte/5746241, and it works perfectly. However, I want this queue to not contain any element with the same ordering 'ord'. How can I achieve this?\n\nI tried to update the maybeReplaceLowest function by giving the function lteq instead of lt.\n\n```\nprivate def maybeReplaceLowest(a: A) {\n    if (ord.lteq(a, head)) {\n      dequeue()\n      super.+=(a)\n    }\n  }\n```\n\n\nBut I think it does not work because the element which has the same ord as the new element might not be at the head. What could be a quick workaround for this problem?\n\nMany thanks.\n    ", "Answer": "\r\nScala PriorityQueue is implemented using ```\nArray```\n. Which is very inefficient for lookup operation, which you need to do for every insert (to check if the element already exists in the queue.\n\nFor TreeSet is ideal for lookup and ordered storage. \nBut since this is a sealed class (scala-2.12.8) I created composite class \n\n```\nimport scala.collection.mutable\n\nclass PrioritySet[A](val maxSize:Int)(implicit ordering:Ordering[A]) {\n    var set = mutable.TreeSet[A]()(ordering)\n\n    private def removeAdditional(): this.type = {\n        val additionalElements = set.size - maxSize\n        if( additionalElements > 0) { set = set.drop(additionalElements) }\n        this\n    }\n\n    def +(elem: A): this.type = {\n        set += elem\n        removeAdditional()\n    }\n\n    def ++=(elem: A, elements: A*) : this.type = {\n        set += elem ++= elements \n        removeAdditional()\n    }\n\n    override def toString = this.getClass.getName + set.mkString(\"(\", \", \", \")\")\n}\n```\n\n\nThis can be used as \n\n```\n>>> val set = new PrioritySet[Int](4)\n>>> set ++=(1000,3,42,2,5, 1,2,4, 100)\n>>> println(set)\nPrioritySet(5, 42, 100, 1000)\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "construct boost priority queue based on iterators\r\n                \r\nI have a list of binomial_heaps and each iteration of the algorithm I have to update the priority of an element in some of the binomial_heaps. For this I use the update function of the boost binomial_heap. However one of the binomial_heaps I have to remove and rebuild completely (as all priorities change). Instead of using push every time (which if I understand correctly would have a complexity of n*log(n)) I would like to construct it based on iterators of an underlying container (a kind of heapify or make_heap operation which would be linear time). This seems possible in the standard priority_queue, but not in the boost implementation. On the other hand the standard one does not provide me with an update function. Is there a way around this where I can have both, or another library that supports both. Or maybe my reasoning, that pushing all elements on an empty priority queue is slower, is not correct?\n\nSome might say there is something seriously wrong with the fact that I need to rebuild an entire priority queue which would make the use of the priority queue completely superfluous. The algorithm I want to implement is \"Finding community structure in very large networks by Aaron Clauset\" in which the authors do exactly that (unless I didn't interpret it correctly)\n\n(Sorry couldn't post the link to the paper as I don't have enough reputation to post more than 2 links)\n    ", "Answer": "\r\nThe \"fast modularity\" algorithm by Clauset et al. (paper here, code here) uses a pair of linked data structures. On the one hand, you have a sparse matrix data structure (which is really just an adjacency list in which instead of storing the elements hanging off a particular array element as a linked list, we store them using a balanced binary tree data structure), and a max-heap. All the values in the sparse matrix (which are really the dQ_ij values for the potential merges in the algorithm) are also stored in the max-heap.\n\nSo, the max-heap is just an efficient way of finding the edge in the sparse matrix with the most positive value. Once you have the ij pair for that edge, you want to \"insert\" the elements of column (row) i into the elements of column (row) j, and then you want to delete column (row) i. So, you're not going to rebuild the entire max-heap after each pop from the max-heap. Instead, you want to delete some elements from it (the ones in the row/column that you delete from the sparse matrix) and update the values of others (the ones in the updated row/column for j).\n\nThis is where the linked data structure is helpful -- in the original implementation, each element in the sparse matrix stores a pointer to its corresponding entry in the max-heap so that if you update the value in the sparse matrix, you can then find the corresponding element in the max-heap and update its value. Once you do this, you need to re-heapify the updated heap element, by letting it move (recursively) up or down in the heap. Similarly, if you delete an element in the sparse matrix, you can find its entry in the heap and call a delete function on it.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "High level description of a priority queue with adjustable priority\r\n                \r\nWhile implementing Dijkstra's and Prim's algorithms, we require a priority queue with adjustable priorities. I Understand how an array based implementation of the heap functions, but I don't understand how to make the priorities adjustable. I've read that a hashmap allows this, but I don't understand how.\n\nCan someone please give me a high level description of this implementation using a hashmap using an example. a,b,c,d,e,f have priorities 2,4,0,6,1,9 respectively, how would I keep a track of their indices after insertion into the heap? if b's priority is changed to 8 how would this work?.\n\nPlease refer me to any additional material I may require to understand this.\n    ", "Answer": "\r\n```\nimport java.util.HashMap;\nimport java.util.NoSuchElementException;\n\npublic class Heap<Key extends Comparable<Key>> {\n    private Key[] heap;\n    private int maxN, n;\n    private HashMap<Key, Integer> map;\n    @SuppressWarnings(\"unchecked\")\n    public Heap(int maxN) {\n        if(maxN < 0 ) throw new IllegalArgumentException();\n        this.maxN = maxN;\n        n = 0;\n        heap = (Key[]) new Comparable[maxN];\n        map = new HashMap<>(maxN);\n    }\n\n    boolean isEmpty() {\n        return n == 0;\n    }\n\n    boolean insert(Key e) {\n        if(n +1 > maxN) throw new IllegalArgumentException(\"maximum capacity reached \" + maxN);\n        heap[n] = e;\n        map.put(e,n);\n        int i = n++;\n        swim(i);\n        return true;\n    }\n\n    Key extractMin() {\n        if(n == 0) throw new NoSuchElementException(\"Priority queue underflow \");\n        Key min = heap[0];\n        swap(0, n-1);\n        map.remove(min);\n        n--;\n        sink(0);\n        return min;\n    }\n\n    void delete(Key e){\n        if(!map.containsKey(e)) return; //throw new NoSuchElementException(e+\" does not exist \");\n        int j = map.get(e);\n        swap(j, n-1);\n        map.remove(e);\n        n--;\n        if(!swim(j))\n            sink(j);\n    }\n\n    void decreasePriority(Key e){\n        if(map.containsKey(e)){\n            int j = map.get(e);\n            swim(j);\n        }\n        else insert(e);\n    }\n\n    private void swap(int i, int j) {\n        Key t = heap[i];\n        heap[i] = heap[j];\n        heap[j] = t;\n        map.replace(heap[i], i);\n        map.replace(heap[j], j);\n    }\n    private boolean swim(int j){\n        boolean change = false;\n        int parent;\n        while( (parent = (j-1)/2 ) >= 0){\n            if(heap[j].compareTo(heap[parent]) < 0){\n                swap(j,parent);\n                j = parent;\n                change = true;\n            }\n            else break;\n        }\n        return change;\n    }\n    private void sink(int j){\n        while(j <= n/2 - 1){\n            int leftChild = j*2 + 1, rightChild = leftChild + 1, s;\n            if(rightChild >= n)\n                s = leftChild;\n            else\n                s = heap[leftChild].compareTo(heap[rightChild]) < 0 ? leftChild : rightChild;\n            if(heap[j].compareTo(heap[s]) > 0){\n                swap(j,s);\n                j = s;\n            }\n            else break;\n        }\n    }\n\n    @Override\n    public String toString() {\n        String res = \"[\";\n        int i;\n        for (i = 0; i < n-1; i++){\n            res += heap[i] + \", \";\n        }\n        res += heap[i]+\"]\";\n        return res;\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Huffman coding and priority queue\r\n                \r\nI had an assignment today and I'm really struggling trying to find a solution.\n\"Using a Binary-Search-Tree based priority queue, implement Huffman Coding [...]\".\nSo, basically, I have to write my own priority queue based on a Binary Search Tree.\nI managed to get a working BST and so on, but I've been really smashing my head against every wall In my room for the last two-tree days for the second part.\nAnd that's Huffman's fault (Just kidding, I know I'm kinda stupid).\nIn Huffman Algorithm, we create a priority queue, fill it with our N starting elements, then we pop() the 2 nodes with minimum frequences, create a new node whose frequence is the sum of the previously popped elements and push() that node into the priority queue and reiterate[...].\nTo make my BST into a priority queue, I added  one member and two methods: ```\nmin```\n,```\ngetMin()```\n and ```\nextractMin()```\n.\n```\nmin```\n is a pointer to the node whose value is the lowest in the tree.\n```\ngetMin()```\n is a method that starts from a given node, and looks for the minimum value in its left subtree.\nPlease, note that everytime a node gets removed or  a new node inserted, it calls an update of the ```\nmin```\n variable of the tree (a new inserted node could have a lower value than the previous ```\nmin```\n, so ```\nmin```\ngets updated, and the node pointer by ```\nmin```\n could be removed, so```\nmin```\n gets updated).\n```\nextractMin()```\n is basically a wrapper for ```\npQueue.remove(pQueue.getMin())```\n.\nThe thing is this: after popping the two elements with lowest frequency, and creating the new node, inserting it in the tree causes a ```\nmin```\n update. Since the ```\nleft```\n and ```\nright```\n members of the new inserted node have a lower frequence than the inserted note itself, the ```\nmin```\n variable is set to one of those two members. I am struggling to find a solution to this. I don't want code or lines, I just want some ideas because I really ran out of patience and intelligence.\nFollowing, my BST class and a snippet of the Huffman code I wrote. Please, be kind, I'm new to coding.\n\n```\n   template <class T>\nclass BST\n{\n    private:\n\n        void setRoot(bstNode<T>* nd){this->root=nd;}\n        bool isEmpty()const{if (this->getRoot()==nullptr) return true; else return false;}\n    protected:\n        bstNode<T>* root;\n        bstNode<T>* min;\n    public:\n        BST(void){this->root=nullptr;this->min=nullptr;}\n        BST(bstNode<T>* rt){this->root=rt;}\n        ~BST(void){this->root=nullptr;};\n        void inorder(bstNode<T>*) const;\n        void insert(bstNode<T>*);\n        bool remove(bstNode<T>*);\n        void extractMin();\n        bstNode<T>* getRoot()const {return this->root;} \n        bstNode<T>* getMin(bstNode<T>*)const; \n        bstNode<T>* getMin()const {return this->min;} //simply returns a pointer to the minimum\n        void setMin(bstNode<T>* nd){this->min=nd;}\n};\n\ntemplate <class T>\nvoid BST<T>::extractMin()\n{\n    if (this->getMin()!=nullptr)\n        this->remove(this->getMin());\n    else return;\n}\n\n\ntemplate <class T>\nvoid BST<T>::insert(bstNode<T>* nd)\n{\n    if (this->isEmpty()==true)\n    {\n        this->setRoot(nd);\n        this->setMin(nd);\n        return;\n    }\n    else\n    {\n        bstNode<T>* up=nullptr;\n        bstNode<T>* actual=this->getRoot();\n\n    while (actual!=nullptr)\n    {\n        up=actual;\n        if(nd->getValue()<=actual->getValue())\n            actual=actual->getLeft();\n        else actual=actual->getRight();\n    }\n    nd->setParent(up);\n    if (nd->getValue()<=up->getValue())\n        up->setLeft(nd);\n    else up->setRight(nd);\n}\nif (nd->getValue()<=this->getMin()->getValue())\n    this->setMin(nd);\n}\n\ntemplate <class T>\nbool BST<T>::remove(bstNode<T>* nd)\n{\n\n    if (nd==this->getMin())\n        this->setMin(nullptr);\n    if (nd==this->getRoot() && nd->getRight()==nullptr && nd->getLeft()==nullptr)\n    {\n        this->setRoot(nullptr);\n        return true;\n    }\n    if (nd==this->getRoot() && nd->getRight()!=nullptr)\n        this->setRoot(nd->getRight());\n    else if( nd==this->getRoot() && nd->getLeft()!=nullptr)\n        this->setRoot(nd->getLeft());\n    bstNode<T>* Root=this->getRoot();\n    bstNode<T>* temp, *temp2;;\n    if (nd->getLeft()==nullptr)\n        this->swapTree(Root,nd,nd->getRight());\n    else if (nd->getRight()==nullptr)\n        this->swapTree(Root,nd,nd->getLeft());\n    else \n    {\n        temp=this->getMin(nd->getRight());\n        if (temp->getParent()!=nd)\n        {\n            this->swapTree(Root,temp,temp->getRight());\n            temp->setRight(nd->getRight());\n            temp2=temp->getRight();\n            temp2->setParent(temp);\n        }\n        this->swapTree(Root,nd,temp);\n        temp->setLeft(nd->getLeft());\n        temp2=temp->getLeft();\n        temp2->setParent(temp);\n    }\n    this->setMin(this->getMin(this->getRoot()));\n    return true;\n}\ntemplate <class T>\nbstNode<T>* BST<T>::getMin(bstNode<T>* nd)const //find and return the minimum of the tree whose root is nd\n{\n    while (nd->getLeft()!=nullptr)\n        nd=nd->getLeft();\n    return nd;\n}\n```\n\n\nand here's the Huffman part: \n\n```\ntemplate <class T>\nclass Encoder\n{\n    private:\n        std::vector <myTuple> *alphabet; //vector of tuples     <fequency,character, isInternal>\n        void createPqueue();\n        void createAlphabet();\n        void encode();\n        void showHuff(bstNode<T>*, string);\n        BST<T> *hTree;\n    public:\n        Encoder(){createAlphabet();createPqueue();};\n        ~Encoder(){};\n        std::vector <myTuple> * getAlphabet()const{return this-    >alphabet;}\n        BST<T> *getPqueue()const{return this->hTree;}\n        void askWhat();\n};\n\ntemplate <class T>\nvoid Encoder<T>::createPqueue()\n{\n    this->hTree=new BST<myTuple>();\n    if (this->hTree==nullptr)\n    {\n        cout<<\"Error allocating Red-Black Tree, now exiting...\"<<endl;\n        exit(-1);\n    }\n}\n\n\n\nfor (unsigned int i = 0; i < this->getAlphabet()->size(); ++i)\n{\n    bstNode<myTuple>* temp;\n    temp=new bstNode<myTuple>(this->getAlphabet()->at(i));\n    if (temp!=nullptr)\n        this->getPqueue()->insert(temp); //fill the priority Queue with  <int frequency, char character, bool is_internal> Nodes. I still have to remove tuples since they are not necessary anymore.\n    else\n         exit(-1);\n}\nbstNode<myTuple> *left, *right, *top;\nfor (unsigned int i = 0; i< u_int(this->getAlphabet()->size())-2;i++)\n{\n    left=this->getPqueue()->getMin();\n    this->getPqueue()->extractMin();\n    right=this->getPqueue()->getMin();\n    this->getPqueue()->extractMin();\n    myTuple temp ((get<0>( left->getValue() ) + get<0>( right->getValue() )),'\\0',true);\n    top=new bstNode<myTuple>(temp);\n    if (top==nullptr)\n    {\n        cout <<\"Can't allocate top, now exiting...\"<<endl;\n        exit(-1);\n    }\n    top->setLeft(left);\n    top->setRight(right);\n    this->getPqueue()->insert(top);\n}\n```\n\n\nI've been using the ```\nbool```\n value in tuples to distinguish between internal and external nodes, but with no success.\nThank you in advance and I'm really sorry if I've been messy, my clearness equals my state of mind as of now. Thank you.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Trying to sort a priority queue by one of the stored nodes' values\r\n                \r\nSo I'm new to priority queues. In an algorithm I'm trying to implement, I want to sort a priority queue according to the stored nodes' functionValue. I don't understand how the priority queue will know to sort the nodes by that value, as opposed to one of the other eight instance variables of my node objects. I'm pretty sure I define a Comparator object to define the comparison/ sorting rules, but I can't make heads or tails of the Oracle class library for Comparator.\n\nHere are the properties of my Node Class\n\n```\npublic class Node{\n\npublic char label;      //Holds char for the Move used; U, D, L, R\npublic boolean visited = false; \npublic State nodeState; //Each node holds a State object \nint depth;\nint heuristicCount;\nint functionCount;   <--- This is the property I want the priority queue to sort by.\n.\n.\n.\n```\n\n    ", "Answer": "\r\n```\nComparator```\n is a pretty simple interface. What's your difficulty with it? The key bit is the ```\ncompare```\n method. You simply implement that to compare two instances of your class. Something like:\n\n```\npublic class NodeComparator implements Comparator<Node> {\n    public int compare(Node a, Node b) {\n        Integer aCount = a.getFunctionCount();\n        Integer bCount = b.getFunctionCount();\n        return a.compareTo(b);\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Javascript and Priority Queues in coding interviews [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 2 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nOne pretty big issue I've run into with JS is that it has no in built in priority queue unlike Java or Python (heapq).\nI was just wondering in an interview situation, could you propose below solution and essentially 'pretend' that JS does indeed have a native Priority Queue structure:\nhttps://leetcode.com/problems/merge-k-sorted-lists/discuss/10528/A-java-solution-based-on-Priority-Queue\nOnly asking because implementing a MinHeap is pretty complicated and not sure if I'll able to do it in a high stress environment.\n    ", "Answer": "\r\nI think it's fair to assume you can use an npm library to make JavaScript have capabilities comparable to other languages.\nGoogle Closure Library has some useful structures implemented in JavaScript.\nYou can find ```\ngoog.structs.PriorityQueue```\n here.\nFacebook similarly has fbjs.\nYou can find their ```\nHeap```\n implementation here.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "In Python, without inporting anything, is it possible to do constant time searching on a Double Ended Priority Queue?\r\n                \r\nDouble Ended Priority Queue is implemented using Interval Heaps. \nMy double ended priority queue is of the form [['abc',xyz'],['c'.'t'],['f','n']]; so here minimum is 'abc' and maximum is 'xyz'. Heap is represented as list.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue - Binary Heap\r\n                \r\nI'm trying to implement a priority queue as an sorted array backed minimum binary heap. I'm trying to get the update_key function to run in logarithmic time, but to do this I have to know the position of the item in the array. Is there anyway to do this without the use of a map? If so, how? Thank you\n    ", "Answer": "\r\nIf you really want to be able to change the key of an arbitrary element, a heap is not the best choice of data structure.  What it gives you is the combination of:\n\n\ncompact representation (no pointers, just an array and an implicit\nindexing scheme)\nlogarithmic insertion, rebalancing\nlogarithmic removal of the smallest (largest) element.\nO(1) access to the value of the smallest (largest) element.  -\n\n\nA side benefit of 1. is that the lack of pointers means you do substantially fewer calls to ```\nmalloc/free```\n (```\nnew/delete```\n).\nA map (represented in the standard library as a balanced binary tree) gives you the middle two of these, adding in \n\n\nlogarithmic ```\nfind()```\n on any key.  \n\n\nSo while you could attach another data structure to your heap, storing pointers in the heap and then making the comparison operator dereference through the pointer, you'd pretty soon find yourself with the complexity in time and space of just using a ```\nmap```\n in the first place.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "in menu driven program printing the highest priority Using Priority Queue and Heap\r\n                \r\nSo basically i am trying to implement a menu driven program using Priority Queue and Heap to accept incoming patient’s name and an integer that indicates the seriousness of their condition.  This integer is a value between 1 and 5 – 1 being a minor illness and 5 being a critical condition\nThe code i have got for Heap\n```\n#include <iostream>\n\ntemplate<class ItemType>\n// Assumes ItemType is either a built-in simple  // type or a class with overloaded relational    // operators.\nstruct HeapType\n{\n    void ReheapDown(int root, int bottom);\n    void ReheapUp(int root, int bottom);\n    ItemType* elements;                                       // Array to be allocated dynamically\n    int numElements;\n\n    //new\n    void Swap(ItemType& x, ItemType& y);\n};\n\ntemplate<class ItemType>\nvoid HeapType<ItemType>::ReheapDown(int root, int bottom)\n// Post: Heap property is restored.\n{\n    int maxChild;\n    int rightChild;\n    int leftChild;\n    leftChild = root * 2 + 1;\n    rightChild = root * 2 + 2;\n    if (leftChild <= bottom)\n    {\n        if (leftChild == bottom)\n            maxChild = leftChild;\n        else\n        {\n            if (elements[leftChild] <= elements[rightChild])\n                maxChild = rightChild;\n            else\n                maxChild = leftChild;\n        }\n        if (elements[root] < elements[maxChild])\n        {\n            Swap(elements[root], elements[maxChild]);\n            ReheapDown(maxChild, bottom);\n        }\n    }\n}\n\n\ntemplate<class ItemType>\nvoid HeapType<ItemType>::ReheapUp(int root, int bottom)\n// Post: Heap property is restored.\n{\n    int parent;\n    if (bottom > root)\n    {\n        parent = (bottom - 1) / 2;\n        if (elements[parent] < elements[bottom])\n        {\n            Swap(elements[parent], elements[bottom]);\n            ReheapUp(root, parent);\n        }\n    }\n}\n\n// New\n// Swapp items\ntemplate<class ItemType>\nvoid HeapType<ItemType>::Swap(ItemType& x, ItemType& y) {\n\n    ItemType t = x;\n    x = y;\n    y = t;\n}\n```\n\nThe code i have got for Priority Queue\n```\n#pragma once\n#include <iostream>\n#include \"Heap.h\"\n\nusing namespace std;\n\ntemplate<class ItemType>\n\nclass PQType\n{\npublic:\n    PQType(int);                                // parameterized class constructor\n    ~PQType();                                // class destructor\n    void MakeEmpty();\n    // Function: Initializes the queue to an empty\n    // state.\n    // Post: Queue is empty.\n    bool IsEmpty() const;\n    // Function: Determines whether the queue is\n    // empty.\n    // Post: Function value = (queue is empty)\n    bool IsFull() const;\n    // Function: Determines whether the queue is\n    // full.\n    // Post: Function value = (queue is full)\n    void Enqueue(ItemType newItem);\n    // Function: Adds newItem to the rear of the\n    // queue.\n    // Pre:  Queue is not full.\n    // Post: newItem is in the queue.\n    void Dequeue(ItemType& item);\n    // Function: Removes element with highest\n    // priority from the queue\n    // and returns it in item.\n    // Pre:  Queue is not empty.\n    // Post: Highest priority element has been \n    //       removed from the queue.\n    //       item is a copy of the removed element\n    void Print();\n\n  private:\n    int numItems;\n    HeapType<ItemType> items;\n    int maxItems;\n};\n\ntemplate<class ItemType>\nPQType<ItemType>::PQType(int max)\n{\n    maxItems = max;\n    items.elements = new ItemType[max];\n    numItems = 0;\n}\n\ntemplate<class ItemType>\nPQType<ItemType>::~PQType()\n{\n    delete[] items.elements;\n}\n\ntemplate<class ItemType>\nvoid PQType<ItemType>::MakeEmpty()\n{\n    numItems = NULL;\n}\n\ntemplate<class ItemType>\nbool PQType<ItemType>::IsEmpty() const\n// Post: Function value = true if the queue is   //         empty; false, otherwise\n{\n    return numItems == 0;\n}\ntemplate<class ItemType>\nbool PQType<ItemType>::IsFull() const\n// Post: Function value = true if the queue is   //         full; false, otherwise\n{\n    return numItems == maxItems;\n}\n\ntemplate<class ItemType>\nvoid PQType<ItemType>::Enqueue(ItemType newItem)\n// Post: newItem is in the queue.\n{\n    numItems++;\n    items.elements[numItems - 1] = newItem;\n    items.ReheapUp(0, numItems - 1);\n}\n\ntemplate<class ItemType>\nvoid PQType<ItemType>::Dequeue(ItemType& item)\n// Post: element with highest priority has been  \n// removed from the queue; a copy is returned in item.\n{\n    item = items.elements[0];\n    items.elements[0] = items.elements[numItems - 1];\n    numItems--;\n    items.ReheapDown(0, numItems - 1);\n}\n\ntemplate <class ItemType>\nvoid PQType<ItemType>::Print()\n{\n    for (int i = 0; i <= numItems - 1; i++)\n    {\n        cout << \"\\t \" << items.elements[i].name << \" \\t \" << items.elements[i].priority << endl;\n    }\n}\n```\n\nThe code for main page i have got\n```\n#include \"Priority_Queue.h\"\n#include \"Heap.h\"\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\n\nstruct Patient\n{\n    string name;\n    int priority;\n\n    bool operator < (Patient P1)\n    {\n        return false;\n    }\n    bool operator <= (Patient P1) \n    {\n        return true;\n    }\n    bool operator > (Patient P1) \n    {\n        return false;\n    }\n    bool operator >= (Patient P1) \n    {\n        return false;\n    }\n    bool operator == (Patient P1) \n    {\n        return true;\n    }\n};\n\nint main()\n{\n    string x = \"2\";\n    int y = 0;\n\n    Patient P1 = { \"Tom\", 3 };\n    Patient P2 = { \"Mary\", 4 };\n    Patient P3 = { \"Fred\", 3 };\n    Patient P4 = { \"Sarah\", 1 };\n    Patient P5 = { \"Ann\", 5 };\n    Patient P6 = { \"Mike\", 4 };\n    Patient PUser = { x , y };\n\n    PQType<Patient> pQueue(100);\n\n   /* pQueue.Enqueue(P1);\n    pQueue.Enqueue(P2);\n    pQueue.Enqueue(P3);\n    pQueue.Enqueue(P4);\n    pQueue.Enqueue(P5);*/\n\n    int choice, priority;\n    string name = \"\";\n\n    do\n    {\n        cout << \"1.Insert\\n\";\n        cout << \"2.Delete\\n\";\n        cout << \"3.Display\\n\";\n        cout << \"4.Quit\\n\";\n        cout << \"Enter your choice : \";\n\n        cin >> choice;\n        switch (choice)\n        {\n        case 1:\n            cout << \"Enter Patient`s name: \";\n            cin >> name;\n            cout << \"Enter the priority: \";\n            cin >> priority;\n            break;\n\n        case 2:\n            cout << \"Enter Patient`s name: \";\n            cin >> name;\n            break;\n\n        case 3:\n            pQueue.Print();\n            break;\n\n        case 4:\n            break;\n\n         default:\n\n            cout << endl;\n            cout << \"Wrong choice\\n\";\n            cout << endl;\n        }\n\n    } while (choice != 4);\n\n    return 0;\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue using MultiMap - Java\r\n                \r\nI have to implement Priority Queue using MultiMap. I use MultiMap from Google Collections. \nThe following code creates a MultiMap and adds few elements into it. \n\n```\n    Multimap<Integer, String> multimap = HashMultimap.create();\n\n    multimap.put(5,\"example\");\n    multimap.put(1,\"is\");\n    multimap.put(1,\"this\");\n    multimap.put(4,\"some\");\n```\n\n\nNow my problem is how to write the pop method? \n\nI think that there should be a for loop and it should be iterating through MultiMap. \n\nThe lowest key should be the highest priority, so in C++ I would set a pointer to the first element and increment it. How to do it in Java?\n    ", "Answer": "\r\nThe ```\nHashMultimap```\n you're using won't give you any help in efficiently selecting the lowest element. Instead use a ```\nTreeMultimap```\n (also in Google Collections) which lets you specify an ordering and iterate through the items in the list in that order. For instance:\n\n```\nfor (Map.Entry<Integer, String> entry : multimap.entries()) {\n  System.out.println(\"Item \" + entry.getValue() + \" has priority \" + entry.getKey();\n}\n```\n\n\nYou'll notice that this always prints out entries in priority order, so to get the first-priority element you can just do ```\nmultimap.entries().iterator().next()```\n  (assuming you know the map has at least one element).\n\nSee the TreeMultimap documentation for more information.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Peek Method For Priority Queue\r\n                \r\nI am implementing a priority queue using a singly sorted linked list. How do I do the peek method? It is supposed to return a copy of the next item in the queue, without removing the item. The next item is the same value that would be returned by the dequeue operation. An item cannot be dequeued from an empty queue.\n\nWould I simply just return a part of my dequeued function or would I do something else??\n\nMy Code:\n\n```\nclass Node( object ) :\n  def __init__( self, cargo = None, next = None ) :\n      self.cargo = cargo\n      self.next = next\n\n# Creates a new empty unbounded priority queue\nclass PriorityQueue :\n\n\n  def __init__( self ) :\n      self.length = 0\n      self.head = None\n      self.last = None\n\n # Returns a boolean value indicating whether the queue is empty\n  def isEmpty( self ) :\n      return (self.length == 0)\n\n # Returns the number of items currently in the queue\n def __len__( self ) :\n      return len(self.length)\n\n\n # Adds the given item to the queue by inserting it in the proper position \n # based on the given priority. The new node is appeneded to the end of the\n # linked list\n  def enqueue( self, item, priority) :\n      newNode = Node(cargo)\n      newNode.next = None\n      if self.length == 0:\n          self.head self.last = newNode\n      newNode.next = self.head\n      self.head = newNode\n      self.last.next = newNode\n      self.last = newNode\n\n      temp = self.head\n      p = self.head.next\n      while p != None :\n          if p.cargo > newNode.cargo:\n             temp = temp.next\n             p = p.next\n          break\n      newNode.next = temp.next\n      temp.next = newNode\n\n\n # Removes and returns the next item from the queue, which is the item with \n # the highest priority. If two or more items have the same priority, those \n # items are removed in FIFO order. An item cannot be dequeued from an\n # empty queue. The linked list is searched to find the entry with the  \n # highest priority.\n  def dequeue( self ) :\n      cargo = self.head.cargo\n      self.head = self.head.next\n      self.length = self.length - 1\n      if self.length == 0:\n          self.last = None\n      return cargo\n\n\n# Returns a copy of the next item in the queue, without removing the item. \n# The next item is the same value that would be returned by the dequeue \n# operation. An item cannot be dequeued from an empty queue.\n  def peek( self ) :\n```\n\n    ", "Answer": "\r\n```\nDef Peek():\n    if not self.empty():\n        return self.head.cargo\n    else:\n        return None\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priorities in Priority Queue\r\n                \r\nI was doing interview question on priority queues and have a simple question I was hoping to get some help with. The question is:\n\nShould the priorities be integral? Could I implement string priorities.\n\nThanks in advance :-)\n    ", "Answer": "\r\n?\n\nThe priorities can be anything that have a partial order defined, although a total order would be more common (e.g. integers, or strings ordered lexiographically).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "\"No matching member function for call to push\" in Priority Queues C++\r\n                \r\nI'm trying to implement a priority queue right now, but I keep getting an error saying that ```\npush```\n is not a member function. I never used priority queue before, so I'm pretty sure I'm messing up somewhere...\n\n```\nstruct X\n{\n    unordered_map<string, double> distance;\n    unordered_map<string, string> vertices;\n};\n\nvoid make(std::string source)\n{\n    X distance;\n    X parent;\n    priority_queue<X, std::vector<X>, greater<void>> pq; //i'm pretty sure there's something wrong with the templates?\n    distance.distance[source] = 0;\n    pq.push(std::make_pair(start, 0));\n```\n\n    ", "Answer": "\r\nThe class has to be comparable and must respond to operators like < and > so that the queue can sort them:\n\n```\nclass X {\n    public:\n    unordered_map<string, double> distance;\n    unordered_map<string, string> vertices;\n    int priority;\n    bool operator< (const X& b) {\n        return priority < b.priority;\n    }\n    bool operator> (const X& b) {\n        return priority > b.priority;\n    }\n};\n\nvoid make(std::string source) {\n    priority_queue<X, vector<X>, greater<void>> pq;\n\n    X element;\n    element.distance[source] = 0;\n    element.priority = 100;\n    pq.push(element);\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queue INSERTION and DISPLAY function in C++\r\n                \r\nTrying to implement priority queue insertion dev c++ IDE), i.e. before node with priority > new node's priority. Insertions from user seem to occur on command prompt but display function outputs only the first node. Why are other queue elements not being displayed? I am afraid they are not being inserted in first place that is why upon subsequent insertion of 10,20,30 and then deletion..it prints empty queue.. because queue only had 10..why?Please suggest.\n\nNote: I have not included delete and main function, here in code, but it is there in the program, obviously..no run time exception occurs..compilation works fine. But no desired output. \n\n```\n#include<iostream>\nusing namespace std;\n\ntypedef struct node{ //template would enable generic datatype\n        int info,prn;\n        node * link;\n}node;\n\nnode * start = 0;\nint item,pri;\n\n\n\n    void insert(int item, int pri){\n     node * newnode = new node;\n     newnode-> info = item;\n     newnode-> prn = pri;\n\n     if(start == 0){//explicit check in insert if start is NULL.\n              start = newnode;\n              newnode->link = 0;\n     }\n     /*When you first run the program, start = 0 or NULL. You then say prev = start, \nso as a result prev = NULL. So when you try to access prev->link, there's an access violation.*/\n     else{ \n          node * prev= start;\n          node * temp = prev->link;\n          while (temp!= 0){\n                if(temp->prn > newnode->prn){\n                        newnode -> link = prev -> link;\n                        prev -> link = newnode;\n                break;\n                } \n                else{\n                     if( temp->link == 0){\n                              temp -> link = newnode;\n                              newnode->link = 0;\n                     break;\n                     }\n                } \n           prev = prev->link;                    \n          }\n     }\n}\nvoid display(){\n     if(start == 0)\n              cout<<\"Empty priority queue\\n\";\n     else{\n          cout<<(\"The Contents of the List are: \");\n          node *temp = start;   \n          while(temp!=NULL){   //if we do while temp->link!=NULL, then last node won't print\n                               cout<< temp->info;\n                               cout<<\" ---> \";\n                               temp = temp->link;\n          }\n     }             \n}\n```\n\n    ", "Answer": "\r\nWhen insert is called for the first time, start will be 0 but yet you will assign it to prev. On the next line, the one giving you the error you call ```\nprev->link```\n so c++ crashes as you invoke a method on NULL(which invokes undefined behavior). You should add an explicit check in insert if ```\nstart```\n is NULL.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "F# Priority Queue\r\n                \r\nI have tried to use this snippet of code\n\nhttps://code.msdn.microsoft.com/windowsdesktop/Net-Implementation-of-a-d3ac7b9d\n\nto implement a heap-based implementation of Prim's algorithm to solve the Minimum Spanning Tree (MST) problem in a non-directed connected graph.\n\nafter a few iterations, i find that the heap/priority queue is not well maintained anymore.\nthat is the head of the PriorityQueue doesn't have the lowest Key in the Heap.\n\n```\nPQ 0 [-7230, 309]\n...\nPQ 146 [-7277, 308]\n```\n\n\nHas anyone use this code and experienced similar problems ?\nI can post a link on GitHub if anyone would be looking at it\n\nMy needs are for a heap datastructure which supports deletion of an element in the middle. It looks like Fsharpx.collections doesnt have such a data structure.\n\ndoes anybody know a good implementation available somewhere ?\n\nthanks\n    ", "Answer": "\r\nRecently, I ported a MaxHeap from PLINQ to F# here and made it MinHeap. It is array-based and performs much better than any \"pure functional\" alternative.\n\nHowever, after a lot of benchmarking, I found that SortedDeque based on just a simple sorted circular buffer performs significantly better on most use cases even when I need to add or delete in the middle.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "generic priority queues design in C++\r\n                \r\nI am designing a generic priority queue in C++ which can take any data type as key either it can be int or user defined structure. I want to implement priority queue using binary heap, linked lists, bionomial heap, and fibanocci heap. Here user can select any implementation. For some of the functions I should return internal handles to user so that users can pass to priority queue for certain operations to have good performance, for example change function, remove functions, here if we have handle we can have this implementations fast rather than searching.\n\nSo I have generic priority interface as shown below\n\n```\ntemplate <class Item>\nclass IMyPriorityQueue {\nprivate:\n    /* Implementattion dependent code\n       Here we can implement priority queue functions mentioned in public section of class using\n       ordered array, unordered array, ordered list, unordered list, heap data structure, \n       bionomial heap and fibonacci heap.  (here list means double linked list).\n\n       Heap means is a tree is heap-ordered if the key in each node is larger than or equal to the keys in all of that node's children (if any).\n       Equivalently, the key in each node of a heap-ordered tree is smaller than or equal to the key in that node's parent (if any).\n\n       Read Robert Sedwick on various implementation have performance on Table 9.1 on page .\n\n    */\n\npublic:\n    // Implementation-dependent handle definition\n    IMyPriorityQueue(int);\n    virtual ~IMyPriorityQueue();\n    virtual int empty() const            = 0;\n    virtual handle insert(Item )         = 0;\n    virtual int getmax()                 = 0;\n    virtual void change(handle, Item)    = 0;\n    virtual void remove(handle)          = 0;\n    virtual void join(IMyPriorityQueue&) = 0;\n};\n\n\ntemplate <class Item>\nclass CMyLinkedListPriorityQueue : public IMyPriorityQueue {\nprivate:\n\n    // Implementing using unordered double linked list.\n    struct sPQNode {\n        Item     pqItem;\n        sPQNode* pPrevPQNode;\n        sPQNode* pNextPQNode;\n\n        sPQNode(Item itm) {\n            pqItem      = itm; \n            pPrevPQNode = 0; \n            pNextPQNode = 0; \n        }\n    };\n\n    // Note: here head and tail are it self sPQNode* rather than void* pointer which points to first node.\n    sPQNode* m_pPQhead;\n    sPQNode* m_pPQTail;\n\n    std::vector<sPQNode*> m_vecPQNodePointer;\n    int                   m_iVecContainerIndex;\n\n    CMyLinkedListPriorityQueue(int = 0) {\n        m_pPQhead = new sPQNode(0);\n        m_pPQTail = new sPQNode(0);\n        m_pPQhead->pPrevPQNode = m_pPQTail; m_pPQhead->pNextPQNode = m_pPQTail;\n        m_pPQTail->pPrevPQNode = m_pPQhead; m_pPQTail->pNextPQNode = m_pPQhead;\n        m_iVecContainerIndex  = 0;\n    }\n\n    int empty() const {\n        return m_pPQhead->pNextPQNode->pNextPQNode == m_pPQhead;\n        m_iVecContainerIndex = 0;\n    }\n\n    handle insert(Item v) {\n        handle insPQNode = new node(v);\n        insPQNode->pNextPQNode = m_pPQhead->pNextPQNode; insPQNode->pNextPQNode->pPrevPQNode = insPQNode;\n        insPQNode->pPrevPQNode = m_pPQhead; m_pPQhead->pNextPQNode = insPQNode;\n        m_vecPQNodePointer[m_iVecContainerIndex++] = insPQNode\n        return (m_iVecContainerIndex - 1);\n    }\n\n    Item getmax() {\n        Item max; sPQNode* pHeadNext = head->next;\n        for (link t = x; t->next != head; t = t->next) {\n            if (x->item < t->item) x = t;\n        }\n        max = x->item;\n        remove(x);\n        return max;\n    }\n\n    void change(handle hItem, Item itm) {\n        m_iVecContainerIndex[hItem]->item = itm;\n    }\n\n    void remove(handle hItem) {\n                // **Question how to handle this and join operation**\n                 }\n\n    void join(PQ<Item>& p) {\n        tail->prev->next = p.head->next;\n        p.head->next->prev = tail->prev;\n        head->prev = p.tail;\n        p.tail->next = head;\n        delete tail; delete p.head;\n        tail = p.tail;\n     }\n};\n```\n\n\nProblem I am facing with above design if we remove an item and empty that particular location I am making that entry in vector to null, but problem is that vector size is growing as program runs for long time. I can think of use of map container but again this will search again. I want to avoid search during remove, join and change operations.\n\nAny better design to handle above scenario.\n\nThanks for your inputs\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "c++ a fixed sized priority queue to store k-nearest neighbors\r\n                \r\nI am implementing k nearest neighbor search in a tree data structure. I store the results in a priority queue, which will automatically sort the elements in a ascending order, and so the first k elements are the results. The priority_queue container in STL is really not a good option here because it support only a few functions such as push(), pop(), top(), size() empty(), etc. A big problem here is that when searching the whole tree, I need to visit a lot of nodes, and using push() will make the priority queue longer and longer, which will increase time cost for later operations. What I really want is a fixed-length priority queue, so when push() a new element into the queue, some elements with larger values will be automatically deleted. How can I implement this? Or is there any standard container I can use? Thank you.   \n    ", "Answer": "\r\nWhat about using ```\nstd::set```\n? It stores elements in order, and if it grows above ```\nk```\n elements you can just remove the largest one (in constant time). Each insertion is O(log k).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "STL priority queue and overloading with pointers\r\n                \r\nThis is my first time using a priority queue. I'm trying to implement Dijkstra's algorithm for school and I figured I need a min heap to do this. Right now my nodes are pointers and I want to compare their weight, but I don't think I can overload > and < with pointers? Is there a way I could accomplish this?\n\nCode this far:\n\n```\npriority_queue<Node*, vector<Node*>, node_comparison> minHeap;\n```\n\n\nAnd then I have a struct to compare the node's weights\n\n```\nstruct node_comparison \n{\n   bool operator<( const Node* a, const Node* b ) const \n   {\n    return a->totalWeight < b->totalWeight;\n   }\n};\n```\n\n\nHowever it says there are too many parameters for this operator function. I've been trying to figure out how I could manage a min heap priority queue with my nodes for a while now and keep getting stuck. Any ideas?\n    ", "Answer": "\r\nIf I understand your question correctly, I believe what you actually want is to make ```\nnode_comparison```\n a functor (more specifically, a binary predicate):\n\n```\nstruct node_comparison \n{\n    bool operator () ( const Node* a, const Node* b ) const \n    {\n        return a->totalWeight < b->totalWeight;\n    }\n};\n```\n\n\nA functor is a class whose objects provide an overload of the call operator (```\noperator ()```\n) and, therefore, can be invoked with the same syntax you would use for invoking a function:\n\n```\nNode* p1 = ...;\nNode* p2 = ...;\nnode_comparison comp;\nbool res = comp(p1, p2) // <== Invokes your overload of operator ()\n```\n\n\nInternally, ```\nstd::priority_queue```\n will instantiate your predicate more or less like I did in the code snippet above, and invoke it that way to perform comparisons between its elements.\n\n\n\nThe advantage of functors over regular functions is that they could hold state information (something you probably won't need for the moment, but which often turns out to be desirable):\n\n```\n#include <cmath>\n\nstruct my_comparator\n{\n    my_comparator(int x) : _x(x) { }\n\n    bool operator () (int n, int m) const\n    {\n        return abs(n - _x) < abs(m - _x);\n    }\n\n    int _x;\n};\n```\n\n\nThe above predicate, for instance, compares integers based on how distant they are from another integer provided at construction time. This is how it could be used:\n\n```\n#include <queue>\n#include <iostream>\n\nvoid foo(int pivot)\n{\n    my_comparator mc(pivot);\n    std::priority_queue<int, std::deque<int>, my_comparator> pq(mc);\n\n    pq.push(9);\n    pq.push(2);\n    pq.push(17);\n\n    while (!pq.empty())\n    {\n        std::cout << pq.top();\n        pq.pop();\n    }\n}\n\nint main()\n{\n    foo(7);\n\n    std::cout << std::endl;\n\n    foo(10);\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How would i pop and push with this priority queue?\r\n                \r\nI am trying to use the push and pop with jobs from the priority queue. How would i do this? I am curious on how to implement this?  \n\n```\nclass Job\n    {\n    public:\n        int job_id;\n        string job_description;\n        int n_procs;    \n        int n_ticks;\n\n\n        Job(int job_id, string job_description, int n_procs, int n_ticks);\n        Job(void);\n        ~Job(void);\n    };\n\n\n\n    typedef vector<Job> Jobs;\n    typedef priority_queue<Job, Jobs, less<Job>> JobQueue;\n```\n\n    ", "Answer": "\r\nThe priority queue class provides basic operations for accessing elements in the queue:\n\n\n```\nvoid std::priority_queue::push(const T &)```\n: Pushes the given object onto the priority queue.\n```\nconst T &std::priority_queue::top() const```\n: Returns the \"top\" element.\n```\nvoid std::priority_queue::pop();```\n: Removes the \"top\" element.\n\n\nJust substitute ```\nJob```\n for ```\nT```\n.\n\nBTW:\n\n\n  I have not overloaded the < operator. I think the less just makes it the priority queue in decending order\n\n\nAnd how will it know what \"decending order\" is without knowing how to compare them? All ```\nstd::less```\n does is call whatever ```\noperator<```\n you have defined. If you haven't defined an ```\noperator<```\n, then ```\nstd::less```\n will fail to work.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do I get pika to listen on priority queues first?\r\n                \r\nI have 2 microservices that communicate via rabbitmq, I need to implement priority messages.\nThe first microservice acts as a publisher, written in symfony + messenger (amqp transport).\nThe second microservice acts as a consumer, written in python + pika.\nThe messenger documentation (https://symfony.com/doc/current/messenger.html#prioritized-transports) recommends using separate queues for different message priorities, this component is not able to use rabbitmq's built-in capabilities to prioritize messages. And actually there are no problems with the publisher, I configured it so that the necessary messages go to the priority queue.\nProblems came with the consumer, I can't get pika to read the priority queue first, and then the regular one.\nHere is an example of my messenger component configuration:\n```\nframework:\n    messenger:\n        transports:\n            priority:\n                dsn: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n                options:\n                    exchange:\n                        name: priority\n                    queues:\n                        priority: ~\n            normal:\n                dsn: \"%env(MESSENGER_TRANSPORT_DSN)%\"\n                options:\n                    exchange:\n                        name: normal\n                    queues:\n                        normal: ~\n        routing:\n            'App\\Message\\PriorityRequest': priority\n            'App\\Message\\NormalRequest': normal\n\n```\n\nThis is how I fill the queues:\n```\nfor ($i = 0; $i < 10; $i++) {\n    $bus->dispatch(new PriorityRequest($i, 'priority'));\n    $bus->dispatch(new NormalRequest($i, 'normal'));\n}\n```\n\nAnd here is an example of a consumer implementation in python + pika:\n```\nimport pika\nimport os\n\ndef do_work(self, connection, channel, delivery_tag, body):\n   print(body)\n\n\nparameters = pika.URLParameters(os.getenv('MESSENGER_TRANSPORT_DSN'))\nconnection = pika.BlockingConnection(parameters)\n\nchannel = connection.channel()\nchannel.basic_qos(prefetch_count=1)\n\nchannel.queue_declare(queue='priority', durable=True)\nchannel.queue_declare(queue='normal', durable=True)\n\nchannel.basic_consume(queue='priority', on_message_callback=do_work, auto_ack=True)\nchannel.basic_consume(queue='normal', on_message_callback=do_work, auto_ack=True)\n\nchannel.start_consuming()\n```\n\nAnd if we run the consumer code, we get the following output:\n```\n{'id': 0, 'data': 'priority'}\n{'id': 0, 'data': 'normal'}\n{'id': 1, 'data': 'priority'}\n{'id': 1, 'data': 'normal'}\n{'id': 2, 'data': 'priority'}\n{'id': 2, 'data': 'normal'}\n{'id': 3, 'data': 'priority'}\n{'id': 3, 'data': 'normal'}\n{'id': 4, 'data': 'priority'}\n{'id': 4, 'data': 'normal'}\n{'id': 5, 'data': 'priority'}\n{'id': 5, 'data': 'normal'}\n{'id': 6, 'data': 'priority'}\n{'id': 6, 'data': 'normal'}\n{'id': 7, 'data': 'priority'}\n{'id': 7, 'data': 'normal'}\n{'id': 8, 'data': 'priority'}\n{'id': 8, 'data': 'normal'}\n{'id': 9, 'data': 'priority'}\n{'id': 9, 'data': 'normal'}\n```\n\nMessages are processed in FIFO order, how do I force pika to process messages first from the priority queue and only if the priority queue is empty go to the normal queue?\n    ", "Answer": "\r\nThis is not supported by Pika out-of-the-box.\nOne option is to ```\nbasic_consume```\n from the priority queue first. When the queue is empty, cancel that consumer, and then ```\nbasic_consume```\n from the other queue. When that work is done, repeat and go back to the priority queue.\n\nNOTE: the RabbitMQ team monitors the ```\nrabbitmq-users```\n mailing list and only sometimes answers questions on StackOverflow.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do I implement in Java a priority queue of a Tuple that sorts using both fields with different types?\r\n                \r\nI have created a class called Thread with two fields: int index and long start_time, like this:\n\n```\nclass Thread {\n    public Thread(int index, long start_time) {\n        this.index = index;\n        this.start_time = start_time;\n    }\n\n    public int index;\n    public long start_time;\n}\n```\n\n\nAfter that I've created a Priority Queue of Threads like this:\n\n```\nPriorityQueue<Thread> worker = new PriorityQueue<>();\n```\n\n\nSo, I'm going to feed this queue with n threads with numbers from 0 to n-1. They all start with 0 as start_time like this:\n\n```\nfor (int i = 0; i < numWorkers;i++){\n            worker.add(new Threads(i , 0));\n}  \n```\n\n\nAnd later I'll add jobs in time, so lets say the jobs are {4 , 3}; if the Pqueue has 2 elements (0,0) and (1,0) it will turn into (0,4) and (1,3) as poll() will pick 0 as priority (ascendant according to index) but next time poll() will pop (1,3) first because 3 is less than 4 (so it sorts ascendant by start_time but if they are equal, then it sorts ascendant by index). \n\nI'm just learning data structures and working with Comparable and Comparator so this is the first time I have to use it but most examples dont mention Tuples or they just sort by one field. My idea of implementation was this:\n\n```\nclass threadComparator implements Comparator<Thread> {\n    @Override\n    public int compare(Thread a, Thread b) {\n        if (a.start_time==b.start_time){\n            return a.index - b.index;\n        }\n        return a.start_time - b.start_time;\n    }\n}\n```\n\n\nAccording to my IDE, I cannot use return a.start_time - b.start_time (incompatible types required int found long) \n\nI used this page in CodeGeeks as example but that example doesn't use long types. \n\nFinally, how should where should I include this threadComparator to apply this sort order in my Priority Queue? I assume is:\n\n```\nPriorityQueue<Thread> worker = new PriorityQueue<>(new threadComparator);\n```\n\n\nWould that be right? Should I implement the Comparator in the threadComparator class or just in the Thread class.\nPlease don't be mean, I've googled for it and searched here in SO but I cant find a similar example. Hope my explanation is clear enough.\n    ", "Answer": "\r\nThe substraction of 2 ```\nlong```\n values is of type ```\nlong```\n, which is why you cannot return\n\n```\na.start_time - b.start_time\n```\n\n\nFurthermore note that in case negative values are allowed,\n\n```\na.index - b.index\n```\n\n\nand\n\n```\na.start_time - b.start_time\n```\n\n\ncould overflow and return invalid results.\n\nIt would be preferable to implement the ```\ncompare```\n like this:\n\n```\npublic int compare(Thread a, Thread b) {\n    int c = Long.compare(a.start_time, b.start_time);\n    return c == 0\n                  ? Integer.compare(a.index, b.index) // compare index, if start_time is the same\n                  : c; // if start_times are different, use the result of comparing the 2 fields\n}\n```\n\n\nIn java 8 you could also construct a comparator like this:\n\n```\nComparator<Thread> comparator = Comparator.comparingLong(thread -> thread.start_time)\n                                          .thenComparingInt(thread -> thread.index);\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Issues with Declaring a C++ Priority Queue using a custom Comparator\r\n                \r\nI have been trying to implement a Priority queue consisting of a custom data type and a custom comparator but when I try to compile I get this error. I have tried multiple declarations but they all yield this error.\n\n```\npriority_queue<myData, vector<myData>, myComp> myPQ;\n\npriority_queue<myData, vector<myData>, myComp> myPQ(compVariable);\n```\n\n\nI also am trying to create a vector of these priority queues after creating them.\n\n```\n   /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h: In instantiation of ‘bool std::less<_Tp>::operator()(const _Tp&, const _Tp&) const [with _Tp = Order]’:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_heap.h:183:47:   required from ‘void std::__push_heap(_RandomAccessIterator, _Distance, _Distance, _Tp, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Order*, std::vector<Order, std::allocator<Order> > >; _Distance = long int; _Tp = Order; _Compare = std::less<Order>]’\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_heap.h:222:58:   required from ‘void std::push_heap(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Order*, std::vector<Order, std::allocator<Order> > >; _Compare = std::less<Order>]’\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_queue.h:499:41:   required from ‘void std::priority_queue<_Tp, _Sequence, _Compare>::push(const value_type&) [with _Tp = Order; _Sequence = std::vector<Order, std::allocator<Order> >; _Compare = std::less<Order>; std::priority_queue<_Tp, _Sequence, _Compare>::value_type = Order]’\nMarket.cpp:144:32:   required from here\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: error: no match for ‘operator<’ (operand types are ‘const Order’ and ‘const Order’)\n       { return __x < __y; }\n                    ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note: candidates are:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_algobase.h:64:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/char_traits.h:39,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_pair.h:220:5: note: template<class _T1, class _T2> constexpr bool std::operator<(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\n     operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_pair.h:220:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::pair<_T1, _T2>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_algobase.h:67:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/char_traits.h:39,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:297:5: note: template<class _Iterator> bool std::operator<(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\n     operator<(const reverse_iterator<_Iterator>& __x,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:297:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_algobase.h:67:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/char_traits.h:39,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:347:5: note: template<class _IteratorL, class _IteratorR> bool std::operator<(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\n     operator<(const reverse_iterator<_IteratorL>& __x,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:347:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::reverse_iterator<_Iterator>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_algobase.h:67:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/char_traits.h:39,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:1055:5: note: template<class _IteratorL, class _IteratorR> bool std::operator<(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)\n     operator<(const move_iterator<_IteratorL>& __x,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:1055:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::move_iterator<_Iterator>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_algobase.h:67:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/char_traits.h:39,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:1061:5: note: template<class _Iterator> bool std::operator<(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)\n     operator<(const move_iterator<_Iterator>& __x,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_iterator.h:1061:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::move_iterator<_Iterator>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:52:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/basic_string.h:2569:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator<(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)\n     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/basic_string.h:2569:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:52:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/basic_string.h:2581:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator<(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\n     operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/basic_string.h:2581:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:52:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/basic_string.h:2593:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator<(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)\n     operator<(const _CharT* __lhs,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/basic_string.h:2593:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   mismatched types ‘const _CharT*’ and ‘Order’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/vector:64:0,\n                 from P2.h:4,\n                 from Market.cpp:3:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_vector.h:1420:5: note: template<class _Tp, class _Alloc> bool std::operator<(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\n     operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_vector.h:1420:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::vector<_Tp, _Alloc>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/deque:64:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/queue:60,\n                 from Market.cpp:6:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_deque.h:273:5: note: template<class _Tp, class _Ref, class _Ptr> bool std::operator<(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref, _Ptr>&)\n     operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_deque.h:273:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::_Deque_iterator<_Tp, _Ref, _Ptr>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/deque:64:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/queue:60,\n                 from Market.cpp:6:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_deque.h:281:5: note: template<class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR> bool std::operator<(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\n     operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_deque.h:281:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::_Deque_iterator<_Tp, _Ref, _Ptr>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/deque:64:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/queue:60,\n                 from Market.cpp:6:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_deque.h:1975:5: note: template<class _Tp, class _Alloc> bool std::operator<(const std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\n     operator<(const deque<_Tp, _Alloc>& __x,\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_deque.h:1975:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::deque<_Tp, _Alloc>’\n       { return __x < __y; }\n                    ^\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/queue:64:0,\n                 from Market.cpp:6:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_queue.h:286:5: note: template<class _Tp, class _Seq> bool std::operator<(const std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\n     operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n     ^\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_queue.h:286:5: note:   template argument deduction/substitution failed:\nIn file included from /usr/um/gcc-4.8.2/include/c++/4.8.2/string:48:0,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/locale_classes.h:40,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/bits/ios_base.h:41,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ios:42,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/ostream:38,\n                 from /usr/um/gcc-4.8.2/include/c++/4.8.2/iostream:39,\n                 from Market.cpp:1:\n/usr/um/gcc-4.8.2/include/c++/4.8.2/bits/stl_function.h:235:20: note:   ‘const Order’ is not derived from ‘const std::queue<_Tp, _Seq>’\n       { return __x < __y; }\n```\n\n\nHere is an example of what is causing the error:\n\n```\nclass myData {\npublic:\n    int a;\n    int b;\n    int c;\n    int d;\n};\n\nclass myComp {\npublic:\n    bool operator()(myData& d1, myData& d2) {\n        if(d1.a == d2.a) {\n            return d2.b < d2.c;\n        }\n        else {\n            return d1.a < d2.a;\n        }\n    }\n};\n\npriority_queue<myData, vector<myData>, myComp> myPQ;\n\nvector<priority_queue<myData, vector<myData>, myComp> > vec_PQ(n, myPQ);\n```\n\n    ", "Answer": "\r\nFrom : http://en.cppreference.com/w/cpp/concept/Compare\n\nThe concept Compare is a set of requirements expected by some of the standard library facilities from the user-provided function object types.\nThe return value of the function call operation applied to an object of type Compare, when contextually converted to ```\nbool```\n, yields ```\ntrue```\n if the first argument of the call appears before the second in the strict weak ordering relation induced by this Compare type, and ```\nfalse```\n otherwise.\nAs with any BinaryPredicate, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators.\n\nThe arguments to ```\nmyComp::operator()```\n should be ```\nconst&```\n.\n```\nbool myComp::operator()(myData const& d1, myData const& d2) {\n```\n\nAs indicated by @T.C. in a comment, the function itself should be a const member function but that is strictly not necessary in this case.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement Java's Comparable module in Ruby\r\n                \r\nI'm currently going over Robert Sedgewick's Algorithms book. In the book for the implementation of a Priority Queue there is the use of the Comparable module. While going over the top k frequent elements leetcode problem I noticed that there would be an error in my Ruby implementation.\n```\ndef top_k_frequent(nums, k)\n  ans = []\n  h = Hash.new(0)\n\n  nums.each do |num|\n    h[num] += 1\n  end\n\n  heap = Heap.new\n  h.each do |k,v|\n    heap.insert({k => v})\n  end\n\n  k.times do\n    a = heap.del_max\n    ans.push(a.keys[0])\n  end\n\n  ans\nend\n\n\nclass Heap\n  def initialize\n    @n = 0\n    @pq = []\n  end\n\n  def insert(v)\n    @pq[@n += 1] = v\n    swim(@n)\n  end\n\n  def swim(k)\n    while k > 1 && less((k / 2).floor, k)\n      swap((k / 2).floor, k)\n      k = k/2\n    end\n  end\n\n  def swap(i, j)\n    temp = @pq[i]\n    @pq[i] = @pq[j]\n    @pq[j] = temp\n  end\n\n  def less(i, j)\n    @pq[i].values[0] < @pq[j].values[0]\n  end\n\n  def del_max\n    max = @pq[1]\n    swap(1, @n)\n    @n -= 1\n    @pq[@n + 1] = nil\n    sink(1)\n    max\n  end\n\n  def sink(k)\n    while 2 * k <= @n\n      j = 2 * k\n\n      if !@pq[j + 1].nil?\n        j += 1 if j > 1 && @pq[j].values[0] < @pq[j + 1].values[0]\n      end\n      break if !less(k, j)\n\n      swap(k, j)\n      k = j\n    end\n  end\nend\n```\n\nAbove is the Java Priority Queue implementation.\n    ", "Answer": "\r\nRuby's comparable operator is ```\n<=>```\n which will return one of ```\n-1```\n, ```\n0```\n, ```\n1```\n and ```\nnil```\n (```\nnil```\n mean could not compare).\nIn order to compare two objects , both need to implement a method ```\ndef <=>(other)```\n. This is not on ```\nObject```\n, so is not available on any objects that don't implement it or extend from a class that does implement it. Numbers and Strings, for example, do have an implementation. Hashes do not.\nI think in your case, the issue is slightly different.\nWhen you call ```\nqueue.insert(my_hash)```\n what you're expecting is for the algorithm to break up ```\nmy_hash```\n and build from that. Instead, the algorithm takes the hash as a single, atomic object and inserts that.\nIf you add something like:\n```\nclass Tuple\n  attr_accessor :key, :value\n\n  def initialize(key, value)\n    @key = key\n    @value = value\n  end\n\n  def <=>(other)\n    return nil unless other.is_a?(Tuple)\n    value <=> other.value\n  end\nend\n```\n\nthen this will allow you to do something like:\n```\nhsh = { 1 => 3, 2 => 2, 3 => 1}\ntuples = hsh.map { |k, v| Tuple.new(k, v) }\n\ntuples.each { |tuple| my_heap.insert(tuple) }\n```\n\nyou will have all of your data in the heap.\nWhen you retrieve an item, it will be a tuple, so you can just call ```\nitem.key```\n and ```\nitem.value```\n to access the data.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Comparable object with Priority Queue\r\n                \r\nI am trying to use a priority queue (java.util.PriorityQueue) on a custom class. I understand that the PriorityQueue class uses the Comparable interface, so I implemented it in my custom class:\n\n```\npublic class State implements Comparable<State> {\n    public int val;\n\n    public State(){\n        this.val = 0;\n    }\n\n    public int compareTo(State other){\n        return this.val - other.val;\n    }\n}\n```\n\n\nAnd to use the queue, I did:\n\n```\nPriorityQueue<State> q = new PriorityQueue<State>();\nq.add(myState1);\nq.add(myState2);\n// etc.\n```\n\n\nIt compiles correctly, but I get this exception during runtime:\n\n```\nException in thread \"main\" java.lang.ClassCastException: State cannot be cast to\njava.lang.Comparable\n    at java.util.PriorityQueue.siftUpComparable(Unknown Source)\n    at java.util.PriorityQueue.siftUp(Unknown Source)\n    at java.util.PriorityQueue.offer(Unknown Source)\n    at java.util.PriorityQueue.add(Unknown Source)\n    at MapTable.search(MapTable.java:308)\n    at Map.main(Map.java:67)\n```\n\n\nWhat am I doing wrong? As far as I can remember, this is how I would implement comparable. Thanks for all answers.\n    ", "Answer": "\r\namit originally suggested in his comment a very wise piece of advice; essentially, make sure you're not referring to another class named ```\nState```\n which is hiding your own ```\nState```\n from view, e.g. ```\njava.lang.Thread.State```\n and ```\njavax.swing.plaf.nimbus.State```\n. This is often the cause of many bugs, so make sure you remember this.\n\nUnfortunately, it's not the case here. As I pointed out in a comment, the exception would print the qualified name of whatever other ```\nState```\n as a part of the exception message in that case. Since the qualified name was ```\nState```\n, it makes sense that you likely forgot to recompile ```\nState```\n. :-)\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Request Priority Queue in Node.js\r\n                \r\nI have an script that adds products to a remote database using a RESTful API in Node.js. It works well, but I would like to change the priority HTTP requests are processed. Here is some code to better illustrate what I am trying to do:\n\n```\nstep(\n    function initializeCategories() {\n        createCategories(products, this);\n    },\n    function createProducts(err, categoriesHash) {\n        console.log(\"\\nCreating products:\");\n        console.log(\"==================\");\n\n        var group = this.group(),\n            productDoneCallback;\n\n        products.forEach(function (product) {\n            product.categories = categoriesHash[product.category + \"/\" + product.make + \"/\" + product.model];\n            productDoneCallback = group();\n\n            step(\n                function createProduct() {\n                    postProduct(convertToBigCommerceObj(product), this);\n                },\n                function overwriteProduct(err, product, allowOverwrite) {\n                    if (err) {\n                        console.log(err);\n                    }\n\n                    allowOverwrite = allowOverwrite || false;\n\n                    if (allowOverwrite) {\n                        updateProduct(product, this);\n                    } else {\n                        this(err, product);\n                    }\n                },\n                function addExtraInfo(err, product) {\n                    addImage(product, productDoneCallback);\n                }\n            );\n        });\n    },\n    function printStats(err) {\n        if (err) {\n            logError(err);\n        }\n\n        var endTime = +new Date(),\n            duration = endTime - startTime;\n\n        console.log(\"\\nFinished after \" + (duration / 1000 / 60) + \" minutes\");\n        console.log(productsAdded + \" Products added successfully\");\n        console.log(productsUpdated + \" Products updated successfully\");\n        console.log(productsSkipped + \" Products skipped\");\n        console.log(\"Average time (milliseconds) per product was : \" + (duration / totalNumProducts ));\n        console.log(\"For more information see error log (error.log)\" );\n    }\n);\n```\n\n\nIn this code the product images are always added last after all products have been added. This is because the forEach loop puts all of the postProduct requests on the node event queue right away. After the first product is done has been posted to the server another entry is added to the end of the queue to add that product's image. Instead, I would like that new entry to float to the top of the queue and be the next entry to be processed (not another product post, that can wait).\n\nI realize that to do that I need a priority queue. I am just not sure how I can achieve this in Node and Javascript.\n\nUpdate: after finding an implementation of a PriorityQueue at https://github.com/STRd6/PriorityQueue.js, the real trouble is processing the queue asynchronously every time a request completes. Or more like everytime there is an available http channel that has been freed we need to take the highest priority item.\n    ", "Answer": "\r\nWhenever you heard \"priority queue\", you should think about having a heap data structure.  They are not the only way to do that, but they are simple to implement and so are a good first goto.\n\nSee http://eloquentjavascript.net/appendix2.html for a random implementation.  They assume that when you create the heap, you pass in a function that takes an element and returns its priority.  In your case you could store elements like ```\n[priority, object]```\n and initialize your heap wth a function like ```\nfunction (x) {return x[0]}```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Redis - performance of using priority set as priority queue with limited range in priorities\r\n                \r\nI am writing an application using redis where I need a sort of priority queue- items are assigned a priority between 1 and 10 and then one of the highest priority items is popped (order does not matter). From my understanding, the priority set's ```\nZADD```\n and ```\nBZPOPMAX```\n seem perfect for this use case.\nHowever, I noticed in the Redis docs that both operations have an O(LOG(N)) whereas equivalent operations for lists and sets are O(1).\nThis leads me to a couple performance-related questions:\n\nEven though I know my queue will have a very small range of priorities (1-10), will the practical big O of the redis priority set implementations still be O(LOG(N))?\nIs it likely to be worth pursuing an alternative implementation (perhaps one that uses a couple calls to lists and sets instead)? My queue may have hundreds of thousands or even millions of items in it.\n\n    ", "Answer": "\r\n\nEven though I know my queue will have a very small range of priorities (1-10), will the practical big O of the redis priority set implementations still be O(LOG(N))?\n\nThe time complexity of Redis sorted set has nothing to do with the range of scores (in your case, the priorities). Instead, it's related to the number of items in the sorted set. So the practical big O is still ```\nO(LOG(N))```\n.\n\nIs it likely to be worth pursuing an alternative implementation (perhaps one that uses a couple calls to lists and sets instead)?\n\nYou cannot achieve the goal with Redis List and Redis Set. Because Redis set is unordered, and searching list and accessing items in list (except the head and tail of the list) are O(N).\n```\nO(LOG(N))```\n is not slow. Even if you have 1 million items, a call to ```\nZPOPMAX```\n only needs about 20 comparisons to get the result, which is quite fast.\nTry the simple solution and do a benchmark before choosing a more complex algorithm.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is Heap Sorting and Priority Queue? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                    \r\n                        \r\n                    \r\n                \r\n                    \r\n                            \r\n                                As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,  or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question  can be improved and possibly reopened, visit the help center for guidance.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 11 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nFor my C++ Data Structure class, we are implementing a dial-up modem simulator. Our professor gave us a working source file that uses the STL priority queue, but our job is to replace that by implementing a binary heap. I went in to go see her for help today with what exactly binary heap is, but she basically told me and my friend to transfer to IT :(. She just started talking about it on Monday, both priority-queues and binary heap, which she rushed through in an hour, she started talking about a new subject today because her slides aren't done so she's going to resume with binary heap on Friday which is when the program is due. \n\nI understand this much, binary heap is the back-end of priority queue. But do I sort when the elements are being inserted or being popped? And she mentioned using a vector or a list, where does that come in play when you're just building a tree? Also I don't understand why this code works on her's:\n\n```\ntypedef priority_queue<Event,vector<Event>,greater<Event> > PQ;\n```\n\n\nIs that just how you declare a STL priority queue? The program is hard to describe so I will paste it at the bottom. It's only one source file. \n\nNote: Random.h just has functions that return random numbers according to some stats distribution. \n\nmodemSimu.cpp:\n\n```\n#include <queue>\n#include <vector>\n#include <functional>  // for greater()\n#include <climits>     // for INT_MAX\n#include <iostream>\n#include \"random.h\"\nusing namespace std;\n\nclass Event{\n    enum { DIAL_IN = 1, HANGUP = 2 };\n  public:\n    Event( int name = 0, int tm = 0, int type = DIAL_IN )\n         : time( tm ), who( name ), what( type ) { }\n    bool operator> ( const Event & rhs ) const\n      { return time > rhs.time; }\n    friend class ModemSim;\n  private:\n    int who;        // the number of the user\n    int time;       // when the event will occur\n    int what;       // DIAL_IN or HANGUP\n};\n\ntypedef priority_queue<Event,vector<Event>,greater<Event> > PQ; \n\nclass ModemSim{\n  public:\n    ModemSim( int modems, double avgLen, int callIntrvl );\n      // Add a call to eventSet at the current time,\n      // and schedule one for delta in the future.\n    void nextCall( int delta );\n\n      // Run the simulation\n    void runSim( int stoppingTime = INT_MAX );\n\n  private:\n    Random r;                       // A random source\n    PQ eventSet;                    // Pending events\n\n      // Basic parameters of the simulation\n    int freeModems;                 // Number of modems unused\n    const double avgCallLen;        // Length of a call\n    const int freqOfCalls;          // Interval between calls\n};\n\n// Constructor for ModemSim.\nModemSim::ModemSim( int modems, double avgLen, int callIntrvl )\n  : freeModems( modems ), avgCallLen( avgLen ),\n    freqOfCalls( callIntrvl ), r( (int) time( 0 ) )\n{\n    nextCall( freqOfCalls );  // Schedule first call\n}\n\n// Place a new DIAL_IN event into the event queue.\n// Then advance the time when next DIAL_IN event will occur.\n// In practice, we would use a random number to set the time.\n    void ModemSim::nextCall( int delta ){\n    static int nextCallTime = 0;\n    static int userNum = 0;\n\n    eventSet.push( Event( userNum++, nextCallTime ) );\n    nextCallTime += delta;\n}\n\n// Run the simulation until stopping time occurs.\nvoid ModemSim::runSim( int stoppingTime ){\n    static Event e;\n    int howLong;\n\n    while( !eventSet.empty( ) ){\n        e = eventSet.top( );\n        eventSet.pop( );\n        if( e.time > stoppingTime )\n            break;\n\n        if( e.what == Event::HANGUP )    // HANGUP\n        {\n            freeModems++;\n            cout << \"User \" << e.who << \" hangs up at time \"\n                 << e.time << endl;\n        }\n        else                             // DIAL_IN\n        {\n            cout << \"User \" << e.who << \" dials in at time \"\n                 << e.time << \" \";\n            if( freeModems > 0 )\n            {\n                freeModems--;\n                howLong = r.negExp( avgCallLen );\n                cout << \"and connects for \"\n                     << howLong << \" minutes\" << endl;\n                e.time += howLong;\n                e.what = Event::HANGUP;\n                eventSet.push( e );      // insert HANGUP\n            }\n            else\n                cout << \"but gets busy signal\" << endl;\n            nextCall( freqOfCalls );\n        }\n    }\n}\n\n\n// Simple main to test ModemSim class.\nint main( )\n{\n    int numModems;\n    int totalTime;\n    double avgConnectTime;\n    int dialInFrequency;\n\n    cout << \"Enter number of modems, length of simulation,\\n\"\n         << \" average connect time, how often calls occur: \";\n\n    cin >> numModems >> totalTime >>\n                    avgConnectTime >> dialInFrequency;\n\n    ModemSim s( numModems, avgConnectTime, dialInFrequency );\n    s.runSim( totalTime );\n\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nDo you not have a text?  If not, I suggest you look up heap sort in virtually any data structures text, e.g. Aho, Hopcroft and Ullman.  Heaps are a sort of binary tree that is normally stored in an array (vector) where the left half of the tree is in the bottom half of the array and the right half in the top half of the array (recursively).  You only need the index into the array to determine the location in the tree (and vice versa).  A heap is not actually maintained sorted; the element at the front is always the min (or it could be max); and there is an operation normally called re-heapify that takes log n time to restore the heap property after an element is added or removed.  Removal is only from the front.  That should give you an idea of how heaps and priority queues and vectors are related.  The algorithm for re-heapify should be in your text.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "prority queue comparison and update\r\n                \r\nA possible solution is to mark the entry as removed and add a new entry with the revised priority. The documentation provides an example implementation: \n\nI am reading about priority queues in python 3 documentation at following link\n\nhttps://docs.python.org/3/library/heapq.html\n\nHere in implementation details\n\nPriority Queue Implementation Notes\n\nA priority queue is common use for a heap, and it presents several implementation challenges:\n\n\n  •Sort stability: how do you get two tasks with equal priorities to be\n  returned in the order they were originally added? •Tuple comparison\n  breaks for (priority, task) pairs if the priorities are equal and the\n  tasks do not have a default comparison order. •If the priority of a\n  task changes, how do you move it to a new position in the heap? •Or if\n  a pending task needs to be deleted, how do you find it and remove it\n  from the queue?\n\n\nI am not able to understand below. Particularly \"what does if tasks do not have a default comparison order\" Request to elaborate with example\n\n•Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order\n\nThanks for your time and help\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Use celery priority queue with broadcast tasks\r\n                \r\nI want to implement task priority in my celery workers. I can do this by creating different queues for high priority tasks and low priority tasks. But also I need to send broadcast tasks to all workers with a broadcast queue and its not working. Here is tasks.py file:\n\n```\nfrom celery import Celery\nfrom kombu.common import Broadcast, Queue, Exchange\n\napp = Celery('tasks')\n\napp.conf.update(\n    CELERY_RESULT_BACKEND='amqp',\n    CELERY_ACCEPT_CONTENT=['json'],\n    CELERY_TASK_SERIALIZER='json',\n    CELERY_RESULT_SERIALIZER='json',\n    BROKER_URL='amqp://',\n    CELERY_QUEUES=(Queue('default',\n                         Exchange('default'),\n                         routing_key='default'),\n                   Queue('low_priority',\n                         Exchange('low_priority'),\n                         routing_key='low_priority'),\n                   Broadcast('broadcast_tasks'), ),\n    CELERY_ROUTES={'tasks.broadcast':\n                   {'queue': 'broadcast_tasks'},\n                   'tasks.low_task':\n                   {'queue': 'low_priority'},\n                   },\n    CELERY_DEFAULT_QUEUE = 'default',\n    CELERY_DEFAULT_EXCHANGE = 'default',\n    CELERY_DEFAULT_ROUTING_KEY = 'default'\n)\n\n@app.task\ndef broadcast():\n    print \"Broadcast called\"\n\n@app.task\ndef low_task():\n    print \"Low priority called\"\n\n@app.task\ndef def_task():\n    print \"Default called\"\n```\n\n\nWhen I run celery workers with this command:\n\n```\ncelery -A tasks -Q default worker --loglevel=info\ncelery -A tasks -Q default,low_priority worker --loglevel=info\n```\n\n\nTask priority works but broadcast tasks are not acknowledged.\n\nWhen I run the same command without a queue argument, broadcast works but task priority does not:\n\n```\ncelery -A tasks worker --loglevel=info\ncelery -A tasks worker --loglevel=info\n```\n\n\nAs I understand, it happens because broadcast queues have unique names, like ```\nbcast.0b5dbce0-9bcb-48a5-8554-cbb7f32a6703```\n for each worker.\n\nDoes anyone have a good workaround? Thanks in advance!\n    ", "Answer": "\r\nYou must explicitly consume a broadcast queue, so modify your commandline invocation as the comment above per ANDY_VAR.\n\nA similar question was asked here:\n\n\nstart celery worker and enable it for broadcast queue\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Safe way of removing elements in priority queue while ranging\r\n                \r\nI took the full implementation of priority queue from go documentation.\nI want to remove elements if they satisfy some condition. So I should:\n\niterate over queue then\ncheck the condition\nif condition is OK, remove element\n\nLike this:\n```\nfor i, value := range pq{\n  if someCondtion{\n    heap.Remove(&pq, i)\n  }\n```\n\n}\nOr for simplicity:\n```\nfor i, value := range pq{\n    heap.Remove(&pq, i)\n}\n```\n\nBut it is not the safe way because there is an error:\n```\npanic: runtime error: index out of range\ngoroutine 1 [running]:\nmain.PriorityQueue.Swap(...)\nmain.(*PriorityQueue).Swap(0xc420088020, 0x2, 0x0)\ncontainer/heap.Remove(0x4c69a0, 0xc420088020, 0x2, 0xf, 0x0)\n```\n\nHow can I properly do it?\nHere is an example https://play.golang.org/p/XrQdAJIbZPw\n    ", "Answer": "\r\nAfter every call to ```\nheap.Remove```\n the heap is reorganized. So the initial length of ```\npq```\n gets smaller in every loop. You will reach the point when it is smaller than the current value of ```\ni```\n requires it to be.\n\nIf you manipulate ```\npq```\n you must loop as it is done in the example:\n\n```\nfor pq.Len() > 0 {\n    item := heap.Pop(&pq).(*Item)\n    fmt.Printf(\"%.2d:%s\\n\", item.priority, item.value)\n}\n```\n\n\nsee https://play.golang.org/p/Ayt4_zLo8FF\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Algorithm for Broken Priority Queue\r\n                \r\nIF a priority queue has two operations: ```\ninsert```\n and ```\nbroken_min```\n.\nWhere ```\nbroken_min```\n returns either the first or second minimum item.\n\nThese cannot both be implemented in o(logn) time.\nI think this is because insert uses broken_min and would then have to do more checks to see if it has the maximum or not.\n\nIs this correct reasoning?\n    ", "Answer": "\r\nYes, I believe you're correct.\n\nA priority-queue is typically implemented as a heap:\n\n\n  A heap is a specialized [binary-]tree-based data structure ... the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node (min heap).\n\n\n```\nbroken_min```\n can be implemented in O(1) since one of the children will be the second largest element, so we can just check both.\n\nBut ```\ninsert```\n will take Ω(log n), which isn't o(log n) (but would indeed be O(log n)).\n\nI doubt you'll find a priority-queue implementation that could satisfy the given running times, but saying it's impossible would be irresponsible.\n\nNote: I assume you meant little-o (a strict upper bound, as opposed to big-O, which is a greater-or-equal upper bound) given the tag, although big-O is used most of them time, and little-o is almost never used (as far as I've seen).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to maintain the precedence of an object inside a priority queue once it is being taken out to update its priority?\r\n                \r\nI am wondering if there is anyway to maintain the precedence of an object inside a priority queue once it is being removed and reinserted into the queue to update its priority?\n\nThe way I do this is that I remove the object from the priority queue and put the updated object into the queue again. However, this will disrupt the natural ordering I had implemented using ```\nComparator```\n\n\nThe ```\nComparator```\n:\n\n```\nclass PriorityValueComparator implements Comparator<Human>{\n    public int compare(Human x, Human y){\n        return y._priority - x._priority;\n    }\n}\n```\n\n\nFor example,\n\n\n  insert in the following order: John, Alex, Kerby, Jane\n  The priority queue is in the following form: [Jane, 100], [Kerby, 59], [Alex, 33], [John, 13] \n  Update John to 100\n  [John, 100] (since John is inserted before Jane),  [Jane, 100], [Kerby, 59], [Alex, 33]\n\n\nUPDATE:\nAlternatively, in the Human Class, a static attribute ```\ntime```\n can be added. Inside the constructor of Human,\n\n```\npublic Human() {\n    //add in whatever you want here\n    time++; //This will ensure that every elements will have their own unique order number\n}\n```\n\n    ", "Answer": "\r\nThe priority queue implementation is allowed to choose arbitrarily between elements with the same priority. If you want to force a particular order, then you need to change the comparator. Assuming that you maintain a field ```\n_insertion_time```\n such that humans inserted earlier have lesser, nonnegative values, then you can rewrite the comparator to\n\n```\nclass PriorityValueComparator implements Comparator<Human>{\n    public int compare(Human x, Human y){\n        if (y._priority != x._priority) return y._priority - x._priority;\n        else return y._insertion_time - x._insertion_time;\n    }\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Input the text file to Priority Queue using heap\r\n                \r\nI am trying to implement priority queue using heap  in c++.The code given below is working fine.But i want to generate a file containing priority  (integer)and value(char or string)associated to it. Now  use this file as input it to the code below to generate a sequence of values in increasing order of priorities.\n\n```\n#include<queue>\n#include <utility>\n\nint main() \n{\n\n    std::priority_queue<std::pair<int, std::string> > pq;\n    pq.push(std::make_pair(3, \"Clear drains\"));\n    pq.push(std::make_pair(4, \"Feed cat\"));\n    pq.push(std::make_pair(5, \"Make tea\"));\n    pq.push(std::make_pair(1, \"Solve RC tasks\"));\n    pq.push(std::make_pair(2, \"Tax return\"));\n    while (!pq.empty())\n    {\n        std::cout << pq.top().first << \", \" << pq.top().second << std::endl;\n        pq.pop();\n    }\n    return 0;\n\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to implement priority queue using Sorted Linked List?\r\n                \r\ni want to implement this in c#, i have my linked list class ready, but problem occurs when i sort the class using this Sort method. How can I give priority to elements, so that the highest priority element dequeue first.\n\n```\n        public void Sort()\n   {\n       ListNode current=first;\n       int temp;\n\n       for (int i = 0; i < counter; i++)\n       {\n           while (current.Next != null)\n           {\n\n               if (current.Data > current.Next.Data)\n               {\n                   temp = current.Data;\n                   current.Data = current.Next.Data;\n                   current.Next.Data = current.Data;\n               }\n               current = current.Next;\n           }\n       }\n   }\n```\n\n    ", "Answer": "\r\nTo analyze your code a little: \n\nThis looks like 1 stroke of a bubble-sort, so don't expect it to sort everything.  \n\nIt will only ensure that the largest value becomes the last element. And only after you fix the swap part:\n\n```\nif (current.Data > current.Next.Data)\n{\n  temp = current.Data;\n  current.Data = current.Next.Data;\n  current.Next.Data = temp;\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to get the minimum element from a priority queue after modifying the contents of queue [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Updating Java PriorityQueue when its elements change priority\r\n                            \r\n                                (8 answers)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI was trying to implement Dijkstra's algorithm using a ```\npriority queue```\n in Java..\nUnfortunately it was returning wrong results...I have tracked down the problem.\nHere's the Problem..After inserting the node weights into the queue,I am modifying those node weight,but when i try to remove the element from the priority queue ,its returning the historical minimum (minimum at the time of insertion).```\nremove()```\n doesn't know that the priority queue has been modified..Any help would be greatly appreciated ...Thanks!\n\nNote:i can add the source code if required\n    ", "Answer": "\r\nThis SO question should help you. The drawback with the PriorityQueue in Java is that the if an inserted element value changes, the priority queue is not re-constructed to reflect the new order. Thus you would have to remove and re-insert the changing elements to satisfy your use case.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why does this priority queue implementation only print one value repeatedly?\r\n                \r\nThis program should print out the values in order ascending order. But it only displays 957.0 repeatedly. How do I display the numbers in order?\n\n```\nimport java.io.*;\nimport java.util.*;\n\n\nclass PriorityQ {\n    public int maxSize;\n    public double[] queArray;\n    public int nItems;\n    //------\n    public PriorityQ(int s){\n        maxSize = s;\n        queArray = new double[maxSize];\n        nItems = 0;\n    }\n    //-----\n    public void insert(double item){\n        int j;\n\n        if(nItems == 0){\n            queArray[nItems++] = item;\n        }\n        else{\n            for(j = nItems-1; j >= 0; j--){\n                if(item > queArray[j]){\n                    queArray[j + 1] = item;\n                }\n                else{\n                    break;\n                }\n            }\n        queArray[j + 1] = item;\n        nItems++;\n        }\n    }\n\n    //-----\n    public double remove(){\n        return queArray[--nItems];\n    }\n    //-----\n    public double peekMin(){\n        return queArray[nItems - 1];\n    }\n    //-----\n    public boolean isEmpty(){\n        return(nItems == 0);\n    }\n    //-----\n    public boolean isFull(){\n        return(nItems == maxSize);\n    }\n}\n    //-----\n\n\n    public class PriorityQApp{\n        public static void main(String[] args) throws IOException{\n            PriorityQ thePQ = new PriorityQ(5);\n            thePQ.insert(546);\n            thePQ.insert(687);\n            thePQ.insert(36);\n            thePQ.insert(98);\n            thePQ.insert(957);\n\n            while(!thePQ.isEmpty()){\n                double item = thePQ.remove();\n                System.out.print(item + \" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n```\n\n    ", "Answer": "\r\nYou should save yourself the effort and use a priority queue with the generic type ```\nDouble```\n. If you wanted descending order you could even use a comparator that orders the highest value before the lowest, but you asked for ascending. \n\nYour problem is that your array does contain many copies of 957.\nThis is because of this line in your code:\n\n```\nif(item > queArray[j]){\n    queArray[j + 1] = item;\n}\n```\n\n\nTry:\n\n```\nimport java.io.*;\nimport java.util.*;\n\npublic class PriorityQApp{\n    public static void main(String[] args) throws IOException{\n        PriorityQueue<Double> thePQ = new PriorityQueue<Double>(5);\n        thePQ.add(546);\n        thePQ.add(687);\n        thePQ.add(36);\n        thePQ.add(98);\n        thePQ.add(957);\n\n        while(thePQ.size() > 0){\n            double item = thePQ.poll();\n            System.out.print(item + \" \");\n        }\n        System.out.println(\"\");\n    }\n}\n```\n\n\nOr I can fix your code to print out the queue in descending order leaving it to you to then make it print out in ascending order, the block I pointed to before should read like this instead:\n\n```\nif(item < queArray[j]){\n    queArray[j + 1] = queArray[j];\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ while using priority queue Debug assertion failed, Expression: invalid heap\r\n                \r\nEnvironment:\n- Win7 pro x64\n- VS2010\n- C++\n- Empty Project  \n\nGoal:\n Implementation of Dijkstra's shortest path algo using a priority queue.\n\nProblem:\n When the program runs it gets a Debug assertion failed, Expression: invalid heap error.  If the user inputs the source vertex as 1, everything works fine.  The assertion only occurs when the source vertex is other than 1.  Also, if the assertions are ignored, the code finishes eventually and outputs the proper paths through the graph.  I am guessing the error has something to do with altering the data that pointers in the priority queue point to, but if this is the case, I don't understand why using 1 as the source allows the code to complete successfully.\n\nThanks for any and all help!\n\nheader:\n\n```\n#ifndef _GRAPH_H_\n#define _GRAPH_H_\n#include <map>\n#include <queue>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\nclass Graph\n{\n\npublic:\n\n    struct Vertex\n    {\n        int name; // V number\n        double dv; // distance\n        Vertex* pv; // previous V* from this V\n        map<Vertex*, double> neighbors; // map of all neighbors/distances connected to vert\n    };\n\n    vector<Vertex*> verts; // vector of all V*\n\n    void dijkstra(ifstream& stream, int start_vert); // create graph & find shortest paths\n    void printPath(Vertex* v); // echo path\n\n    class CompareVert // overloaded compare operator for priorty queue data struct, sort queue so V with smallest dist on top\n    {\n    public:\n        bool operator()(const Vertex* v1, const Vertex* v2) const\n        {\n            return v1->dv > v2->dv;\n        }\n    };\n};\n\n#endif\n```\n\n\nimplementation: \n\n```\n#include \"Graph.h\"\n#include <iostream>\n#include <queue>\n#include <limits> // used for numeric_limits<double>::infinity()\n#include <vector>\n\nusing namespace std;\n\nint path_length = 0;\n\nvoid Graph::printPath(Vertex* v) // print shortest paths\n{\n    if (v->pv != NULL)\n    {\n        printPath(v->pv);\n        cout << \" -> \";\n    }\n    cout << v->name;\n}\n\nvoid Graph::dijkstra(ifstream& stream, int start_vert) // create graph & get shortest path\n{\n    /////////////////////////////////////////////\n    /////////////// create graph ////////////////\n    /////////////////////////////////////////////\n\n    int total_edges;\n    priority_queue<Vertex*, vector<Vertex*>, CompareVert> q;\n    double infinity = numeric_limits<double>::infinity();\n    int source;\n    int dest;\n    double dist;\n    stream >> total_edges;\n    for (int i=0;i<total_edges;i++)\n    {\n        stream >> source;\n        stream >> dest;\n        stream >> dist;\n        bool source_exists = false;\n        bool dest_exists = false;\n        Vertex* _source;\n        Vertex* _dest;\n\n        for (int i=0;i<verts.size();i++)\n        {\n            if (verts.at(i)->name == source) // vertex already exists, set to V\n            {\n                _source = verts.at(i);\n                source_exists = true;\n                break;\n            }\n        }\n\n        for (int i=0;i<verts.size();i++)\n        {\n            if (verts.at(i)->name == dest) // vertex already exists, set to V\n            {\n                _dest = verts.at(i);\n                dest_exists = true;\n                break;\n            }\n        }\n\n        if (!source_exists) // create vert\n        {\n            _source = new Vertex;\n            _source->name = source;\n            _source->dv = infinity;\n            _source->pv = NULL;\n            verts.push_back(_source);\n        }\n\n        if (!dest_exists) // create vert\n        {\n            _dest = new Vertex;\n            _dest->name = dest;\n            _dest->dv = infinity;\n            _dest->pv = NULL;\n            verts.push_back(_dest);\n        }\n        _source->neighbors.insert(pair<Vertex*, double>(_dest, dist)); // populate V's adjacency map\n    }\n\n    for (int i=0;i<verts.size();i++)\n    {\n        if (verts.at(i)->name == start_vert) // set source\n        {\n            verts.at(i)->dv = 0;\n        }       \n        q.push(verts.at(i)); // push all vertices to priority queue\n    }\n\n    /////////////////////////////////////////////\n    ////////////////  find paths  ///////////////\n    /////////////////////////////////////////////\n\n    vector<int> displayed;\n    bool print; // flag to call printPath\n    while (!q.empty())\n    {\n        map<Vertex*, double>::iterator it;\n        Vertex* temp = q.top(); // get V with smallest dist\n        print = true;\n        for (it = temp->neighbors.begin(); it!=temp->neighbors.end();++it)\n        {\n            if ((temp->dv + it->second) < it->first->dv)\n            {\n                print = false;\n                it->first->dv = (temp->dv + it->second);\n                it->first->pv = temp;\n                q.push(it->first);\n            }\n        }\n\n        for (int i=0;i<displayed.size();i++) // if end V of path has already been printed, do not print\n        {\n            if (displayed.at(i) == temp->name)\n                print = false;\n        }\n\n        if (print == true)\n        {\n            printPath(temp);\n            path_length = temp->dv;\n            cout << \" total distance = \" << path_length <<endl << endl;\n            displayed.push_back(temp->name);\n        }\n\n        path_length = 0;\n        q.pop();\n    }\n}\n```\n\n\ndriver:\n\n```\n#include \"Graph.h\"\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <list>\n\nusing namespace std;\n\nstring fname;\nint vname;\nstring line;\n\nint main(void)\n{\n    cout << \"Please enter the file to read in a graph (graph.txt): \";\n    cin >> fname;\n    cout << \"Please choose a starting vertex (1 is a good choice): \";\n    cin >> vname;\n    cout << endl;\n\n    ifstream my_stream (fname);\n    Graph my_graph;\n    my_graph.dijkstra(my_stream, vname);\n    my_stream.close();\n}\n```\n\n\ngraph.txt:\n\n```\n12\n1 2 2\n1 4 1\n2 4 3\n2 5 10\n3 1 4\n3 6 5\n4 3 2\n4 5 2\n4 6 8\n4 7 4\n5 7 6\n7 6 1\n```\n\n    ", "Answer": "\r\nYou should pop the top element from the priority_queue right after your call to q.top(). Instead you do q.pop() after pushing a new element into the queue with ```\nq.push(it->first);```\n \n\nThat seems to me to be not what you want because you could now potentially be popping an element different from what you thought was the top element. \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java: how to priority queue HashSet in order of SIZE (smallest first)?\r\n                \r\nI am trying to implement a priority queue that will order HashSets in order of their size (i.e. smallest HashSets will have the highest priority).\n\nHow may I implement this in Java?\n\nBelow is my attempt that successfully orders HashSets by their priority number (highest first).\n\nMy main method:\n\n```\n        System.out.print(\"Enter size of priority queue: \");\n        int inputSize = scanner.nextInt();\n\n        HashSetQueue pq = new HashSetQueue(inputSize);\n\n        System.out.println(\"1. insert\");\n        System.out.println(\"2. remove\");\n        System.out.println(\"3. check empty\");\n        System.out.println(\"4. check full\");\n        System.out.println(\"5. empty\");\n        System.out.println(\"6. check size\");\n        System.out.println(\"7. print\");\n        System.out.print(\"Please enter a number: \");\n\n        int choice = scanner.nextInt();\n        switch (choice) {\n        case 1:\n          System.out.print(\"Please enter a value: \");\n          int userInput = scanner.nextInt();\n\n          HashSet<Integer> set = new HashSet<Integer>();\n          set.add(userInput);\n\n          System.out.println(\"Please enter a priority: \");\n          int priority = scanner.nextInt();\n\n          pq.insert(priority, set);\n          break;\n        case 2:\n          System.out.println(\"\\nJob removed \\n\\n\" + pq.remove());\n          break;\n        case 3:\n          System.out.println(\"\\nEmpty Status: \" + pq.isEmpty());\n          break;\n        case 4:\n          System.out.println(\"\\nFull Status: \" + pq.isFull());\n          break;\n        case 5:\n          System.out.println(\"\\nPriority Queue Cleared!\");\n          pq.clear();\n          break;\n        case 6:\n          System.out.println(\"\\nSize = \" + pq.size());\n          break;\n        case 7:\n          pq.print();\n          break;\n        default:\n          System.out.println(\"\\nPlease enter a valid number on the list!\");\n          break;\n```\n\n\nMy PriorityQueue class\n\n```\nimport java.util.HashSet;\n\n/** class Task **/\nclass Task {\n  int priority;\n  HashSet<Integer> job;\n\n  /** Constructor **/\n  public Task(int priority, HashSet<Integer> job) {\n    this.job = job;\n    this.priority = priority;\n  }\n\n  /** toString() **/\n  public String toString() {\n    return \"\\nPriority : \" + priority + \"\\nJob Name : \" + job;\n  }\n}\n\n/** Class PriorityQueue **/\nclass HashSetQueue {\n  private Task[] heap;\n  private int heapSize, capacity;\n\n  /** Constructor **/\n  public HashSetQueue(int capacity) {\n    this.capacity = capacity++;\n    heap = new Task[this.capacity];\n    heapSize = 0;\n  }\n\n  /** function to clear **/\n  public void clear() {\n    heap = new Task[capacity];\n    heapSize = 0;\n  }\n\n  /** function to check if empty **/\n  public boolean isEmpty() {\n    return heapSize == 0;\n  }\n\n  /** function to check if full **/\n  public boolean isFull() {\n    return heapSize == capacity - 1;\n  }\n\n  /** function to get Size **/\n  public int size() {\n    return heapSize;\n  }\n\n  public void print() {\n    Task item;\n\n    for (int i = 1; i <= heapSize; i++) {\n      item = heap[i];\n      System.out.println(item);\n    }\n  }\n\n  /** function to insert task **/\n  public void insert(int priority, HashSet<Integer> job) {\n    Task newJob = new Task(priority, job);\n\n    heap[++heapSize] = newJob;\n    int pos = heapSize;\n    while (pos != 1 && newJob.priority > heap[pos / 2].priority) {\n      heap[pos] = heap[pos / 2];\n      pos /= 2;\n    }\n    heap[pos] = newJob;\n  }\n\n  /** function to remove task **/\n  public Task remove() {\n    int parent, child;\n    Task item, temp;\n    if (isEmpty()) {\n      System.out.println(\"Heap is empty\");\n      return null;\n    }\n\n    item = heap[1];\n    temp = heap[heapSize--];\n\n    parent = 1;\n    child = 2;\n    while (child <= heapSize) {\n      if (child < heapSize && heap[child].priority < heap[child + 1].priority)\n        child++;\n      if (temp.priority >= heap[child].priority)\n        break;\n\n      heap[parent] = heap[child];\n      parent = child;\n      child *= 2;\n    }\n    heap[parent] = temp;\n\n    return item;\n  }\n}\n```\n\n    ", "Answer": "\r\nI think you need to change this line:\n\n```\nwhile (pos != 1 && newJob.priority > heap[pos / 2].priority) {\n```\n\n\nto:\n\n```\nwhile (pos != 1 && newJob.job.size() < heap[pos / 2].job.size()) {\n```\n\n\nthis will insert the new task before another tasks with more jobs.\n\nOn the other hand if it's not for education purpose, then don't try to reinvent the wheel and just use a ```\nPriorityQueue```\n with your ```\nComparator```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue Insertion sort\r\n                \r\nI'm supposed to implement an insertion sort method using linked lists in a priority queue. My problem is when it comes to sorting the last few elements it compares them but puts them in the wrong order. Here is my code.\n\nPQInsertionSort class\n\n```\n class PQInsertionSort\n{\n Entry head;\nint size;\npublic PQInsertionSort()\n{\n head = null;\n  size = 0;\n}\n\npublic void insert(Entry elem) \n{\n\nif (size == 0)\n{\n    System.out.println(\"1\");\n\n head = elem;\n}\n\nelse if(head.getKey() > elem.getKey())\n{ \n    System.out.println(\"2\");\n\n    elem.setNext(head);\n    head = elem;\n}\nelse\n{\n     Entry curr;\n     Entry prev;\n      curr = head;\n      prev = head;\n\n    System.out.println(\"3\");\n\n    while(curr.getNext() != null && curr.getKey() < elem.getKey())\n    {\n        prev = curr;\n        curr=curr.getNext();\n        System.out.println(\"curr is \"+ curr.getKey() + \" elem is \" +elem.getKey());\n\n    } \n\nif(curr.getNext() != null)\n{\n     System.out.println(\"6\");\n    elem.setNext(prev.getNext());\n    prev.setNext(elem);\n    }\nelse\n    {\n    System.out.println(\"5\");\n    curr.setNext(elem);\n    }\n\n    }\n  size++;\n}\n\npublic Entry removeMin()\n{\n Entry tmp = null;\n if (size == 0)\n {\n   System.out.println(\"Queue is empty.\");\n }\n else\n {\n    tmp = head;\n    head = head.getNext();\n    size--;\n }\n if (size == 0)\n {\n  head = null; \n\n  } \n   return tmp;\n  }\npublic String min()\n{\n\n    return head.getName();\n\n}\n\npublic int size()\n{\n  return size(); \n}\n\npublic boolean isEmpty()\n{\nreturn (head == null);\n\n}\n\npublic void print()\n{\n Entry p = head;\n while(p != null)\n {\n     System.out.println(p.getKey() + p.getName());\n\n     p = p.getNext();\n }\n\n}\n\n}\n```\n\n\nEntry Class\n\n```\nclass Entry\n{\n  private int key;\n  private String name;\n  private Entry next;\n\n  public Entry(int k, String n, Entry e)\n  {\n    key = k;\n    name = n;\n\n    next = e;\n\n  }\n\n  public void setNext(Entry e)\n  {\n    next = e;\n  }\n\n  public Entry getNext()\n  {\n    return next;\n  }\n\n  public int getKey()\n  {\n    return key;\n  }\n\n  public void setKey(int k)\n  {\n    key = k;\n  }\n\n  public String getName()\n  {\n    return name;\n  }\n\n  public void setName(String n)\n  {\n    name = n;  \n  }\n}\n```\n\n\nTester Class\n\n```\npublic class Test {\n\n    public static void main(String[] args)\n    {\n        PQInsertionSort qs = new PQInsertionSort();\n\n        qs.insert(new Entry(4, \"Sam\", null));\n        qs.insert(new Entry(3, \"Tim\", null));\n        qs.insert(new Entry(7, \"Amanda\", null));\n        qs.insert(new Entry(1, \"Chris\", null));\n        qs.insert(new Entry(2, \"Jimbo\", null));\n        qs.insert(new Entry(5, \"Melinda\", null));\n        qs.insert(new Entry(6, \"Alice\", null));\n\n        qs.print();\n    }\n\n}\n```\n\n\nThe output is this\n\n```\n1\n2\n3\nprev is 4 elem is 7\n5\n2\n3\nprev is 3 elem is 2\n6\n3\nprev is 2 elem is 5\nprev is 3 elem is 5\nprev is 4 elem is 5\nprev is 7 elem is 5\n5\n3\nprev is 2 elem is 6\nprev is 3 elem is 6\nprev is 4 elem is 6\nprev is 7 elem is 6\n6\n1Chris\n2Jimbo\n3Tim\n4Sam\n6Alice\n7Amanda\n5Melinda\n```\n\n\nSee how 5 is output as the lass elem. Any ideas?\n    ", "Answer": "\r\nI seemed to figure it out. After the while loop I had to add another condition because it was passing straight to the else. so it should be like this.\n\n```\nif(curr.getNext() != null)\n{\n     System.out.println(\"6\");\n    elem.setNext(prev.getNext());\n    prev.setNext(elem);\n\n}\nelse if(curr.getKey() > elem.getKey())\n{\n    elem.setNext(prev.getNext());\n    prev.setNext(elem);\n}\nelse\n    {\n    System.out.println(\"5\");\n\n    curr.setNext(elem);\n    }\n\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Queue, how to implement with priority\r\n                \r\n\"As staff members become available, they select from the pool of waiting requests according to their priority list of topics. All requests arriving at time t are available for allocation at time t. If two staff members are simultaneously available, scheduling preference is given to the one whose most recent job was scheduled earliest. If there is still a tie, scheduling preference is given to the person whose id number appears earlier in the input list of staff people.\"\n\nhow do I implement this? I'm having trouble with implementing the service agents that get priority.\nFor ex:\nIll be defining two agents.\nAgent 1 can do topics math, science.\nAgent 2 can do science, math.\n\ngiven a topic named \"Science\"\nif these two agents are available,\nhow do i pick agent 2? because he prioritizes science topics more than Agent 1.\n...\n\nI had no trouble with the if two agents are available at the same time, it will be given to the agent whose most recent job was scheduled earliest.\nI just sorted the agents through an attribute i gave them.\nAny tips will be helpful.\n    ", "Answer": "\r\nA priority queue is implemented via a heap. It's a datastructure that's worth learning.\n\nCheck it out:\n\nhttp://pages.cs.wisc.edu/~vernon/cs367/notes/11.PRIORITY-Q.html\n\nhttp://algs4.cs.princeton.edu/24pq/\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Stream compaction within cuda kernel for maintaining priority queue\r\n                \r\nI am looking for the optimisation strategy for my cuda program. At each iteration inside the for loop of my kernel, each thread produces a score. I am maintaining a shared priority queue of the scores to maintain top-k of them per block. Please see the pseudo-code below:\n\n```\n__global__ gpuCompute(... arguments)\n{\n    __shared__ myPriorityQueue[k];  //To maintain top k scores ( k < #threads in this block)\n    __shared__ scoresToInsertInQueue[#threadsInBlock];\n    __shared__ counter;\n    for(...)       //About 1-100 million iterations\n    {\n        int score = calculate_score(...);\n        if(score > Minimum element of P. Queue && ...)\n        {\n            ATOMIC Operation : localCounter = counter++;\n            scoresToInsertInQueue[localCounter] = score;\n        }\n        __syncthreads();\n        //Merge scores from scoresToInsertInQueue to myPriorityQueue\n        while(counter>0)\n        {\n            //Parallel insertion of scoresToInsertInQueue[counter] to myPriorityQueue using the participation of k threads in this block\n            counter--;  \n            __syncthreads(); \n        }\n        __syncthreads();\n    }\n}\n```\n\n\nHoping that above code makes sense to you guys. Now, I am looking for a way to remove the atomic operation overhead s.t. each thread saves '1' or '0' depending upon the value should go to priority queue or not. I am wondering if any there is any implementation of stream-compaction within kernel so that I can reduce '1000000000100000000' to '11000000000000000000' buffer (or know the index of '1's) and finally insert the scores corresponding to '1's in the queue.\nNote that '1's would be very sparse in this case.\n    ", "Answer": "\r\nIf the ones are very sparse, the ```\natomic```\n method may be fastest.  However the method I describe here will have more predictable and bounded worst-case performance.\n\nFor a good mix of ones and zeroes in your decision array, it may be faster to use a parallel scan or prefix-sum to build an insertion-point index array out of the decision array:\n\nSuppose I have a thresholding decision that chooses scores > 30 to go into the queue.  My data might look like this:\n\n```\nscores:     30  32  28  77  55  12  19\nscore > 30:  0   1   0   1   1   0   0\ninsert_pt:   0   0   1   1   2   3   3    (an \"exclusive prefix sum\")\n```\n\n\nThen each thread makes a storage choice as follows:\n\n```\nif (score[threadIdx.x] > 30) temp[threadIdx.x] = 1;\nelse temp[threadIdx.x] = 0;\n__syncthreads();\n// perform exclusive scan on temp array into insert_pt array\n__syncthreads();\nif (temp[threadIdx.x] == 1)\n  myPriorityQueue[insert_pt[threadIdx.x]] = score[threadIdx.x];\n```\n\n\nCUB has a fast parallel prefix scan.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Explanation of this insert into priority Queue Method\r\n                \r\nWill someone please explain this method for inserting into a priority queue for me. I get what occurs when say the list is [1,2,3,4,5,6,8,9] and you insert 7. Though I'm failing to see how it properly inserts 10 (or any other number greater than 9). From how I see it in its current implementation if the number is greater than the last number in the queue then it gets inserted improperly. Is this correct? Or am I missing something?\n\n```\n public void insert(double item) // insert item\n {\n        int j;\n        if(nItems==0) // if no items,\n            queArray[nItems++] = item; // insert at 0\n        else // if any items\n        {\n            for(j=nItems-1; j>=0; j--) // start at end,\n            {\n                if( item > queArray[j] ) // if new item larger, \n                    queArray[j+1] = queArray[j]; // shift upward\n                else // if smaller,\n                    break; // done shifting\n            } // end for\n            queArray[j+1] = item; // insert it\n            nItems++;\n        } // end else (nItems > 0)\n    } // end insert()\n```\n\n    ", "Answer": "\r\nIt's not clear how you're handling the growth of the array. If it's size is 8 and you add to it, accessing it at index 8 will throw an AIOOBE. But OK, assume it's handled somehow.\n\n\n  I get what occurs when say the list is [1,2,3,4,5,6,8,9] and you insert 7\n\n\nHere is what happens when you insert 7 to [1,2,3,4,5,6,8,9]:\n\n```\nfor(j=nItems-1; j>=0; j--) // start at end,\n```\n\n\n```\nnItems```\n is 8 so ```\nj = 7```\n\n\n```\nif( item > queArray[j] )\n```\n\n\nso ```\n7 > 9```\n is ```\nfalse```\n\n\n```\nqueArray[j+1] = item;\n```\n\n\nif you don't get AIOOBE, the result it [1,2,3,4,5,6,8,9,7]\n\nSo this is already wrong.\n\n\n  Though I'm failing to see how it properly inserts 10\n\n\nHere is what happens when you insert 10 to [1,2,3,4,5,6,8,9]:\n\n```\nfor(j=nItems-1; j>=0; j--) // start at end,\n```\n\n\n```\nnItems```\n is 8 so ```\nj = 7```\n\n\n```\nif( item > queArray[j] )\n```\n\n\nso ```\n10 > 9```\n is ```\ntrue```\n\n\n```\nqueArray[j+1] = queArray[j]; // shift upward\n```\n\n\n(AIOOBE) the new array is [1,2,3,4,5,6,8,9,9].\n\nnow ```\nj = 6```\n, going on with the loop\n\n```\nif( item > queArray[j] )\n```\n\n\nso ```\n10 > 8```\n is ```\ntrue```\n\n\n```\nqueArray[j+1] = queArray[j]; // shift upward\n```\n\n\nthe new array is [1,2,3,4,5,6,8,8,9]\n\ncontinue with the loop you'll get to the end with ```\nj = 0```\n and ```\n10 > 1```\n is ```\ntrue```\n\n\n```\nqueArray[j+1] = queArray[j]; // shift upward\n```\n\n\nthe new array is [1,1,2,3,4,5,6,8,9].\n\nNow ```\nj = -1```\n fails the loop condition\n\n```\n queArray[j+1] = item;\n```\n\n\nthe final array is [10,1,2,3,4,5,6,8,9].\n\nSo this is also wrong.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue in .Net [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\nPossible Duplicate:\nPriority queue in .Net\n\n\nThis question is similar, but i want to exactly know:\nIs there any class/struct/... in .Net for priority queue?  Just like in STL that have  ```\npriority_queue```\n for this. It accepts a comparsion function to support customized sorts.\nThe best thing i found in .Net is SortedList< Key, Value > that sorts it's values by Key. So one solution is implementing a custom Compare interface for Key class. But i cannot seperate my elements into Key/Value pairs. I have atomic elements that must queued according to their values with a custom function.\nSo, is there any collection class in .Net that accepts a Compare function for sorting the it's elements?\nIs there any way to derive a .Net class (maybe HashSet) that supports this feature?\n\nNote:\n\nI know that many third-parties implemented really good classes for this. Maybe a good example is PowerCollections. But i want t quick and simple solution using existing classes in .Net\nI am using .Net Framework 3.5\n\n    ", "Answer": "\r\nYou can use a SortedDictionary class, which is generic.\n\nYou can specify a comparer object to the constructor, which should handle the priority comparison of your objects:\n\n```\npublic class DataComparer : IComparer<Data>\n{\n    public Int32 Compare(Data a, Data b)\n    {\n        if (a == null && b == null)\n            return 0;\n        if (a == null)\n            return -1;\n        if (b == null)\n            return +1;\n        return a.Priority.CompareTo(b.Priority);\n    }\n}\n\nSortedDictionary<Data, Data> priQueue = new SortedDictionary<Data, Data>(\n    new DataComparer());\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Deleting from Indexed Priority Queue (java)\r\n                \r\nI have an Indexed Minimum Priority Queue implemented as a heap. When deleting an indexed element, the code is:\n\n```\n public void delete(int i) {\n    if (i < 0 || i >= maxN) throw new IllegalArgumentException();\n    if (!contains(i)) throw new NoSuchElementException(\"index is not in the priority queue\");\n    int index = qp[i];\n    exch(index, n--);\n    swim(index); // Why is this needed?\n    sink(index);\n    keys[i] = null;\n    qp[i] = -1;\n}\n```\n\n\nThe rest of the code can be found here: https://algs4.cs.princeton.edu/24pq/IndexMinPQ.java.html\n\nSince ```\npq[N```\n] is the last element in ```\npq[]```\n, and this is swapped with the element at ```\npq[i]```\n (which is to be deleted), wouldn't this mean that the value at ```\npq[i]```\n after the swap is larger or equal to ```\npq[i]```\n before the swap? The question is why do we have to call ```\nswim(i)```\n at all and not just ```\nsink(i)```\n alone? Under which specific conditions is there a need to call ```\nswim(i)```\n after the swap? \n\n(There are 3 arrays, ```\nqp[]```\n and ```\nkeys[]```\n with corresponding indexes, and ```\npq[]```\n such that ```\nqp[pq[i]]```\n = ```\npq[qp[i]]```\n = ```\ni```\n.)\n    ", "Answer": "\r\n\nSince pq[N] is the last element in pq[], and this is swapped with the element at pq[i] (which is to be deleted), wouldn't this mean that the value at pq[i] after the swap is larger or equal to pq[i] before the swap?\n\nNo, that is not necessarily true.  The only requirement for a valid min-heap is that a child cannot be smaller than its parent.  While this means that the element in the first position is the smallest, it does not mean that the element in the last position is the largest.  Consider the following heap:\n```\n                1\n      10                 2  \n  15       18        5        3\n16  17   19  20    7   8    6   4\n```\n\n```\npq[N]```\n is ```\n4```\n and yet there are lots of elements in that heap that are larger than it.  Suppose we wanted to remove ```\n15```\n by replacing it with ```\n4```\n.  ```\n4```\n is smaller than ```\n10```\n and so would have to be moved up the tree (using ```\nswim```\n).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Binary Heap and Priority Queues\r\n                \r\nI am new to Heaps, Binary Heap and I am trying to understand why do we need to implement Priority Queue using a Binary Heap. I also understand that the underlying data structure of Binary Heap is again an array. \n\nSo my question is why can we not use an array, sorted in either descending (for max heap) or ascending (for min heap) order to represent a priority queue ? I might be wrong here, but I think the time complexity of the operations like, findMax, findMin, insert and delete will remain almost the same if implemented this way. So can we not not a use a sorted array to represent the priority queue ?\n\nI have already read this answer: Heap vs Binary Search Tree (BST)\n    ", "Answer": "\r\nYou can use an array to represent a priority queue, but you lose a lot of efficiency when you do so. Imagine you insert something into an array, and it has higher priority than any object in the queue. It needs to go at index 0, the object at index 0 needs to go to index 1, and so on. \n\nThis is O(n), but if you insert a value into the front of a priority queue composed of a binary tree, you only need to change lg(n) nodes, making binary trees much better at modeling priority queues than arrays are.\n\nDeleting elements have a similar time complexity.\n\nAccessing the back of the priority queue is constant time if it's implemented with an array, but O(n) time if it's implemented with a binary tree, so this is a significant advantage arrays have over binary trees, but priority queues in general don't need to access the element with the least priority much of the time, and so binary trees represent priority queues more efficiently than arrays in general.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "List to priority queue\r\n                \r\nI have a college programming project in C++ divided into two parts. I beggining the second part where it's supposed to use ```\npriority_queues```\n, ```\nhash tables```\n and ```\nBST```\n's.\n\nI'm having trouble (at least) with priority queues since it's obligating myself to redone a lot of code already implemented in the first part.\n\nThe project it's about implementing a simple airport management system and, therefore, I have classes like Airport (main class), Airplane, Terminal and Flight. My airport had a ```\nlist```\n of terminals but now the project specification points out that I must keep the terminals in a ```\npriority_queue```\n where the top contains the terminal less occupied, i.e has less flights.\n\nFor each class, I have CRUD functions but now how am I supposed, for example, edit a terminal and add a flight to it? With a list, I just had to iterate to a specific position but now I only have access to object in the top of the queue. The solution I thought about was to copy the priority queue terminals to a temporary list but, honestly, I don't like this approach.\n\nWhat should I do?\n\nThanks in advance.\n    ", "Answer": "\r\nIt sounds like you need a priority queue with efficient increase and decrease key operations. You might be better of creating you own your own priority queue implementation.\n\nThe priority_queue container is great for dynamic sets. But since the number of terminal in an airport are pretty much fixed you can a fixed size container with the heap family of algorithms.\n\nAs the internal storage, you could use any container that provides random access iterators (vector, array, deque). Then, use make_heap(), sort_heap() family of functions to heapify the array. Now you can cheaply access the top(), modify the priority of a random member in the heap and iterate through all elements easily.\n\nFor an example see:\nhttp://www.cplusplus.com/reference/algorithm/make_heap/\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why does Julia throw a bound error when deleting an element from priority queue\r\n                \r\nI am learning Julia and have encountered a frustrating error. Consider the following function:\n```\nfunction deletetag(id::Id, tag::Tag, dat::DataSet)\n  if haskey(dat.tags, id)\n    tags = dat.tags[id]\n    if haskey(tags, tag)\n      dat.tags[id] = delete!(tags, tag)\n    end\n  end\n  nothing\nend\n```\n\nthe parameter dat contains some priority queues in its .tags field, the particular queue is found using the id passed as first parameter. I want to remove the given tag from the priority queue, but the delete! method throws the following error:\n```\nBoundsError: attempt to access 19-element Vector{Pair{Main.Ana.Tag, Main.Ana.Tag}} at index [22]\n\nStacktrace:\n [1] getindex\n   @ ./array.jl:924 [inlined]\n [2] force_up!(pq::DataStructures.PriorityQueue{Main.Ana.Tag, Main.Ana.Tag, Main.Ana.TagOrder}, i::Int64)\n   @ DataStructures ~/.julia/packages/DataStructures/59MD0/src/priorityqueue.jl:163\n [3] dequeue_pair!\n   @ ~/.julia/packages/DataStructures/59MD0/src/priorityqueue.jl:324 [inlined]\n [4] delete!(pq::DataStructures.PriorityQueue{Main.Ana.Tag, Main.Ana.Tag, Main.Ana.TagOrder}, key::Main.Ana.Tag)\n   @ DataStructures ~/.julia/packages/DataStructures/59MD0/src/priorityqueue.jl:346\n [5] deletetag(id::Main.Ana.Frames.FrameId, tag::Main.Ana.Tag, dat::Main.Ana.DataSet)\n   @ Main.Ana ~/Documents/school/Bachelor Thesis/Thesis/src/Ana.jl:162\n [6] filter(cs::Vector{Main.Ana.Frames.FrameId}, key::Main.Ana.Keys.Key, dat::Main.Ana.DataSet; choose::var\"#81#83\", window::Int64, beginning::Main.Ana.Keys.Key, ending::Main.Ana.Keys.Key)\n   @ Main.Ana ~/Documents/school/Bachelor Thesis/Thesis/src/Ana.jl:400\n [7] top-level scope\n   @ ~/Documents/school/Bachelor Thesis/Thesis/src/Schubert.ipynb:12\n```\n\nI cannot figure out what is happening here, my first thought is that there is a bug in Julia's code, the reason why I think so is that the inner implementation of the priority queue throws the error, which should not happen. On the other hand I might just be doing something that I am really not supposed to do, like calling the delete! method like that?\nMy question is: why do I get this bound error, if this is supposed to happen, how am I supposed to delete an element from a priority queue? Note that I did override the Base.:(==) and Base.hash(...) methods for type Tag.\nThank you.\nEdit, definition of DataSet:\n```\nstruct DataSet <: Hierarchy\n  \n  wrapped::Chakra.Hierarchy\n  data::Dict{Id, Constituent}\n  tags::Dict{Id, PriorityQueue{Tag, Tag}} # MAKE CHARM ATTRIBUTE\n  \n  function DataSet(wrapped::Chakra.Hierarchy)\n    new(wrapped, Dict(), Dict())\n  end\n\nend\n```\n\nConstituent and Hierarchy are just abstract types:\n```\nabstract type Id end\nabstract type Constituent end\nabstract type Hierarchy end\n```\n\nThe chackra module can be found here: https://github.com/nick-harley/Chakra/blob/main/src/Chakra.jl\nTags as followed:\n```\nstruct Tag <: Constituent\n  \n  complete::Bool\n  root::Int\n  key::Key\n  inversion::Int\n  score::Float64\n\n  function Tag(c, r, k, i, s)\n    new(c, r, k, i, s)\n  end\n  function Tag()\n    new(false, -1, Keys.major(-1), -1, 0)\n  end\n  function Tag(k)\n    new(true, k.pitch, k, 0, -1)\n  end\n\nend\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Compare argument in priority queue\r\n                \r\nI am trying to understand the priority queue in stl. What I have understood is that the third argument is basically typename(in this case function pointer). So,if it just accepts the typename, how will it have access over my compare function when it will implement its operations if it just accept typename and not actual function pointer?\n\n```\n#include <iostream>\n    #include <bits/stdc++.h>\n    using namespace std;\n    bool comp(int a,int b){\n        return a<b;\n    }\n\n    int main()\n    {\n        int (*p)(int,int);\n        p=comp;\n        priority_queue< int,vector<int>,decltype(&comp) > pq;\n        decltype(p) a;\n        cout<<typeid(a).name();\n    }\n```\n\n    ", "Answer": "\r\n\n  So,if it just accepts the typename, how will it have access over my compare function when it will implement its operations if it just accept typename and not actual function pointer?\n\n\nThere are two options for you.\n\n\nMake a class, that can be constructed which has this function as a call operator.\n\n```\nstruct comparator {\n    bool operator()(int a, int b) { return comp(a, b); }\n};\n```\n\n\nThen use like you written, pass only the typename:\n\n```\npriority_queue< int,vector<int>,comparator > pq;\n```\n\nPass a reference to your object (which may be a function pointer). So no need for constructing your object again:\n\n```\npriority_queue< int,vector<int>,decltype(p) > pq(p)\n```\n\n\nWhere p is the function pointer you made before.\n\n```\nbool (*p)(int,int);\np=comp;\npriority_queue< int,vector<int>,decltype(p) > pq(p);\n```\n\n\n\nCheck the constructors of the ```\npriority_queue```\n class.\n\nConstructors of ```\npriority_queue```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementation of BFS, DFS and Dijkstra\r\n                \r\nIs it true that the implementation of BFS, DFS and Dijkstra are almost the same, except that BFS uses queue, DFS uses stack, while Dijkstra uses min priority queue?\n\nMore precisely. Can we use the following code for all of BFS, DFS, and Dijkstra, with Q being a queue for BFS, and a stack for DFS, and a min priority queue for Dijkstra? Thanks!\n\n```\nInit d[]=Inf; // distance from the node s\nInit c[]='w'; // color of nodes: 'w':undiscovered, 'g':discovered, 'b':fully explored\nInit p[]=null; // previous node in the path\nc[s]='g';\nd[s]=0;\nQ.push(s);\nwhile(!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    for v in adj[u] {\n        if(c(v)=='w') {\n            c[v]='g';\n            if(d[u]+w(u,v)<d[v]) {\n                d[v]=d[u]+w(u,v);\n                p[v]=u;\n            }\n            Q.push(v);\n        }\n    }\n    c[u]='b';\n}\n```\n\n    ", "Answer": "\r\nYes\n\nLet's say we have this graph, and want to find the shortest distances starting at ```\nA```\n:\n\n\n\nHere is a simple ```\nNodeCollection```\n interface that allows for the operations needed for the traversal:\n\n```\ninterface NodeCollection<E> {\n    void offer(E node);\n    E extract();\n    boolean isEmpty();\n}\n```\n\n\nAnd the implementations for queue, stack and priority queue. Note that this interface and classes don't really need to be generic:\n\n```\nstatic class NodeQueue<E> implements NodeCollection<E> {\n    private final Queue<E> queue = new LinkedList<E>();\n    @Override public void offer(E node) { queue.offer(node); }\n    @Override public E extract() { return queue.poll(); }\n    @Override public boolean isEmpty() { return queue.isEmpty(); }\n}\n\nstatic class NodeStack<E> implements NodeCollection<E> {\n    private final Stack<E> stack = new Stack<E>();\n    @Override public void offer(E node) { stack.push(node); }\n    @Override public E extract() { return stack.pop(); }\n    @Override public boolean isEmpty() { return stack.isEmpty(); }\n}\n\nstatic class NodePriorityQueue<E> implements NodeCollection<E> {\n    private final PriorityQueue<E> pq = new PriorityQueue<E>();\n    @Override public void offer(E node) { pq.add(node); }\n    @Override public E extract() { return pq.poll(); }\n    @Override public boolean isEmpty() { return pq.isEmpty(); }\n}\n```\n\n\nNote that for ```\nPriorityQueue```\n to work as expected, the ```\nNode```\n class needs to provide a ```\ncompareTo(Node)```\n method:\n\n```\nstatic class Node implements Comparable<Node> {\n    final String name;\n    Map<Node, Integer> neighbors;\n    int dist = Integer.MAX_VALUE;\n    Node prev = null;\n    char color = 'w';\n\n    Node(String name) {\n        this.name = name;\n        this.neighbors = Maps.newHashMap();\n    }\n\n    @Override public int compareTo(Node o) {\n        return ComparisonChain.start().compare(this.dist, o.dist).result();\n    }\n}\n```\n\n\nNow here's the ```\nGraph```\n class. Note that the ```\ntraverse```\n method takes a ```\nNodeCollection```\n instance, which will be used for storing nodes during the traversal.\n\n```\nstatic class Graph {\n    Map<String, Node> nodes = Maps.newHashMap();\n\n    void addEdge(String fromName, String toName, int weight) {\n        Node from = getOrCreate(fromName);\n        Node to = getOrCreate(toName);\n        from.neighbors.put(to, weight);\n        to.neighbors.put(from, weight);\n    }\n\n    Node getOrCreate(String name) {\n        if (!nodes.containsKey(name)) {\n            nodes.put(name, new Node(name));\n        }\n        return nodes.get(name);\n    }\n\n    /**\n     * Traverses this graph starting at the given node and returns a map of shortest paths from the start node to\n     * every node.\n     *\n     * @param startName start node\n     * @return shortest path for each node in the graph\n     */\n    public Map<String, Integer> traverse(String startName, NodeCollection<Node> collection) {\n        assert collection.isEmpty();\n        resetNodes();\n\n        Node start = getOrCreate(startName);\n        start.dist = 0;\n        collection.offer(start);\n\n        while (!collection.isEmpty()) {\n            Node curr = collection.extract();\n            curr.color = 'g';\n            for (Node neighbor : curr.neighbors.keySet()) {\n                if (neighbor.color == 'w') {\n                    int thisPathDistance = curr.dist + curr.neighbors.get(neighbor);\n                    if (thisPathDistance < neighbor.dist) {\n                        neighbor.dist = thisPathDistance;\n                        neighbor.prev = curr;\n                    }\n                    collection.offer(neighbor);\n                }\n            }\n            curr.color = 'b';\n        }\n\n        Map<String, Integer> shortestDists = Maps.newTreeMap();\n        for (Node node : nodes.values()) {\n            shortestDists.put(node.name, node.dist);\n        }\n        return shortestDists;\n    }\n\n    private void resetNodes() {\n        for (Node node : nodes.values()) {\n            node.dist = Integer.MAX_VALUE;\n            node.prev = null;\n            node.color = 'w';\n        }\n    }\n}\n```\n\n\nFinally here's the ```\nmain```\n method, which traverses the same graph 3 times, once with each of the ```\nNodeCollection```\n types:\n\n```\nprivate static Graph initGraph() {\n    Graph graph = new Graph();\n    graph.addEdge(\"A\", \"B\", 2);\n    graph.addEdge(\"B\", \"C\", 2);\n    graph.addEdge(\"C\", \"D\", 2);\n    graph.addEdge(\"D\", \"E\", 2);\n    graph.addEdge(\"E\", \"F\", 2);\n    graph.addEdge(\"F\", \"L\", 2);\n\n    graph.addEdge(\"A\", \"G\", 10);\n    graph.addEdge(\"G\", \"H\", 10);\n    graph.addEdge(\"H\", \"I\", 10);\n    graph.addEdge(\"I\", \"J\", 10);\n    graph.addEdge(\"J\", \"K\", 10);\n    graph.addEdge(\"K\", \"L\", 10);\n\n    return graph;\n}\n\npublic static void main(String[] args) {\n    Graph graph = initGraph();\n    System.out.println(\"Queue (BFS):\\n\" + graph.traverse(\"A\", new NodeQueue<Node>()));\n    System.out.println(\"Stack (DFS):\\n\" + graph.traverse(\"A\", new NodeStack<Node>()));\n    System.out.println(\"PriorityQueue (Dijkstra):\\n\" + graph.traverse(\"A\", new NodePriorityQueue<Node>()));\n}\n```\n\n\nAnd the results!\n\n```\nQueue (BFS):\n{A=0, B=2, C=4, D=6, E=8, F=10, G=10, H=20, I=30, J=40, K=22, L=12}\nStack (DFS):\n{A=0, B=2, C=4, D=66, E=64, F=62, G=10, H=20, I=30, J=40, K=50, L=60}\nPriorityQueue (Dijkstra):\n{A=0, B=2, C=4, D=6, E=8, F=10, G=10, H=20, I=30, J=32, K=22, L=12}\n```\n\n\nNote that DFS will sometimes take the top branch first, yielding different but symmetric results.\n\nHere's what the results look like this on the graph:\n\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Stack using priority Queue in Python3\r\n                \r\nI have come up with the below code but somehow its not working as expected.  What could be the reason of this. Idea is to make a pair of count and item to be pushed to the priority queue and then just pop.But how to implement this in python3?\n\n```\nimport heapq\n\nclass Stack:\n\n    def __init__(self):\n        self.dict ={}\n        self.cnt = 0\n        self.hq = []\n\n    def push(self, item):\n        self.cnt += 1\n        self.heappush(hq, {self.cnt:item})\n\n    def pop(self):\n        self.cnt -= 1\n        return self.heappop(hq)\n\nif __name__ == '__main__':\n    s = Stack()\n    s.push(10)\n    s.push(20)\n    s.push(30)\n    print(s.pop())\n```\n\n\nI am receiving the below error.\n\n```\nTraceback (most recent call last):\n  File \"/home/shrivatsa/Documents/E/Learning-Path/Python/Algorithms and Datastructure/stackpriorityqueue.py\", line 19, in <module>\n    s.push(10)\n  File \"/home/shrivatsa/Documents/E/Learning-Path/Python/Algorithms and Datastructure/stackpriorityqueue.py\", line 11, in push\n    self.heappush(hq, {self.cnt:item})\nAttributeError: 'Stack' object has no attribute 'heappush'\n```\n\n    ", "Answer": "\r\nThe ```\nself```\n keyword is used to reference the object, this way we can specify we're referring to attributes or methods defined within the class. ```\nheappush```\n and ```\nheappop```\n are not defined in the Stack class but in the ```\nheapq```\n library so you should call them ```\nheapq.heappush```\n and ```\nheapq.heappop```\n instead.\n\nAnother issue to take into account is that dictionaries do not have an ordering defined, and thus they can't be pushed into a heap. If you want to save these pairs you should use tuples instead.\n\nExample:\n\n```\nimport heapq\n\nclass Stack:\n\n    def __init__(self):\n        self.cnt = 0\n        self.hq = []\n\n    def push(self, item):\n        self.cnt += 1\n        heapq.heappush(self.hq, (self.cnt, item))\n\n    def pop(self):\n        self.cnt -= 1\n        return heapq.heappop(self.hq)\n\nif __name__ == '__main__':\n    s = Stack()\n    s.push(10)\n    s.push(20)\n    s.push(30)\n    print(s.pop())\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Alamofire Priority Queue\r\n                \r\nI am using Alamofire as my networking library for my Swift app. Is there a way to keep a \"priority queue\" of network requests with Alamofire? I believe I saw this feature in a library in the past but I can no longer find it or find other posts about this.\n\nLet's say I open a page in my application and it starts to make a few requests. First it gets some JSON, which is fast and no problem.\n\nFrom that JSON, it pulls out some information and then starts downloading images. These images have the potential to be quite large and take many seconds (~30 seconds or more sometimes). But the tricky part is that the user has the option to move on to the next page before the image(s) finish downloading.\n\nIf the user moves on to the next page before the image downloading is done, is it possible to move it on to a lower priority queue? So that when the images on the next page start loading they will go faster? I would even be open to pausing the old one entirely until the new requests are finished if that is even possible. \n\nKeep in mind I am open to many suggestions. I have a lot of freedom with my implementation. So if this is a different library, or different mechanism in iOS that is fine. Even if I continue to use Alamofire for JSON and do all my image downloading and management with something else that would be alright too.\n\nAlso, probably irrelevant but I will add it here. I'm using https://github.com/rs/SDWebImage for caching my images once they're fully downloaded. Which is why I don't want to cancel the request completely. I need it to finish and then it won't happen again.\n\nTL;DR I want a fast queue and a slow queue with the ability to move things from the fast queue to the slow queue before they are finished.\n    ", "Answer": "\r\nHave you considered managing a NSOperationQueue? This tutorial might be helpful. In his example, he pauses the downloads as they scroll off the page, but I believe you could adjust the queuePriority property of the NSOperation objects instead.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue that uses a comparator and has decrease key operation\r\n                \r\nSo I have a problem where I have a set of objects with two fields. I need to be able to get the min object of the set at a fast time time (using a custom comparator). The problem is, when I get the min object set, it changes the fields of some objects in my original set. Thus, the ordering of the set needs to be changed when I am done with the min object.  \n\nTo me it seems obvious to use a priority queue with a custom comparator, the problem is, the Priority Queue in Java doesn't have a change or decrease key operation. I have tried looking for other implementations online for a priority queue that uses a comparator with the decrease key operation but I cannot find one. Any help would be greatly appreciated as to how to approach this problem? Is there another data structure I can use?\n\nBelow is my adaptation of what I am talking about.It is a bit hackish and I have found it doesn't work properly, as I have found in testing the ordering of adding elements into the queue somehow affects the ordering of the priority queue itself. I am not looking for help on this specific code as it will be most likely tossed. \n\n```\n**\n * A class representing a Fibonacci heap.\n *\n * @param T The type of elements to store in the heap.\n * @author Keith Schwarz (htiek@cs.stanford.edu)\n */\npublic final class FibonacciHeap<T> {\n    /* In order for all of the Fibonacci heap operations to complete in O(1),\n     * clients need to have O(1) access to any element in the heap.  We make\n     * this work by having each insertion operation produce a handle to the\n     * node in the tree.  In actuality, this handle is the node itself, but\n     * we guard against external modification by marking the internal fields\n     * private.\n     */\n    public static final class Entry<T> {\n        private int     mDegree = 0;       // Number of children\n        private boolean mIsMarked = false; // Whether this node is marked\n\n        private Entry<T> mNext;   // Next and previous elements in the list\n        private Entry<T> mPrev;\n\n        private Entry<T> mParent; // Parent in the tree, if any.\n\n        private Entry<T> mChild;  // Child node, if any.\n\n        private T      mElem;     // Element being stored here\n        private int mPriority; // Its priority\n\n        /**\n         * Returns the element represented by this heap entry.\n         *\n         * @return The element represented by this heap entry.\n         */\n        public T getValue() {\n            return mElem;\n        }\n        /**\n         * Sets the element associated with this heap entry.\n         *\n         * @param value The element to associate with this heap entry.\n         */\n        public void setValue(T value) {\n            mElem = value;\n        }\n\n        /**\n         * Returns the priority of this element.\n         *\n         * @return The priority of this element.\n         */\n        public int getPriority() {\n            return mPriority;\n        }\n\n        /**\n         * Constructs a new Entry that holds the given element with the indicated\n         * priority.\n         *\n         * @param elem The element stored in this node.\n         * @param priority The priority of this element.\n         */\n        private Entry(T elem, int priority) {\n            mNext = mPrev = this;\n            mElem = elem;\n            mPriority = priority;\n        }\n    }\n\n    /* Pointer to the minimum element in the heap. */\n    private Entry<T> mMin = null;\n\n    /* Cached size of the heap, so we don't have to recompute this explicitly. */\n    private int mSize = 0;\n\n    /**\n     * Inserts the specified element into the Fibonacci heap with the specified\n     * priority.  Its priority must be a valid double, so you cannot set the\n     * priority to NaN.\n     *\n     * @param value The value to insert.\n     * @param priority Its priority, which must be valid.\n     * @return An Entry representing that element in the tree.\n     */\n    public Entry<T> enqueue(T value, int priority) {\n        /* Create the entry object, which is a circularly-linked list of length\n         * one.\n         */\n        Entry<T> result = new Entry<T>(value, priority);\n\n        /* Merge this singleton list with the tree list. */\n        mMin = mergeLists(mMin, result);\n\n        /* Increase the size of the heap; we just added something. */\n        ++mSize;\n\n        /* Return the reference to the new element. */\n        return result;\n    }\n\n    /**\n     * Returns an Entry object corresponding to the minimum element of the\n     * Fibonacci heap, throwing a NoSuchElementException if the heap is\n     * empty.\n     *\n     * @return The smallest element of the heap.\n     * @throws NoSuchElementException If the heap is empty.\n     */\n    public Entry<T> min() {\n        if (isEmpty())\n            throw new NoSuchElementException(\"Heap is empty.\");\n        return mMin;\n    }\n\n    /**\n     * Returns whether the heap is empty.\n     *\n     * @return Whether the heap is empty.\n     */\n    public boolean isEmpty() {\n        return mMin == null;\n    }\n\n    /**\n     * Returns the number of elements in the heap.\n     *\n     * @return The number of elements in the heap.\n     */\n    public int size() {\n        return mSize;\n    }\n\n    /**\n     * Given two Fibonacci heaps, returns a new Fibonacci heap that contains\n     * all of the elements of the two heaps.  Each of the input heaps is\n     * destructively modified by having all its elements removed.  You can\n     * continue to use those heaps, but be aware that they will be empty\n     * after this call completes.\n     *\n     * @param one The first Fibonacci heap to merge.\n     * @param two The second Fibonacci heap to merge.\n     * @return A new FibonacciHeap containing all of the elements of both\n     *         heaps.\n     */\n    public static <T> FibonacciHeap<T> merge(FibonacciHeap<T> one, FibonacciHeap<T> two) {\n        /* Create a new FibonacciHeap to hold the result. */\n        FibonacciHeap<T> result = new FibonacciHeap<T>();\n\n        /* Merge the two Fibonacci heap root lists together.  This helper function\n         * also computes the min of the two lists, so we can store the result in\n         * the mMin field of the new heap.\n         */\n        result.mMin = mergeLists(one.mMin, two.mMin);\n\n        /* The size of the new heap is the sum of the sizes of the input heaps. */\n        result.mSize = one.mSize + two.mSize;\n\n        /* Clear the old heaps. */\n        one.mSize = two.mSize = 0;\n        one.mMin  = null;\n        two.mMin  = null;\n\n        /* Return the newly-merged heap. */\n        return result;\n    }\n\n    /**\n     * Dequeues and returns the minimum element of the Fibonacci heap.  If the\n     * heap is empty, this throws a NoSuchElementException.\n     *\n     * @return The smallest element of the Fibonacci heap.\n     * @throws NoSuchElementException If the heap is empty.\n     */\n    public Entry<T> dequeueMin() {\n        /* Check for whether we're empty. */\n        if (isEmpty())\n            throw new NoSuchElementException(\"Heap is empty.\");\n\n        /* Otherwise, we're about to lose an element, so decrement the number of\n         * entries in this heap.\n         */\n        --mSize;\n\n        /* Grab the minimum element so we know what to return. */\n        Entry<T> minElem = mMin;\n\n        /* Now, we need to get rid of this element from the list of roots.  There\n         * are two cases to consider.  First, if this is the only element in the\n         * list of roots, we set the list of roots to be null by clearing mMin.\n         * Otherwise, if it's not null, then we write the elements next to the\n         * min element around the min element to remove it, then arbitrarily\n         * reassign the min.\n         */\n        if (mMin.mNext == mMin) { // Case one\n            mMin = null;\n        }\n        else { // Case two\n            mMin.mPrev.mNext = mMin.mNext;\n            mMin.mNext.mPrev = mMin.mPrev;\n            mMin = mMin.mNext; // Arbitrary element of the root list.\n        }\n\n        /* Next, clear the parent fields of all of the min element's children,\n         * since they're about to become roots.  Because the elements are\n         * stored in a circular list, the traversal is a bit complex.\n         */\n        if (minElem.mChild != null) {\n            /* Keep track of the first visited node. */\n            Entry<?> curr = minElem.mChild;\n            do {\n                curr.mParent = null;\n\n                /* Walk to the next node, then stop if this is the node we\n                 * started at.\n                 */\n                curr = curr.mNext;\n            } while (curr != minElem.mChild);\n        }\n\n        /* Next, splice the children of the root node into the topmost list,\n         * then set mMin to point somewhere in that list.\n         */\n        mMin = mergeLists(mMin, minElem.mChild);\n\n        /* If there are no entries left, we're done. */\n        if (mMin == null) return minElem;\n\n        /* Next, we need to coalsce all of the roots so that there is only one\n         * tree of each degree.  To track trees of each size, we allocate an\n         * ArrayList where the entry at position i is either null or the\n         * unique tree of degree i.\n         */\n        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();\n\n        /* We need to traverse the entire list, but since we're going to be\n         * messing around with it we have to be careful not to break our\n         * traversal order mid-stream.  One major challenge is how to detect\n         * whether we're visiting the same node twice.  To do this, we'll\n         * spent a bit of overhead adding all of the nodes to a list, and\n         * then will visit each element of this list in order.\n         */\n        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();\n\n        /* To add everything, we'll iterate across the elements until we\n         * find the first element twice.  We check this by looping while the\n         * list is empty or while the current element isn't the first element\n         * of that list.\n         */\n        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)\n            toVisit.add(curr);\n\n        /* Traverse this list and perform the appropriate unioning steps. */\n        for (Entry<T> curr: toVisit) {\n            /* Keep merging until a match arises. */\n            while (true) {\n                /* Ensure that the list is long enough to hold an element of this\n                 * degree.\n                 */\n                while (curr.mDegree >= treeTable.size())\n                    treeTable.add(null);\n\n                /* If nothing's here, we're can record that this tree has this size\n                 * and are done processing.\n                 */\n                if (treeTable.get(curr.mDegree) == null) {\n                    treeTable.set(curr.mDegree, curr);\n                    break;\n                }\n\n                /* Otherwise, merge with what's there. */\n                Entry<T> other = treeTable.get(curr.mDegree);\n                treeTable.set(curr.mDegree, null); // Clear the slot\n\n                /* Determine which of the two trees has the smaller root, storing\n                 * the two tree accordingly.\n                 */\n                //TODO Test\n                Entry<T> min = (((Comparable<T>)other.mElem).compareTo(curr.mElem) < -1)? other : curr;\n                Entry<T> max = (((Comparable<T>)other.mElem).compareTo(curr.mElem) < -1)? curr  : other;\n\n                /* Break max out of the root list, then merge it into min's child\n                 * list.\n                 */\n                max.mNext.mPrev = max.mPrev;\n                max.mPrev.mNext = max.mNext;\n\n                /* Make it a singleton so that we can merge it. */\n                max.mNext = max.mPrev = max;\n                min.mChild = mergeLists(min.mChild, max);\n\n                /* Reparent max appropriately. */\n                max.mParent = min;\n\n                /* Clear max's mark, since it can now lose another child. */\n                max.mIsMarked = false;\n\n                /* Increase min's degree; it now has another child. */\n                ++min.mDegree;\n\n                /* Continue merging this tree. */\n                curr = min;\n            }\n\n            /* Update the global min based on this node.  Note that we compare\n             * for <= instead of < here.  That's because if we just did a\n             * reparent operation that merged two different trees of equal\n             * priority, we need to make sure that the min pointer points to\n             * the root-level one.\n             */\n            if (((Comparable<T>)curr.mElem).compareTo(mMin.mElem) < 1){\n                mMin = curr;\n            }\n        }\n        return minElem;\n    }\n\n    /**\n     * Decreases the key of the specified element to the new priority.  If the\n     * new priority is greater than the old priority, this function throws an\n     * IllegalArgumentException.  The new priority must be a finite double,\n     * so you cannot set the priority to be NaN, or +/- infinity.  Doing\n     * so also throws an IllegalArgumentException.\n     *\n     * It is assumed that the entry belongs in this heap.  For efficiency\n     * reasons, this is not checked at runtime.\n     *\n     * @param entry The element whose priority should be decreased.\n     * @param newPriority The new priority to associate with this entry.\n     * @throws IllegalArgumentException If the new priority exceeds the old\n     *         priority, or if the argument is not a finite double.\n     */\n    public void decreaseKey(Entry<T> entry, int newPriority) {\n        if (newPriority > entry.mPriority)\n            throw new IllegalArgumentException(\"New priority exceeds old.\");\n\n        /* Forward this to a helper function. */\n        decreaseKeyUnchecked(entry, newPriority);\n    }\n\n    /**\n     * Deletes this Entry from the Fibonacci heap that contains it.\n     *!!!\n     * It is assumed that the entry belongs in this heap.  For efficiency\n     * reasons, this is not checked at runtime.\n     *\n     * @param entry The entry to delete.\n     */\n    public void delete(Entry<T> entry) {\n        /* Use decreaseKey to drop the entry's key to -infinity.  This will\n         * guarantee that the node is cut and set to the global minimum.\n         */\n        decreaseKeyUnchecked(entry, Integer.MIN_VALUE);\n\n        /* Call dequeueMin to remove it. */\n        dequeueMin();\n    }\n\n\n    /**\n     * Utility function which, given two pointers into disjoint circularly-\n     * linked lists, merges the two lists together into one circularly-linked\n     * list in O(1) time.  Because the lists may be empty, the return value\n     * is the only pointer that's guaranteed to be to an element of the\n     * resulting list.\n     *\n     * This function assumes that one and two are the minimum elements of the\n     * lists they are in, and returns a pointer to whichever is smaller.  If\n     * this condition does not hold, the return value is some arbitrary pointer\n     * into the doubly-linked list.\n     *\n     * @param one A pointer into one of the two linked lists.\n     * @param two A pointer into the other of the two linked lists.\n     * @return A pointer to the smallest element of the resulting list.\n     */\n    private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {\n        /* There are four cases depending on whether the lists are null or not.\n         * We consider each separately.\n         */\n        if (one == null && two == null) { // Both null, resulting list is null.\n            return null;\n        }\n        else if (one != null && two == null) { // Two is null, result is one.\n            return one;\n        }\n        else if (one == null && two != null) { // One is null, result is two.\n            return two;\n        }\n        else { // Both non-null; actually do the splice.\n            /* This is actually not as easy as it seems.  The idea is that we'll\n             * have two lists that look like this:\n             *\n             * +----+     +----+     +----+\n             * |    |--N->|one |--N->|    |\n             * |    |<-P--|    |<-P--|    |\n             * +----+     +----+     +----+\n             *\n             *\n             * +----+     +----+     +----+\n             * |    |--N->|two |--N->|    |\n             * |    |<-P--|    |<-P--|    |\n             * +----+     +----+     +----+\n             *\n             * And we want to relink everything to get\n             *\n             * +----+     +----+     +----+---+\n             * |    |--N->|one |     |    |   |\n             * |    |<-P--|    |     |    |<+ |\n             * +----+     +----+<-\\  +----+ | |\n             *                  \\  P        | |\n             *                   N  \\       N |\n             * +----+     +----+  \\->+----+ | |\n             * |    |--N->|two |     |    | | |\n             * |    |<-P--|    |     |    | | P\n             * +----+     +----+     +----+ | |\n             *              ^ |             | |\n             *              | +-------------+ |\n             *              +-----------------+\n             *\n             */\n            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.\n            one.mNext = two.mNext;\n            one.mNext.mPrev = one;\n            two.mNext = oneNext;\n            two.mNext.mPrev = two;\n\n            /* Return a pointer to whichever's smaller. */\n            return ((Comparable<T>)one.mElem).compareTo(two.mElem) < 0? one : two;\n        }\n    }\n\n    /**\n     * Decreases the key of a node in the tree without doing any checking to ensure\n     * that the new priority is valid. This method does not modify and members in the\n     * entry objects element.\n     *\n     * @param entry The node whose key should be decreased.\n     * @param priority The node's new priority.\n     */\n    private void decreaseKeyUnchecked(Entry<T> entry, int priority) {\n        /* First, change the node's priority. */\n        entry.mPriority = priority;\n        ((GNode)entry.mElem).setInE(priority);\n\n        /* If the node no longer has a higher priority than its parent, cut it.\n         * Note that this also means that if we try to run a delete operation\n         * that decreases the key to -infinity, it's guaranteed to cut the node\n         * from its parent.\n         */\n        if (entry.mParent != null && ((GNode)entry.mElem).compareTo((GNode)entry.mParent.mElem) <= 0)\n            cutNode(entry);\n\n        /* If our new value is the new min, mark it as such.  Note that if we\n         * ended up decreasing the key in a way that ties the current minimum\n         * priority, this will change the min accordingly.\n         */\n        //NPE fix If mMin in null, means we have only one entry left... and we swap\n        if (mMin == null || ((GNode)entry.mElem).compareTo((GNode)mMin.mElem) <= 0)\n            mMin = entry;\n    }\n\n    /**\n     * Cuts a node from its parent.  If the parent was already marked, recursively\n     * cuts that node from its parent as well.\n     *\n     * @param entry The node to cut from its parent.\n     */\n    private void cutNode(Entry<T> entry) {\n        /* Begin by clearing the node's mark, since we just cut it. */\n        entry.mIsMarked = false;\n\n        /* Base case: If the node has no parent, we're done. */\n        if (entry.mParent == null) return;\n\n        /* Rewire the node's siblings around it, if it has any siblings. */\n        if (entry.mNext != entry) { // Has siblings\n            entry.mNext.mPrev = entry.mPrev;\n            entry.mPrev.mNext = entry.mNext;\n        }\n\n        /* If the node is the one identified by its parent as its child,\n         * we need to rewrite that pointer to point to some arbitrary other\n         * child.\n         */\n        if (entry.mParent.mChild == entry) {\n            /* If there are any other children, pick one of them arbitrarily. */\n            if (entry.mNext != entry) {\n                entry.mParent.mChild = entry.mNext;\n            }\n            /* Otherwise, there aren't any children left and we should clear the\n             * pointer and drop the node's degree.\n             */\n            else {\n                entry.mParent.mChild = null;\n            }\n        }\n\n        /* Decrease the degree of the parent, since it just lost a child. */\n        --entry.mParent.mDegree;\n\n        /* Splice this tree into the root list by converting it to a singleton\n         * and invoking the merge subroutine.\n         */\n        entry.mPrev = entry.mNext = entry;\n        mMin = mergeLists(mMin, entry);\n\n        /* Mark the parent and recursively cut it if it's already been\n         * marked.\n         */\n        if (entry.mParent.mIsMarked)\n            cutNode(entry.mParent);\n        else\n            entry.mParent.mIsMarked = true;\n\n        /* Clear the relocated node's parent; it's now a root. */\n        entry.mParent = null;\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Why is the Java Priority Queue not empty after execution in the following code?\r\n                \r\nI am trying to implement Dijkstra Algorithm and have used the following code. I have used the debugger in Eclipse to step through the program and have found that it produces correct values mid way through the execution. However after that, the priority queue that I have used from the java.util package, does not show up to be empty. While theoretically it should be empty from the following code.\n\nFrom the debugger, it can be seen that the priority queue contains references with values set to Infinity. What is the bug in the code?\n\n```\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\n\n\npublic class Dijkstra {\n    static class Vertex implements Comparable<Vertex>{\n        private int vertexid;\n        private Double distance;\n\n        public Vertex(int vertexid, Double distance) {\n            this.vertexid = vertexid;\n            this.distance = distance;\n        }\n\n        public int getVertexid() {\n            return vertexid;\n        }\n\n        public Double getDistance() {\n            return distance;\n        }\n\n        public int compareTo(Vertex other) {\n            return this.getDistance().compareTo(other.getDistance());\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof Vertex) {\n                Vertex v = (Vertex) o;\n                return vertexid == v.vertexid && distance == v.distance;\n            }\n            return false;\n        }\n    }\n\n    public static void dijkstra(double g[][], int n, int m, int source) {\n        // g is the adjacency matrix\n        // n is the number of nodes\n        // m is the number of edges\n\n        // initialize shortest path\n\n        double d[] = new double[n];\n\n\n        for (int i = 0; i < n; i++) {\n            d[i] = Double.POSITIVE_INFINITY;\n        }\n        d[source] = 0;\n\n        HashMap<Integer, Double> s = new HashMap<Integer, Double>();\n        PriorityQueue<Vertex> q = new PriorityQueue<Vertex>();\n\n        // initialize q\n        for (int i = 0; i < n; i++) {\n            q.add(new Vertex(i, d[i]));\n        }\n\n        Vertex u;\n\n        while (!q.isEmpty()) {\n            u = q.remove();\n            //System.out.println(u.getVertexid() + \"\\t\" + u.getDistance());\n            s.put(u.getVertexid(), u.getDistance());\n\n            for (int i = 0; i < n; i++) {\n                if (i != u.getVertexid() || g[u.getVertexid()][i] != Double.POSITIVE_INFINITY) {\n                    if (u.getDistance().doubleValue() + g[u.getVertexid()][i] < d[i] && s.containsKey(i) == false) {\n                        q.remove(new Vertex(i, d[i]));\n                        d[i] = u.getDistance().doubleValue() + g[u.getVertexid()][i];\n                        q.add(new Vertex(i, d[i]));\n                    }\n                }\n            }\n        }\n\n        /*for(double i: d){\n            System.out.println(i);\n        }*/\n\n        System.out.println(Arrays.asList(s));\n    }\n\n    public static void main(String[] args) {\n        double graph[][] = {{Double.POSITIVE_INFINITY, 4, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 8, Double.POSITIVE_INFINITY},\n                {4, Double.POSITIVE_INFINITY, 8, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 11, Double.POSITIVE_INFINITY},\n                {Double.POSITIVE_INFINITY, 8, Double.POSITIVE_INFINITY, 7, Double.POSITIVE_INFINITY, 4, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 2},\n                {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 7, Double.POSITIVE_INFINITY, 9, 14, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY},\n                {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 9, Double.POSITIVE_INFINITY, 10, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY},\n                {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 4, 14, 10, Double.POSITIVE_INFINITY, 2, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY},\n                {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 2, Double.POSITIVE_INFINITY, 1, 6},\n                {8, 11, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1, Double.POSITIVE_INFINITY, 7},\n                {Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 2, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 6, 7, Double.POSITIVE_INFINITY}\n               };\n\n        Dijkstra.dijkstra(graph, 9, 14, 0);\n\n    }\n}\n```\n\n\nThe following are the references from the debugger:\n\n\n\nAnd for the Priority Queue Contents:\n\n\n\nAfter the execution the s values all get set to infinity.\n    ", "Answer": "\r\n```\n// initialize q\nfor (int i = 0; i < n; i++) {\n    q.add(new Vertex(i, d[i]));\n}\n```\n\n\nThere should only be the source element in the queue in first place. You should not insert all the infinity distances to the queue. Only the source should be in the queue. And then while processing the source you insert the nodes reachable from source, and then process the nearest node among the nodes. That's how this algorithm work. So remove the for loop where you are inserting all the nodes into the queue. Insert only the source in queue before starting while loop. \nExample:\n\n```\n    ...\n    for (int i = 0; i < n; i++) {\n        d[i] = Double.POSITIVE_INFINITY;\n    }\n    d[source] = 0;\n\n    HashMap<Integer, Double> s = new HashMap<Integer, Double>();\n    PriorityQueue<Vertex> q = new PriorityQueue<Vertex>();\n\n    // initialize q\n    // only the source in the queue with 0 distance.\n\n    q.add(new Vertex(source, d[source]));\n\n    Vertex u;\n    ...\n    ...\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "problems when trying to overload << operator in c++11\r\n                \r\nim trying to write a c++ priority Queue implementation. \n\nthis is the class of the priority queue element: \n\n```\ntemplate <class Priority, class T>\nclass PriorityQueueElement {\n\npublic:\nPriority priority;\nT* data;\n\nprivate:\n    PriorityQueueElement* next ;\npublic:\n\n    PriorityQueueElement( const Priority& priority,T data ) :\n        priority(priority) ,data(&data) , next(NULL){\n    }\n    // ... other functions .. //\n    template <class P, class Y>\n    friend ostream& operator<<(ostream& os ,const PriorityQueueElement<P,Y>& element);\n\n}; \n```\n\n\nand the function : \n\n```\ntemplate<class Priority, class T>\nostream& operator<<(ostream& os ,const PriorityQueueElement<Priority,T>& elemen){\n        return os << \"[\" << elemen.getPriority() << \",\" << elemen.getData( ) << \"]\";\n}\n```\n\n\nim getting the error: \n\n```\nMultiple markers at this line\n    - template argument deduction/substitution failed:\n    - template<class Priority, class T> std::ostream& mtm::operator<<(std::ostream&, const \n mtm::PriorityQueueElement<Priority, T>&)\nMultiple markers at this line\n    - required from 'std::ostream& mtm::operator<<(std::ostream&, const mtm::PriorityQueueElement<Priority, T>&) [with Priority = int; T = int; std::ostream = \n std::basic_ostream<char>]'\n    - required from 'std::ostream& mtm::operator<<(std::ostream&, const mtm::PriorityQueueElement<Priority, T>&) [with Priority = double; T = Student; \n std::ostream = std::basic_ostream<char>]'\n```\n\n\nand if i try to use:\n\n```\ntemplate <class Priority,class T>\n```\n\n\ni am getting an error about shadowing the template in the class itself\n\nthank you for your help!\n    ", "Answer": "\r\nI copied your code and modified a bit( for test )\n\n```\ntemplate<class Priority, class T>\n    ostream& operator<<(ostream& os, const PriorityQueueElement<Priority, T>& elemen)\n    {\n        return os << \"[\" << elemen.priority << \",\" << *elemen.data << \"]\";\n    }\n```\n\n\nAnd its working, in main i put:\n\n```\nPriorityQueueElement<int, const char*> x( 1, \"fsdfsdfsd\" );\ncout << x;\n```\n\n\nand it gave me output: [1,fsdfsdfsd]\n\ntested on visual studio 2013.\nProblemem probably is somewhere else\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is heap an abstract data type? If so, what about priority queues?\r\n                \r\nI read that priority queue is an abstract data type for heap data structure or to put it in another way, heap is an implementation for priority queues. But what confuses me is that I see heap in itself as an ADT since they're normally implemented using arrays (talking about min/max heaps here). Could someone give me a clear distinction among the three within the realm of ADT? \n    ", "Answer": "\r\nLet me answer you in two steps..\ni) Defenitions\nData type is a set of values together with operations on that type.\nAlmost any noun can give rise to a data type.\n\nExample: integer, date, string, complex number, paragraph, bond, image, set, bag, vector, list, stack, queue, deque, priority queue, ring, dictionary, tree, graph.\n\nThere are a variety of constructs which are technically data types but are \"low-level\" in the sense that their operations are partially specified. For example, a binary search tree \"implements\" a set by performing lookups, insertions and deletions by \"navigating left and right\" — but the meanings of left and right depend on whether the items in the tree are stored in an array or are linked together.\n\nExample: binary search tree, AVL tree, B-tree, heap, pairing heap, hashtable, splay tree, trie, R-tree\n\n\nii) Conclusion regard to your question\nboth priority queues & heaps are data types (more accurate; abstract data type or ADT) but because heap Implemented by priority queues, we can consider it data structure.\nThe heap is one maximally efficient implementation of an abstract data type called a priority queue, and in fact priority queues are often referred to as \"heaps\", regardless of how they may be implemented. Note that despite the similarity of the name \"heap\" to \"stack\" and \"queue\", the latter two are abstract data types, while a heap is a specific data structure, and \"priority queue\" is the proper term for the abstract data type.\n\nNote: my answer comes from below references:\n\nhttp://cs.lmu.edu/~ray/notes/dtds/\nhttps://en.wikipedia.org/wiki/Data_type\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How to change the priority function of Priority Queue in Python?\r\n                \r\nI want to implement Djikstra's algorithm in Python. Thus, when I store nodes of a graph in a priority Queue, I want them to be sorted in the order of their distances from the source node. How can I change the priority function so that the nodes are sorted in this way?\nI am using the PriorityQueue Class in the queue module. By default, the integers entered are sorted in descending order, i.e., the priority of the smallest element is the highest. I want to enter a priority function which sorts nodes on the basis of the distance attribute in the node object. Following is the node class - \nclass node\n    node\n    distance\nCan someone help me out here?\n    ", "Answer": "\r\nAs the documentation explains, ```\nPriorityQueue```\n's in python do not seem to accept custom comparison functions. However, you can use ```\nmin```\n and a regular list to achieve what you want since the ```\nmin```\n function call accepts a ```\nkey```\n function that decides what the smallest item is.\n\n```\nclass node():\n    def __init__(self, dist):\n        self.dist = dist\n\ndef get_dist(node):\n    return node.dist\n\nnodes = [node(4), node(413), node(2), node(14), node(5)]\n\nout = min(nodes, key=get_dist)\nnodes.remove(out)\nprint('popped out:', out.dist) # popped out: 2\n\nout = min(nodes, key=get_dist)\nnodes.remove(out)\nprint('popped out:', out.dist) # popped out: 4\n\nout = min(nodes, key=get_dist)\nnodes.remove(out)\nprint('popped out:', out.dist) # popped out: 5\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "1/0 Knapsack, how to make it parallel with priority queue [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 9 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIn 1/0 Knapsack Problem, one can implement it dynamically with two for loops, like\non this site: http://www.bogotobogo.com/Algorithms/knapsack.php\n\nHow can i implement it with a priority queue and optimize it with multithreading?\n    ", "Answer": "\r\nIn the algorithm in the section \"0-1 Knapsack - Dynamic Programming\", the inner loop can be parallelized. The execution of the loop's body for different values of ```\njw```\n can be executed in parallel as the calculation of the value for ```\nm[i][jw]```\n does not require values ```\nm[i][jw']```\n where ```\njw'!=jw```\n, i.e. any iteration does not depend on previous iterations.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Python Priority Queue with objects heappush does not support '>' between objects\r\n                \r\nIn my attempt to implement a simple version of A* Search, I am trying to enqueue the following in a priority queue:\n\nPriority: sum of heuristic value and cost from source to current element\nQueue Node: Object of class queue node with data members point and cost\nThe code goes something like this:\n'''s = queueNode(start, 0)\nq.put((s.dist + heuristics[s.pt[0]][s.pt[1]],s))  # Enqueue source cell'''\n\nHowever, it gives the following error:\nin _put\nheappush(self.queue, item)\nTypeError: '<' not supported between instances of 'queueNode' and 'queueNode'\nHere is the code for class Queue Node\n```\nclass queueNode:\n    def __init__(self, pt, dist: int):\n        self.pt = pt  # The cordinates of the cell\n        self.dist = dist  # Cell's distance from the source\n```\n\nupdate:\nI tried to make the classes comparable by these two Implementations\nFirst\n```\nclass queueNode:\ndef __init__(self, pt, dist):\n    self.pt = pt  # The cordinates of the cell\n    self.dist = dist  # Cell's distance from the source\n\ndef __it__(self,other):\n    return self.dist < other.dist\n```\n\nSecond\n```\nclass queueNode:\ndef __init__(self, pt, dist):\n    self.pt = pt  # The cordinates of the cell\n    self.dist = dist  # Cell's distance from the source\n\ndef __it__(self,other):\n    return id(self) < id(other)\n```\n\nit still gives the same error\nUpdate:\nA workaround to this is to use a list object instead of priority queue and sort it everytime you enter a new element.\nCODE\nq=[]\nAPPENDING\nq.append((heuristics[i][j],queueNodeObject))\nSORTING ON BASIS OF COST\n```\ndef sort(q):\n    #start stop step\n    for i in range(0,q.__len__(),1):\n        for j in range(i+1,q.__len__()-1,1):\n            if q[i][0]<q[j][0]:\n#q[i] returns the element in queue list i.e tuple=(cost, object) q[i][0] returns #the cost\n                temp=q[i]\n                q[i]=q[j]\n                q[j]=temp\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue in Linked List Test Cases\r\n                \r\nSo I'm trying to implement a priority queue with a linked list. I think I have the basics together, but for some reason my test cases aren't working. When I run it, the size show up fine, but none of the node values are showing (only an arrow \"->\" pops up once). If anyone could help me figure out why it isn't working, or suggest a better way to set up test cases in java (I've never done that before) it would be appreciated!\n\nNode class:\n\n```\npublic class Node {     //Node class structure\n\n    int data;   //data contained in Node; for assignment purposes, data is an int\n    Node next;  //pointer to Next Node\n\n    //Node Constructor\n    public Node(int data) {    \n        this.data = data;\n        next = null;\n    }\n\n    //Set Methods\n    public void setData(int data) {         //set Node value\n        this.data = data;\n    }\n    public void setNext(Node next) {        //set next Node value\n        this.next = next;\n    }   \n\n    //Get Methods\n    public int getData() {                  //get Node value\n        return this.data;\n    }   \n    public Node getNext() {                 //get next Node value\n        return this.next;\n    }\n\n    //Display the Node Value\n    public void displayNode() {\n        System.out.println(data + \"urgh\");  //display value as a string\n    }\n}\n```\n\n\nLinked List Class:\n\n```\nimport Question1.Node;\n\n//basic set-up of a FIFO singly linked list\npublic class SLList{\n\n    protected Node head;    //head of SLList\n    protected Node tail;    //tail of SLList\n    int n;      //number of elements in SLList\n\n    //SLList constructor\n    public SLList() {\n        head = null;\n        n = 0;\n    }   \n\n    //check if list is empty\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    //return the size of the list\n    public int size() {\n        return n;           \n    }\n\n    //add a new node to the end of the list\n    public boolean insert(int x){\n        Node y = new Node(x);\n\n        if (head == null){  //if head is null, thus an empty list\n            head = y;       //assign head as y\n        }\n        else{               //if there is already a tail node\n            tail.next = y;  //assign the tail's pointer to the new node\n        }\n        tail = y;           //assign tail to y\n        this.n++;           //increment the queue's size\n        return true;        //show action has taken place\n    }\n\n    //remove and return node from head of list\n    public Node remove(){\n        if (n == 0){            //if the list is of size 0, and thus empty\n            return null;        //do nothing\n        }\n        else{                           //if there are node(s) in the list\n            Node pointer = head;        //assign pointer to the head\n            head = head.next;           //reassign head as next node,               \n            n--;                        //decrement list size\n            return pointer;             //return the pointer\n        }       \n    }\n\n    //display SLList as string\n    public void displayList() {\n        Node pointer = head;\n\n        while (pointer != null) {\n            pointer.displayNode();\n            pointer = pointer.next;\n        }\n        System.out.println(\" \");\n    }\n}\n```\n\n\nPriority Queue Class:\n\n```\nimport Question1.Node;\nimport Question1.SLList;\n\npublic class PriorityQueue extends SLList {\n\n    private SLList list;        //SLList variable\n\n    public PriorityQueue(){     //create the official SLList\n        list = new SLList();\n    }\n\n    //add a new node; new add method that ensures the first element is sorted to be the \"priority\"\n    public boolean add(int x){\n        Node y = new Node(x);\n\n        if (n == 0){        //if there are 0 elements, thus an empty list\n            head = y;       //assign head as y\n        }\n        else if (y.data < head.data){   //if new node y is the smallest element, thus highest priority\n            y.next = head;              //assign y's next to be current head of queue\n            head = y;                   //reassign head to be actual new head of queue (y)\n        }\n        else{               //if there is already a tail node\n            tail.next = y;  //assign the tail's pointer to the new node\n        }\n        tail = y;           //assign tail to y\n        n++;                //increment the queue's size\n        return true;        //show action has taken place\n    }\n\n    //delete the minimim value (highest priority value) from the queue and return its value\n    public Node deleteMin(){\n        return list.remove();       //the list is sorted such that the element being removed in indeed the min\n    }\n\n    //return the size of the queue\n    public int size() {\n        return n;           \n    }\n\n    //display Queue as string\n    public void displayQueue() {\n        System.out.println(\"->\");\n        list.displayList();\n    }\n}\n```\n\n\nTest Cases (so far, the delete one wasn't working so it's commented out):\n\n```\nimport Question1.PriorityQueue;\n\npublic class TestQ1 {           //Test code\n\n    public static void main(String[] args){\n        PriorityQueue PQueue1 = new PriorityQueue();\n\n        PQueue1.add(3);\n        PQueue1.add(2);\n        PQueue1.add(8);\n        PQueue1.add(4);\n\n        System.out.println(\"Test add(x): \");\n        PQueue1.displayQueue();\n        System.out.println(\"Test size(): \" + PQueue1.size());\n\n        PriorityQueue PQueue2 = new PriorityQueue();\n        //Node node1 = PQueue1.deleteMin();\n\n        System.out.println(\"Test deleteMin():\");\n        PQueue2.displayQueue();\n        System.out.println(\"Test size(): \" + PQueue2.size());\n    }   \n}\n```\n\n    ", "Answer": "\r\nChange ```\nlist.displayList()```\n to ```\ndisplayList()```\n, and you'll see the expected output.\n\n\n\nWhy? Because your queue is already a list (that is, an instance of ```\nSLList```\n). When a class ```\nA```\n extends another class ```\nB```\n, an instance of ```\nA```\n is also an instance of ```\nB```\n. This is inheritance.\n\nYou've also included an instance variable ```\nprivate SLList list```\n within your ```\nPriorityQueue```\n implementation, which is an example of composition. Generally you'll only do one or the other of these two options, depending on your situation. In this case it seems you're trying to use inheritance, so there's no reason to create a separate ```\nlist```\n instance variable. You're adding the data directly to the queue (using the fact that, intrinsically, it is a list in its own right).\n\nYou should remove the ```\nlist```\n instance variable, and all the usages of it should refer to the parent class' methods or variables.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue in Linked List Test Cases\r\n                \r\nSo I'm trying to implement a priority queue with a linked list. I think I have the basics together, but for some reason my test cases aren't working. When I run it, the size show up fine, but none of the node values are showing (only an arrow \"->\" pops up once). If anyone could help me figure out why it isn't working, or suggest a better way to set up test cases in java (I've never done that before) it would be appreciated!\n\nNode class:\n\n```\npublic class Node {     //Node class structure\n\n    int data;   //data contained in Node; for assignment purposes, data is an int\n    Node next;  //pointer to Next Node\n\n    //Node Constructor\n    public Node(int data) {    \n        this.data = data;\n        next = null;\n    }\n\n    //Set Methods\n    public void setData(int data) {         //set Node value\n        this.data = data;\n    }\n    public void setNext(Node next) {        //set next Node value\n        this.next = next;\n    }   \n\n    //Get Methods\n    public int getData() {                  //get Node value\n        return this.data;\n    }   \n    public Node getNext() {                 //get next Node value\n        return this.next;\n    }\n\n    //Display the Node Value\n    public void displayNode() {\n        System.out.println(data + \"urgh\");  //display value as a string\n    }\n}\n```\n\n\nLinked List Class:\n\n```\nimport Question1.Node;\n\n//basic set-up of a FIFO singly linked list\npublic class SLList{\n\n    protected Node head;    //head of SLList\n    protected Node tail;    //tail of SLList\n    int n;      //number of elements in SLList\n\n    //SLList constructor\n    public SLList() {\n        head = null;\n        n = 0;\n    }   \n\n    //check if list is empty\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    //return the size of the list\n    public int size() {\n        return n;           \n    }\n\n    //add a new node to the end of the list\n    public boolean insert(int x){\n        Node y = new Node(x);\n\n        if (head == null){  //if head is null, thus an empty list\n            head = y;       //assign head as y\n        }\n        else{               //if there is already a tail node\n            tail.next = y;  //assign the tail's pointer to the new node\n        }\n        tail = y;           //assign tail to y\n        this.n++;           //increment the queue's size\n        return true;        //show action has taken place\n    }\n\n    //remove and return node from head of list\n    public Node remove(){\n        if (n == 0){            //if the list is of size 0, and thus empty\n            return null;        //do nothing\n        }\n        else{                           //if there are node(s) in the list\n            Node pointer = head;        //assign pointer to the head\n            head = head.next;           //reassign head as next node,               \n            n--;                        //decrement list size\n            return pointer;             //return the pointer\n        }       \n    }\n\n    //display SLList as string\n    public void displayList() {\n        Node pointer = head;\n\n        while (pointer != null) {\n            pointer.displayNode();\n            pointer = pointer.next;\n        }\n        System.out.println(\" \");\n    }\n}\n```\n\n\nPriority Queue Class:\n\n```\nimport Question1.Node;\nimport Question1.SLList;\n\npublic class PriorityQueue extends SLList {\n\n    private SLList list;        //SLList variable\n\n    public PriorityQueue(){     //create the official SLList\n        list = new SLList();\n    }\n\n    //add a new node; new add method that ensures the first element is sorted to be the \"priority\"\n    public boolean add(int x){\n        Node y = new Node(x);\n\n        if (n == 0){        //if there are 0 elements, thus an empty list\n            head = y;       //assign head as y\n        }\n        else if (y.data < head.data){   //if new node y is the smallest element, thus highest priority\n            y.next = head;              //assign y's next to be current head of queue\n            head = y;                   //reassign head to be actual new head of queue (y)\n        }\n        else{               //if there is already a tail node\n            tail.next = y;  //assign the tail's pointer to the new node\n        }\n        tail = y;           //assign tail to y\n        n++;                //increment the queue's size\n        return true;        //show action has taken place\n    }\n\n    //delete the minimim value (highest priority value) from the queue and return its value\n    public Node deleteMin(){\n        return list.remove();       //the list is sorted such that the element being removed in indeed the min\n    }\n\n    //return the size of the queue\n    public int size() {\n        return n;           \n    }\n\n    //display Queue as string\n    public void displayQueue() {\n        System.out.println(\"->\");\n        list.displayList();\n    }\n}\n```\n\n\nTest Cases (so far, the delete one wasn't working so it's commented out):\n\n```\nimport Question1.PriorityQueue;\n\npublic class TestQ1 {           //Test code\n\n    public static void main(String[] args){\n        PriorityQueue PQueue1 = new PriorityQueue();\n\n        PQueue1.add(3);\n        PQueue1.add(2);\n        PQueue1.add(8);\n        PQueue1.add(4);\n\n        System.out.println(\"Test add(x): \");\n        PQueue1.displayQueue();\n        System.out.println(\"Test size(): \" + PQueue1.size());\n\n        PriorityQueue PQueue2 = new PriorityQueue();\n        //Node node1 = PQueue1.deleteMin();\n\n        System.out.println(\"Test deleteMin():\");\n        PQueue2.displayQueue();\n        System.out.println(\"Test size(): \" + PQueue2.size());\n    }   \n}\n```\n\n    ", "Answer": "\r\nChange ```\nlist.displayList()```\n to ```\ndisplayList()```\n, and you'll see the expected output.\n\n\n\nWhy? Because your queue is already a list (that is, an instance of ```\nSLList```\n). When a class ```\nA```\n extends another class ```\nB```\n, an instance of ```\nA```\n is also an instance of ```\nB```\n. This is inheritance.\n\nYou've also included an instance variable ```\nprivate SLList list```\n within your ```\nPriorityQueue```\n implementation, which is an example of composition. Generally you'll only do one or the other of these two options, depending on your situation. In this case it seems you're trying to use inheritance, so there's no reason to create a separate ```\nlist```\n instance variable. You're adding the data directly to the queue (using the fact that, intrinsically, it is a list in its own right).\n\nYou should remove the ```\nlist```\n instance variable, and all the usages of it should refer to the parent class' methods or variables.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Find 2nd largest element. Two variables vs priority queue for interview\r\n                \r\nA classical interview problem is \"Find 2nd largest element in an array\".\nThe most straight forward way would be to keep track of variables like ```\nlargest```\n, ```\nsecondLargest```\n, and iterate over, O(n) time complexity, and O(1) space complexity.\nAnother option would be to keep priority queue implemented by using heap size 2 (or K), and get the elements the heap, after you iterate. For each iteration, I am adding to queue size of 2, so the time complexity is O(n*log(K)), where K is 2, so it is technically O(n).\nHere is argument from each side:\nTwo variables:\n\nsimple for loop\nthinking about going beyond k=2 is a \"You Aren't Gonna Need It (YAGNI)\" problem.\nSome O(n) are better solutions, if it requires less computations.\n\nPriority queue:\n\noverhead of heap exists and it affects the coefficient in the time complexity. But we drop constants in complexity analysis, so it is technically a linear solution.\nBut can be easily modified for find kth largest element.\nIt isn't that much more difficult to implement it.\n\nMy point of view is that the two variables version is definitely more performant and simple for this specific question, but I have slight preference toward the heap version because even with some expense and extra code, it can be easily scaled. I don't think the scope is big enough to consider using heap a \"YAGNI\".\nAssuming back and forth discussion has been done during the interview, which one would you prefer?\nEdit: As mentioned in the comments/answer section, I have specified priority queue with heap implementation.\n    ", "Answer": "\r\nIf you look at the definition for priority queue, it basically states:\n\nA priority queue is a special type of queue in which each element is associated with a priority value\n\nNote that no particular data structure is mentioned to implement the priority queue. It is generally done using a heap (like you have assumed in your statement), but that's not always true (here's a priority queue using linked list). As Matt has pointed out in his comment, keeping a track of the largest and second largest element is the same thing as having a priority queue of size 2.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue synchronization with pthreads\r\n                \r\nI'm working on a college assignment where we are to implement parallelized A* search for a 15 puzzle. For this part, we are to use only one priority queue (I suppose to see that the contention by multiple threads would limit speedup). A problem I am facing is properly synchronizing popping the next \"candidate\" from the priority queue.\n\nI tried the following:\n\n```\nwhile(1) {\n  // The board I'm trying to pop.\n  Board current_board;\n\n  pthread_mutex_lock(&priority_queue_lock);\n  // If the heap is empty, wait till another thread adds new candidates.\n  if (pq->heap_size == 0)\n  {\n    printf(\"Waiting...\\n\");\n    pthread_mutex_unlock(&priority_queue_lock);\n    continue;\n  }\n  current_board = top(pq);\n  pthread_mutex_unlock(&priority_queue_lock);\n\n  // Generate the new boards from the current one and add to the heap...\n}\n```\n\n\nI've tried different variants of the same idea, but for some reason there are occasions where the threads get stuck on \"Waiting\". The code works fine serially (or with two threads), so that leads me to believe this is the offending part of the code. I can post the entire thing if necessary. I feel like it's an issue with my understanding of the mutex lock though. Thanks in advance for help.\n\nEdit:\nI've added the full code for the parallel thread below:\n\n```\n// h and p are global pointers initialized in main()\nvoid* parallelThread(void* arg)\n{\n    int thread_id = (int)(long long)(arg);\n    while(1)\n    {\n        Board current_board;\n\n        pthread_mutex_lock(&priority_queue_lock);\n        current_board = top(p);\n        pthread_mutex_unlock(&priority_queue_lock);\n\n        // Move blank up.\n        if (current_board.blank_x > 0)\n        {\n            int newpos = current_board.blank_x - 1;\n            Board new_board = current_board;\n            new_board.board[current_board.blank_x][current_board.blank_y] = new_board.board[newpos][current_board.blank_y];\n            new_board.board[newpos][current_board.blank_y] = BLANK;\n            new_board.blank_x = newpos;\n\n            new_board.goodness = get_goodness(new_board.board);\n            new_board.turncount++;\n\n            if (check_solved(new_board))\n            {\n                printf(\"Solved in %d turns\",new_board.turncount);\n                exit(0);\n            }\n\n            if (!exists(h,new_board))\n            {\n                insert(h,new_board);\n                push(p,new_board);\n            }\n        }\n\n        // Move blank down.\n        if (current_board.blank_x < 3)\n        {\n            int newpos = current_board.blank_x + 1;\n            Board new_board = current_board;\n            new_board.board[current_board.blank_x][current_board.blank_y] = new_board.board[newpos][current_board.blank_y];\n            new_board.board[newpos][current_board.blank_y] = BLANK;\n            new_board.blank_x = newpos;\n\n            new_board.goodness = get_goodness(new_board.board);\n            new_board.turncount++;\n\n            if (check_solved(new_board))\n            {\n                printf(\"Solved in %d turns\",new_board.turncount);\n                exit(0);\n            }\n\n            if (!exists(h,new_board))\n            {\n                insert(h,new_board);\n                push(p,new_board);\n            }\n        }\n\n        // Move blank right.\n        if (current_board.blank_y < 3)\n        {\n            int newpos = current_board.blank_y + 1;\n            Board new_board = current_board;\n            new_board.board[current_board.blank_x][current_board.blank_y] = new_board.board[current_board.blank_x][newpos];\n            new_board.board[current_board.blank_x][newpos] = BLANK;\n            new_board.blank_y = newpos;\n\n            new_board.goodness = get_goodness(new_board.board);\n            new_board.turncount++;\n\n            if (check_solved(new_board))\n            {\n                printf(\"Solved in %d turns\",new_board.turncount);\n                exit(0);\n            }\n\n            if (!exists(h,new_board))\n            {\n                insert(h,new_board);\n                push(p,new_board);\n            }\n        }\n\n        // Move blank left.\n        if (current_board.blank_y > 0)\n        {\n            int newpos = current_board.blank_y - 1;\n            Board new_board = current_board;\n            new_board.board[current_board.blank_x][current_board.blank_y] = new_board.board[current_board.blank_x][newpos];\n            new_board.board[current_board.blank_x][newpos] = BLANK;\n            new_board.blank_y = newpos;\n\n            new_board.goodness = get_goodness(new_board.board);\n            new_board.turncount++;\n\n            if (check_solved(new_board))\n            {\n                printf(\"Solved in %d turns\",new_board.turncount);\n                exit(0);\n            }\n\n            if (!exists(h,new_board))\n            {\n                insert(h,new_board);\n                push(p,new_board);\n            }\n        }\n    }\n\n    return NULL;\n}\n```\n\n    ", "Answer": "\r\n\n  I tried the following:\n\n\nI don't see anything wrong with the code that follows, assuming that ```\ntop```\n also removes the board from the queue. It's wasteful (if the queue is empty, it will spin locking and unlocking the mutex), but not wrong.\n\n\n  I've added the full code\n\n\nThis is useless without the code for ```\nexists```\n, ```\ninsert```\n and ```\npush```\n.\n\nOne general observation:\n\n```\n    pthread_mutex_lock(&priority_queue_lock);\n    current_board = top(p);\n    pthread_mutex_unlock(&priority_queue_lock);\n```\n\n\nIn the code above, your locking is \"ouside\" of the ```\ntop```\n function. But here:\n\n```\n        if (!exists(h,new_board))\n        {\n            insert(h,new_board);\n            push(p,new_board);\n        }\n```\n\n\nyou either do no locking at all (in which case that's a bug), or you do locking \"inside\" ```\nexists```\n, ```\ninsert```\n and ```\npush```\n.\n\nYou should not mix \"inside\" and \"outside\" locking. Pick one or the other and stick with it.\n\nIf you in fact do not lock the queue inside ```\nexists```\n, ```\ninsert```\n, etc. then you have a data race and are thinking of mutexes incorrectly: they protect invariants, and you can't check whether the queue is empty in parallel with another thread executing \"remove top element\" -- these operations require serialization, and thus must both be done under a lock.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Handling Python Priority Queue priority conflicts\r\n                \r\nI'm implementing a PriorityQueue in a program I'm writing. I'm ordering it based off of a timestamp, when each object needs to be executed. I'm trying to find a more efficient way of dealing with two entries having the same timestamp (same priority). \nAs of now, I use a method wherein I keep a record of all the entries in a dict and check the dict everytime; however, it is possible that I could have thousands of entries in the queue and thus the dict would become large and resource intensive to search through.\n\nI believe in other languages there's a way to dead with these kinds of issue in a priority queue. \n\nIs there some way to tell the PriorityQueue that I don't care which order a given entry is placed if it has the same priority as another entry?\n\nI tried finding mention of comparators in the docs, but couldn't find anything useful. \n\nAny help would be greatly appreciated. \n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Enqueue for priority queue not working properly C++\r\n                \r\nFor my Computer Science class I am implementing a ```\ntemplated```\n Priority Queue class and I am struggling to implement the ```\nenqueue```\n function. I know the error is in the ```\nif(value < back)```\n block of the function.\nHere is the Function:\n\n```\ntemplate<class T>\nbool PriorityQueue<T>::enqueue(T& value){\n\n   if(!isEmpty()){\n        if(value < back()){\n        Node<T>* curr = f_ptr;\n        Node<T>* prev = NULL;\n        while(value > curr->data() && curr != NULL){\n            prev = curr;\n            curr = curr->m_next;\n        }\n        if(curr != NULL && value == curr->data()){\n            prev = curr;\n            curr = curr->m_next;\n        }\n        Node<T>* tmp = new Node<T>(value,curr);\n        prev->m_next = tmp;\n        return true;\n        }else{\n            b_ptr->m_next = new Node<T>(value);\n            b_ptr = b_ptr->m_next;\n        }\n   }else{\n    f_ptr = new Node<T>(value);\n    b_ptr = f_ptr;\n    return true;\n   }\n}\n```\n\n\nThe Helper functions are all functioning properly. Please explain what part of my logic is incorrect. \n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Moving elements in a priority queue to a lower level\r\n                \r\nI have a multi-level priority queue which is implemented as a list of (level:int, priority:int, 'a). The datatype looks like this:\n\n```\ndatatype 'a queue = NONE | Q of (int * int * 'a) list;\n```\n\n\nElements at lower level are at the front of the queue. Elements at same level are sorted on basis of priority. I have an enqueue function\n\nSo, if existing queue is:  ```\nval a = Q [(3,2,\"c\"),(3,2,\"d\"),(5,2,\"b\"),(5,3,\"a\")],```\n\nthen, enqueue a 1 5 \"e\"\n gives\n\n```\nval a = Q [(1,5,\"e\"),(3,2,\"c\"),(3,2,\"d\"),(5,2,\"b\"),(5,3,\"a\")]\n```\n\n\nI have to write a function move which operates on a predicate p which moves all elements that satisfy the predicate p to a lower level queue within q.\nThat is : val move : ('a -> bool) -> 'a queue -> 'a queue\nDefinition as below won't work.\n\n```\nfun move pred (Q((l,p,v)::xs)) =  if (pred (v)) then enqueue (Q xs) (l-1) p v else (move pred (Q xs))\n  | move pred (Q[]) = raise Empty\n```\n\n\nI have just started learning sml. Please help.\n    ", "Answer": "\r\nFirst off, having a constructor named ```\nNONE```\n is bad, since it overwrites the\nbuilt-in option-type value of the same name. Secondly, you say that elements for\nwhich the predicate satisfies should be moved to a lower level - is that level\nalways one less than its previous level?\n\nYour ```\nmove```\n will not work because you apparently do not call it recursively\nwhen ```\npred v```\n is true, only when it isn't. If you instead enqueue ```\n(l,p,v)```\n into\na queue on which ```\nmove pred```\n is called recursively (i.e. ```\nmove pred (Q xs)```\n\nrather than ```\nQ xs```\n), perhaps it will work better.\n\nNote also that this problem is ideal for solving through folding:\n\n```\nfun move pred (Q elems) =\n    let fun enq ((l,p,v), q) = enqueue q (if pred v then l-1 else l) p v\n    in foldl enq (Q []) elems end\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Writing a priority queue with a max heap structure in c++\r\n                \r\nI am writing a priority queue with a max heap structure as an assignment for school. I can either write it as an array or I can use a vector. I chose a vector. So the assignment is this, the user chooses options from a menu where he either wants to add,print, or view the elements. When the user chooses to add he gets ask who wants to be added, the instructor, student, or TA. He can enter i,I,t,T,S,s. The instructor having the highest priority where if the user chooses the option to print and there is an instructor in the queue he gets to go first. The TA having the second highest priority where if there is a TA and a student in the queue, the TA goes first. If there is is more than one instructor than the queue acts as a normal queue. I have written most of it, or tried. I got my max heap implementation from my textbook since they provide one. Now the problem is this, when I have more than one item in the priority queue and I choose to print, it crashes and gives me a vector subscript out of range exception. I been trying to fix it and no luck. Also, when I try to print the elements in the queue or print them, it needs to say the job# with the name of the person. Can someone help me find a way to implement that. \n\n```\n#pragma once\n#include <vector>\n\nstruct Heap\n{\n    std::vector<int> m_elements;\n\n    void ReHeapDown(int, int);\n    void ReHeapUp(int, int);\n    void Swap(int& a, int& b);\n};\n\n    #include \"heap.h\"\n\nvoid Heap::ReHeapDown(int index, int bottom)\n{\n    int maxChild, rightChild, leftChild;\n\n    leftChild = index * 2 + 1;\n    rightChild = index * 2 + 2;\n\n    if (leftChild <= bottom)\n    {\n        if (leftChild == bottom)\n            maxChild = leftChild;\n        else\n        {\n            if (m_elements[leftChild] <= m_elements[rightChild])\n                maxChild = rightChild;\n            else\n                maxChild = leftChild;\n        }\n        if (m_elements[index] < m_elements[maxChild])\n        {\n            Swap(m_elements[index], m_elements[maxChild]);\n            ReHeapDown(maxChild, bottom);\n        }\n    }\n}\n\nvoid Heap::ReHeapUp(int index, int bottom)\n{\n    int  parent;\n\n    if (bottom  > index)\n    {\n        parent = (bottom - 1) / 2;\n        if (m_elements[parent]  <  m_elements[bottom])\n        {\n            Swap(m_elements[parent], m_elements[bottom]);\n            ReHeapUp(index, parent);\n        }\n    }\n}\n\nvoid Heap::Swap(int& a, int& b)\n{\n    int temp;\n    temp = a;\n    a = b;\n    b = temp;\n}\n\n    #include <iostream>\n#include \"heap.h\"\n#pragma once\n\nclass PQTYPE\n{\n\nprivate:\n    Heap m_Items;\n\npublic:\n    bool isEmpty() const;\n    void Enqueue(int, std::string);\n    void Dequeue(int, std::string);\n    void printElements();\n};\n\n\n\n#include \"pqtype.h\"\n\nbool PQTYPE::isEmpty() const\n{\n    return m_Items.m_elements.empty();\n}\n\nvoid PQTYPE::Enqueue(int newItem, std::string lName)\n{\n\n    if (lName == \"Student\")\n    {\n        m_Items.m_elements.push_back(newItem);\n        m_Items.ReHeapUp(0, m_Items.m_elements.size() - 1);\n    }\n    else if (lName == \"TA\")\n    {\n        m_Items.m_elements.push_back(newItem);\n        m_Items.ReHeapUp(0, m_Items.m_elements.size() - 1);\n    }\n    else if (lName == \"Instructor\")\n    {\n        m_Items.m_elements.push_back(newItem);\n        m_Items.ReHeapUp(0, m_Items.m_elements.size() - 1);\n    }\n}\n\nvoid PQTYPE::Dequeue(int item, std::string lName)\n{\n    if (isEmpty())\n        std::cout << \"No jobs to print\\n\";\n    else\n    {\n        m_Items.m_elements[0] = m_Items.m_elements.back();\n        std::cout << \"Now printing Job#\" << m_Items.m_elements[item - 1] << \" \" << lName.c_str() << std::endl;\n        m_Items.m_elements.pop_back();\n        m_Items.ReHeapDown(0, item - 1);\n    }\n}\n\nvoid PQTYPE::printElements()\n{\n    if (isEmpty())\n        std::cout << \"No jobs to print\\n\";\n    else\n    {\n        for (int i = 0; i < m_Items.m_elements.size(); i++)\n        {\n            std::cout << \"Job#\" << m_Items.m_elements[i] << std::endl;\n        }\n    }\n}\n\n\n#include\"pqtype.h\"\n\nstruct Person\n{\n    int m_priority;\n    std::string m_name;\n\n    Person()\n    {\n        m_priority = 0;\n        m_name = \" \";\n    }\n};\n\nint showMenu();\nvoid addJobs(PQTYPE&, Person&);\nvoid printJobs(PQTYPE&, Person&);\nvoid viewJobs(PQTYPE&);\n\nint main()\n{\n\n    int option;\n    Person p;\n    PQTYPE pq;\n\n    do\n    {\n        option = showMenu();\n\n        switch (option)\n        {\n        case 1: addJobs(pq, p);\n        break;\n        case 2: printJobs(pq, p);\n        break;\n        case 3: viewJobs(pq);\n        break;\n        case 4:\n        break;\n        default: std::cout << \"Wrong input\\n\";\n        break;\n        }\n\n    } while (option != 4);\n\n\n    return 0;\n}\n\nint showMenu()\n{\n    int choice;\n    std::cout << \" 1.)Add Job\\n\";\n    std::cout << \" 2.)Print Job\\n\";\n    std::cout << \" 3.)View Jobs\\n\";\n    std::cout << \" 4.)Exit\\n\";\n    std::cout << \" Enter Choice: \";\n    std::cin >> choice;\n\n    return choice;\n}\n\nvoid addJobs(PQTYPE& pq, Person& per)\n{\n    char jobChoice;\n\n    std::cout << \"Who is the job for ( Instructor(i or I), TA(t or T), Student(s or S) :\";\n    std::cin >> jobChoice;\n\n    if (jobChoice == 'S' || jobChoice == 's')\n    {\n        per.m_priority++;\n        per.m_name = \"Student\";\n        pq.Enqueue(per.m_priority, per.m_name);\n    }\n    else if (jobChoice == 'T' || jobChoice == 't')\n    {\n        per.m_priority++;\n        per.m_name = \"TA\";\n        pq.Enqueue(per.m_priority, per.m_name);\n    }\n    if (jobChoice == 'I' || jobChoice == 'i')\n    {\n        per.m_priority++;\n        per.m_name = \"Instructor\";\n        pq.Enqueue(per.m_priority, per.m_name);\n    }\n}\n\nvoid printJobs(PQTYPE& pq, Person& p)\n{\n    pq.Dequeue(p.m_priority, p.m_name);\n}\n\nvoid viewJobs(PQTYPE& pq)\n{\n    pq.printElements();\n}\n```\n\n    ", "Answer": "\r\nIn your original code the index used inside Dequeue() for accessing the vector doesn't seem to be initialised in the right way. Let's assume that you have added two entries to your list. In this case the value of P.m_priority inside your main() is 2. Now you're calling printJobs() for the first time. printJobs() calls pq.Dequeue(p.m_priority, p.m_name), so Dequeue() gets p.m_priority as its parameter item. Keep in mind that item has the value 2.\n\n```\nm_Items.m_elements[0] = m_Items.m_elements.back();\nstd::cout << \"Now printing Job#\" << m_Items.m_elements[item - 1] << \" \" << lName.c_str() << std::endl;\nm_Items.m_elements.pop_back();\n```\n\n\nYou're accessing your std::vector using an index of item - 1. This works for the first time, as there are two elements in your list. In this call, there is also a pop_back() done on your list, which decreases its size by one. The next time you call printJobs(), the given parameter item won't have changed, it still has the value 2. When you access your Itemlist, there is no longer an index of 1, and an subscript out of range exception will be thrown.\n\nThere were no fixed priorities assigned to the three entry types in your original version, so I added these (see addJobs() ).\n\nSo a possible solution to store the person's name could look like this:\n\n```\nstruct Person\n{\n    int m_priority;\n    std::string m_name;\n\n    Person()\n    {\n        m_priority = 0;\n        m_name = \" \";\n    }\n};\n\nstruct Heap\n{\n    std::vector<Person> m_elements;\n\n    void ReHeapDown(int, int);\n    void ReHeapUp(int, int);\n    void Swap(Person& a, Person& b);\n};\n\nvoid Heap::ReHeapDown(int index, int bottom)\n{\n    int maxChild, rightChild, leftChild;\n\n    leftChild = index * 2 + 1;\n    rightChild = index * 2 + 2;\n\n    if (leftChild <= bottom)\n    {\n        if (leftChild == bottom)\n            maxChild = leftChild;\n        else\n        {\n            if (m_elements[leftChild].m_priority <= m_elements[rightChild].m_priority)\n                maxChild = rightChild;\n            else\n                maxChild = leftChild;\n        }\n        if (m_elements[index].m_priority < m_elements[maxChild].m_priority)\n        {\n            Swap(m_elements[index], m_elements[maxChild]);\n            ReHeapDown(maxChild, bottom);\n        }\n    }\n}\n\nvoid Heap::ReHeapUp(int index, int bottom)\n{\n    int  parent;\n\n    if (bottom  > index)\n    {\n        parent = (bottom - 1) / 2;\n        if (m_elements[parent].m_priority  <  m_elements[bottom].m_priority)\n        {\n            Swap(m_elements[parent], m_elements[bottom]);\n            ReHeapUp(index, parent);\n        }\n    }\n}\n\nvoid Heap::Swap(Person& a, Person& b)\n{\n    Person temp;\n    temp = a;\n    a = b;\n    b = temp;\n}\n\n#include <iostream>\n\nclass PQTYPE\n{\n\nprivate:\n    Heap m_Items;\n\npublic:\n    bool isEmpty() const;\n    void Enqueue(Person);\n    void Dequeue();\n    void printElements();\n};\n\nbool PQTYPE::isEmpty() const\n{\n    return m_Items.m_elements.empty();\n}\n\nvoid PQTYPE::Enqueue(Person newItem)\n{\n\n    if (!newItem.m_name.compare(\"Student\"))\n    {\n        m_Items.m_elements.push_back(newItem);\n        m_Items.ReHeapUp(0, m_Items.m_elements.size() - 1);\n    }\n    else if (!newItem.m_name.compare(\"TA\"))\n    {\n        m_Items.m_elements.push_back(newItem);\n        m_Items.ReHeapUp(0, m_Items.m_elements.size() - 1);\n    }\n    else if (!newItem.m_name.compare(\"Instructor\"))\n    {\n        m_Items.m_elements.push_back(newItem);\n        m_Items.ReHeapUp(0, m_Items.m_elements.size() - 1);\n    }\n}\n\nvoid PQTYPE::Dequeue()\n{\n    if (isEmpty())\n        std::cout << \"No jobs to print\\n\";\n    else\n    {\n        Person front = m_Items.m_elements.front();\n        std::cout << \"Now printing Job#\" << front.m_priority << \" \" << front.m_name.c_str() << std::endl;\n        m_Items.m_elements.erase(m_Items.m_elements.begin());\n        m_Items.ReHeapDown(0, m_Items.m_elements.size() - 1);\n    }\n}\n\n\nvoid PQTYPE::printElements()\n{\n    if (isEmpty())\n        std::cout << \"No jobs to print\\n\";\n    else\n    {\n        for (int i = 0; i < m_Items.m_elements.size(); i++)\n        {\n            std::cout << \"Job#\" << m_Items.m_elements[i].m_priority << \" \" << m_Items.m_elements[i].m_name.c_str() << std::endl;\n        }\n    }\n}\n\nint showMenu();\nvoid addJobs(PQTYPE&, Person&);\nvoid printJobs(PQTYPE&, Person&);\nvoid viewJobs(PQTYPE&);\n\nint showMenu()\n{\n    int choice;\n    std::cout << \" 1.)Add Job\\n\";\n    std::cout << \" 2.)Print Job\\n\";\n    std::cout << \" 3.)View Jobs\\n\";\n    std::cout << \" 4.)Exit\\n\";\n    std::cout << \" Enter Choice: \";\n    std::cin >> choice;\n\n    return choice;\n}\n\nvoid addJobs(PQTYPE& pq, Person& per)\n{\n    char jobChoice;\n\n    std::cout << \"Who is the job for ( Instructor(i or I), TA(t or T), Student(s or S) :\";\n    std::cin >> jobChoice;\n\n    if (jobChoice == 'S' || jobChoice == 's')\n    {\n        per.m_priority = 0;\n        per.m_name = \"Student\";\n        pq.Enqueue(per);\n    }\n    else if (jobChoice == 'T' || jobChoice == 't')\n    {\n        per.m_priority = 1;\n        per.m_name = \"TA\";\n        pq.Enqueue(per);\n    }\n    if (jobChoice == 'I' || jobChoice == 'i')\n    {\n        per.m_priority = 2;\n        per.m_name = \"Instructor\";\n        pq.Enqueue(per);\n    }\n}\n\nvoid printJobs(PQTYPE& pq)\n{\n    pq.Dequeue();\n}\n\nvoid viewJobs(PQTYPE& pq)\n{\n    pq.printElements();\n}\n\nint main()\nint option;\n    Person p;\n    PQTYPE pq;\n\n    do\n    {\n        option = showMenu();\n\n        switch (option)\n        {\n        case 1: addJobs(pq, p);\n        break;\n        case 2: printJobs(pq);\n        break;\n        case 3: viewJobs(pq);\n        break;\n        case 4:\n        break;\n        default: std::cout << \"Wrong input\\n\";\n        break;\n        }\n\n    } while (option != 4);\n\n    return 0\n}\n```\n\n\nAre you sure that the methods ReHeapUp and ReHeapDown meet your requirements? And shouldn't there be a distinction between job number and priority?\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How do I hide the heap methods from the user when writing a priority queue?\r\n                \r\nI'm following this code to implement a priority queue. The thing I don't like is that when using it in the main method, the user has to call heap.Push and heap.Pop. It would make more sense to me to have my Priority queue contain a heap, rather than wrapping it in a heap. Am I thinking about this wrong, or does the example code show the right way to do it in Golang?\n    ", "Answer": "\r\nI created a wrapper class which calls heap.Push and heap.Pop.\n\n```\npackage huffman\n\nimport \"container/heap\"\n\ntype RunePriorityQueue struct {\n    queue PriorityQueue\n}\n\nfunc (RunePriorityQueue) NewRunePriorityQueue() *RunePriorityQueue {\n    newRPQ := new(RunePriorityQueue)\n    heap.Init(&newRPQ.queue)\n    return newRPQ\n}\n\nfunc (rpq *RunePriorityQueue) Push(item *Item) {\n    heap.Push(&rpq.queue, item)\n}\n\nfunc (rpq *RunePriorityQueue) Pop() *Item {\n    return heap.Pop(&rpq.queue).(*Item)\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "What is an efficient way to read/write a priority queue to a text file?\r\n                \r\nI have a priority queue class that I implemented in Java as it being an array of queues. I need a good way (without using Serialization) of recording and storing the contents of the priority queue after each \"transaction\" or enqueue()/dequeue() of an object from the priority queue. It should serve as a backup in the event that the priority queue needs to be rebuilt by the program from the text file.\n\nSome ideas I had and my problems with each:\n\n\nAfter each \"transaction\", loop through the queues and write each one to a line in the file using delimiters between objects.\n-- My problem with this is that it would require dequeueing and re-enqueueing all the objects and this seems highly inefficient.\nAfter each enqueue or dequeue simply write that object or remove that object from the file.\n-- My problem with this is: if this is the approach I should be taking, I am having a hard time coming up with a way to easily find and delete the object after being dequeued.\n\n\nAny hints/tips/suggestions would be greatly appreciated!\n    ", "Answer": "\r\nTo loop through a queue you can just iterate over it.  This is non-destructive (but only loosely thread safe)\n\nWriting the contents of the queue to disk every time is likely to be very slow.  For a typical hard drive, a small queue will take about 20 ms to write. i.e. 50 times per second at best. If you use an SSD this will be much faster for a small queue, however you still have to marshal your data even if you don't use Serialisation.\n\nAn alternative is to use a JMS server which is designed to support transactions, queues and persistence.  A typical JMS server can handle about 10,000 messages per second. There are a number of good free servers available.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "When is it a bad idea to use a heap for a Priority Queue?\r\n                \r\nIn the section that explains Dijkstra's Algorithm in the book Introduction to Algorithms by Cormen et. al., while analysing the complexity of the algorithm, they say\n\nIf the graph is sufficiently sparse ... we can improve the algorithm by implementing the min priority queue with a binary min heap\n\nSo I was wondering, what is the need for such a statement? Isn't it always wiser to just use heaps for priority queues?\n    ", "Answer": "\r\nThere are many different ways to implement a priority queue. A binary min heap is useful because it performs reasonably well and is easy to implement. But a pairing heap is pretty easy to implement, too, and it has better performance for some operations. In particular, it does a decrease key operation much more quickly than a binary heap does.\n\nOr you could go with a skip list priority queue. A skip list has some nice properties that make it attractive in some priority queue applications. In particular, it's easier to make a concurrent skip list than a concurrent heap.\n\nSo, no, it's not always wiser to use heaps for priority queues. It's almost certainly wiser to use a heap than a sorted list, but there are times when something else is more appropriate than a heap.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I add a tuple (key, value) from AVL Tree to a priority queue in java?\r\n                \r\nnew java developer. I want to build a priority queue, where the elements are the nodes of my AVL tree. the priority queue should order the nodes with the one with the highest value first and the one with the lowest Value last. I tried to create a new class to implement it, but I'm not sure how to create it in a way that indicates that each element in the priority queue is a node in the AVL tree.\nthis is my code so far:\n```\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n    public class PriorityQueue_AVL {\n\n    static class Tuple implements Comparable<Tuple>{\n        String key;\n        int value;\n         \n        public Tuple(String key, int value){\n            this.key = key;\n            this.value = value;\n        }\n \n        //@Override\n        public int compareTo(Tuple node) {\n            return this.value - node.value; //if positive, then this.value is larger so it goes first, and vice versa\n        }\n```\n\nRight below the compareTo() method in the above class, I also tried to create a method that iterates through the AVL tree to add each element to the priority queue, but I’m not sure if that's how it should be done. ```\nnode```\n, ```\nkey```\n, and ```\nvalue```\n are all underlined in red in the method:\n```\nstatic void AVLtoPQ(){\n            System.out.println();\n            // push elements into priority queue PQ\n            PriorityQueue<Tuple> PQ = new PriorityQueue<Tuple>();\n            if (AVLTree.node != null) {\n                inOrderTraversal(node.left);\n                PQ.add(new Tuple(key, value));\n                inOrderTraversal(node.right);\n            \n                }\n}\n```\n\nthis is how I'm defining the AVL tree nodes in the AVLTree.java class:\n```\npublic class AVLTree<Key extends Comparable<Key>, Value> {\n\n    private Node root;  // root of the AVL tree\n\n    // A node of the AVL tree\n    public class Node {\n        private Key key;           // key of the node\n        private Value value;       // value of the node\n        private Node left, right;  // left and right subtrees of the node\n        private int height;        // height of the node\n\n        public Node(Key key, Value value) {\n            this.key = key;\n            this.value = value;\n            this.height = 1;\n        }\n    }\n```\n\nwhat's wrong with the code? and how can I fix it? I know I need to \"connect\" the AVLTree.java class to the PriorityQueue_AVL.java class to be able to use the object Node there, but I'm not sure how. also the syntax for the priority queue is off and I can't pinpoint why.\n    ", "Answer": "\r\nI have a few comments to offer, based on the OP's original question and most recent reply.  Since the OP doesn't seem to have a specific technical question, I'm just going to provide some commentary, in hopes of moving them forwards.\nFirst, I would try not to get too hung up on the integration between the AVL tree and PriorityQueue.  It's fine to have this as an end goal, but good implementations of most data structures will be generic enough that they can be easily modified to accept slightly different incoming data types.  You can often accomplish this with generics (which it seems you are already familiar with), but good, flexible class design can also go a long way.  So to start with, I would focus on creating a functional AVL tree that just stores, for example, integers, and then a functional Priority Queue that also just stores integers, and then you can worry about the extra complexity of additional types and interfacing between the two of them once the base functionality works.  That is my personal philosophy though, and there are lots of other viable design strategies here as well.\nSecond, you said \"I'm trying to create a priorityqueue class that takes a the node (a tuple) as input\".  I want to point out that right now, a Node is NOT a Tuple, nor are they related to each other in any way.  It would also be very weird to define a method on your priority queue that accepts an instance of AVLTree::Node; this would be tightly coupling two inherently unrelated data structures together.  If you wanted to extract Node to its own public class, and have it extend Tuple, or something of that nature, that is one option.  But most data structure implementations you see in the real world will be standalone and will utilize either primitive or generic types for their public methods.\nSo to give an example, using some very rough code that will not compile, I would consider this to be a bad implementation:\n```\npublic class PriorityQueue{\n  private LinkedList<Integer> queue;\n\n  // tied too tightly to a different data structure that should be unrelated\n  public void addNodeToPQ(Node node){\n    this.queue.addLast(node.value);  // this isn't really how you would add a value to a PriorityQueue, it's just for example\n  }\n}\n\nPriorityQueue pq = new PriorityQueue();\nAVLTree avlTree = new AVLTree();\npq.addNodeToPQ(avlTree.get(1));\n```\n\nWhile this implementation is cleaner and more extendable\n```\npublic class PriorityQueue{\n  private LinkedList<Integer> queue;\n\n  // Uses a very basic type (Integer), rather than relying on another specialized data structure.  This allows multiple consumers to use your PriorityQueue, not just your AVLTree\n  public void addValueToPQ(Integer value){\n    this.queue.addLast(value); // this isn't really how you would add a value to a PriorityQueue, it's just for example\n  }\n}\n\nPriorityQueue pq = new PriorityQueue();\nAVLTree avlTree = new AVLTree();\npq.addValueToPQ(avlTree.get(1).value);\n```\n\nRegarding errors in your ```\nPriorityQueue_AVL```\n code, I can think of 4 things I would change off the top of my head\n\nNo obvious reason to import HashMap, Map, or PriorityQueue in your class\nPresumably you are going to be instantiating individual Tuple objects, so using ```\nstatic```\n in the class definition is not appropriate and will not work\n```\n@Override```\n should not be commented\nYou were missing a closing ```\n}```\n for your class.\n\nOutside of these, the code compiles just fine for me, so if there are additional syntax errors that you would like help with, some more details will be necessary.\nLastly, I do want to point out that an AVLTree (and also a PriorityQueue to some extent) is a complex data structure.  If you're new to Java (and ESPECIALLY if you are new to programming in general) and you're doing this exercise purely for academic purposes, I suggest starting off by implementing something a little easier (ArrayList and LinkedList come to mind).  But if that isn't the case, disregard.\nIf you have additional, specific questions, I (or others) are likely happy to help, but without more code or details added to your original question, I think the above is pretty much everything I have to offer.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Iterator for a list of sorted lists using a priority queue [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Given K sorted lists of up to N elements in each list, return a sorted iterator over all the items\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 4 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI found the following interview question here.\n\n\n  SortedIterator - consists of List of Lists with sorted int values in\n  each list. You have to give next sorted value when call next().\n  \n  have to implement methods\n  * constructor\n  * next()\n  * hasNext()\n  \n  [ [1, 4, 5, 8, 9], [3, 4, 4, 6], [0, 2, 8] ]\n  \n  next() -> 0, 1, 2, 3, 4, 4, 4...\n\n\nI wrote a quick implementation in Java:\n\n```\npackage com.app;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class SortedIterator implements Iterator<Integer> {\n\n    private final List<Integer> mFlattenedList;\n    private final Iterator<Integer> mIntegerIterator;\n\n    SortedIterator(final List<List<Integer>> lists) {\n        mFlattenedList = flattenLists(lists);\n        mIntegerIterator = mFlattenedList.iterator();\n    }\n\n    private List<Integer> flattenLists(final List<List<Integer>> lists) {\n        final List<Integer> result = new ArrayList<>();\n        for (List<Integer> list : lists) {\n            for (int value : list) {\n                result.add(value);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return mIntegerIterator.hasNext();\n    }\n\n    @Override\n    public Integer next() {\n        return mIntegerIterator.next();\n    }\n}\n```\n\n\nTime: O (K * N) to flatten the input list of lists + O (N*K) to iterate over the flattened list = O (N * K)\n\nSpace: O (N * K) to store the flattened list.\n\nN - number of lists.\n\nK - number of elements in each list.\n\nBut the answer from the link says:\n\n\n  There is a solution with time complexity O(logN) using a priority\n  queue. Maybe an interviewer expected something like that, I don't\n  know.\n\n\nHow is ```\nO (log N)```\n possible? If a priority queue is used, every time we call ```\nhasNext()```\n, we'll need to check if the queue is empty (```\nO(1)```\n). Then we call ```\nnext()```\n which extracts the min element from the queue (```\nO(log (N*K)```\n) for any implementation) according to the table. Since we need to call ```\nnext()```\n N * K times, it takes us ```\nO(N * K * log (N*K)```\n to iterate over all the elements.\n    ", "Answer": "\r\nThe solution's O(logN) complexity is the complexity per element, not the complexity to iterate over all values.\n\nThe solution looks something like this:\n\n\nFirst define a new class called ```\nListValue```\n that stores a value as well as the index of the list it came from. These should be comparable to other ```\nListValue```\n objects using the value.\nConstructor: Initialize a ```\nPriorityQueue<ListValue>```\n called ```\npq```\n and place the first element from each of the N lists into ```\npq```\n.\nnext(): Pop the ```\nListValue```\n at the front of ```\npq```\n. The value inside is the value to be returned, but first, move the next element from that ```\nListValue```\n's list into ```\npq```\n. Complexity is O(log N), since we remove one element and add one element to ```\npq```\n, which contains at most N elements.\n\n\nNote that the solution doesn't keep all N*K values in the priority queue at once, only the single \"next\" value from each of the N lists. Hence, the priority queue has (at most) N elements at all times, so its operations are all O(log N).\n\nTo understand why this works, recall that each list is already sorted, so the minimum unused value must appear at the \"front\" of some list (not including the values already consumed). Then, note that the priority queue contains precisely the \"front\" element of each list -- we force this to happen in ```\nnext()```\n when we add an element to ```\npq```\n from the same list as the element we removed. Therefore, at all times ```\npq```\n will contain the minimum unused value (until all values are exhausted).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Segmentation fault: Implementing Priority Queues in C\r\n                \r\nI'm trying to implement priority. A higher value of variable prior implies a lower priority in my code. Here it is:\n```\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct MinMax_PriorityQueue{\n    int ele, prior;\n    struct MinMax_PriorityQueue *next;\n};\n\nint isEmpty(struct MinMax_PriorityQueue **pq){\n    return ((*pq)==NULL);\n}\n\nint checkPriority(int p){\n    return(p>0);\n}\n\nvoid enqueue(struct MinMax_PriorityQueue **pq, int x, int p){\n    struct MinMax_PriorityQueue *temp=malloc(sizeof(*temp));\n    //struct MinMax_PriorityQueue *temp1=*pq;\n    if(!checkPriority(p)){\n        printf(\"Priority should be greater than 0\");\n        return;\n    }\n    temp->ele=x;\n    temp->prior=p;\n    temp->next=NULL;\n    /*if(isEmpty(pq)){\n        *pq=temp;\n    }\n    while(temp1->next!=NULL){\n        temp1=temp1->next;\n    }*/\n    (*pq)->next=temp;\n    printf(\"The item %d with priority %d has been enqueued into the priority queue\\n\", x, p);\n}\n\nint maxPriority(struct MinMax_PriorityQueue **pq){\n    struct MinMax_PriorityQueue *temp=malloc(sizeof(*temp));\n    temp=*pq;\n    int maxp=temp->prior;\n    while(temp!=NULL){\n        if(temp->prior<=maxp)\n            maxp=temp->prior;\n        temp=temp->next;\n    }\n    return maxp;\n}\n\nvoid dequeue(struct MinMax_PriorityQueue **pq){\n    if(isEmpty(pq)){\n        printf(\"The priority queue is empty. No more elements can be removed!\\n\");\n    }\n    int maxp=maxPriority(pq);\n    struct MinMax_PriorityQueue *temp=*pq;\n    while(temp!=NULL){\n        if(temp->prior==maxp){\n            printf(\"The item %d with priority %d has been dequeued from the priority queue\\n\", temp->ele, temp->prior);\n            free(temp);\n            break;\n        }\n        temp=temp->next;\n    }\n}\n\nvoid minSearch(struct MinMax_PriorityQueue **pq){\n    struct MinMax_PriorityQueue *temp=malloc(sizeof(*temp));\n    temp=*pq;\n    int minp=0;\n    while(temp!=NULL){\n        if(temp->prior>=minp)\n            minp=temp->prior;\n        temp=temp->next;\n    }\n    temp=*pq;\n    while(temp!=NULL){\n        if(temp->prior==minp){\n            printf(\"The element %d has minimum priority\\n\", temp->ele);\n        }\n        temp=temp->next;\n    }\n}\n\nvoid maxSearch(struct MinMax_PriorityQueue **pq){\n    int maxp=maxPriority(pq);\n    struct MinMax_PriorityQueue *temp=*pq;\n    while(temp!=NULL){\n        if(temp->prior==maxp){\n            printf(\"The element %d has maximum priority\\n\", temp->ele);\n        }\n        temp=temp->next;\n    }\n}\n\nvoid display(struct MinMax_PriorityQueue *pq){\n    struct MinMax_PriorityQueue *temp=pq;\n    printf(\"The contents of the priority queue are:\\n\");\n    if(isEmpty(&temp)){\n        printf(\"Nothing to be shown, the priority queue is empty.\\n\");\n        return;\n    }\n    for(int i=0;temp!=NULL;temp=temp->next){\n        if(i){\n            printf(\" ------ \\n\");\n        }\n        printf(\"|  %d  |\\n\", temp->ele);\n        i=1;\n    }\n}\n\nint main()\n{\n    int choice, element, priority;\n    printf(\"LET'S START WITH AN EMPTY QUEUE\\n\\n\");\n    struct MinMax_PriorityQueue *pq=malloc(sizeof(*pq));\n    pq=NULL;\n    while(1){\n        printf(\"\\nMENU\\n\");\n        printf(\"----\\n\");\n        printf(\"\\t1. Enqueue\\n\");\n        printf(\"\\t2. Dequeue\\n\");\n        printf(\"\\t3. Display queue\\n\");\n        printf(\"\\t4. Search minimum priority\\n\");\n        printf(\"\\t5. Search maximum priority\\n\");\n        printf(\"\\t6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        switch(choice){\n            case 1: printf(\"Enter the element to be enqueued: \");\n                    scanf(\"%d\", &element);\n                    printf(\"Enter its priority: \");\n                    scanf(\"%d\", &priority);\n                    enqueue(&pq, element, priority);\n                    break;\n            case 2: dequeue(&pq);\n                    break;\n            case 3: display(pq);\n                    break;\n            case 4: minSearch(&pq);\n                    break;\n            case 5: maxSearch(&pq);\n                    break;\n            case 6: printf(\"Program terminated successfully!\\n\");\n                    return 0;\n            default: printf(\"Invalid input\");\n        }\n    }\n}\n```\n\nUpon enqueuing, I find a segmentation fault in the line: (*pq)->next\nin the enqueue() function. I can't wrap my head around why that is happening. Is it because I took an argument of type ```\nstruct MinMax_PriorityQueue **```\n?\nAny help is appreciated.\n    ", "Answer": "\r\n```\n(*pq)->next=temp;```\n in the ```\nenqueue```\n function causes segfault as ```\n*pq```\n is NULL on the first call.\nYou shouldn't have commented out the check for NULL. You need it.. but like\n```\nif(isEmpty(pq)){\n    *pq=temp;\n    return;      // Add this\n}\n```\n\nBTW:\nThe reason the ```\n*pq```\n is NULL on the first call of ```\nenqueue```\n is this code in ```\nmain```\n\n```\nstruct MinMax_PriorityQueue *pq=malloc(sizeof(*pq));\npq=NULL;    // You set pq back to NULL  (and leaks memory)\n```\n\nBut you shouldn't do the ```\nmalloc```\n in ```\nmain```\n to start with. Simply do:\n```\nstruct MinMax_PriorityQueue *pq=NULL;  // Empty queue\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "priority queues and dijkstra\r\n                \r\nExplain to me how to construct a priority queue and why you have to construct that way as though the limit of my my experiences with priority queues is knowing what a queue is (I have never used one in my life).\n\nWhen I'm looking at this website:\nhttp://comsci.liu.edu/~jrodriguez/cs631sp08/c++priorityqueue.html\n\n```\npriority_queue<Time, vector<Time>, CompareTime> pq;\n```\n\n\nI understand that Time is so that you have a queue of Times, Compare Time is what determines the priority of which a time is placed into the queue, but why does ```\nvector<Time>```\n need to be in the constructor?\n\nAbout Dijkstra:\nI'm implementing a graph as a vector of nodes, which each node containing a list of all its neighbors positions in that vector), so it looks something like this:\n\n```\nclass Node {\n  protected:\n  string name;\n  int value;\n  list<int> nodes\n}\n```\n\n\nHow would I implement this part of Dijkstra:\n\n```\nfor each vertex v in Graph:                                \n    dist[v] := infinity ;                               \n    previous[v] := undefined ;     \n```\n\n\nfor dist[v] = infinity, I'm assuming I set the value of every node to infinity, but what variable would allow me to do that? And for previous[v], what does it mean by undefined?\n    ", "Answer": "\r\nIn C++ int max value could be used as infinite\n\n```\n#include <limits>\n```\n\n\nthen use\n\n```\nint imax = std::numeric_limits<int>::max();\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Iterator for a list of sorted lists using a priority queue [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has an answer here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Given K sorted lists of up to N elements in each list, return a sorted iterator over all the items\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 4 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI found the following interview question here.\n\n\n  SortedIterator - consists of List of Lists with sorted int values in\n  each list. You have to give next sorted value when call next().\n  \n  have to implement methods\n  * constructor\n  * next()\n  * hasNext()\n  \n  [ [1, 4, 5, 8, 9], [3, 4, 4, 6], [0, 2, 8] ]\n  \n  next() -> 0, 1, 2, 3, 4, 4, 4...\n\n\nI wrote a quick implementation in Java:\n\n```\npackage com.app;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class SortedIterator implements Iterator<Integer> {\n\n    private final List<Integer> mFlattenedList;\n    private final Iterator<Integer> mIntegerIterator;\n\n    SortedIterator(final List<List<Integer>> lists) {\n        mFlattenedList = flattenLists(lists);\n        mIntegerIterator = mFlattenedList.iterator();\n    }\n\n    private List<Integer> flattenLists(final List<List<Integer>> lists) {\n        final List<Integer> result = new ArrayList<>();\n        for (List<Integer> list : lists) {\n            for (int value : list) {\n                result.add(value);\n            }\n        }\n        Collections.sort(result);\n        return result;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return mIntegerIterator.hasNext();\n    }\n\n    @Override\n    public Integer next() {\n        return mIntegerIterator.next();\n    }\n}\n```\n\n\nTime: O (K * N) to flatten the input list of lists + O (N*K) to iterate over the flattened list = O (N * K)\n\nSpace: O (N * K) to store the flattened list.\n\nN - number of lists.\n\nK - number of elements in each list.\n\nBut the answer from the link says:\n\n\n  There is a solution with time complexity O(logN) using a priority\n  queue. Maybe an interviewer expected something like that, I don't\n  know.\n\n\nHow is ```\nO (log N)```\n possible? If a priority queue is used, every time we call ```\nhasNext()```\n, we'll need to check if the queue is empty (```\nO(1)```\n). Then we call ```\nnext()```\n which extracts the min element from the queue (```\nO(log (N*K)```\n) for any implementation) according to the table. Since we need to call ```\nnext()```\n N * K times, it takes us ```\nO(N * K * log (N*K)```\n to iterate over all the elements.\n    ", "Answer": "\r\nThe solution's O(logN) complexity is the complexity per element, not the complexity to iterate over all values.\n\nThe solution looks something like this:\n\n\nFirst define a new class called ```\nListValue```\n that stores a value as well as the index of the list it came from. These should be comparable to other ```\nListValue```\n objects using the value.\nConstructor: Initialize a ```\nPriorityQueue<ListValue>```\n called ```\npq```\n and place the first element from each of the N lists into ```\npq```\n.\nnext(): Pop the ```\nListValue```\n at the front of ```\npq```\n. The value inside is the value to be returned, but first, move the next element from that ```\nListValue```\n's list into ```\npq```\n. Complexity is O(log N), since we remove one element and add one element to ```\npq```\n, which contains at most N elements.\n\n\nNote that the solution doesn't keep all N*K values in the priority queue at once, only the single \"next\" value from each of the N lists. Hence, the priority queue has (at most) N elements at all times, so its operations are all O(log N).\n\nTo understand why this works, recall that each list is already sorted, so the minimum unused value must appear at the \"front\" of some list (not including the values already consumed). Then, note that the priority queue contains precisely the \"front\" element of each list -- we force this to happen in ```\nnext()```\n when we add an element to ```\npq```\n from the same list as the element we removed. Therefore, at all times ```\npq```\n will contain the minimum unused value (until all values are exhausted).\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "i want a C++ priority-queue implement, and when the element is popped, the corresponding queue space is released？ [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed last year.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nWhich C++ third-party library implements the queue, and when the element is popped, the corresponding queue space is released？\nc++ stl library support queue.but when i pop() some elements,queue use memory does not be samll.So i want to find a third-party library which can solve this problem.\n    ", "Answer": "\r\nThe C++ standard library has a class that suits your needs: It's ```\nstd::list```\n. Just use its ```\npush_front```\n and ```\npop_back```\n member functions. The memory of any element you pop will immediately be freed.\nNote that this is only worth the trouble if your elements are large. Otherwise, the allocation overhead of the linked list nodes will outweigh the advantage of freeing nodes immediately.\nAlso keep in mind that your ```\nmalloc```\n implementation won't give the memory back to the operating system immediately. (Or at all, really. Looking at you, glibc.) So you may not see the program's memory usage decrease immediately, anyway. However, your program can immediately re-use the memory of any freed nodes.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue Issue\r\n                \r\nAm implementing the A* algorithm based on this tutorials:  \n\n```\ncreate the open list of nodes, initially containing only our starting node\n   create the closed list of nodes, initially empty\n   while (we have not reached our goal) {\n       consider the best node in the open list (the node with the lowest f value)\n       if (this node is the goal) {\n           then we're done\n       }\n       else {\n           move the current node to the closed list and consider all of its neighbors\n           for (each neighbor) {\n               if (this neighbor is in the closed list and our current g value is lower) {\n                   update the neighbor with the new, lower, g value \n                   change the neighbor's parent to our current node\n               }\n               else if (this neighbor is in the open list and our current g value is lower) {\n                   update the neighbor with the new, lower, g value \n                   change the neighbor's parent to our current node\n               }\n               else this neighbor is not in either the open or closed list {\n                   add the neighbor to the open list and set its g value\n               }\n           }\n       }\n   }\n```\n\n\nNow i have two priority Queues for the open list and the closed list.\n\nAfter moving a node from the open list to the closed list, i must generate its neighbours and check them one by one if they are also in the closed list and perform an operation as described above. The problem is i can only peek() only the head of the queue and compare to the generated neighbours. I can't access the rest of the nodes in the queue in order to compare them as well.\n\nMy questions is:\n\nhow can i compare the neighbours to the nodes in the closed list. Or should i use a different data structure for the closed list?\n\nthanks\n    ", "Answer": "\r\nPriorityQueue's main disadvantage is it is only guarantees \"what is the first element\", no guarantees on any other elements [except they are \"bigger\" then the first], so finding an element is an expansive operation. \n\nYou can use a TreeSet to store your states, and then finding the elements will be done in ```\nO(logn)```\n time, instead the ```\nO(n)```\n PriorityQueue offers. You can use the first() method to get the first [lowest] element. To modify an element, you will need first to remove the original [will probably require an additional ```\nHashMap:State->value```\n to store the current value] and then to insert the new node, with its modified value\nNote that you will probably have to rewrite ```\nequals()```\n for your nodes.\n\nAlso note:Though both are ```\nO(logn)```\n, each insert operation in a ```\nTreeSet```\n is usually slower then its equivalent in ```\nPriorityQueue```\n, so if your problem doesn't have to reopen states, this solution can actually be slower. However, in the general case, this is expected to be faster then the alternative, due to the shortened seek time.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Serializing a priority queue with custom items in PHP\r\n                \r\nI'm implementing a customized priority queue based on PHP's SPLPriorityQueue in a Zend Application. It contains custom objects, PriorityQueueItens, instead of pure values aside the priority value. When storing the queue in APC (or memcache) I have to make sure the queue and its items are serializable, so I've set them to implement the Serializable interface using code from the upcoming Zend Framework 2.\n\n```\npublic function serialize()\n{\n    $data = array();\n    while ($this->valid()) {\n        $data[] = $this->current();\n        $this->next();\n    }\n    foreach ($data as $item) {\n        $this->insert($item['data'], $item['priority']);\n    }\n    return serialize($data);\n}\n\npublic function unserialize($data)\n{\n    foreach (unserialize($data) as $item) {\n        $this->insert($item['data'], $item['priority']);\n    }\n}\n```\n\n\nAfter fetching the queue from APC and retrieving the top item in the priority queue, using ```\n$this->extract()```\n, I don't get the item but the array that is created during serialization. \n\nSo, instead of a ```\nPriorityQueueItem```\n, the base class I use for objects stored in the queue, I get an associative array with indices data and priority (similar to the array in the serialize function). To get the actual item I need to retrive the data part of the array instead of treating the returned item as an item, which is how it works when not storing the queue in APC and how I assumed it would work now as well.\n\nIs this a feature of serialization of objects or am I approaching this in a wrong way?\n\nUpdate: The issue here was that I had a separate function that did extra cruft besides the ```\nextract()```\n. This function returned the item as an array, but as soon as I called ```\nextract()```\n explicitly I got the item as expected. Are there certain precautions to take with public functions in objects that have been serialized?\n    ", "Answer": "\r\nYou mixed/switched this probably:\n\nIn your code you are serializing the ```\n$data```\n array, not \"your object\". I'm not entirely sure of this because I do not know what the ```\ninsert()```\n function is for.\n\nBut for the serialize in an object with the ```\nserializable```\n interface you will get back what has been returned from ```\nobject::serialize()```\n. \n\nAs you serialize an array, you will get the serialized array back. PHP in the background is taking care that this was stored as your object.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue returns wrong order\r\n                \r\nI edited a bit the official documentation on Priority Queue and I found an interesting behavior: the order gets messed up.\nSpecifically, I updated this line:\n```\nitem := heap.Pop(&pq).(*Item)\n```\n\nwith this line (now pointing to the implemented method itself)\n```\nitem := pq.Pop().(*Item)\n```\n\n\nResults are now: ```\n03:banana 02:apple 04:pear```\n\n\nWhy are the results different? Why are the 2 methods (heap.Pop and *pq.Pop) named the same if they perform different function. It leads to confusion.\n```\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\n// An Item is something we manage in a priority queue.\ntype Item struct {\n    value    string // The value of the item; arbitrary.\n    priority int    // The priority of the item in the queue.\n    // The index is needed by update and is maintained by the heap.Interface methods.\n    index int // The index of the item in the heap.\n}\n\n// A PriorityQueue implements heap.Interface and holds Items.\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    // We want Pop to give us the highest, not lowest, priority so we use greater than here.\n    return pq[i].priority > pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index = i\n    pq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    old[n-1] = nil  // avoid memory leak\n    item.index = -1 // for safety\n    *pq = old[0 : n-1]\n    return item\n}\n\n// update modifies the priority and value of an Item in the queue.\nfunc (pq *PriorityQueue) update(item *Item, value string, priority int) {\n    item.value = value\n    item.priority = priority\n    heap.Fix(pq, item.index)\n}\n\n// This example creates a PriorityQueue with some items, adds and manipulates an item,\n// and then removes the items in priority order.\nfunc main() {\n    // Some items and their priorities.\n    items := map[string]int{\n        \"banana\": 3, \"apple\": 2, \"pear\": 4,\n    }\n\n    // Create a priority queue, put the items in it, and\n    // establish the priority queue (heap) invariants.\n    pq := make(PriorityQueue, len(items))\n    i := 0\n    for value, priority := range items {\n        pq[i] = &Item{\n            value:    value,\n            priority: priority,\n            index:    i,\n        }\n        i++\n    }\n    heap.Init(&pq)\n\n    // Take the items out; they arrive in decreasing priority order.\n    for pq.Len() > 0 {\n        //item := heap.Pop(&pq).(*Item)\n        item := pq.Pop().(*Item)\n        fmt.Printf(\"%.2d:%s \", item.priority, item.value)\n    }\n}\n```\n\n    ", "Answer": "\r\nIf you observe closly, the ```\nPriorityQueue```\n actually is just a ```\n[]*Item```\n. It is defined in documentation that ```\n// A PriorityQueue implements heap.Interface and holds Items```\n. This heap interface as defined in documentation:\n```\n// Note that Push and Pop in this interface are for package heap's\n// implementation to call. To add and remove things from the heap,\n// use heap.Push and heap.Pop.\ntype Interface interface {\n    sort.Interface\n    Push(x interface{}) // add x as element Len()\n    Pop() interface{}   // remove and return element Len() - 1.\n}\n```\n\nSo clearly, the priority queue uses heap to work properly. Heap has Push and Pop menthod which then use the methods defined by PriorityQueue to sort, store and prioritise the Items in queue.\nWhat you did just displays the list as you stored it. There was no sorting and prioritising happening in the process.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "In Python, how to implement a min-priority queue which maintains the heap invariant when you change the priority of one of its members?\r\n                \r\nI'd like to implement Dijkstra's shortest-path algorithm using a heap data structure. To this end, I'm looking for a heap which automatically sifts its members up and down as required when you change the priority of an element.\n\nSo far I've tried queue.PriorityQueue and Stutzbach's heapdict, but neither seems to have this property as seen from the tests below:\n\n```\nimport queue\nfrom heapdict import heapdict\nimport pytest\n\nclass Node(object):\n    def __init__(self, d):\n        self.d = d\n\n    def __lt__(self, other):\n        return self.d < other.d\n\n\ndef test_priority_queue():\n    node1 = Node(d=5)\n    node2 = Node(d=10)\n    Q = queue.PriorityQueue()\n    Q.put(node1)\n    Q.put(node2)\n    node2.d = 2\n    assert Q.get().d == 2       # Fails because 5 != 2\n\ndef test_heapdict():\n    node1 = Node(d=5)\n    node2 = Node(d=10)\n    hd = heapdict()\n    hd[1] = node1\n    hd[2] = node2\n    node2.d = 2\n    index, node = hd.popitem()\n    assert node.d == 2          # Fails because 5 != 2\n\n\nif __name__ == \"__main__\":\n    pytest.main([__file__])\n```\n\n\nWhen I update the priority of ```\nnode2```\n to ```\n2```\n instead of ```\n10```\n, it should automatically move to the top of the heap, so that the ```\nget```\n/```\npopitem```\n method returns it. I'd like to create a data structure such that a similar test would pass.\n\nI'm struggling a bit to come up with a high-level idea of how to implement this, however. It should probably follow an observer pattern and use a property attribute, but how exactly?\n\nUpdate\n\nAn object that does something similar is pqdict. However, according to its documentation it also doesn't work with mutable objects:\n\n\n  Value mutability. If you use mutable objects as values in a ```\npqdict```\n, changes to the state of those objects can break the priority queue. If this does happen, the data structure can be repaired by calling ```\npq.heapify()```\n. (But you probably shouldn’t be using mutable values in the first place.)\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue that allows event cancelation\r\n                \r\nI'm working on a real-time application centered around a priority queue, which has a twist: I need to support \"cancelations\" of any event sitting in the queue.\n\nObviously the traditional implementation of a priority queue, a heap, doesn't lend itself well to this application because locating an arbitrary item for deletion is O(n).\n\nIf you have a pointer to an item, though, deletion is only O(log n).  I figure I can do this by maintaining a hash table whose nodes are also linked together as a heap.  This should allow for O(log n) insertion, deletion, and pop-max.\n\nThen again, how is that better than a binary search tree?  All operations there are also O(log n), so why maintain a cumbersome dual data structure?\n\nIt also seems to me like a skip list would be better overall; pop-max would be O(1), and other operations would be amortized O(log n).\n\nAnd for some reason I keep coming back to the idea of a beap, which has O(sqrt n) performance for all operations.\n\nI think any of these solutions would work, but my question is... Which would work best in a real-time system that strives to service requests with minimal latency?  Asymptotic analysis is useful, but big-O notation doesn't tell you how expensive an individual operation is.  My data set isn't huge -- a few thousand entries tops -- so although a binary search tree looks better on paper than a beap, the beap may very well outperform it in my case because it doesn't waste time with rebalancing operations.\n\nAnyway, I was hoping someone had similar experiences here.  A priority queue with cancelation support doesn't seem to be well-described, but it doesn't seem to me like it's THAT far-out of a  problem that nobody else has implemented one before.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Grid Engine Queue Priority Setup\r\n                \r\nSon of Grid Engine - version SGE 8.1.9, CentOS 7.\n\nWe want to implement queues with job scheduling priorities, so a job to high priority queue are always schedule ahead of any other low priority queue.\nExplanation:\n3 queues:  High.q, Medium.q and Low.q\nwhen jobs are queued, jobs in High.q needs to go first once resource is available, even they are submitted later. Medium.q jobs can go only if there are no High.q jobs pending. Same for Medium.q jobs scheduled ahead of Low.q.\n\nWe tried setting in each queues like:\nfor High.q:         seq_no                0\n                    priority              0\nfor Medium.q:       seq_no                1\n                    priority              5\nfor Low.q:          seq_no                2\n                    priority              10\n\nOur cluster is setup for:\nqueue_sort_method                 seqno\n(we tried default \"load\" also)\n    ", "Answer": "\r\nHave you looked at job reservations in SGE? ```\n-R y```\n along side job priority might suffice for the purpose you seek \n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How priority queue is used with heap to solve min distance\r\n                \r\nPlease bear with me I am very new to data structures.\n\nI am getting confused how a priroity queue is used to solve min distance. For example if I have a matrix and want to find the min distance from the source to the destination, I know that I would perform Dijkstra algorithm in which with a queue I can easily find the distance between source and all elements in the matrix.\n\nHowever, I am confused how a heap + priority queue is used here. For example say that I start at ```\n(1,1)```\n on a grid and want to find the min distance to ```\n(3,3)```\n I know how to implement the algorithm in the sense of finding the neighbours and checking the distances and marking as visited. But I have read about priority queues and min heaps and want to implement that.\n\nRight now, my only understanding is a priority queue has a key to position elements. My issue is when I insert the first neighbours ```\n(1,0),(0,0),(2,1),(1,2)```\n they are inserted in the pq based on a key (which would be distance in this case). So then the next search would be the element in the matrix with the shortest distance. But with the pq, how can a heap be used here with more then 2 neighbours? For example the children of ```\n(1,1)```\n are the 4 neighbours stated above. This would go against the ```\n2*i```\n and ```\n2*i + 1```\n and ```\ni/2```\n\n\nIn conclusion, I don't understand how a min heap + priority queue works with finding the min of something like distance.\n\n```\n    0 1 2 3\n     _ _ _ _\n0 - |2|1|3|2|\n1 - |1|3|5|1|\n2 - |5|2|1|4|\n3 - |2|4|2|1|\n```\n\n    ", "Answer": "\r\nYou need to use the priority queue to get the minimum weights in every move so the MinPQ will be fit for this.\n\nMinPQ uses internally technique of heap to put the elements in the right position operations such as ```\nsink()```\n ```\nswim()```\n\n\nSo the MinPQ is the data structure that uses heap technique internally\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing a Priority Queue as a Stack Java\r\n                \r\nI've implemented my program but I am getting an exception ```\njava.lang.ClassCastException```\n\n\nThis is the code:\n\n```\nimport java.util.NoSuchElementException;\n\npublic class BasePQStack<Item> implements Stack<Item> {\n\n// TODO: implement this object.\nprivate int N = 0;\nprivate MaxPQ<Compare> pq = new MaxPQ<>();\nprivate int count;\n\npublic BasePQStack() {\n    count = 0;\n\n}\n\n/**\n * entry point for sample output..\n * \n * @param args\n */\npublic static void main(String[] args) {\n    Stack<Integer> S = new BasePQStack<Integer>();\n\n    S.push(new Integer(2));\n    S.push(new Integer(7));\n    Integer W = S.pop();\n    S.push(new Integer(8));\n    S.push(new Integer(5));\n    ;\n    Integer X = S.pop();\n    Integer Y = S.peek();\n    S.push(new Integer(3));\n    Integer Z = S.pop();\n\n    System.out.println(\"Testing: \");\n    System.out.println(W);\n    System.out.println(X);\n    System.out.println(Y);\n    System.out.println(Z);\n}\n\n@Override\npublic Item push(Item item) {\n    Compare x = new Compare(item, count);\n    pq.insert(x);\n    count++;\n    N++;\n\n    return item;\n}\n\n@Override\npublic Item pop() {\n    if (isEmpty())\n        throw new NoSuchElementException(\"no such element\");\n\n    else {\n        Item var = (Item) pq.delMax();\n        N--;\n        return var;\n    }\n}\n\n@Override\npublic Item peek() {\n    if (isEmpty())\n        throw new NoSuchElementException(\"no such element\");\n\n    else {\n        Item var = (Item) pq.delMax();\n        push(var);\n        return var;\n    }\n\n}\n\n@Override\npublic boolean isEmpty() {\n    return N == 0;\n}\n\n@Override\npublic int size() {\n    return N;\n}\n\npublic class Compare implements Comparable<Compare> {\n    private Item value;\n    private int a;\n\n    public Compare(Item value, int a) {\n        this.a = a;\n        this.value = value;\n    }\n\n    @Override\n    public int compareTo(Compare x) {\n        if (this.a > x.a)\n            return 1;\n        if (this.a < x.a)\n            return -1;\n        else\n            return 0;\n    }\n\n    public int getA() {\n        return this.a;\n    }\n\n    public Item getValue() {\n        return this.value;\n    }\n\n    @Override\n    public String toString() {\n        return \"item {\" + \"value = \" + value + \",a = \" + a + '}';\n    }\n}\n```\n\n\n}\n\nThe message I am getting from the console is BasePQStack$Compare cannot be cast to java.lang.Integer. I've tried to do many castings but could not figure anything out as it just led to more error\n\nThe output of the code should be:\n\n7\n\n5\n\n8\n\n3\n    ", "Answer": "\r\nYou should probably replace this line\n\n\n\n```\nItem var = (Item) pq.delMax()\n```\n\n\nWith\n\n\n\n```\nItem var = (Item) pq.delMax().getValue();\n```\n\n\nBecause ```\ndelMax()```\n returns a compare object and you need a Item object.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue with Tuples and Dicts\r\n                \r\nProblem Statement\n\nCurrently I am implementing an A* search algorithm (heavily modified for a particular problem) in Python. As a component of the problem, I need a fast access to the smallest heuristic value in LIFO order. Python's priority queue looked best. My data structure was already a list of dictionaries with parent relations, so it'd be nice to be able to sort those. However, I seem to be having difficulties doing so. For example, I have an example newly dictionary:\n\n```\nqueue = PriorityQueue() # Could be instantiated based on an existing list of dicts\nexampleDict = {\"x\": 10, \"y\": 20, \"f\": 123, \"parent\":{}}\n```\n\n\nI would like to be able to insert this dictionary into the priority queue via a tuple or some like-form\n\n```\nqueue.put((exampleDict[\"f\"], exampleDict))\n```\n\n\nPlease note that I cannot try an external library, so I'm looking for a more native-to-py3 solution.\n\nWhats Happening\n\nI've tried every solution that was obvious to me. Reading the docs, I found that Python allows a tuple in which the second item in the tuple was the dictionary, and the first was the priority:\n\n```\nparent = {'x': 0, 'y': 0, 'parent': False, 'f': 0, 'g': 50, 'wallPassed': 0}\nsomething = (1, {'h': 9, 'x': 0, 'y': 1, 'parent': parent, 'f': 60, 'g': 51, 'wallPassed': 0})\nsomethingElse = (1, {'h': 9, 'x': 1, 'y': 0, 'parent': parent, 'f': 60, 'g': 51, 'wallPassed': 1})\ntest = PriorityQueue()\ntest.put(something)\ntest.put(somethingElse)\n```\n\n\nIt works when inserting one value, but the minute I insert another it fails\n\n```\nTraceback (most recent call last):\n  File \"test.py\", line 8, in <module>\n    test.put(somethingElse)\n  File \"C:\\Users\\champloo11\\AppData\\Local\\Programs\\Python\\Python35-32\\lib\\queue.py\", line 143, in put\n    self._put(item)\n  File \"C:\\Users\\champloo11\\AppData\\Local\\Programs\\Python\\Python35-32\\lib\\queue.py\", line 227, in _put\n    heappush(self.queue, item)\nTypeError: unorderable types: dict() < dict()\n```\n\n\nIs there anything that can be done about this? There doesn't seem to bemuch in the way of documentation regarding the problem, or solving it without frozendict.\n    ", "Answer": "\r\nThe problem is that dictionaries are unorderable types in Python. That is, if you try to run something like:\n\n```\n>>> {'alpha': 1} < {'beta': 2}\n----> 1 {'alpha': 1} < {'beta': 2}\n\nTypeError: unorderable types: dict() < dict()\n```\n\n\nyou'll get a ```\nTypeError```\n. The trick you're trying to employ is to wrap the dictionary up into a tuple whose first element is orderable -- something like a number. Then we can compare them:\n\n```\n>>> (1, {'alpha': 1}) < (2, {'beta': 2})\nTrue\n```\n\n\nNow it pays to look at how Python compares tuples. First, Python compares the first entries of each tuple. In this case, ```\n1 < 2```\n, and Python returns ```\nTrue```\n. But if the first entries are not ordered -- say they are the same -- Python then goes to comparing the second entries. For instance\n\n```\n>>> (1, 42) < (2, 7)\nTrue\n>>> (1, 42) < (1, 88)  # 42 < 88\nTrue\n>>> (1, 42) < (1, 7)   # 42 >= 7\nFalse\n```\n\n\nSo what happens in your example above is that you have two tuples with the same first entry, and the second entry of each is a dictionary. Hence Python compares the first two entries, can't determine an order from them, and then attempts to compare the second entries, which are dictionaries and can't be ordered. In an example,\n\n```\n>>> (1, {'alpha': 1}) < (2, {'beta': 2})\nTrue\n```\n\n\nworks just fine, as we saw above. But changing the first entry of the tuple on the right gives an error:\n\n```\n>>> (1, {'alpha': 1}) < (1, {'beta': 2})\n----> 1 (1, {'alpha': 1}) < (1, {'beta': 2})\nTypeError: unorderable types: dict() < dict()\n```\n\n\n\n\nSo what is the right solution? If you have a way of assigning a unique priority to each dictionary, then the tuple approach will work. But the first entry of each tuple must be unique! Otherwise Python will resort to comparing the second entries, which are dictionaries, and you'll have the same issue again.\n\nIf that isn't possible or desirable, then we have to give Python a way of comparing these two dictionaries. One way of doing this is to create a ```\nPriorityEntry```\n class and define its ```\n__lt__```\n method. To create an instance of this class, you give a priority, which can be ordered, and data, which need not be orderable. Then ```\n__lt__```\n orders two instances of the class by their priorities only, and not by their data. That is:\n\n```\nclass PriorityEntry(object):\n\n    def __init__(self, priority, data):\n        self.data = data\n        self.priority = priority\n\n    def __lt__(self, other):\n        return self.priority < other.priority\n```\n\n\nand so\n\n```\n>>> PriorityEntry(1, {'alpha': 1}) < PriorityEntry(1, {'beta': 2})\nFalse\n>>> PriorityEntry(1, {'alpha': 1}) < PriorityEntry(2, {'beta': 2})\nTrue\n```\n\n\nor, using your data:\n\n```\nparent = {'x': 0, 'y': 0, 'parent': False, 'f': 0, 'g': 50, 'wallPassed': 0}\nsomething = PriorityEntry(1, {'h': 9, 'x': 0, 'y': 1, 'parent': parent, 'f': 60, 'g': 51, 'wallPassed': 0})\nsomethingElse = PriorityEntry(1, {'h': 9, 'x': 1, 'y': 0, 'parent': parent, 'f': 60, 'g': 51, 'wallPassed': 1})\ntest = PriorityQueue()\ntest.put(something)\ntest.put(somethingElse)\n```\n\n\nwhich will now run without raising the error.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue with insert/delmin operations in constant (amortized) running times\r\n                \r\nIs it possible implement a priority queue with O(1) (amortized) running time of operations ```\ninsert```\n and ```\ndelete_min```\n (delete element with the lowest priority) if I know the range of priorities?\n\nI thought of some modification of Fibonacci heap, but it does not seem to work due to the O(logn) amortized running time of ```\ndelete_min```\n.\n\nWould approach similar to bucket-sort do the job?\n    ", "Answer": "\r\nYou can create a hash table that maps each priority to it's current frequency.\n\nWhen you ```\ninsert```\n a priority, you can do it in constant time on average: You find the entry and increment priority's frequency.\n\nWhen you ```\ndelete_min```\n you have to traverse the hash table to find the minimum priority with non zero frequency and then decrement this frequency. But since you have a constant number of distinct priority values, this runs in constant time also. It is of theoretical value though, if the number of priorities is large.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "java queue with dynamic priority flag\r\n                \r\nI need to build a queue where the elements will be added and removed in chronological order by default. But if the client sets the priority flag for the queue I need to be able to pull the elements based on the priority order of the elements.\n\nI am thinking of creating a priority queue backed by a map that keeps track of the queue index in priority order and based on priority flag I can pull the items from the map and pop the item from index from the queue.\n\nHowever with this approach the question will be, weather I create the map by default or only if the flag is set (considering the cost of creating the map on fly being high, I am inclining towards having it by default).\n\nPlease let me know if there is a better way of doing this or if there is an existing implementation that exists.\n\nHere is what I currently have:\n\n```\nimport javax.naming.OperationNotSupportedException;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class DynamicPriorityQueue<ComparableQueueElement> implements IQueue<ComparableQueueElement> {\n\n    private static final int CONSTANT_HUNDRED = 100;\n    private boolean fetchByCustomPriority = false;\n    private final ReentrantLock lock;\n    private final PriorityQueue<ComparableQueueElement> queue;\n    private final PriorityQueue<ComparableQueueElement> customPriorityQueue;\n\n    public DynamicPriorityQueue() {\n        this(null);\n    }\n\n    public DynamicPriorityQueue(Comparator<ComparableQueueElement> comparator) {\n        this.lock = new ReentrantLock();\n        this.queue = new PriorityQueue<>(CONSTANT_HUNDRED);\n        if (comparator != null)\n            this.customPriorityQueue = new PriorityQueue<ComparableQueueElement>(CONSTANT_HUNDRED, comparator);\n        else\n            this.customPriorityQueue = null;\n    }\n\n    public void setFetchByCustomPriority(boolean fetchByCustomPriority) throws OperationNotSupportedException {\n        if (this.customPriorityQueue == null)\n            throw new OperationNotSupportedException(\"Object was created without a custom comparator.\");\n\n        this.fetchByCustomPriority = fetchByCustomPriority;\n    }\n\n    public void push(ComparableQueueElement t) throws InterruptedException {\n        if (this.lock.tryLock(CONSTANT_HUNDRED, TimeUnit.MILLISECONDS)) {\n            try {\n                this.queue.offer(t);\n                if (this.customPriorityQueue != null)\n                    this.customPriorityQueue.offer(t);\n            } finally {\n                this.lock.unlock();\n            }\n        }\n    }\n\n    public ComparableQueueElement peek() {\n        return this.fetchByCustomPriority ? this.queue.peek()\n                : (this.customPriorityQueue != null ? this.customPriorityQueue.peek() : null);\n    }\n\n    public ComparableQueueElement pop() throws InterruptedException {\n        ComparableQueueElement returnElement = null;\n        if (this.lock.tryLock(CONSTANT_HUNDRED, TimeUnit.MILLISECONDS)) {\n            try {\n                if (this.fetchByCustomPriority && this.customPriorityQueue != null) {\n                    returnElement = this.customPriorityQueue.poll();\n                    this.queue.remove(returnElement);\n                }\n                else {\n                    returnElement = this.queue.poll();\n                    if (this.customPriorityQueue != null) {\n                        this.customPriorityQueue.remove(returnElement);\n                    }\n                }\n            } finally {\n                this.lock.unlock();\n            }\n        }\n        return returnElement;\n    }\n}\n```\n\n    ", "Answer": "\r\nI deleted my comments after rereading the question, it may get complicated. You need to turn a fifo (chronological) queue into a priority queue with a flag. Your map would need to be ordered and be able to hold repeated values. Otherwise you would need to search the map to find the highest priority or search the queue. I wouldn't do it.\n\nEDIT\n\nWhat about using a wrapping class:\n\n```\nclass Pointer<T>{\n    T element\n}\n```\n\n\nAnd two queues of Pointers where the queues share the Pointers but they return them differently? The only thing you would need to do is to check that \"element\" is not null (you set it null when it leaves one of the queues. \n\nThe Pointer reference remains in the other queue but you check for null before returning.\n\nEDIT\n\nYour code doesn't have a map.\n\n```\npublic ComparableQueueElement peek() {\n        return this.fetchByCustomPriority ? this.queue.peek()\n                : (this.customPriorityQueue != null ? this.customPriorityQueue.peek() : null);\n    }\n```\n\n\nis not correct. If it is not custom you should peek from this.queue\n\nEDIT\n\nNote that by using a wrapping class you save yourself the remove calls in the other queue. The only overhead added is that you need to check for null when fetching\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Is there a C++ MinMax Heap implementation?\r\n                \r\nI'm looking for algorithms like ones in the stl (```\npush_heap```\n, ```\npop_heap```\n, ```\nmake_heap```\n) except with the ability to pop both the minimum and maximum value efficiently. AKA double ended priority queue. As described here. \n\nAny clean implementation of a double ended priority queue would also be of interest as an alternative, however this question is mainly about a MinMax Heap implementation.\n\nMy google-fu has not been fruitful, but surely, it must exist?\n    ", "Answer": "\r\nIs there a reason you can't use ```\nstd::set```\n? It sounds like that, along with some wrappers to access and remove ```\nset::begin()```\n and ```\n--set::end()```\n will solve the problem. I imagine it will be difficult to find something that can generally do a MinMax Heap much faster than the default implementation of set.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "How can I use priority queue in SWI-Prolog?\r\n                \r\nI am trying to implement the A* algorithm in SWI-Prolog. I have a graph whose each state consists of the following values ```\n(Cost_So_Far, Heuristic, \"Doesn't Matter\", \"Doesn't Matter\", \"Doesn't Matter\")```\n and I want to insert the state into a priority queue according to Heuristic which is an integer. How can I do this?\n    ", "Answer": "\r\nYou can use a \"heap\" library, which is an implementation of the concept of \"priority queue\". There's a heap Prolog implementation by Richard O'Keefe floating around. SWI-Prolog also comes with a heap implementation in its \"heaps\" library by Lars Buitinck. Logtalk (which runs on several Prolog systems, including SWI-Prolog) also includes max- and min-heaps derived from Richard's original implementation. Using the heuristic value as the key as Boris suggested, a heap should be more efficient than a list that you would have to resort every time you add a new pair.\n\nSome useful links:\n\nSWI-Prolog heaps library\n\nLogtalk heap protocol\n\nLogtalk min-heap and max-heap implementations\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Double-ended Priority Queue using a doubly LinkedList\r\n                \r\nI'm trying to implement a Double-ended Priority Queue using a doubly LinkedList \n\n```\npublic class ListDoubleEndedPriorityQueue<AnyType> implements DoubleEndedPriorityQueue<AnyType>{\n\nprivate Comparator<? super AnyType> cmp;\nprivate Node<AnyType> first = null;\nprivate Node<AnyType> last  = null;\nprivate int size = 0;\n```\n\n\nthis is my node class\n\n```\nprivate static class Node<AnyType>{\n\n    private Node<AnyType> next;\n    private Node<AnyType> prev;\n    private AnyType e;\n\n    public Node(AnyType data){\n        next = prev = null;\n        e = data;\n    }\n    public AnyType getElement(){\n        return this.e;\n    }\n    public Node<AnyType> next(){\n        return next;\n    }\n    public Node<AnyType> prev(){\n        return prev;\n    }\n    public Node<AnyType> setNext(Node<AnyType> x){\n        return this.next = x;\n    }\n    public Node<AnyType> setPrev(Node<AnyType> x){\n        return this.prev = x;\n    }\n}\n```\n\n\nAnd I have to implement several methods like this one:\n\n```\n public AnyType findMax ( ){\n    Node<AnyType> curr = first;\n    Node<AnyType> max = first;\n    int i = 0;\n    while(i < size){\n        if(cmp.compare(curr.e, max.e) > 0){\n            max = curr;\n            break;\n        }\n        curr = curr.next();\n    }\n    return max.e;\n}\n```\n\n\naparently the problem is with this statement: cmp.compare(curr.e, max.e)\nbut I have no idea what I'm doing wrong can someone please help me, thanks.\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing Min priority Queue(C++ STL) using user-defined objects\r\n                \r\nI am implementing Prims Algorithm. I have a vector of Edges along with their weights. \nThe problem is, after inserting, the queue does not remain in increasing order according to weight of edges. \n\nThe relevant code is given below:-\n\n```\nstruct weightcomp // To be used solely for priority Queue...\n{\n    bool operator()(Edge &E1, Edge &E2)\n    {\n        if(E1.weight > E2.weight)\n            return true;\n    }\n};\n\nstd::priority_queue<Edge,std::vector<Edge>,weightcomp> PQ; // Priority Queue for Edges\n\nvoid visit(std::vector<Edge> &PMST, int i) // PMST = Vector of edges and i = name of node\n{\n    for(auto iter = PMST.begin();iter != PMST.end();++iter)\n    {\n        if((*iter).u == i || (*iter).v == i)\n        {\n            PQ.push((*iter));\n            (*iter).del = true;  // Mark the vectors elements to be removed.\n        }\n    }\n\n    PMST.erase(std::remove_if(PMST.begin(),PMST.end(),[](Edge e){ return e.del;}),PMST.end()); // Delete the marked elements\n}\n```\n\n\nWhat am I missing in the implementation?\n    ", "Answer": "\r\nYou have undefined behaviour because your comparison doesn't always return a value. You need something along the lines of\n\n```\nbool operator()(const Edge &E1, const Edge &E2) const\n{\n    return E1.weight > E2.weight;\n}\n```\n\n\nWhere I have made the parameters ```\nconst```\n references because a comparison shouldn't modify them, and the operator ```\nconst```\n because it doesn't change the state of the functor.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority queue which can be stored on disk?\r\n                \r\nI need to implement a application which has a priority queue which has more than 100M records. My problem is I am not able to keep all this data in memory, so I need to store it on disk. Is there any cache solution where I can store all this information to disk?\n    ", "Answer": "\r\nI think that you can solve this by using a B-tree with a few minor modifications.\n\nB-trees are specifically designed to store sorted elements on-disk in a way that minimizes the number of disk reads necessary to locate any element. Because they store their elements in sorted order, you can use them as priority queues by performing insertions as normal and finding the minimum element by taking the leftmost element in the tree (i.e. the first element of the leftmost leaf node).\n\nIn a B-tree of order d, you can find the minimum element using O(logd n) disk reads and writes, where n is the total number of elements. Insertions and deletions will also only require O(logd n) disk reads and writes.\n\nHowever, you can significantly speed this up by storing a pointer to the leftmost leaf node in the B-tree. This node will store the minimum key plus other keys close to the minimum. If you have this pointer, you can look up the minimum value in a single disk read by taking the first element in the node. This also speeds up the extract-min operation: you can delete the key directly from that node without having to search for it. There may be some B-tree rebalancing operations necessary to make this work, though you can show that these operations happen so infrequently that the amortized work to do a deletion is only O(1).\n\nIn other words, using a B-tree with a pointer to the leftmost leaf has the following time complexities in terms of disk reads and writes:\n\n\nfind-min: O(1)\ninsert: O(logd n)\nextract-min: O(1) amortized\n\n\nHope this helps!\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Insert element in a priority queue, with priority attribute\r\n                \r\nI have an exercise, where I have to implement a priority queue, using a min-heap.\nHowever I cannot use the PriorityClass library, I have to implement it, by myself.\nI've managed to do it by far, but, my professor, told me that my insert methods is wrong. He told me, to create an Element class, which contains 2 attributes of type T.These two attributes are (T element and T priority). How can I edit my insert method?\n\n```\npackage priorityQueue;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport priorityQueueInterfaces.PriorityQueue;\n\n\npublic class BinaryHeap<T> implements PriorityQueue<T> \n{\nprivate int currentSize = 0;\nprivate static final int DEFAULT_CAPACITY = 20;\nprivate ArrayList<T> array = null;\nprivate Comparator <? super T> comparator = null;\n\n/**\n * Constructor of binary-heap\n */\npublic BinaryHeap(Comparator <? super T> comparator)\n{\n    currentSize = 0;\n    array = new ArrayList<>(DEFAULT_CAPACITY + 1);\n    this.comparator = comparator;\n}\n\n/**\n * Construct the binary heap from an arrayList\n */\npublic BinaryHeap(ArrayList<T> array, Comparator <? super T> comparator)\n{\n    this.currentSize = array.size();\n    this.array = new ArrayList<>(array.size() + 1);\n    this.comparator = comparator;\n\n    for(int i = 0; i < array.size(); i++)\n        this.array.set(i + 1, array.get(i));\n}\n\n/**\n * Method which builds the min heap with the minHeapify method\n * @throws PriorityQueueException\n */\npublic void buildMinHeap(ArrayList<T> array, int heapSize) throws PriorityQueueException\n{\n    for(int i = this.currentSize / 2; i > 0;i--)\n        minHeapify(this.array,i,this.currentSize);\n}\n\n/**\n * Method which builds the max heap with the maxHeapify method\n * @throws PriorityQueueException\n */\npublic void buildMaxHeap() throws PriorityQueueException \n{\n    for(int i = this.currentSize/2; i > 0; i--)\n        maxHeapify(this.array,i,this.currentSize);\n}\n\npublic void buildMaxHeap(ArrayList<T> array, int heapSize)throws PriorityQueueException\n{\n    if(this.array == null)\n        throw new NullPointerException(\"ArrayList is null\");\n    if(this.array.size() <= 0 || heapSize <= 0 )\n        throw new IllegalArgumentException(\"Illegal Parameters: either the arraylist or the heap size are not valid\");\n    if(heapSize > this.array.size())\n        heapSize = this.array.size();\n\n    for(int i = heapSize/2; i > 0; i--)\n        maxHeapify(this.array,i,heapSize);\n}\n\n/**\n * Insert into the priority queue.\n * Duplicates are allowed.\n * @param element is the item to insert.\n */\npublic void insert(T element) throws PriorityQueueException \n{\n    if(element == null)\n        throw new IllegalArgumentException(\"Element to be inserted, cannot be null!\");\n    if(this.size() + 1 == this.array.size())\n        extendArray();\n\n    this.currentSize = this.size() + 1;\n\n    if(this.isEmpty())\n        this.array.add(0,element);\n    else\n    {\n        this.array.add(element);\n        int index = this.size() - 1;//indice index = all'elemento appena aggiunto\n\n        while( index > 1 && this.comparator.compare(this.array.get(index/2), this.array.get(index)) < 0)\n        {\n            swapElements(index, index/2);\n            index = index / 2;\n        }\n    }\n}\n/**\n * @param firstIndex of the element that has to be swapped\n * @param secondIndex of the element that has to be swapped\n * @throws PriorityQueueException\n */\nprivate void swapElements(int firstIndex,int secondIndex)throws PriorityQueueException\n{\n    T temp = this.array.get(firstIndex);\n    this.array.set(firstIndex, this.array.get(secondIndex));\n    this.array.set(secondIndex,temp);\n}\n}   \n```\n\n\nTHAT'S MY ELEMENT CLASS Which I have to use for adding an element with min-priority\n\n```\npackage priorityQueue;\n\npublic class Element<T> \n{\nprivate T element;\nprivate T priority;\n\npublic Element(T element,T priority)\n{\n    this.element = element;\n    this.priority = priority;\n}\n\npublic void setElement(T element)\n{\n    this.element = element;\n}\n\npublic void setPriority(T priority)\n{\n    this.priority = priority;\n}\n\npublic T getElement()\n{\n    return this.element;\n}\n\npublic T getPriority()\n{\n    return this.priority;\n}\n}\n```\n\n\nMy method of insert works just fine, but i have to insert also the priority contained in the class element. How to do it?\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C# Sorting a priority queue based on a linked list\r\n                \r\nI'm developing an implementation of a priority queue using a linked list (nodes) as the underlying data structure. Up to this point, I'm able to enqueue my data from a file of mock data, however my sort method is not working correctly. I suspect the problem is with my references to the head and tail. Note : there are 1000 rows in the CSV I'm reading from.\n```\nusing (var reader = new StreamReader(@file_Path))\n{\n    //creates head of linked list\n    Node newNode = new Node(reader.ReadLine().Split(','), rand.Next(1000));\n    current = head = newNode;\n    while (!reader.EndOfStream)\n    {\n        //creates next node after head until end of file\n        current._right = new Node(reader.ReadLine().Split(','), rand.Next(1000));\n\n        //if the tail exists, the oldest node is the new tail\n        if (tail != null) current._left = tail;\n\n        tail = current;\n        //sets the current node to the next node in the list so while loop continues.\n        current = current._right;\n        //Sort();\n    }\n}\n\npublic static void Dequeue()\n{\n    Sort();\n    if (tail != null)\n    {\n        current = head;\n        while (current != null)\n        {\n            Console.WriteLine(\"LastName: \" + current.Data.last_name + \"\\t\\t\\tFirstName: \" + current.Data.first_name + \" \\t\\tRandomNumber: \" + current.Data.randomValue.value);\n            current = current._right;\n        }\n    }\n}\n\npublic static void Sort()\n{\n    int length = 0;\n    comparable = tail;\n    current = head;\n\n\n    for (int i = 0; i < length; i++)\n    {\n        for (int b = 0; b < length; b++)\n        {\n            while (current != null && comparable != null)\n            {\n                if (current.Data.randomValue.value > comparable.Data.randomValue.value)\n                {\n                    Swap(current, comparable);\n                }\n                if (current.Data.randomValue.value < comparable.Data.randomValue.value)\n                {\n                    Swap(comparable, current);\n                }\n\n                current = comparable._left;\n                break;\n            }\n        }\n\n    }\n}\n```\n\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Using two different priority queues in Golang\r\n                \r\nI am a Gopher Noob. I ran into this question recently regarding implementing priority queues in Golang. I went through https://pkg.go.dev/container/heap@go1.17.3 for implementing a priority queue. All one has to do is implement the heap.Interface for the container. Its straightforward enough and i have no questions about that.\nMy question though is this:\nI need two priority queues. One is a minimum and maximum priority queue. In Java, this is quiet easy is initialize. I just have to change the comparator during initialization and thats it.\nIn golang, I simply have to change the Less method in sort.Interface which is fine. However, I am not interested in writing redundant code and i am looking for cleaner way to create both priority queues.\nHere is an example for what i am looking to do:\n```\n// A PriorityQueue1\n\ntype PriorityQueue1 []*Item\n\n// Implement all the following methods for the min Prioirity queue\nfunc (pq PriorityQueue1) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue1) Less(i, j int) bool {\n    // We want Pop to give us the highest, not lowest, priority so we use greater than here.\n    return pq[i].priority > pq[j].priority\n}\n\nfunc (pq PriorityQueue1) Swap(i, j int) {\n  //Swap\n}\n\nfunc (pq *PriorityQueue1) Push(x interface{}) {\n  //Define push logic\n}\n\nfunc (pq *PriorityQueue1) Pop() interface{} {\n  //Define pop logic\n}\n\nNow, I define the maximum priority queue (**everything is the same except Less**), which goes like this.. \n\n// A PriorityQueue2\n\ntype PriorityQueue2 []*Item\n\n// Implement all the following methods for the max Prioirity queue\nfunc (pq PriorityQueue2) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue2) Less(i, j int) bool {\n    return **pq[i].priority < pq[j].priority**  // Thats it. One line change..\n}\n\nfunc (pq PriorityQueue2) Swap(i, j int) {\n  //Swap\n}\n\nfunc (pq *PriorityQueue2) Push(x interface{}) {\n  //Define push logic\n}\n\nfunc (pq *PriorityQueue2) Pop() interface{} {\n  //Define pop logic\n}\n```\n\nNow why would i have to go through this ordeal of rewriting almost the same methods as that of the min queue for a one line change in Less. I am looking to reduce the boilerplate and i am wondering about what is the cleanest and concise way to go about solving this question. I am also not interested in using any third party libraries (but i am interested in its logic if there is one which provides a clean wrapper).\nPlease provide some inputs. Thanks..\n    ", "Answer": "\r\nYou can inject the function as a dependency to the constructor for the Priority Queue struct.\nIt should work as follows:\n```\ntype Item int\n\ntype PriorityQueue []Item\n\nvar lesser LessFunction\n\nfunc GetPriorityQueue(l LessFunction) PriorityQueue {\n    lesser = l\n    return []Item{}\n}\n\ntype LessFunction func(i, j int) bool\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return lesser(i, j)\n}\n```\n\nUse this in code as follows:\n```\nq := GetPriorityQueue(func(i, j int) bool { return i < j })\n```\n\nPlease note:\nThere are multiple ways you can tackle this apart from what I have shown. This shows the similarity to Java's lambda functions.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C# priority queue, generic type <T> conversion\r\n                \r\n```\npublic class PriorityQueue<T> : IPriorityQueue<T> \n                            where T : IComparable\n```\n\n\nSo, I've made a priority queue class with the Header above and I'm attempting to use it with another class. \n\n```\n        private static PriorityQueue<Order> PQ;\n```\n\n\nIt seems like this should work perfectly fine, but I'm receiving this error. \n\n\n  My ```\nnamespace.Order```\n cannot be used as type parameter ```\nT```\n in the generic method ```\nnamespace.PriorityQueue<T>```\n. There is no implicit conversion from ```\nnamespace.Order```\n to ```\nSystem.IComparable```\n\n\n\nI can't really discern what that is telling me to do. Does this mean that my ```\nIComparable```\n implementation isn't sufficient for this purpose, or is it some sort of bad syntax I'm using?\n    ", "Answer": "\r\nIt says, that your generic type parameter (i.e. ```\nOrder```\n type) should implement IComparable interface.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Java Priority Queue with ArrayLists and Pairs\r\n                \r\nI'm looking for simple way to build a Priority Queue in Java. I've built an ```\nArrayList<Pair>```\n, and each ```\nPair```\n instance contains an ```\nX```\n and ```\nY```\n values.\n```\nclass Pair {\n    private final Float xVal;\n    private final Float yVal;\n\n    public Pair(Float aXVal, Float aYVal) {\n        xVal = aXVal;\n        yVal = aYVal;\n    }\n\n    public float getX() {\n        return xVal;\n    }\n\n    public float getY() {\n        return yVal;\n    }\n}\n```\n\nMy ```\nArrayList```\n looks like:\n```\nArrayList<Pair> listOfPoints;\n```\n\nUsing the ```\nArrayList listOfPoints```\n, I wanted to build two priority queues:\n\nOne that is sorted on the x Values from low to high.\nOne that is sorted on the y Values form low to high.\n\nI was looking for a simple way to do this using Lambda expressions.\nI did look at this question on Stack Overflow, and I found this code:\n```\nPriorityQueue<String> pq=\n                    new PriorityQueue<String>(5,(a,b) -> a.length() - b.length());\n```\n\nI think this is close to what I want.\nI was trying to implement the following:\n```\nPriorityQueue<Pair> xSorted = new PriorityQueue<Pair>(numOfPoints, (x1,x2) -> Need Help Here);\n```\n\nHow do I access Pair in order to have it compare ```\nx1```\n and ```\nx2```\n?\nNote, that ```\nnummberOfPoints```\n I was setting to the length of ```\nArrayList<Pair> listOfPoints```\n.\n    ", "Answer": "\r\nFor the natural (ascending) order based on ```\nxVal```\n:\n```\nPriorityQueue<Pair> pq= new PriorityQueue<>(Comparator.comparingDouble(Pair::getX));\n\n```\n\nFor the reversed (descending) order based on ```\nxVal```\n:\n```\nPriorityQueue<Pair> pq= new PriorityQueue<>(Comparator.comparingDouble(Pair::getX).reversed());\n\n```\n\nYou can use the same approach for ```\nyVal```\n or any other comparable field, by using Comparator API.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++: priority queue with pointer to object does not work correctly\r\n                \r\nI am trying to implement Dijkstra-Algorithm. For that i am using a priority queue storing pointers to objects of the class 'Node' which shall return the node with the lowest distance to the start node. I reduced my code so that it manually edits the distance between start node and current node and extracts element from the priority queue. Normally Dijkstra would do that. The following code does not work correctly:\n\n```\nusing namespace std;\n\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <queue>\n\nconst int numberNodes = 6;\nint IMAX = numeric_limits<int>::max();\n\nclass Node{\npublic:\n    Node(float pdistance, int pid){distance = pdistance;    id = pid;}\n    float distance;\n    int id;     //only for debug\n};\n\nNode** nodes;       //in int main() Array of Node*\n\nclass Compare{  //Compare pointer to nodes based on distance to start node (Dijkstra)\npublic:\n    bool operator() (Node *n1, Node *n2) const {\n        return n1->distance>n2->distance;\n    }\n};\n\npriority_queue<Node*, vector<Node*>, Compare> pq;\n\nint main(){\n    nodes = new Node*[numberNodes];\n    for(int i=0; i<numberNodes; i++){       //create new objects and store them in pq\n        nodes[i] = new Node(IMAX, i);\n        pq.push(nodes[i]);\n    }\n    Node* sNode;        //Start node. not contained in nodes[]\n    sNode = new Node(0, -1);        //distance 0, id -1\n    pq.push(sNode);\n\n    cout << \"extracted: Node \" << (pq.top())->id << \" , distance \" << (pq.top())->distance << endl;\n    pq.pop();\n\n    nodes[0]->distance = 0.5;\n    nodes[1]->distance = 0.5;\n    cout << \"extracted: Node \" << (pq.top())->id << \" , distance \" << (pq.top())->distance << endl;\n    pq.pop();       \n\n    cout << \"extracted: Node \" << (pq.top())->id << \" , distance \" << (pq.top())->distance << endl;\n    pq.pop();   \n\n    nodes[2]->distance = 2.5;\n    nodes[3]->distance = 3.5;\n    cout << \"extracted: Node \" << (pq.top())->id << \" , distance \" << (pq.top())->distance << endl;\n    pq.pop();   \n}\n```\n\n\nIt returns:\n\n```\nextracted: Node -1 , distance 0\nextracted: Node 0 , distance 0.5\nextracted: Node 1 , distance 0.5\nextracted: Node 5 , distance 2.14748e+09\n```\n\n\nThree times the pq works correctly, but at the end it should return Node 2 with distance 2.5.\n\nSo how can i make it work?\n\nThanks for answers\n    ", "Answer": "\r\nSince you are popping out the elements of your priority_queue its size is beeing reduced, since the line:\n\nnodes[2]->distance = 2.5;\nnodes[3]->distance = 3.5;\n\nShould be changed to:\n\nnodes[0]->distance = 2.5;\nnodes[1]->distance = 3.5;\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Min/Max Heap or Priority Queue data structure in Objective-C\r\n                \r\nIs there Min/Max Heap or Priority Queue like data structure provided by the system framework in Objective-C?\n\nI can implement it myself or use a third party library, but I'm just curious if the system has already provide it like Java does.\n    ", "Answer": "\r\nFor priority queues: No. There is no generic standard in Cocoa, even classes as ```\nNSOperationQueue```\n uses priority queues.\n\nFor min-max heaps: No. And you will never find. A min-max heap is a structure to implement a priority queue. Cocoa's APIs are never built on top of an implementation, but from the final collection. I. e. you have ```\nNSArray```\n for ordered collections. There are several structures used for implementing that array. But you always get the final product ```\nNSArray```\n independent of the structure used internally.\n\nThis is a design principle of Cocoa.\n\nSo, if someone (Apple, someone else, you) implements a priority queue, he likely uses min-max heaps. But you will never know, if it is implemented according to the concepts of Cocoa.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "C++ Priority queue to find and modify objects\r\n                \r\nI am trying to implement an A* algorithm and I need a priority queue, but the the ```\nstd::priority_queue```\n doesn't work for me because I need to find whether an element(a ```\nNode```\n object) is in the ```\npriority_queue```\n or not, to access its data and to modify it if necessary. \n\nCan I do this using the ```\nstd::priority_queue```\n somehow? \n\nI would appreciate code suggestions since I don't have much experience with ```\nstd::priority_queue```\n. \n    ", "Answer": "\r\n\n  \"but the the stl::priority_queue doesn't work for me because I need to find whether an element(a Node object) is in the priority_queue or not, to access its data and to modify it if necessary.\"\n\n\nYou can well do this for any kind of class providing an appropriate ```\nCompare```\n class parameter.\n\n```\nstd::priority_queue<T>```\n requires the underlying ```\nContainer```\n to comply with the concept of a ```\nSequenceContainer```\n.\n\n```\ntemplate<\n    class T,\n    class Container = std::vector<T>,\n    class Compare = std::less<typename Container::value_type>\n> class priority_queue;\n```\n\n\nyou can take the address of the ```\nstd::priority_queue<T>::front()```\n reference, and iterate through the queue, to find certain instances.\n\n\n\nIf you really need to have uniquely existent instances of objects, that should be managed additionally by some priority algorithm, it could be a good idea to store smart pointers (e.g. ```\nstd::shared_ptr<T>```\n), rather than values or raw pointers. The ```\nCompare```\n class needs to be adapted appropriately of course.\n\n\n\n```\nstruct CompareNodes {\n    bool operator\n        ( const std::shared_ptr<Node>& lhs\n        , const std::shared_ptr<Node>& rhs\n        ) {\n        // Provide some operation to compare lhs < rhs (less) results in true\n        // This function is meant to determine the actual priority of your Node\n        // instances, when referenced in the priority_queue<> in question.\n    }\n};\n\nstd::priority_queue\n    < std::shared_ptr<Node>\n    , std::vector<std::shared_ptr<Node>>\n    , CompareNodes\n    > myQueue;\n```\n\n\n\n\n\n  \"to access its data and to modify it if necessary.\"\n\n\nUsing the priority queue with ```\nstd::shared_ptr```\n as shown in the above sample, may also release you from even need to find instances in the queue, and synchronize data modifications from the original instance.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "java priority queue to queue adaptation\r\n                \r\nI have a priority queue that lists aload of jobs from an sql database in date order. I then have get the closestDeadlineJob function below that gets the top job, checks if any other jobs have the same date then compare priorities to see which is the top job. I then get returned the top job.\n\nFind original queue top job:\n\n```\npublic JobRequest closestDeadlineJob(int freeCPUS) {\n        // find top job to determine if other jobs for date need to be considered\n        JobRequest nextJob = scheduledJobs.peek(); // return top most job\n\n        if (nextJob != null) {\n\n            System.out.println(\"Found top EDF job:\");\n            printJob( nextJob );\n\n            // what is it's date?\n            Date highestRankedDate = nextJob.getConvertedDeadlineDate();\n\n            // create a temporary queue to work out priorities of jobs with same deadline\n            JobPriorityQueue schedulerPriorityQueue = new JobPriorityQueue();\n\n            // add the top job to priority queue\n            //schedulerPriorityQueue.addJob(nextJob);\n\n            for (JobRequest jr : scheduledJobs) {\n\n                // go through scheduled jobs looking for all jobs with same date\n                if (jr.getConvertedDeadlineDate().equals(highestRankedDate)) {\n                    // same date deadline, soadd to scheduler priority queue\n                    schedulerPriorityQueue.addJob(jr);\n                    System.out.println(\"Adding following job to priority queue:\");\n                    printJob(jr);\n                }\n            }\n\n            JobRequest highestPriorityJob = schedulerPriorityQueue.poll();\n            // this is the item at the top of the PRIORTY JOB queue to return \n\n            // remove that item from scheduledJobs\n            scheduledJobs.remove(highestPriorityJob);\n\n\n            return highestPriorityJob;\n        } else {\n            return null;\n        }\n    }\n```\n\n\nfollowing code to process top jobs into a queue:\n\n```\n    public void processNextJob() {\n        /*\n         * 1. get # of free CPU's still avaialble\n         * 2. get top most job from priority queue\n         * 3. run job - put to CPU queue\n         * 4. develop a CPU queue here\n         * 5. count cores against freeCPUS and some sort of calculation to sort run times\n         */\n        int freeCPUS = 500;\n        int availableCPUS = 0;\n        Queue q = new PriorityQueue();\n\n//        while(freeCPUS >= 500)\n//        {\n//           \n//        }\n\n\n        JobRequest nextJob = schedulerPriorityQueue.closestDeadlineJob(freeCPUS); // returns top job from queue\n        if (nextJob != null) {\n            System.out.println(\"Top priority / edf job:\");\n            System.out.print(nextJob.getUserID() + \"-->\");\n            System.out.print(nextJob.getStartDate() + \"--START-->\");\n            System.out.print(nextJob.getEndDate() + \"---END-->\");\n            System.out.print(nextJob.getDeadDate() + \"--DROP-->\");\n            System.out.print(nextJob.getDepartment() + \"-->\");\n            System.out.print(nextJob.getProjectName() + \"-->\");\n            System.out.print(nextJob.getProjectApplication() + \"-->\");\n            System.out.print(nextJob.getPriority() + \"--PRIORITY-->\");\n            System.out.print(nextJob.getCores() + \"-->\");\n            System.out.print(nextJob.getDiskSpace() + \"-->\");\n            System.out.println(nextJob.getAnaylsis());\n\n            // now got correct job based on earliest deadline / priority\n            // implement a FIFO queue here / execution stack\n            // add next job here\n        } else {\n            System.out.println(\"Job = null\");\n        } \n\n    }\n```\n\n\nWhat I need to do is fix my poor attempt or adaptation at putting jobs from my closestDeadlineJob into a queue then stop putting them in a queue when I reach my 500 core limit. at the moment I just get stuck in the for loop below the while true and I don't think the way I've set out would even work after leaving the loop.\n\nAny thoughts?\n\nEDIT\n\n```\npublic void processNextJob() {\n        /*\n         * 1. get # of free CPU's still avaialble\n         * 2. get top most job from priority queue\n         * 3. run job - put to CPU queue\n         * 4. develop a CPU queue here\n         * 5. count cores against freeCPUS and some sort of calculation to sort run times\n         */\n        int freeCPUS = 500;\n        int availableCPUS = 0;\n\n        JobRequest nextJob = schedulerPriorityQueue.closestDeadlineJob(freeCPUS); // returns top job from queue\n        if (nextJob != null) {\n            System.out.println(\"Top priority / edf job:\");\n            printJob( nextJob );\n            // go through scheduled jobs looking for all jobs with same date\n            if (nextJob.getCores() <= freeCPUS) {\n                // same date deadline, soadd to scheduler priority queue\n                schedulerPriorityQueue.addJob(nextJob);\n                System.out.println(\"Adding following job to execution queue:\");\n                printJob( nextJob );     \n                // can use this to get the next top job but need to add calculations to printout the next top job aslong as CPU less than 500\n//                schedulerPriorityQueue.closestDeadlineJob(freeCPUS);\n//                schedulerPriorityQueue.addJob(nextJob);\n            } else if (nextJob.getCores() > freeCPUS) {\n                System.out.println(\"Queue temporarily full\");\n            }\n            // now got correct job based on earliest deadline / priority\n            // implement a FIFO queue here / execution stack\n            // add next job here\n        } else {\n            System.out.println(\"Job = null\");\n        }\n\n    }\n```\n\n\nI imagine I need to implement a loop above and move out the if statements saying take next job, if under 500, loop through again and get another then put it into a new queue of some sort, when 500 cores criteria is met stop adding to the new queue\n    ", "Answer": "\r\nI would use the utilities in the ```\njava.util.concurrent```\n package as much as possible.  \n\nTo start, ou can define a ```\nPriorityBlockingQueue```\n with a ```\nComparator```\n that sorts you jobs by date then priority, so the job with the earliest date and highest priority is always at the start of the queue:\n\n```\nPriorityBlockingQueue<JobRequest> q = new PriorityBlockingQueue<Test1.JobRequest>(0, new Comparator<JobRequest>()\n  {\n    @Override\n    public int compare(JobRequest o1, JobRequest o2)\n    {\n      int dateComparison = o1.getDate().compareTo(o2.getDate());\n      if (dateComparison != 0)\n        return dateComparison;\n      // assume higher number means higher priority\n      return o2.getPriority() - o1.getPriority();\n    }\n  });\n```\n\n\nI'm still not sure I understand your requirements on the cores, but you have two options here.  If you want up to  500 jobs to execute concurrently, then reject new items you can use an executor with ```\nSynchronousQueue```\n:\n\n```\nExecutorService executor = new ThreadPoolExecutor(0 /*core size*/, \n                                                  500 /*max size*/, \n                                                  0 /*keep alive*/, \n                                                  TimeUnit.SECONDS, \n                                                  new SynchronousQueue<Runnable>());\n```\n\n\nAlternatively, if you want fewer jobs executing concurrently, you could use an ```\nArrayBlockingQueue```\n which blocks while it is full:\n\n```\nExecutorService executor = new ThreadPoolExecutor(0 /*core size*/, \n                                                  5 /*max size*/, \n                                                  0 /*keep alive*/, \n                                                  TimeUnit.SECONDS, \n                                                  new ArrayBlockingQueue(500-5)<Runnable>());\n```\n\n\nThen pull jobs from the queue and execute them, handling rejected execution however you want to:\n\n```\nwhile (!isFinished)\n{\n  JobRequest job = q.take();\n  try\n  {\n    executor.execute(job);\n  }\n  catch (RejectedExecutionException e)\n  {\n\n  }\n}\n```\n\n\nIf, however, you just want 500 jobs running concurrently and subsequent jobs queued, just pass in a ```\nLinkedBlockingQueue```\n or, use one of the utility methods on ```\nExecutors```\n, like ```\nnewFixedThreadPool(int nThreads)```\n.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Priority Queue using doubly linked list\r\n                \r\nI am trying to implement a Priority Queue with a doubly linked list, but im stuck on the insertion of the nodes.\nThe task is:\nA method to insert a new element to the list. To insert the element you should calculate the average of the first and last element in the list (if the list contains elements). If the new elements priority has a numerical value less than this average the element should be inserted from the beginning of the list, otherwise from the end of the list to save time.\n```\n    public class Node<Item> { //node class with priority, value and pointers to next and prev\n    Item item;\n    int  priority;\n    Node next;\n    Node prev;\n}\n\npublic <Item> void add(Item value, int priority){ //fixa asap\n    Node tmp = new Node();\n    int currentpriority = sentinel.next.priority + sentinel.prev.priority / 2;\n\n    if (sentinel.next == this.sentinel ) {  //if its empty add after sentinel\n        sentinel.next.prev = tmp;\n        tmp.next = null;\n        tmp.prev = sentinel;\n        sentinel.next = tmp;\n        tmp.item = value;\n        tmp.priority = priority;\n    }\n\n        else if (priority <= sentinel.next.priority){  //if the first element is larger than the new element replace it with the new one at the front\n        sentinel.next.prev = tmp;\n        tmp.next = sentinel.next;\n        tmp.prev = sentinel;\n        sentinel.next = tmp;\n        tmp.item = value;\n        tmp.priority = priority;\n    }\n    else if (priority >= sentinel.prev.priority){  //if the last element is smaller than the new element replace it with the new one at the front\n        sentinel.prev.next = tmp;\n        tmp.prev = sentinel.prev;\n        tmp.next = null;\n        sentinel.prev = tmp;\n        tmp.item = value;\n        tmp.priority = priority;\n    }\n\n        else if(priority <= currentpriority ) { // if true add FROM the front\n            Node start = sentinel.next;\n            while (priority > start.priority)\n            start = start.next;\n             System.out.println(\"Test from the front\");\n            tmp.next = start;\n            tmp.prev = start.prev;\n            start.prev = tmp;\n            tmp.item = value;\n            tmp.priority = priority;\n\n    }\n```\n\nIf I run this and insert 2 nodes i.e 1 with priority 1 and 3 with priority 3 I get\n1 3\nnow I wish to insert 2 with priority 2\nbut it doesnt show up in the list, its still\n1 3\nWhat am i doing wrong?\nThanks!\n    ", "Answer": "", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Implementing an Unbounded Min Priority Queue using a Singly Linked List in Python\r\n                \r\nI am doing a class project and I have to implement an unbounded singly linked list using python. I need to implement a given 'insert' that has to consider the following cases...\ninsert into an empty queue\ninsert at the front of the queue\ninsert after some existing node.\nThis is the class given in python and i need to implement the insert function given at the bottom.\nI am new to this so any help would be greatly appreciated!\n```\nclass CinemaPriorityQueue:\n    \"\"\"A linked list implementation of an unbounded min-priority queue.\"\"\"\n\n    class Node:\n        \"\"\"A node in a linked list.\"\"\"\n\n        def __init__(self, item: object, priority_value: int) -> None:\n            \"\"\"Initialise the node with the given item and priority value.\"\"\"\n            self.item = item\n            self.priority = priority_value\n            self.next = None\n\n    def __init__(self) -> None:\n        \"\"\"Initialise the queue to be empty.\"\"\"\n        self.head = None\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Preconditions: true\n        Postconditions: the output is true if the queue is empty, false otherwise\n        \"\"\"\n        return self.head == None\n\n    def print(self) -> None:\n        \"\"\"Print out the queue\"\"\"\n        if self.head == None:\n            print('The queue is empty')\n        else:\n            current = self.head\n            while current != None:\n                print(current.item, current.priority)\n                current = current.next\n\n\n\n    def insert(self, item: object, priority_value: int) -> None:\n        \"\"\"Insert item according to priority.\n        Preconditions: true\n        Postconditions: post-self is the sequence\n        pre-self with item inserted after\n        the last item in self with the same priority\n        \"\"\"\n        pass\n        #*Write your code solution here*\n```\n\n    ", "Answer": "\r\nI can tell you the idea behind the solution. In the singly linked list, while adding a new element, compare it with the elements in the linked list and add it where it fits so that the linked list is sorted. This will give you a min priority queue.\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
{"Question": "Removing element from priority queue\r\n                \r\nI'm trying to pass input from a servlet to my backend, and remove object from queue if the information matches.\n\nsegment from webpage where user inputs name of project they want to delete\nbelow is where it reads the input then attempts to send the data to a back-end java file which is holding my priority queue\n\nthis section is aimed at reading in input from a form then that form calls processDeleteJobs which is called readdeletejobs above.\n\nReadin in the deletejobs input, set my jobrequest element to testdelete then I send it off to a function in the back end\n\n```\npublic boolean deleteJobFrontEnd(JobRequest job) {\nboolean remove;\nremove = scheduledJobs.remove().equals(job.getProjectName());\nreturn remove;\n}\n```\n\n\nThe aim is to remove a jobrequest in the priorityqueue if a certain criteria matches\nso if projectname within that jobrequest is matched then remove from queue\nAlso unsure on my boolean implementation whether this will remove it correctly or not.\n\nvery much a novice as you can see\n    ", "Answer": "\r\nJust remove it by calling ```\nPriorityQueue.remove(Object obj)```\n: \n\n```\npublic boolean deleteJobFrontEnd(JobRequest job) {\n    return scheduledJobs.remove(job);\n}\n```\n\n\nAlso, make sure ```\nJobRequest```\n has ```\nequals()```\n implemented correctly.\n\nOr use an iterator:\n\n```\nIterator it = scheduledJobs.iterator();\nwhile(it.hasNext())\n{\n    if(sameJob(it.next())) // Implement sameJob \n        it.remove();\n}\n```\n\n    ", "Knowledge_point": "Priority Queue Implementation", "Tag": "算法分析"}
