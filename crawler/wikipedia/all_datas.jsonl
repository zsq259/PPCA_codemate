["https://zh.wikipedia.org/wiki/P/NP%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95", "https://zh.wikipedia.org/wiki/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F", "https://zh.wikipedia.org/wiki/%E9%BE%90%E7%89%B9%E9%87%8C%E4%BA%9E%E9%87%91%E5%B0%8D%E5%81%B6%E6%80%A7", "https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95", "https://zh.wikipedia.org/wiki/%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95", "https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%B0%91%E5%A5%B3", "https://zh.wikipedia.org/wiki/%E6%A0%88", "https://zh.wikipedia.org/wiki/%E5%AE%8C%E7%BE%8E%E6%95%A3%E5%88%97", "https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92", "https://zh.wikipedia.org/wiki/%E5%A4%96%E8%92%99%E5%8F%A4%E7%8B%AC%E7%AB%8B", "https://zh.wikipedia.org/wiki/%E8%A7%84%E7%BA%A6", "https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91", "https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84", "https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2", "https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81", "https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6", "https://zh.wikipedia.org/wiki/%E6%A8%A1%E8%BF%90%E7%AE%97", "https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2", "https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97", "https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3%E4%B9%98%E6%B3%95", "https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%99%A8%E5%85%A5%E9%97%A8%E5%A5%97%E4%BB%B6", "https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E4%BD%B3%E5%B8%A6%E6%9D%83%E5%8C%B9%E9%85%8D", "https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BD%8D%E6%95%B0", "https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97", "https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95", "https://zh.wikipedia.org/wiki/%E8%B2%AA%E5%A9%AA%E7%AE%97%E6%B3%95", "https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3", "https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7", "https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86", "https://zh.wikipedia.org/wiki/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81", "https://zh.wikipedia.org/wiki/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F", "https://zh.wikipedia.org/wiki/1A2B", "https://zh.wikipedia.org/wiki/%E6%9C%80%E5%BC%BA%E5%A4%A7%E8%84%91", "https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88", "https://zh.wikipedia.org/wiki/%E9%95%BF%E5%BA%A6", "https://zh.wikipedia.org/wiki/Dijkstra%E7%AE%97%E6%B3%95", "https://zh.wikipedia.org/wiki/Fibonacci%E6%95%B0%E5%88%97", "https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2", "https://zh.wikipedia.org/wiki/%E9%9C%8D%E6%81%A9%E5%AD%90%E5%8F%A5", "https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E5%85%B3%E7%B3%BB", "https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%BC%AF%E8%B7%9D%E9%9B%A2", "https://zh.wikipedia.org/wiki/%E5%8D%A2%E6%81%A9%E7%AE%97%E6%B3%95", "https://zh.wikipedia.org/wiki/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95", "https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98", "https://zh.wikipedia.org/wiki/%E4%B9%98%E6%B3%95"]{"Answer": "广度优先搜索算法（英語：Breadth-first search，縮寫：BFS），又譯作寬度優先搜索，或橫向優先搜索，是一種圖形搜索演算法。簡單的說，BFS是從根節點開始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索", "Tag": "算法设计"}
{"Answer": "BFS是一種暴力搜索算法，目的是系統地展開並檢查圖中的所有節點，以找尋結果。換句話說，它並不考慮結果的可能位址，徹底地搜索整張圖，直到找到結果為止。BFS並不使用經驗法則演算法。\n從演算法的觀點，所有因為展開節點而得到的子節點都會被加進一個先進先出的队列中。一般的實作裡，其鄰居節點尚未被檢驗過的節點會被放置在一個被稱為 open 的容器中（例如佇列或是链表），而被檢驗過的節點則被放置在被稱為 closed 的容器中。（open-closed表）\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的作法", "Tag": "算法设计"}
{"Answer": "首先將根節點放入队列中。\n從队列中取出第一個節點，並檢驗它是否為目標。\n如果找到目標，則結束搜尋並回傳結果。\n否則將它所有尚未檢驗過的直接子節點加入队列中。\n若队列為空，表示整張圖都檢查過了——亦即圖中沒有欲搜尋的目標。結束搜尋並回傳「找不到目標」。\n重複步驟2。 s为初始点\n \n  \n    \n      \n        R\n        :=\n        {\n        s\n        }\n        ,\n        Q\n        :=\n        {\n        s\n        }\n        ,\n        T\n        =\n        ∅\n      \n    \n    {\\displaystyle R:=\\{s\\},Q:=\\{s\\},T=\\emptyset }\n  \n\n while \n  \n    \n      \n        Q\n        ≠\n        ∅\n      \n    \n    {\\displaystyle Q\\neq \\emptyset }\n  \n\n     從Q中選一點 v /* 若改選最後插入進Q的點，則為深度遍歷,可以说後進先出。*/\n     if \n  \n    \n      \n        ∃\n        w\n        ∈\n        N\n        (\n        v\n        )\n        ∖\n        R\n      \n    \n    {\\displaystyle \\exists w\\in N(v)\\setminus R}\n  \n then    /* N(v):v的邻接点 */\n         \n  \n    \n      \n        Q\n        :=\n        Q\n        ∪\n        {\n        w\n        }\n      \n    \n    {\\displaystyle Q:=Q\\cup \\{w\\}}\n  \n\n         \n  \n    \n      \n        R\n        :=\n        R\n        ∪\n        {\n        w\n        }\n      \n    \n    {\\displaystyle R:=R\\cup \\{w\\}}\n  \n\n         \n  \n    \n      \n        T\n        :=\n        T\n        ∪\n        {\n        v\n        w\n        }\n      \n    \n    {\\displaystyle T:=T\\cup \\{vw\\}}\n  \n\n     else \n  \n    \n      \n        Q\n        :=\n        Q\n        ∖\n        {\n        w\n        }\n      \n    \n    {\\displaystyle Q:=Q\\setminus \\{w\\}}\n  \n\n return H=(R,T)\nC 的实例[编辑]/*\n    ADDQ (Q, p) - p PUSH 入 Q\n    DELQ (Q) - POP Q 并返回 Q 顶\n    FIRSTADJ (G,v) - v 的第一个邻接点，找不到则返回 -1\n    NEXTADJ (G,v) - v 的下一个邻接点，找不到则返回 -1\n    VISIT (v) - 访问 v\n    visited [] - 是否已访问\n*/\n\n// 广度优先搜索算法\nvoid BFS(VLink G[], int v) {\n    int w;\n    VISIT(v); // 访问 v 并入队\n    visited[v] = 1;\n    ADDQ(Q, v);\n    // 对队列 Q 的各元素\n    while (!EMPTYQ(Q)) {\n        v = DELQ(Q);\n        w = FIRSTADJ(G, v);\n        do {\n            // 进行访问和入队\n            if (visited[w] == 0) {\n                VISIT(w);\n                ADDQ(Q, w);\n                visited[w] = 1;\n            }\n        } while ((w = NEXTADJ(G, v)) != -1);\n    }\n}\n\n// 对图G=(V,E)进行广度优先搜索的主算法\nvoid TRAVEL_BFS(VLink G[], bool visited[], int n) {\n    // 清零标记数组\n    for (int i = 0; i < n; ++i)\n        visited[i] = 0;\n    for (int i = 0; i < n; ++i)\n        if (visited[i] == 0)\n            BFS(G, i);\n}\nC++ 的實作[编辑](這個例子僅針對Binary Tree)\n定义一个结构体来表达一个節點的结构：\nstruct node {\n    int self;     //数据\n    node *left;   //左节点\n    node *right;  //右节点\n};\n那么，我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：\n   A\nB     C\nA是第一个访问的，然后顺序是B和C；然后再是B的子节点，C的子节点。那么我们怎么来保证这个顺序呢？\n这里就应该用queue資料結構，因为queue採用先进先出( first-in-first-out )的顺序。\n使用C++的STL函式庫，下面的程序能帮助理解：\n std::queue<node *> visited, unvisited;\nnode nodes[9];\nnode *current;\n\nunvisited.push(&nodes[0]); // 先把root放入unvisited queue\n\nwhile (!unvisited.empty()) { // 只有unvisited不空\n    current = (unvisited.front()); // 目前應該檢驗的\n    if (current->left != NULL)\n        unvisited.push(current->left); // 把左邊放入queue中\n    if (current->right != NULL) // 右邊壓入。因為QUEUE是一個先進先出的結構构，所以即使後面再壓其他东西，依然會先訪問這個。\n        unvisited.push(current->right);\n    visited.push(current);\n    cout << current->self << endl;\n    unvisited.pop();\n}\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的實作方法", "Tag": "算法设计"}
{"Answer": "/*\n    ADDQ (Q, p) - p PUSH 入 Q\n    DELQ (Q) - POP Q 并返回 Q 顶\n    FIRSTADJ (G,v) - v 的第一个邻接点，找不到则返回 -1\n    NEXTADJ (G,v) - v 的下一个邻接点，找不到则返回 -1\n    VISIT (v) - 访问 v\n    visited [] - 是否已访问\n*/\n\n// 广度优先搜索算法\nvoid BFS(VLink G[], int v) {\n    int w;\n    VISIT(v); // 访问 v 并入队\n    visited[v] = 1;\n    ADDQ(Q, v);\n    // 对队列 Q 的各元素\n    while (!EMPTYQ(Q)) {\n        v = DELQ(Q);\n        w = FIRSTADJ(G, v);\n        do {\n            // 进行访问和入队\n            if (visited[w] == 0) {\n                VISIT(w);\n                ADDQ(Q, w);\n                visited[w] = 1;\n            }\n        } while ((w = NEXTADJ(G, v)) != -1);\n    }\n}\n\n// 对图G=(V,E)进行广度优先搜索的主算法\nvoid TRAVEL_BFS(VLink G[], bool visited[], int n) {\n    // 清零标记数组\n    for (int i = 0; i < n; ++i)\n        visited[i] = 0;\n    for (int i = 0; i < n; ++i)\n        if (visited[i] == 0)\n            BFS(G, i);\n}\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的C 的实例", "Tag": "算法设计"}
{"Answer": "(這個例子僅針對Binary Tree)\n定义一个结构体来表达一个節點的结构：\nstruct node {\n    int self;     //数据\n    node *left;   //左节点\n    node *right;  //右节点\n};\n那么，我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：\n   A\nB     C\nA是第一个访问的，然后顺序是B和C；然后再是B的子节点，C的子节点。那么我们怎么来保证这个顺序呢？\n这里就应该用queue資料結構，因为queue採用先进先出( first-in-first-out )的顺序。\n使用C++的STL函式庫，下面的程序能帮助理解：\n std::queue<node *> visited, unvisited;\nnode nodes[9];\nnode *current;\n\nunvisited.push(&nodes[0]); // 先把root放入unvisited queue\n\nwhile (!unvisited.empty()) { // 只有unvisited不空\n    current = (unvisited.front()); // 目前應該檢驗的\n    if (current->left != NULL)\n        unvisited.push(current->left); // 把左邊放入queue中\n    if (current->right != NULL) // 右邊壓入。因為QUEUE是一個先進先出的結構构，所以即使後面再壓其他东西，依然會先訪問這個。\n        unvisited.push(current->right);\n    visited.push(current);\n    cout << current->self << endl;\n    unvisited.pop();\n}\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的C++ 的實作", "Tag": "算法设计"}
{"Answer": "空間複雜度[编辑]因為所有節點都必須被儲存，因此BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。註：另一種說法稱BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          B\n          \n            M\n          \n        \n        )\n      \n    \n    {\\displaystyle O(B^{M})}\n  \n，其中B是最大分支係數，而M是樹的最長路徑長度。由於對空間的大量需求，因此BFS並不適合解非常大的問題，對於類似的問題，應用IDDFS以達節省空間的效果。\n時間複雜度[编辑]最差情形下，BFS必須尋找所有到可能節點的所有路徑，因此其時間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。\n完全性[编辑]廣度優先搜索演算法具有完全性。這意指無論圖形的種類如何，只要目標存在，則BFS一定會找到。然而，若目標不存在，且圖為無限大，則BFS將不收斂（不會結束）。\n最佳解[编辑]若所有邊的長度相等，廣度優先搜索演算法是最佳解——亦即它找到的第一個解，距離根節點的邊數目一定最少；但對一般的圖來說，BFS並不一定回傳最佳解。這是因為當圖形為加權圖（亦即各邊長度不同）時，BFS仍然回傳從根節點開始，經過邊數目最少的解；而這個解距離根節點的距離不一定最短。這個問題可以使用考慮各邊權值，BFS的改良演算法成本一致搜尋法來解決。然而，若非加權圖形，則所有邊的長度相等，BFS就能找到最近的最佳解。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性", "Tag": "算法设计"}
{"Answer": "因為所有節點都必須被儲存，因此BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。註：另一種說法稱BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          B\n          \n            M\n          \n        \n        )\n      \n    \n    {\\displaystyle O(B^{M})}\n  \n，其中B是最大分支係數，而M是樹的最長路徑長度。由於對空間的大量需求，因此BFS並不適合解非常大的問題，對於類似的問題，應用IDDFS以達節省空間的效果。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的空間複雜度", "Tag": "算法设计"}
{"Answer": "最差情形下，BFS必須尋找所有到可能節點的所有路徑，因此其時間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的時間複雜度", "Tag": "算法设计"}
{"Answer": "廣度優先搜索演算法具有完全性。這意指無論圖形的種類如何，只要目標存在，則BFS一定會找到。然而，若目標不存在，且圖為無限大，則BFS將不收斂（不會結束）。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的完全性", "Tag": "算法设计"}
{"Answer": "若所有邊的長度相等，廣度優先搜索演算法是最佳解——亦即它找到的第一個解，距離根節點的邊數目一定最少；但對一般的圖來說，BFS並不一定回傳最佳解。這是因為當圖形為加權圖（亦即各邊長度不同）時，BFS仍然回傳從根節點開始，經過邊數目最少的解；而這個解距離根節點的距離不一定最短。這個問題可以使用考慮各邊權值，BFS的改良演算法成本一致搜尋法來解決。然而，若非加權圖形，則所有邊的長度相等，BFS就能找到最近的最佳解。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的最佳解", "Tag": "算法设计"}
{"Answer": "廣度優先搜索演算法能用來解決圖論中的許多問題，例如：\n尋找圖中所有連接元件（Connected Component）。一個連接元件是圖中的最大相連子圖。\n尋找連接元件中的所有節點。\n尋找非加權圖中任兩點的最短路徑。\n測試一圖是否為二分圖。\n（Reverse）Cuthill–McKee演算法尋找連接元件[编辑]由起點開始，執行廣度優先搜索演算法後所經過的所有節點，即為包含起點的一個連接元件。\n測試是否二分圖[编辑]BFS可以用以測試二分圖。從任一節點開始搜尋，並在搜尋過程中給節點不同的標籤。例如，給開始點標籤0，開始點的所有鄰居標籤1，開始點所有鄰居的鄰居標籤0……以此類推。若在搜尋過程中，任一節點有跟其相同標籤的鄰居，則此圖就不是二分圖。若搜尋結束時這種情形未發生，則此圖為一二分圖。\n應用於電腦遊戲中平面網格[编辑]BFS可用來解決電腦遊戲（例如即時策略遊戲）中找尋路徑的問題。在這個應用中，使用平面網格來代替圖形，而一個格子即是圖中的一個節點。所有節點都與它的鄰居（上、下、左、右、左上、右上、左下、右下）相接。\n值得一提的是，當這樣使用BFS演算法時，首先要先檢驗上、下、左、右的鄰居節點，再檢驗左上、右上、左下、右下的鄰居節點。這是因為BFS趨向於先尋找斜向鄰居節點，而不是四方的鄰居節點，因此找到的路徑將不正確。BFS應該先尋找四方鄰居節點，接著才尋找斜向鄰居節點1。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用", "Tag": "算法设计"}
{"Answer": "由起點開始，執行廣度優先搜索演算法後所經過的所有節點，即為包含起點的一個連接元件。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用的尋找連接元件", "Tag": "算法设计"}
{"Answer": "BFS可以用以測試二分圖。從任一節點開始搜尋，並在搜尋過程中給節點不同的標籤。例如，給開始點標籤0，開始點的所有鄰居標籤1，開始點所有鄰居的鄰居標籤0……以此類推。若在搜尋過程中，任一節點有跟其相同標籤的鄰居，則此圖就不是二分圖。若搜尋結束時這種情形未發生，則此圖為一二分圖。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用的測試是否二分圖", "Tag": "算法设计"}
{"Answer": "BFS可用來解決電腦遊戲（例如即時策略遊戲）中找尋路徑的問題。在這個應用中，使用平面網格來代替圖形，而一個格子即是圖中的一個節點。所有節點都與它的鄰居（上、下、左、右、左上、右上、左下、右下）相接。\n值得一提的是，當這樣使用BFS演算法時，首先要先檢驗上、下、左、右的鄰居節點，再檢驗左上、右上、左下、右下的鄰居節點。這是因為BFS趨向於先尋找斜向鄰居節點，而不是四方的鄰居節點，因此找到的路徑將不正確。BFS應該先尋找四方鄰居節點，接著才尋找斜向鄰居節點1。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用的應用於電腦遊戲中平面網格", "Tag": "算法设计"}
{"Answer": "先验算法\n深度優先搜索", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的參見", "Tag": "算法设计"}
{"Answer": "Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein],  Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 22.2: Breadth-first search, pp. 531–539.", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的參考資料", "Tag": "算法设计"}
{"Answer": "（英文） 資料結構與演算法字典：廣度優先搜索 （页面存档备份，存于互联网档案馆）\n（英文） C++ Boost Graph函式庫：廣度優先搜索 （页面存档备份，存于互联网档案馆）\n（英文） 深度與廣度優先搜索：解釋與原始碼 （页面存档备份，存于互联网档案馆）\n（英文） BFS 動畫說明 （页面存档备份，存于互联网档案馆）", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的外部連結", "Tag": "算法设计"}
{"Answer": "在數學中，整數分解（英語：integer factorization）又稱質因數分解（prime factorization），是將一個正整數寫成幾個因數的乘積。例如，給出45這個數，它可以分解成\n  \n    \n      \n    \n    {\\displaystyle }\n  \n\n  \n    \n      \n        \n          3\n          \n            2\n          \n        \n        ×\n        5\n      \n    \n    {\\displaystyle 3^{2}\\times 5}\n  \n。根據算術基本定理，這樣的分解結果應該是獨一無二的。這個問題在代數學、密碼學、計算複雜性理論和量子計算機等領域中有重要意義。\n", "Konwledge_Point": "整数分解", "Question": "什么是整数分解", "Tag": "算法设计"}
{"Answer": "完整的因子列表可以根據因數分解推導出，將冪從零不斷增加直到等於這個數，算出可以整除這個數的所有整數。\n例如，因為\n  \n    \n      \n        45\n        =\n        \n      \n    \n    {\\displaystyle 45=\\,}\n  \n\n  \n    \n      \n        \n          3\n          \n            2\n          \n        \n        ×\n        5\n      \n    \n    {\\displaystyle 3^{2}\\times 5}\n  \n，由此可知，\n45可以被以下數字因子分解:\n30 ×50 =1\n30×51 =5\n31×50 =3\n31×51 =15\n32×50 =9\n32×51 =45 相對應的，因數分解只包括因數因子。參見因數分解算法。\n", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的因子分解", "Tag": "算法设计"}
{"Answer": "給出兩個整數，很容易就能將它們兩個相乘。但是，給出一個大整數(100位數以上的整數)，找出它們的因數就顯得不是那麼容易了。這就是許多現代密碼系統的關鍵所在。如果能夠找到解決整數分解問題的快速方法，幾個重要的密碼系統將會被攻破，包括RSA加密演算法公鑰算法和Blum Blum Shub（英语：Blum Blum Shub）隨機數發生器。儘管快速分解是攻破這些系統的方法之一，仍然會有其它的不涉及到分解的其它方法。所以情形完全可能變成這樣：整數分解問題仍然是非常困難，這些密碼系統卻是能夠很快攻破。有的密碼系統則能提供更強的保證：如果這些密碼系統被快速破解（即可以以多項式時間複雜度破解），則可以利用破解這些系統的算法來快速地以多項式時間複雜度分解整數。換句話說，破解這樣的密碼系統不會比整數分解更容易。這種的密碼系統包括Rabin cryptosystem（英语：Rabin cryptosystem）(RSA的一個變體）以及Blum Blum Shub（英语：Blum Blum Shub）隨機數發生器。\n", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的實際應用", "Tag": "算法设计"}
{"Answer": "2005年，作為公共研究一部分的，有663個二進制數位之長的RSA200（英语：RSA numbers）已經被一種一般用途的方法所分解。如果一個大的，有n個二進制數位長度的數，是兩個差不多大小相等的因數的乘積，現在還沒有很好的演算法來以多項式時間複雜度分解它。即意味著沒有已知算法可以在O（nk）（k為常數）的時間內分解它，但是現在的算法也是比O(en)快的。亦即，現在我們已知最好的算法比指數數量級時間要快，比多項式數量級時間要慢。已知最好的漸近線運行時間是普通數域篩選法（GNFS）。\n時間是：\n\n  \n    \n      \n        \n          O\n        \n        \n          (\n          \n            exp\n            ⁡\n            \n              (\n              \n                \n                  \n                    (\n                    \n                      \n                        \n                          64\n                          9\n                        \n                      \n                      n\n                    \n                    )\n                  \n                  \n                    \n                      1\n                      3\n                    \n                  \n                \n                (\n                log\n                ⁡\n                n\n                \n                  )\n                  \n                    \n                      2\n                      3\n                    \n                  \n                \n              \n              )\n            \n          \n          )\n        \n      \n    \n    {\\displaystyle \\mathrm {O} \\left(\\exp \\left(\\left({\\frac {64}{9}}n\\right)^{\\frac {1}{3}}(\\log n)^{\\frac {2}{3}}\\right)\\right)}\n  \n對於平常的計算機，GNFS是我們已知最好的對付n個二進制數位大因數的方法。不過，對於量子計算機，彼得·秀尔在1994年發現了一種可以用多項式時間來解決這個問題的算法。如果大的量子計算機建立起來，會對密碼學有很重要的意義。這個算法在時間上只需要O(n3)，空間只要O(n)就可以了。構造出這樣一個算法只需要2n個量子位。2001年，第一個7量子位的量子計算機第一個運行這個算法，它分解的數是15。\n難度與複雜度[编辑]現在還不確切知道整數分解屬於哪個複雜度類。我們知道這個問題的判定問題形式（「請問N是否有一個比M小的因數?」）是在NP與反NP之中。因為不管是答案為是或不是，我們都可以用一個質因數以及該質因數的質數證明來驗證這個答案。由秀爾演算法可知，這個問題在BQP中。大部份的人則懷疑這個問題不在P、NP完全、以及反NP完全這三個複雜性類別中。如果這個問題可以被證明為NP完全或反NP完全，則我們便可推得NP=反NP。這將會是個很震撼的結果，也因此大多數人猜想整數分解這個問題不在上述的複雜性類別中。也有許多人嘗試去找出多項式時間的演算法來解決這個問題，但是都尚未成功，因此這個問題也被多數人懷疑不在P中。\n但判定一個整數是否是質數比分解該整數簡單許多。AKS算法証明前者可以在多項式時間中解決。 測試一個數是否為質數是RSA演算法中非常重要的一環，因為它在一開始的时候需要找很大的質數。\n", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的當今的新進展", "Tag": "算法设计"}
{"Answer": "現在還不確切知道整數分解屬於哪個複雜度類。我們知道這個問題的判定問題形式（「請問N是否有一個比M小的因數?」）是在NP與反NP之中。因為不管是答案為是或不是，我們都可以用一個質因數以及該質因數的質數證明來驗證這個答案。由秀爾演算法可知，這個問題在BQP中。大部份的人則懷疑這個問題不在P、NP完全、以及反NP完全這三個複雜性類別中。如果這個問題可以被證明為NP完全或反NP完全，則我們便可推得NP=反NP。這將會是個很震撼的結果，也因此大多數人猜想整數分解這個問題不在上述的複雜性類別中。也有許多人嘗試去找出多項式時間的演算法來解決這個問題，但是都尚未成功，因此這個問題也被多數人懷疑不在P中。\n但判定一個整數是否是質數比分解該整數簡單許多。AKS算法証明前者可以在多項式時間中解決。 測試一個數是否為質數是RSA演算法中非常重要的一環，因為它在一開始的时候需要找很大的質數。\n", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的當今的新進展的難度與複雜度", "Tag": "算法设计"}
{"Answer": "特殊用途算法[编辑]一個特別的因數分解算法的運行時間依賴它本身的未知因子：大小，類型等等。在不同的算法之間運行時間也是不同的。\n試除法\n輪式因數分解法（英语：Wheel factorization）\n波拉德RHO算法（英语：Pollard's rho algorithm）\n代数群因式分解算法（英语：Algebraic-group factorisation algorithms），其中包括Pollard's p − 1算法（英语：Pollard's p − 1 algorithm）、Williams' p + 1算法（英语：Williams' p + 1 algorithm）和Lenstra橢圓曲線分解法（英语：Lenstra elliptic curve factorization）\n費馬質數判定法\n欧拉因式分解法（英语：Euler's factorization method）\n特殊數域篩選法（英语：Special number field sieve）一般用途算法[编辑]一般用途算法的運行時間僅僅依賴要分解的整數的長度。這種算法可以用來分解RSA數。大部分一般用途算法基於平方同余方法。\nDixon算法（英语：Dixon's algorithm）\n連分數分解法（英语：Continued fraction factorization）（CFRAC）\n二次篩選法\n有理筛选法\n普通數域篩選法\nShanks' square forms factorization（英语：Shanks' square forms factorization）（SQUFOF）其他算法[编辑]秀尔算法", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的整數分解算法", "Tag": "算法设计"}
{"Answer": "一個特別的因數分解算法的運行時間依賴它本身的未知因子：大小，類型等等。在不同的算法之間運行時間也是不同的。\n試除法\n輪式因數分解法（英语：Wheel factorization）\n波拉德RHO算法（英语：Pollard's rho algorithm）\n代数群因式分解算法（英语：Algebraic-group factorisation algorithms），其中包括Pollard's p − 1算法（英语：Pollard's p − 1 algorithm）、Williams' p + 1算法（英语：Williams' p + 1 algorithm）和Lenstra橢圓曲線分解法（英语：Lenstra elliptic curve factorization）\n費馬質數判定法\n欧拉因式分解法（英语：Euler's factorization method）\n特殊數域篩選法（英语：Special number field sieve）", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的整數分解算法的特殊用途算法", "Tag": "算法设计"}
{"Answer": "一般用途算法的運行時間僅僅依賴要分解的整數的長度。這種算法可以用來分解RSA數。大部分一般用途算法基於平方同余方法。\nDixon算法（英语：Dixon's algorithm）\n連分數分解法（英语：Continued fraction factorization）（CFRAC）\n二次篩選法\n有理筛选法\n普通數域篩選法\nShanks' square forms factorization（英语：Shanks' square forms factorization）（SQUFOF）", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的整數分解算法的一般用途算法", "Tag": "算法设计"}
{"Answer": "秀尔算法", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的整數分解算法的其他算法", "Tag": "算法设计"}
{"Answer": "\n\n数学主题質因數表", "Konwledge_Point": "整数分解", "Question": "什么是整数分解的參見", "Tag": "算法设计"}
{"Answer": "NP完全或NP完备 （NP-Complete，縮寫為NP-C或NPC），是計算複雜度理論中，決定性問題的等級之一。NP完备是NP与NP困难問題的交集，是NP中最難的決定性問題，所有NP問題都可以在多項式時間內被歸約（reduce to）為NP完備問題。倘若任何NP完備問題得到多項式時間內的解法，則該解法就可應用在所有NP問題上，亦可證明NP問題等於P問題，然而目前為止並未發現任何能在多項式時間內解決NP完備問題的方法。\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全", "Tag": "算法设计"}
{"Answer": "  假設P ≠ NP的複雜度類的圖解。若P = NP則三類別相同。一個決定性問題C若是為NPC（NP完備），則代表它對NP是完備的，這表示：\n它是一個NP問題\n它是一個NP困難問題\n其他屬於NP的問題都可在多項式時間內归约（reduce to）成它。可歸約（reducible）在此意指對每個問題L，總有一個多項式時間多對一變換，即一個決定性的演算法可以將實例l ∈ L轉化成實例c ∈ C，並讓c回答Yes当且仅当此答案對l也是Yes。為了證明某個NP問題A實際上是NP完備問題，證明者必須找出一個已知的NP完備問題可以歸約成A。\n本定義得到一個結論，就是若上述的C有一個多項式時間可解的演算法，則我們可以將所有的NP問題降到P之中。若欲證明一個問題是NPC，最簡單的方法是先證明它屬於NP，然後將「某個已知是NPC的問題」歸約成它。\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的正式定義", "Tag": "算法设计"}
{"Answer": "前述定義是史提芬·古克[1]所提出。雖然NPC這個詞並沒有出現在這篇論文上任何地方。在這個資訊科學會議上，資訊科學家激動地討論NPC問題是否可以在一個確定型圖靈機上以多項式時間求解。John Hopcroft總結與會眾人的共識，認為由於沒有人能對某一命題提出駁倒對方的證明，此問題不會於現在解決。此命題就是知名的\nP和NP相等嗎？。尚未有人能提出證明，說明NPC問題是否能在多項式時間中解決，使得此問題成為著名的数学中未解决的问题。位于美国麻省剑桥市的「克雷數學研究所」（Clay Mathematics Institute，簡稱CMI）提供了一百萬美元獎金給任何可以證明P=NP或P≠NP的人。一開始很難相信NPC問題是實際存在的，但著名的古克-李芬定理說明了一切（由Leonid Levin（英语：Leonid Levin）與Cook獨立證出SAT問題是NPC問題（即Cook-Levin理論）。\n在1972年，理查德·卡普證明有好幾個問題也是NPC（請見卡普的二十一個NP-完全問題），因此除了SAT問題外，的確存在著一整類NPC問題。從古克開始，數千個問題藉由從其他NPC問題變換而證實也是NPC問題，其中很多問題被蒐集在Garey與Johnson於1979年出版的書之中[2]。\n滿足條件2（无论是否满足条件1）的問題集合被稱為NP困难。一個NP困难問題至少跟NPC問題一樣難。有一类问题已经被证明属于NP困难但不属于NP，即，这类问题至少与NP-complete一样难，但这类问题又不属于NP（自然也不属于NP-complete）。例如圍棋的必勝下法，就是这样一个問題。[1]\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的歷史", "Tag": "算法设计"}
{"Answer": "子集合加總問題[编辑]一個NPC問題的例子是子集合加總問題，題目為\n給予一個有限數量的整數集合，找出任何一個此集合的非空子集且此子集內整數和為零。\n意即：\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n是一個包括若干整數的集合，找出任一一个\n  \n    \n      \n        \n          S\n          ′\n        \n        ⊂\n        S\n      \n    \n    {\\displaystyle S'\\subset S}\n  \n且\n  \n    \n      \n        \n          ∑\n          \n            x\n            ∈\n            \n              S\n              ′\n            \n          \n        \n        x\n        =\n        0\n      \n    \n    {\\displaystyle \\sum _{x\\in S'}x=0}\n  \n這個問題的答案非常容易驗證，但目前沒有任何一個夠快的方法可以在合理的時間內（意即多項式時間）找到答案。只能一個個將它的子集取出來一一測試，它的時間複雜度是\n  \n    \n      \n        O\n        (\n        \n          2\n          \n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle O(2^{n})}\n  \n，\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n是此集合的元素數量。\n圖同構問題[编辑]另一個有趣的例是圖同構（isomorphism）問題，即以圖論方法決定兩個圖是否為同構。兩圖同構的直覺條件是若其中一圖可以經由移動頂點使它與另一個圖重合，則為同構。思考下列兩問題：\n圖同構：圖G1是否與圖G2同構？\n子圖同構：圖G1是否與圖G2的某一子圖同構？子圖同構問題是NPC，而圖同構問題一般認為不是P也不是NPC問題，雖然它明顯是一個NP問題。這是一個典型被認為很難卻還不是NPC問題的例子。\n其他[编辑]下表列出了一些以決定性命題表示的著名NPC問題：\n  變換流程圖。布尔可满足性问题\nN-puzzle問題（華容道問題）\n背包問題\n漢彌爾頓迴圈問題\n旅行推销员问题\n子圖同構問題：（Subgraph isomorphism problem（英语：Subgraph isomorphism problem））\n子集合加總問題\n分團問題\n頂點覆盖問題：（Vertex cover（英语：Vertex cover））\n獨立頂點集問題：（Independent set problem（英语：Independent set problem））\n圖著色問題\n踩地雷[2]更多NPC問題的例子，請見NP-complete問題列表（英语：List of NP-complete problems）。\n右邊是一些NPC問題及證明其為NPC問題的變換流程圖。在流程圖中，箭頭代表的是從何問題變換成另一問題的過程，要注意的是這張圖並不代表這些問題的數學關係，事實上任兩個本質為NPC的問題都可以以多項式時間變換，這圖僅指示可以讓研究者較為簡單地變換問題的順序。\n通常一個P與NPC問題的敘述看起來只有一些不同的地方，例如3SAT問題（SAT問題的限制版本）仍然是NPC問題，但更限制的2SAT問題則是個P問題（準確的說，是NL-complete問題），而條件較為寬鬆的MAX 2SAT問題卻又成了NPC問題。決定一個圖是否能被兩色塗滿是P問題，但三色圖是NPC問題，即使我們將它限制在平面圖上。決定一個圖有無迴圈或它是兩分圖很容易（在log空間等級），但是發現一個最大二分圖或最大迴圈子圖則是NPC。以一固定百分比來求郊遊打包問題的最佳解可以在多項式時間解決，但是求最佳解是NPC。\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的例子", "Tag": "算法设计"}
{"Answer": "一個NPC問題的例子是子集合加總問題，題目為\n給予一個有限數量的整數集合，找出任何一個此集合的非空子集且此子集內整數和為零。\n意即：\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n是一個包括若干整數的集合，找出任一一个\n  \n    \n      \n        \n          S\n          ′\n        \n        ⊂\n        S\n      \n    \n    {\\displaystyle S'\\subset S}\n  \n且\n  \n    \n      \n        \n          ∑\n          \n            x\n            ∈\n            \n              S\n              ′\n            \n          \n        \n        x\n        =\n        0\n      \n    \n    {\\displaystyle \\sum _{x\\in S'}x=0}\n  \n這個問題的答案非常容易驗證，但目前沒有任何一個夠快的方法可以在合理的時間內（意即多項式時間）找到答案。只能一個個將它的子集取出來一一測試，它的時間複雜度是\n  \n    \n      \n        O\n        (\n        \n          2\n          \n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle O(2^{n})}\n  \n，\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n是此集合的元素數量。\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的例子的子集合加總問題", "Tag": "算法设计"}
{"Answer": "另一個有趣的例是圖同構（isomorphism）問題，即以圖論方法決定兩個圖是否為同構。兩圖同構的直覺條件是若其中一圖可以經由移動頂點使它與另一個圖重合，則為同構。思考下列兩問題：\n圖同構：圖G1是否與圖G2同構？\n子圖同構：圖G1是否與圖G2的某一子圖同構？子圖同構問題是NPC，而圖同構問題一般認為不是P也不是NPC問題，雖然它明顯是一個NP問題。這是一個典型被認為很難卻還不是NPC問題的例子。\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的例子的圖同構問題", "Tag": "算法设计"}
{"Answer": "下表列出了一些以決定性命題表示的著名NPC問題：\n  變換流程圖。布尔可满足性问题\nN-puzzle問題（華容道問題）\n背包問題\n漢彌爾頓迴圈問題\n旅行推销员问题\n子圖同構問題：（Subgraph isomorphism problem（英语：Subgraph isomorphism problem））\n子集合加總問題\n分團問題\n頂點覆盖問題：（Vertex cover（英语：Vertex cover））\n獨立頂點集問題：（Independent set problem（英语：Independent set problem））\n圖著色問題\n踩地雷[2]更多NPC問題的例子，請見NP-complete問題列表（英语：List of NP-complete problems）。\n右邊是一些NPC問題及證明其為NPC問題的變換流程圖。在流程圖中，箭頭代表的是從何問題變換成另一問題的過程，要注意的是這張圖並不代表這些問題的數學關係，事實上任兩個本質為NPC的問題都可以以多項式時間變換，這圖僅指示可以讓研究者較為簡單地變換問題的順序。\n通常一個P與NPC問題的敘述看起來只有一些不同的地方，例如3SAT問題（SAT問題的限制版本）仍然是NPC問題，但更限制的2SAT問題則是個P問題（準確的說，是NL-complete問題），而條件較為寬鬆的MAX 2SAT問題卻又成了NPC問題。決定一個圖是否能被兩色塗滿是P問題，但三色圖是NPC問題，即使我們將它限制在平面圖上。決定一個圖有無迴圈或它是兩分圖很容易（在log空間等級），但是發現一個最大二分圖或最大迴圈子圖則是NPC。以一固定百分比來求郊遊打包問題的最佳解可以在多項式時間解決，但是求最佳解是NPC。\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的例子的其他", "Tag": "算法设计"}
{"Answer": "目前為止，所有已知解NPC問題的演算法需要依照資料數量而定的超多項式（superpolynomial）時間，目前也不知道是否有任何更快的演算法存在。因此要在輸入資料量大的時候解決一個NPC問題，通常我們使用下列的手段來解：\n近似演算法：這類演算法可以快速發現離最佳解在一定差距內的次佳解。\n亂數演算法：此類演算法可提供一亂數產生的輸入資料，讓本質上解答分佈均勻的受測程式可以有良好的求解效率。對於解答分佈不均勻的程式，則可以降低亂數程度以改變輸入資料。\n特例：此演算法可以在題目呈獻某些特殊情況時快速得解。參數化複雜度（英语：Parameterized complexity）（Parameterized complexity）可視為廣義的此類演算法。\n啟發式演算法：這種演算法在許多時候可以產生理性解答（即運用評比或線索找出解），但無法保證它效率的良莠與解答的好壞程度。一個啟發式演算法的例子是用在圖著色問題以O（n log n）的貪婪演算法找次佳解，用在某些編譯器的暫存器配置階段上，此技術又叫圖著色全域暫存器配置（graph-coloring global register allocation）。每頂點視為一變數，每邊代表兩變數同時使用的情況，顏色則代表配置給每一變數的暫存器編號。由於大多數的RISC機器擁有大量通用暫存器，因此啟發式演算法很適合用來解這類題目。", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的折衷的解法", "Tag": "算法设计"}
{"Answer": "依照上述NPC的定義，所謂的歸約（reduce to）其實是多項式時間多對一變換的簡稱。\n另一種歸約法稱為多项式时间图灵归约（polynomial-time Turing reduction）。若我們提供一個副函式（subroutine）可以在多項式時間解出\"Y\"，又可寫出呼叫此副函式的程式並在多項式時間解出問題\"X\"，代表我們可以將\"X\"多項式時間圖靈變換成\"Y\"。相較起來，不同處在於多對一變換只能呼叫上述副函式一次，且副函式的回傳值必須就是整個變換程式回傳的值。\n如果有人使用圖靈變換而非多對一變換來解析NPC，此問題的解答集合不一定會小於NPC。孰大孰小其實是個開放問題。如果兩個概念相同，則可導出NP=反NP（co-NP）。此結論成立的道理在於NPC與反NPC的定義以图灵归约來看是相等的，且圖靈變換定義的NPC包含多對一變換定義的NPC，反NPC也是相同情況。所以若是兩種變換定義的NPC一樣大的話，反NPC也會比照辦理（在兩者的定義之下）。例如SAT的反問題也會是NPC（在兩者的定義之下）。因此推得NP = 反NP（證明在反NP條目中）。雖然NP是否等於反NP是個開放問題，但一般認為這似乎不大可能，也因此那兩類的NPC定義也不大可能相等。\n另一種很常用於NPC證明的歸約手法是對數空間多對一變換（logarithmic-space many-one reduction），它是一種可以在對數量級空間運用的多對一變換法。由於每道可以在對數空間完成的運算也可以在多項式時間做完，因此能使用對數空間多對一變換的場合也可以使用多項式時間多對一變換。本方法較多項式時間多對一變換優雅，它也可以讓我們對演算法複雜度細分出更多分類，例如P完備複雜度。而NPC的定義是否會因為使用不同變換手法而產生差異，仍是一個未知的問題。\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的其他歸約法", "Tag": "算法设计"}
{"Answer": "NP-complete問題列表（英语：List of NP-complete problems）\n幾乎完備（英语：Almost complete）問題與弱完備（英语：weakly complete）問題\nASR-complete\nLadner理論\nNP困难\nP/NP问题\n三维匹配问题", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的参见", "Tag": "算法设计"}
{"Answer": "引用[编辑]\n\n^ 依据为《Introduction to Algorithms》3rd By Thomas H. Cormen英文版1078页，引理1\n\n^ How Complicated is Minesweeper? - Richard Kaye (PDF).   [2013-05-11]. （原始内容存档 (PDF)于2012-09-07）. \n\n书籍[编辑]^ S. A. Cook. The complexity of theorem proving procedures, Proceedings, Third Annual ACM Symposium on the Theory of Computing. New York: ACM. 1971: 151–158. \n^ Garey, M.; D. Johnson. Computers and Intractability; A Guide to the Theory of NP-Completeness. 1979. ISBN 978-0-7167-1045-5.  引文使用过时参数coauthors (帮助)（此書是發展此理論及集多種問題的經典）\nPaul E. Dunne. An Annotated List of Selected NP-complete Problems. The University of Liverpool, Dept of Computer Science, COMP202.   [2006-11-23]. （原始内容存档于2006-11-25）. \nPierluigi Crescenzi; Viggo Kann, Magnús Halldórsson, Marek Karpinski, and Gerhard Woeginger. A compendium of NP optimization problems. Stockholm: KTH NADA.   [2006-11-23]. （原始内容存档于2006-12-05）.  引文使用过时参数coauthors (帮助)\nThomas H. Cormen; Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. NP-Completeness. Introduction to Algorithms Second Edition. MIT Press and McGraw-Hill. 2001: 966-1021. ISBN 978-0-262-03293-3.  引文使用过时参数coauthors (帮助) 引文格式1维护：冗余文本 (link)\nMichael Sipser. NP-completeness, Additional NP-complete Problems. Introduction to the Theory of Computation. PWS Publishing. 1997: 248-271. ISBN 978-0-534-94728-6. \nChristos Papadimitriou. NP-complete problems. Computational Complexity 1st edition. Addison Wesley. 1993: 181–218. ISBN 978-0-201-53082-7.  引文格式1维护：冗余文本 (link)网页[编辑]Computational Complexity of Games and Puzzles（页面存档备份，存于互联网档案馆）\nTetris is Hard, Even to Approximate\nMinesweeper is NP-complete!", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的参考文献", "Tag": "算法设计"}
{"Answer": "\n\n^ 依据为《Introduction to Algorithms》3rd By Thomas H. Cormen英文版1078页，引理1\n\n^ How Complicated is Minesweeper? - Richard Kaye (PDF).   [2013-05-11]. （原始内容存档 (PDF)于2012-09-07）. \n\n", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的参考文献的引用", "Tag": "算法设计"}
{"Answer": "^ S. A. Cook. The complexity of theorem proving procedures, Proceedings, Third Annual ACM Symposium on the Theory of Computing. New York: ACM. 1971: 151–158. \n^ Garey, M.; D. Johnson. Computers and Intractability; A Guide to the Theory of NP-Completeness. 1979. ISBN 978-0-7167-1045-5.  引文使用过时参数coauthors (帮助)（此書是發展此理論及集多種問題的經典）\nPaul E. Dunne. An Annotated List of Selected NP-complete Problems. The University of Liverpool, Dept of Computer Science, COMP202.   [2006-11-23]. （原始内容存档于2006-11-25）. \nPierluigi Crescenzi; Viggo Kann, Magnús Halldórsson, Marek Karpinski, and Gerhard Woeginger. A compendium of NP optimization problems. Stockholm: KTH NADA.   [2006-11-23]. （原始内容存档于2006-12-05）.  引文使用过时参数coauthors (帮助)\nThomas H. Cormen; Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. NP-Completeness. Introduction to Algorithms Second Edition. MIT Press and McGraw-Hill. 2001: 966-1021. ISBN 978-0-262-03293-3.  引文使用过时参数coauthors (帮助) 引文格式1维护：冗余文本 (link)\nMichael Sipser. NP-completeness, Additional NP-complete Problems. Introduction to the Theory of Computation. PWS Publishing. 1997: 248-271. ISBN 978-0-534-94728-6. \nChristos Papadimitriou. NP-complete problems. Computational Complexity 1st edition. Addison Wesley. 1993: 181–218. ISBN 978-0-201-53082-7.  引文格式1维护：冗余文本 (link)", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的参考文献的书籍", "Tag": "算法设计"}
{"Answer": "Computational Complexity of Games and Puzzles（页面存档备份，存于互联网档案馆）\nTetris is Hard, Even to Approximate\nMinesweeper is NP-complete!", "Konwledge_Point": "NP完全", "Question": "什么是NP完全的参考文献的网页", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "数字信号处理器入门套件", "Question": "什么是数字信号处理器入门套件", "Tag": "算法设计"}
{"Answer": "在数学中，乘法（英語：multiplication）是加法的連續運算，同一数的若干次连加，其運算結果稱為積（英語：product）。\n\n  \n    \n      \n        \n          \n            \n              \n                a\n                +\n                a\n                +\n                a\n                +\n                ⋯\n                +\n                a\n              \n              ⏟\n            \n          \n          \n            n\n          \n        \n        =\n        a\n        ×\n        n\n      \n    \n    {\\displaystyle \\underbrace {a+a+a+\\cdots +a} _{n}=a\\times n}\n  \n須注意的是，華人地區有將四則運算的被運算數和運算數統一位置，所以被乘數放前面，乘數放後面。唸作「a 乘以 n」或「n 乘 a」。\n但在其它語言（如英文）中，有可能乘數是放在前的，寫作 \n  \n    \n      \n        n\n        ×\n        a\n      \n    \n    {\\displaystyle n\\times a}\n  \n ，唸作「n times a」。\n", "Konwledge_Point": "乘法", "Question": "什么是乘法", "Tag": "算法设计"}
{"Answer": "乘法可以用幾種方法表示。以下的式子表示“五乘以二”：\n\n  \n    \n      \n        5\n        ×\n        2\n      \n    \n    {\\displaystyle 5\\times 2}\n  \n\n\n  \n    \n      \n        5\n        ⋅\n        2\n      \n    \n    {\\displaystyle 5\\cdot 2}\n  \n\n\n  \n    \n      \n        5\n        ∗\n        2\n      \n    \n    {\\displaystyle 5*2}\n  \n\n\n  \n    \n      \n        (\n        5\n        )\n        (\n        2\n        )\n      \n    \n    {\\displaystyle (5)(2)}\n  \n古代常用的方法是將兩個數並排，沒有甚麼特別的符號來表示乘法。\n以「\n  \n    \n      \n        ×\n      \n    \n    {\\displaystyle \\times }\n  \n」表示乘法是威廉·奧特雷德最先使用，分別於一篇現時相信是於1618年他寫的附錄，和約於1628年寫作的、1631年出版的書《數學之鑰》（Clavis Mathematicae）內出現。以「\n  \n    \n      \n        ×\n      \n    \n    {\\displaystyle \\times }\n  \n」表示乘法是現在最流行的寫法。在電腦文書中，也有為方便鍵盤輸入而以小寫英文字母「x」替代「×」。\n以「\n  \n    \n      \n        ⋅\n      \n    \n    {\\displaystyle \\cdot }\n  \n」表示乘法現在用於德國和法國等國家，最早由托马斯·哈里奥特在1631年出版的著作使用，但對這個用法較有影響力的人是萊布尼茲。\n因為星號「\n  \n    \n      \n        ∗\n      \n    \n    {\\displaystyle *}\n  \n」是鍵盤必備的符號，電腦常用星號表示乘號，第一次在計算機使用這個用法的是FORTRAN（福傳）編程語言，事實上可以追溯到更早——1659年，Johann Rahn（1622年－1676年）在Teutsche Algebra一書中首次使用；但筆算時很少使用星號。\n代数中，乘號經常省略掉，形式如\n  \n    \n      \n        5\n        x\n      \n    \n    {\\displaystyle 5x}\n  \n和\n  \n    \n      \n        x\n        y\n      \n    \n    {\\displaystyle xy}\n  \n。若變數多於一個字母，容易使人混淆。這種表示法不會用於只有數字時，即\n  \n    \n      \n        5\n        ×\n        2\n      \n    \n    {\\displaystyle 5\\times 2}\n  \n不會表示成\n  \n    \n      \n        52\n      \n    \n    {\\displaystyle 52}\n  \n。\n乘積可以用大写希臘字母Π（Pi，\n  \n    \n      \n        Π\n      \n    \n    {\\displaystyle \\Pi }\n  \n）來表示：\n\n  \n    \n      \n        \n          ∏\n          \n            i\n            =\n            m\n          \n          \n            n\n          \n        \n        \n          x\n          \n            i\n          \n        \n        :=\n        \n          x\n          \n            m\n          \n        \n        ⋅\n        \n          x\n          \n            m\n            +\n            1\n          \n        \n        ⋅\n        \n          x\n          \n            m\n            +\n            2\n          \n        \n        ⋅\n        …\n        ⋅\n        \n          x\n          \n            n\n            −\n            1\n          \n        \n        ⋅\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\prod _{i=m}^{n}x_{i}:=x_{m}\\cdot x_{m+1}\\cdot x_{m+2}\\cdot \\ldots \\cdot x_{n-1}\\cdot x_{n}}\n  \n", "Konwledge_Point": "乘法", "Question": "什么是乘法的表示法", "Tag": "算法设计"}
{"Answer": "兩個整數的積是：\n\n  \n    \n      \n        m\n        n\n        =\n        \n          ∑\n          \n            k\n            =\n            1\n          \n          \n            n\n          \n        \n        m\n      \n    \n    {\\displaystyle mn=\\sum _{k=1}^{n}m}\n  \n這是“將m加到自己n次”的簡化說法。更清晰來說：\n\n  \n    \n      \n        m\n        n\n        =\n        \n          \n            \n              \n                m\n                +\n                m\n                +\n                m\n                +\n                ⋯\n                +\n                m\n              \n              ⏟\n            \n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle mn=\\underbrace {m+m+m+\\cdots +m} _{n}}\n  \n使用上面的定義，我們很易找到一些乘法的性質：\n交換律：\n  \n    \n      \n        x\n        y\n        =\n        y\n        x\n      \n    \n    {\\displaystyle xy=yx}\n  \n\n結合律：\n  \n    \n      \n        (\n        x\n        y\n        )\n        z\n        =\n        x\n        (\n        y\n        z\n        )\n      \n    \n    {\\displaystyle (xy)z=x(yz)}\n  \n\n分配律：\n  \n    \n      \n        x\n        (\n        y\n        +\n        z\n        )\n        =\n        x\n        y\n        +\n        x\n        z\n      \n    \n    {\\displaystyle x(y+z)=xy+xz}\n  \n將任何數乘以一都會等於該數本身，即\n  \n    \n      \n        1\n        x\n        =\n        x\n      \n    \n    {\\displaystyle 1x=x}\n  \n，稱為單位律。\n將任何數乘以零，即是甚麼也沒做過，結果就是零，即\n  \n    \n      \n        0\n        x\n        =\n        0\n      \n    \n    {\\displaystyle 0x=0}\n  \n。\n當\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n是量，\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n是自然數，乘法的递归定義：\n\n  \n    \n      \n        0\n        x\n        =\n        0\n      \n    \n    {\\displaystyle 0x=0}\n  \n\n\n  \n    \n      \n        x\n        y\n        =\n        x\n        +\n        x\n        (\n        y\n        −\n        1\n        )\n      \n    \n    {\\displaystyle xy=x+x(y-1)}\n  \n", "Konwledge_Point": "乘法", "Question": "什么是乘法的定義", "Tag": "算法设计"}
{"Answer": "  孙子筹算乘法  印度的格子乘法最早最详细的关于十进位制乘法的规则，首见西元400年左右孙子算经。孙子乘法在9世纪经花拉子米介绍而流行于阿拉伯国家，13世纪被翻译成拉丁文而流行西方。\n印度的格子乘法在唐代流入中国，在9世纪初经花拉子米介绍到阿拉伯，但都未能流行。\n", "Konwledge_Point": "乘法", "Question": "什么是乘法的历史", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "乘法", "Question": "什么是乘法的計算", "Tag": "算法设计"}
{"Answer": "\n", "Konwledge_Point": "乘法", "Question": "什么是乘法的參考", "Tag": "算法设计"}
{"Answer": "在可計算性理論與計算複雜性理論中，所謂的歸約是將某個計算問題（英语：computational problem）轉換為另一個問題的過程。可用歸約法定義某些問題的複雜度類（因轉換過程而異）。\n以直覺觀之，如果存在能有效解決問題B的算法，也可以作為解決問題A的子程序，則將問題A稱為「可歸約」到問題B，因此求解A並不會比求解B更困難。\n一般寫作A ≤m B，通常也在≤符號下標使用的歸約類型（m：映射縮小，p：多項式縮減）。\n將一組問題歸約到特定類型所產生的數學結構，通常形成预序关系，其等價類可用於定義求解難度和複雜度。\n", "Konwledge_Point": "歸約", "Question": "什么是歸約", "Tag": "算法设计"}
{"Answer": "  以乘法與平方為例的多一歸約示意圖。我們解題時常遇見似曾相識的題目。此時，我們若可將新題轉換成已解舊題的一例，則新題亦解矣。\n另一更微妙的用法是：若我們擁有一個已證明難以解決的問題，我們又獲得另一個相似的新問題。我們可合理推想此新問題亦是難以解決的。我們可由下列謬證法得證：若此新問題本質上容易解答，且若我們可展示每個舊問題的實例可經由一系列轉換步驟變成新問題的實例，則舊問題便容易解決，因此得到悖論。因此新問題可知亦難以解決。\n一個歸約簡例是從乘法化成平方。設想我們僅能以加、減、平方與除以二等操作，我們可運用此知識並結合下列方程式，以取得任兩數的乘積：\n\n  \n    \n      \n        a\n        ×\n        b\n        =\n        \n          \n            \n              (\n              \n                \n                  \n                    (\n                    \n                      a\n                      +\n                      b\n                    \n                    )\n                  \n                  \n                    2\n                  \n                \n                −\n                \n                  a\n                  \n                    2\n                  \n                \n                −\n                \n                  b\n                  \n                    2\n                  \n                \n              \n              )\n            \n            2\n          \n        \n      \n    \n    {\\displaystyle a\\times b={\\frac {\\left(\\left(a+b\\right)^{2}-a^{2}-b^{2}\\right)}{2}}}\n  \n我們亦可從另一方向歸約此問題：顯然地，若我們可以乘以任兩數，則我們可以對任一數平方：\n\n  \n    \n      \n        \n          a\n          \n            2\n          \n        \n        =\n        a\n        ×\n        a\n      \n    \n    {\\displaystyle a^{2}=a\\times a}\n  \n因此可見兩問題之難度似乎相等，此類歸約稱為圖靈歸約。上題的圖靈歸約關係為：\n乘法\n  \n    \n      \n        \n          ≤\n          \n            T\n          \n        \n      \n    \n    {\\displaystyle \\leq _{T}}\n  \n平方且 平方\n  \n    \n      \n        \n          ≤\n          \n            T\n          \n        \n      \n    \n    {\\displaystyle \\leq _{T}}\n  \n乘法然而，若我們增加條件：「此運算只能使用平方一次，且只能在結尾使用」，則更難尋找合適歸約。在這條件下，即使我們使用所有基礎運算，包括乘法，也找不到適當的歸約步驟。因為我們不僅要運算有理數，也必須運算像是\n  \n    \n      \n        \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\sqrt {2}}}\n  \n的無理數。而另一方向的歸約，我們的確可用一次乘法簡單地平方任何數，且此乘法的確是最後的運算。將此限制形式導入歸約中，我們已展示其歸約結論：普遍來說，乘法的確難於平方。此歸約稱為多一歸約。上題的多一歸約關係為：\n平方\n  \n    \n      \n        \n          ≤\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle \\leq _{m}}\n  \n乘法（因為每個合法的整數平方式n2都可歸約成乘法n×n，但反之不然）", "Konwledge_Point": "歸約", "Question": "什么是歸約的簡易介紹", "Tag": "算法设计"}
{"Answer": "給予兩個自然數N的子集A與B，以及一個函數集合F，型態為由N至N，並擁有複合封閉性。我們稱在F下，A可歸約成B若：\n\n  \n    \n      \n        ∃\n        f\n        ∈\n        F\n        \n          \n             . \n          \n        \n        ∀\n        x\n        ∈\n        \n          N\n        \n        \n          \n             . \n          \n        \n        x\n        ∈\n        A\n        ⇔\n        f\n        (\n        x\n        )\n        ∈\n        B\n      \n    \n    {\\displaystyle \\exists f\\in F{\\mbox{ . }}\\forall x\\in \\mathbb {N} {\\mbox{ . }}x\\in A\\Leftrightarrow f(x)\\in B}\n  \n我們寫做：\n\n  \n    \n      \n        A\n        \n          ≤\n          \n            F\n          \n        \n        B\n      \n    \n    {\\displaystyle A\\leq _{F}B}\n  \n設S為P(N)（即自然数集的幂集）的子集，另設≤的歸約關係，則S稱做封閉於≤之下若：\n\n  \n    \n      \n        ∀\n        s\n        ∈\n        S\n        \n          \n             . \n          \n        \n        ∀\n        A\n        ∈\n        P\n        (\n        \n          N\n        \n        )\n        \n          \n             . \n          \n        \n        A\n        ≤\n        s\n        ⇔\n        A\n        ∈\n        S\n      \n    \n    {\\displaystyle \\forall s\\in S{\\mbox{ . }}\\forall A\\in P(\\mathbb {N} ){\\mbox{ . }}A\\leq s\\Leftrightarrow A\\in S}\n  \n一N的子集A，稱對S困難（hard），若：\n\n  \n    \n      \n        ∀\n        s\n        ∈\n        S\n        \n          \n             . \n          \n        \n        s\n        ≤\n        A\n      \n    \n    {\\displaystyle \\forall s\\in S{\\mbox{ . }}s\\leq A}\n  \n一N的子集A，若A對S困難且A包含於S集合之內，則稱A對S完備（complete）。\n", "Konwledge_Point": "歸約", "Question": "什么是歸約的定義", "Tag": "算法设计"}
{"Answer": "主条目：复杂性类若要證明一問題是不可在決定的，我们可以一可計算函數將它轉換成另一已知不可決定的問題，例如，欲證P是不可決定的，可試將停機問題化約成問題P。\n複雜度類P、NP與PSPACE擁有多項式時間歸約的封閉性。\n複雜度類L、NL、P、NP與PSPACE擁有對數空間歸約的封閉性。詳例[编辑]主条目：停机问题下例利用從停機問題至某個語言的轉換，以證明該語言是不可決定的。設H(M,w)是問題：「判定給定的圖靈機M會否在輸入字串w後停機（接受或拒絕此字串）」。此語言已知是不可決定的[1]。又設E(M)是問題：「給定圖靈機M，判定它所接受的語言是否空（意即M是否接受任何字串）」。我們可以藉由從H歸約成E以顯示E也是不可決定的。\n為了獲得悖論，假設R是E的一個仲裁機器（英语：decider）（即一定會停的圖靈機），我們將用此機器R產生問題H的仲裁機器S。給予輸入資料——一個圖靈機M與某些輸入字串w，定義圖靈機S(M,w)：S創造一個圖靈機N，N僅接受輸入圖靈機M時會停止的字串w，輸入其他字串則N進入無窮迴圈。仲裁機器S現在可評估R(N)，以驗證被N接受的語言是否為空集合。如果R接受N，則被N接受的語言是空集合，所以M不會在輸入為w時停止，所以S可以拒絕。如果R拒絕N，則被N接受的語言是非空集合，則M不會在輸入為w時停止，故S可接受。因此若我們有了E的一仲裁機器R，則我們將能產生停機問題H(M,w)及任何機器M與任何輸入字串w的仲裁機器S。但我們已知此S絕對不存在，故得矛盾。因此可知語言E同樣也是不可決定的。\n", "Konwledge_Point": "歸約", "Question": "什么是歸約的复杂性类的判别", "Tag": "算法设计"}
{"Answer": "主条目：停机问题下例利用從停機問題至某個語言的轉換，以證明該語言是不可決定的。設H(M,w)是問題：「判定給定的圖靈機M會否在輸入字串w後停機（接受或拒絕此字串）」。此語言已知是不可決定的[1]。又設E(M)是問題：「給定圖靈機M，判定它所接受的語言是否空（意即M是否接受任何字串）」。我們可以藉由從H歸約成E以顯示E也是不可決定的。\n為了獲得悖論，假設R是E的一個仲裁機器（英语：decider）（即一定會停的圖靈機），我們將用此機器R產生問題H的仲裁機器S。給予輸入資料——一個圖靈機M與某些輸入字串w，定義圖靈機S(M,w)：S創造一個圖靈機N，N僅接受輸入圖靈機M時會停止的字串w，輸入其他字串則N進入無窮迴圈。仲裁機器S現在可評估R(N)，以驗證被N接受的語言是否為空集合。如果R接受N，則被N接受的語言是空集合，所以M不會在輸入為w時停止，所以S可以拒絕。如果R拒絕N，則被N接受的語言是非空集合，則M不會在輸入為w時停止，故S可接受。因此若我們有了E的一仲裁機器R，則我們將能產生停機問題H(M,w)及任何機器M與任何輸入字串w的仲裁機器S。但我們已知此S絕對不存在，故得矛盾。因此可知語言E同樣也是不可決定的。\n", "Konwledge_Point": "歸約", "Question": "什么是歸約的复杂性类的判别的詳例", "Tag": "算法设计"}
{"Answer": "歸約亦是一種預序關係，意指在P(N)×P(N)，此P(N)上擁有自反關係與傳遞關係，此處的P(N)是自然數的冪集（power set）。\n若在某個複雜度類別上的所有問題都可歸約成某問題P，則可稱P是完備（complete）的，且P自己也會處於此類別中。故問題P代表此類別，因其任一解都可經由歸約解決此類別中的所有問題。[2]\n", "Konwledge_Point": "歸約", "Question": "什么是歸約的註", "Tag": "算法设计"}
{"Answer": "依上例所述，在計算複雜度中，主要有兩大類的歸約：多一歸約與圖靈歸約。多一歸約將一問題的所有實例對應到另一問題的實例上；圖靈歸約計算一問題的解，並假設其他問題容易解決。多一歸約強於圖靈歸約。較弱的歸約在分割問題的種類上效率較高，但它們的威力較弱，使本類歸約較難設計。\n然而，為了使歸約有用，它們必須易於使用。例如實際研究中常常要將難以得解的NP完備問題，例如SAT問題，歸約成顯而易懂的問題，像藉由效率為指數時間並在有解時輸出整數零的機器，決定一數是否為零。但這並沒有多少用處，因為我們可以執行如同解決舊問題一樣難的歸約以解決新問題。\n因此，依照複雜度類別使用適當歸約符號的學問興起。在鑽研複雜度類NP與更難的類別時，我們使用多項式時間多一歸約。在多項式譜系中定義類別時，我們使用多項式時間圖靈歸約。當我們在類別P之內學習NC與NL類別時，我們使用對數空間歸約。歸約也用在可計算性理論中，以顯示問題是否可不可被任何機器解決；在此情境下，歸約僅侷限於可計算函數上。\n", "Konwledge_Point": "歸約", "Question": "什么是歸約的歸約種類與應用", "Tag": "算法设计"}
{"Answer": "\n\n^ 例如：存档副本.   [2007-01-06]. （原始内容存档于2007-01-17）. \n\n^ Thomas H. Cormen, Introduction to Algorithm, second edition, page. 970, figure 34.1.\n\n", "Konwledge_Point": "歸約", "Question": "什么是歸約的参考文献", "Tag": "算法设计"}
{"Answer": "多一歸約\n真值表歸約\n圖靈歸約\nComparison of numberings\n優化 (計算機)", "Konwledge_Point": "歸約", "Question": "什么是歸約的參閱", "Tag": "算法设计"}
{"Answer": "（英文） Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein, Introduction to Algorithms, Second Edition, 2001, ISBN 978-0-262-03293-3\n（英文） Hartley Rogers, Jr.: Theory of Recursive Functions and Effective Computability, McGraw-Hill, 1967, ISBN 978-0-262-68052-3.\n（英文） Peter Bürgisser: Completeness and Reduction in Algebraic Complexity Theory, Springer, 2000, ISBN 978-3-540-66752-0.\n（英文） E.R. Griffor: Handbook of Computability Theory, North Holland, 1999, ISBN 978-0-444-89882-1.", "Konwledge_Point": "歸約", "Question": "什么是歸約的文獻", "Tag": "算法设计"}
{"Answer": "在计算机科学中，分治法（英語：Divide and conquer）是建基於多項分支遞歸的一种很重要的算法範式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。\n这个技巧是很多高效算法的基础，如排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）。\n另一方面，理解及設計分治法算法的能力需要一定時間去掌握。正如以歸納法去證明一個理論，為了使遞歸能夠推行，很多時候需要用一個較為概括或複雜的問題去取代原有問題。而且並沒有一個系統性的方法去適當地概括問題。\n分治法這個名稱有時亦會用於將問題簡化為只有一個細問題的算法，例如用於在已排序的列中尋找其中一項的折半搜索算法（或是在數值分析中類似的勘根算法）。這些算法比一般的分治算法更能有效地執行。其中，假如算法使用尾部遞歸的話，便能轉換成簡單的迴圈。但在這廣義之下，所有使用遞歸或迴圈的算法均被視作「分治算法」。因此，有些作者考慮「分治法」這個名稱應只用於每個有最少兩個子問題的算法。而只有一個子問題的曾被建議使用減治法這個名稱。\n分治算法通常以數學歸納法來驗證。而它的計算成本則多數以解遞迴關係式來判定。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法", "Tag": "算法设计"}
{"Answer": "折半搜索算法——一個將原來問題連逐地拆細成大約一半大小的單一子問題的分治算法——擁有一段悠長歴史。雖然算法在計算機上的清楚描述出現在1946年約翰莫齊利（John Mauchly）的一篇文章裡，然而利用已排序的物件序列去加快搜尋的構想早已在公元前200年的巴比倫尼亞出現。另一個單一子問題的分治算法是找出2個數的最大公因數的輾轉相除法（透過將數字化小至使子問題變得簡單），於公元前數世紀已經出現。\n一個早期有多個子問題的分治算法是高斯在1805年描述關於快速傅立葉变换的算法，儘管他沒有量化地分析它的操作數目，而快速傅立葉变换直至在一世紀之後被重新發現之前亦沒有廣泛流傳。這個算法現在稱為库利－图基快速傅里叶变换算法。\n至於專門用於計算機之上而且正確地分析的分治算法早期例子，則可以數到约翰·冯·诺伊曼於1945年發明的歸並排序。\n另一個顯著的例子是Anatolii Alexeevitch Karatsuba於1960年發明在\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            3\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{\\log _{2}3})}\n  \n步驟內將兩個n位數相乘的Karatsuba算法。它反證了安德雷·柯爾莫哥洛夫於1956年認為這個乘法需要\n  \n    \n      \n        Ω\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle \\Omega (n^{2})}\n  \n步驟的猜想。\n高德納舉了一個最初並沒有涉及計算機的分治算法例子，就是一般郵局用於分發信件的方法：信件在主要郵局根據不同的地理範圍而分到不同的袋裡，每個袋亦在運送到地區郵局時分到更小的袋裡，如是者直至信件被派發為止。這個方法與早於1929年的打孔卡排序機所用的基数排序相類同。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的早期历史上的先例", "Tag": "算法设计"}
{"Answer": "解决困难问题[编辑]分治算法是一个解决复杂问题的好工具，它可以把问题分解成若干个子问题，把子问题逐个解决，再组合到一起形成大问题的答案。比如，汉诺塔问题如果采用分治算法，可以把高度为n的塔的问题转换成高度为n-1的塔来解决，如此重复，直至问题化简到可以很容易的处理为止。\n算法效率[编辑]人们发现有很多效率很高的分治算法，比如，Karatsuba快速乘法算法、快速排序算法和并行算法、矩阵乘法的施特拉森演算法、快速傅里叶变换等。\n同步性[编辑]修正控制[编辑]", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势", "Tag": "算法设计"}
{"Answer": "分治算法是一个解决复杂问题的好工具，它可以把问题分解成若干个子问题，把子问题逐个解决，再组合到一起形成大问题的答案。比如，汉诺塔问题如果采用分治算法，可以把高度为n的塔的问题转换成高度为n-1的塔来解决，如此重复，直至问题化简到可以很容易的处理为止。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的解决困难问题", "Tag": "算法设计"}
{"Answer": "人们发现有很多效率很高的分治算法，比如，Karatsuba快速乘法算法、快速排序算法和并行算法、矩阵乘法的施特拉森演算法、快速傅里叶变换等。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的算法效率", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的同步性", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的修正控制", "Tag": "算法设计"}
{"Answer": "循环递归[编辑]在每一层递归上都有三个步骤：\n分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题。\n解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题。\n合并：将各子问题的解合并为原问题的解。显堆栈[编辑]", "Konwledge_Point": "分治法", "Question": "什么是分治法的实现", "Tag": "算法设计"}
{"Answer": "在每一层递归上都有三个步骤：\n分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题。\n解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题。\n合并：将各子问题的解合并为原问题的解。", "Konwledge_Point": "分治法", "Question": "什么是分治法的实现的循环递归", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "分治法", "Question": "什么是分治法的实现的显堆栈", "Tag": "算法设计"}
{"Answer": "分治法在高级语言中主要的一个思想是递归，LISP语言中的体现出了极丰富的分治法。\n以下是归并排序C语言的示例代码，输入参数中，需要排序的数组为array[],起始索引为first，终止索引为last。调用完成后，array[]中从first到last处于升序排列。\n void merge_sort(int array[], unsigned int first, unsigned int last)\n {\n \tint mid = 0;\n \tif(first<last)\n \t{\n \t\tmid = (first+last)/2;\n \t\tmerge_sort(array, first, mid);\n \t\tmerge_sort(array, mid+1,last);\n \t\tmerge(array,first,mid,last);\n \t}\n }\n在程式中可以看出分治法的應用：在merge_sort()中，將原來針對索引first到last的數組排序的問題，分為二份較小的問題\n先針對索引first到mid的數組排序。\n再針對索引mid+1到last的數組排序。最後再進行二個數組的合併。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的示例", "Tag": "算法设计"}
{"Answer": "分叉会合模型", "Konwledge_Point": "分治法", "Question": "什么是分治法的参见", "Tag": "算法设计"}
{"Answer": "密碼學（英語：Cryptography）可分为古典密码学和现代密码学。在西方語文中，密码学一词源於希臘語kryptós“隱藏的”，和gráphein“書寫”。古典密码学主要关注信息的保密书写和传递，以及与其相对应的破译方法。而现代密码学不只关注信息保密问题，还同时涉及信息完整性验证（消息验证码）、信息发布的不可抵赖性（数字签名）、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。古典密码学与现代密码学的重要区别在于，古典密码学的编码和破译通常依赖于设计者和敌手的创造力与技巧，作为一种实用性艺术存在，并没有对于密码学原件的清晰定义。而现代密码学则起源于20世纪末出现的大量相关理论，这些理论使得现代密码学成为了一种可以系统而严格地学习的科学。\n密码学是数学和计算机科学的分支，同时其原理大量涉及信息论。著名的密碼學者罗纳德·李维斯特解釋道：「密碼學是關於如何在敵人存在的環境中通訊」，自工程學的角度，這相當于密碼學與純數學的差异。密碼學的发展促進了计算机科学，特別是在於電腦與網路安全所使用的技術，如存取控制與資訊的機密性。密碼學已被應用在日常生活：包括自动柜员机的晶片卡、電腦使用者存取密碼、電子商務等等。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学", "Tag": "算法设计"}
{"Answer": "直到現代以前，密碼學幾乎專指加密算法：將普通信息（明文）轉換成難以理解的資料（密文）的過程；解密算法則是其相反的過程：由密文轉換回明文；加解密包含了這兩種算法，一般加密即同時指稱加密與解密的技術。\n加解密的具体運作由两部分决定：一个是算法，另一个是密钥。密钥是一個用於加解密算法的秘密參數，通常只有通訊者擁有。歷史上，密钥通常未經認證或完整性測試而被直接使用在加解密上。\n密码协议是使用密碼技術的通信协议。近代密碼學者多認為除了傳統上的加解密演算法，密码协议也一樣重要，兩者為密碼學研究的兩大課題。在英文中，“cryptography”和“cryptology”都可代表密碼學，前者又称密碼術。但更嚴謹地说，前者（cryptography）指密碼技術的使用，而后者（cryptology）指研究密码的學問，包含密碼術與密码分析。密码分析是研究如何破解密碼學的學問。但在实际使用中，通常都称密码学（即cryptography），而不具体区分其含义。\n編碼：它意指以碼字（英语：code word）取代特定的明文。例如，以『蘋果派』（apple pie）替換『拂曉攻擊』（attack at dawn）。編碼已經不再被使用在嚴謹的密碼學，它在信息论或通訊原理上有更明確的意義。\n在漢語口語中，電腦系統或網路使用的個人帳戶通行碼也常被以密碼代稱，雖然通行碼亦屬密碼學研究的範圍，但學術上通行碼與密碼學中所稱的金鑰並不相同，即使兩者間常有密切的關連。\n對稱金鑰加密[编辑]對稱金鑰加密是密碼學中的一種加密法，是以轉換其中一個數字、字母或僅字串隨機字母，一個秘密金鑰會以特定的方式變更訊息里面的文字或字母，例如更換字母相对位置（例如hello變成lohel）。只要寄件者與收件者知道秘密金鑰，他們可以加密和解密並使用這個資料。\n公開金鑰加密[编辑]公開金鑰加密（也稱為非對稱加密）是密碼學中的一種加密法，非對稱金鑰，是指一對加密金鑰與解密金鑰，某使用者使用加密金鑰加密後所獲得的資料，只能用該使用者的解密金鑰才能夠解密。如果知道了其中一個，並不能計算出另外一個。因此如果公開了其中一個金鑰，並不會危害到另外一個。因此公開的金鑰為公鑰；不公開的密鑰為私鑰。\n數位簽章[编辑]數位簽章（又稱公鑰數位簽章、電子簽章）是一種類似寫在紙上的簽名，但是使用了公鑰加密領域的技術實現，用於鑒別數位信息的方法。在網路上，我們可以使用“數位簽章”來進行身份確認。數位簽章是一個獨一無二的數值，若公鑰能通過驗證，那我們就能確定對應的公鑰的正確性，數位簽章兼具這兩種雙重屬性：\"可確認性\"及\"不可否認性（不需要筆跡專家驗證）\"。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的術語", "Tag": "算法设计"}
{"Answer": "對稱金鑰加密是密碼學中的一種加密法，是以轉換其中一個數字、字母或僅字串隨機字母，一個秘密金鑰會以特定的方式變更訊息里面的文字或字母，例如更換字母相对位置（例如hello變成lohel）。只要寄件者與收件者知道秘密金鑰，他們可以加密和解密並使用這個資料。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的術語的對稱金鑰加密", "Tag": "算法设计"}
{"Answer": "公開金鑰加密（也稱為非對稱加密）是密碼學中的一種加密法，非對稱金鑰，是指一對加密金鑰與解密金鑰，某使用者使用加密金鑰加密後所獲得的資料，只能用該使用者的解密金鑰才能夠解密。如果知道了其中一個，並不能計算出另外一個。因此如果公開了其中一個金鑰，並不會危害到另外一個。因此公開的金鑰為公鑰；不公開的密鑰為私鑰。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的術語的公開金鑰加密", "Tag": "算法设计"}
{"Answer": "數位簽章（又稱公鑰數位簽章、電子簽章）是一種類似寫在紙上的簽名，但是使用了公鑰加密領域的技術實現，用於鑒別數位信息的方法。在網路上，我們可以使用“數位簽章”來進行身份確認。數位簽章是一個獨一無二的數值，若公鑰能通過驗證，那我們就能確定對應的公鑰的正確性，數位簽章兼具這兩種雙重屬性：\"可確認性\"及\"不可否認性（不需要筆跡專家驗證）\"。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的術語的數位簽章", "Tag": "算法设计"}
{"Answer": "主条目：密碼學歷史許多物理裝置被用來輔助加密，例如古希臘斯巴達的密碼棒，這是一個協助置換法的圓柱體，可將資訊內字母的次序調動，利用了字條纏繞木棒的方式，把字母進行位移，收信人要使用相同直徑的木棒才能得到還原的資訊。在歐洲中世紀時期，密碼欄（英语：cipher grille）用在某類隱寫術上。\n多字元加密法出現後，更多樣的輔助工具出現，如阿伯提發明的密碼盤、特里特米烏斯發明的表格法、以及美國總統湯瑪斯·傑佛遜發明的杰弗逊圆盘（英语：Jefferson disk）（巴泽里耶斯（英语：Bazeries）約在1900年再次獨立發明改進）。\n二十世紀早期，多項加解密機械被發明且被註冊專利，包括最有名的轉輪機（英语：rotor machines），第二次世界大戰德軍所用，別名『謎』式密碼機（恩尼格玛密码机），其加密法是在第一次世界大戰後針對當時破密術所做最好的設計。\n二十世紀早期的密碼學本質上主要考慮語言學上的模式。從此之後重心轉移，現在密碼學使用大量的數學，包括資訊理論、計算複雜性理論、統計學、組合學、抽象代數以及數論。密碼學同時也是工程學的分支，但卻是與別不同，因為它必須面對有智能且惡意的對手，大部分其他的工程僅需處理無惡意的自然力量。檢視密碼學問題與量子物理間的關連也是目前熱門的研究。\n經典密碼學[编辑]主条目：經典密碼在近代以前，密碼學只考慮到訊息的機密性：如何將可理解的訊息轉換成難以理解的訊息，並且使得有秘密訊息的人能够逆向回復，但缺乏秘密訊息的攔截者或竊聽者则無法解讀。近數十年來，這個領域已經擴展到涵蓋身分認證（或称鉴权）、訊息完整性檢查、数字签名、互動證明、安全多方計算等各類技術。\n古中國周朝兵書《六韬．龍韜》記載了密碼學的運用，其中的《陰符》和《陰書》便記載了周武王問姜子牙關於征戰時與主將通訊的方式：\n\n太公曰：「主與將，有陰符，凡八等。有大勝克敵之符，長一尺。破軍擒將之符，長九寸。降城得邑之符，長八寸。卻敵報遠之符，長七寸。警眾堅守之符，長六寸。請糧益兵之符，長五寸。敗軍亡將之符，長四寸。失利亡士之符，長三寸。諸奉使行符，稽留，若符事聞，泄告者，皆誅之。八符者，主將祕聞，所以陰通言語，不泄中外相知之術。敵雖聖智，莫之能識。」\n武王問太公曰：「…符不能明；相去遼遠，言語不通。為之奈何？」\n太公曰：「諸有陰事大慮，當用書，不用符。主以書遺將，將以書問主。書皆一合而再離，三發而一知。再離者，分書為三部。三發而一知者，言三人，人操一分，相參而不相知情也。此謂陰書。敵雖聖智，莫之能識。」\n\n陰符是以八等長度的符來表達不同的消息和指令，可算是密碼學中的替代法（英语：substitution），把資訊轉變成敵人看不懂的符號。至於陰書則運用了移位法，把書一分為三，分三人傳遞，要把三份書重新拼合才能獲得還原的資訊。\n进入宋朝，有字验的加密方法。\n其實在公元前，秘密書信已用於戰爭之中。西洋「史學之父」（pater historiae）希羅多德的《歷史》當中記載了一些最早的秘密書信故事。公元前5世紀，希臘城邦為對抗奴役和侵略，與波斯發生多次衝突和戰爭。於西元前480年，波斯秘密結了強大的軍隊，準備對雅典和斯巴達發動一次突襲。希臘人狄馬拉圖斯在波斯的蘇薩城裏看到了這次集結，便利用了一層蠟把木板上的字遮蓋住，送往並告知了希臘人波斯的圖謀。最後，波斯海軍覆沒於雅典附近的沙拉米斯灣（英语：Salamis Bay）。\n据说，斯巴达司令派人给前线送一条这样的腰带：[1]\nKGDEINPKLRIJLFGOKLMNISOJNTVWG\n指挥官拿到后，把它缠在一条木棍上，得到明文“Kill King”，如下：\nKGDEINPKLRIJLFGOKLMNISOJNTVWG\n即每4位取一个字母。其他字母是干扰的。但此传说并未得到证实，因为故事发生的地点在希腊和波斯，但密文却是英文。\n由於古時多數人並不識字，最早的秘密書寫的形式只用到紙筆或等同物品，隨著識字率提高，就開始需要真正的密碼學了。最古典的兩個加密技巧是：\n转置密码（英语：Transposition cipher）：將字母順序重新排列，例如『help me』變成『ehpl em』；與\n替换式密码：有系統地將一組字母換成其他字母或符號，例如『fly at once』變成『gmz bu podf』（每個字母用下一個字母取代）。這兩種單純的方式都不足以提供足夠的機密性。凱撒密码是最經典的替代法，據傳由古羅馬帝國的皇帝凱撒所發明，用在與遠方將領的通訊上，每個字母被往後位移三格字母所取代。\n加密旨在確保通訊的秘密性，例如間諜、軍事將領、外交人員間的通訊，同時也有宗教上的應用。舉例來說，早期基督徒使用密碼學模糊他們寫作的部份觀點以避免遭受迫害。666年或部分更早期的手稿上的616年是新約聖經啟示錄所指的野獸的數字，常用來暗指專迫害基督徒的古羅馬皇帝尼祿。史上也有部份希伯來文密碼的記載。古印度慾经中也提及愛侶可利用密碼來通信。隱寫術也出現在古代，希羅多德記載將訊息刺青在奴隸的頭皮上，較近代的隱寫術使用隱形墨水、縮影術或数字水印來隱藏訊息。\n除了應用於軍事外，西元四世紀婆羅門學者伐蹉衍那（英语：Vatsyayana）所書的《慾經》4中曾提及到用代替法加密資訊。書中第45項是秘密書信（英语：mlecchita-vikalpa），用以幫助婦女隱瞞她們與愛郞之間的關係。其中一種方法是把字母隨意配對互換，如套用在羅馬字母中，可有得出下表：\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史", "Tag": "算法设计"}
{"Answer": "主条目：經典密碼在近代以前，密碼學只考慮到訊息的機密性：如何將可理解的訊息轉換成難以理解的訊息，並且使得有秘密訊息的人能够逆向回復，但缺乏秘密訊息的攔截者或竊聽者则無法解讀。近數十年來，這個領域已經擴展到涵蓋身分認證（或称鉴权）、訊息完整性檢查、数字签名、互動證明、安全多方計算等各類技術。\n古中國周朝兵書《六韬．龍韜》記載了密碼學的運用，其中的《陰符》和《陰書》便記載了周武王問姜子牙關於征戰時與主將通訊的方式：\n\n太公曰：「主與將，有陰符，凡八等。有大勝克敵之符，長一尺。破軍擒將之符，長九寸。降城得邑之符，長八寸。卻敵報遠之符，長七寸。警眾堅守之符，長六寸。請糧益兵之符，長五寸。敗軍亡將之符，長四寸。失利亡士之符，長三寸。諸奉使行符，稽留，若符事聞，泄告者，皆誅之。八符者，主將祕聞，所以陰通言語，不泄中外相知之術。敵雖聖智，莫之能識。」\n武王問太公曰：「…符不能明；相去遼遠，言語不通。為之奈何？」\n太公曰：「諸有陰事大慮，當用書，不用符。主以書遺將，將以書問主。書皆一合而再離，三發而一知。再離者，分書為三部。三發而一知者，言三人，人操一分，相參而不相知情也。此謂陰書。敵雖聖智，莫之能識。」\n\n陰符是以八等長度的符來表達不同的消息和指令，可算是密碼學中的替代法（英语：substitution），把資訊轉變成敵人看不懂的符號。至於陰書則運用了移位法，把書一分為三，分三人傳遞，要把三份書重新拼合才能獲得還原的資訊。\n进入宋朝，有字验的加密方法。\n其實在公元前，秘密書信已用於戰爭之中。西洋「史學之父」（pater historiae）希羅多德的《歷史》當中記載了一些最早的秘密書信故事。公元前5世紀，希臘城邦為對抗奴役和侵略，與波斯發生多次衝突和戰爭。於西元前480年，波斯秘密結了強大的軍隊，準備對雅典和斯巴達發動一次突襲。希臘人狄馬拉圖斯在波斯的蘇薩城裏看到了這次集結，便利用了一層蠟把木板上的字遮蓋住，送往並告知了希臘人波斯的圖謀。最後，波斯海軍覆沒於雅典附近的沙拉米斯灣（英语：Salamis Bay）。\n据说，斯巴达司令派人给前线送一条这样的腰带：[1]\nKGDEINPKLRIJLFGOKLMNISOJNTVWG\n指挥官拿到后，把它缠在一条木棍上，得到明文“Kill King”，如下：\nKGDEINPKLRIJLFGOKLMNISOJNTVWG\n即每4位取一个字母。其他字母是干扰的。但此传说并未得到证实，因为故事发生的地点在希腊和波斯，但密文却是英文。\n由於古時多數人並不識字，最早的秘密書寫的形式只用到紙筆或等同物品，隨著識字率提高，就開始需要真正的密碼學了。最古典的兩個加密技巧是：\n转置密码（英语：Transposition cipher）：將字母順序重新排列，例如『help me』變成『ehpl em』；與\n替换式密码：有系統地將一組字母換成其他字母或符號，例如『fly at once』變成『gmz bu podf』（每個字母用下一個字母取代）。這兩種單純的方式都不足以提供足夠的機密性。凱撒密码是最經典的替代法，據傳由古羅馬帝國的皇帝凱撒所發明，用在與遠方將領的通訊上，每個字母被往後位移三格字母所取代。\n加密旨在確保通訊的秘密性，例如間諜、軍事將領、外交人員間的通訊，同時也有宗教上的應用。舉例來說，早期基督徒使用密碼學模糊他們寫作的部份觀點以避免遭受迫害。666年或部分更早期的手稿上的616年是新約聖經啟示錄所指的野獸的數字，常用來暗指專迫害基督徒的古羅馬皇帝尼祿。史上也有部份希伯來文密碼的記載。古印度慾经中也提及愛侶可利用密碼來通信。隱寫術也出現在古代，希羅多德記載將訊息刺青在奴隸的頭皮上，較近代的隱寫術使用隱形墨水、縮影術或数字水印來隱藏訊息。\n除了應用於軍事外，西元四世紀婆羅門學者伐蹉衍那（英语：Vatsyayana）所書的《慾經》4中曾提及到用代替法加密資訊。書中第45項是秘密書信（英语：mlecchita-vikalpa），用以幫助婦女隱瞞她們與愛郞之間的關係。其中一種方法是把字母隨意配對互換，如套用在羅馬字母中，可有得出下表：\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史的經典密碼學", "Tag": "算法设计"}
{"Answer": "本質上所有的密碼仍然受到上述的破密法的危害，直到阿伯提約在1467年發明了多字母加密法（英语：polyalphabetic cipher），阿伯提的創新在於對訊息的不同部分使用不同的代碼，他同時也發明了可能是第一個自動加密器，一個實現他部分想法的轉輪。多字元加密法最典型的例子是維吉尼亞加密法：加密重複使用到一個關鍵字，用哪個字母取代端視輪替到關鍵字的哪個字母而定。儘管如此，多字母加密法仍然受到頻率分析法的部分危害，不過這直到十九世紀中期才被查爾斯·巴貝奇發現。\n比較近代的著名的例子可數中世紀蘇格蘭的瑪麗女王、第一次世界大戰德國的齊默爾曼電報和第二次世界大戰的「恩尼格玛」。\n蘇格蘭的瑪麗女王[编辑]西元1578年，瑪麗女王被伊莉莎白女王軟禁。在1586年1月6日瑪麗收到一批秘密信件，得悉了安東尼·貝平頓（Anthony Babington）的計劃。安東尼和幾個同黨在密謀營救瑪麗，並計劃行刺伊莉莎白女王。他們的信件被轉成密碼，並藏在啤酒桶的木塞以掩人耳目。但卻被英格蘭大臣華興翰（Walsingham）從中截獲、複製、還信入塞，並由菲力普·馬尼斯（Philip van Marnix）破解信件。信件破解後，華興翰使菲力普摹擬瑪麗的筆跡引誘安東尼行動，把叛逆者一網成擒，審判並處死瑪麗女王。問題在於錯誤地使用脆弱的加密法會製造虛假的安全錯覺：安東尼對他們的通訊方式太過有信心，令他的加密方法過於簡單，輕易被敵人破解。\n第一次世界大戰[编辑]1914年8月25日德國的馬格德堡巡洋艦（Magdeburg）在芬蘭灣（Gulf of Finland）擱淺，俄國搜出多份德國的文件及兩本電碼本，一本被送往英國的「40號房間」（Room 40）進行密碼分析。同時，無線電的發明亦使得截獲密信易如反掌。由於德國通往美國的電纜在大戰開始時被剪斷了，德國借用了美國的海底電纜發電報到華盛頓，但電纜經過了英國，1917年1月17日齊默爾曼電報被「40號房間」截獲。同年2月23日，密電內容揭開了，內容指德國將在1917年2月1日開始『無限制潛艇戰』，用潛艇攻擊戰時包括中立國在內的海上商運船。為了阻止美國因此參戰，德國建議墨西哥入侵美國，並承諾幫助墨西哥從美國手中奪回得克薩斯、新墨西哥和亞利桑那三州。德國還要墨西哥說服日本共同進攻美國，德國將提供軍事和資金援助。密電內容揭開後，美國在4月16日向德國宣戰。\n第二次世界大戰[编辑]德國汲取了第一次大戰的教訓，發展出以機械代替人手的加密方法。雪畢伍斯（Arthur Scherbius）發明了「謎」（ENIGMA，恩尼格玛密码机），用於軍事和商業上。「謎」主要由鍵盤、編碼器和燈板組成。三組編碼器合、加上接線器和其他配件，合共提供了一億億種編碼的可能性。1925年，「謎」開始有系列生產，在20年間，德國軍方購入了3萬多台「謎」，亦難倒了「40號房」，成為德國在二次大戰的重要工具。波蘭位於德國東面，俄國的西面，一直受到威脅，故成立了波蘭密碼局（Biuro Szyfrow）以獲取情報。波蘭從漢斯-提羅·施密德（Hans-Thilo Schmidt）處得到諜報，由年輕的數學家马里安·雷耶夫斯基（Marian Rejewski）解譯，用了一年時間編纂目錄，並在1930年代製造了「炸彈」（bomba），漸漸掌握瞭解「謎」的技術。\n1938年12月德國加強了「謎」的安全性，令波蘭失去了情報。「謎」成為了希特勒（Hitler）閃電戰略的核心，每天更改的加密排列維繫了強大快速的攻擊。1939年4月27日德國撤銷與波蘭的互不侵犯條約，波蘭才不得不決定把「炸彈」這個構想與英、法分享，合力破解新的「謎」。1939年9月1日，德國侵擊波蘭，大戰爆發。英國得到了波蘭的解密技術後，40號房間除了原有的語言和人文學家，還加入了數學家和科學家，後來更成立了政府代碼暨密碼學校（Government code and Cipher School），5年內人數增至7000人。1940至1942年是加密和解密的拉鋸戰，成功的解碼提供了很多寶貴的情報。例如在1940年得到了德軍進攻丹麥和挪威的作戰圖，以及在不列顛戰役（Battle of Britain）事先獲得了空襲情報，化解了很多危機。但「謎」卻並未被完全破解，加上「謎」的網絡很多，令德國一直在大西洋戰役中佔上風。最後英國在「順手牽羊」的行動中在德國潛艇上俘獲「謎」的密碼簿，破解了「謎」。英國以各種虛假手段掩飾這件事，免得德國再次更改密碼，並策劃摧毀了德國的補給線，缩短了大西洋戰役的持续时间。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史的中世紀至第二次世界大戰", "Tag": "算法设计"}
{"Answer": "西元1578年，瑪麗女王被伊莉莎白女王軟禁。在1586年1月6日瑪麗收到一批秘密信件，得悉了安東尼·貝平頓（Anthony Babington）的計劃。安東尼和幾個同黨在密謀營救瑪麗，並計劃行刺伊莉莎白女王。他們的信件被轉成密碼，並藏在啤酒桶的木塞以掩人耳目。但卻被英格蘭大臣華興翰（Walsingham）從中截獲、複製、還信入塞，並由菲力普·馬尼斯（Philip van Marnix）破解信件。信件破解後，華興翰使菲力普摹擬瑪麗的筆跡引誘安東尼行動，把叛逆者一網成擒，審判並處死瑪麗女王。問題在於錯誤地使用脆弱的加密法會製造虛假的安全錯覺：安東尼對他們的通訊方式太過有信心，令他的加密方法過於簡單，輕易被敵人破解。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史的中世紀至第二次世界大戰的蘇格蘭的瑪麗女王", "Tag": "算法设计"}
{"Answer": "1914年8月25日德國的馬格德堡巡洋艦（Magdeburg）在芬蘭灣（Gulf of Finland）擱淺，俄國搜出多份德國的文件及兩本電碼本，一本被送往英國的「40號房間」（Room 40）進行密碼分析。同時，無線電的發明亦使得截獲密信易如反掌。由於德國通往美國的電纜在大戰開始時被剪斷了，德國借用了美國的海底電纜發電報到華盛頓，但電纜經過了英國，1917年1月17日齊默爾曼電報被「40號房間」截獲。同年2月23日，密電內容揭開了，內容指德國將在1917年2月1日開始『無限制潛艇戰』，用潛艇攻擊戰時包括中立國在內的海上商運船。為了阻止美國因此參戰，德國建議墨西哥入侵美國，並承諾幫助墨西哥從美國手中奪回得克薩斯、新墨西哥和亞利桑那三州。德國還要墨西哥說服日本共同進攻美國，德國將提供軍事和資金援助。密電內容揭開後，美國在4月16日向德國宣戰。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史的中世紀至第二次世界大戰的第一次世界大戰", "Tag": "算法设计"}
{"Answer": "德國汲取了第一次大戰的教訓，發展出以機械代替人手的加密方法。雪畢伍斯（Arthur Scherbius）發明了「謎」（ENIGMA，恩尼格玛密码机），用於軍事和商業上。「謎」主要由鍵盤、編碼器和燈板組成。三組編碼器合、加上接線器和其他配件，合共提供了一億億種編碼的可能性。1925年，「謎」開始有系列生產，在20年間，德國軍方購入了3萬多台「謎」，亦難倒了「40號房」，成為德國在二次大戰的重要工具。波蘭位於德國東面，俄國的西面，一直受到威脅，故成立了波蘭密碼局（Biuro Szyfrow）以獲取情報。波蘭從漢斯-提羅·施密德（Hans-Thilo Schmidt）處得到諜報，由年輕的數學家马里安·雷耶夫斯基（Marian Rejewski）解譯，用了一年時間編纂目錄，並在1930年代製造了「炸彈」（bomba），漸漸掌握瞭解「謎」的技術。\n1938年12月德國加強了「謎」的安全性，令波蘭失去了情報。「謎」成為了希特勒（Hitler）閃電戰略的核心，每天更改的加密排列維繫了強大快速的攻擊。1939年4月27日德國撤銷與波蘭的互不侵犯條約，波蘭才不得不決定把「炸彈」這個構想與英、法分享，合力破解新的「謎」。1939年9月1日，德國侵擊波蘭，大戰爆發。英國得到了波蘭的解密技術後，40號房間除了原有的語言和人文學家，還加入了數學家和科學家，後來更成立了政府代碼暨密碼學校（Government code and Cipher School），5年內人數增至7000人。1940至1942年是加密和解密的拉鋸戰，成功的解碼提供了很多寶貴的情報。例如在1940年得到了德軍進攻丹麥和挪威的作戰圖，以及在不列顛戰役（Battle of Britain）事先獲得了空襲情報，化解了很多危機。但「謎」卻並未被完全破解，加上「謎」的網絡很多，令德國一直在大西洋戰役中佔上風。最後英國在「順手牽羊」的行動中在德國潛艇上俘獲「謎」的密碼簿，破解了「謎」。英國以各種虛假手段掩飾這件事，免得德國再次更改密碼，並策劃摧毀了德國的補給線，缩短了大西洋戰役的持续时间。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史的中世紀至第二次世界大戰的第二次世界大戰", "Tag": "算法设计"}
{"Answer": "第二次世界大戰後計算機與電子學的發展促成了更複雜的密碼，而且計算機可以加密任何二進位形式的資料，不再限於書寫的文字，以語言學為基礎的破密術因此失效。多數計算機加密的特色是在二進位字串上操作，而不像经典密码学那样直接地作用在傳統字母數字上。然而，計算機同時也促進了破密分析的发展，抵消了某些加密法的優勢。不過，優良的加密法仍保持領先，通常好的加密法都相當有效率（快速且使用少量資源），而破解它需要許多級數以上的資源，使得破密變得不可行。\n雖然頻率分析是很有效的技巧，實際上加密法通常還是有用的。不使用頻率分析來破解一個訊息需要知道目前是使用何種加密法，因此才會促成了諜報、賄賂、竊盜或背叛等行為。直到十九世紀學者們才體認到加密法的演算法並非理智或實在的防護。實際上，適當的密碼學機制（包含加解密法）應該保持安全，即使敵人知道了使用何種演算法。對好的加密法來說，金鑰的秘密性理應足以保障資料的機密性。這個原則首先由奧古斯特·柯克霍夫（Auguste Kerckhoffs）提出並被稱為柯克霍夫原則（Kerckhoffs' principle）。資訊理論始祖克勞德·艾爾伍德·香農（Claude Shannon）重述：「敵人知道系統。」\n大量公開的學術研究出現于现代。這起源於一九七零年代中期，美國國家標準局（National Bureau of Standards, NBS；現稱國家標準技術研究所，National, NIST）制定數位加密標準（DES），惠特菲爾德·迪菲（Whitfield Diffie）和馬丁·赫爾曼（Martin Hellman）提出的開創性論文，以及公開釋出RSA。從那個時期開始，密碼學成為通訊、電腦網路、電腦安全等上的重要工具。許多現代的密碼技術的基礎依賴於特定計算問題的困難度，例如因數分解問題或是離散對數問題。許多密碼技術可被證明為只要特定的計算問題無法被有效的解出，那就安全。除了一個著名的例外：一次性密碼本（one-time pad，OTP），這類證明是偶然的而非決定性的，但是是目前可用的最好的方式。\n密碼學演算法與系統設計者不但要留意密碼學歷史，而且必須考慮到未來發展。例如，持續增加計算機處理速度會增進蛮力攻击（brute-force attacks）的速度。量子計算的潛在效應已經是部份密碼學家的焦點。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史的現代密碼學", "Tag": "算法设计"}
{"Answer": "第二次世界大戰後計算機與電子學的發展促成了更複雜的密碼，而且計算機可以加密任何二進位形式的資料，不再限於書寫的文字，以語言學為基礎的破密術因此失效。多數計算機加密的特色是在二進位字串上操作，而不像经典密码学那样直接地作用在傳統字母數字上。然而，計算機同時也促進了破密分析的发展，抵消了某些加密法的優勢。不過，優良的加密法仍保持領先，通常好的加密法都相當有效率（快速且使用少量資源），而破解它需要許多級數以上的資源，使得破密變得不可行。\n雖然頻率分析是很有效的技巧，實際上加密法通常還是有用的。不使用頻率分析來破解一個訊息需要知道目前是使用何種加密法，因此才會促成了諜報、賄賂、竊盜或背叛等行為。直到十九世紀學者們才體認到加密法的演算法並非理智或實在的防護。實際上，適當的密碼學機制（包含加解密法）應該保持安全，即使敵人知道了使用何種演算法。對好的加密法來說，金鑰的秘密性理應足以保障資料的機密性。這個原則首先由奧古斯特·柯克霍夫（Auguste Kerckhoffs）提出並被稱為柯克霍夫原則（Kerckhoffs' principle）。資訊理論始祖克勞德·艾爾伍德·香農（Claude Shannon）重述：「敵人知道系統。」\n大量公開的學術研究出現于现代。這起源於一九七零年代中期，美國國家標準局（National Bureau of Standards, NBS；現稱國家標準技術研究所，National, NIST）制定數位加密標準（DES），惠特菲爾德·迪菲（Whitfield Diffie）和馬丁·赫爾曼（Martin Hellman）提出的開創性論文，以及公開釋出RSA。從那個時期開始，密碼學成為通訊、電腦網路、電腦安全等上的重要工具。許多現代的密碼技術的基礎依賴於特定計算問題的困難度，例如因數分解問題或是離散對數問題。許多密碼技術可被證明為只要特定的計算問題無法被有效的解出，那就安全。除了一個著名的例外：一次性密碼本（one-time pad，OTP），這類證明是偶然的而非決定性的，但是是目前可用的最好的方式。\n密碼學演算法與系統設計者不但要留意密碼學歷史，而且必須考慮到未來發展。例如，持續增加計算機處理速度會增進蛮力攻击（brute-force attacks）的速度。量子計算的潛在效應已經是部份密碼學家的焦點。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的密碼學與密碼分析的歷史的現代密碼學", "Tag": "算法设计"}
{"Answer": "主条目：公钥密码学公開金鑰密碼學，简称公钥密码学，又稱非對稱金鑰密碼學，相對於對稱金鑰密碼學，最大的特點在於加密和解密使用不同的金鑰。\n在對稱金鑰密碼學中，加密和解密使用相同的金鑰，也許對不同的訊息使用不同的金鑰，但都面臨金鑰管理的難題。由於每對通訊方都必須使用異於他組的金鑰，當網路成員的數量增加時，金鑰數量成二次方增加。更尷尬的難題是：當安全的通道不存在於雙方時，如何建立一個共有的金鑰以利安全的通訊？如果有通道可以安全地建立金鑰，何不使用現有的通道。這個矛盾是長年以來密碼學無法在真實世界應用的阻礙。\n1976年，惠特菲爾德·迪菲與馬丁·赫爾曼發表開創性的論文，提出公開金鑰密碼學的概念：一對不同值但數學相關的金鑰，公開金鑰（公鑰, public key）與私密金鑰（私鑰, private key or secret key）。在公鑰系統中，由公開金鑰推算出配對的私密金鑰於計算上是不可行的。歷史學者David Kahn（英语：David Kahn）這樣描述公開金鑰密碼學；「從文藝復興的多字元取代法後最革命性的概念。」\n在公鑰系統中，公鑰可以隨意流傳，但私鑰只有該人擁有。典型的用法是，其他人用公鑰來加密給該接受者，接受者使用自己的私鑰解密。Diffie與Hellman也展示了如何利用公開金鑰密碼學來達成迪菲-赫爾曼密鑰交換協定。\n1978年，麻省理工学院的罗纳德·李维斯特、阿迪·萨莫尔和伦纳德·阿德曼發明另一個公開金鑰系統，RSA。\n直到1997年的公開文件中大眾才知道，早在1970年代早期，英國情報機構政府通信总部的數學家James H. Ellis（英语：James H. Ellis）便已發明非對稱金鑰密碼學，而且Diffie-Hellman與RSA都曾被Malcolm J. Williamson（英语：Malcolm J. Williamson）與Clifford Cocks（英语：Clifford Cocks）分別發明於前。這兩個最早的公鑰系統提供優良的加密法基礎，因而被大量使用。其他公鑰系統還有Cramer-Shoup（英语：Cramer-Shoup）、El Gamal、以及橢圓曲線密碼學等等。\n除了加密外，公開金鑰密碼學最顯著的成就是實現了數位簽章。數位簽章名副其實是普通簽章的數位化，他們的特性都是某人可以輕易製造簽章，但他人卻難以仿冒。數位簽章可以永久地與被簽署訊息結合，無法自訊息上移除。數位簽章大致包含兩個演算法：一個是簽署，使用私密金鑰處理訊息或訊息的雜湊值而產生簽章；另一個是驗證，使用公開金鑰驗證簽章的真實性。RSA和DSA是兩種最流行的數位簽章機制。數位簽章是公開金鑰基礎建設（public key infranstructures, PKI）以及許多網路安全機制（SSL/TLS, 虛擬私人網路等）的基礎。\n公開金鑰演算法大多基於計算複雜度上的難題，通常來自於數論。例如，RSA源於整數因數分解問題；DSA源於離散對數問題。近年發展快速的橢圓曲線密碼學則基於和橢圓曲線相關的數學難題，與離散對數相當。由於這些底層的問題多涉及模數乘法或指數運算，相對於區塊加密法需要更多計算資源。因此，公開金鑰系統通常是複合式的，內含一個高效率的對稱金鑰演算法，用以加密訊息，再以公開金鑰加密對稱金鑰系統所使用的金鑰，以增進效率。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的現代密碼學的公钥密碼學", "Tag": "算法设计"}
{"Answer": "主条目：密碼分析密碼分析又稱破密術。密碼分析的目的是發現密碼機制的弱點，從事者可能是意圖顛覆系統惡意的攻擊者或評估系統弱點的設計人。在現代，密碼演算法與協定必須被仔細檢查和測試，確定其保證的安全性。\n大眾普遍誤解認為所有加密法都可以被破解。香农在二战时的工作就已證明只要金鑰是完全隨機，不重覆使用，對外絕對保密，與訊息等長或比訊息更長的一次一密是不可能破解的。除了一次一密以外的多數加密法都可以以暴力攻擊法破解，但是破解所需的努力可能是金鑰長度的指數成長。\n密碼分析的方式有很多，因此有數個分類。一個常見的分別法則是攻擊者知曉多少資訊。在唯密文攻击中，密碼分析者只能存取密文，好的現代密碼系統對這種情況通常是免疫的。在已知明文攻击中，密碼分析者可以存取多個明文、密文對。在选择明文攻击中，密碼分析者可以自選任意明文，並被賦予相對應的密文，例如二戰時布列顛所使用的園藝法。最後，选择密文攻击中，密碼分析者可以自選任意密文，並被賦予相對應的明文\n對稱金鑰加密的密碼分析通常旨在尋找比已知最佳破解法更有效率的方式。例如，以最簡單的暴力法破解DES需要一個已知明文與255解密運算，嘗試近半數可能的金鑰。線性分析攻擊法對DES需要243已知明文與243 DES運算，顯然比暴力法有效。\n公開金鑰演算法則基於多種數學難題，其中最有名的是整数分解和離散對數問題。許多公開金鑰密碼分析在研究如何有效率地解出這些計算問題的數值演算法。例如，已知解出基於橢圓曲線的離散對數問題比相同金鑰大小的整數因數分解問題更困難。因此，為了達到相等的安全強度，基於因數分解的技術必須使用更長的金鑰。由於這個因素，基於橢圓曲線的公開金鑰密碼系統從1990年代中期後逐漸流行。\n當純粹的密碼分析著眼於演算法本身時，某些攻擊則專注於密碼裝置執行的弱點，稱為副通道攻擊。如果密碼分析者可以存取到裝置執行加密或回報通行碼錯誤的時間，它就可能使用時序攻擊法破解密碼。攻擊者也可能研究訊息的模式與長度，得出有用的資訊，稱為流量分析，對機敏的敵人這相當有效。當然，社會工程與其它針對人事、社交的攻擊與破密術一併使用時可能是最有力的攻擊法。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的現代密碼學的密碼分析", "Tag": "算法设计"}
{"Answer": "多數的密碼學理論研究在探討密碼學原型：具備基本密碼學特質的演算法以及和其他問題的關連。例如，容易正向運算卻難以逆向運算的單向函數。通常而言，密碼應用如果要安全，就必須保證單向函數存在。然而，如果單向函數存在，就表示P ≠ NP。既然目前P與NP問題仍是未解，我們就無從得知單向函數是否存在。如果單向函數存在，那安全的準亂數產生器與準亂數函數就存在。\n目前已知的密碼學原型僅提供基本的機能。通常是機密、訊息完整、認證、和不可否認。任何其他機能都是基本演算法的組合與延伸，這類組合稱為密碼系統。例如PGP、SSH、SSL/TLS、公開金鑰基礎建設和數位簽章等。其他密碼原型還有加密演算法本身、單向排列、暗門排列等。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的現代密碼學的密碼學原型", "Tag": "算法设计"}
{"Answer": "主条目：密碼协议在許多狀況，密碼技術涉及通訊的雙方或多方（例如公司總部與分部）或是跨越時間（例如保護備份資料）。密碼協议已經擴展到涵蓋多種議題，像是互動證明、秘密分享與零知識，更複雜的有電子鈔票和安全多方計算。\n當一個好的密碼系統的安全失效時，很少是密碼學原型出現漏洞。大部分的弱點都發生於協定設計、系統實作、或是某些人為錯誤。許多密碼學協定都在非系統化的過程中發展出來，很少有安全上的証明。一些正規分析協定安全的方式都本於數學邏輯（例如BAN（英语：BAN）邏輯）或近期的具體安全原則，這些都是數十年來研究人員的主題。很不幸的，這些工具都相當的笨重也無法用於複雜的設計。如何实現與整合密碼學的應用本身是截然不同的領域，參見密碼學工程與安全工程。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的現代密碼學的密碼协议", "Tag": "算法设计"}
{"Answer": "禁令[编辑]密碼學長期以來都是情報或司法機構的興趣。由於這些單位的隱密性以及禁令後個人隱私的減少，密碼學也是人權支持者關心的焦點。環繞密碼學的法律議題已有很長的歷史，特別是在可以執行高品質密碼的廉價計算機問世後。\n在某些國家甚至本國性的密碼學也受限制。直到1999年，法國仍然限制國內密碼學的使用。許多國家有更嚴格的限制，例如白俄羅斯、哈薩克、蒙古、巴基斯坦、俄羅斯、新加坡、突尼西亞、委內瑞拉和越南。\n在美國，國內的使用是合法的，但仍然有許多法律衝突。一個特別重要的議題是密碼軟體與硬體的出口管制。由於密碼分析在二戰時期扮演的重要角色，也期待密碼學可以持續在國家安全上效力，許多西方國家政府嚴格規範密碼學的出口。二戰之後，在美國散佈加密科技到國外曾是違法的。事實上，加密技術曾被視為軍需品，就像坦克與核武。直到個人電腦和網際網路問世後情況才改變。好的密碼學與壞的密碼學對絕大部分使用者來說是沒有差別的，其實多數情況下，大部分現行密碼技術普遍緩慢而且易出錯。然而當網際網路與個人電腦日益成長，優良的加密技術逐漸廣為人知。可見出口管制將成為商務與研究上的阻礙。\n出口管制[编辑]在1990年代發生了數件挑戰美國出口規範的事件。其中一件是菲爾·齊默爾曼的PGP加密程式，於1991年6月在美國連原始碼一併釋出於網際網路。在RSA Security公司提出抗議後，Zimmermann被商務部和聯邦調查局偵訊達數年。接著，柏克萊加州大學的研究生Daniel Bernstein（英语：Daniel Bernstein）發起了對美國政府的法律訴訟，以言論自由挑戰禁令的某些觀點。1995年的Bernstein v. United States（英语：Bernstein v. United States）案例促成了在1999年判決印出密碼演算法的原始碼屬美國憲法言論自由保障範圍內。在1996年，39個國家簽訂處理軍武出口的華沙公約。該公約約定使用短金鑰長度（對稱金鑰56位元；RSA　512位元）的密碼學不再受到出口管制。從2000年後，美國出口密碼學已經寬鬆許多。現在，幾乎所有的網際網路使用者都可存取到優良的密碼學，就在瀏覽器內建的傳輸層安全性協定（TLS）或安全套接层（SSL）。Mozilla Thunderbird和微軟Outlook電子郵件用戶端程式可以用TLS連結至IMAP或Pop伺服器，並以S/MIME收送加密的電子郵件。許多網路用戶並不知曉他們的基本應用內含大量的密碼系統。這些瀏覽器與郵件程式如此普及，甚至試圖規範市民使用密碼學使用的政府單位也無力從事有效的限制。\n美國國家安全局介入[编辑]另一個密碼學的爭議點是美國國家安全局（美国国家安全局）在加密法發展的介入。國家安全局考量到將其制訂為國家表準局的聯邦標準，曾介入於IBM發展的DES。DES是NSA與IBM為了克制強力的差分分析法而制定，這個攻擊直到1980年代晚期才公開。根據Steven Levy（英语：Steven Levy）所說，IBM曾重新發現差分分析法，但被NSA下禁口令。這個攻擊法直到Biham與Shamir（英语：Shamir）在數年後再次發現才公開。這些事情顯示了決定攻擊者擁有哪些資源或知識的困難。還有1993年，NSA涉入用在Capstone（英语：Capstone）計劃的加密微晶片Clipper chip（英语：Clipper chip）。Clipper飽受密碼學者的批評，其一是因為其加密演算法被列為機密，NSA可能蓄意設計較弱的加密法以達成情報目的；其二是整個計畫案違反柯克霍夫原则，由於這機制使用到一個特別的只有政府才有的委任金鑰，難保沒有竊聽的可能。\n數位智慧財產權管理[编辑]數位智慧財產權管理又稱數位智財權（Digital rights management, DRM）\n密碼學是數位智慧財產權的核心，有許多技術被應用在保障版權資料的使用。1998年，美國總統比尔·克林顿（Bill Clinton）簽署了數位千禧年版權法案（數字千年版權法, DMCA），明定特定破密技術的重制或散佈屬犯罪行為，特別是某些迴避DRM者。這對密碼學研究社群造成了相當嚴重的潛在衝擊，因为任何逆向解码技術都可以被用于破解DRM从而被認定为違反DMCA。考慮到這些爭議，美國聯邦調查局與司法部並未嚴格執行DMCA。一位密碼學者Niels Ferguson（英语：Niels Ferguson）曾公開陳述受DMCA的影响，他將不會釋出部分研究給英特尔安全設計。Linux核心的第二號發展人物艾倫·考克斯與普林斯頓大學教授Edward Felten（英语：Edward Felten）都曾受到這法案的相關困擾。Dmitry Sklyarov（英语：Dmitry Sklyarov）在從俄羅斯到美國訪問時曾因違反該法案被監禁達數月，但違反DMCA的作品實際上發生於俄羅斯，而且在俄羅斯是合法行為。類似的事情發生在許多國家。例如歐盟所制定的Copyright Directive（英语：Copyright Directive）。在2007年，負責數碼多功能影音光碟與HD DVD防偽的金鑰被發現且是出在網際網路上，同時，美國電影協會發出多個違DMCA的告示，導致大量網際網路使用者回擊，也引出了公平使用與言論自由的議題。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的與密碼學有關的法律議題", "Tag": "算法设计"}
{"Answer": "密碼學長期以來都是情報或司法機構的興趣。由於這些單位的隱密性以及禁令後個人隱私的減少，密碼學也是人權支持者關心的焦點。環繞密碼學的法律議題已有很長的歷史，特別是在可以執行高品質密碼的廉價計算機問世後。\n在某些國家甚至本國性的密碼學也受限制。直到1999年，法國仍然限制國內密碼學的使用。許多國家有更嚴格的限制，例如白俄羅斯、哈薩克、蒙古、巴基斯坦、俄羅斯、新加坡、突尼西亞、委內瑞拉和越南。\n在美國，國內的使用是合法的，但仍然有許多法律衝突。一個特別重要的議題是密碼軟體與硬體的出口管制。由於密碼分析在二戰時期扮演的重要角色，也期待密碼學可以持續在國家安全上效力，許多西方國家政府嚴格規範密碼學的出口。二戰之後，在美國散佈加密科技到國外曾是違法的。事實上，加密技術曾被視為軍需品，就像坦克與核武。直到個人電腦和網際網路問世後情況才改變。好的密碼學與壞的密碼學對絕大部分使用者來說是沒有差別的，其實多數情況下，大部分現行密碼技術普遍緩慢而且易出錯。然而當網際網路與個人電腦日益成長，優良的加密技術逐漸廣為人知。可見出口管制將成為商務與研究上的阻礙。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的與密碼學有關的法律議題的禁令", "Tag": "算法设计"}
{"Answer": "在1990年代發生了數件挑戰美國出口規範的事件。其中一件是菲爾·齊默爾曼的PGP加密程式，於1991年6月在美國連原始碼一併釋出於網際網路。在RSA Security公司提出抗議後，Zimmermann被商務部和聯邦調查局偵訊達數年。接著，柏克萊加州大學的研究生Daniel Bernstein（英语：Daniel Bernstein）發起了對美國政府的法律訴訟，以言論自由挑戰禁令的某些觀點。1995年的Bernstein v. United States（英语：Bernstein v. United States）案例促成了在1999年判決印出密碼演算法的原始碼屬美國憲法言論自由保障範圍內。在1996年，39個國家簽訂處理軍武出口的華沙公約。該公約約定使用短金鑰長度（對稱金鑰56位元；RSA　512位元）的密碼學不再受到出口管制。從2000年後，美國出口密碼學已經寬鬆許多。現在，幾乎所有的網際網路使用者都可存取到優良的密碼學，就在瀏覽器內建的傳輸層安全性協定（TLS）或安全套接层（SSL）。Mozilla Thunderbird和微軟Outlook電子郵件用戶端程式可以用TLS連結至IMAP或Pop伺服器，並以S/MIME收送加密的電子郵件。許多網路用戶並不知曉他們的基本應用內含大量的密碼系統。這些瀏覽器與郵件程式如此普及，甚至試圖規範市民使用密碼學使用的政府單位也無力從事有效的限制。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的與密碼學有關的法律議題的出口管制", "Tag": "算法设计"}
{"Answer": "另一個密碼學的爭議點是美國國家安全局（美国国家安全局）在加密法發展的介入。國家安全局考量到將其制訂為國家表準局的聯邦標準，曾介入於IBM發展的DES。DES是NSA與IBM為了克制強力的差分分析法而制定，這個攻擊直到1980年代晚期才公開。根據Steven Levy（英语：Steven Levy）所說，IBM曾重新發現差分分析法，但被NSA下禁口令。這個攻擊法直到Biham與Shamir（英语：Shamir）在數年後再次發現才公開。這些事情顯示了決定攻擊者擁有哪些資源或知識的困難。還有1993年，NSA涉入用在Capstone（英语：Capstone）計劃的加密微晶片Clipper chip（英语：Clipper chip）。Clipper飽受密碼學者的批評，其一是因為其加密演算法被列為機密，NSA可能蓄意設計較弱的加密法以達成情報目的；其二是整個計畫案違反柯克霍夫原则，由於這機制使用到一個特別的只有政府才有的委任金鑰，難保沒有竊聽的可能。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的與密碼學有關的法律議題的美國國家安全局介入", "Tag": "算法设计"}
{"Answer": "數位智慧財產權管理又稱數位智財權（Digital rights management, DRM）\n密碼學是數位智慧財產權的核心，有許多技術被應用在保障版權資料的使用。1998年，美國總統比尔·克林顿（Bill Clinton）簽署了數位千禧年版權法案（數字千年版權法, DMCA），明定特定破密技術的重制或散佈屬犯罪行為，特別是某些迴避DRM者。這對密碼學研究社群造成了相當嚴重的潛在衝擊，因为任何逆向解码技術都可以被用于破解DRM从而被認定为違反DMCA。考慮到這些爭議，美國聯邦調查局與司法部並未嚴格執行DMCA。一位密碼學者Niels Ferguson（英语：Niels Ferguson）曾公開陳述受DMCA的影响，他將不會釋出部分研究給英特尔安全設計。Linux核心的第二號發展人物艾倫·考克斯與普林斯頓大學教授Edward Felten（英语：Edward Felten）都曾受到這法案的相關困擾。Dmitry Sklyarov（英语：Dmitry Sklyarov）在從俄羅斯到美國訪問時曾因違反該法案被監禁達數月，但違反DMCA的作品實際上發生於俄羅斯，而且在俄羅斯是合法行為。類似的事情發生在許多國家。例如歐盟所制定的Copyright Directive（英语：Copyright Directive）。在2007年，負責數碼多功能影音光碟與HD DVD防偽的金鑰被發現且是出在網際網路上，同時，美國電影協會發出多個違DMCA的告示，導致大量網際網路使用者回擊，也引出了公平使用與言論自由的議題。\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的與密碼學有關的法律議題的數位智慧財產權管理", "Tag": "算法设计"}
{"Answer": "\n\n^ 王树禾. 《数学演义》. 科学出版社. : P187. ISBN 9787030218377. \n\n", "Konwledge_Point": "密码学", "Question": "什么是密码学的參考文獻", "Tag": "算法设计"}
{"Answer": "Helger's cryptography pointers\nRSA Laboratories' FAQ About today's cryptography  essentially elementary coverage\nThe sci.crypt FAQ（页面存档备份，存于互联网档案馆） extensive and detailed; in 'traditional FAQ' format\nsci.crypt mini-FAQ (more recent)\nThe sci.crypt newsgroup\nSavard's glossary an extensive and detailed view of cryptographic history with emphasis on crypto devices\nThe Beginner's Guide to Cryptography - An elementary overview of a few basic areas of cryptography.\nAn Introduction to the Use of Encryption（页面存档备份，存于互联网档案馆） - A fairly non-technical introduction to the subject.\nEncryption and Privacy（页面存档备份，存于互联网档案馆）", "Konwledge_Point": "密码学", "Question": "什么是密码学的外部連結", "Tag": "算法设计"}
{"Answer": "\n\n密码学主题\n数学主题\n计算机科学主题密碼學主題列表\n密碼學家列表\n密碼學領域重要出版物", "Konwledge_Point": "密码学", "Question": "什么是密码学的参见", "Tag": "算法设计"}
{"Answer": "P/NP问题是理论信息学中计算复杂度理论领域至今未解决的问题，是克雷数学研究所七題千禧年大奖难题之一。P/NP问题包括复杂度类P与NP的关系。1971年由史提芬·古克（Stephen A. Cook）和列昂尼德·列文（英语：Leonid Levin）分別提出。\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题", "Tag": "算法设计"}
{"Answer": "复杂度类P即為所有可以由一个确定型图灵机在多项式表达的时间内解决的问题；类NP由所有可以在多项式时间内验证它的解是否正確的决定问题组成，或者等效的说，那些可以在非確定型圖靈機上在多项式时间内找出解的问题的集合。很可能，计算理论最大的未解决问题就是关于这两类的关系的：\nP和NP相等在2002年对于100研究者的调查中，61人相信答案是否定的，9人相信答案是肯定的，22人不确定，而8人相信问题可能和现在所接受的公理独立，所以不可能证明或证否。[1]对于正确的解答，有一个一百萬美元的奖励。\nNP-完全问题（或者叫NPC）的集合在这讨论有重大作用，它们可以大致的描述为那些在NP中最不像在P中的（确切定义细节请参看NP-完全理论）。计算机科学家现在相信P、NP和NPC类之间的关系如图中所示，其中P和NPC类不相交。\n  假设P≠NP的复杂度类的图解。如P=NP则三个类相同。簡單來說，P=NP即：「若问题的答案可以很快验证，其答案是否也可以很快被计算出來。」\n例如某大数是否合数：如53308290611有否非平凡因數。答案是肯定的，虽然人手找出一个因數很麻烦。从另一个方面讲，如果有人声称答案是「对，224737可以整除53308290611」，则我们可以很快用除法验证。验证一个数是除数比找出一個明顯除数来简单得多。用於验证一个正面答案所需的信息也称为证明。所以我们的结论是，给定正确的证明，问题的正面答案可以很快（也就是，在多项式时间内）验证，而这就是这个问题属于NP的原因。\n虽然这个特定的问题，最近也獲证實在P类中（参看下面的关于\"质数在P中\"的参考），这一点也不明显，而且有很多类似的问题相信不属于类P。\n像上面这样，把问题限制到“是／不是”问题并没有改变原问题（即没有降低难度）；即使我们允许更复杂的答案，最后的问题（是否FP=FNP）是等价的。\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的P=NP", "Tag": "算法设计"}
{"Answer": "更正式一些，一个决定问题是一个取一些字符串为输入并要求输出为是或否的问题。若有一个算法（譬如图灵机，或一个LISP或Pascal的程序并有无限的内存）能够在最多nk步内对一个串长度为n的输入给出正确答案，其中k是某个不依赖于输入串的常数，则我们称该问题可以在多项式时间内解决，并且将它置入类P。直观的讲，我们将P中的问题视为可以较快解决的问题。\n现在假设有一个算法A(w,C)取两个参数，一个串w，也就是我们的决定问题的输入串，而另一个串C是“建议证明”，并且使得A在最多nk步内产生“是／否”答案（其中n是w的长度而k不依赖于w）。然後假设：w是一个答案为“是”的例子，当且仅当，存在C使得A(w,C)返回“是”。\n则我们称这个问题可以在非决定性多项式时间内解决，且将它放入NP类。我们把算法A作为一个所建议的证明的检验器，它运行足够快。（注意缩写NP代表“Non-deterministic（非确定性）Polynomial（多项式）”而不是代表“Non-Polynomial（非多项式）。）\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的学术定义", "Tag": "算法设计"}
{"Answer": "要解决P=NP问题，NP完全的概念非常有用。不严格的讲，NP完全问题是NP类中“最难”的问题，也就是说它们是最可能不属于P类的。这是因为任何NP中的问题可以在多项式时间内变换成为任何特定NP完全问题的一个特例。例如，旅行推销员问题的判定问题版本为NP完全。所以NP中的任何问题的任何特例可以在多项式时间内转换成旅行商问题的一个特例。所以若旅行商问题能证實在P内，则P=NP。旅行商问题是很多这样的NP完全的问题之一。若任何一个NP完全的问题在P内，则可以推出P=NP。不幸的是，虽然很多重要的问题被证實为NP完全，但却没有一个有已知快速的算法。\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的NP完全", "Tag": "算法设计"}
{"Answer": "虽然是否P=NP还是未知的，在P之外的问题是已经知道存在的。寻找国际象棋或围棋最佳走法（在n乘n棋盘上）是NP困难的。因为可以证明P≠EXPTIME（指数时间），这些问题位于P之外，所以需要比多项式时间更多的时间。判定皮尔斯伯格算术（英语：Presburger arithmetic）中的命题是否为真的问题更加困难。Fischer和Rabin（英语：Michael O. Rabin）于1974年证明每个决定Presburger命题的真伪性的算法有最少22cn的运行时间，c为某个常数。这裡，n是Presburger命题的长度。因此，该命题已知需要比指数时间更多的运行时间。不可判定问题是更加困难的，例如停机问题，而它们无法在任何给定时间内解决。\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的更难的问题", "Tag": "算法设计"}
{"Answer": "上面所有的讨论，假设了P表示“容易”而“不在P中”表示“困难”。这是一个在复杂度理论中常见而且有一定准确性的假设，它在实践中却不总是真的，原因包括如下几点：\n它忽略了常数因子。一个需要101000n时间的问题是属于P的（它是线性时间的），但是事实上完全无法处理。一个需要10-100002n时间的问题不是在P中的（它是指数时间的），但是对于n取值直到几千时还是很容易处理的。\n它忽略了指数的大小。一个时间复杂度n1000属于P，但是很难对付。已经证明在P中存在需要任意大的指数的问题（参看时间层次定理）。一个时间复杂度2n/1000的问题不属于P，但对于n直到几千还是容易应对的。\n它只考虑了最坏情况的复杂度。可能现实世界中的有些问题在多数时候可以在时间n中解决，但是很偶尔你会看到需要时间2n的特例。这问题可能有一个多项式的平均时间，但最坏情况是指数式的，所以该问题不属于P。\n它只考虑确定性解。可能有一个问题你可以很快解决如果你可以接受出现一点误差的可能，但是确保正确的答案会难得多。这个问题不会属于P，虽然事实上它可以很快求解。这实际上是解决属于NP而还不知道是否属于P的问题的一个办法（参看RP，BPP）。\n新的诸如量子计算机这样的计算模型，可能可以快速的解决一些尚未知道是否属于P的问题；但是，没有一个它们已知能够解决的问题是NP完全的。不过，必须注意到P和NP问题的定义是采用像图灵机这样的经典计算模型的术语表述的。所以，即使一个量子计算机算法獲发现能有效解决一个NP完全问题，我们只是有了一个快速解决困难问题的实际方法，而不是数学类P和NP相等的证明。", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的P真的容易处理吗？", "Tag": "算法设计"}
{"Answer": "多数计算机科学家[谁？]相信P≠NP。该信念的一个关键原因是经过数十年对这些问题的研究，没人能发现一个NP完全问题的多项式时间算法。而且，人们早在NP完全的概念出现前就开始寻求这些算法（Karp的21个NP完全问题，在最早发现的一批中，有所有著名的已经存在的问题）。进一步，P=NP这样的结果会导致很多惊人结果，那些结果现在被相信不成立，如NP=反NP和P=PH。\n也有这样论证：问题难求解（P）但易验证（NP），这和我们日常经验相符。\n从另一方面讲，某些研究者认为我们过于相信P≠NP，而应该也去寻找P=NP的证明。例如，2002年有这声明：[1]\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的P≠NP的觀點", "Tag": "算法设计"}
{"Answer": "虽然百万美元的奖金和投入巨大却没有实质性结果的大量研究足以显示该问题很难，但是还有一些形式化的结果证明为什么该问题可能很难解决。\n最常引用的结果之一是设计神諭。假想你有部魔法机器可以解决单一问题，例如「判定某数是否质数」，這魔法機器可以瞬间解决这问题。我们的新问题是，若我们獲允许任意利用这机器，是否存在我们可以在多项式时间内验证但无法在多项式时间内解决的问题？结果是，依赖于机器能解决的问题，P=NP和P≠NP二者都可以证明。这个结论带来的后果是，任何可以通过修改神諭来证明该机器的存在性的结果不能解决问题。不幸的是，几乎所有经典的方法和大部分已知的方法可以这样修改（我们称它们在相对化）。\n如果这还不算太糟的话，1993年Razborov和Rudich证明的一个结果表明，给定一个特定的可信的假设，在某种意义下“自然”的证明不能解决P=NP问题。[2]（页面存档备份，存于互联网档案馆）这表明一些现在似乎最有希望的方法不太可能成功。随着更多这类定理得到证明，该定理的可能证明方法有越来越多的陷阱要规避。\n这实际上也是为什么NP完全问题有用的原因－若对于NP完全问题存在有一个多项式时间算法，或者没有这样的算法，这将能用一种相信不被上述结果排除在外的方法来解决P=NP问题。\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的关于证明的难度的结果", "Tag": "算法设计"}
{"Answer": "沒人知道多項式時間演算法對於NP完全問題是否存在。但是如果這樣的演算法存在，我們已經知道其中的一些了！例如下面的算法正確地接受了一個NP完全語言，但是沒人知道通常它需要多久執行。它是一個多項式時間演算法當且僅當P=NP。\n  // 接受NP完全語言的一個算法子集和。\n  //\n  // 這是一個多項式時間算法當且僅當P=NP。\n  //\n  // “多項式時間”表示它在多項式時間內返回“是”，若\n  // 結果是“是”，否則永遠運行。\n  //\n  // 輸入：S = 一個自然數的有限集\n  // 輸出：\"是\"如果某個S的子集加起來等於0。\n  //         否則，它永遠運行沒有輸出。\n  // 注意:  \"程序數P\"是你將一個整數P寫為二進制，然後\n  //         將位元串考慮為一個程序。\n  //         每個可能的程序都可以這樣產生，\n  //         雖然多數什麼也不做因為有語法錯誤。\n  //         \n  FOR N = 1...infinity\n      FOR P = 1...N\n          以S為輸入運行程序數P N步\n          IF程序輸出一個不同的整數的列表\n              AND所有整數都在S中\n              AND整數的和為0\n          THEN\n              OUTPUT \"是\"並 停機\n若P=NP，则这是一个接受一个NP完全语言的多项式时间算法。“接受”表示它在多项式时间内给出“是”的答案，但允许在答案是“否”的时候永远运行。\n可能我们想要“解决”子集和问题，而不是仅仅“接受”子集和语言。这表示我们想要它总是停机并返回一个“是”或“否”的答案。是否存在任何可能在多项式时间内解决这个问题的算法？没有人知道。但是如果这样的算法存在，那么我们已经知道其中的一些了！只要将上面的算法中的IF语句替换成下面的语句：\n          IF程序輸出一個完整的數學證明\n              AND證明的每一步合法\n              AND結論是S確實有（或者沒有）一個和為0的子集\n          THEN\n              OUTPUT \"是\"（如果獲證實，就\"不是\"）並停機\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的多項式時間演算法", "Tag": "算法设计"}
{"Answer": "P=NP问题可以用逻辑命题的特定类的可表达性的术语来重新表述。所有P中的语言可以用一阶逻辑加上最小不动点操作（实际上，这允许了递归函数的定义）来表达。类似，NP是可以用存在性二阶逻辑来表达—也就是，在关系、函数、和子集上排除了全称量词的二阶逻辑。多项式等级，PH中的语言对应与所有的二阶逻辑。这样，“P是NP的真子集吗”这样的问题可以表述为“是否存在性二阶逻辑能够表达带最小不动点操作的一阶逻辑的所不能表达的语言？”\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的逻辑表述", "Tag": "算法设计"}
{"Answer": "普林斯顿大学计算机系楼将二进制代码表述的“P=NP？”问题刻进顶楼西面的砖头上。如果证明了P=NP，砖头可以很方便的换成表示“P=NP！”。[2]\n[3]\n康奈尔大学的Hubert Chen博士提供了这个玩笑式的P不等于NP的证明：[4]\n.mw-parser-output .templatequote{margin-top:0;overflow:hidden}.mw-parser-output .templatequote .templatequotecite{line-height:1em;text-align:left;padding-left:2em;margin-top:0}.mw-parser-output .templatequote .templatequotecite cite{font-size:small}\n\n反证法。设P=NP。令y为一个P=NP的证明。证明y可以用一个合格的计算机科学家在多项式时间内验证，我们认定这样的科学家的存在性为真，但因为P=NP，该证明y可在多项式时间内由这样的科学家发现，但是这样的发现还没有发生（虽然这样的科学家试图发现这样的一个证明），我们得到矛盾。", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的花絮", "Tag": "算法设计"}
{"Answer": "\n\n^ William I. Gasarch. The P=?NP poll. (PDF). SIGACT News. June 2002, 33 (2): 34–47  [29 December 2008]. doi:10.1145/1052796.1052804. （原始内容存档 (PDF)于2019-10-27）. \n\n^ https://www.cs.princeton.edu/general/images/csbricksjpg.   [2018-10-04]. （原始内容存档于2019-02-17）.  外部链接存在于|title= (帮助)\n\n^ https://www.cs.princeton.edu/general/bricks.   [2018-10-04]. （原始内容存档于2017-12-14）.  外部链接存在于|title= (帮助)\n\n^ http://www.cs.cornell.edu/hubes/pnp.htm.   [2005-07-15]. （原始内容存档于2005-09-27）.  外部链接存在于|title= (帮助)\n\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的註釋", "Tag": "算法设计"}
{"Answer": "\nGerhard J. Woeginger. The P-versus-NP page（页面存档备份，存于互联网档案馆）。Lists a number of incorrect solutions to the problem.\nA. S. Fraenkel and D. Lichtenstein, Computing a perfect strategy for n*n chess requires time exponential in n, Proc. 8th Int. Coll. Automata, Languages, and Programming, Springer LNCS 115 (1981) 278-293 and J. Comb. Th. A 31 (1981) 199-214.\nE. Berlekamp and D. Wolfe, Mathematical Go: Chilling Gets the Last Point, A. K. Peters, 1994. D. Wolfe, Go endgames are hard, MSRI Combinatorial Game Theory Research Worksh., 2000.\nNeil Immerman。Languages Which Capture Complexity Classes. 15th ACM STOC Symposium, pp.347-354. 1983.\n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的参考文献", "Tag": "算法设计"}
{"Answer": "\nFraenkel, A. S.; Lichtenstein, D. Computing a Perfect Strategy for n*n Chess Requires Time Exponential in N.. Lecture Notes in Computer Science. 1981: 278–293. doi:10.1007/3-540-10843-2_23. （原始内容存档于2017-04-25）. \nGarey, Michael; Johnson, David. Computers and Intractability: A Guide to the Theory of NP-Completeness. San Francisco: W. H. Freeman and Company. 1979. ISBN 0-7167-1045-5. \nGoldreich, Oded. P, Np, and Np-Completeness. Cambridge: Cambridge University Press. 2010. ISBN 978-0-521-12254-2.  Online drafts（页面存档备份，存于互联网档案馆）\nImmerman, N. Languages which capture complexity classes. SIAM Journal on Computing. 1987, 16 (4): 760–778  [2018-01-19]. doi:10.1137/0216051. （原始内容存档于2013-04-29）. \nCormen, Thomas. Introduction to Algorithms. Cambridge: MIT Press. 2001. ISBN 0-262-03293-7. \nPapadimitriou, Christos. Computational Complexity. Boston: Addison-Wesley. 1994. ISBN 0-201-53082-1. \nFortnow, L. The Status of the P versus NP problem. Communications of the ACM. 2009, 52 (9): 78  [2018-01-19]. doi:10.1145/1562164.1562186. （原始内容存档于2017-02-15）. \nFortnow, L.; Gasarch, W. Computational complexity.   [2019-04-27]. （原始内容存档于2009-05-01）. \n", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的延伸閱讀", "Tag": "算法设计"}
{"Answer": "未來數學家的挑戰（P與NP的簡介，清楚明瞭）（页面存档备份，存于互联网档案馆）（繁體中文）\nThe Clay Math Institute Millennium Prize Problems\nComputational Complexity of Games and Puzzles（页面存档备份，存于互联网档案馆）\nManindra Agarwal, Nitin Saxena, Neeraj Kayal, \"PRIMES is in P\", Preprint, August 6, 2002\nThe \"PRIMES is in P\" FAQ\nScott Aaronson's Complexity Zoo（页面存档备份，存于互联网档案馆）", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的外部链接", "Tag": "算法设计"}
{"Answer": "P (复杂度)\nNP (复杂度)\nNP完全\n未解決數學問題\nNP-complete問題列表\n幾乎完備（Almost complete（英语：Almost complete））問題與弱完備（weakly complete（英语：weakly complete））問題\nASR-complete\nLadner理論\nNP困难", "Konwledge_Point": "P/NP问题", "Question": "什么是P/NP问题的参见", "Tag": "算法设计"}
{"Answer": "深度优先搜索算法（英語：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。[1]（p. 603）这种算法不会根据图的结构等信息调整执行策略[來源請求]。\n深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的拓扑排序表[1]（p. 612），利用拓扑排序表可以方便的解决很多相关的图论问题，如无权最长路径问题等等。\n因发明“深度优先搜索算法”，約翰·霍普克洛夫特与罗伯特·塔扬在1986年共同获得计算机领域的最高奖：图灵奖。[2]\n", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索", "Tag": "算法设计"}
{"Answer": "首先将根节点放入stack中。\n从stack中取出第一个节点，并检验它是否为目标。\n如果找到目标，则结束搜寻并回传结果。\n否则将它某一个尚未检验过的直接子节点加入stack中。\n重复步骤2。\n如果不存在未检测过的直接子节点。\n将上一级节点加入stack中。\n重复步骤2。\n重复步骤4。\n若stack为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的演算方法", "Tag": "算法设计"}
{"Answer": "定义一个结构体来表达一個二叉树的节点的结构：\nstruct Node {\n    int self;     // 数据\n    Node *left;   // 左孩子\n    Node *right;  // 右孩子\n};\n那么我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：\n", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的C++的實作", "Tag": "算法设计"}
{"Answer": "\n\n^ 1.0 1.1 Introduction to Algorithms [算法导论]. ISBN 978-7-111-40701-0. \n\n^ Robert E Tarjan - A.M. Turing Award Winner.   [2017-10-29]. （原始内容存档于2017-10-30） （英语）. \n\n", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的参考文献", "Tag": "算法设计"}
{"Answer": "广度优先搜索", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的參見", "Tag": "算法设计"}
{"Answer": "最小生成树（minimum spanning tree，MST）是最小權重生成樹（minimum weight spanning tree）的簡稱，是一副连通加权无向图中一棵权值最小的生成树。\n在一給定的無向圖 \n  \n    \n      \n        G\n        =\n        (\n        V\n        ,\n        E\n        )\n      \n    \n    {\\displaystyle G=(V,E)}\n  \n 中，\n  \n    \n      \n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle (u,v)}\n  \n 代表連接頂點 u 與頂點 v 的邊（即 \n  \n    \n      \n        (\n        u\n        ,\n        v\n        )\n        ∈\n        E\n      \n    \n    {\\displaystyle (u,v)\\in E}\n  \n），而 \n  \n    \n      \n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle w(u,v)}\n  \n 代表此邊的權重，若存在 T 為 E 的子集（即 \n  \n    \n      \n        T\n        ⊆\n        E\n      \n    \n    {\\displaystyle T\\subseteq E}\n  \n）且 (V, T) 為樹，使得：\n\n  \n    \n      \n        w\n        (\n        T\n        )\n        =\n        \n          ∑\n          \n            (\n            u\n            ,\n            v\n            )\n            ∈\n            T\n          \n        \n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle w(T)=\\sum _{(u,v)\\in T}w(u,v)}\n  \n的 w(T) 最小，則此 T 為 G 的最小生成樹。\n一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为最小生成森林。\n以有線電視電纜的架設為例，若只能沿著街道佈線，則以街道為邊，而路口為頂點，其中必然有一最小生成樹能使佈線成本最低。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树", "Tag": "算法设计"}
{"Answer": "存在个数[编辑]  这张图表明一个图中可能有多个最小生成树最小生成树在一些情况下可能会有多个。例如，当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。\n唯一性[编辑]如果图的每一条边的权值都互不相同，那么最小生成树将只有一个[1]。这一定理同样适用于最小生成森林。\n证明：\n\n假设图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n为每条边权值互不相同的连通图，且有两个不同的最小生成树\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n和\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n。\n则\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中必然存在一些在\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中并不存在的边，取其中一条这样的边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n。\n因为\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n是最小生成树，所以若往\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中添加边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，则将会出现环路。（因为有\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n个顶点的树有且仅有\n  \n    \n      \n        m\n        −\n        1\n      \n    \n    {\\displaystyle m-1}\n  \n条边）\n同时可知，如果从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，则\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n将分为互不连通的两个连通分量。因为\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        ∉\n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle e_{0}\\notin T'}\n  \n，所以\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中必然有其他的边连接这两个连通分量。且将\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n加入\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n后形成的环路中，除了\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n外至少有另一条连接\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n后的这两个连通分量的边。取其中一条这样的边，记作\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n。此时若将\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n加入\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n，则可连接从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n后得到的两个连通分量，并形成一棵不同的生成树。\n因为\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中所有边的权值互不相同，所以关于\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n和\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n的权重大小关系，可能有以下两种情况之一：\n\n若\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        <\n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle e_{0}<{e_{0}}'}\n  \n，则可从\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中删除\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n并加入\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，从而得到一棵总权值更小的生成树。这和\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n是最小生成树相矛盾。\n若\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        >\n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle e_{0}>{e_{0}}'}\n  \n，则可从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n并加入\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n，从而得到一棵总权值更小的生成树。同样，这和\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n是最小生成树相矛盾。\n综上，若\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n各边权重互不相等，则不可能存在两棵互不相同的最小生成树。即\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的最小生成树是唯一的。\n\n边的权值之和最低的子图[编辑]如果图的边的权值都为正数，那么最小生成树就是该图的所有包含所有顶点的子图中权值最低的连通子图。\n环定理[编辑]对于连通图中的任意一个环\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n：如果\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n中有边\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n的权值大于该环中任意一个其它的边的权值，那么这个边不会是最小生成树中的边\n证明：\n假设\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n属于最小生成树\n  \n    \n      \n        T\n        1\n      \n    \n    {\\displaystyle T1}\n  \n，那么将\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n删去将会使得\n  \n    \n      \n        T\n        1\n      \n    \n    {\\displaystyle T1}\n  \n变为两个树。因为环\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n必然还存在另一横切边ｆ可以连接两个子树形成生成树\n  \n    \n      \n        T\n        2\n      \n    \n    {\\displaystyle T2}\n  \n，且由于\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n＜\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n，生成树\n  \n    \n      \n        T\n        2\n      \n    \n    {\\displaystyle T2}\n  \n权值更小，与\n  \n    \n      \n        T\n        1\n      \n    \n    {\\displaystyle T1}\n  \n是最小生成树矛盾。\n割定理[编辑]  此图展示了最小生成树的割定理。\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n是该图唯一的最小生成树，令\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            A\n            ,\n            B\n            ,\n            D\n            ,\n            E\n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{A,B,D,E\\right\\}}\n  \n，则\n  \n    \n      \n        V\n        −\n        S\n        =\n        \n          {\n          \n            C\n            ,\n            F\n          \n          }\n        \n      \n    \n    {\\displaystyle V-S=\\left\\{C,F\\right\\}}\n  \n，这样就形成了一个割，其割集包含3条割边，即BC，EC，EF，如果去除它们就可以将这两个子图完全断开。在割集中，\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n是权值最小的边，所以\n  \n    \n      \n        S\n        ∪\n        \n          {\n          e\n          }\n        \n      \n    \n    {\\displaystyle S\\cup \\left\\{e\\right\\}}\n  \n是最小生成树\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n的一部分。在一幅连通加权无向图中，给定任意的割（英语：Cut (graph theory)），如有一条割边的权值严格小于所有其他割边，则这条边必然属于图的最小生成树。\n证明：\n令\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n为权重最小的割边，假设\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n为图的最小生成树，且\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n不包含\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n。那么如果将\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n加入\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n，得到的图必然含有一条经过\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n的环，且这个环也含有另一条割边--设为\n  \n    \n      \n        \n          e\n          ′\n        \n      \n    \n    {\\displaystyle e'}\n  \n，\n  \n    \n      \n        \n          e\n          ′\n        \n      \n    \n    {\\displaystyle e'}\n  \n的权重必然大于\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n，那么用\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n替换\n  \n    \n      \n        \n          e\n          ′\n        \n      \n    \n    {\\displaystyle e'}\n  \n可以形成一个权值小于\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n的生成树，与\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n为最小生成树矛盾。所以假设不成立，因此\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n必然包含\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n。[2]。\n最小权值边[编辑]如果图的具有最小权值的边只有一条，那么这条边包含在任意一个最小生成树中。\n证明：\n假设该边\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n没有在最小生成树\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中，那么将\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n加入\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中会形成环，用\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n替换环中的任意一条权值更大的边，将会形成权值更小的生成树，与题设矛盾。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关性质", "Tag": "算法设计"}
{"Answer": "  这张图表明一个图中可能有多个最小生成树最小生成树在一些情况下可能会有多个。例如，当图的每一条边的权值都相同时，该图的所有生成树都是最小生成树。\n唯一性[编辑]如果图的每一条边的权值都互不相同，那么最小生成树将只有一个[1]。这一定理同样适用于最小生成森林。\n证明：\n\n假设图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n为每条边权值互不相同的连通图，且有两个不同的最小生成树\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n和\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n。\n则\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中必然存在一些在\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中并不存在的边，取其中一条这样的边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n。\n因为\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n是最小生成树，所以若往\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中添加边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，则将会出现环路。（因为有\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n个顶点的树有且仅有\n  \n    \n      \n        m\n        −\n        1\n      \n    \n    {\\displaystyle m-1}\n  \n条边）\n同时可知，如果从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，则\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n将分为互不连通的两个连通分量。因为\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        ∉\n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle e_{0}\\notin T'}\n  \n，所以\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中必然有其他的边连接这两个连通分量。且将\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n加入\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n后形成的环路中，除了\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n外至少有另一条连接\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n后的这两个连通分量的边。取其中一条这样的边，记作\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n。此时若将\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n加入\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n，则可连接从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n后得到的两个连通分量，并形成一棵不同的生成树。\n因为\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中所有边的权值互不相同，所以关于\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n和\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n的权重大小关系，可能有以下两种情况之一：\n\n若\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        <\n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle e_{0}<{e_{0}}'}\n  \n，则可从\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中删除\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n并加入\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，从而得到一棵总权值更小的生成树。这和\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n是最小生成树相矛盾。\n若\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        >\n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle e_{0}>{e_{0}}'}\n  \n，则可从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n并加入\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n，从而得到一棵总权值更小的生成树。同样，这和\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n是最小生成树相矛盾。\n综上，若\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n各边权重互不相等，则不可能存在两棵互不相同的最小生成树。即\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的最小生成树是唯一的。\n\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关性质的存在个数", "Tag": "算法设计"}
{"Answer": "如果图的每一条边的权值都互不相同，那么最小生成树将只有一个[1]。这一定理同样适用于最小生成森林。\n证明：\n\n假设图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n为每条边权值互不相同的连通图，且有两个不同的最小生成树\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n和\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n。\n则\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中必然存在一些在\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中并不存在的边，取其中一条这样的边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n。\n因为\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n是最小生成树，所以若往\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中添加边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，则将会出现环路。（因为有\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n个顶点的树有且仅有\n  \n    \n      \n        m\n        −\n        1\n      \n    \n    {\\displaystyle m-1}\n  \n条边）\n同时可知，如果从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除边\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，则\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n将分为互不连通的两个连通分量。因为\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        ∉\n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle e_{0}\\notin T'}\n  \n，所以\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中必然有其他的边连接这两个连通分量。且将\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n加入\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n后形成的环路中，除了\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n外至少有另一条连接\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n后的这两个连通分量的边。取其中一条这样的边，记作\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n。此时若将\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n加入\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n，则可连接从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n后得到的两个连通分量，并形成一棵不同的生成树。\n因为\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中所有边的权值互不相同，所以关于\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n和\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n的权重大小关系，可能有以下两种情况之一：\n\n若\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        <\n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle e_{0}<{e_{0}}'}\n  \n，则可从\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n中删除\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n并加入\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n，从而得到一棵总权值更小的生成树。这和\n  \n    \n      \n        \n          T\n          ′\n        \n      \n    \n    {\\displaystyle T'}\n  \n是最小生成树相矛盾。\n若\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n        >\n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle e_{0}>{e_{0}}'}\n  \n，则可从\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中删除\n  \n    \n      \n        \n          e\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle e_{0}}\n  \n并加入\n  \n    \n      \n        \n          \n            \n              e\n              \n                0\n              \n            \n          \n          ′\n        \n      \n    \n    {\\displaystyle {e_{0}}'}\n  \n，从而得到一棵总权值更小的生成树。同样，这和\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n是最小生成树相矛盾。\n综上，若\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n各边权重互不相等，则不可能存在两棵互不相同的最小生成树。即\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的最小生成树是唯一的。\n\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关性质的存在个数的唯一性", "Tag": "算法设计"}
{"Answer": "如果图的边的权值都为正数，那么最小生成树就是该图的所有包含所有顶点的子图中权值最低的连通子图。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关性质的边的权值之和最低的子图", "Tag": "算法设计"}
{"Answer": "对于连通图中的任意一个环\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n：如果\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n中有边\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n的权值大于该环中任意一个其它的边的权值，那么这个边不会是最小生成树中的边\n证明：\n假设\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n属于最小生成树\n  \n    \n      \n        T\n        1\n      \n    \n    {\\displaystyle T1}\n  \n，那么将\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n删去将会使得\n  \n    \n      \n        T\n        1\n      \n    \n    {\\displaystyle T1}\n  \n变为两个树。因为环\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n必然还存在另一横切边ｆ可以连接两个子树形成生成树\n  \n    \n      \n        T\n        2\n      \n    \n    {\\displaystyle T2}\n  \n，且由于\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n＜\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n，生成树\n  \n    \n      \n        T\n        2\n      \n    \n    {\\displaystyle T2}\n  \n权值更小，与\n  \n    \n      \n        T\n        1\n      \n    \n    {\\displaystyle T1}\n  \n是最小生成树矛盾。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关性质的环定理", "Tag": "算法设计"}
{"Answer": "  此图展示了最小生成树的割定理。\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n是该图唯一的最小生成树，令\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            A\n            ,\n            B\n            ,\n            D\n            ,\n            E\n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{A,B,D,E\\right\\}}\n  \n，则\n  \n    \n      \n        V\n        −\n        S\n        =\n        \n          {\n          \n            C\n            ,\n            F\n          \n          }\n        \n      \n    \n    {\\displaystyle V-S=\\left\\{C,F\\right\\}}\n  \n，这样就形成了一个割，其割集包含3条割边，即BC，EC，EF，如果去除它们就可以将这两个子图完全断开。在割集中，\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n是权值最小的边，所以\n  \n    \n      \n        S\n        ∪\n        \n          {\n          e\n          }\n        \n      \n    \n    {\\displaystyle S\\cup \\left\\{e\\right\\}}\n  \n是最小生成树\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n的一部分。在一幅连通加权无向图中，给定任意的割（英语：Cut (graph theory)），如有一条割边的权值严格小于所有其他割边，则这条边必然属于图的最小生成树。\n证明：\n令\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n为权重最小的割边，假设\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n为图的最小生成树，且\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n不包含\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n。那么如果将\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n加入\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n，得到的图必然含有一条经过\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n的环，且这个环也含有另一条割边--设为\n  \n    \n      \n        \n          e\n          ′\n        \n      \n    \n    {\\displaystyle e'}\n  \n，\n  \n    \n      \n        \n          e\n          ′\n        \n      \n    \n    {\\displaystyle e'}\n  \n的权重必然大于\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n，那么用\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n替换\n  \n    \n      \n        \n          e\n          ′\n        \n      \n    \n    {\\displaystyle e'}\n  \n可以形成一个权值小于\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n的生成树，与\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n为最小生成树矛盾。所以假设不成立，因此\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n必然包含\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n。[2]。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关性质的割定理", "Tag": "算法设计"}
{"Answer": "如果图的具有最小权值的边只有一条，那么这条边包含在任意一个最小生成树中。\n证明：\n假设该边\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n没有在最小生成树\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中，那么将\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n加入\n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n中会形成环，用\n  \n    \n      \n        e\n      \n    \n    {\\displaystyle e}\n  \n替换环中的任意一条权值更大的边，将会形成权值更小的生成树，与题设矛盾。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关性质的最小权值边", "Tag": "算法设计"}
{"Answer": "历史简介[编辑]计算稠密图的最小生成树最早是由罗伯特·普里姆（英语：Robert C. Prim）在1957年发明的[3]，即Prim算法。之后艾兹赫尔·戴克斯特拉也独自发明了它[4]。但该算法的基本思想是由沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）于1930年发明的[5]。所以该算法有时候也被称为Jarník算法或者Prim-Jarník算法。20世纪70年代，优先队列发明之后很快被用在了寻找稀疏图中的最小生成树上。1984年，迈克尔·弗里德曼和罗伯特·塔扬发明了斐波那契堆，Prim算法所需要的运行时间在理论上由\n  \n    \n      \n        E\n        log\n        ⁡\n        E\n      \n    \n    {\\displaystyle E\\log E}\n  \n提升到了\n  \n    \n      \n        E\n        +\n        V\n        log\n        ⁡\n        V\n      \n    \n    {\\displaystyle E+V\\log V}\n  \n。约瑟夫·克鲁斯卡尔（英语：Joseph Kruskal）在1956年发表了他的算法，在他的论文中提到了Prim算法的一个变种，而奥塔卡尔·布卢瓦卡（英语：Otakar Borůvka）在20世纪20年代的论文中就已经提到了该变种。M.Sollin在1961年重新发现了该算法，该算法后成为实现较好渐进性能的最小生成树算法和并行最小生成树算法的基础[6]。\n以下各算法介绍中，\n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n表示图的边数，\n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n表示图的顶点数。　\nBorůvka算法[编辑]第一个用于寻找最小生成树的算法由捷克科学家奥塔卡尔·布卢瓦卡（英语：Otakar Borůvka）提出，即Borůvka算法（英语：Borůvka's algorithm）。\nPrim算法[编辑]主条目：普里姆算法Prim算法的每一步都会为一棵生长中的树添加一条边，该树最开始只有一个顶点，然后会添加\n  \n    \n      \n        V\n        −\n        1\n      \n    \n    {\\displaystyle V-1}\n  \n个边。每次总是添加生长中的树和树中除该生长的树以外的部分形成的切分的具有最小权值的横切边。\nPrim算法的时间复杂度为\n  \n    \n      \n        O\n        (\n        E\n        +\n        V\n        log\n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(E+V\\log V)}\n  \n。\nKruskal算法[编辑]主条目：克鲁斯克尔演算法按照边的权重顺序（从小到大）将边加入生成树中，但是若加入该边会与生成树形成环则不加入该边。直到树中含有\n  \n    \n      \n        V\n        −\n        1\n      \n    \n    {\\displaystyle V-1}\n  \n条边为止。这些边组成的就是该图的最小生成树。\nKruskal算法的时间复杂度为\n  \n    \n      \n        E\n        log\n        ⁡\n        E\n      \n    \n    {\\displaystyle E\\log E}\n  \n。\n更快的算法[编辑]一些研究者希望可以找出更为高效的算法，在这方面也有了一定的成果。\nKarger，Klein & Tarjan (1995)针对边的权值可以成对比较的特殊模型提出了一个基于Borůvka算法和翻转删除算法的可以在线性时间内解决最小生成树的算法[7][8]。\n最快的非随机比较算法是由伯纳德·沙泽勒（英语：Bernard Chazelle）提出的。该算法依赖于soft heap（英语：soft heap）这样一个类似于优先级队列的数据结构[9][10] 。该算法的时间复杂度为\n  \n    \n      \n        O\n        (\n        E\n        α\n        (\n        E\n        ,\n        V\n        )\n        )\n      \n    \n    {\\displaystyle O(E\\alpha (E,V))}\n  \n。\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n就是阿克曼函数反函数，\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n的增长速度非常慢，对于一般的数值来说，其值很难超过5，所以该算法的复杂度可以近似看成是线性时间。\n线性时间的最小生成树算法[编辑]目前，既不能证明不存在能在线性时间内得到任意图的最小生成树的算法，也未能发明能够在线性时间内计算稀疏图的最小生成树的算法。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关算法", "Tag": "算法设计"}
{"Answer": "计算稠密图的最小生成树最早是由罗伯特·普里姆（英语：Robert C. Prim）在1957年发明的[3]，即Prim算法。之后艾兹赫尔·戴克斯特拉也独自发明了它[4]。但该算法的基本思想是由沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）于1930年发明的[5]。所以该算法有时候也被称为Jarník算法或者Prim-Jarník算法。20世纪70年代，优先队列发明之后很快被用在了寻找稀疏图中的最小生成树上。1984年，迈克尔·弗里德曼和罗伯特·塔扬发明了斐波那契堆，Prim算法所需要的运行时间在理论上由\n  \n    \n      \n        E\n        log\n        ⁡\n        E\n      \n    \n    {\\displaystyle E\\log E}\n  \n提升到了\n  \n    \n      \n        E\n        +\n        V\n        log\n        ⁡\n        V\n      \n    \n    {\\displaystyle E+V\\log V}\n  \n。约瑟夫·克鲁斯卡尔（英语：Joseph Kruskal）在1956年发表了他的算法，在他的论文中提到了Prim算法的一个变种，而奥塔卡尔·布卢瓦卡（英语：Otakar Borůvka）在20世纪20年代的论文中就已经提到了该变种。M.Sollin在1961年重新发现了该算法，该算法后成为实现较好渐进性能的最小生成树算法和并行最小生成树算法的基础[6]。\n以下各算法介绍中，\n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n表示图的边数，\n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n表示图的顶点数。　\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关算法的历史简介", "Tag": "算法设计"}
{"Answer": "第一个用于寻找最小生成树的算法由捷克科学家奥塔卡尔·布卢瓦卡（英语：Otakar Borůvka）提出，即Borůvka算法（英语：Borůvka's algorithm）。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关算法的Borůvka算法", "Tag": "算法设计"}
{"Answer": "主条目：普里姆算法Prim算法的每一步都会为一棵生长中的树添加一条边，该树最开始只有一个顶点，然后会添加\n  \n    \n      \n        V\n        −\n        1\n      \n    \n    {\\displaystyle V-1}\n  \n个边。每次总是添加生长中的树和树中除该生长的树以外的部分形成的切分的具有最小权值的横切边。\nPrim算法的时间复杂度为\n  \n    \n      \n        O\n        (\n        E\n        +\n        V\n        log\n        ⁡\n        V\n        )\n      \n    \n    {\\displaystyle O(E+V\\log V)}\n  \n。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关算法的Prim算法", "Tag": "算法设计"}
{"Answer": "主条目：克鲁斯克尔演算法按照边的权重顺序（从小到大）将边加入生成树中，但是若加入该边会与生成树形成环则不加入该边。直到树中含有\n  \n    \n      \n        V\n        −\n        1\n      \n    \n    {\\displaystyle V-1}\n  \n条边为止。这些边组成的就是该图的最小生成树。\nKruskal算法的时间复杂度为\n  \n    \n      \n        E\n        log\n        ⁡\n        E\n      \n    \n    {\\displaystyle E\\log E}\n  \n。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关算法的Kruskal算法", "Tag": "算法设计"}
{"Answer": "一些研究者希望可以找出更为高效的算法，在这方面也有了一定的成果。\nKarger，Klein & Tarjan (1995)针对边的权值可以成对比较的特殊模型提出了一个基于Borůvka算法和翻转删除算法的可以在线性时间内解决最小生成树的算法[7][8]。\n最快的非随机比较算法是由伯纳德·沙泽勒（英语：Bernard Chazelle）提出的。该算法依赖于soft heap（英语：soft heap）这样一个类似于优先级队列的数据结构[9][10] 。该算法的时间复杂度为\n  \n    \n      \n        O\n        (\n        E\n        α\n        (\n        E\n        ,\n        V\n        )\n        )\n      \n    \n    {\\displaystyle O(E\\alpha (E,V))}\n  \n。\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n就是阿克曼函数反函数，\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n的增长速度非常慢，对于一般的数值来说，其值很难超过5，所以该算法的复杂度可以近似看成是线性时间。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关算法的更快的算法", "Tag": "算法设计"}
{"Answer": "目前，既不能证明不存在能在线性时间内得到任意图的最小生成树的算法，也未能发明能够在线性时间内计算稀疏图的最小生成树的算法。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关算法的线性时间的最小生成树算法", "Tag": "算法设计"}
{"Answer": "k-最小生成树（英语：k-minimum spanning tree）：图中包含k个顶点的所有子图的所有最小生成树中权值最小的生成树。\n欧几里得最小生成树（英语：Euclidean minimum spanning tree）是一个用欧几里得距离来表示权值的连通加权图的最小生成树。\n方格线最小生成树（英语：rectilinear minimum spanning tree）是一个用曼哈顿距离来表示权值的连通加权图的最小生成树。\n容量最小生成树（英语：capacitated minimum spanning tree）是一棵树且其每个节点的子树的容量都不大于\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n。解决该问题是NP困难的[11]。但是伊萨·威廉姆斯和夏尔马以及提出了可以在接近多项式时间内解决该问题的启发式。\n度受限最小生成树（英语：degree-constrained spanning tree）是一棵树，其每一个顶点连接的顶点数都不超过d。对一些特定的d值，该问题类似于旅行推销员问题。该问题也是NP困难的。\n对有向图来说，其与最小生成树类似的图处理问题叫做最小树形图问题。\n最大生成树是一棵比其它所有生成树都要大或者相等的生成树。其解决方法类似于最小生成树算法。求解最大生成树的算法在自然语言处理以及条件随机场这些问题上起到很大的作用[12]。\n动态最小生成树是在已经计算完一个图的最小生成树后动态改变一些边的取值或删除/添加一些点或者边，求解新图的最小生成树[13][14][15]。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的相关问题", "Tag": "算法设计"}
{"Answer": "^1 ：用一条边链接树中的任意两个顶点都会产生一个新的环。\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的注释", "Tag": "算法设计"}
{"Answer": "\n\n^ Minimum Spanning Trees. princeton.edu. 2015-09-13  [2016-02-08]. （原始内容存档于2020-09-27） （英语）. \n\n^ Robert Sedgewick, Kevin Wayne. 算法. 北京: 人民邮电出版社. 2012年10月. ISBN 978-7-115-29380-0.  使用|accessdate=需要含有|url= (帮助)，p391--p392\n\n^ Prim, R. C., Shortest connection networks And some generalizations, Bell System Technical Journal, November 1957, 36 (6): 1389–1401, doi:10.1002/j.1538-7305.1957.tb01515.x .\n\n^ Dijkstra, E. W., A note on two problems in connexion with graphs (PDF), Numerische Mathematik, 1959, 1: 269–271  [2016-02-06], doi:10.1007/BF01386390, （原始内容存档 (PDF)于2020-01-23） .\n\n^ Jarník, V., O jistém problému minimálním [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 1930, 6: 57–63  [2016-02-06], （原始内容存档于2017-06-17） （捷克语） .\n\n^ Robert Sedgewick, Kevin Wayne. 算法. 北京: 人民邮电出版社. 2012年10月. ISBN 978-7-115-29380-0.  使用|accessdate=需要含有|url= (帮助)，p407--p408\n\n^ Karger, David R.; Klein, Philip N.; Tarjan, Robert E., A randomized linear-time algorithm to find minimum spanning trees, Journal of the Association for Computing Machinery, 1995, 42 (2): 321–328, MR 1409738, doi:10.1145/201019.201022 \n\n^ Pettie, Seth; Ramachandran, Vijaya, Minimizing randomness in minimum spanning tree, parallel connectivity, and set maxima algorithms, Proc. 13th ACM-SIAM Symposium on Discrete Algorithms (SODA '02), San Francisco, California: 713–722, 2002 .\n\n^ Chazelle, Bernard, A minimum spanning tree algorithm with inverse-Ackermann type complexity, Journal of the Association for Computing Machinery, 2000, 47 (6): 1028–1047, MR 1866456, doi:10.1145/355541.355562 .\n\n^ Chazelle, Bernard, The soft heap: an approximate priority queue with optimal error rate, Journal of the Association for Computing Machinery, 2000, 47 (6): 1012–1027, MR 1866455, doi:10.1145/355541.355554 .\n\n^ Jothi, Raja; Raghavachari, Balaji, Approximation Algorithms for the Capacitated Minimum Spanning Tree Problem and Its Variants in Network Design, ACM Trans. Algorithms, 2005, 1 (2): 265–282, doi:10.1145/1103963.1103967 \n\n^ McDonald, Ryan; Pereira, Fernando; Ribarov, Kiril; Hajič, Jan. Non-projective dependency parsing using spanning tree algorithms (PDF). Proc. HLT/EMNLP. 2005  [2016-02-06]. （原始内容存档 (PDF)于2020-10-01）. \n\n^ Spira, P. M.; Pan, A., On finding and updating spanning trees and shortest paths, SIAM Journal on Computing, 1975, 4 (3): 375–380, MR 0378466, doi:10.1137/0204032 .\n\n^ Holm, Jacob; de Lichtenberg, Kristian; Thorup, Mikkel, Poly-logarithmic deterministic fully dynamic algorithms for connectivity, minimum spanning tree, 2-edge, and biconnectivity, Journal of the Association for Computing Machinery, 2001, 48 (4): 723–760, MR 2144928, doi:10.1145/502090.502095 .\n\n^ Chin, F.; Houck, D., Algorithms for updating minimal spanning trees, Journal of Computer and System Sciences, 1978, 16 (3): 333–344, doi:10.1016/0022-0000(78)90022-3 .\n\n", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的参考", "Tag": "算法设计"}
{"Answer": "Otakar Boruvka on Minimum Spanning Tree Problem (translation of the both 1926 papers, comments, history) (2000) （页面存档备份，存于互联网档案馆） Jaroslav Nešetřil, Eva Milková, Helena Nesetrilová. (Section 7 gives his algorithm, which looks like a cross between Prim's and Kruskal's.)\nThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 23: Minimum Spanning Trees, pp. 561–579.\nEisner, Jason (1997). State-of-the-art algorithms for minimum spanning trees: A tutorial discussion （页面存档备份，存于互联网档案馆）. Manuscript, University of Pennsylvania, April. 78 pp.\nKromkowski, John David. \"Still Unmelted after All These Years\", in Annual Editions, Race and Ethnic Relations, 17/e (2009 McGraw Hill) (Using minimum spanning tree as method of demographic analysis of ethnic diversity across the United States).", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的参考文献", "Tag": "算法设计"}
{"Answer": "Implemented in BGL, the Boost Graph Library （页面存档备份，存于互联网档案馆）\nThe Stony Brook Algorithm Repository - Minimum Spanning Tree codes （页面存档备份，存于互联网档案馆）\nImplemented in QuickGraph for .Net", "Konwledge_Point": "最小生成树", "Question": "什么是最小生成树的外部链接", "Tag": "算法设计"}
{"Answer": "归并排序（英語：Merge sort，或mergesort），是建立在归并操作上的一种有效的排序算法，效率為\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序", "Tag": "算法设计"}
{"Answer": "采用分治法:\n分割：递归地把当前序列平均分割成两半。\n整合：在保持元素顺序的同时将上一步得到的子序列整合到一起（归并）。", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的概述", "Tag": "算法设计"}
{"Answer": "归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。\n递归法（Top-down）[编辑]申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n设定两个指针，最初位置分别为两个已经排序序列的起始位置\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n重复步骤3直到某一指针到达序列尾\n将另一序列剩下的所有元素直接复制到合并序列尾迭代法（Bottom-up）[编辑]原理如下（假设序列共有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n个元素）：\n将序列每相邻两个数字进行归并操作，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        2\n        )\n      \n    \n    {\\displaystyle ceil(n/2)}\n  \n个序列，排序后每个序列包含两/一个元素\n若此时序列数不是1个则将上述序列再次归并，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        4\n        )\n      \n    \n    {\\displaystyle ceil(n/4)}\n  \n个序列，每个序列包含四/三个元素\n重复步骤2，直到所有元素排序完毕，即序列数为1", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的归并操作", "Tag": "算法设计"}
{"Answer": "申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n设定两个指针，最初位置分别为两个已经排序序列的起始位置\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n重复步骤3直到某一指针到达序列尾\n将另一序列剩下的所有元素直接复制到合并序列尾", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的归并操作的递归法（Top-down）", "Tag": "算法设计"}
{"Answer": "原理如下（假设序列共有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n个元素）：\n将序列每相邻两个数字进行归并操作，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        2\n        )\n      \n    \n    {\\displaystyle ceil(n/2)}\n  \n个序列，排序后每个序列包含两/一个元素\n若此时序列数不是1个则将上述序列再次归并，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        4\n        )\n      \n    \n    {\\displaystyle ceil(n/4)}\n  \n个序列，每个序列包含四/三个元素\n重复步骤2，直到所有元素排序完毕，即序列数为1", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的归并操作的迭代法（Bottom-up）", "Tag": "算法设计"}
{"Answer": "C語言[编辑]迭代版：\nint min(int x, int y) {\n    return x < y ? x : y;\n}\nvoid merge_sort(int arr[], int len) {\n    int *a = arr;\n    int *b = (int *) malloc(len * sizeof(int));\n    int seg, start;\n    for (seg = 1; seg < len; seg += seg) {\n        for (start = 0; start < len; start += seg * 2) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        int *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        int i;\n        for (i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    free(b);\n}\n遞歸版：\n// 分治-治\nvoid mergeSort_conquer(int* array, int left, int mid, int right, int* temp) {\n    // [left, mid]和[mid+1, right]两个有序数组\n    int i = left;\n    int j = mid + 1;\n    int index = 0;\n    while (i <= mid && j <= right) {\n        if (array[i] < array[j]) {\n            temp[index++] = array[i++];\n        } else {\n            temp[index++] = array[j++];\n        }\n    }\n    // 剩余元素直接放入temp\n    while (i <= mid) {\n        temp[index++] = array[i++];\n    }\n    while (j <= right) {\n        temp[index++] = array[j++];\n    }\n    // 放回原数组\n    index = 0;\n    while (left <= right) {\n        array[left++] = temp[index++];\n    }\n}\n\n// 分治-分\nvoid mergeSort_divide(int* array, int left, int right, int* temp) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        // 左边归并排序\n        mergeSort_divide(array, left, mid, temp);\n        // 右边归并排序\n        mergeSort_divide(array, mid + 1, right, temp);\n        // 合并两个有序序列\n        mergeSort_conquer(array, left, mid, right, temp);\n    }\n}\n\nvoid mergeSort(int* array, int size) {\n    int* temp = (int*)malloc(sizeof(int) * size);\n    mergeSort_divide(array, 0, size - 1, temp);\n}\nC++[编辑]迭代版：\ntemplate<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"(<)的運算子功能\nvoid merge_sort(T arr[], int len) {\n    T *a = arr;\n    T *b = new T[len];\n    for (int seg = 1; seg < len; seg += seg) {\n        for (int start = 0; start < len; start += seg + seg) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        T *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        for (int i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    delete[] b;\n}\n遞歸版：\nvoid Merge(vector<int> &Array, int front, int mid, int end) {\n    // preconditions:\n    // Array[front...mid] is sorted\n    // Array[mid+1 ... end] is sorted\n    // Copy Array[front ... mid] to LeftSubArray\n    // Copy Array[mid+1 ... end] to RightSubArray\n    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);\n    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);\n    int idxLeft = 0, idxRight = 0;\n    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());\n    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());\n    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]\n    for (int i = front; i <= end; i++) {\n        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) {\n            Array[i] = LeftSubArray[idxLeft];\n            idxLeft++;\n        } else {\n            Array[i] = RightSubArray[idxRight];\n            idxRight++;\n        }\n    }\n}\n\nvoid MergeSort(vector<int> &Array, int front, int end) {\n    if (front >= end)\n        return;\n    int mid = front + (end - front) / 2;\n    MergeSort(Array, front, mid);\n    MergeSort(Array, mid + 1, end);\n    Merge(Array, front, mid, end);\n}\n[1]\nC#[编辑]public static List<int> sort(List<int> lst) {\n    if (lst.Count <= 1)\n        return lst;\n    int mid = lst.Count / 2;\n    List<int> left = new List<int>();  // 定义左侧List\n    List<int> right = new List<int>(); // 定义右侧List\n    // 以下兩個循環把 lst 分為左右兩個 List\n    for (int i = 0; i < mid; i++)\n        left.Add(lst[i]);\n    for (int j = mid; j < lst.Count; j++)\n        right.Add(lst[j]);\n    left = sort(left);\n    right = sort(right);\n    return merge(left, right);\n}\n/// <summary>\n/// 合併兩個已經排好序的List\n/// </summary>\n/// <param name=\"left\">左側List</param>\n/// <param name=\"right\">右側List</param>\n/// <returns></returns>\nstatic List<int> merge(List<int> left, List<int> right) {\n    List<int> temp = new List<int>();\n    while (left.Count > 0 && right.Count > 0) {\n        if (left[0] <= right[0]) {\n            temp.Add(left[0]);\n            left.RemoveAt(0);\n        } else {\n            temp.Add(right[0]);\n            right.RemoveAt(0);\n        }\n    }\n    if (left.Count > 0) {\n        for (int i = 0; i < left.Count; i++)\n            temp.Add(left[i]);\n    }\n    if (right.Count > 0) {\n        for (int i = 0; i < right.Count; i++)\n            temp.Add(right[i]);\n    }\n    return temp;\n}\nRuby[编辑]def merge list\n  return list if list.size < 2\n\n  pivot = list.size / 2\n\n  # Merge\n  lambda { |left, right|\n    final = []\n    until left.empty? or right.empty?\n      final << if left.first < right.first; left.shift else right.shift end\n    end\n    final + left + right\n  }.call merge(list[0...pivot]), merge(list[pivot..-1])\nend\nJava[编辑]遞歸版：\nstatic void merge_sort_recursive(int[] arr, int[] result, int start, int end) {\n\tif (start >= end)\n\t\treturn;\n\tint len = end - start, mid = (len >> 1) + start;\n\tint start1 = start, end1 = mid;\n\tint start2 = mid + 1, end2 = end;\n\tmerge_sort_recursive(arr, result, start1, end1);\n\tmerge_sort_recursive(arr, result, start2, end2);\n\tint k = start;\n\twhile (start1 <= end1 && start2 <= end2)\n\t\tresult[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];\n\twhile (start1 <= end1)\n\t\tresult[k++] = arr[start1++];\n\twhile (start2 <= end2)\n\t\tresult[k++] = arr[start2++];\n\tfor (k = start; k <= end; k++)\n\t\tarr[k] = result[k];\n}\npublic static void merge_sort(int[] arr) {\n\tint len = arr.length;\n\tint[] result = new int[len];\n\tmerge_sort_recursive(arr, result, 0, len - 1);\n}\n迭代版：\npublic static void merge_sort(int[] arr) {\n\tint[] orderedArr = new int[arr.length];\n\tfor (int i = 2; i < arr.length * 2; i *= 2) {\n\t\tfor (int j = 0; j < (arr.length + i - 1) / i; j++) {\n\t\t\tint left = i * j;\n\t\t\tint mid = left + i / 2 >= arr.length ? (arr.length - 1) : (left + i / 2);\n\t\t\tint right = i * (j + 1) - 1 >= arr.length ? (arr.length - 1) : (i * (j + 1) - 1);\n\t\t\tint start = left, l = left, m = mid;\n\t\t\twhile (l < mid && m <= right) {\n\t\t\t\tif (arr[l] < arr[m]) {\n\t\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\t\t} else {\n\t\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (l < mid)\n\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\twhile (m <= right)\n\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\tSystem.arraycopy(orderedArr, left, arr, left, right - left + 1);\n\t\t}\n\t}\n}\nPHP[编辑]function merge_sort($arr) {\n\t$len = count($arr);\n\tif ($len <= 1)\n\t\treturn $arr;\n\t$half = ($len>>1) + ($len & 1);\n\t$arr2d = array_chunk($arr, $half);\n\t$left = merge_sort($arr2d[0]);\n\t$right = merge_sort($arr2d[1]);\n\twhile (count($left) && count($right))\n\t\tif ($left[0] < $right[0])\n\t\t\t$reg[] = array_shift($left);\n\t\telse\n\t\t\t$reg[] = array_shift($right);\n\treturn array_merge($reg, $left, $right);\n}\n\n$arr = array(21, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70);\n$arr = merge_sort($arr);\nfor ($i = 0; $i < count($arr); $i++) {\n\techo $arr[$i] . ' ';\n}\nPython3[编辑]def mergeSort(nums):\n    if len(nums) < 2:\n        return nums\n    mid = len(nums) // 2\n    left = mergeSort(nums[:mid])\n    right = mergeSort(nums[mid:])\n\n    i = j = 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]: \n            result.append(left[i])\n            i += 1\n        else: \n            result.append(right[j])\n            j += 1\n\n    while i < len(left): \n        result.append(left[i]) \n        i += 1\n\n    while j < len(right): \n        result.append(right[j]) \n        j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    nums = [1, 4, 2, 3.6, -1, 0, 25, -34, 8, 9, 1, 0]\n    print(\"original:\", nums)\n    print(\"Sorted:\", mergeSort(nums))\nErlang[编辑]%% @doc 归并排序\ng_sort([]) ->\n    [];\ng_sort([T]) ->\n    [T];\ng_sort(L) ->\n    g_sort(L, length(L)).\n\ng_sort([_, _ | _] = L, Length) ->\n    SplitNum = trunc(Length / 2),\n    {L1, L2} = lists:split(SplitNum, L),\n    g_merge(g_sort(L1, SplitNum), g_sort(L2, Length - SplitNum));\ng_sort(L, _Length) ->\n    L.\n\n%% 已经排好序的两个list合并\ng_merge([], L2) ->\n    L2;\ng_merge(L1, []) ->\n    L1;\ng_merge([T1 | Rest1] = L1, [T2 | Rest2] = L2) ->\n    if\n        T1 =< T2 -> [T1 | g_merge(Rest1, L2)];\n        true -> [T2 | g_merge(L1, Rest2)]\n    end.\nJavascript[编辑]\n递归法function merge(left, right){\n  var result = [];\n  while(left.length > 0 && right.length > 0){\n    if(left[0] < right[0]){\n      result.push(left.shift());\n    }else{\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left, right);\n}\n\nfunction mergeSort(arr){\n  if(arr.length <=1) return arr;\n  var middle = Math.floor(arr.length / 2);\n  var left = arr.slice(0, middle);\n  var right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n迭代法\nGo[编辑]package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc MergeSort(list []int) []int {\n\tvar length = len(list)\n\tif length < 2 {\n\t\treturn list\n\t}\n\tvar mid = length / 2\n\treturn merge(MergeSort(list[:mid]), MergeSort(list[mid:]))\n}\n\nfunc merge(x, y []int) []int {\n\tvar r []int = make([]int, len(x)+len(y))\n\tfor i, j := 0, 0; ; {\n\t\tif i < len(x) && (j == len(y) || x[i] < y[j]) {\n\t\t\tr[i+j] = x[i]\n\t\t\ti++\n\t\t} else if j < len(y) {\n\t\t\tr[i+j] = y[j]\n\t\t\tj++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn r\n}\n\nfunc main() {\n\tvar list []int = []int{56, 48, 58, 94, 87, 4, 5, 61, 5, 8, 74, 9, 84, 15, 94, 9, 4, 31, 41, 68, 7, 4, 6, 94, 16, 9, 8, 4}\n\tfmt.Println(MergeSort(list))\n\tfmt.Println(list)\n\n\tsort.Ints(list)\n\tfmt.Println(list)\n}\n递归版\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc merge(data []int) []int {\n\tsum := len(data)\n\tif sum <= 1 {\n\t\treturn data\n\t}\n\tleft := data[0 : sum/2]\n\tlSize := len(left)\n\tif lSize >= 2 {\n\t\tleft = merge(left)\n\t}\n\tright := data[sum/2:]\n\trSize := len(right)\n\tif rSize >= 2 {\n\t\tright = merge(right)\n\t}\n\tj := 0\n\tt := 0\n\tarr := make([]int, sum)\n\tfmt.Println(left, right, data)\n\tfor i := 0; i < sum; i++ {\n\t\tif j < lSize && t < rSize {\n\t\t\tif left[j] <= right[t] {\n\t\t\t\tarr[i] = left[j]\n\t\t\t\tj++\n\t\t\t} else {\n\t\t\t\tarr[i] = right[t]\n\t\t\t\tt++\n\t\t\t}\t\n\t\t}  else if j >= lSize{\n\t\t\tarr[i] = right[t]\n\t\t\tt++\n\t\t}  else if t >= rSize{\n\t\t\tarr[i] = left[j]\n\t\t\tj++\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc main() {\n\tvar aa = []int{1000, 2, 31, 34, 5, 9, 7, 4, 6, 89, 90, 99, 99, 99, 99, 99}\n\t\n\tvar bb = merge(aa)\n\tfmt.Println(bb)\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例", "Tag": "算法设计"}
{"Answer": "迭代版：\nint min(int x, int y) {\n    return x < y ? x : y;\n}\nvoid merge_sort(int arr[], int len) {\n    int *a = arr;\n    int *b = (int *) malloc(len * sizeof(int));\n    int seg, start;\n    for (seg = 1; seg < len; seg += seg) {\n        for (start = 0; start < len; start += seg * 2) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        int *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        int i;\n        for (i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    free(b);\n}\n遞歸版：\n// 分治-治\nvoid mergeSort_conquer(int* array, int left, int mid, int right, int* temp) {\n    // [left, mid]和[mid+1, right]两个有序数组\n    int i = left;\n    int j = mid + 1;\n    int index = 0;\n    while (i <= mid && j <= right) {\n        if (array[i] < array[j]) {\n            temp[index++] = array[i++];\n        } else {\n            temp[index++] = array[j++];\n        }\n    }\n    // 剩余元素直接放入temp\n    while (i <= mid) {\n        temp[index++] = array[i++];\n    }\n    while (j <= right) {\n        temp[index++] = array[j++];\n    }\n    // 放回原数组\n    index = 0;\n    while (left <= right) {\n        array[left++] = temp[index++];\n    }\n}\n\n// 分治-分\nvoid mergeSort_divide(int* array, int left, int right, int* temp) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        // 左边归并排序\n        mergeSort_divide(array, left, mid, temp);\n        // 右边归并排序\n        mergeSort_divide(array, mid + 1, right, temp);\n        // 合并两个有序序列\n        mergeSort_conquer(array, left, mid, right, temp);\n    }\n}\n\nvoid mergeSort(int* array, int size) {\n    int* temp = (int*)malloc(sizeof(int) * size);\n    mergeSort_divide(array, 0, size - 1, temp);\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的C語言", "Tag": "算法设计"}
{"Answer": "迭代版：\ntemplate<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"(<)的運算子功能\nvoid merge_sort(T arr[], int len) {\n    T *a = arr;\n    T *b = new T[len];\n    for (int seg = 1; seg < len; seg += seg) {\n        for (int start = 0; start < len; start += seg + seg) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        T *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        for (int i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    delete[] b;\n}\n遞歸版：\nvoid Merge(vector<int> &Array, int front, int mid, int end) {\n    // preconditions:\n    // Array[front...mid] is sorted\n    // Array[mid+1 ... end] is sorted\n    // Copy Array[front ... mid] to LeftSubArray\n    // Copy Array[mid+1 ... end] to RightSubArray\n    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);\n    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);\n    int idxLeft = 0, idxRight = 0;\n    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());\n    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());\n    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]\n    for (int i = front; i <= end; i++) {\n        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) {\n            Array[i] = LeftSubArray[idxLeft];\n            idxLeft++;\n        } else {\n            Array[i] = RightSubArray[idxRight];\n            idxRight++;\n        }\n    }\n}\n\nvoid MergeSort(vector<int> &Array, int front, int end) {\n    if (front >= end)\n        return;\n    int mid = front + (end - front) / 2;\n    MergeSort(Array, front, mid);\n    MergeSort(Array, mid + 1, end);\n    Merge(Array, front, mid, end);\n}\n[1]\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的C++", "Tag": "算法设计"}
{"Answer": "public static List<int> sort(List<int> lst) {\n    if (lst.Count <= 1)\n        return lst;\n    int mid = lst.Count / 2;\n    List<int> left = new List<int>();  // 定义左侧List\n    List<int> right = new List<int>(); // 定义右侧List\n    // 以下兩個循環把 lst 分為左右兩個 List\n    for (int i = 0; i < mid; i++)\n        left.Add(lst[i]);\n    for (int j = mid; j < lst.Count; j++)\n        right.Add(lst[j]);\n    left = sort(left);\n    right = sort(right);\n    return merge(left, right);\n}\n/// <summary>\n/// 合併兩個已經排好序的List\n/// </summary>\n/// <param name=\"left\">左側List</param>\n/// <param name=\"right\">右側List</param>\n/// <returns></returns>\nstatic List<int> merge(List<int> left, List<int> right) {\n    List<int> temp = new List<int>();\n    while (left.Count > 0 && right.Count > 0) {\n        if (left[0] <= right[0]) {\n            temp.Add(left[0]);\n            left.RemoveAt(0);\n        } else {\n            temp.Add(right[0]);\n            right.RemoveAt(0);\n        }\n    }\n    if (left.Count > 0) {\n        for (int i = 0; i < left.Count; i++)\n            temp.Add(left[i]);\n    }\n    if (right.Count > 0) {\n        for (int i = 0; i < right.Count; i++)\n            temp.Add(right[i]);\n    }\n    return temp;\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的C#", "Tag": "算法设计"}
{"Answer": "def merge list\n  return list if list.size < 2\n\n  pivot = list.size / 2\n\n  # Merge\n  lambda { |left, right|\n    final = []\n    until left.empty? or right.empty?\n      final << if left.first < right.first; left.shift else right.shift end\n    end\n    final + left + right\n  }.call merge(list[0...pivot]), merge(list[pivot..-1])\nend\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Ruby", "Tag": "算法设计"}
{"Answer": "遞歸版：\nstatic void merge_sort_recursive(int[] arr, int[] result, int start, int end) {\n\tif (start >= end)\n\t\treturn;\n\tint len = end - start, mid = (len >> 1) + start;\n\tint start1 = start, end1 = mid;\n\tint start2 = mid + 1, end2 = end;\n\tmerge_sort_recursive(arr, result, start1, end1);\n\tmerge_sort_recursive(arr, result, start2, end2);\n\tint k = start;\n\twhile (start1 <= end1 && start2 <= end2)\n\t\tresult[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];\n\twhile (start1 <= end1)\n\t\tresult[k++] = arr[start1++];\n\twhile (start2 <= end2)\n\t\tresult[k++] = arr[start2++];\n\tfor (k = start; k <= end; k++)\n\t\tarr[k] = result[k];\n}\npublic static void merge_sort(int[] arr) {\n\tint len = arr.length;\n\tint[] result = new int[len];\n\tmerge_sort_recursive(arr, result, 0, len - 1);\n}\n迭代版：\npublic static void merge_sort(int[] arr) {\n\tint[] orderedArr = new int[arr.length];\n\tfor (int i = 2; i < arr.length * 2; i *= 2) {\n\t\tfor (int j = 0; j < (arr.length + i - 1) / i; j++) {\n\t\t\tint left = i * j;\n\t\t\tint mid = left + i / 2 >= arr.length ? (arr.length - 1) : (left + i / 2);\n\t\t\tint right = i * (j + 1) - 1 >= arr.length ? (arr.length - 1) : (i * (j + 1) - 1);\n\t\t\tint start = left, l = left, m = mid;\n\t\t\twhile (l < mid && m <= right) {\n\t\t\t\tif (arr[l] < arr[m]) {\n\t\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\t\t} else {\n\t\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (l < mid)\n\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\twhile (m <= right)\n\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\tSystem.arraycopy(orderedArr, left, arr, left, right - left + 1);\n\t\t}\n\t}\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Java", "Tag": "算法设计"}
{"Answer": "function merge_sort($arr) {\n\t$len = count($arr);\n\tif ($len <= 1)\n\t\treturn $arr;\n\t$half = ($len>>1) + ($len & 1);\n\t$arr2d = array_chunk($arr, $half);\n\t$left = merge_sort($arr2d[0]);\n\t$right = merge_sort($arr2d[1]);\n\twhile (count($left) && count($right))\n\t\tif ($left[0] < $right[0])\n\t\t\t$reg[] = array_shift($left);\n\t\telse\n\t\t\t$reg[] = array_shift($right);\n\treturn array_merge($reg, $left, $right);\n}\n\n$arr = array(21, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70);\n$arr = merge_sort($arr);\nfor ($i = 0; $i < count($arr); $i++) {\n\techo $arr[$i] . ' ';\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的PHP", "Tag": "算法设计"}
{"Answer": "def mergeSort(nums):\n    if len(nums) < 2:\n        return nums\n    mid = len(nums) // 2\n    left = mergeSort(nums[:mid])\n    right = mergeSort(nums[mid:])\n\n    i = j = 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]: \n            result.append(left[i])\n            i += 1\n        else: \n            result.append(right[j])\n            j += 1\n\n    while i < len(left): \n        result.append(left[i]) \n        i += 1\n\n    while j < len(right): \n        result.append(right[j]) \n        j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    nums = [1, 4, 2, 3.6, -1, 0, 25, -34, 8, 9, 1, 0]\n    print(\"original:\", nums)\n    print(\"Sorted:\", mergeSort(nums))\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Python3", "Tag": "算法设计"}
{"Answer": "%% @doc 归并排序\ng_sort([]) ->\n    [];\ng_sort([T]) ->\n    [T];\ng_sort(L) ->\n    g_sort(L, length(L)).\n\ng_sort([_, _ | _] = L, Length) ->\n    SplitNum = trunc(Length / 2),\n    {L1, L2} = lists:split(SplitNum, L),\n    g_merge(g_sort(L1, SplitNum), g_sort(L2, Length - SplitNum));\ng_sort(L, _Length) ->\n    L.\n\n%% 已经排好序的两个list合并\ng_merge([], L2) ->\n    L2;\ng_merge(L1, []) ->\n    L1;\ng_merge([T1 | Rest1] = L1, [T2 | Rest2] = L2) ->\n    if\n        T1 =< T2 -> [T1 | g_merge(Rest1, L2)];\n        true -> [T2 | g_merge(L1, Rest2)]\n    end.\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Erlang", "Tag": "算法设计"}
{"Answer": "\n递归法function merge(left, right){\n  var result = [];\n  while(left.length > 0 && right.length > 0){\n    if(left[0] < right[0]){\n      result.push(left.shift());\n    }else{\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left, right);\n}\n\nfunction mergeSort(arr){\n  if(arr.length <=1) return arr;\n  var middle = Math.floor(arr.length / 2);\n  var left = arr.slice(0, middle);\n  var right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n迭代法\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Javascript", "Tag": "算法设计"}
{"Answer": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc MergeSort(list []int) []int {\n\tvar length = len(list)\n\tif length < 2 {\n\t\treturn list\n\t}\n\tvar mid = length / 2\n\treturn merge(MergeSort(list[:mid]), MergeSort(list[mid:]))\n}\n\nfunc merge(x, y []int) []int {\n\tvar r []int = make([]int, len(x)+len(y))\n\tfor i, j := 0, 0; ; {\n\t\tif i < len(x) && (j == len(y) || x[i] < y[j]) {\n\t\t\tr[i+j] = x[i]\n\t\t\ti++\n\t\t} else if j < len(y) {\n\t\t\tr[i+j] = y[j]\n\t\t\tj++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn r\n}\n\nfunc main() {\n\tvar list []int = []int{56, 48, 58, 94, 87, 4, 5, 61, 5, 8, 74, 9, 84, 15, 94, 9, 4, 31, 41, 68, 7, 4, 6, 94, 16, 9, 8, 4}\n\tfmt.Println(MergeSort(list))\n\tfmt.Println(list)\n\n\tsort.Ints(list)\n\tfmt.Println(list)\n}\n递归版\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc merge(data []int) []int {\n\tsum := len(data)\n\tif sum <= 1 {\n\t\treturn data\n\t}\n\tleft := data[0 : sum/2]\n\tlSize := len(left)\n\tif lSize >= 2 {\n\t\tleft = merge(left)\n\t}\n\tright := data[sum/2:]\n\trSize := len(right)\n\tif rSize >= 2 {\n\t\tright = merge(right)\n\t}\n\tj := 0\n\tt := 0\n\tarr := make([]int, sum)\n\tfmt.Println(left, right, data)\n\tfor i := 0; i < sum; i++ {\n\t\tif j < lSize && t < rSize {\n\t\t\tif left[j] <= right[t] {\n\t\t\t\tarr[i] = left[j]\n\t\t\t\tj++\n\t\t\t} else {\n\t\t\t\tarr[i] = right[t]\n\t\t\t\tt++\n\t\t\t}\t\n\t\t}  else if j >= lSize{\n\t\t\tarr[i] = right[t]\n\t\t\tt++\n\t\t}  else if t >= rSize{\n\t\t\tarr[i] = left[j]\n\t\t\tj++\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc main() {\n\tvar aa = []int{1000, 2, 31, 34, 5, 9, 7, 4, 6, 89, 90, 99, 99, 99, 99, 99}\n\t\n\tvar bb = merge(aa)\n\tfmt.Println(bb)\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Go", "Tag": "算法设计"}
{"Answer": "比较操作的次数介于\n  \n    \n      \n        (\n        n\n        log\n        ⁡\n        n\n        )\n        \n          /\n        \n        2\n      \n    \n    {\\displaystyle (n\\log n)/2}\n  \n和\n  \n    \n      \n        n\n        log\n        ⁡\n        n\n        −\n        n\n        +\n        1\n      \n    \n    {\\displaystyle n\\log n-n+1}\n  \n。\n赋值操作的次数是\n  \n    \n      \n        (\n        2\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle (2n\\log n)}\n  \n。归并算法的空间复杂度为：\n  \n    \n      \n        Θ\n        (\n        n\n        )\n      \n    \n    {\\displaystyle \\Theta (n)}\n  \n\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的算法复杂度", "Tag": "算法设计"}
{"Answer": "\n\n^ Cormen, Thomas H. （英语：Thomas H. Cormen）; Leiserson, Charles E. （英语：Charles E. Leiserson）; Rivest, Ronald L.; Stein, Clifford. Section 2.3: Designing algorithms. Introduction to Algorithms 3rd. MIT Press and McGraw-Hill. 2009: 29–34 [1990]. ISBN 0-262-03384-4. .\n\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的参考文献", "Tag": "算法设计"}
{"Answer": "Dictionary of Algorithms and Data Structures: Merge sort （页面存档备份，存于互联网档案馆）\nMerge sort Algorithm with example program （页面存档备份，存于互联网档案馆）\nMerge Sort Algorithm Simulation\nMergesort For Linked Lists （页面存档备份，存于互联网档案馆）\nMergesort in Java, Python, Perl, C, Ruby", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的外部連結", "Tag": "算法设计"}
{"Answer": "大O符号（英語：Big O notation），又稱為漸進符號，是用于描述函数渐近行为的数学符号。更确切地说，它是用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。在数学中，它一般用来刻画被截断的无穷级数尤其是渐近级数的剩余项；在计算机科学中，它在分析算法复杂性的方面非常有用。\n大O符号是由德国数论学家保罗·巴赫曼在其1892年的著作《解析数论》（Analytische Zahlentheorie）首先引入的。而这个记号则是在另一位德国数论学家愛德蒙·蘭道的著作中才推广的，因此它有时又称为蘭道符号（Landau symbols）。代表“order of ...”（……阶）的大O，最初是一个大写希腊字母“Ο”（omicron），现今用的是大写拉丁字母“O”。\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号", "Tag": "算法设计"}
{"Answer": "无穷大渐近[编辑]大O符号在分析算法效率的时候非常有用。举个例子，解决一个规模为\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的问题所花费的时间（或者所需步骤的数目）可以表示為：\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        4\n        \n          n\n          \n            2\n          \n        \n        −\n        2\n        n\n        +\n        2\n      \n    \n    {\\displaystyle T(n)=4n^{2}-2n+2}\n  \n。当\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n增大时，\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n项将开始占主导地位，而其他各项可以被忽略。举例说明：当\n  \n    \n      \n        n\n        =\n        500\n      \n    \n    {\\displaystyle n=500}\n  \n，\n  \n    \n      \n        4\n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle 4n^{2}}\n  \n项是\n  \n    \n      \n        2\n        n\n      \n    \n    {\\displaystyle 2n}\n  \n项的1000倍大，因此在大多数场合下，省略后者对表达式的值的影响将是可以忽略不计的。\n进一步看，如果我们与任一其他级的表达式比较，\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n项的系数也是无关紧要的。例如：一个包含\n  \n    \n      \n        \n          n\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle n^{3}}\n  \n或\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n项的表达式，即使\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        1\n        ,\n        000\n        ,\n        000\n        ⋅\n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle T(n)=1,000,000\\cdot n^{2}}\n  \n，假定\n  \n    \n      \n        U\n        (\n        n\n        )\n        =\n        \n          n\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle U(n)=n^{3}}\n  \n，一旦\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n增长到大于1,000,000，后者就会一直超越前者（\n  \n    \n      \n        T\n        (\n        1\n        ,\n        000\n        ,\n        000\n        )\n        =\n        1\n        ,\n        000\n        ,\n        \n          000\n          \n            3\n          \n        \n        =\n        U\n        (\n        1\n        ,\n        000\n        ,\n        000\n        )\n      \n    \n    {\\displaystyle T(1,000,000)=1,000,000^{3}=U(1,000,000)}\n  \n）。\n\n这样，針對第一個例子\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        4\n        \n          n\n          \n            2\n          \n        \n        −\n        2\n        n\n        +\n        2\n      \n    \n    {\\displaystyle T(n)=4n^{2}-2n+2}\n  \n，大O符号就记下剩余的部分，写作：\n\n  \n    \n      \n        T\n        (\n        n\n        )\n        ∈\n        \n          O\n        \n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle T(n)\\in \\mathrm {O} (n^{2})}\n  \n或\n\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        \n          O\n        \n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle T(n)=\\mathrm {O} (n^{2})}\n  \n并且我们就说该算法具有\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n阶（平方阶）的时间复杂度。\n无穷小渐近[编辑]大O也可以用来描述数学函数估计中的误差项。例如\n  \n    \n      \n        \n          e\n          \n            x\n          \n        \n      \n    \n    {\\displaystyle e^{x}}\n  \n的泰勒展开：\n\n  \n    \n      \n        \n          e\n          \n            x\n          \n        \n        =\n        1\n        +\n        x\n        +\n        \n          \n            \n              x\n              \n                2\n              \n            \n            2\n          \n        \n        +\n        \n          \n            O\n          \n        \n        (\n        \n          x\n          \n            3\n          \n        \n        )\n        \n      \n    \n    {\\displaystyle e^{x}=1+x+{\\frac {x^{2}}{2}}+{\\hbox{O}}(x^{3})\\qquad }\n  \n当\n  \n    \n      \n        x\n        →\n        0\n      \n    \n    {\\displaystyle x\\to 0}\n  \n时这表示，如果\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n足够接近于0，那么误差\n  \n    \n      \n        \n          e\n          \n            x\n          \n        \n        −\n        \n          (\n          \n            1\n            +\n            x\n            +\n            \n              \n                \n                  x\n                  \n                    2\n                  \n                \n                2\n              \n            \n          \n          )\n        \n      \n    \n    {\\displaystyle e^{x}-\\left(1+x+{\\frac {x^{2}}{2}}\\right)}\n  \n的绝对值小于\n  \n    \n      \n        \n          x\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle x^{3}}\n  \n的某一常数倍。\n注：泰勒展开的误差余项\n  \n    \n      \n        \n          r\n          \n            3\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle r_{3}(x)}\n  \n是关于\n  \n    \n      \n        \n          x\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle x^{3}}\n  \n一个高阶无穷小量，用小o来表示，即：\n  \n    \n      \n        \n          r\n          \n            3\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle r_{3}(x)}\n  \n=\n  \n    \n      \n        o\n        (\n        \n          x\n          \n            3\n          \n        \n        )\n      \n    \n    {\\displaystyle o(x^{3})}\n  \n，也就是\n  \n    \n      \n        \n          lim\n          \n            x\n            →\n            0\n          \n        \n        \n          \n            \n              \n                r\n                \n                  3\n                \n              \n              (\n              x\n              )\n            \n            \n              x\n              \n                3\n              \n            \n          \n        \n        =\n        0.\n      \n    \n    {\\displaystyle \\lim _{x\\to 0}{\\frac {r_{3}(x)}{x^{3}}}=0.}\n  \n\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的使用", "Tag": "算法设计"}
{"Answer": "大O符号在分析算法效率的时候非常有用。举个例子，解决一个规模为\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的问题所花费的时间（或者所需步骤的数目）可以表示為：\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        4\n        \n          n\n          \n            2\n          \n        \n        −\n        2\n        n\n        +\n        2\n      \n    \n    {\\displaystyle T(n)=4n^{2}-2n+2}\n  \n。当\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n增大时，\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n项将开始占主导地位，而其他各项可以被忽略。举例说明：当\n  \n    \n      \n        n\n        =\n        500\n      \n    \n    {\\displaystyle n=500}\n  \n，\n  \n    \n      \n        4\n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle 4n^{2}}\n  \n项是\n  \n    \n      \n        2\n        n\n      \n    \n    {\\displaystyle 2n}\n  \n项的1000倍大，因此在大多数场合下，省略后者对表达式的值的影响将是可以忽略不计的。\n进一步看，如果我们与任一其他级的表达式比较，\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n项的系数也是无关紧要的。例如：一个包含\n  \n    \n      \n        \n          n\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle n^{3}}\n  \n或\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n项的表达式，即使\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        1\n        ,\n        000\n        ,\n        000\n        ⋅\n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle T(n)=1,000,000\\cdot n^{2}}\n  \n，假定\n  \n    \n      \n        U\n        (\n        n\n        )\n        =\n        \n          n\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle U(n)=n^{3}}\n  \n，一旦\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n增长到大于1,000,000，后者就会一直超越前者（\n  \n    \n      \n        T\n        (\n        1\n        ,\n        000\n        ,\n        000\n        )\n        =\n        1\n        ,\n        000\n        ,\n        \n          000\n          \n            3\n          \n        \n        =\n        U\n        (\n        1\n        ,\n        000\n        ,\n        000\n        )\n      \n    \n    {\\displaystyle T(1,000,000)=1,000,000^{3}=U(1,000,000)}\n  \n）。\n\n这样，針對第一個例子\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        4\n        \n          n\n          \n            2\n          \n        \n        −\n        2\n        n\n        +\n        2\n      \n    \n    {\\displaystyle T(n)=4n^{2}-2n+2}\n  \n，大O符号就记下剩余的部分，写作：\n\n  \n    \n      \n        T\n        (\n        n\n        )\n        ∈\n        \n          O\n        \n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle T(n)\\in \\mathrm {O} (n^{2})}\n  \n或\n\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        \n          O\n        \n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle T(n)=\\mathrm {O} (n^{2})}\n  \n并且我们就说该算法具有\n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n^{2}}\n  \n阶（平方阶）的时间复杂度。\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的使用的无穷大渐近", "Tag": "算法设计"}
{"Answer": "大O也可以用来描述数学函数估计中的误差项。例如\n  \n    \n      \n        \n          e\n          \n            x\n          \n        \n      \n    \n    {\\displaystyle e^{x}}\n  \n的泰勒展开：\n\n  \n    \n      \n        \n          e\n          \n            x\n          \n        \n        =\n        1\n        +\n        x\n        +\n        \n          \n            \n              x\n              \n                2\n              \n            \n            2\n          \n        \n        +\n        \n          \n            O\n          \n        \n        (\n        \n          x\n          \n            3\n          \n        \n        )\n        \n      \n    \n    {\\displaystyle e^{x}=1+x+{\\frac {x^{2}}{2}}+{\\hbox{O}}(x^{3})\\qquad }\n  \n当\n  \n    \n      \n        x\n        →\n        0\n      \n    \n    {\\displaystyle x\\to 0}\n  \n时这表示，如果\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n足够接近于0，那么误差\n  \n    \n      \n        \n          e\n          \n            x\n          \n        \n        −\n        \n          (\n          \n            1\n            +\n            x\n            +\n            \n              \n                \n                  x\n                  \n                    2\n                  \n                \n                2\n              \n            \n          \n          )\n        \n      \n    \n    {\\displaystyle e^{x}-\\left(1+x+{\\frac {x^{2}}{2}}\\right)}\n  \n的绝对值小于\n  \n    \n      \n        \n          x\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle x^{3}}\n  \n的某一常数倍。\n注：泰勒展开的误差余项\n  \n    \n      \n        \n          r\n          \n            3\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle r_{3}(x)}\n  \n是关于\n  \n    \n      \n        \n          x\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle x^{3}}\n  \n一个高阶无穷小量，用小o来表示，即：\n  \n    \n      \n        \n          r\n          \n            3\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle r_{3}(x)}\n  \n=\n  \n    \n      \n        o\n        (\n        \n          x\n          \n            3\n          \n        \n        )\n      \n    \n    {\\displaystyle o(x^{3})}\n  \n，也就是\n  \n    \n      \n        \n          lim\n          \n            x\n            →\n            0\n          \n        \n        \n          \n            \n              \n                r\n                \n                  3\n                \n              \n              (\n              x\n              )\n            \n            \n              x\n              \n                3\n              \n            \n          \n        \n        =\n        0.\n      \n    \n    {\\displaystyle \\lim _{x\\to 0}{\\frac {r_{3}(x)}{x^{3}}}=0.}\n  \n\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的使用的无穷小渐近", "Tag": "算法设计"}
{"Answer": "給定兩個定義在實數某子集上的關於\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n的函數\n  \n    \n      \n        f\n        (\n        x\n        )\n      \n    \n    {\\displaystyle f(x)}\n  \n和\n  \n    \n      \n        g\n        (\n        x\n        )\n      \n    \n    {\\displaystyle g(x)}\n  \n，當\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n趨近於無窮大時，存在正实數\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n，使得對於所有充分大（英语：sufficiently large）的\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n，都有\n  \n    \n      \n        f\n        (\n        x\n        )\n      \n    \n    {\\displaystyle f(x)}\n  \n的絕對值小於等於\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n乘以\n  \n    \n      \n        g\n        (\n        x\n        )\n      \n    \n    {\\displaystyle g(x)}\n  \n的絕對值，那麼我們就可以說，當\n  \n    \n      \n        x\n        →\n        ∞\n      \n    \n    {\\displaystyle x\\to \\infty }\n  \n時，\n\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          O\n        \n        (\n        g\n        (\n        x\n        )\n        )\n      \n    \n    {\\displaystyle f(x)=\\mathrm {O} (g(x))}\n  \n也就是說，假如存在正實數\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n和實數\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n0，使得對於所有的\n  \n    \n      \n        x\n        ≥\n        \n          x\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle x\\geq x_{0}}\n  \n，均有：\n  \n    \n      \n        \n          |\n        \n        f\n        (\n        x\n        )\n        \n          |\n        \n        ≤\n         \n        M\n        \n          |\n        \n        g\n        (\n        x\n        )\n        \n          |\n        \n      \n    \n    {\\displaystyle |f(x)|\\leq \\ M|g(x)|}\n  \n成立，我們就可以認爲，\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          O\n        \n        (\n        g\n        (\n        x\n        )\n        )\n      \n    \n    {\\displaystyle f(x)=\\mathrm {O} (g(x))}\n  \n。\n在很多情況下，我們會省略“當\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n趨近於無限大時”這個前提，而簡寫爲：\n\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          O\n        \n        (\n        g\n        (\n        x\n        )\n        )\n      \n    \n    {\\displaystyle f(x)=\\mathrm {O} (g(x))}\n  \n此概念也可以用於描述函數\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n在接近實數\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n時的行爲，通常\n  \n    \n      \n        a\n        =\n        0\n      \n    \n    {\\displaystyle a=0}\n  \n。當我們說，當\n  \n    \n      \n        x\n        →\n        a\n      \n    \n    {\\displaystyle x\\to a}\n  \n時，有\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          O\n        \n        (\n        g\n        (\n        x\n        )\n        )\n      \n    \n    {\\displaystyle f(x)=\\mathrm {O} (g(x))}\n  \n，也就相當於稱，當且僅當存在正實數\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n和實數\n  \n    \n      \n        δ\n      \n    \n    {\\displaystyle \\delta }\n  \n，使得對於所有的\n  \n    \n      \n        0\n        ≤\n        \n          |\n        \n        x\n        −\n        a\n        \n          |\n        \n        ≤\n        δ\n      \n    \n    {\\displaystyle 0\\leq |x-a|\\leq \\delta }\n  \n，均有\n  \n    \n      \n        \n          |\n        \n        f\n        (\n        x\n        )\n        \n          |\n        \n        ≤\n         \n        M\n        \n          |\n        \n        g\n        (\n        x\n        )\n        \n          |\n        \n      \n    \n    {\\displaystyle |f(x)|\\leq \\ M|g(x)|}\n  \n成立。\n如果當\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n和\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n足夠接近時，\n  \n    \n      \n        g\n        (\n        x\n        )\n      \n    \n    {\\displaystyle g(x)}\n  \n的值仍不爲0，這兩種定義就可以統一用上極限來表示：\n當且僅當\n  \n    \n      \n        \n          lim sup\n          \n            x\n            →\n            a\n          \n        \n        \n          |\n          \n            \n              \n                f\n                (\n                x\n                )\n              \n              \n                g\n                (\n                x\n                )\n              \n            \n          \n          |\n        \n        <\n        ∞\n      \n    \n    {\\displaystyle \\limsup _{x\\to a}\\left|{\\frac {f(x)}{g(x)}}\\right|<\\infty }\n  \n時，有\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          O\n        \n        (\n        g\n        (\n        x\n        )\n        )\n      \n    \n    {\\displaystyle f(x)=\\mathrm {O} (g(x))}\n  \n。", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的形式化定义", "Tag": "算法设计"}
{"Answer": "在具体的运用中，我们不一定使用大O符号的标准定义，而是使用几条简化规则来求出关于函数\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n的大O表示：\n假如\n  \n    \n      \n        f\n        (\n        x\n        )\n      \n    \n    {\\displaystyle f(x)}\n  \n是几项之和，那么只保留增长最快（通常是阶最高）的项，其他项省略。\n假如\n  \n    \n      \n        f\n        (\n        x\n        )\n      \n    \n    {\\displaystyle f(x)}\n  \n是几项之积，那么常数（不取决于x的乘数）省略。比如，使\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        6\n        \n          x\n          \n            4\n          \n        \n        −\n        2\n        \n          x\n          \n            3\n          \n        \n        +\n        5\n      \n    \n    {\\displaystyle f(x)=6x^{4}-2x^{3}+5}\n  \n，我们想要用大O符号来简化这个函数，来描述\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n接近无穷大时函数的增长情况。此函数由三项相加而成，\n  \n    \n      \n        6\n        \n          x\n          \n            4\n          \n        \n      \n    \n    {\\displaystyle 6x^{4}}\n  \n，\n  \n    \n      \n        −\n        2\n        \n          x\n          \n            3\n          \n        \n      \n    \n    {\\displaystyle -2x^{3}}\n  \n和\n  \n    \n      \n        5\n      \n    \n    {\\displaystyle 5}\n  \n。由于增长最快的是\n  \n    \n      \n        6\n        \n          x\n          \n            4\n          \n        \n      \n    \n    {\\displaystyle 6x^{4}}\n  \n这一项（因为阶最高，在x接近无穷大时，其对和的影响会大大超过其余两项），应用第一条规则，保留它而省略其他两项。对于\n  \n    \n      \n        6\n        \n          x\n          \n            4\n          \n        \n      \n    \n    {\\displaystyle 6x^{4}}\n  \n，由两项相乘而得，\n  \n    \n      \n        6\n      \n    \n    {\\displaystyle 6}\n  \n和\n  \n    \n      \n        \n          x\n          \n            4\n          \n        \n      \n    \n    {\\displaystyle x^{4}}\n  \n；应用第二条规则，\n  \n    \n      \n        6\n      \n    \n    {\\displaystyle 6}\n  \n是无关x的常数，所以省略。最后结果为\n  \n    \n      \n        \n          x\n          \n            4\n          \n        \n      \n    \n    {\\displaystyle x^{4}}\n  \n，也即\n  \n    \n      \n        g\n        (\n        x\n        )\n        =\n        \n          x\n          \n            4\n          \n        \n      \n    \n    {\\displaystyle g(x)=x^{4}}\n  \n。故有：\n由\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          O\n        \n        (\n        g\n        (\n        x\n        )\n        )\n      \n    \n    {\\displaystyle f(x)=\\mathrm {O} (g(x))}\n  \n，可得：\n\n  \n    \n      \n        6\n        \n          x\n          \n            4\n          \n        \n        −\n        2\n        \n          x\n          \n            3\n          \n        \n        +\n        5\n        =\n        O\n        (\n        \n          x\n          \n            4\n          \n        \n        )\n      \n    \n    {\\displaystyle 6x^{4}-2x^{3}+5=O(x^{4})}\n  \n我们可以将上式扩展为标准定义形式：\n对任意\n  \n    \n      \n        x\n        ≥\n        \n          x\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle x\\geq x_{0}}\n  \n，均有\n  \n    \n      \n        \n          |\n        \n        f\n        (\n        x\n        )\n        \n          |\n        \n        ≤\n        M\n        \n          |\n        \n        g\n        (\n        x\n        )\n        \n          |\n        \n      \n    \n    {\\displaystyle |f(x)|\\leq M|g(x)|}\n  \n，也就是\n  \n    \n      \n        6\n        \n          x\n          \n            4\n          \n        \n        −\n        2\n        \n          x\n          \n            3\n          \n        \n        +\n        5\n        ≤\n        M\n        \n          |\n        \n        \n          x\n          \n            4\n          \n        \n        \n          |\n        \n      \n    \n    {\\displaystyle 6x^{4}-2x^{3}+5\\leq M|x^{4}|}\n  \n可以（粗略）求出\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n和\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle x_{0}}\n  \n的值来验证。使\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle x_{0}=1}\n  \n：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  |\n                \n                6\n                \n                  x\n                  \n                    4\n                  \n                \n                −\n                2\n                \n                  x\n                  \n                    3\n                  \n                \n                +\n                5\n                \n                  |\n                \n              \n              \n                \n                ≤\n                6\n                \n                  x\n                  \n                    4\n                  \n                \n                +\n                \n                  |\n                \n                2\n                \n                  x\n                  \n                    3\n                  \n                \n                \n                  |\n                \n                +\n                5\n              \n            \n            \n              \n              \n                \n                ≤\n                6\n                \n                  x\n                  \n                    4\n                  \n                \n                +\n                2\n                \n                  x\n                  \n                    4\n                  \n                \n                +\n                5\n                \n                  x\n                  \n                    4\n                  \n                \n              \n            \n            \n              \n              \n                \n                ≤\n                13\n                \n                  x\n                  \n                    4\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}|6x^{4}-2x^{3}+5|&\\leq 6x^{4}+|2x^{3}|+5\\\\&\\leq 6x^{4}+2x^{4}+5x^{4}\\\\&\\leq 13x^{4}\\end{aligned}}}\n  \n故\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n可以为13。故两者都存在。\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的例子", "Tag": "算法设计"}
{"Answer": "下面是在分析算法的时候常见的函数分类列表。所有这些函数都处于\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n趋近于无穷大的情况下，增长得慢的函数列在上面。\n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n  \n是一个任意常数。\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的常用的函数阶", "Tag": "算法设计"}
{"Answer": "大O是最经常使用的比较函数的渐近符号。\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的一些相关的渐近符号", "Tag": "算法设计"}
{"Answer": "大O符号经常被误用：有的作者可能会使用大O符号表达大Θ符号的含义。因此在看到大O符号时应首先确定其是否为误用。\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的注意", "Tag": "算法设计"}
{"Answer": "O（拉丁字母）\n小o符號\n大Ω符号\n大Θ符号", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的参看", "Tag": "算法设计"}
{"Answer": "引用[编辑]\n来源[编辑]\n书籍\n严蔚敏、吴伟民：《数据结构：C语言版》. 清华大学出版社，1996. ISBN 7-302-02368-9. 1.4节 算法和算法分析，pp. 14-17.\n朱青：《計算機算法與程序設計》. 清华大学出版社，2009.10。ISBN 978-7-302-20267-7. 1.4节 算法的複雜性分析，pp. 16-17.\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的参考文献", "Tag": "算法设计"}
{"Answer": "\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的参考文献的引用", "Tag": "算法设计"}
{"Answer": "\n书籍\n严蔚敏、吴伟民：《数据结构：C语言版》. 清华大学出版社，1996. ISBN 7-302-02368-9. 1.4节 算法和算法分析，pp. 14-17.\n朱青：《計算機算法與程序設計》. 清华大学出版社，2009.10。ISBN 978-7-302-20267-7. 1.4节 算法的複雜性分析，pp. 16-17.\n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的参考文献的来源", "Tag": "算法设计"}
{"Answer": "\nHardy, G. H. Orders of Infinity: The 'Infinitärcalcül' of Paul du Bois-Reymond. Cambridge University Press. 1910. \nKnuth, Donald. 1.2.11: Asymptotic Representations. Fundamental Algorithms. The Art of Computer Programming 1 3rd. Addison–Wesley. 1997. ISBN 0-201-89683-4. \nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. 3.1: Asymptotic notation. Introduction to Algorithms 2nd. MIT Press and McGraw–Hill. 2001. ISBN 0-262-03293-7. \nSipser, Michael. Introduction to the Theory of Computation. PWS Publishing. 1997: 226–228. ISBN 0-534-94728-X. \nAvigad, Jeremy; Donnelly, Kevin. Formalizing O notation in Isabelle/HOL (PDF). International Joint Conference on Automated Reasoning. 2004. doi:10.1007/978-3-540-25984-8_27. \nBlack, Paul E. Black, Paul E. , 编. big-O notation. Dictionary of Algorithms and Data Structures. U.S. National Institute of Standards and Technology. 11 March 2005  [December 16, 2006]. （原始内容存档于2019-05-20）. \nBlack, Paul E. Black, Paul E. , 编. little-o notation. Dictionary of Algorithms and Data Structures. U.S. National Institute of Standards and Technology. 17 December 2004  [December 16, 2006]. （原始内容存档于2020-11-01）. \nBlack, Paul E. Black, Paul E. , 编. Ω. Dictionary of Algorithms and Data Structures. U.S. National Institute of Standards and Technology. 17 December 2004  [December 16, 2006]. （原始内容存档于2021-01-25）. \nBlack, Paul E. Black, Paul E. , 编. ω. Dictionary of Algorithms and Data Structures. U.S. National Institute of Standards and Technology. 17 December 2004  [December 16, 2006]. （原始内容存档于2021-01-26）. \nBlack, Paul E. Black, Paul E. , 编. Θ. Dictionary of Algorithms and Data Structures. U.S. National Institute of Standards and Technology. 17 December 2004  [December 16, 2006]. （原始内容存档于2021-01-26）. \n", "Konwledge_Point": "大O符号", "Question": "什么是大O符号的延伸閱讀", "Tag": "算法设计"}
{"Answer": "《最强大脑》是德国电视二台〈德國最強大腦（德语：Deutschlands Superhirn）〉的中国版，由江苏卫视引进。节目专注于传播脑科学知识和脑力竞技， 于2014年1月3日正式开播。节目全程邀请科学家，从科学角度，探秘天才的世界，把科学带出实验室，“让科学流行起来”。不同于其他游戏节目，本节目并不以高额的奖金或物质奖励作为卖点，而重在发现脑力超乎常人的人类。节目由《非诚勿扰》团队制作，中国、德国、意大利、西班牙、美国、俄罗斯与Endemol Shine集团的国际团队合作。\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑", "Tag": "算法设计"}
{"Answer": "本节目第一季录影场地为南京国际博览中心，第二季至第五季为江苏省广播电视总台演播室。\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的播出平台及时间", "Tag": "算法设计"}
{"Answer": "2013年10月，中国广电总局向各大卫视频道提出加强版的「限娱令」，规定每家卫视每年新引进版权模式节目不得超一个，卫视歌唱类节目黄金档最多保留4档[1]。这对各卫视频道有较大影响，于是各台纷纷调整了2014年的节目计划，向文化益智类节目转型，如安徽卫视在2013年推出了以演说制胜的文化选秀节目《超级演说家》，而江苏卫视和浙江卫视等电视台也决定推出多档崭新的节目，《最强大脑》便是其中之一。[2]\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的背景", "Tag": "算法设计"}
{"Answer": "德国原版[编辑]根据Endemol官网对于这个节目模式的描述，德国电视二台原版的《Superhirn》规则是，7位选手在一期节目里向观众展示自己的大脑才能，成功的选手接受观众投票，最佳者获得25000欧元现金奖励。\n中国版[编辑]中国版本的《最强大脑》与欧洲各版完全不同。中国版《最强大脑》前两季的赛程分为晋级赛、挑战赛、中外PK赛三个阶段，中外PK赛詳情請參閱下表[註 1]。\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的赛制", "Tag": "算法设计"}
{"Answer": "根据Endemol官网对于这个节目模式的描述，德国电视二台原版的《Superhirn》规则是，7位选手在一期节目里向观众展示自己的大脑才能，成功的选手接受观众投票，最佳者获得25000欧元现金奖励。\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的赛制的德国原版", "Tag": "算法设计"}
{"Answer": "中国版本的《最强大脑》与欧洲各版完全不同。中国版《最强大脑》前两季的赛程分为晋级赛、挑战赛、中外PK赛三个阶段，中外PK赛詳情請參閱下表[註 1]。\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的赛制的中国版", "Tag": "算法设计"}
{"Answer": "第一季（2014年1月—3月）[编辑]", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第一季（2014年1月—3月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第二季（2015年1月—3月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第三季（2016年1月—4月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第四季（2017年1月—4月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第五季（2018年1月－4月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第六季（2019年2月－5月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第七季（2020年5月－7月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第八季（2021年1月－4月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第九季（2022年1月－4月）", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的节目详情的第十季（2023年1月－3月）", "Tag": "算法设计"}
{"Answer": "第一季关于金秀贤[编辑]北京时间2014年3月8日下午，韩国演员金秀贤参与本节目第一季第11期的录影（该期节目将于2014年3月21日晚上播出）。有媒体报道称，金此次来华是江苏卫视包机从韩国首都首尔接到中国江苏南京，随行贴身安保团队人数超过二百，江苏省、南京市两级公安部门也是派出超过300名警力执勤，现场安保里三层外三层戒备森严，审核身份程序非同一般的严格，无票观众被谢绝入场；此外，一旦发现观众持倒票进场，立刻停止录影并驱逐观众。另据报道，其来华出场费高达300万元人民币。就连金本人上厕所喝水，也必须有至少两名保安陪同。[6]\n第四季“听音盲拧”[编辑]2017年1月8日的《最强大脑》第四季节目录制中出现了听音盲拧项目，盲拧实力明显弱于对手的贾立平战胜了世界第一的选手林恺俊。由于项目设置的争议以及出人意料的冷门，一时间舆论哗然。\n贾立平与林恺俊同台竞技，结果贾立平以2：0战胜林恺俊，获得了本轮比赛的胜利，结果遭到了裁判的异议，裁判认为贾立平用逆序还原的方式还原魔方，属于犯规，应该取消贾立平的参赛资格。经过询问世界魔方协会官方人士的意见，双方达成一致，贾立平合理利用比赛规则，使用逆序还原并不是犯规行为。同时决定重新录制听音盲拧项目。要求两位选手在进行打乱声音与打乱魔方的匹配观察，在盲拧过程中必须按照国际比赛的方法盲拧复原魔方；比赛加赛两局，共五局。林恺俊决定放弃本轮比赛。\n事件发生后，许多专业魔方选手纷纷站队林恺俊，认为“听音盲拧”的比赛项目具有不合理性，因为魔方的转动，声音几乎是没有区别的，选手不可能通过魔方转动的声音来复原魔方。有网友指出提出贾立平的“逆序还原”方法已经违反世界魔方比赛的规则，在提前知道打乱公式的前提下，使用逆序还原魔方的行为等同于作弊。\n2月24日晚，选手林恺俊微博发长文，详细讲述《最强大脑》录制前后经过。林恺俊指出，世界魔方协会的比赛规则中并没有禁止逆序还原的说法，那是因为参赛选手是不可能提前知道打乱公式，也就不存在逆序还原的可能。但是在《最强大脑》节目录制之前，导演组已经提前将15个魔方的打乱公式以及魔方打乱的声音（音频）发给两位选手，两位选手只需要记忆对应的音频特点，在现场识别出是哪一种打乱方法，进行还原即可。这样一来，这个项目考察的是盲拧魔方的技巧，不如说考察的是两位选手对音频的记忆能力。\n围棋世界冠军柯洁以嘉宾身份做客电视节目《最强大脑》，对于选手林恺俊愤怒退出，围棋世界冠军柯洁力挺林恺俊，他这样写道：“林恺俊选手当时的愤怒可想而知，退出这个舞台是对节目公平性最有有力的抗议，我支持你。节目组套路深，娱乐节目别太当真。”\n最强大脑节目组找来第三季的盲拧选手奇安弗兰科·乌安奇录制视频，视频中亦表示“使用逆序还原并不是犯规行为”，但方述杰随后向其说明实际情况后奇安弗兰科·乌安奇表示被节目组蒙蔽了。\n这一事件影响过于恶劣，最强大脑节目组最终决定取消了国际赛所有的魔方比赛。但有批评者指出这样的处理方式并不能真正惩罚贾立平，相反误伤同为中国战队的魔方赛手王鹰豪。第六季“舞弊门”系列丑闻[编辑]2019年3月24日：鲍橒於新浪微博發布“云之队三问大脑节目组”文章，指出节目组疑似為了節目效果而對“已播出节目中对实际录制情况进行剪辑改动”會造成觀眾對節目內容曲解，也提出“王易木能够提前了解到队内赛小项目的题目甚至还能画出示意图”的疑問，甚至抖出節目組疑似利用合同內容限制選手對節目黑幕的控訴[7]。\n2019年3月26日：節目組在官方新浪微博及微信公眾號發出聲明，表示：經過調查及取證後並未發現作弊情形發生。[8][9]\n2019年3月31日：節目組在官方新浪微博及微信公眾號發出“云之队队长鲍橒发布不实言论”的郑重声明，強調鲍橒所言不實，也指出鲍橒有違規操作行為，已收集證據，將與鲍橒合作的合同解約，並要求其刪除不實言論否則將尋求法律途徑。[10][11]2019年4月1日：鲍橒发布了第二篇头条文章《解答热心观众的疑点》，其中提到。随后，江苏广电官方新浪微博指出：《最强大脑》节目组已请律师团队介入并启动法律程序。[12]", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的批评与争议", "Tag": "算法设计"}
{"Answer": "北京时间2014年3月8日下午，韩国演员金秀贤参与本节目第一季第11期的录影（该期节目将于2014年3月21日晚上播出）。有媒体报道称，金此次来华是江苏卫视包机从韩国首都首尔接到中国江苏南京，随行贴身安保团队人数超过二百，江苏省、南京市两级公安部门也是派出超过300名警力执勤，现场安保里三层外三层戒备森严，审核身份程序非同一般的严格，无票观众被谢绝入场；此外，一旦发现观众持倒票进场，立刻停止录影并驱逐观众。另据报道，其来华出场费高达300万元人民币。就连金本人上厕所喝水，也必须有至少两名保安陪同。[6]\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的批评与争议的第一季关于金秀贤", "Tag": "算法设计"}
{"Answer": "2017年1月8日的《最强大脑》第四季节目录制中出现了听音盲拧项目，盲拧实力明显弱于对手的贾立平战胜了世界第一的选手林恺俊。由于项目设置的争议以及出人意料的冷门，一时间舆论哗然。\n贾立平与林恺俊同台竞技，结果贾立平以2：0战胜林恺俊，获得了本轮比赛的胜利，结果遭到了裁判的异议，裁判认为贾立平用逆序还原的方式还原魔方，属于犯规，应该取消贾立平的参赛资格。经过询问世界魔方协会官方人士的意见，双方达成一致，贾立平合理利用比赛规则，使用逆序还原并不是犯规行为。同时决定重新录制听音盲拧项目。要求两位选手在进行打乱声音与打乱魔方的匹配观察，在盲拧过程中必须按照国际比赛的方法盲拧复原魔方；比赛加赛两局，共五局。林恺俊决定放弃本轮比赛。\n事件发生后，许多专业魔方选手纷纷站队林恺俊，认为“听音盲拧”的比赛项目具有不合理性，因为魔方的转动，声音几乎是没有区别的，选手不可能通过魔方转动的声音来复原魔方。有网友指出提出贾立平的“逆序还原”方法已经违反世界魔方比赛的规则，在提前知道打乱公式的前提下，使用逆序还原魔方的行为等同于作弊。\n2月24日晚，选手林恺俊微博发长文，详细讲述《最强大脑》录制前后经过。林恺俊指出，世界魔方协会的比赛规则中并没有禁止逆序还原的说法，那是因为参赛选手是不可能提前知道打乱公式，也就不存在逆序还原的可能。但是在《最强大脑》节目录制之前，导演组已经提前将15个魔方的打乱公式以及魔方打乱的声音（音频）发给两位选手，两位选手只需要记忆对应的音频特点，在现场识别出是哪一种打乱方法，进行还原即可。这样一来，这个项目考察的是盲拧魔方的技巧，不如说考察的是两位选手对音频的记忆能力。\n围棋世界冠军柯洁以嘉宾身份做客电视节目《最强大脑》，对于选手林恺俊愤怒退出，围棋世界冠军柯洁力挺林恺俊，他这样写道：“林恺俊选手当时的愤怒可想而知，退出这个舞台是对节目公平性最有有力的抗议，我支持你。节目组套路深，娱乐节目别太当真。”\n最强大脑节目组找来第三季的盲拧选手奇安弗兰科·乌安奇录制视频，视频中亦表示“使用逆序还原并不是犯规行为”，但方述杰随后向其说明实际情况后奇安弗兰科·乌安奇表示被节目组蒙蔽了。\n这一事件影响过于恶劣，最强大脑节目组最终决定取消了国际赛所有的魔方比赛。但有批评者指出这样的处理方式并不能真正惩罚贾立平，相反误伤同为中国战队的魔方赛手王鹰豪。", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的批评与争议的第四季“听音盲拧”", "Tag": "算法设计"}
{"Answer": "2019年3月24日：鲍橒於新浪微博發布“云之队三问大脑节目组”文章，指出节目组疑似為了節目效果而對“已播出节目中对实际录制情况进行剪辑改动”會造成觀眾對節目內容曲解，也提出“王易木能够提前了解到队内赛小项目的题目甚至还能画出示意图”的疑問，甚至抖出節目組疑似利用合同內容限制選手對節目黑幕的控訴[7]。\n2019年3月26日：節目組在官方新浪微博及微信公眾號發出聲明，表示：經過調查及取證後並未發現作弊情形發生。[8][9]\n2019年3月31日：節目組在官方新浪微博及微信公眾號發出“云之队队长鲍橒发布不实言论”的郑重声明，強調鲍橒所言不實，也指出鲍橒有違規操作行為，已收集證據，將與鲍橒合作的合同解約，並要求其刪除不實言論否則將尋求法律途徑。[10][11]2019年4月1日：鲍橒发布了第二篇头条文章《解答热心观众的疑点》，其中提到。随后，江苏广电官方新浪微博指出：《最强大脑》节目组已请律师团队介入并启动法律程序。[12]", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的批评与争议的第六季“舞弊门”系列丑闻", "Tag": "算法设计"}
{"Answer": "第一季", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的收视率", "Tag": "算法设计"}
{"Answer": "第27届中国电视金鹰奖「最佳电视文艺节目作品奖」[13]\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的奖项", "Tag": "算法设计"}
{"Answer": "\n^ 第七季~第九季因2019冠狀病毒病影響取消中外PK賽\n\n^ 本期节目被国际评审Robert选中的最难的项目为郑才千和Franco的挑战项目，但X信封的内容并未在节目中播出。\n\n^ 因西班牙选手是色盲，选手挑战项目不相同。第七回合（本场第三回合）的项目：\n 中国选手：背对屏幕填写数独，其中由对手给出“一条龙”（9个格子，45度倾斜相连），选手必须遵循数独基本规则，同时这一条“龙”必须按严格递增或者递减的顺序填写1、2、3、……、9或9、8、7、……、1。\n 西班牙选手：由其对手在国际象棋棋盘内指定一个起点和终点，以及起点处的一个数字和每一行、每一列的八个数字之和（介于200和500之间的唯一整数）。下一个数字必须在上一个数字以国际象棋的“马”（Knight）跳行的位置上填写。例如，节目中孙指定A5是起始位置，下一个位置可以是B7、B6、B4（B3虽然也符合国际象棋中“马”的规则，但这是她指定的终点位置，必须最后填入数字），必须在这三格之一填入数字。\n\n^ 以上标出的是国际评审认定本期最难的项目，因第八回合结果已定，没有播出。\n\n^ 因受国家新闻出版广电总局通报表扬，本期被特别批准于2014年3月28日21:30—23:45在江苏卫视播出（包括前导片和尾声片段）。\n\n^ 由於其他國家沒有任何選手能夠玩蜂巢迷宮項目，所以鮑橒被逼退出比賽\n\n^ 袁梦因没有队长选择让她加入战队而被淘汰。\n\n^ 本局比賽為2 vs. 2，勝出方獲得積分2分\n\n^ 本局比賽為2 vs. 2，勝出方獲得積分2分\n\n^ 本局比賽為3 vs. 3，勝出方獲得積分3分\n\n\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的注", "Tag": "算法设计"}
{"Answer": "\n\n^ “加强版限娱令”：明年每季只有一档唱歌节目 （页面存档备份，存于互联网档案馆）金鹰网.\n\n^ 广电再推限娱令 益智类节目走俏 （页面存档备份，存于互联网档案馆）金羊网-羊城晚报.\n\n^ #最强大脑#播出时间调整【公告】 （页面存档备份，存于互联网档案馆）最强大脑官方新浪微博 2022-02-02[2022-02-04]\n\n^ #最强大脑#播出时间调整【公告】 （页面存档备份，存于互联网档案馆）最强大脑官方新浪微博 2022-03-01[2022-03-01]\n\n^ 【播出时间调整通知】 （页面存档备份，存于互联网档案馆）最强大脑官方新浪微博 2022-03-25[2022-03-25]\n\n^ 金秀贤来华首秀排场大 陶子柏芝瞬间成粉丝 （页面存档备份，存于互联网档案馆），新华网援引央广网（中国广播网）消息，北京时间2014年3月10日.\n\n^ 云之队三问大脑节目组 （页面存档备份，存于互联网档案馆）鲍橒新浪微博 2019-03-24[2019-03-31]\n\n^ #最强大脑##最强大脑发布声明#关于《光影迷踪》 项目争议的说明。 （页面存档备份，存于互联网档案馆）最强大脑官方新浪微博 2019-03-26[2019-03-27]\n\n^ 关于《光影迷踪》项目争议的说明 （页面存档备份，存于互联网档案馆）最强大脑官方微信公眾號 2019-03-26[2019-03-27]\n\n^ 关于“鲍橒散布不实言论”的郑重说明 （页面存档备份，存于互联网档案馆）最强大脑官方微信公眾號 2019-03-31[2019-03-31]\n\n^ #最强大脑##最强大脑发布声明# 《最强大脑》关于“云之队队长鲍橒发布不实言论”的郑重声明。 （页面存档备份，存于互联网档案馆）最强大脑官方新浪微博 2019-03-31[2019-03-31]\n\n^ 江苏广电的微博貼文 （页面存档备份，存于互联网档案馆）江苏广电官方新浪微博 2019-04-10[2019-04-10]\n\n^ “最强大脑”“汉字听写大会”等节目获第27届中国电视金鹰奖 （页面存档备份，存于互联网档案馆），凤凰网援引新华网消息，2014年9月10日.\n\n", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的参考资料", "Tag": "算法设计"}
{"Answer": "官方网站\n官方微博（页面存档备份，存于互联网档案馆）\n最强大脑（第二季）香港無綫電視官方網站（页面存档备份，存于互联网档案馆）", "Konwledge_Point": "最强大脑", "Question": "什么是最强大脑的外部链接", "Tag": "算法设计"}
{"Answer": "在计算机科学和运筹学中，近似算法（英語：Approximation algorithm）是指能为最优化问题寻找近似解的算法，该类算法找到的近似解与最优解之间的差值需能证明不超过某个值[1][2]。由于人们普遍猜测P≠NP，许多优化问题因此无法在多项式时间内得到精确解决。进而，理論計算機科學领域内自然而然地出现了试图在多项式时间复杂度内得到近似最优解的近似算法。在绝大多数情况下，近似算法得到的近似值位于最优解到最优解乘以某个特定的值之间，这个特定的值被称作近似比。不过，也有一些算法得到的近似值是在最优解到最优解加某个特定的值之间。\n近似算法的设计及分析过程中都包含一系列的数学证明，以保证其最差情况效率仍可接受[2]。这点也是它与模拟退火等启发式算法之间的不同之处，启发式算法通常能够找到一个比较好的近似解，但其设计及分析之初往往并不涉及最差情况效率的证明。\n", "Konwledge_Point": "近似算法", "Question": "什么是近似算法", "Tag": "算法设计"}
{"Answer": "在计算复杂性理论中的某些假设下，比如最著名的\n  \n    \n      \n        P\n        ≠\n        N\n        P\n      \n    \n    {\\displaystyle P\\neq NP}\n  \n假设下，对于一些可已被证明为NP完全的优化问题，无法在多项式时间内精确求到最优解，然而在现实或理论研究中，这类问题都有广泛的应用，在精确解无法得到的情况下，转而依靠高效的近似算法求可以接受的近似解。近似算法的研究也是当今计算机科学研究的一个主要方向。\n", "Konwledge_Point": "近似算法", "Question": "什么是近似算法的背景", "Tag": "算法设计"}
{"Answer": "对于一个最大化问题的实例，设其最优解是\n  \n    \n      \n        O\n        P\n        T\n      \n    \n    {\\displaystyle OPT}\n  \n，某个近似算法的解是\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n，若下式成立，\n\n  \n    \n      \n        α\n        ⋅\n        O\n        P\n        T\n        ≤\n        x\n        ≤\n        O\n        P\n        T\n      \n    \n    {\\displaystyle \\alpha \\cdot OPT\\leq x\\leq OPT}\n  \n\n其中\n  \n    \n      \n        0\n        <\n        α\n        <\n        1\n      \n    \n    {\\displaystyle 0<\\alpha <1}\n  \n则定义此近似算法的近似比为\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n。\n相应的，对于一个最小化问题的实例，设其最优解是\n  \n    \n      \n        O\n        P\n        T\n      \n    \n    {\\displaystyle OPT}\n  \n，某个近似算法的解是\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n，若下式成立，\n\n  \n    \n      \n        O\n        P\n        T\n        ≤\n        x\n        ≤\n        α\n        ⋅\n        O\n        P\n        T\n      \n    \n    {\\displaystyle OPT\\leq x\\leq \\alpha \\cdot OPT}\n  \n\n其中\n  \n    \n      \n        α\n        >\n        1\n      \n    \n    {\\displaystyle \\alpha >1}\n  \n则定义此近似算法的近似比为\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n。\n", "Konwledge_Point": "近似算法", "Question": "什么是近似算法的近似比", "Tag": "算法设计"}
{"Answer": "按照可以达到近似比的不同，可以将近似算法大致按以下分类：\nFPTAS（英语：Fully polynomial-time approximation scheme）\n多項式時間近似算法（PTAS）\n常数近似\n对数的多项式\n多项式其中对数的多项式和多项式都是对应于输入规模的。\n", "Konwledge_Point": "近似算法", "Question": "什么是近似算法的分类", "Tag": "算法设计"}
{"Answer": "近似算法的常用设计方法有贪心法，线性规划、半正定规划的松弛和取整，随机算法等。\n", "Konwledge_Point": "近似算法", "Question": "什么是近似算法的设计方法", "Tag": "算法设计"}
{"Answer": "对于一些问题，近似算法的近似比也会有一定的局限性，一个最大化问题（最小化问题类似）最好的近似算法可以达到的近似比不能比某个特定的值更高。20世纪90年代发展起来的PCP理论为证明近似的困难性提供了一套系统的工具。例如，对于常见的MAX3SAT问题，一个简单的随机算法可以满足7/8的子句，但是可以证明，找到一个能保证满足高于\n  \n    \n      \n        7\n        \n          /\n        \n        8\n        +\n        ϵ\n        (\n        ∀\n        ϵ\n        >\n        0\n        )\n      \n    \n    {\\displaystyle 7/8+\\epsilon (\\forall \\epsilon >0)}\n  \n比例子句的问题是NP困难的。所以在\n  \n    \n      \n        P\n        ≠\n        N\n        P\n      \n    \n    {\\displaystyle P\\neq NP}\n  \n的假设下，这个问题我们可以得到的最优近似比是7/8。进入21世纪之后，计算机科学家为了近似困难性更往前一步，提出了唯一性游戏假设，在这一假设下，一些重要的问题如MAX-CUT、MAX2SAT也被证明了可能达到的最优近似比。\n", "Konwledge_Point": "近似算法", "Question": "什么是近似算法的近似的困难性", "Tag": "算法设计"}
{"Answer": "P/NP問題", "Konwledge_Point": "近似算法", "Question": "什么是近似算法的參見", "Tag": "算法设计"}
{"Answer": "\n\n^ Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. 算法导论. 由潘金贵; 顾铁成; 李成法; 叶懋翻译 原书第二版. 机械工业出版社. 2006: 633-634. ISBN 978-7-111-18777-6 （中文（简体））.  使用|accessdate=需要含有|url= (帮助)\n\n^ 2.0 2.1 Bernard., Shmoys, David. The design of approximation algorithms. Cambridge University Press. 2011  [2022-09-04]. ISBN 9780521195270. OCLC 671709856. （原始内容存档于2022-12-20）. \n\n", "Konwledge_Point": "近似算法", "Question": "什么是近似算法的参考文献", "Tag": "算法设计"}
{"Answer": "編輯距離是針對二個字符串（例如英文字）的差異程度的量化量測，量測方式是看至少需要多少次的處理才能將一個字符串變成另一個字符串。編輯距離可以用在自然语言处理中，例如拼寫檢查可以根據一個拼錯的字和其他正確的字的編輯距離，判斷哪一個（或哪幾個）是比較可能的字。DNA也可以視為用A、C、G和T組成的字符串，因此編輯距離也用在生物信息学中，判斷二個DNA的類似程度。Unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。\n編輯距離有幾種不同的定義，差異在可以對字符串進行的處理。\n在萊文斯坦距離中，可以刪除、加入、取代字符串中的任何一個字元，也是較常用的編輯距離定義，常常提到編輯距離時，指的就是萊文斯坦距離[1]。\n也存在其他編輯距離的定義方式，例如 Damerau-Levenshtein 距离是一种莱文斯坦距离的变种，但允许以单一操作交换相邻的两个字符（称为字符转置），如 AB→BA 的距离是 1（交换）而非 2（先删除再插入、或者两次替换）。\nLCS（最长公共子序列）距離只允許刪除、加入字元[1]:37。\nJaro 距离只允许字符转置。\n汉明距离只允許取代字元[1]。例子[编辑]kitten和sitting的萊文斯坦距離是3。將kitten變為sitting的最小處理方式如下：\nkitten → sitten（將k改為s）\nsitten → sittin（將e改為i）\nsittin → sitting（最後加入g）若是考慮LCS距離（只考慮加入及刪除），LCS距離是5：\n刪除位在第1個字的k\n在第1個字之前加入s\n刪除位在第4個字的e\n在第4個字之前加入i\n在第6個字之前加入g", "Konwledge_Point": "編輯距離", "Question": "什么是編輯距離", "Tag": "算法设计"}
{"Answer": "kitten和sitting的萊文斯坦距離是3。將kitten變為sitting的最小處理方式如下：\nkitten → sitten（將k改為s）\nsitten → sittin（將e改為i）\nsittin → sitting（最後加入g）若是考慮LCS距離（只考慮加入及刪除），LCS距離是5：\n刪除位在第1個字的k\n在第1個字之前加入s\n刪除位在第4個字的e\n在第4個字之前加入i\n在第6個字之前加入g", "Konwledge_Point": "編輯距離", "Question": "什么是編輯距離的例子", "Tag": "算法设计"}
{"Answer": "\n\n^ 1.0 1.1 1.2 Navarro, Gonzalo. A guided tour to approximate string matching (PDF). ACM Computing Surveys. 1 March 2001, 33 (1): 31–88  [19 March 2015]. doi:10.1145/375360.375365. （原始内容 (PDF)存档于2021-04-19）. \n\n", "Konwledge_Point": "編輯距離", "Question": "什么是編輯距離的參考資料", "Tag": "算法设计"}
{"Answer": "在數學上，特別是在調和分析與拓撲群的理論中，龐特里雅金對偶定理解釋了傅立葉變換的一般性質。它統合了實數線上或有限阿貝爾群上的一些結果，如：\n實數線上夠「好」的複數值周期函數能表成傅立葉級數，反之也能從傅立葉級數推出原函數。實數線上夠「好」的複數值函數有傅立葉變換；一如周期函數，在此也能從其傅立葉變換反推出原函數。有限阿貝爾群上的複數值函數有離散傅立葉變換，這是在對偶群上的函數。此外，也從離散傅立葉變換反推原函數。此理論由龐特里亞金（Lev Pontryagin）首開，並結合了約翰·馮·諾伊曼與安德烈·韦伊的哈爾測度理論，它依賴於局部緊阿貝爾群的對偶群理論。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性", "Tag": "算法设计"}
{"Answer": "一個拓撲群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n被稱作局部緊的，若且唯若其單位元素e有個緊鄰域。明白地說，這代表存在一個包含e的開集\n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n，使得它在\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n裡的閉包\n  \n    \n      \n        \n          \n            \n              V\n              ¯\n            \n          \n        \n      \n    \n    {\\displaystyle {\\bar {V}}}\n  \n是緊的。局部緊群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n最值得注意的性質之一是它帶有一個唯一的自然測度，稱作哈爾測度，這使得我們可以一致地為\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中「夠好」的子集測量大小；在此「夠好」的明確意義是博雷爾集，即由緊集生成的σ-代數。更明確地說，局部緊群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的一個右哈爾測度是指一個有限可加的博雷爾測度μ，並在\n  \n    \n      \n        μ\n        (\n        x\n        g\n        )\n        =\n        μ\n        (\n        x\n        )\n        \n        (\n        ∀\n        g\n        ∈\n        G\n        )\n      \n    \n    {\\displaystyle \\mu (xg)=\\mu (x)\\;(\\forall g\\in G)}\n  \n的意義下滿足「右不變性」；此測度尚須滿足一些正則性（詳見主條目哈爾測度）。任兩個右不變哈爾測度至多差一個正的比例常數。準此要領，亦可定義左不變哈爾測度，當\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n是阿貝爾群時兩者符應。\n此測度讓我們得以定義\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n上的複數值博雷爾函數的積分，特別是可以考慮相關的\n  \n    \n      \n        \n          L\n          \n            p\n          \n        \n      \n    \n    {\\displaystyle L^{p}}\n  \n空間： \n\n  \n    \n      \n        \n          L\n          \n            μ\n          \n          \n            p\n          \n        \n        (\n        G\n        )\n        =\n        \n          {\n          \n            f\n            :\n            G\n            →\n            \n              C\n            \n            :\n            \n              ∫\n              \n                G\n              \n            \n            \n              |\n            \n            f\n            (\n            x\n            )\n            \n              \n                |\n              \n              \n                p\n              \n            \n            \n            d\n            μ\n            (\n            x\n            )\n            <\n            ∞\n          \n          }\n        \n      \n    \n    {\\displaystyle L_{\\mu }^{p}(G)=\\left\\{f:G\\rightarrow \\mathbb {C} :\\int _{G}|f(x)|^{p}\\,d\\mu (x)<\\infty \\right\\}}\n  \n以下是局部緊阿貝爾群的若干例子：\n\n  \n    \n      \n        \n          \n            R\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\mathbb {R} ^{n}}\n  \n，配上向量加法。\n正實數配上乘法。此群透過指數及對數映射同構於\n  \n    \n      \n        \n          R\n        \n      \n    \n    {\\displaystyle \\mathbb {R} }\n  \n。\n任意賦以離散拓撲的有限阿貝爾群。根據有限阿貝爾群的結構定理，任何這樣的群都是循環群的直積。\n整數\n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} }\n  \n配上加法，並賦予離散拓撲。\n圓群\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n。這是絕對值為一的複數在乘法下構成的群。我們有同構\n  \n    \n      \n        \n          T\n        \n        ≅\n        \n          R\n        \n        \n          /\n        \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {T} \\cong \\mathbb {R} /\\mathbb {Z} }\n  \n。\np進數配上加法及其p進拓撲。", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的哈爾測度", "Tag": "算法设计"}
{"Answer": "若\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n是局部緊緻阿貝爾群，\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的特徵標是一個從\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n到圓群\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n的連續群同態；特徵標在逐點乘法下構成一個群，一個特徵標的反元素是它的複共軛。可證明所有\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n上的特徵標在緊緻開拓撲（即：以緊集上的一致收斂定義收歛性）下構成一個局部緊緻阿貝爾群，稱作對偶群，記為\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n或\n  \n    \n      \n        \n          G\n          \n            ∧\n          \n        \n      \n    \n    {\\displaystyle G^{\\wedge }}\n  \n。若\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n可分，則\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n可度量化，對一般的\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n則不盡然。\n這可用線性代數中的對偶空間來類比，就像一個佈於\n  \n    \n      \n        K\n      \n    \n    {\\displaystyle K}\n  \n的向量空間\n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n有對偶空間\n  \n    \n      \n        \n          H\n          o\n          m\n        \n        (\n        V\n        ,\n        K\n        )\n      \n    \n    {\\displaystyle \\mathrm {Hom} (V,K)}\n  \n，對偶群可看成\n  \n    \n      \n        \n          H\n          o\n          m\n        \n        (\n        G\n        ,\n        \n          T\n        \n        )\n      \n    \n    {\\displaystyle \\mathrm {Hom} (G,\\mathbb {T} )}\n  \n。更抽象的說，這兩者都是可表函子，被\n  \n    \n      \n        K\n      \n    \n    {\\displaystyle K}\n  \n及\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n所表示。\n定理：二次對偶\n  \n    \n      \n        \n          G\n          \n            ∧\n            ∧\n          \n        \n      \n    \n    {\\displaystyle G^{\\wedge \\wedge }}\n  \n與\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n有個自然同構。\n在此，「自然」或「典範」同構意謂一個「自然地」定義的映射\n  \n    \n      \n        G\n        →\n        \n          G\n          \n            ∧\n            ∧\n          \n        \n      \n    \n    {\\displaystyle G\\rightarrow G^{\\wedge \\wedge }}\n  \n，要點是它在範疇中滿足函子性（詳見條目範疇論）。舉例明之：任何有限阿貝爾群都同構於其對偶群，但並不存在典範同構。\n定理中的自然同構定義如下：\n\n  \n    \n      \n        x\n        ↦\n        {\n        χ\n        ↦\n        χ\n        (\n        x\n        )\n        }\n        \n          \n             i.e. \n          \n        \n        x\n        (\n        χ\n        )\n        :=\n        χ\n        (\n        x\n        )\n      \n    \n    {\\displaystyle x\\mapsto \\{\\chi \\mapsto \\chi (x)\\}{\\mbox{ i.e. }}x(\\chi ):=\\chi (x)}\n  \n。換言之，我們藉著將一個元素\n  \n    \n      \n        x\n        ∈\n        G\n      \n    \n    {\\displaystyle x\\in G}\n  \n在每個\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的特徵上求值，得到一個\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n上的特徵。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的對偶群", "Tag": "算法设计"}
{"Answer": "在整數對加法形成的無窮循環群\n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} }\n  \n （配上離散拓撲）上，設χ為一特徵，則\n  \n    \n      \n        χ\n        (\n        n\n        )\n        =\n        χ\n        (\n        1\n        \n          )\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\chi (n)=\\chi (1)^{n}}\n  \n，因此χ決定於χ(1)的值；反之，給定一個\n  \n    \n      \n        α\n        ∈\n        \n          T\n        \n      \n    \n    {\\displaystyle \\alpha \\in \\mathbb {T} }\n  \n，必存在特徵χ使得χ(1)=α，由此得到群同構\n  \n    \n      \n        \n          \n            Z\n          \n          \n            ∧\n          \n        \n        \n          \n            \n              \n                →\n              \n              \n                ∼\n              \n            \n          \n        \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} ^{\\wedge }{\\stackrel {\\sim }{\\rightarrow }}\\mathbb {T} }\n  \n。此外也容易驗證\n  \n    \n      \n        \n          \n            Z\n          \n          \n            ∧\n          \n        \n      \n    \n    {\\displaystyle \\mathbb {Z} ^{\\wedge }}\n  \n上的緊-開拓撲對應到\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n誘導自\n  \n    \n      \n        \n          C\n        \n      \n    \n    {\\displaystyle \\mathbb {C} }\n  \n的拓撲。\n因此，\n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} }\n  \n的對偶群自然地同構於\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n。\n反之，\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n上的特徵皆形如\n  \n    \n      \n        z\n        ↦\n        \n          z\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle z\\mapsto z^{n}}\n  \n，其中n是整數。由於\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n是緊的，其對偶群上的拓撲由一致收斂性給出，對應的不外是\n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} }\n  \n上的離散拓撲。因此\n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbb {T} }\n  \n的對偶群自然地同構於\n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} }\n  \n。\n實數對加法構成的群\n  \n    \n      \n        \n          R\n        \n      \n    \n    {\\displaystyle \\mathbb {R} }\n  \n同構於自身的對偶群；\n  \n    \n      \n        \n          R\n        \n      \n    \n    {\\displaystyle \\mathbb {R} }\n  \n上的特徵皆形如\n  \n    \n      \n        r\n        ↦\n        \n          e\n          \n            i\n            r\n          \n        \n      \n    \n    {\\displaystyle r\\mapsto e^{ir}}\n  \n，其中r是實數。藉著這些對偶性，下節描述的傅立葉變換將符應於\n  \n    \n      \n        \n          R\n        \n      \n    \n    {\\displaystyle \\mathbb {R} }\n  \n上的古典版本。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的例子", "Tag": "算法设计"}
{"Answer": "對於一個局部緊阿貝爾群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n，傅立葉變換的值域是其對偶群。設\n  \n    \n      \n        f\n        ∈\n        \n          L\n          \n            1\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle f\\in L^{1}(G)}\n  \n，則其傅立葉變換是下述\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n上的函數：\n\n  \n    \n      \n        \n          \n            \n              f\n              ^\n            \n          \n        \n        (\n        χ\n        )\n        =\n        \n          ∫\n          \n            G\n          \n        \n        f\n        (\n        x\n        )\n        \n          \n            \n              χ\n              (\n              x\n              )\n            \n            ¯\n          \n        \n        \n        d\n        μ\n        (\n        x\n        )\n      \n    \n    {\\displaystyle {\\widehat {f}}(\\chi )=\\int _{G}f(x){\\overline {\\chi (x)}}\\;d\\mu (x)}\n  \n其中μ是\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n上的一個哈爾測度。可以證明\n  \n    \n      \n        \n          \n            \n              f\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {f}}}\n  \n是\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n上的有界連續函數，且在無窮遠處趨近零。同理可給出\n  \n    \n      \n        g\n        ∈\n        \n          L\n          \n            1\n          \n        \n        (\n        \n          \n            \n              G\n              ^\n            \n          \n        \n        )\n      \n    \n    {\\displaystyle g\\in L^{1}({\\hat {G}})}\n  \n的傅立葉逆變換\n\n  \n    \n      \n        \n          \n            \n              g\n              ˇ\n            \n          \n        \n        (\n        x\n        )\n        =\n        \n          ∫\n          \n            \n              \n                G\n                ^\n              \n            \n          \n        \n        g\n        (\n        χ\n        )\n        χ\n        (\n        x\n        )\n        \n        d\n        ν\n        (\n        χ\n        )\n      \n    \n    {\\displaystyle {\\check {g}}(x)=\\int _{\\widehat {G}}g(\\chi )\\chi (x)\\;d\\nu (\\chi )}\n  \n其中ν是\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n上的一個哈爾測度。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的傅立葉變換", "Tag": "算法设计"}
{"Answer": "局部緊阿貝爾群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n上的可積函數構成一個代數，其乘法由卷積給出：設\n  \n    \n      \n        f\n        ,\n        g\n        ∈\n        \n          L\n          \n            1\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle f,g\\in L^{1}(G)}\n  \n，則卷積定義為\n\n  \n    \n      \n        [\n        f\n        ⋆\n        g\n        ]\n        (\n        x\n        )\n        =\n        \n          ∫\n          \n            G\n          \n        \n        f\n        (\n        x\n        −\n        y\n        )\n        g\n        (\n        y\n        )\n        \n        d\n        μ\n        (\n        y\n        )\n      \n    \n    {\\displaystyle [f\\star g](x)=\\int _{G}f(x-y)g(y)\\,d\\mu (y)}\n  \n。定理：巴拿赫空間\n  \n    \n      \n        \n          L\n          \n            1\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle L^{1}(G)}\n  \n在卷積下構成一個交換結合代數。\n此代數稱作\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的群代數。根據\n  \n    \n      \n        \n          L\n          \n            1\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle L^{1}(G)}\n  \n的完備性，它是個巴拿赫空間。巴拿赫代數\n  \n    \n      \n        \n          L\n          \n            1\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle L^{1}(G)}\n  \n一般沒有乘法單位元，除非\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n離散。但它有個近似單位元，這是個網，以一有向集\n  \n    \n      \n        I\n      \n    \n    {\\displaystyle I}\n  \n為索引，寫作\n  \n    \n      \n        (\n        \n          e\n          \n            i\n          \n        \n        \n          )\n          \n            i\n            ∈\n            I\n          \n        \n      \n    \n    {\\displaystyle (e_{i})_{i\\in I}}\n  \n並滿足下述性質。\n\n  \n    \n      \n        f\n        ⋆\n        \n          e\n          \n            i\n          \n        \n        →\n        f\n      \n    \n    {\\displaystyle f\\star e_{i}\\rightarrow f}\n  \n。傅立葉變換將卷積映至逐點乘法，即：\n\n  \n    \n      \n        \n          \n            F\n          \n        \n        (\n        f\n        ⋆\n        g\n        )\n        (\n        χ\n        )\n        =\n        \n          \n            F\n          \n        \n        (\n        f\n        )\n        (\n        χ\n        )\n        ⋅\n        \n          \n            F\n          \n        \n        (\n        g\n        )\n        (\n        χ\n        )\n      \n    \n    {\\displaystyle {\\mathcal {F}}(f\\star g)(\\chi )={\\mathcal {F}}(f)(\\chi )\\cdot {\\mathcal {F}}(g)(\\chi )}\n  \n。特別是，對任意\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n上的特徵χ，可在群代數上定義一積性線性泛函\n\n  \n    \n      \n        f\n        ↦\n        \n          \n            \n              f\n              ^\n            \n          \n        \n        (\n        χ\n        )\n      \n    \n    {\\displaystyle f\\mapsto {\\widehat {f}}(\\chi )}\n  \n。群代數的重要性質之一，在於這些線性泛函窮竭了群代數上所有非平凡（即：非恆零）的積性線性泛函。見文獻中Loomis著作的第34節。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的群代數", "Tag": "算法设计"}
{"Answer": "如前所述，一個局部緊阿貝爾群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的對偶群依然是局部緊阿貝爾群，因而帶有一族哈爾測度，彼此至多差一個比例常數。\n定理：對偶群上存在一個哈爾測度，使得傅立葉變換在緊支集連續函數空間上的限制為等距同構。它可以唯一地延拓為一個么正算子。\n\n  \n    \n      \n        \n          \n            F\n          \n        \n        :\n        \n          L\n          \n            μ\n          \n          \n            2\n          \n        \n        (\n        G\n        )\n        →\n        \n          L\n          \n            ν\n          \n          \n            2\n          \n        \n        (\n        \n          \n            \n              G\n              ^\n            \n          \n        \n        )\n      \n    \n    {\\displaystyle {\\mathcal {F}}:L_{\\mu }^{2}(G)\\rightarrow L_{\\nu }^{2}({\\widehat {G}})}\n  \n其中\n  \n    \n      \n        ν\n      \n    \n    {\\displaystyle \\nu }\n  \n是對偶群上既取的哈爾測度。 \n注意到：若\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n非緊，\n  \n    \n      \n        \n          L\n          \n            1\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle L^{1}(G)}\n  \n並不包含\n  \n    \n      \n        \n          L\n          \n            2\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle L^{2}(G)}\n  \n，所以我們須訴諸一些技巧，例如限制於一個稠密子空間。\n依循Loomis書中術語，我們稱一對\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n與其對偶群上的哈爾測度\n  \n    \n      \n        (\n        μ\n        ,\n        ν\n        )\n      \n    \n    {\\displaystyle (\\mu ,\\nu )}\n  \n是相繫的，若且唯若傅立葉反轉公式成立。傅立葉變換之么正性遂蘊含：對所有\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n上的連續緊支集複數值函數\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n都有\n\n  \n    \n      \n        \n          ∫\n          \n            G\n          \n        \n        \n          |\n        \n        f\n        (\n        x\n        )\n        \n          \n            |\n          \n          \n            2\n          \n        \n         \n        d\n        μ\n        (\n        x\n        )\n        =\n        \n          ∫\n          \n            \n              \n                G\n                ^\n              \n            \n          \n        \n        \n          |\n        \n        \n          \n            \n              f\n              ^\n            \n          \n        \n        (\n        χ\n        )\n        \n          \n            |\n          \n          \n            2\n          \n        \n         \n        d\n        ν\n        (\n        χ\n        )\n      \n    \n    {\\displaystyle \\int _{G}|f(x)|^{2}\\ d\\mu (x)=\\int _{\\widehat {G}}|{\\widehat {f}}(\\chi )|^{2}\\ d\\nu (\\chi )}\n  \n在平方可積函數空間上，我們考慮的傅立葉變換是透過上述么正延拓得到的算子。對偶群本身也有個傅立葉逆變換；它可以刻劃為傅立葉變換之逆（或其伴隨算子，因為傅立葉變換是么正的），這是以下傅立葉反轉公式的內涵。\n定理：取定一對相繫哈爾測度\n  \n    \n      \n        (\n        μ\n        ,\n        ν\n        )\n      \n    \n    {\\displaystyle (\\mu ,\\nu )}\n  \n；對於傅立葉變換在緊支集連續函數上的限制，其伴隨算子是傅立葉逆變換：\n\n  \n    \n      \n        \n          L\n          \n            ν\n          \n          \n            2\n          \n        \n        (\n        \n          \n            \n              G\n              ^\n            \n          \n        \n        )\n        →\n        \n          L\n          \n            μ\n          \n          \n            2\n          \n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle L_{\\nu }^{2}({\\widehat {G}})\\rightarrow L_{\\mu }^{2}(G)}\n  \n在\n  \n    \n      \n        G\n        =\n        \n          \n            R\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle G=\\mathbb {R} ^{n}}\n  \n的情形，我們有\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n        =\n        \n          \n            R\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}=\\mathbb {R} ^{n}}\n  \n，若取下述相繫的哈爾測度，則回到傅立葉變換的古典定義：\n  \n    \n      \n        μ\n        =\n        (\n        2\n        π\n        \n          )\n          \n            −\n            n\n            \n              /\n            \n            2\n          \n        \n        ×\n      \n    \n    {\\displaystyle \\mu =(2\\pi )^{-n/2}\\times }\n  \n（勒貝格測度）\n\n  \n    \n      \n        ν\n        =\n        (\n        2\n        π\n        \n          )\n          \n            −\n            n\n            \n              /\n            \n            2\n          \n        \n        ×\n      \n    \n    {\\displaystyle \\nu =(2\\pi )^{-n/2}\\times }\n  \n（勒貝格測度）在\n  \n    \n      \n        G\n        =\n        \n          T\n        \n      \n    \n    {\\displaystyle G=\\mathbb {T} }\n  \n的情形，對偶群\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n自然同構於\n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} }\n  \n，而上述算子\n  \n    \n      \n        F\n      \n    \n    {\\displaystyle F}\n  \n歸於計算周期函數的傅立葉係數。\n若\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n為有限群，則得到離散傅立葉變換。此情形易直接證明。", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的普朗歇尔暨傅立葉反轉定理", "Tag": "算法设计"}
{"Answer": "龐特里亞金對偶定理的重要應用之一是下述刻劃：\n定理：一個局部緊阿貝爾群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n為緊，若且唯若對偶群\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n為離散。另一方面，\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n為離散若且唯若\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n為緊。\n對任何拓撲群，無論局部緊或交換與否，皆可定義玻爾緊化。上述對偶性的用處之一是刻劃局部緊阿貝爾群的玻爾緊化。對一個局部緊阿貝爾群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n，考慮拓撲群\n  \n    \n      \n        \n          \n            \n              H\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {H}}}\n  \n，其中\n  \n    \n      \n        H\n      \n    \n    {\\displaystyle H}\n  \n就群結構而言是\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n，但帶離散拓撲。由於下述包含映射\n\n  \n    \n      \n        ι\n        :\n        H\n        →\n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle \\iota :H\\rightarrow {\\widehat {G}}}\n  \n是個連續同態，其對偶同態\n\n  \n    \n      \n        G\n        ∼\n        \n          \n            \n              \n                \n                  G\n                  ^\n                \n              \n              ^\n            \n          \n        \n        \n          →\n        \n        \n          \n            \n              H\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle G\\sim {\\widehat {\\widehat {G}}}{\\rightarrow }{\\widehat {H}}}\n  \n是個映至一個緊群的同態；可以證明它滿足定義玻爾緊化的泛性質，因而\n  \n    \n      \n        \n          \n            \n              H\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {H}}}\n  \n確為\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的玻爾緊化。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的玻爾緊化", "Tag": "算法设计"}
{"Answer": "函子的觀點對於研究對偶群是很有用的。以下將以LCA表示所有局部緊阿貝爾群及其間的連續群同態構成之範疇。\n對偶群的構造\n  \n    \n      \n        G\n        ↦\n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle G\\mapsto {\\hat {G}}}\n  \n給出一個對偶函子\n  \n    \n      \n        \n          L\n          C\n          A\n        \n        →\n        \n          \n            L\n            C\n            A\n          \n          \n            \n              o\n              p\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {LCA} \\rightarrow \\mathbf {LCA} ^{\\mathrm {op} }}\n  \n。其二次迭代\n  \n    \n      \n        G\n        ↦\n        \n          G\n          \n            ∧\n            ∧\n          \n        \n      \n    \n    {\\displaystyle G\\mapsto G^{\\wedge \\wedge }}\n  \n遂給出函子\n  \n    \n      \n        \n          L\n          C\n          A\n        \n        →\n        \n          L\n          C\n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {LCA} \\rightarrow \\mathbf {LCA} }\n  \n。\n定理：對偶函子是一個範疇等價。\n定理：對偶函子的二次迭代自然同構於LCA上的恆等函子。\n此同構可以類比於有限維向量空間的二次對偶（特別是實與複向量空間）。\n龐特里亞金對偶性將離散群與緊群的子範疇交換。若\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n是一個環，而\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n是個左\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n-模，則從對偶性可推知離散左\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n-模與緊右\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n-模對偶。LCA裡的自同態環\n  \n    \n      \n        \n          E\n          n\n          d\n        \n        (\n        G\n        )\n      \n    \n    {\\displaystyle \\mathrm {End} (G)}\n  \n依對偶性對應至其反環（即：環的乘法次序交換）。舉例明之：取\n  \n    \n      \n        G\n        =\n        \n          Z\n        \n      \n    \n    {\\displaystyle G=\\mathbb {Z} }\n  \n，則\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n        =\n        \n          T\n        \n      \n    \n    {\\displaystyle {\\hat {G}}=\\mathbb {T} }\n  \n；前者滿足\n  \n    \n      \n        \n          E\n          n\n          d\n        \n        (\n        G\n        )\n        =\n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathrm {End} (G)=\\mathbb {Z} }\n  \n，對後者亦然。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的範疇論觀點", "Tag": "算法设计"}
{"Answer": "對非交換群\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n沒有類似的理論，因為此時對偶的對象\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n={\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的不可約表示之同構類}不只有一維表示，因此不構成一個群。在範疇論中類似的推廣稱作Tannaka-Krein對偶定理；但它缺乏與調和分析的聯繫，因而無法處理關於\n  \n    \n      \n        \n          \n            \n              G\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle {\\hat {G}}}\n  \n上的普朗歇尔測度的問題。\n某些非交換群的對偶理論以C*-代數的語言表述。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的非交換理論", "Tag": "算法设计"}
{"Answer": "龐特里亞金在1934年為局部緊阿貝爾群及其對偶性的理論奠下基礎。他的進路須假定群是第二可數的，並且是緊群或離散群。此條件先後由E.R. van Kampen（1935年）與安德魯·韋伊（1953年）改進為局部緊阿貝爾群。\n", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的源流", "Tag": "算法设计"}
{"Answer": "下列書籍（可在大部分大學圖書館找到）都有局部緊阿貝爾群、對偶定理與傅立葉變換的相關章節。Dixmier的著作有非交換調和分析的材料，也有英譯本。\nJacques Dixmier, Les C*-algèbres et leurs Représentations, Gauthier-Villars,1969.\nLynn H. Loomis, An Introduction to Abstract Harmonic Analysis, D. van Nostrand Co, 1953\nWalter Rudin, Fourier Analysis on Groups, 1962\nHans Reiter, Classical Harmonic Analysis and Locally Compact Groups, 1968（2nd ed produced by Jan D. Stegeman, 2000）。\nHewitt and Ross, Abstract Harmonic Analysis, vol 1, 1963.", "Konwledge_Point": "龐特里亞金對偶性", "Question": "什么是龐特里亞金對偶性的文獻", "Tag": "算法设计"}
{"Answer": "在优化理论中，最大流问题（英語：Maximum flow problem）涉及到在一个单源点、单汇点的网络流中找到一条最大的流。\n最大流问题可以被看作是一个更复杂的网络流问题（循环问题，circulation problem）的特殊情况。s-t流（从源点s到汇点t）的最大值等于s-t割的最小容量，这被称为最大流最小割定理。\n", "Konwledge_Point": "最大流问题", "Question": "什么是最大流问题", "Tag": "算法设计"}
{"Answer": "最大流问题最早是在1954年，由T.E.Harris 和F.S.Ross通过一个苏联铁路的交通流量的简化模型提出的。[1][2][3]\n1955年，L.R. Ford, Jr.和D.R. Fulkerson创建了第一个已知的算法， Ford–Fulkerson算法。[4][5]\n多年来，最大流问题的各种改进算法被发现，例如Edmonds和Karp还有Dinitz的最短增广路算法；Dinitz的阻塞流算法； Goldberg和陶尔扬的Push-Relabel算法；Goldberg和Rao的binary阻塞流算法。 Christiano, Kelner, Madry的电流算法，Spielman 发现一个最大流近似最优解，但仅适用于无向图。[6][7]\n", "Konwledge_Point": "最大流问题", "Question": "什么是最大流问题的历史", "Tag": "算法设计"}
{"Answer": "  一个网络流，源点为 s，汇点为 t。边上的数字为容量。设\n  \n    \n      \n        N\n        =\n        (\n        V\n        ,\n        E\n        )\n      \n    \n    {\\displaystyle N=(V,E)}\n  \n为一个网络，其中\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n和\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n分别是\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n的源点和汇点（\n  \n    \n      \n        s\n        ,\n        t\n        ∈\n        V\n      \n    \n    {\\displaystyle s,t\\in V}\n  \n）。\n一个边的容量为映射\n  \n    \n      \n        c\n        :\n        E\n        →\n        \n          \n            R\n          \n          \n            +\n          \n        \n      \n    \n    {\\displaystyle c:E\\to \\mathbb {R} ^{+}}\n  \n，记为\n  \n    \n      \n        \n          c\n          \n            u\n            v\n          \n        \n      \n    \n    {\\displaystyle c_{uv}}\n  \n或\n  \n    \n      \n        c\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle c(u,v)}\n  \n。它表示可以通过一条边的流量的最大值。一个流为一个映射\n  \n    \n      \n        f\n        :\n        E\n        →\n        \n          \n            R\n          \n          \n            +\n          \n        \n      \n    \n    {\\displaystyle f:E\\to \\mathbb {R} ^{+}}\n  \n，记为\n  \n    \n      \n        \n          f\n          \n            u\n            v\n          \n        \n      \n    \n    {\\displaystyle f_{uv}}\n  \n或\n  \n    \n      \n        f\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle f(u,v)}\n  \n，遵循下面两个限制：\n对于每个\n  \n    \n      \n        (\n        u\n        ,\n        v\n        )\n        ∈\n        E\n      \n    \n    {\\displaystyle (u,v)\\in E}\n  \n，有\n  \n    \n      \n        \n          f\n          \n            u\n            v\n          \n        \n        ≤\n        \n          c\n          \n            u\n            v\n          \n        \n      \n    \n    {\\displaystyle f_{uv}\\leq c_{uv}}\n  \n（即容量限制：一个边的流量不能超过它的容量）；\n对于每个\n  \n    \n      \n        v\n        ∈\n        V\n        ∖\n        {\n        s\n        ,\n        t\n        }\n      \n    \n    {\\displaystyle v\\in V\\setminus \\{s,t\\}}\n  \n，有\n  \n    \n      \n        \n          ∑\n          \n            u\n            :\n            (\n            u\n            ,\n            v\n            )\n            ∈\n            E\n          \n        \n        \n          f\n          \n            u\n            v\n          \n        \n        =\n        \n          ∑\n          \n            u\n            :\n            (\n            v\n            ,\n            u\n            )\n            ∈\n            E\n          \n        \n        \n          f\n          \n            v\n            u\n          \n        \n      \n    \n    {\\displaystyle \\sum _{u:(u,v)\\in E}f_{uv}=\\sum _{u:(v,u)\\in E}f_{vu}}\n  \n（即流的保留：流入一个节点的流的总和必须等于流出这个节点的流的总和，源点和汇点除外）。流量定义为 \n  \n    \n      \n        \n          |\n        \n        f\n        \n          |\n        \n        =\n        \n          ∑\n          \n            v\n            :\n            (\n            s\n            ,\n            v\n            )\n            ∈\n            E\n          \n        \n        \n          f\n          \n            s\n            v\n          \n        \n      \n    \n    {\\displaystyle |f|=\\sum _{v:(s,v)\\in E}f_{sv}}\n  \n，其中\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n为\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n的源点，它表示从源点到汇点的流的数量。最大流问题就是最大化\n  \n    \n      \n        \n          |\n        \n        f\n        \n          |\n        \n      \n    \n    {\\displaystyle |f|}\n  \n，即从\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n点到\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n点尽可能规划最大的流量。", "Konwledge_Point": "最大流问题", "Question": "什么是最大流问题的定义", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最大流问题", "Question": "什么是最大流问题的解法", "Tag": "算法设计"}
{"Answer": "\n\n^ Schrijver, A. On the history of the transportation and maximum flow problems. Mathematical Programming. 2002, 91 (3): 437–445. doi:10.1007/s101070100259. \n\n^ Gass, Saul I.; Assad, Arjang A. Mathematical, algorithmic and professional developments of operations research from 1951 to 1956. An Annotated Timeline of Operations Research. International Series in Operations Research & Management Science 75. 2005: 79–110. ISBN 1-4020-8116-2. doi:10.1007/0-387-25837-X_5. \n\n^ Harris, T. E.; Ross, F. S. Fundamentals of a Method for Evaluating Rail Net Capacities (PDF). Research Memorandum (Rand Corporation). 1955  [2017-03-07]. （原始内容存档 (PDF)于2017-02-17）. \n\n^ Ford, L. R.; Fulkerson, D. R. Maximal flow through a network. Canadian Journal of Mathematics. 1956, 8: 399. doi:10.4153/CJM-1956-045-5. \n\n^ Ford, L.R., Jr.; Fulkerson, D.R., Flows in Networks, Princeton University Press (1962).\n\n^ Kelner, J. A.; Lee, Y. T.; Orecchia, L.; Sidford, A. An Almost-Linear-Time Algorithm for Approximate Max Flow in Undirected Graphs, and its Multicommodity Generalizations. Proceedings of the Twenty-Fifth Annual ACM-SIAM Symposium on Discrete Algorithms (PDF). 2014: 217. ISBN 978-1-61197-338-9. arXiv:1304.2338 . doi:10.1137/1.9781611973402.16. （原始内容 (PDF)存档于2016-03-03）. \n\n^ Knight, Helen. New algorithm can dramatically streamline solutions to the ‘max flow’ problem. MIT News. 7 January 2014  [8 January 2014]. （原始内容存档于2014-02-26）. \n\n^ Malhotra, V.M.; Kumar, M.Pramodh; Maheshwari, S.N. An \n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          \n            |\n          \n          \n            3\n          \n        \n        )\n      \n    \n    {\\displaystyle O(|V|^{3})}\n  \n algorithm for finding maximum flows in networks. Information Processing Letters. 1978, 7 (6): 277–278. doi:10.1016/0020-0190(78)90016-9. \n\n^ King, V.; Rao, S.; Tarjan, R. A Faster Deterministic Maximum Flow Algorithm. Journal of Algorithms. 1994, 17 (3): 447–474. doi:10.1006/jagm.1994.1044. \n\n^ Goldberg, A. V.; Rao, S. Beyond the flow decomposition barrier. ACM期刊. 1998, 45 (5): 783. doi:10.1145/290179.290181. \n\n^ Orlin, James B. Max flows in O(nm) time, or better. STOC '13 Proceedings of the forty-fifth annual ACM symposium on Theory of computing. 2013: 765–774. doi:10.1145/2488608.2488705. \n\n", "Konwledge_Point": "最大流问题", "Question": "什么是最大流问题的参考文献", "Tag": "算法设计"}
{"Answer": "斐波那契数（意大利语：Successione di Fibonacci），又譯為菲波拿契數、菲波那西數、斐氏數、黃金分割數。所形成的數列稱為斐波那契数列（意大利语：Successione di Fibonacci），又譯為菲波拿契數列、菲波那西數列、斐氏數列、黃金分割數列。這個數列是由意大利數學家斐波那契在他的《算盤書》中提出。\n在數學上，斐波那契數是以遞歸的方法來定義：\n\n  \n    \n      \n        \n          F\n          \n            0\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle F_{0}=0}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            1\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle F_{1}=1}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          F\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle F_{n}=F_{n-1}+F_{n-2}}\n  \n（\n  \n    \n      \n        n\n        ≧\n        2\n      \n    \n    {\\displaystyle n\\geqq 2}\n  \n）用文字來說，就是斐波那契數列由0和1開始，之後的斐波那契數就是由之前的兩數相加而得出。首幾個斐波那契數是：\n1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987……（OEIS數列A000045）特別指出：0不是第一項，而是第零項。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数", "Tag": "算法设计"}
{"Answer": "公元1150年印度數學家Gopala和金月在研究箱子包裝物件長宽剛好為1和2的可行方法數目時，首先描述這個數列。在西方，最先研究這個數列的人是比薩的李奧納多（義大利人斐波那契Leonardo Fibonacci, 1175－1250），他描述兔子生長的數目時用上了這數列：\n  兔子对的数量就是斐波那契数列第一個月初有一對剛誕生的兔子\n第二個月之後（第三個月初）牠們可以生育\n每月每對可生育的兔子會誕生下一對新兔子\n兔子永不死去假設在\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n月有兔子總共\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n對，\n  \n    \n      \n        n\n        +\n        1\n      \n    \n    {\\displaystyle n+1}\n  \n月總共有\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n對。在\n  \n    \n      \n        n\n        +\n        2\n      \n    \n    {\\displaystyle n+2}\n  \n月必定總共有\n  \n    \n      \n        a\n        +\n        b\n      \n    \n    {\\displaystyle a+b}\n  \n對：因為在\n  \n    \n      \n        n\n        +\n        2\n      \n    \n    {\\displaystyle n+2}\n  \n月的時候，前一月（\n  \n    \n      \n        n\n        +\n        1\n      \n    \n    {\\displaystyle n+1}\n  \n月）的\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n對兔子可以存留至第\n  \n    \n      \n        n\n        +\n        2\n      \n    \n    {\\displaystyle n+2}\n  \n月（在當月屬於新誕生的兔子尚不能生育）。而新生育出的兔子對數等於所有在\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n月就已存在的\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n對\n  斐波纳契数是帕斯卡三角形的每一条红色对角线上数字的和。斐波纳契数也是杨辉三角的每一条红色对角线上数字的和。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的起源", "Tag": "算法设计"}
{"Answer": "為求得斐波那契數列的一般表達式，可以藉助線性代數的方法。高中的初等數學知識也能求出。\n初等代數解法[编辑]已知\n\n  \n    \n      \n        \n          a\n          \n            1\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle a_{1}=1}\n  \n\n\n  \n    \n      \n        \n          a\n          \n            2\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle a_{2}=1}\n  \n\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{n}=a_{n-1}+a_{n-2}}\n  \n（n≥3）首先構建等比數列[编辑]設\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        =\n        β\n        (\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle a_{n}+\\alpha a_{n-1}=\\beta (a_{n-1}+\\alpha a_{n-2})}\n  \n化簡得\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        (\n        β\n        −\n        α\n        )\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        α\n        β\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{n}=(\\beta -\\alpha )a_{n-1}+\\alpha \\beta a_{n-2}}\n  \n\n比較係數可得：\n\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  β\n                  −\n                  α\n                  =\n                  1\n                \n              \n              \n                \n                  α\n                  β\n                  =\n                  1\n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}\\beta -\\alpha =1\\\\\\alpha \\beta =1\\end{cases}}}\n  \n\n不妨設\n  \n    \n      \n        β\n        >\n        0\n        ,\n        α\n        >\n        0\n      \n    \n    {\\displaystyle \\beta >0,\\alpha >0}\n  \n\n解得：\n\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  α\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          −\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n              \n                \n                  β\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          +\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}\\alpha ={\\dfrac {{\\sqrt {5}}-1}{2}}\\\\\\beta ={\\dfrac {{\\sqrt {5}}+1}{2}}\\end{cases}}}\n  \n\n\n又因为有\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        =\n        β\n        (\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle a_{n}+\\alpha a_{n-1}=\\beta (a_{n-1}+\\alpha a_{n-2})}\n  \n，\n即\n  \n    \n      \n        \n          {\n          \n            \n              a\n              \n                n\n              \n            \n            +\n            α\n            \n              a\n              \n                n\n                −\n                1\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{a_{n}+\\alpha a_{n-1}\\right\\}}\n  \n為等比數列。\n求出數列\n  \n    \n      \n        \n          {\n          \n            \n              a\n              \n                n\n              \n            \n            +\n            α\n            \n              a\n              \n                n\n                −\n                1\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{a_{n}+\\alpha a_{n-1}\\right\\}}\n  \n[编辑]由以上可得：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  a\n                  \n                    n\n                    +\n                    1\n                  \n                \n                +\n                α\n                \n                  a\n                  \n                    n\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  a\n                  \n                    2\n                  \n                \n                +\n                α\n                \n                  a\n                  \n                    1\n                  \n                \n                )\n                \n                  β\n                  \n                    n\n                    −\n                    1\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                (\n                1\n                +\n                α\n                )\n                \n                  β\n                  \n                    n\n                    −\n                    1\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  β\n                  \n                    n\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}a_{n+1}+\\alpha a_{n}&=(a_{2}+\\alpha a_{1})\\beta ^{n-1}\\\\&=(1+\\alpha )\\beta ^{n-1}\\\\&=\\beta ^{n}\\\\\\end{aligned}}}\n  \n\n變形得：\n\n  \n    \n      \n        \n          \n            \n              a\n              \n                n\n                +\n                1\n              \n            \n            \n              β\n              \n                n\n                +\n                1\n              \n            \n          \n        \n        +\n        \n          \n            α\n            β\n          \n        \n        ⋅\n        \n          \n            \n              a\n              \n                n\n              \n            \n            \n              β\n              \n                n\n              \n            \n          \n        \n        =\n        \n          \n            1\n            β\n          \n        \n      \n    \n    {\\displaystyle {\\frac {a_{n+1}}{\\beta ^{n+1}}}+{\\frac {\\alpha }{\\beta }}\\cdot {\\frac {a_{n}}{\\beta ^{n}}}={\\frac {1}{\\beta }}}\n  \n。\n令\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          \n            \n              a\n              \n                n\n              \n            \n            \n              β\n              \n                n\n              \n            \n          \n        \n      \n    \n    {\\displaystyle b_{n}={\\frac {a_{n}}{\\beta ^{n}}}}\n  \n\n求數列\n  \n    \n      \n        \n          {\n          \n            \n              b\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{{b_{n}}\\right\\}}\n  \n進而得到\n  \n    \n      \n        \n          {\n          \n            a\n            \n              n\n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{a_{n}\\right\\}}\n  \n[编辑]\n  \n    \n      \n        \n          b\n          \n            n\n            +\n            1\n          \n        \n        +\n        \n          \n            α\n            β\n          \n        \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          \n            1\n            β\n          \n        \n      \n    \n    {\\displaystyle b_{n+1}+{\\frac {\\alpha }{\\beta }}b_{n}={\\frac {1}{\\beta }}}\n  \n\n設\n  \n    \n      \n        \n          b\n          \n            n\n            +\n            1\n          \n        \n        +\n        λ\n        =\n        −\n        \n          \n            α\n            β\n          \n        \n        (\n        \n          b\n          \n            n\n          \n        \n        +\n        λ\n        )\n      \n    \n    {\\displaystyle b_{n+1}+\\lambda =-{\\frac {\\alpha }{\\beta }}(b_{n}+\\lambda )}\n  \n，解得\n  \n    \n      \n        λ\n        =\n        −\n        \n          \n            1\n            \n              α\n              +\n              β\n            \n          \n        \n      \n    \n    {\\displaystyle \\lambda =-{\\frac {1}{\\alpha +\\beta }}}\n  \n。\n故數列\n  \n    \n      \n        \n          {\n          \n            \n              b\n              \n                n\n              \n            \n            +\n            λ\n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{b_{n}+\\lambda \\right\\}}\n  \n為等比數列\n即\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        +\n        λ\n        =\n        \n          \n            (\n            \n              −\n              \n                \n                  α\n                  β\n                \n              \n            \n            )\n          \n          \n            n\n            −\n            1\n          \n        \n        \n          (\n          \n            \n              b\n              \n                1\n              \n            \n            +\n            λ\n          \n          )\n        \n      \n    \n    {\\displaystyle b_{n}+\\lambda =\\left(-{\\frac {\\alpha }{\\beta }}\\right)^{n-1}\\left(b_{1}+\\lambda \\right)}\n  \n。而\n  \n    \n      \n        \n          b\n          \n            1\n          \n        \n        =\n        \n          \n            \n              a\n              \n                1\n              \n            \n            β\n          \n        \n        =\n        \n          \n            1\n            β\n          \n        \n      \n    \n    {\\displaystyle b_{1}={\\frac {a_{1}}{\\beta }}={\\frac {1}{\\beta }}}\n  \n，\n故有\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        +\n        λ\n        =\n        \n          \n            (\n            \n              −\n              \n                \n                  α\n                  β\n                \n              \n            \n            )\n          \n          \n            n\n            −\n            1\n          \n        \n        \n          (\n          \n            \n              \n                1\n                β\n              \n            \n            +\n            λ\n          \n          )\n        \n      \n    \n    {\\displaystyle b_{n}+\\lambda =\\left(-{\\frac {\\alpha }{\\beta }}\\right)^{n-1}\\left({\\frac {1}{\\beta }}+\\lambda \\right)}\n  \n\n又有\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  α\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          −\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n              \n                \n                  β\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          +\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}\\alpha ={\\dfrac {{\\sqrt {5}}-1}{2}}\\\\\\beta ={\\dfrac {{\\sqrt {5}}+1}{2}}\\end{cases}}}\n  \n\n和\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          \n            \n              a\n              \n                n\n              \n            \n            \n              β\n              \n                n\n              \n            \n          \n        \n      \n    \n    {\\displaystyle b_{n}={\\frac {a_{n}}{\\beta ^{n}}}}\n  \n\n可得\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          \n            \n              5\n            \n            5\n          \n        \n        ⋅\n        \n          [\n          \n            \n              \n                (\n                \n                  \n                    \n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n            −\n            \n              \n                (\n                \n                  \n                    \n                      1\n                      −\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n          \n          ]\n        \n      \n    \n    {\\displaystyle a_{n}={\\frac {\\sqrt {5}}{5}}\\cdot \\left[\\left({\\frac {1+{\\sqrt {5}}}{2}}\\right)^{n}-\\left({\\frac {1-{\\sqrt {5}}}{2}}\\right)^{n}\\right]}\n  \n\n得出\n  \n    \n      \n        \n          \n            a\n            \n              n\n            \n          \n        \n      \n    \n    {\\displaystyle {a_{n}}}\n  \n表達式\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          \n            \n              5\n            \n            5\n          \n        \n        ⋅\n        \n          [\n          \n            \n              \n                (\n                \n                  \n                    \n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n            −\n            \n              \n                (\n                \n                  \n                    \n                      1\n                      −\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n          \n          ]\n        \n      \n    \n    {\\displaystyle a_{n}={\\frac {\\sqrt {5}}{5}}\\cdot \\left[\\left({\\frac {1+{\\sqrt {5}}}{2}}\\right)^{n}-\\left({\\frac {1-{\\sqrt {5}}}{2}}\\right)^{n}\\right]}\n  \n\n用數學歸納法證明表達式[编辑]證明\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            n\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            n\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{n}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{n}-(1-\\varphi )^{n}]}\n  \n，其中\n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n為黃金比例\n  \n    \n      \n        \n          \n            \n              1\n              +\n              \n                \n                  5\n                \n              \n            \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1+{\\sqrt {5}}}{2}}}\n  \n，\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為任意整數若\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為非負整數當\n  \n    \n      \n        n\n        =\n        0\n      \n    \n    {\\displaystyle n=0}\n  \n時，\n  \n    \n      \n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            0\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            0\n          \n        \n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        1\n        −\n        1\n        ]\n        =\n        0\n        =\n        \n          F\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\sqrt {5}}}[\\varphi ^{0}-(1-\\varphi )^{0}]={\\frac {1}{\\sqrt {5}}}[1-1]=0=F_{0}}\n  \n，成立\n當\n  \n    \n      \n        n\n        =\n        1\n      \n    \n    {\\displaystyle n=1}\n  \n時，\n  \n    \n      \n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            1\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            1\n          \n        \n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        φ\n        −\n        1\n        +\n        φ\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        2\n        φ\n        −\n        1\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ×\n        \n          \n            5\n          \n        \n        =\n        1\n        =\n        \n          F\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\sqrt {5}}}[\\varphi ^{1}-(1-\\varphi )^{1}]={\\frac {1}{\\sqrt {5}}}[\\varphi -1+\\varphi ]={\\frac {1}{\\sqrt {5}}}[2\\varphi -1]={\\frac {1}{\\sqrt {5}}}\\times {\\sqrt {5}}=1=F_{1}}\n  \n，成立\n設當\n  \n    \n      \n        n\n        =\n        k\n      \n    \n    {\\displaystyle n=k}\n  \n及\n  \n    \n      \n        n\n        =\n        k\n        +\n        1\n      \n    \n    {\\displaystyle n=k+1}\n  \n時皆成立，即\n  \n    \n      \n        \n          F\n          \n            k\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            k\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            k\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{k}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k}-(1-\\varphi )^{k}]}\n  \n且\n  \n    \n      \n        \n          F\n          \n            k\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            k\n            +\n            1\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            k\n            +\n            1\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{k+1}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k+1}-(1-\\varphi )^{k+1}]}\n  \n\n當\n  \n    \n      \n        n\n        =\n        k\n        +\n        2\n      \n    \n    {\\displaystyle n=k+2}\n  \n時\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  F\n                  \n                    k\n                    +\n                    2\n                  \n                \n              \n              \n                \n                =\n                \n                  F\n                  \n                    k\n                    +\n                    1\n                  \n                \n                +\n                \n                  F\n                  \n                    k\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    k\n                    +\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                    +\n                    1\n                  \n                \n                ]\n                +\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    k\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    k\n                    +\n                    1\n                  \n                \n                +\n                \n                  φ\n                  \n                    k\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                    +\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        k\n                      \n                    \n                    (\n                    \n                      \n                        φ\n                        +\n                        1\n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        k\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        )\n                        +\n                        1\n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        k\n                      \n                    \n                    (\n                    \n                      \n                        \n                          φ\n                          \n                            2\n                          \n                        \n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        k\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        \n                          )\n                          \n                            2\n                          \n                        \n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        k\n                        +\n                        2\n                      \n                    \n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        k\n                        +\n                        2\n                      \n                    \n                  \n                  }\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}F_{k+2}&=F_{k+1}+F_{k}\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k+1}-(1-\\varphi )^{k+1}]+{\\frac {1}{\\sqrt {5}}}[\\varphi ^{k}-(1-\\varphi )^{k}]\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k+1}+\\varphi ^{k}-(1-\\varphi )^{k+1}-(1-\\varphi )^{k}]\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{k}({\\color {brown}\\varphi +1})-(1-\\varphi )^{k}[{\\color {green}(1-\\varphi )+1}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{k}({\\color {brown}\\varphi ^{2}})-(1-\\varphi )^{k}[{\\color {green}(1-\\varphi )^{2}}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{k+2}-(1-\\varphi )^{k+2}\\right\\}\\\\\\end{aligned}}}\n  \n\n亦成立若\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為非正整數當\n  \n    \n      \n        n\n        =\n        0\n      \n    \n    {\\displaystyle n=0}\n  \n時，成立\n當\n  \n    \n      \n        n\n        =\n        −\n        1\n      \n    \n    {\\displaystyle n=-1}\n  \n時，\n  \n    \n      \n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          \n            \n              φ\n              \n                −\n                1\n              \n            \n          \n        \n        −\n        \n          \n            (\n            1\n            −\n            φ\n            \n              )\n              \n                −\n                1\n              \n            \n          \n        \n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        (\n        \n          \n            φ\n            −\n            1\n          \n        \n        )\n        −\n        (\n        \n          \n            −\n            φ\n          \n        \n        )\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        2\n        φ\n        −\n        1\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ×\n        \n          \n            5\n          \n        \n        =\n        1\n        =\n        \n          F\n          \n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\sqrt {5}}}[{\\color {brown}\\varphi ^{-1}}-{\\color {green}(1-\\varphi )^{-1}}]={\\frac {1}{\\sqrt {5}}}[({\\color {brown}\\varphi -1})-({\\color {green}-\\varphi })]={\\frac {1}{\\sqrt {5}}}[2\\varphi -1]={\\frac {1}{\\sqrt {5}}}\\times {\\sqrt {5}}=1=F_{-1}}\n  \n，成立\n設當\n  \n    \n      \n        n\n        =\n        −\n        k\n      \n    \n    {\\displaystyle n=-k}\n  \n及\n  \n    \n      \n        n\n        =\n        −\n        k\n        −\n        1\n      \n    \n    {\\displaystyle n=-k-1}\n  \n時皆成立，即\n  \n    \n      \n        \n          F\n          \n            −\n            k\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            −\n            k\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            −\n            k\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{-k}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k}-(1-\\varphi )^{-k}]}\n  \n且\n  \n    \n      \n        \n          F\n          \n            −\n            k\n            −\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            −\n            k\n            −\n            1\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            −\n            k\n            −\n            1\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{-k-1}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k-1}-(1-\\varphi )^{-k-1}]}\n  \n\n當\n  \n    \n      \n        n\n        =\n        −\n        k\n        −\n        2\n      \n    \n    {\\displaystyle n=-k-2}\n  \n時\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  F\n                  \n                    −\n                    k\n                    −\n                    2\n                  \n                \n              \n              \n                \n                =\n                \n                  F\n                  \n                    −\n                    k\n                  \n                \n                −\n                \n                  F\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    k\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                  \n                \n                ]\n                −\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    k\n                  \n                \n                −\n                \n                  φ\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                  \n                \n                +\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    (\n                    \n                      \n                        φ\n                        −\n                        1\n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        )\n                        −\n                        1\n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    (\n                    \n                      \n                        \n                          φ\n                          \n                            −\n                            1\n                          \n                        \n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        \n                          )\n                          \n                            −\n                            1\n                          \n                        \n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        −\n                        k\n                        −\n                        2\n                      \n                    \n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        −\n                        k\n                        −\n                        2\n                      \n                    \n                  \n                  }\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}F_{-k-2}&=F_{-k}-F_{-k-1}\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k}-(1-\\varphi )^{-k}]-{\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k-1}-(1-\\varphi )^{-k-1}]\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k}-\\varphi ^{-k-1}-(1-\\varphi )^{-k}+(1-\\varphi )^{-k-1}]\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{-k-1}({\\color {brown}\\varphi -1})-(1-\\varphi )^{-k-1}[{\\color {green}(1-\\varphi )-1}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{-k-1}({\\color {brown}\\varphi ^{-1}})-(1-\\varphi )^{-k-1}[{\\color {green}(1-\\varphi )^{-1}}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{-k-2}-(1-\\varphi )^{-k-2}\\right\\}\\\\\\end{aligned}}}\n  \n\n亦成立因此，根據數學歸納法原理，此表達式對於任意整數\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n皆成立\n線性代數解法[编辑]\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n              \n            \n            )\n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  1\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            )\n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    F\n                    \n                      n\n                    \n                  \n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}F_{n+2}\\\\F_{n+1}\\end{pmatrix}}={\\begin{pmatrix}1&1\\\\1&0\\end{pmatrix}}\\cdot {\\begin{pmatrix}F_{n+1}\\\\F_{n}\\end{pmatrix}}}\n  \n\n\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      2\n                    \n                  \n                \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n                \n                  \n                    F\n                    \n                      n\n                    \n                  \n                \n              \n            \n            )\n          \n        \n        =\n        \n          \n            \n              (\n              \n                \n                  \n                    1\n                  \n                  \n                    1\n                  \n                \n                \n                  \n                    1\n                  \n                  \n                    0\n                  \n                \n              \n              )\n            \n          \n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}F_{n+2}&F_{n+1}\\\\F_{n+1}&F_{n}\\end{pmatrix}}={\\begin{pmatrix}1&1\\\\1&0\\end{pmatrix}}^{n+1}}\n  \n\n構建一個矩陣方程[编辑]設\n  \n    \n      \n        \n          J\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle J_{n}}\n  \n為第\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n個月有生育能力的兔子數量，\n  \n    \n      \n        \n          A\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle A_{n}}\n  \n為這一月份的兔子數量。\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  0\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  1\n                \n              \n            \n            )\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                \n              \n              \n                A\n                \n                  n\n                \n              \n            \n            \n              )\n            \n          \n        \n        ,\n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}\\cdot {J_{n} \\choose A_{n}},}\n  \n上式表達了兩個月之間，兔子數目之間的關係。而要求的是，\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}}\n  \n的表達式。\n求矩陣的特徵值：\n  \n    \n      \n        λ\n      \n    \n    {\\displaystyle \\lambda }\n  \n[编辑]根据特征值的计算公式，我们需要算出来 \n  \n    \n      \n        \n          \n            |\n            \n              \n                \n                  −\n                  λ\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  1\n                  −\n                  λ\n                \n              \n            \n            |\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle {\\begin{vmatrix}-\\lambda &1\\\\1&1-\\lambda \\\\\\end{vmatrix}}=0}\n  \n 所对应的解。\n展开行列式有：\n  \n    \n      \n        −\n        λ\n        (\n        1\n        −\n        λ\n        )\n        −\n        1\n        ×\n        1\n        =\n        \n          λ\n          \n            2\n          \n        \n        −\n        λ\n        −\n        1\n      \n    \n    {\\displaystyle -\\lambda (1-\\lambda )-1\\times 1=\\lambda ^{2}-\\lambda -1}\n  \n。\n故當行列式的值為 0，解得 \n  \n    \n      \n        \n          λ\n          \n            1\n          \n        \n        =\n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        +\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle \\lambda _{1}={\\frac {1}{2}}(1+{\\sqrt {5}})}\n  \n 或 \n  \n    \n      \n        \n          λ\n          \n            2\n          \n        \n        =\n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        −\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle \\lambda _{2}={\\frac {1}{2}}(1-{\\sqrt {5}})}\n  \n。\n特徵向量[编辑]將兩個特徵值代入\n\n  \n    \n      \n        \n          (\n          \n            \n              \n                (\n                \n                  \n                    \n                      0\n                    \n                    \n                      1\n                    \n                  \n                  \n                    \n                      1\n                    \n                    \n                      1\n                    \n                  \n                \n                )\n              \n            \n            −\n            λ\n            ⋅\n            E\n          \n          )\n        \n        ⋅\n        \n          \n            \n              x\n              →\n            \n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle \\left({\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}-\\lambda \\cdot E\\right)\\cdot {\\vec {x}}=0}\n  \n\n求特徵向量\n  \n    \n      \n        \n          \n            \n              x\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {x}}}\n  \n得\n\n  \n    \n      \n        \n          \n            \n              \n                x\n                →\n              \n            \n          \n          \n            1\n          \n        \n      \n    \n    {\\displaystyle {\\vec {x}}_{1}}\n  \n=\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}}\n  \n\n\n  \n    \n      \n        \n          \n            \n              \n                x\n                →\n              \n            \n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\vec {x}}_{2}}\n  \n=\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}}\n  \n\n分解首向量[编辑]第一個月的情況是兔子一對，新生0對。\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  1\n                \n              \n              \n                A\n                \n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  0\n                \n              \n              \n                \n                  1\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {J_{1} \\choose A_{1}}={\\begin{pmatrix}0\\\\1\\end{pmatrix}}}\n  \n將它分解為用特徵向量表示。\n\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  0\n                \n              \n              \n                \n                  1\n                \n              \n            \n            )\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}0\\\\1\\end{pmatrix}}={\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}-{\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}}\n  \n  （4）用數學歸納法證明[编辑]從\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  0\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  1\n                \n              \n            \n            )\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                \n              \n              \n                A\n                \n                  n\n                \n              \n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}\\cdot {J_{n} \\choose A_{n}}}\n  \n=\n  \n    \n      \n        λ\n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                \n              \n              \n                A\n                \n                  n\n                \n              \n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle \\lambda \\cdot {J_{n} \\choose A_{n}}}\n  \n可得到\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            \n              (\n              \n                \n                  \n                    0\n                  \n                  \n                    1\n                  \n                \n                \n                  \n                    1\n                  \n                  \n                    1\n                  \n                \n              \n              )\n            \n          \n          \n            n\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  1\n                \n              \n              \n                A\n                \n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          λ\n          \n            n\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  1\n                \n              \n              \n                A\n                \n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}^{n}\\cdot {J_{1} \\choose A_{1}}=\\lambda ^{n}\\cdot {J_{1} \\choose A_{1}}}\n  \n  （5）化簡矩陣方程[编辑]將（4） 代入 （5）\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          λ\n          \n            n\n          \n        \n        ⋅\n        \n          [\n          \n            \n              \n                1\n                \n                  5\n                \n              \n            \n            ⋅\n            \n              \n                (\n                \n                  \n                    \n                      1\n                    \n                  \n                  \n                    \n                      \n                        \n                          1\n                          2\n                        \n                      \n                      (\n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                      )\n                    \n                  \n                \n                )\n              \n            \n            −\n            \n              \n                1\n                \n                  5\n                \n              \n            \n            ⋅\n            \n              \n                (\n                \n                  \n                    \n                      1\n                    \n                  \n                  \n                    \n                      \n                        \n                          1\n                          2\n                        \n                      \n                      (\n                      1\n                      −\n                      \n                        \n                          5\n                        \n                      \n                      )\n                    \n                  \n                \n                )\n              \n            \n          \n          ]\n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}=\\lambda ^{n}\\cdot \\left[{\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}-{\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}\\right]}\n  \n根據3\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            1\n          \n          \n            n\n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            2\n          \n          \n            n\n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{1}^{n}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}-{\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{2}^{n}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}}\n  \n求A的表達式[编辑]現在在6的基礎上，可以很快求出\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}}\n  \n的表達式，將兩個特徵值代入6中\n\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            1\n          \n          \n            n\n            +\n            1\n          \n        \n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            2\n          \n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}={\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{1}^{n+1}-{\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{2}^{n+1}}\n  \n\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        (\n        \n          λ\n          \n            1\n          \n          \n            n\n            +\n            1\n          \n        \n        −\n        \n          λ\n          \n            2\n          \n          \n            n\n            +\n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle A_{n+1}={\\frac {1}{\\sqrt {5}}}\\cdot (\\lambda _{1}^{n+1}-\\lambda _{2}^{n+1})}\n  \n\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          {\n          \n            \n              \n                [\n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  \n                    (\n                    \n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                    \n                    )\n                  \n                \n                ]\n              \n              \n                n\n                +\n                1\n              \n            \n            −\n            \n              \n                [\n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n                ]\n              \n              \n                n\n                +\n                1\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle A_{n+1}={\\frac {1}{\\sqrt {5}}}\\cdot \\left\\{\\left[{\\frac {1}{2}}\\left(1+{\\sqrt {5}}\\right)\\right]^{n+1}-\\left[{\\frac {1}{2}}(1-{\\sqrt {5}})\\right]^{n+1}\\right\\}}\n  \n（7）（7）即為\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}}\n  \n的表達式\n數論解法[编辑]實際上，如果將斐波那契數列的通項公式寫成\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        −\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        −\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle a_{n}-a_{n-1}-a_{n-2}=0}\n  \n，即可利用解二階線性齊次遞迴關係式的方法，寫出其特徵多項式\n  \n    \n      \n        \n          λ\n          \n            2\n          \n        \n        −\n        λ\n        −\n        1\n        =\n        0\n      \n    \n    {\\displaystyle \\lambda ^{2}-\\lambda -1=0}\n  \n（該式和表達斐波那契數列的矩陣的特徵多項式一致），然後解出\n  \n    \n      \n        \n          λ\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle \\lambda _{1}}\n  \n=\n  \n    \n      \n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        +\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\frac {1}{2}}(1+{\\sqrt {5}})}\n  \n，\n  \n    \n      \n        \n          λ\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\lambda _{2}}\n  \n=\n  \n    \n      \n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        −\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\frac {1}{2}}(1-{\\sqrt {5}})}\n  \n，即有\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            1\n          \n        \n        \n          λ\n          \n            1\n          \n          \n            n\n          \n        \n        +\n        \n          c\n          \n            2\n          \n        \n        \n          λ\n          \n            2\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle a_{n}=c_{1}\\lambda _{1}^{n}+c_{2}\\lambda _{2}^{n}}\n  \n，其中\n  \n    \n      \n        \n          c\n          \n            1\n          \n        \n        ,\n        \n          c\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle c_{1},c_{2}}\n  \n为常数。我们知道\n  \n    \n      \n        \n          a\n          \n            0\n          \n        \n        =\n        0\n        ,\n        \n          a\n          \n            1\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle a_{0}=0,a_{1}=1}\n  \n，因此\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  \n                    c\n                    \n                      1\n                    \n                  \n                  +\n                  \n                    c\n                    \n                      2\n                    \n                  \n                  =\n                  0\n                \n              \n              \n                \n                  \n                    \n                      \n                        \n                          c\n                          \n                            1\n                          \n                        \n                        (\n                        1\n                        +\n                        \n                          \n                            5\n                          \n                        \n                        )\n                      \n                      2\n                    \n                  \n                  +\n                  \n                    \n                      \n                        \n                          c\n                          \n                            2\n                          \n                        \n                        (\n                        1\n                        −\n                        \n                          \n                            5\n                          \n                        \n                        )\n                      \n                      2\n                    \n                  \n                  =\n                  1\n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}c_{1}+c_{2}=0\\\\{\\frac {c_{1}(1+{\\sqrt {5}})}{2}}+{\\frac {c_{2}(1-{\\sqrt {5}})}{2}}=1\\end{cases}}}\n  \n，解得\n  \n    \n      \n        \n          c\n          \n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ,\n        \n          c\n          \n            2\n          \n        \n        =\n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n      \n    \n    {\\displaystyle c_{1}={\\frac {1}{\\sqrt {5}}},c_{2}=-{\\frac {1}{\\sqrt {5}}}}\n  \n。\n組合數解法[编辑]\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle F_{n}=\\sum _{i=0}^{\\infty }{\\binom {n-i}{i}}}\n  \n[1]\n\n  \n    \n      \n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          F\n          \n            n\n          \n        \n        =\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                1\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        +\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        1\n        +\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              \n                i\n                −\n                1\n              \n            \n            \n              )\n            \n          \n        \n        +\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        1\n        +\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                +\n                1\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                +\n                1\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle F_{n-1}+F_{n}=\\sum _{i=0}^{\\infty }{\\binom {n-1-i}{i}}+\\sum _{i=0}^{\\infty }{\\binom {n-i}{i}}=1+\\sum _{i=1}^{\\infty }{\\binom {n-i}{i-1}}+\\sum _{i=1}^{\\infty }{\\binom {n-i}{i}}=1+\\sum _{i=1}^{\\infty }{\\binom {n+1-i}{i}}=\\sum _{i=0}^{\\infty }{\\binom {n+1-i}{i}}=F_{n+1}}\n  \n黃金比例恆等式解法[编辑]設\n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n為黃金比例\n  \n    \n      \n        \n          \n            \n              1\n              +\n              \n                \n                  5\n                \n              \n            \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1+{\\sqrt {5}}}{2}}}\n  \n，則有恆等式\n  \n    \n      \n        \n          φ\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        φ\n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\varphi ^{n}=F_{n-1}+\\varphi F_{n}}\n  \n與\n  \n    \n      \n        (\n        1\n        −\n        φ\n        \n          )\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        −\n        φ\n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle (1-\\varphi )^{n}=F_{n+1}-\\varphi F_{n}}\n  \n，其中\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為任意整數[註 1]，則\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  φ\n                  \n                    n\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    n\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  F\n                  \n                    n\n                    −\n                    1\n                  \n                \n                +\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n                )\n                −\n                (\n                \n                  F\n                  \n                    n\n                    +\n                    1\n                  \n                \n                −\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n                )\n              \n            \n            \n              \n              \n                \n                =\n                (\n                \n                  F\n                  \n                    n\n                    −\n                    1\n                  \n                \n                −\n                \n                  F\n                  \n                    n\n                    +\n                    1\n                  \n                \n                )\n                +\n                2\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                −\n                \n                  F\n                  \n                    n\n                  \n                \n                +\n                2\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  F\n                  \n                    n\n                  \n                \n                (\n                2\n                φ\n                −\n                1\n                )\n              \n            \n            \n              \n              \n                \n                =\n                \n                  F\n                  \n                    n\n                  \n                \n                ×\n                \n                  \n                    5\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}\\varphi ^{n}-(1-\\varphi )^{n}&=(F_{n-1}+\\varphi F_{n})-(F_{n+1}-\\varphi F_{n})\\\\&=(F_{n-1}-F_{n+1})+2\\varphi F_{n}\\\\&=-F_{n}+2\\varphi F_{n}\\\\&=F_{n}(2\\varphi -1)\\\\&=F_{n}\\times {\\sqrt {5}}\\\\\\end{aligned}}}\n  \n\n因此得到\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n的一般式：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  F\n                  \n                    n\n                  \n                \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    n\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    n\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  [\n                  \n                    (\n                    \n                      \n                        \n                          1\n                          +\n                          \n                            \n                              5\n                            \n                          \n                        \n                        2\n                      \n                    \n                    \n                      )\n                      \n                        n\n                      \n                    \n                    −\n                    (\n                    \n                      \n                        \n                          1\n                          −\n                          \n                            \n                              5\n                            \n                          \n                        \n                        2\n                      \n                    \n                    \n                      )\n                      \n                        n\n                      \n                    \n                  \n                  ]\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}F_{n}&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{n}-(1-\\varphi )^{n}]\\\\&={\\frac {1}{\\sqrt {5}}}\\left[({\\frac {1+{\\sqrt {5}}}{2}})^{n}-({\\frac {1-{\\sqrt {5}}}{2}})^{n}\\right]\\\\\\end{aligned}}}\n  \n\n此一般式對任意整數\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n成立\n近似值[编辑]當\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為足夠大的正整數時，则\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        ≈\n        \n          \n            1\n            \n              5\n            \n          \n        \n        \n          φ\n          \n            n\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  1\n                  2\n                \n              \n              \n                (\n                \n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                \n                )\n              \n            \n            ]\n          \n          \n            n\n          \n        \n        ≈\n        0.4472135955\n        ⋅\n        \n          1.61803398875\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}\\approx {\\frac {1}{\\sqrt {5}}}\\varphi ^{n}={\\frac {1}{\\sqrt {5}}}\\cdot \\left[{\\frac {1}{2}}\\left(1+{\\sqrt {5}}\\right)\\right]^{n}\\approx 0.4472135955\\cdot 1.61803398875^{n}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            −\n            n\n          \n        \n        ≈\n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        (\n        1\n        −\n        φ\n        \n          )\n          \n            −\n            n\n          \n        \n        =\n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  1\n                  2\n                \n              \n              \n                (\n                \n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                \n                )\n              \n            \n            ]\n          \n          \n            −\n            n\n          \n        \n        ≈\n        −\n        0.4472135955\n        ⋅\n        (\n        −\n        0.61803398875\n        \n          )\n          \n            −\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{-n}\\approx -{\\frac {1}{\\sqrt {5}}}(1-\\varphi )^{-n}=-{\\frac {1}{\\sqrt {5}}}\\cdot \\left[{\\frac {1}{2}}\\left(1-{\\sqrt {5}}\\right)\\right]^{-n}\\approx -0.4472135955\\cdot (-0.61803398875)^{-n}}\n  \n用計算機求解[编辑]可通過編程觀察斐波那契數列。分為兩類問題，一種已知數列中的某一項，求序數。第二種是已知序數，求該項的值。\n可通過遞歸遞推的算法解決此兩個問題。\n事實上當\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n相當巨大的時候，O（n）的遞推/遞歸非常慢……這時候要用到矩陣快速幂這一技巧，可以使遞迴加速到O(logn)。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式", "Tag": "算法设计"}
{"Answer": "已知\n\n  \n    \n      \n        \n          a\n          \n            1\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle a_{1}=1}\n  \n\n\n  \n    \n      \n        \n          a\n          \n            2\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle a_{2}=1}\n  \n\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{n}=a_{n-1}+a_{n-2}}\n  \n（n≥3）首先構建等比數列[编辑]設\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        =\n        β\n        (\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle a_{n}+\\alpha a_{n-1}=\\beta (a_{n-1}+\\alpha a_{n-2})}\n  \n化簡得\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        (\n        β\n        −\n        α\n        )\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        α\n        β\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{n}=(\\beta -\\alpha )a_{n-1}+\\alpha \\beta a_{n-2}}\n  \n\n比較係數可得：\n\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  β\n                  −\n                  α\n                  =\n                  1\n                \n              \n              \n                \n                  α\n                  β\n                  =\n                  1\n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}\\beta -\\alpha =1\\\\\\alpha \\beta =1\\end{cases}}}\n  \n\n不妨設\n  \n    \n      \n        β\n        >\n        0\n        ,\n        α\n        >\n        0\n      \n    \n    {\\displaystyle \\beta >0,\\alpha >0}\n  \n\n解得：\n\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  α\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          −\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n              \n                \n                  β\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          +\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}\\alpha ={\\dfrac {{\\sqrt {5}}-1}{2}}\\\\\\beta ={\\dfrac {{\\sqrt {5}}+1}{2}}\\end{cases}}}\n  \n\n\n又因为有\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        =\n        β\n        (\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        α\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle a_{n}+\\alpha a_{n-1}=\\beta (a_{n-1}+\\alpha a_{n-2})}\n  \n，\n即\n  \n    \n      \n        \n          {\n          \n            \n              a\n              \n                n\n              \n            \n            +\n            α\n            \n              a\n              \n                n\n                −\n                1\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{a_{n}+\\alpha a_{n-1}\\right\\}}\n  \n為等比數列。\n求出數列\n  \n    \n      \n        \n          {\n          \n            \n              a\n              \n                n\n              \n            \n            +\n            α\n            \n              a\n              \n                n\n                −\n                1\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{a_{n}+\\alpha a_{n-1}\\right\\}}\n  \n[编辑]由以上可得：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  a\n                  \n                    n\n                    +\n                    1\n                  \n                \n                +\n                α\n                \n                  a\n                  \n                    n\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  a\n                  \n                    2\n                  \n                \n                +\n                α\n                \n                  a\n                  \n                    1\n                  \n                \n                )\n                \n                  β\n                  \n                    n\n                    −\n                    1\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                (\n                1\n                +\n                α\n                )\n                \n                  β\n                  \n                    n\n                    −\n                    1\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  β\n                  \n                    n\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}a_{n+1}+\\alpha a_{n}&=(a_{2}+\\alpha a_{1})\\beta ^{n-1}\\\\&=(1+\\alpha )\\beta ^{n-1}\\\\&=\\beta ^{n}\\\\\\end{aligned}}}\n  \n\n變形得：\n\n  \n    \n      \n        \n          \n            \n              a\n              \n                n\n                +\n                1\n              \n            \n            \n              β\n              \n                n\n                +\n                1\n              \n            \n          \n        \n        +\n        \n          \n            α\n            β\n          \n        \n        ⋅\n        \n          \n            \n              a\n              \n                n\n              \n            \n            \n              β\n              \n                n\n              \n            \n          \n        \n        =\n        \n          \n            1\n            β\n          \n        \n      \n    \n    {\\displaystyle {\\frac {a_{n+1}}{\\beta ^{n+1}}}+{\\frac {\\alpha }{\\beta }}\\cdot {\\frac {a_{n}}{\\beta ^{n}}}={\\frac {1}{\\beta }}}\n  \n。\n令\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          \n            \n              a\n              \n                n\n              \n            \n            \n              β\n              \n                n\n              \n            \n          \n        \n      \n    \n    {\\displaystyle b_{n}={\\frac {a_{n}}{\\beta ^{n}}}}\n  \n\n求數列\n  \n    \n      \n        \n          {\n          \n            \n              b\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{{b_{n}}\\right\\}}\n  \n進而得到\n  \n    \n      \n        \n          {\n          \n            a\n            \n              n\n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{a_{n}\\right\\}}\n  \n[编辑]\n  \n    \n      \n        \n          b\n          \n            n\n            +\n            1\n          \n        \n        +\n        \n          \n            α\n            β\n          \n        \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          \n            1\n            β\n          \n        \n      \n    \n    {\\displaystyle b_{n+1}+{\\frac {\\alpha }{\\beta }}b_{n}={\\frac {1}{\\beta }}}\n  \n\n設\n  \n    \n      \n        \n          b\n          \n            n\n            +\n            1\n          \n        \n        +\n        λ\n        =\n        −\n        \n          \n            α\n            β\n          \n        \n        (\n        \n          b\n          \n            n\n          \n        \n        +\n        λ\n        )\n      \n    \n    {\\displaystyle b_{n+1}+\\lambda =-{\\frac {\\alpha }{\\beta }}(b_{n}+\\lambda )}\n  \n，解得\n  \n    \n      \n        λ\n        =\n        −\n        \n          \n            1\n            \n              α\n              +\n              β\n            \n          \n        \n      \n    \n    {\\displaystyle \\lambda =-{\\frac {1}{\\alpha +\\beta }}}\n  \n。\n故數列\n  \n    \n      \n        \n          {\n          \n            \n              b\n              \n                n\n              \n            \n            +\n            λ\n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{b_{n}+\\lambda \\right\\}}\n  \n為等比數列\n即\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        +\n        λ\n        =\n        \n          \n            (\n            \n              −\n              \n                \n                  α\n                  β\n                \n              \n            \n            )\n          \n          \n            n\n            −\n            1\n          \n        \n        \n          (\n          \n            \n              b\n              \n                1\n              \n            \n            +\n            λ\n          \n          )\n        \n      \n    \n    {\\displaystyle b_{n}+\\lambda =\\left(-{\\frac {\\alpha }{\\beta }}\\right)^{n-1}\\left(b_{1}+\\lambda \\right)}\n  \n。而\n  \n    \n      \n        \n          b\n          \n            1\n          \n        \n        =\n        \n          \n            \n              a\n              \n                1\n              \n            \n            β\n          \n        \n        =\n        \n          \n            1\n            β\n          \n        \n      \n    \n    {\\displaystyle b_{1}={\\frac {a_{1}}{\\beta }}={\\frac {1}{\\beta }}}\n  \n，\n故有\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        +\n        λ\n        =\n        \n          \n            (\n            \n              −\n              \n                \n                  α\n                  β\n                \n              \n            \n            )\n          \n          \n            n\n            −\n            1\n          \n        \n        \n          (\n          \n            \n              \n                1\n                β\n              \n            \n            +\n            λ\n          \n          )\n        \n      \n    \n    {\\displaystyle b_{n}+\\lambda =\\left(-{\\frac {\\alpha }{\\beta }}\\right)^{n-1}\\left({\\frac {1}{\\beta }}+\\lambda \\right)}\n  \n\n又有\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  α\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          −\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n              \n                \n                  β\n                  =\n                  \n                    \n                      \n                        \n                          \n                            \n                              5\n                            \n                          \n                          +\n                          1\n                        \n                        2\n                      \n                    \n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}\\alpha ={\\dfrac {{\\sqrt {5}}-1}{2}}\\\\\\beta ={\\dfrac {{\\sqrt {5}}+1}{2}}\\end{cases}}}\n  \n\n和\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          \n            \n              a\n              \n                n\n              \n            \n            \n              β\n              \n                n\n              \n            \n          \n        \n      \n    \n    {\\displaystyle b_{n}={\\frac {a_{n}}{\\beta ^{n}}}}\n  \n\n可得\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          \n            \n              5\n            \n            5\n          \n        \n        ⋅\n        \n          [\n          \n            \n              \n                (\n                \n                  \n                    \n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n            −\n            \n              \n                (\n                \n                  \n                    \n                      1\n                      −\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n          \n          ]\n        \n      \n    \n    {\\displaystyle a_{n}={\\frac {\\sqrt {5}}{5}}\\cdot \\left[\\left({\\frac {1+{\\sqrt {5}}}{2}}\\right)^{n}-\\left({\\frac {1-{\\sqrt {5}}}{2}}\\right)^{n}\\right]}\n  \n\n得出\n  \n    \n      \n        \n          \n            a\n            \n              n\n            \n          \n        \n      \n    \n    {\\displaystyle {a_{n}}}\n  \n表達式\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          \n            \n              5\n            \n            5\n          \n        \n        ⋅\n        \n          [\n          \n            \n              \n                (\n                \n                  \n                    \n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n            −\n            \n              \n                (\n                \n                  \n                    \n                      1\n                      −\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n          \n          ]\n        \n      \n    \n    {\\displaystyle a_{n}={\\frac {\\sqrt {5}}{5}}\\cdot \\left[\\left({\\frac {1+{\\sqrt {5}}}{2}}\\right)^{n}-\\left({\\frac {1-{\\sqrt {5}}}{2}}\\right)^{n}\\right]}\n  \n\n用數學歸納法證明表達式[编辑]證明\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            n\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            n\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{n}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{n}-(1-\\varphi )^{n}]}\n  \n，其中\n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n為黃金比例\n  \n    \n      \n        \n          \n            \n              1\n              +\n              \n                \n                  5\n                \n              \n            \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1+{\\sqrt {5}}}{2}}}\n  \n，\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為任意整數若\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為非負整數當\n  \n    \n      \n        n\n        =\n        0\n      \n    \n    {\\displaystyle n=0}\n  \n時，\n  \n    \n      \n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            0\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            0\n          \n        \n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        1\n        −\n        1\n        ]\n        =\n        0\n        =\n        \n          F\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\sqrt {5}}}[\\varphi ^{0}-(1-\\varphi )^{0}]={\\frac {1}{\\sqrt {5}}}[1-1]=0=F_{0}}\n  \n，成立\n當\n  \n    \n      \n        n\n        =\n        1\n      \n    \n    {\\displaystyle n=1}\n  \n時，\n  \n    \n      \n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            1\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            1\n          \n        \n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        φ\n        −\n        1\n        +\n        φ\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        2\n        φ\n        −\n        1\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ×\n        \n          \n            5\n          \n        \n        =\n        1\n        =\n        \n          F\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\sqrt {5}}}[\\varphi ^{1}-(1-\\varphi )^{1}]={\\frac {1}{\\sqrt {5}}}[\\varphi -1+\\varphi ]={\\frac {1}{\\sqrt {5}}}[2\\varphi -1]={\\frac {1}{\\sqrt {5}}}\\times {\\sqrt {5}}=1=F_{1}}\n  \n，成立\n設當\n  \n    \n      \n        n\n        =\n        k\n      \n    \n    {\\displaystyle n=k}\n  \n及\n  \n    \n      \n        n\n        =\n        k\n        +\n        1\n      \n    \n    {\\displaystyle n=k+1}\n  \n時皆成立，即\n  \n    \n      \n        \n          F\n          \n            k\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            k\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            k\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{k}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k}-(1-\\varphi )^{k}]}\n  \n且\n  \n    \n      \n        \n          F\n          \n            k\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            k\n            +\n            1\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            k\n            +\n            1\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{k+1}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k+1}-(1-\\varphi )^{k+1}]}\n  \n\n當\n  \n    \n      \n        n\n        =\n        k\n        +\n        2\n      \n    \n    {\\displaystyle n=k+2}\n  \n時\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  F\n                  \n                    k\n                    +\n                    2\n                  \n                \n              \n              \n                \n                =\n                \n                  F\n                  \n                    k\n                    +\n                    1\n                  \n                \n                +\n                \n                  F\n                  \n                    k\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    k\n                    +\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                    +\n                    1\n                  \n                \n                ]\n                +\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    k\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    k\n                    +\n                    1\n                  \n                \n                +\n                \n                  φ\n                  \n                    k\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                    +\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    k\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        k\n                      \n                    \n                    (\n                    \n                      \n                        φ\n                        +\n                        1\n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        k\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        )\n                        +\n                        1\n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        k\n                      \n                    \n                    (\n                    \n                      \n                        \n                          φ\n                          \n                            2\n                          \n                        \n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        k\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        \n                          )\n                          \n                            2\n                          \n                        \n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        k\n                        +\n                        2\n                      \n                    \n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        k\n                        +\n                        2\n                      \n                    \n                  \n                  }\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}F_{k+2}&=F_{k+1}+F_{k}\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k+1}-(1-\\varphi )^{k+1}]+{\\frac {1}{\\sqrt {5}}}[\\varphi ^{k}-(1-\\varphi )^{k}]\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{k+1}+\\varphi ^{k}-(1-\\varphi )^{k+1}-(1-\\varphi )^{k}]\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{k}({\\color {brown}\\varphi +1})-(1-\\varphi )^{k}[{\\color {green}(1-\\varphi )+1}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{k}({\\color {brown}\\varphi ^{2}})-(1-\\varphi )^{k}[{\\color {green}(1-\\varphi )^{2}}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{k+2}-(1-\\varphi )^{k+2}\\right\\}\\\\\\end{aligned}}}\n  \n\n亦成立若\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為非正整數當\n  \n    \n      \n        n\n        =\n        0\n      \n    \n    {\\displaystyle n=0}\n  \n時，成立\n當\n  \n    \n      \n        n\n        =\n        −\n        1\n      \n    \n    {\\displaystyle n=-1}\n  \n時，\n  \n    \n      \n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          \n            \n              φ\n              \n                −\n                1\n              \n            \n          \n        \n        −\n        \n          \n            (\n            1\n            −\n            φ\n            \n              )\n              \n                −\n                1\n              \n            \n          \n        \n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        (\n        \n          \n            φ\n            −\n            1\n          \n        \n        )\n        −\n        (\n        \n          \n            −\n            φ\n          \n        \n        )\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        2\n        φ\n        −\n        1\n        ]\n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ×\n        \n          \n            5\n          \n        \n        =\n        1\n        =\n        \n          F\n          \n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\sqrt {5}}}[{\\color {brown}\\varphi ^{-1}}-{\\color {green}(1-\\varphi )^{-1}}]={\\frac {1}{\\sqrt {5}}}[({\\color {brown}\\varphi -1})-({\\color {green}-\\varphi })]={\\frac {1}{\\sqrt {5}}}[2\\varphi -1]={\\frac {1}{\\sqrt {5}}}\\times {\\sqrt {5}}=1=F_{-1}}\n  \n，成立\n設當\n  \n    \n      \n        n\n        =\n        −\n        k\n      \n    \n    {\\displaystyle n=-k}\n  \n及\n  \n    \n      \n        n\n        =\n        −\n        k\n        −\n        1\n      \n    \n    {\\displaystyle n=-k-1}\n  \n時皆成立，即\n  \n    \n      \n        \n          F\n          \n            −\n            k\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            −\n            k\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            −\n            k\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{-k}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k}-(1-\\varphi )^{-k}]}\n  \n且\n  \n    \n      \n        \n          F\n          \n            −\n            k\n            −\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        [\n        \n          φ\n          \n            −\n            k\n            −\n            1\n          \n        \n        −\n        (\n        1\n        −\n        φ\n        \n          )\n          \n            −\n            k\n            −\n            1\n          \n        \n        ]\n      \n    \n    {\\displaystyle F_{-k-1}={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k-1}-(1-\\varphi )^{-k-1}]}\n  \n\n當\n  \n    \n      \n        n\n        =\n        −\n        k\n        −\n        2\n      \n    \n    {\\displaystyle n=-k-2}\n  \n時\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  F\n                  \n                    −\n                    k\n                    −\n                    2\n                  \n                \n              \n              \n                \n                =\n                \n                  F\n                  \n                    −\n                    k\n                  \n                \n                −\n                \n                  F\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    k\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                  \n                \n                ]\n                −\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    k\n                  \n                \n                −\n                \n                  φ\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                  \n                \n                +\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    k\n                    −\n                    1\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    (\n                    \n                      \n                        φ\n                        −\n                        1\n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        )\n                        −\n                        1\n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    (\n                    \n                      \n                        \n                          φ\n                          \n                            −\n                            1\n                          \n                        \n                      \n                    \n                    )\n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        −\n                        k\n                        −\n                        1\n                      \n                    \n                    [\n                    \n                      \n                        (\n                        1\n                        −\n                        φ\n                        \n                          )\n                          \n                            −\n                            1\n                          \n                        \n                      \n                    \n                    ]\n                  \n                  }\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  {\n                  \n                    \n                      φ\n                      \n                        −\n                        k\n                        −\n                        2\n                      \n                    \n                    −\n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        −\n                        k\n                        −\n                        2\n                      \n                    \n                  \n                  }\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}F_{-k-2}&=F_{-k}-F_{-k-1}\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k}-(1-\\varphi )^{-k}]-{\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k-1}-(1-\\varphi )^{-k-1}]\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{-k}-\\varphi ^{-k-1}-(1-\\varphi )^{-k}+(1-\\varphi )^{-k-1}]\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{-k-1}({\\color {brown}\\varphi -1})-(1-\\varphi )^{-k-1}[{\\color {green}(1-\\varphi )-1}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{-k-1}({\\color {brown}\\varphi ^{-1}})-(1-\\varphi )^{-k-1}[{\\color {green}(1-\\varphi )^{-1}}]\\right\\}\\\\&={\\frac {1}{\\sqrt {5}}}\\left\\{\\varphi ^{-k-2}-(1-\\varphi )^{-k-2}\\right\\}\\\\\\end{aligned}}}\n  \n\n亦成立因此，根據數學歸納法原理，此表達式對於任意整數\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n皆成立\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式的初等代數解法", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n              \n            \n            )\n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  1\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            )\n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    F\n                    \n                      n\n                    \n                  \n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}F_{n+2}\\\\F_{n+1}\\end{pmatrix}}={\\begin{pmatrix}1&1\\\\1&0\\end{pmatrix}}\\cdot {\\begin{pmatrix}F_{n+1}\\\\F_{n}\\end{pmatrix}}}\n  \n\n\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      2\n                    \n                  \n                \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    F\n                    \n                      n\n                      +\n                      1\n                    \n                  \n                \n                \n                  \n                    F\n                    \n                      n\n                    \n                  \n                \n              \n            \n            )\n          \n        \n        =\n        \n          \n            \n              (\n              \n                \n                  \n                    1\n                  \n                  \n                    1\n                  \n                \n                \n                  \n                    1\n                  \n                  \n                    0\n                  \n                \n              \n              )\n            \n          \n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}F_{n+2}&F_{n+1}\\\\F_{n+1}&F_{n}\\end{pmatrix}}={\\begin{pmatrix}1&1\\\\1&0\\end{pmatrix}}^{n+1}}\n  \n\n構建一個矩陣方程[编辑]設\n  \n    \n      \n        \n          J\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle J_{n}}\n  \n為第\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n個月有生育能力的兔子數量，\n  \n    \n      \n        \n          A\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle A_{n}}\n  \n為這一月份的兔子數量。\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  0\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  1\n                \n              \n            \n            )\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                \n              \n              \n                A\n                \n                  n\n                \n              \n            \n            \n              )\n            \n          \n        \n        ,\n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}\\cdot {J_{n} \\choose A_{n}},}\n  \n上式表達了兩個月之間，兔子數目之間的關係。而要求的是，\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}}\n  \n的表達式。\n求矩陣的特徵值：\n  \n    \n      \n        λ\n      \n    \n    {\\displaystyle \\lambda }\n  \n[编辑]根据特征值的计算公式，我们需要算出来 \n  \n    \n      \n        \n          \n            |\n            \n              \n                \n                  −\n                  λ\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  1\n                  −\n                  λ\n                \n              \n            \n            |\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle {\\begin{vmatrix}-\\lambda &1\\\\1&1-\\lambda \\\\\\end{vmatrix}}=0}\n  \n 所对应的解。\n展开行列式有：\n  \n    \n      \n        −\n        λ\n        (\n        1\n        −\n        λ\n        )\n        −\n        1\n        ×\n        1\n        =\n        \n          λ\n          \n            2\n          \n        \n        −\n        λ\n        −\n        1\n      \n    \n    {\\displaystyle -\\lambda (1-\\lambda )-1\\times 1=\\lambda ^{2}-\\lambda -1}\n  \n。\n故當行列式的值為 0，解得 \n  \n    \n      \n        \n          λ\n          \n            1\n          \n        \n        =\n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        +\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle \\lambda _{1}={\\frac {1}{2}}(1+{\\sqrt {5}})}\n  \n 或 \n  \n    \n      \n        \n          λ\n          \n            2\n          \n        \n        =\n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        −\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle \\lambda _{2}={\\frac {1}{2}}(1-{\\sqrt {5}})}\n  \n。\n特徵向量[编辑]將兩個特徵值代入\n\n  \n    \n      \n        \n          (\n          \n            \n              \n                (\n                \n                  \n                    \n                      0\n                    \n                    \n                      1\n                    \n                  \n                  \n                    \n                      1\n                    \n                    \n                      1\n                    \n                  \n                \n                )\n              \n            \n            −\n            λ\n            ⋅\n            E\n          \n          )\n        \n        ⋅\n        \n          \n            \n              x\n              →\n            \n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle \\left({\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}-\\lambda \\cdot E\\right)\\cdot {\\vec {x}}=0}\n  \n\n求特徵向量\n  \n    \n      \n        \n          \n            \n              x\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {x}}}\n  \n得\n\n  \n    \n      \n        \n          \n            \n              \n                x\n                →\n              \n            \n          \n          \n            1\n          \n        \n      \n    \n    {\\displaystyle {\\vec {x}}_{1}}\n  \n=\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}}\n  \n\n\n  \n    \n      \n        \n          \n            \n              \n                x\n                →\n              \n            \n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\vec {x}}_{2}}\n  \n=\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}}\n  \n\n分解首向量[编辑]第一個月的情況是兔子一對，新生0對。\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  1\n                \n              \n              \n                A\n                \n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  0\n                \n              \n              \n                \n                  1\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {J_{1} \\choose A_{1}}={\\begin{pmatrix}0\\\\1\\end{pmatrix}}}\n  \n將它分解為用特徵向量表示。\n\n  \n    \n      \n        \n          \n            (\n            \n              \n                \n                  0\n                \n              \n              \n                \n                  1\n                \n              \n            \n            )\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {\\begin{pmatrix}0\\\\1\\end{pmatrix}}={\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}-{\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}}\n  \n  （4）用數學歸納法證明[编辑]從\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            (\n            \n              \n                \n                  0\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  1\n                \n              \n            \n            )\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                \n              \n              \n                A\n                \n                  n\n                \n              \n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}\\cdot {J_{n} \\choose A_{n}}}\n  \n=\n  \n    \n      \n        λ\n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                \n              \n              \n                A\n                \n                  n\n                \n              \n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle \\lambda \\cdot {J_{n} \\choose A_{n}}}\n  \n可得到\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            \n              (\n              \n                \n                  \n                    0\n                  \n                  \n                    1\n                  \n                \n                \n                  \n                    1\n                  \n                  \n                    1\n                  \n                \n              \n              )\n            \n          \n          \n            n\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  1\n                \n              \n              \n                A\n                \n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          λ\n          \n            n\n          \n        \n        ⋅\n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  1\n                \n              \n              \n                A\n                \n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\begin{pmatrix}0&1\\\\1&1\\end{pmatrix}}^{n}\\cdot {J_{1} \\choose A_{1}}=\\lambda ^{n}\\cdot {J_{1} \\choose A_{1}}}\n  \n  （5）化簡矩陣方程[编辑]將（4） 代入 （5）\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          λ\n          \n            n\n          \n        \n        ⋅\n        \n          [\n          \n            \n              \n                1\n                \n                  5\n                \n              \n            \n            ⋅\n            \n              \n                (\n                \n                  \n                    \n                      1\n                    \n                  \n                  \n                    \n                      \n                        \n                          1\n                          2\n                        \n                      \n                      (\n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                      )\n                    \n                  \n                \n                )\n              \n            \n            −\n            \n              \n                1\n                \n                  5\n                \n              \n            \n            ⋅\n            \n              \n                (\n                \n                  \n                    \n                      1\n                    \n                  \n                  \n                    \n                      \n                        \n                          1\n                          2\n                        \n                      \n                      (\n                      1\n                      −\n                      \n                        \n                          5\n                        \n                      \n                      )\n                    \n                  \n                \n                )\n              \n            \n          \n          ]\n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}=\\lambda ^{n}\\cdot \\left[{\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}-{\\frac {1}{\\sqrt {5}}}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}\\right]}\n  \n根據3\n\n  \n    \n      \n        \n          \n            \n              (\n            \n            \n              \n                J\n                \n                  n\n                  +\n                  1\n                \n              \n              \n                A\n                \n                  n\n                  +\n                  1\n                \n              \n            \n            \n              )\n            \n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            1\n          \n          \n            n\n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            2\n          \n          \n            n\n          \n        \n        ⋅\n        \n          \n            (\n            \n              \n                \n                  1\n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle {J_{n+1} \\choose A_{n+1}}={\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{1}^{n}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1+{\\sqrt {5}})\\end{pmatrix}}-{\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{2}^{n}\\cdot {\\begin{pmatrix}1\\\\{\\frac {1}{2}}(1-{\\sqrt {5}})\\end{pmatrix}}}\n  \n求A的表達式[编辑]現在在6的基礎上，可以很快求出\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}}\n  \n的表達式，將兩個特徵值代入6中\n\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            1\n          \n          \n            n\n            +\n            1\n          \n        \n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          λ\n          \n            2\n          \n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}={\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{1}^{n+1}-{\\frac {1}{\\sqrt {5}}}\\cdot \\lambda _{2}^{n+1}}\n  \n\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        (\n        \n          λ\n          \n            1\n          \n          \n            n\n            +\n            1\n          \n        \n        −\n        \n          λ\n          \n            2\n          \n          \n            n\n            +\n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle A_{n+1}={\\frac {1}{\\sqrt {5}}}\\cdot (\\lambda _{1}^{n+1}-\\lambda _{2}^{n+1})}\n  \n\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          {\n          \n            \n              \n                [\n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  \n                    (\n                    \n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                    \n                    )\n                  \n                \n                ]\n              \n              \n                n\n                +\n                1\n              \n            \n            −\n            \n              \n                [\n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                  )\n                \n                ]\n              \n              \n                n\n                +\n                1\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle A_{n+1}={\\frac {1}{\\sqrt {5}}}\\cdot \\left\\{\\left[{\\frac {1}{2}}\\left(1+{\\sqrt {5}}\\right)\\right]^{n+1}-\\left[{\\frac {1}{2}}(1-{\\sqrt {5}})\\right]^{n+1}\\right\\}}\n  \n（7）（7）即為\n  \n    \n      \n        \n          A\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle A_{n+1}}\n  \n的表達式\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式的線性代數解法", "Tag": "算法设计"}
{"Answer": "實際上，如果將斐波那契數列的通項公式寫成\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        −\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        −\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle a_{n}-a_{n-1}-a_{n-2}=0}\n  \n，即可利用解二階線性齊次遞迴關係式的方法，寫出其特徵多項式\n  \n    \n      \n        \n          λ\n          \n            2\n          \n        \n        −\n        λ\n        −\n        1\n        =\n        0\n      \n    \n    {\\displaystyle \\lambda ^{2}-\\lambda -1=0}\n  \n（該式和表達斐波那契數列的矩陣的特徵多項式一致），然後解出\n  \n    \n      \n        \n          λ\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle \\lambda _{1}}\n  \n=\n  \n    \n      \n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        +\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\frac {1}{2}}(1+{\\sqrt {5}})}\n  \n，\n  \n    \n      \n        \n          λ\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\lambda _{2}}\n  \n=\n  \n    \n      \n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        −\n        \n          \n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\frac {1}{2}}(1-{\\sqrt {5}})}\n  \n，即有\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            1\n          \n        \n        \n          λ\n          \n            1\n          \n          \n            n\n          \n        \n        +\n        \n          c\n          \n            2\n          \n        \n        \n          λ\n          \n            2\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle a_{n}=c_{1}\\lambda _{1}^{n}+c_{2}\\lambda _{2}^{n}}\n  \n，其中\n  \n    \n      \n        \n          c\n          \n            1\n          \n        \n        ,\n        \n          c\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle c_{1},c_{2}}\n  \n为常数。我们知道\n  \n    \n      \n        \n          a\n          \n            0\n          \n        \n        =\n        0\n        ,\n        \n          a\n          \n            1\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle a_{0}=0,a_{1}=1}\n  \n，因此\n  \n    \n      \n        \n          \n            {\n            \n              \n                \n                  \n                    c\n                    \n                      1\n                    \n                  \n                  +\n                  \n                    c\n                    \n                      2\n                    \n                  \n                  =\n                  0\n                \n              \n              \n                \n                  \n                    \n                      \n                        \n                          c\n                          \n                            1\n                          \n                        \n                        (\n                        1\n                        +\n                        \n                          \n                            5\n                          \n                        \n                        )\n                      \n                      2\n                    \n                  \n                  +\n                  \n                    \n                      \n                        \n                          c\n                          \n                            2\n                          \n                        \n                        (\n                        1\n                        −\n                        \n                          \n                            5\n                          \n                        \n                        )\n                      \n                      2\n                    \n                  \n                  =\n                  1\n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{cases}c_{1}+c_{2}=0\\\\{\\frac {c_{1}(1+{\\sqrt {5}})}{2}}+{\\frac {c_{2}(1-{\\sqrt {5}})}{2}}=1\\end{cases}}}\n  \n，解得\n  \n    \n      \n        \n          c\n          \n            1\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ,\n        \n          c\n          \n            2\n          \n        \n        =\n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n      \n    \n    {\\displaystyle c_{1}={\\frac {1}{\\sqrt {5}}},c_{2}=-{\\frac {1}{\\sqrt {5}}}}\n  \n。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式的數論解法", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle F_{n}=\\sum _{i=0}^{\\infty }{\\binom {n-i}{i}}}\n  \n[1]\n\n  \n    \n      \n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          F\n          \n            n\n          \n        \n        =\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                1\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        +\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        1\n        +\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              \n                i\n                −\n                1\n              \n            \n            \n              )\n            \n          \n        \n        +\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        1\n        +\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                +\n                1\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        \n          ∑\n          \n            i\n            =\n            0\n          \n          \n            ∞\n          \n        \n        \n          \n            \n              (\n            \n            \n              \n                n\n                +\n                1\n                −\n                i\n              \n              i\n            \n            \n              )\n            \n          \n        \n        =\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle F_{n-1}+F_{n}=\\sum _{i=0}^{\\infty }{\\binom {n-1-i}{i}}+\\sum _{i=0}^{\\infty }{\\binom {n-i}{i}}=1+\\sum _{i=1}^{\\infty }{\\binom {n-i}{i-1}}+\\sum _{i=1}^{\\infty }{\\binom {n-i}{i}}=1+\\sum _{i=1}^{\\infty }{\\binom {n+1-i}{i}}=\\sum _{i=0}^{\\infty }{\\binom {n+1-i}{i}}=F_{n+1}}\n  \n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式的組合數解法", "Tag": "算法设计"}
{"Answer": "設\n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n為黃金比例\n  \n    \n      \n        \n          \n            \n              1\n              +\n              \n                \n                  5\n                \n              \n            \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1+{\\sqrt {5}}}{2}}}\n  \n，則有恆等式\n  \n    \n      \n        \n          φ\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        φ\n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\varphi ^{n}=F_{n-1}+\\varphi F_{n}}\n  \n與\n  \n    \n      \n        (\n        1\n        −\n        φ\n        \n          )\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        −\n        φ\n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle (1-\\varphi )^{n}=F_{n+1}-\\varphi F_{n}}\n  \n，其中\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為任意整數[註 1]，則\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  φ\n                  \n                    n\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    n\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  F\n                  \n                    n\n                    −\n                    1\n                  \n                \n                +\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n                )\n                −\n                (\n                \n                  F\n                  \n                    n\n                    +\n                    1\n                  \n                \n                −\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n                )\n              \n            \n            \n              \n              \n                \n                =\n                (\n                \n                  F\n                  \n                    n\n                    −\n                    1\n                  \n                \n                −\n                \n                  F\n                  \n                    n\n                    +\n                    1\n                  \n                \n                )\n                +\n                2\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                −\n                \n                  F\n                  \n                    n\n                  \n                \n                +\n                2\n                φ\n                \n                  F\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  F\n                  \n                    n\n                  \n                \n                (\n                2\n                φ\n                −\n                1\n                )\n              \n            \n            \n              \n              \n                \n                =\n                \n                  F\n                  \n                    n\n                  \n                \n                ×\n                \n                  \n                    5\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}\\varphi ^{n}-(1-\\varphi )^{n}&=(F_{n-1}+\\varphi F_{n})-(F_{n+1}-\\varphi F_{n})\\\\&=(F_{n-1}-F_{n+1})+2\\varphi F_{n}\\\\&=-F_{n}+2\\varphi F_{n}\\\\&=F_{n}(2\\varphi -1)\\\\&=F_{n}\\times {\\sqrt {5}}\\\\\\end{aligned}}}\n  \n\n因此得到\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n的一般式：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  F\n                  \n                    n\n                  \n                \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    n\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    n\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                \n                  [\n                  \n                    (\n                    \n                      \n                        \n                          1\n                          +\n                          \n                            \n                              5\n                            \n                          \n                        \n                        2\n                      \n                    \n                    \n                      )\n                      \n                        n\n                      \n                    \n                    −\n                    (\n                    \n                      \n                        \n                          1\n                          −\n                          \n                            \n                              5\n                            \n                          \n                        \n                        2\n                      \n                    \n                    \n                      )\n                      \n                        n\n                      \n                    \n                  \n                  ]\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}F_{n}&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{n}-(1-\\varphi )^{n}]\\\\&={\\frac {1}{\\sqrt {5}}}\\left[({\\frac {1+{\\sqrt {5}}}{2}})^{n}-({\\frac {1-{\\sqrt {5}}}{2}})^{n}\\right]\\\\\\end{aligned}}}\n  \n\n此一般式對任意整數\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n成立\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式的黃金比例恆等式解法", "Tag": "算法设计"}
{"Answer": "當\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為足夠大的正整數時，则\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        ≈\n        \n          \n            1\n            \n              5\n            \n          \n        \n        \n          φ\n          \n            n\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  1\n                  2\n                \n              \n              \n                (\n                \n                  1\n                  +\n                  \n                    \n                      5\n                    \n                  \n                \n                )\n              \n            \n            ]\n          \n          \n            n\n          \n        \n        ≈\n        0.4472135955\n        ⋅\n        \n          1.61803398875\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}\\approx {\\frac {1}{\\sqrt {5}}}\\varphi ^{n}={\\frac {1}{\\sqrt {5}}}\\cdot \\left[{\\frac {1}{2}}\\left(1+{\\sqrt {5}}\\right)\\right]^{n}\\approx 0.4472135955\\cdot 1.61803398875^{n}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            −\n            n\n          \n        \n        ≈\n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        (\n        1\n        −\n        φ\n        \n          )\n          \n            −\n            n\n          \n        \n        =\n        −\n        \n          \n            1\n            \n              5\n            \n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  1\n                  2\n                \n              \n              \n                (\n                \n                  1\n                  −\n                  \n                    \n                      5\n                    \n                  \n                \n                )\n              \n            \n            ]\n          \n          \n            −\n            n\n          \n        \n        ≈\n        −\n        0.4472135955\n        ⋅\n        (\n        −\n        0.61803398875\n        \n          )\n          \n            −\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{-n}\\approx -{\\frac {1}{\\sqrt {5}}}(1-\\varphi )^{-n}=-{\\frac {1}{\\sqrt {5}}}\\cdot \\left[{\\frac {1}{2}}\\left(1-{\\sqrt {5}}\\right)\\right]^{-n}\\approx -0.4472135955\\cdot (-0.61803398875)^{-n}}\n  \n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式的近似值", "Tag": "算法设计"}
{"Answer": "可通過編程觀察斐波那契數列。分為兩類問題，一種已知數列中的某一項，求序數。第二種是已知序數，求該項的值。\n可通過遞歸遞推的算法解決此兩個問題。\n事實上當\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n相當巨大的時候，O（n）的遞推/遞歸非常慢……這時候要用到矩陣快速幂這一技巧，可以使遞迴加速到O(logn)。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的表達式的用計算機求解", "Tag": "算法设计"}
{"Answer": "開普勒發現數列前、後兩項之比\n  \n    \n      \n        \n          \n            1\n            2\n          \n        \n        ,\n        \n          \n            2\n            3\n          \n        \n        ,\n        \n          \n            3\n            5\n          \n        \n        ,\n        \n          \n            5\n            8\n          \n        \n        ,\n        \n          \n            8\n            13\n          \n        \n        ,\n        \n          \n            13\n            21\n          \n        \n        ,\n        \n          \n            21\n            34\n          \n        \n        ,\n        ⋯\n      \n    \n    {\\displaystyle {\\frac {1}{2}},{\\frac {2}{3}},{\\frac {3}{5}},{\\frac {5}{8}},{\\frac {8}{13}},{\\frac {13}{21}},{\\frac {21}{34}},\\cdots }\n  \n，也組成了一個數列，會趨近黃金分割：\n\n  \n    \n      \n        \n          \n            \n              f\n              \n                n\n                +\n                1\n              \n            \n            \n              f\n              \n                n\n              \n            \n          \n        \n        ≈\n        a\n        =\n        \n          \n            1\n            2\n          \n        \n        (\n        1\n        +\n        \n          \n            5\n          \n        \n        )\n        =\n        φ\n        ≈\n        1\n        \n          .\n        \n        618\n        \n          .\n          .\n          .\n        \n      \n    \n    {\\displaystyle {\\frac {f_{n+1}}{f_{n}}}\\approx a={\\frac {1}{2}}(1+{\\sqrt {5}})=\\varphi \\approx 1{.}618{...}}\n  \n斐波那契數亦可以用連分數來表示：\n\n  \n    \n      \n        \n          \n            1\n            1\n          \n        \n        =\n        1\n        \n        \n          \n            2\n            1\n          \n        \n        =\n        1\n        +\n        \n          \n            1\n            1\n          \n        \n        \n        \n          \n            3\n            2\n          \n        \n        =\n        1\n        +\n        \n          \n            1\n            \n              1\n              +\n              \n                \n                  1\n                  1\n                \n              \n            \n          \n        \n        \n        \n          \n            5\n            3\n          \n        \n        =\n        1\n        +\n        \n          \n            1\n            \n              1\n              +\n              \n                \n                  1\n                  \n                    1\n                    +\n                    \n                      \n                        1\n                        1\n                      \n                    \n                  \n                \n              \n            \n          \n        \n        \n        \n          \n            8\n            5\n          \n        \n        =\n        1\n        +\n        \n          \n            1\n            \n              1\n              +\n              \n                \n                  1\n                  \n                    1\n                    +\n                    \n                      \n                        1\n                        \n                          1\n                          +\n                          \n                            \n                              1\n                              1\n                            \n                          \n                        \n                      \n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{1}}=1\\qquad {\\frac {2}{1}}=1+{\\frac {1}{1}}\\qquad {\\frac {3}{2}}=1+{\\frac {1}{1+{\\frac {1}{1}}}}\\qquad {\\frac {5}{3}}=1+{\\frac {1}{1+{\\frac {1}{1+{\\frac {1}{1}}}}}}\\qquad {\\frac {8}{5}}=1+{\\frac {1}{1+{\\frac {1}{1+{\\frac {1}{1+{\\frac {1}{1}}}}}}}}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          \n            1\n            \n              5\n            \n          \n        \n        \n          [\n          \n            \n              \n                (\n                \n                  \n                    \n                      1\n                      +\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n            −\n            \n              \n                (\n                \n                  \n                    \n                      1\n                      −\n                      \n                        \n                          5\n                        \n                      \n                    \n                    2\n                  \n                \n                )\n              \n              \n                n\n              \n            \n          \n          ]\n        \n        =\n        \n          \n            \n              φ\n              \n                n\n              \n            \n            \n              \n                5\n              \n            \n          \n        \n        −\n        \n          \n            \n              (\n              1\n              −\n              φ\n              \n                )\n                \n                  n\n                \n              \n            \n            \n              \n                5\n              \n            \n          \n        \n      \n    \n    {\\displaystyle F_{n}={\\frac {1}{\\sqrt {5}}}\\left[\\left({\\frac {1+{\\sqrt {5}}}{2}}\\right)^{n}-\\left({\\frac {1-{\\sqrt {5}}}{2}}\\right)^{n}\\right]={\\varphi ^{n} \\over {\\sqrt {5}}}-{(1-\\varphi )^{n} \\over {\\sqrt {5}}}}\n  \n\n而黃金分割數亦可以用無限連分數表示：\n\n  \n    \n      \n        φ\n        =\n        1\n        +\n        \n          \n            1\n            \n              1\n              +\n              \n                \n                  1\n                  \n                    1\n                    +\n                    \n                      \n                        1\n                        \n                          1\n                          +\n                          \n                            \n                              1\n                              \n                                1\n                                +\n                                .\n                                .\n                                .\n                              \n                            \n                          \n                        \n                      \n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\varphi =1+{\\frac {1}{1+{\\frac {1}{1+{\\frac {1}{1+{\\frac {1}{1+...}}}}}}}}}\n  \n而黃金分割數也可以用無限多重根號表示：\n\n  \n    \n      \n        φ\n        =\n        \n          \n            1\n            +\n            \n              \n                1\n                +\n                \n                  \n                    1\n                    +\n                    \n                      \n                        1\n                        +\n                        .\n                        .\n                        .\n                      \n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\varphi ={\\sqrt {1+{\\sqrt {1+{\\sqrt {1+{\\sqrt {1+...}}}}}}}}}\n  \n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的和黃金分割的關係", "Tag": "算法设计"}
{"Answer": "更多信息：自然界的圖案（英语：Patterns in nature）参见：Golden ratio#Nature（英语：Golden ratio#Nature）  春黄菊的頭狀花序上，小花呈螺旋狀排列，從不同方向可以數出21（深藍）和13（淺藍）條旋臂，為相鄰的斐氏數。類似的螺旋狀排列見於多種植物。斐氏數列見於不同的生物學現象[2]，如樹的分枝、葉在枝條上的排列（英语：Phyllotaxis）、菠蘿聚花果上小單果的排列、[3]雅枝竹的花蕾、正在舒展的蕨葉、松毬的鱗的排列[4]、蜜蜂的家族樹[5][6]。开普勒曾指出斐氏數列存在於自然界，並以此解釋某些花的五邊形形態（與黄金分割率相關）。[7]法國菊的「瓣」（舌狀花）數通常為斐氏數。[8]1830年，K. F. Schimper和A. Braun發現植物的旋生葉序中，連續兩塊葉之間轉過的角度與周角之比，約成整數比時，常出現斐氏數[9]，如\n  \n    \n      \n        2\n        \n          /\n        \n        5\n      \n    \n    {\\displaystyle 2/5}\n  \n或\n  \n    \n      \n        5\n        \n          /\n        \n        13\n      \n    \n    {\\displaystyle 5/13}\n  \n[10]。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的和自然的關係", "Tag": "算法设计"}
{"Answer": "資料來源：[11]\n證明以下的恆等式有很多方法。以下會用組合論述來證明。\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n可以表示用多個1和多個2相加令其和等於\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的方法的數目。不失一般性，我們假設\n  \n    \n      \n        n\n        ≥\n        1\n      \n    \n    {\\displaystyle n\\geq 1}\n  \n，\n  \n    \n      \n        \n          F\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle F_{n+1}}\n  \n是計算了將1和2加到n的方法的數目。若第一個被加數是1，有\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n種方法來完成對\n  \n    \n      \n        n\n        −\n        1\n      \n    \n    {\\displaystyle n-1}\n  \n的計算；若第一個被加數是2，有\n  \n    \n      \n        \n          F\n          \n            n\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle F_{n-1}}\n  \n來完成對\n  \n    \n      \n        n\n        −\n        2\n      \n    \n    {\\displaystyle n-2}\n  \n的計算。因此，共有\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        +\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle F_{n}+F_{n-1}}\n  \n種方法來計算n的值。\n\n  \n    \n      \n        \n          F\n          \n            0\n          \n        \n        +\n        \n          F\n          \n            1\n          \n        \n        +\n        \n          F\n          \n            2\n          \n        \n        +\n        \n          F\n          \n            3\n          \n        \n        +\n        .\n        .\n        .\n        +\n        \n          F\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            +\n            2\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle F_{0}+F_{1}+F_{2}+F_{3}+...+F_{n}=F_{n+2}-1}\n  \n計算用多個1和多個2相加令其和等於\n  \n    \n      \n        n\n        +\n        1\n      \n    \n    {\\displaystyle n+1}\n  \n的方法的數目，同時至少一個加數是2的情況。\n如前所述，當\n  \n    \n      \n        n\n        >\n        0\n      \n    \n    {\\displaystyle n>0}\n  \n，有\n  \n    \n      \n        \n          F\n          \n            n\n            +\n            2\n          \n        \n      \n    \n    {\\displaystyle F_{n+2}}\n  \n種這樣的方法。因為當中只有一種方法不用使用2，就即\n  \n    \n      \n        1\n        +\n        1\n        +\n        .\n        .\n        .\n        +\n        1\n      \n    \n    {\\displaystyle 1+1+...+1}\n  \n　（\n  \n    \n      \n        n\n        +\n        1\n      \n    \n    {\\displaystyle n+1}\n  \n項），於是我們從\n  \n    \n      \n        \n          F\n          \n            n\n            +\n            2\n          \n        \n      \n    \n    {\\displaystyle F_{n+2}}\n  \n減去1。\n若第1個被加數是2，有\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n種方法來計算加至\n  \n    \n      \n        n\n        −\n        1\n      \n    \n    {\\displaystyle n-1}\n  \n的方法的數目；\n若第2個被加數是2、第1個被加數是1，有\n  \n    \n      \n        \n          F\n          \n            n\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle F_{n-1}}\n  \n種方法來計算加至\n  \n    \n      \n        n\n        −\n        2\n      \n    \n    {\\displaystyle n-2}\n  \n的方法的數目。\n重複以上動作。\n若第\n  \n    \n      \n        n\n        +\n        1\n      \n    \n    {\\displaystyle n+1}\n  \n個被加數為2，它之前的被加數均為1，就有\n  \n    \n      \n        \n          F\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle F_{0}}\n  \n種方法來計算加至0的數目。若該數式包含2為被加數，2的首次出現位置必然在第1和\n  \n    \n      \n        n\n        +\n        1\n      \n    \n    {\\displaystyle n+1}\n  \n的被加數之間。2在不同位置的情況都考慮到後，得出\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        +\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        .\n        .\n        .\n        +\n        \n          F\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle F_{n}+F_{n-1}+...+F_{0}}\n  \n為要求的數目。\n\n  \n    \n      \n        \n          F\n          \n            1\n          \n        \n        +\n        2\n        \n          F\n          \n            2\n          \n        \n        +\n        3\n        \n          F\n          \n            3\n          \n        \n        +\n        .\n        .\n        .\n        +\n        n\n        \n          F\n          \n            n\n          \n        \n        =\n        n\n        \n          F\n          \n            n\n            +\n            2\n          \n        \n        −\n        \n          F\n          \n            n\n            +\n            3\n          \n        \n        +\n        2\n      \n    \n    {\\displaystyle F_{1}+2F_{2}+3F_{3}+...+nF_{n}=nF_{n+2}-F_{n+3}+2}\n  \n\n  \n    \n      \n        \n          F\n          \n            1\n          \n        \n        +\n        \n          F\n          \n            3\n          \n        \n        +\n        \n          F\n          \n            5\n          \n        \n        +\n        .\n        .\n        .\n        +\n        \n          F\n          \n            2\n            n\n            −\n            1\n          \n        \n        =\n        \n          F\n          \n            2\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{1}+F_{3}+F_{5}+...+F_{2n-1}=F_{2n}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            2\n          \n        \n        +\n        \n          F\n          \n            4\n          \n        \n        +\n        \n          F\n          \n            6\n          \n        \n        +\n        .\n        .\n        .\n        +\n        \n          F\n          \n            2\n            n\n          \n        \n        =\n        \n          F\n          \n            2\n            n\n            +\n            1\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle F_{2}+F_{4}+F_{6}+...+F_{2n}=F_{2n+1}-1}\n  \n\n\n  \n    \n      \n        \n          \n            \n              F\n              \n                1\n              \n            \n          \n          \n            2\n          \n        \n        +\n        \n          \n            \n              F\n              \n                2\n              \n            \n          \n          \n            2\n          \n        \n        +\n        \n          \n            \n              F\n              \n                3\n              \n            \n          \n          \n            2\n          \n        \n        +\n        .\n        .\n        .\n        +\n        \n          \n            \n              F\n              \n                n\n              \n            \n          \n          \n            2\n          \n        \n        =\n        \n          F\n          \n            n\n          \n        \n        \n          F\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle {F_{1}}^{2}+{F_{2}}^{2}+{F_{3}}^{2}+...+{F_{n}}^{2}=F_{n}F_{n+1}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        \n          F\n          \n            m\n            −\n            k\n          \n        \n        −\n        \n          F\n          \n            m\n          \n        \n        \n          F\n          \n            n\n            −\n            k\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            n\n            −\n            k\n          \n        \n        \n          F\n          \n            m\n            −\n            n\n          \n        \n        \n          F\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle F_{n}F_{m-k}-F_{m}F_{n-k}=(-1)^{n-k}F_{m-n}F_{k}}\n  \n，其中\n  \n    \n      \n        m\n        ,\n        n\n        ,\n        k\n      \n    \n    {\\displaystyle m,n,k}\n  \n與\n  \n    \n      \n        F\n      \n    \n    {\\displaystyle F}\n  \n的序數皆不限於正整數。[註 2]\n特別地，當\n  \n    \n      \n        n\n        =\n        m\n        −\n        k\n      \n    \n    {\\displaystyle n=m-k}\n  \n時，\n  \n    \n      \n        \n          \n            \n              F\n              \n                n\n              \n            \n          \n          \n            2\n          \n        \n        −\n        \n          F\n          \n            n\n            +\n            k\n          \n        \n        \n          F\n          \n            n\n            −\n            k\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            n\n            −\n            k\n          \n        \n        \n          \n            \n              F\n              \n                k\n              \n            \n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle {F_{n}}^{2}-F_{n+k}F_{n-k}=(-1)^{n-k}{F_{k}}^{2}}\n  \n\n更特別地，當\n  \n    \n      \n        k\n        =\n        1\n      \n    \n    {\\displaystyle k=1}\n  \n或\n  \n    \n      \n        k\n        =\n        −\n        1\n      \n    \n    {\\displaystyle k=-1}\n  \n時，對於數列連續三項，有\n  \n    \n      \n        \n          \n            \n              F\n              \n                n\n              \n            \n          \n          \n            2\n          \n        \n        −\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            n\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle {F_{n}}^{2}-F_{n-1}F_{n+1}=(-1)^{n-1}}\n  \n\n另一方面，當\n  \n    \n      \n        (\n        m\n        ,\n        n\n        ,\n        k\n        )\n        =\n        (\n        n\n        +\n        1\n        ,\n        n\n        ,\n        −\n        2\n        )\n      \n    \n    {\\displaystyle (m,n,k)=(n+1,n,-2)}\n  \n時，對於數列連續四項，有\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        \n          F\n          \n            n\n            +\n            3\n          \n        \n        −\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        \n          F\n          \n            n\n            +\n            2\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle F_{n}F_{n+3}-F_{n+1}F_{n+2}=(-1)^{n+1}}\n  \n[註 3]\n\n  \n    \n      \n        \n          φ\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        φ\n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\varphi ^{n}=F_{n-1}+\\varphi F_{n}}\n  \n且\n  \n    \n      \n        (\n        1\n        −\n        φ\n        \n          )\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        −\n        φ\n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle (1-\\varphi )^{n}=F_{n+1}-\\varphi F_{n}}\n  \n，其中\n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n為黃金比例\n  \n    \n      \n        \n          \n            \n              1\n              +\n              \n                \n                  5\n                \n              \n            \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1+{\\sqrt {5}}}{2}}}\n  \n，\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n為任意整數[註 1]藉由上述公式，又可推得以下恆等式[註 4]：\n  \n    \n      \n        \n          \n            F\n            \n              m\n            \n          \n        \n        \n          \n            F\n            \n              n\n            \n          \n        \n        +\n        \n          \n            F\n            \n              m\n              −\n              1\n            \n          \n        \n        \n          \n            F\n            \n              n\n              −\n              1\n            \n          \n        \n        =\n        \n          F\n          \n            m\n            +\n            n\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle {F_{m}}{F_{n}}+{F_{m-1}}{F_{n-1}}=F_{m+n-1}}\n  \n[11]\n\n  \n    \n      \n        \n          F\n          \n            m\n          \n        \n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        +\n        \n          F\n          \n            m\n            −\n            1\n          \n        \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            m\n            +\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{m}F_{n+1}+F_{m-1}F_{n}=F_{m+n}}\n  \n[11]特別地，當\n  \n    \n      \n        m\n        =\n        n\n      \n    \n    {\\displaystyle m=n}\n  \n時，\n  \n    \n      \n        \n          \n            \n              \n                \n                  F\n                  \n                    2\n                    n\n                    −\n                    1\n                  \n                \n              \n              \n                \n                =\n                \n                  F\n                  \n                    n\n                  \n                  \n                    2\n                  \n                \n                +\n                \n                  F\n                  \n                    n\n                    −\n                    1\n                  \n                  \n                    2\n                  \n                \n              \n            \n            \n              \n                \n                  F\n                  \n                    2\n                    n\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  F\n                  \n                    n\n                    −\n                    1\n                  \n                \n                +\n                \n                  F\n                  \n                    n\n                    +\n                    1\n                  \n                \n                )\n                \n                  F\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                (\n                2\n                \n                  F\n                  \n                    n\n                    −\n                    1\n                  \n                \n                +\n                \n                  F\n                  \n                    n\n                  \n                \n                )\n                \n                  F\n                  \n                    n\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}F_{2n-1}&=F_{n}^{2}+F_{n-1}^{2}\\\\F_{2n}&=(F_{n-1}+F_{n+1})F_{n}\\\\&=(2F_{n-1}+F_{n})F_{n}\\end{aligned}}}\n  \n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的恆等式", "Tag": "算法设计"}
{"Answer": "公因數和整除關係[编辑]\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n整除\n  \n    \n      \n        \n          F\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle F_{m}}\n  \n，若且唯若\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n整除\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n，其中\n  \n    \n      \n        n\n        ≧\n        3\n      \n    \n    {\\displaystyle n\\geqq 3}\n  \n。\n\n  \n    \n      \n        gcd\n        (\n        \n          F\n          \n            m\n          \n        \n        ,\n        \n          F\n          \n            n\n          \n        \n        )\n        =\n        \n          F\n          \n            gcd\n            (\n            m\n            ,\n            n\n            )\n          \n        \n      \n    \n    {\\displaystyle \\gcd(F_{m},F_{n})=F_{\\gcd(m,n)}}\n  \n\n任意連續三個菲波那契數兩兩互質，亦即，對於每一個\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n，\n  \n    \n      \n        \n          g\n          c\n          d\n        \n        (\n        \n          F\n          \n            n\n          \n        \n        ,\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        )\n        =\n        \n          g\n          c\n          d\n        \n        (\n        \n          F\n          \n            n\n          \n        \n        ,\n        \n          F\n          \n            n\n            +\n            2\n          \n        \n        )\n        =\n        \n          g\n          c\n          d\n        \n        (\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        ,\n        \n          F\n          \n            n\n            +\n            2\n          \n        \n        )\n        =\n        1\n      \n    \n    {\\displaystyle \\mathrm {gcd} (F_{n},F_{n+1})=\\mathrm {gcd} (F_{n},F_{n+2})=\\mathrm {gcd} (F_{n+1},F_{n+2})=1}\n  \n斐波那契质数[编辑]主条目：斐波那契质数在斐波那契數列中，有質數：[12]\n2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, 1066340417491710595814572169, 19134702400093278081449423917……\n截至2015年，已知最大的斐波那契質數是第104911個斐波那契數，一共有21925個十進制位。不过，人们仍不知道是不是有无限个斐波那契质数。[13]\n如§ 公因數和整除關係所述，\n  \n    \n      \n        \n          F\n          \n            k\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{kn}}\n  \n總能被\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n整除，故除\n  \n    \n      \n        \n          F\n          \n            4\n          \n        \n        =\n        3\n      \n    \n    {\\displaystyle F_{4}=3}\n  \n之外，任何斐氏質數的下標必同為質數。由於存在任意長（英语：Arbitrarily large）的一列連續合数，斐氏數列中亦能找到連續任意多項全為合數。\n大於\n  \n    \n      \n        \n          F\n          \n            6\n          \n        \n        =\n        8\n      \n    \n    {\\displaystyle F_{6}=8}\n  \n的斐氏數，必不等於質數加一或減一。[14]\n與其他數列的交集[编辑]斐波那契数列中，只有3個平方數：0、1、144。[15][16]2001年，派特·奧蒂洛（匈牙利语：Pethő Attila）證明衹有有限多個斐氏數是完全冪。[17]2006年，Y. Bugeaud、M. Mignotte、S. Siksek三人證明此種冪僅得0、1、8、144。[18]\n1、3、21、55為僅有的斐氏三角形數。Vern Hoggatt（英语：Verner Emil Hoggatt Jr.）曾猜想此結論，後來由罗明證明。[19]\n斐波那契數不能為完全数。[20]推而廣之，除1之外，其他斐氏數皆非多重完全數[21]，任兩個斐氏數之比亦不能是完全數[22]。\n模n的週期性[编辑]主条目：皮萨诺周期斐波那契數列各項模\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的餘數構成週期數列（英语：periodic sequence），其最小正週期稱為皮萨诺周期[23]，至多為\n  \n    \n      \n        6\n        n\n      \n    \n    {\\displaystyle 6n}\n  \n[24]。皮薩諾週期對不同\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n值的通項公式仍是未解問題，其中一步需要求出某個整數（同餘意義下）或二次有限域元素的乘法階數（英语：multiplicative order）。不過，對固定的\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n，求解模\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的皮薩諾週期是週期檢測（英语：cycle detection）問題的特例。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的數論性質", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n整除\n  \n    \n      \n        \n          F\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle F_{m}}\n  \n，若且唯若\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n整除\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n，其中\n  \n    \n      \n        n\n        ≧\n        3\n      \n    \n    {\\displaystyle n\\geqq 3}\n  \n。\n\n  \n    \n      \n        gcd\n        (\n        \n          F\n          \n            m\n          \n        \n        ,\n        \n          F\n          \n            n\n          \n        \n        )\n        =\n        \n          F\n          \n            gcd\n            (\n            m\n            ,\n            n\n            )\n          \n        \n      \n    \n    {\\displaystyle \\gcd(F_{m},F_{n})=F_{\\gcd(m,n)}}\n  \n\n任意連續三個菲波那契數兩兩互質，亦即，對於每一個\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n，\n  \n    \n      \n        \n          g\n          c\n          d\n        \n        (\n        \n          F\n          \n            n\n          \n        \n        ,\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        )\n        =\n        \n          g\n          c\n          d\n        \n        (\n        \n          F\n          \n            n\n          \n        \n        ,\n        \n          F\n          \n            n\n            +\n            2\n          \n        \n        )\n        =\n        \n          g\n          c\n          d\n        \n        (\n        \n          F\n          \n            n\n            +\n            1\n          \n        \n        ,\n        \n          F\n          \n            n\n            +\n            2\n          \n        \n        )\n        =\n        1\n      \n    \n    {\\displaystyle \\mathrm {gcd} (F_{n},F_{n+1})=\\mathrm {gcd} (F_{n},F_{n+2})=\\mathrm {gcd} (F_{n+1},F_{n+2})=1}\n  \n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的數論性質的公因數和整除關係", "Tag": "算法设计"}
{"Answer": "主条目：斐波那契质数在斐波那契數列中，有質數：[12]\n2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, 1066340417491710595814572169, 19134702400093278081449423917……\n截至2015年，已知最大的斐波那契質數是第104911個斐波那契數，一共有21925個十進制位。不过，人们仍不知道是不是有无限个斐波那契质数。[13]\n如§ 公因數和整除關係所述，\n  \n    \n      \n        \n          F\n          \n            k\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{kn}}\n  \n總能被\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}}\n  \n整除，故除\n  \n    \n      \n        \n          F\n          \n            4\n          \n        \n        =\n        3\n      \n    \n    {\\displaystyle F_{4}=3}\n  \n之外，任何斐氏質數的下標必同為質數。由於存在任意長（英语：Arbitrarily large）的一列連續合数，斐氏數列中亦能找到連續任意多項全為合數。\n大於\n  \n    \n      \n        \n          F\n          \n            6\n          \n        \n        =\n        8\n      \n    \n    {\\displaystyle F_{6}=8}\n  \n的斐氏數，必不等於質數加一或減一。[14]\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的數論性質的斐波那契质数", "Tag": "算法设计"}
{"Answer": "斐波那契数列中，只有3個平方數：0、1、144。[15][16]2001年，派特·奧蒂洛（匈牙利语：Pethő Attila）證明衹有有限多個斐氏數是完全冪。[17]2006年，Y. Bugeaud、M. Mignotte、S. Siksek三人證明此種冪僅得0、1、8、144。[18]\n1、3、21、55為僅有的斐氏三角形數。Vern Hoggatt（英语：Verner Emil Hoggatt Jr.）曾猜想此結論，後來由罗明證明。[19]\n斐波那契數不能為完全数。[20]推而廣之，除1之外，其他斐氏數皆非多重完全數[21]，任兩個斐氏數之比亦不能是完全數[22]。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的數論性質的與其他數列的交集", "Tag": "算法设计"}
{"Answer": "主条目：皮萨诺周期斐波那契數列各項模\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的餘數構成週期數列（英语：periodic sequence），其最小正週期稱為皮萨诺周期[23]，至多為\n  \n    \n      \n        6\n        n\n      \n    \n    {\\displaystyle 6n}\n  \n[24]。皮薩諾週期對不同\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n值的通項公式仍是未解問題，其中一步需要求出某個整數（同餘意義下）或二次有限域元素的乘法階數（英语：multiplicative order）。不過，對固定的\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n，求解模\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的皮薩諾週期是週期檢測（英语：cycle detection）問題的特例。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的數論性質的模n的週期性", "Tag": "算法设计"}
{"Answer": "斐波那西數列是斐波那西n步數列步數為2的特殊情況，也和盧卡斯數列有關。\n和盧卡斯數列的關係[编辑]\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        \n          L\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            2\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}L_{n}=F_{2n}}\n  \n反費波那西數列[编辑]反費波那西數列的遞歸公式如下：\n\n  \n    \n      \n        \n          G\n          \n            n\n            +\n            2\n          \n        \n        =\n        \n          G\n          \n            n\n          \n        \n        −\n        \n          G\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle G_{n+2}=G_{n}-G_{n+1}}\n  \n如果它以1,-1開始，之後的數是：1,-1,2,-3,5,-8, ...\n即是\n  \n    \n      \n        \n          F\n          \n            2\n            n\n            +\n            1\n          \n        \n        =\n        \n          G\n          \n            2\n            n\n            +\n            1\n          \n        \n        =\n        \n          F\n          \n            −\n            (\n            2\n            n\n            +\n            1\n            )\n          \n        \n        ,\n        \n          F\n          \n            2\n            n\n          \n        \n        =\n        −\n        \n          G\n          \n            2\n            n\n          \n        \n        =\n        −\n        \n          F\n          \n            −\n            2\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{2n+1}=G_{2n+1}=F_{-(2n+1)},F_{2n}=-G_{2n}=-F_{-2n}}\n  \n，\n亦可寫成\n  \n    \n      \n        \n          F\n          \n            m\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            m\n            +\n            1\n          \n        \n        \n          G\n          \n            m\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            m\n            +\n            1\n          \n        \n        \n          F\n          \n            −\n            m\n          \n        \n      \n    \n    {\\displaystyle F_{m}=(-1)^{m+1}G_{m}=(-1)^{m+1}F_{-m}}\n  \n，其中\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是非負整數。\n反費波那西數列兩項之間的比會趨近\n  \n    \n      \n        −\n        \n          \n            1\n            φ\n          \n        \n        ≈\n        −\n        0.618\n      \n    \n    {\\displaystyle -{\\frac {1}{\\varphi }}\\approx -0.618}\n  \n。\n證明關係式[编辑]證明\n  \n    \n      \n        \n          F\n          \n            m\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            m\n            +\n            1\n          \n        \n        \n          F\n          \n            −\n            m\n          \n        \n      \n    \n    {\\displaystyle F_{m}=(-1)^{m+1}F_{-m}}\n  \n，其中\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是非負整數\n以\n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n表示黃金分割數\n  \n    \n      \n        \n          \n            \n              1\n              +\n              \n                \n                  5\n                \n              \n            \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1+{\\sqrt {5}}}{2}}}\n  \n，則有\n  \n    \n      \n        φ\n        (\n        1\n        −\n        φ\n        )\n        =\n        −\n        1\n      \n    \n    {\\displaystyle \\varphi (1-\\varphi )=-1}\n  \n\n故\n  \n    \n      \n        (\n        −\n        1\n        \n          )\n          \n            m\n          \n        \n        =\n        [\n        φ\n        (\n        1\n        −\n        φ\n        )\n        \n          ]\n          \n            m\n          \n        \n        =\n        \n          φ\n          \n            m\n          \n        \n        (\n        1\n        −\n        φ\n        \n          )\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle (-1)^{m}=[\\varphi (1-\\varphi )]^{m}=\\varphi ^{m}(1-\\varphi )^{m}}\n  \n，因此\n\n  \n    \n      \n        \n          \n            \n              \n                (\n                −\n                1\n                \n                  )\n                  \n                    m\n                    +\n                    1\n                  \n                \n                \n                  F\n                  \n                    −\n                    m\n                  \n                \n              \n              \n                \n                =\n                (\n                −\n                1\n                \n                  )\n                  \n                    m\n                    +\n                    1\n                  \n                \n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    (\n                    −\n                    1\n                    \n                      )\n                      \n                        m\n                      \n                    \n                  \n                \n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    \n                      φ\n                      \n                        m\n                      \n                    \n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        m\n                      \n                    \n                  \n                \n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                    +\n                    m\n                  \n                \n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                    +\n                    m\n                  \n                \n                \n                  φ\n                  \n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    m\n                  \n                \n                −\n                \n                  φ\n                  \n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  F\n                  \n                    m\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}(-1)^{m+1}F_{-m}&=(-1)^{m+1}\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m}-(1-\\varphi )^{-m}]\\\\&=(-1)\\times {\\color {brown}(-1)^{m}}\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m}-(1-\\varphi )^{-m}]\\\\&=(-1)\\times {\\color {brown}\\varphi ^{m}(1-\\varphi )^{m}}\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m}-(1-\\varphi )^{-m}]\\\\&=(-1)\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m+m}(1-\\varphi )^{m}-(1-\\varphi )^{-m+m}\\varphi ^{m}]\\\\&=(-1)\\times {\\frac {1}{\\sqrt {5}}}[(1-\\varphi )^{m}-\\varphi ^{m}]\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{m}-(1-\\varphi )^{m}]\\\\&=F_{m}\\\\\\end{aligned}}}\n  \n巴都萬數列[编辑]費波那西數列可以用一個接一個的正方形來表現，巴都萬數列則是用一個接一個的等邊三角形來表現，它有\n  \n    \n      \n        \n          P\n          \n            n\n          \n        \n        =\n        \n          P\n          \n            n\n            −\n            2\n          \n        \n        +\n        \n          P\n          \n            n\n            −\n            3\n          \n        \n      \n    \n    {\\displaystyle P_{n}=P_{n-2}+P_{n-3}}\n  \n的關係。\n佩爾數列[编辑]佩爾數列的遞歸公式為\n  \n    \n      \n        \n          P\n          \n            n\n          \n        \n        =\n        2\n        \n          P\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          P\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle P_{n}=2P_{n-1}+P_{n-2}}\n  \n，前幾項為0,1,2,5,12,29,70,169,408,...\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的推廣", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        \n          L\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            2\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{n}L_{n}=F_{2n}}\n  \n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的推廣的和盧卡斯數列的關係", "Tag": "算法设计"}
{"Answer": "反費波那西數列的遞歸公式如下：\n\n  \n    \n      \n        \n          G\n          \n            n\n            +\n            2\n          \n        \n        =\n        \n          G\n          \n            n\n          \n        \n        −\n        \n          G\n          \n            n\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle G_{n+2}=G_{n}-G_{n+1}}\n  \n如果它以1,-1開始，之後的數是：1,-1,2,-3,5,-8, ...\n即是\n  \n    \n      \n        \n          F\n          \n            2\n            n\n            +\n            1\n          \n        \n        =\n        \n          G\n          \n            2\n            n\n            +\n            1\n          \n        \n        =\n        \n          F\n          \n            −\n            (\n            2\n            n\n            +\n            1\n            )\n          \n        \n        ,\n        \n          F\n          \n            2\n            n\n          \n        \n        =\n        −\n        \n          G\n          \n            2\n            n\n          \n        \n        =\n        −\n        \n          F\n          \n            −\n            2\n            n\n          \n        \n      \n    \n    {\\displaystyle F_{2n+1}=G_{2n+1}=F_{-(2n+1)},F_{2n}=-G_{2n}=-F_{-2n}}\n  \n，\n亦可寫成\n  \n    \n      \n        \n          F\n          \n            m\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            m\n            +\n            1\n          \n        \n        \n          G\n          \n            m\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            m\n            +\n            1\n          \n        \n        \n          F\n          \n            −\n            m\n          \n        \n      \n    \n    {\\displaystyle F_{m}=(-1)^{m+1}G_{m}=(-1)^{m+1}F_{-m}}\n  \n，其中\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是非負整數。\n反費波那西數列兩項之間的比會趨近\n  \n    \n      \n        −\n        \n          \n            1\n            φ\n          \n        \n        ≈\n        −\n        0.618\n      \n    \n    {\\displaystyle -{\\frac {1}{\\varphi }}\\approx -0.618}\n  \n。\n證明關係式[编辑]證明\n  \n    \n      \n        \n          F\n          \n            m\n          \n        \n        =\n        (\n        −\n        1\n        \n          )\n          \n            m\n            +\n            1\n          \n        \n        \n          F\n          \n            −\n            m\n          \n        \n      \n    \n    {\\displaystyle F_{m}=(-1)^{m+1}F_{-m}}\n  \n，其中\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是非負整數\n以\n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n表示黃金分割數\n  \n    \n      \n        \n          \n            \n              1\n              +\n              \n                \n                  5\n                \n              \n            \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1+{\\sqrt {5}}}{2}}}\n  \n，則有\n  \n    \n      \n        φ\n        (\n        1\n        −\n        φ\n        )\n        =\n        −\n        1\n      \n    \n    {\\displaystyle \\varphi (1-\\varphi )=-1}\n  \n\n故\n  \n    \n      \n        (\n        −\n        1\n        \n          )\n          \n            m\n          \n        \n        =\n        [\n        φ\n        (\n        1\n        −\n        φ\n        )\n        \n          ]\n          \n            m\n          \n        \n        =\n        \n          φ\n          \n            m\n          \n        \n        (\n        1\n        −\n        φ\n        \n          )\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle (-1)^{m}=[\\varphi (1-\\varphi )]^{m}=\\varphi ^{m}(1-\\varphi )^{m}}\n  \n，因此\n\n  \n    \n      \n        \n          \n            \n              \n                (\n                −\n                1\n                \n                  )\n                  \n                    m\n                    +\n                    1\n                  \n                \n                \n                  F\n                  \n                    −\n                    m\n                  \n                \n              \n              \n                \n                =\n                (\n                −\n                1\n                \n                  )\n                  \n                    m\n                    +\n                    1\n                  \n                \n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    (\n                    −\n                    1\n                    \n                      )\n                      \n                        m\n                      \n                    \n                  \n                \n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    \n                      φ\n                      \n                        m\n                      \n                    \n                    (\n                    1\n                    −\n                    φ\n                    \n                      )\n                      \n                        m\n                      \n                    \n                  \n                \n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    −\n                    m\n                    +\n                    m\n                  \n                \n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    −\n                    m\n                    +\n                    m\n                  \n                \n                \n                  φ\n                  \n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                (\n                −\n                1\n                )\n                ×\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    m\n                  \n                \n                −\n                \n                  φ\n                  \n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    1\n                    \n                      5\n                    \n                  \n                \n                [\n                \n                  φ\n                  \n                    m\n                  \n                \n                −\n                (\n                1\n                −\n                φ\n                \n                  )\n                  \n                    m\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                \n                  F\n                  \n                    m\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}(-1)^{m+1}F_{-m}&=(-1)^{m+1}\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m}-(1-\\varphi )^{-m}]\\\\&=(-1)\\times {\\color {brown}(-1)^{m}}\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m}-(1-\\varphi )^{-m}]\\\\&=(-1)\\times {\\color {brown}\\varphi ^{m}(1-\\varphi )^{m}}\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m}-(1-\\varphi )^{-m}]\\\\&=(-1)\\times {\\frac {1}{\\sqrt {5}}}[\\varphi ^{-m+m}(1-\\varphi )^{m}-(1-\\varphi )^{-m+m}\\varphi ^{m}]\\\\&=(-1)\\times {\\frac {1}{\\sqrt {5}}}[(1-\\varphi )^{m}-\\varphi ^{m}]\\\\&={\\frac {1}{\\sqrt {5}}}[\\varphi ^{m}-(1-\\varphi )^{m}]\\\\&=F_{m}\\\\\\end{aligned}}}\n  \n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的推廣的反費波那西數列", "Tag": "算法设计"}
{"Answer": "費波那西數列可以用一個接一個的正方形來表現，巴都萬數列則是用一個接一個的等邊三角形來表現，它有\n  \n    \n      \n        \n          P\n          \n            n\n          \n        \n        =\n        \n          P\n          \n            n\n            −\n            2\n          \n        \n        +\n        \n          P\n          \n            n\n            −\n            3\n          \n        \n      \n    \n    {\\displaystyle P_{n}=P_{n-2}+P_{n-3}}\n  \n的關係。\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的推廣的巴都萬數列", "Tag": "算法设计"}
{"Answer": "佩爾數列的遞歸公式為\n  \n    \n      \n        \n          P\n          \n            n\n          \n        \n        =\n        2\n        \n          P\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          P\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle P_{n}=2P_{n-1}+P_{n-2}}\n  \n，前幾項為0,1,2,5,12,29,70,169,408,...\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的推廣的佩爾數列", "Tag": "算法设计"}
{"Answer": "1970年，尤裏·馬季亞謝維奇指出了偶角標的斐波那契函數\n\n  \n    \n      \n        y\n        =\n        \n          F\n          \n            2\n            x\n          \n        \n      \n    \n    {\\displaystyle y=F_{2x}}\n  \n正是滿足Julia Robison假設的丟番圖函數，因而證明了希爾伯特第十問題是不可解的。\n電腦科學[编辑]  高為6的斐波那契樹。平衡因子以綠色標記，節點的高度則為紅色。最左一條路徑上的鍵值全為斐氏數。考慮以輾轉相除法求兩個正整數的最大公因數，分析此算法的運行時間。同等輸入規模下，最壞情況（用時最長）發生於輸入為兩個相鄰斐氏數時。[25]\n归并排序算法有一多相（polyphase）版本用到斐氏數列，是將未排序的數組分為兩份，長度為相鄰的斐氏數（因此比值接近黃金比）。《计算机程序设计艺术》[页码请求]描述了此種多相合併排序（英语：polyphase merge sort）的實作方法，適用於以磁带机為外存的情況。\n斐波那契樹是一棵二叉树，其每個節點的左右子树高皆恰好差1。由此，斐氏樹為AVL树，且對固定高度而言，是最少節點的AVL樹。此類樹的節點數可寫成斐氏數減1。[26]\n某些伪随机数生成器用到斐氏數列。[具体情况如何？]\n斐波那契堆是一種數據結構，分析其時間複雜度時會用到斐波那契數。\n斐波那契编码是以01字串表示正整數的一種方法，負斐波那契編碼（英语：NegaFibonacci coding）與之類似，還可以表示負數。", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的應用", "Tag": "算法设计"}
{"Answer": "  高為6的斐波那契樹。平衡因子以綠色標記，節點的高度則為紅色。最左一條路徑上的鍵值全為斐氏數。考慮以輾轉相除法求兩個正整數的最大公因數，分析此算法的運行時間。同等輸入規模下，最壞情況（用時最長）發生於輸入為兩個相鄰斐氏數時。[25]\n归并排序算法有一多相（polyphase）版本用到斐氏數列，是將未排序的數組分為兩份，長度為相鄰的斐氏數（因此比值接近黃金比）。《计算机程序设计艺术》[页码请求]描述了此種多相合併排序（英语：polyphase merge sort）的實作方法，適用於以磁带机為外存的情況。\n斐波那契樹是一棵二叉树，其每個節點的左右子树高皆恰好差1。由此，斐氏樹為AVL树，且對固定高度而言，是最少節點的AVL樹。此類樹的節點數可寫成斐氏數減1。[26]\n某些伪随机数生成器用到斐氏數列。[具体情况如何？]\n斐波那契堆是一種數據結構，分析其時間複雜度時會用到斐波那契數。\n斐波那契编码是以01字串表示正整數的一種方法，負斐波那契編碼（英语：NegaFibonacci coding）與之類似，還可以表示負數。", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的應用的電腦科學", "Tag": "算法设计"}
{"Answer": "JavaScript迭代版\nfunction fib(n) {\n    var fib_n = function(curr, next, n) {\n        if (n == 0) {\n            return curr;\n        }\n        else {\n            return fib_n(next, curr+next, n-1);\n        }\n    }\n    return fib_n(0, 1, n);\n}\nalert(fib(40));\nC语言通项公式版\n#include <stdio.h>\n#include <math.h>\n\nint main()\n{\n    int n;\n    double constant_a = (1 + sqrt(5)) / 2;\n    double constant_b = (1 - sqrt(5)) / 2;\n    double constant_c = sqrt(5) / 5;\n    double value_1 = 0;\n    int value_2 = 0;\n    scanf(\"%d\", &n);\n    if(n > 0)\n    {\n        for (int i = 0; i < n; i++)\n        {\n             value_1 = constant_c * (pow(constant_a, i) - pow(constant_b, i));\n             value_2 = (int)value_1;\n             printf(\"%d\\n\", value_2);\n        }\n        return 0;\n    }\n    else\n    {\n        return -1;\n    }\n}\n\nc++二變數求某項版#include <iostream>\nusing namespace std;\nint main () {\n\tint x,y,n;\n    x=1;y=0;\n\tcin >> n;\n\tfor (int i=0;i<n;i=i+1) {\n\t    x=x+y;\n\t\ty=x-y;\n\t}\n\tcout << y;\n\treturn 0;\n}\n\nc++通项公式版#include <iostream>\n#include <cmath>\nusing namespace std;\nint main()\n{\n    unsigned long long n;\n    double ca = (1 + sqrt(5)) / 2;\n    double cb = (1 - sqrt(5)) / 2;\n    double cc = sqrt(5) / 5;\n    double v1 = 0;\n    double v2 = 0;\n    cout <<\" \";\n    cin>>n;\n    if(n > 0)\n    {\n        for (unsigned long long i = 0; i < n; i++)\n    {\n            v1 = cc * (pow(ca, i) - pow(cb, i));\n        v2 = (int)v1;\n        cout <<v2<<endl;\n    }\n    return 0;\n    }\n    else\n    {\n        return -1;\n    }\n        cout <<'/b';\n}\nPython语言通项公式版# Fibonacci numbers module\n\ndef fib(n):    # write Fibonacci series up to n\n    a, b = 0, 1\n    while b < n:\n        print(b, end=' ')\n        a, b = b, a+b\n    print()\n\ndef fib2(n):   # return Fibonacci series up to n\n    result = []\n    a, b = 0, 1\n    while b < n:\n        result.append(b)\n        a, b = b, a+b\n    return result\nfibs = [0, 1]\nnumZS = int(input('How many Fibonacci numbers do you want? '))\nfor i in range(numZS-2):\n    fibs.append(fibs[-2] + fibs[-1])\nprint fibs\nCommon Lisp\n(defun fibs (x)\n  (cond ((equal x 0) 1)\n        ((equal x 1) 1)\n        (t (+ (fibs (- x 1))\n              (fibs (- x 2))))))\n\n(defun fibs (x)\n  (do ((n 0 (+ n 1))\n       (i 1 j)\n       (j 1 (+ i j)))\n      ((equal n x) i)))\nGo\n遞迴版，時間複雜度為 O(2^n)：\nfunc fibonacci(n int) int {\n\tif n < 2 {\n\t\treturn n\n\t}\n\n\treturn fibonacci(n-2) + fibonacci(n-1)\n}\n通用版，時間複雜度為 O(n)：\nfunc fibonacci(n int) int {\n\ta, b := n%2, 1\n\n\tfor i := 0; i < n/2; i++ {\n\t\ta += b\n\t\tb += a\n\t}\n\n\treturn a\n}\nJava语言递归版：\npublic int fibonacci(int n){\n    if(n<2){\n     return n;\n    }else {\n      return fibonacci(n-1)+fibonacci(n-2);\n    }\n}\nJava语言快捷版：\npublic int fibonacci(int n){\n    if(n<2){\n     return n;\n    }else {\n      int[] ans = new int[n];\n          ans[0] = 1;\n          ans[1] = 2;\n          for(int i=2;i<n;i++) {\n              ans[i]=ans[i-1]+ans[i-2];\n          }\n          return ans[n-1];\n    }\n}\nC语言陣列版：\n#include <stdio.h>\n#include <stdlib.h> \nint main()\n{   \n     int n,s,L;\n     printf(\"輸入長度\");\n     scanf(\"%d\",&L);\n     while(L<0)\n     {\n     \tprintf(\"錯誤\"); \n     \treturn 0;\n\t }\n     int a[L]; \n     int x=1,y=2;\n     a[0]=x;\n     a[1]=x;\n     a[2]=y;\n\t for(n=3;n<L;n++)\n\t {  \n\t\t a[n]=a[n-1]+a[n-2];  \t\n\t }\n       for(n=0;n<L;n++)\n     {\n         printf(\"%d \",a[n]);\n     }\n     system(\"pause\");\n     return 0;\n}\nPython Lambda 遞迴版:\nfib = lambda n: n if n<2 else fib(n-1) + fib(n-2)\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的程式參考", "Tag": "算法设计"}
{"Answer": "KNUTH, D. E. 1997. The Art of Computer ProgrammingArt of Computer Programming, Volume 1: Fundamental Algorithms, Third Edition. Addison-Wesley. Chapter 1.2.8.\nArakelian, Hrant (2014). Mathematics and History of the Golden Section. Logos, 404 p. ISBN 978-5-98704-663-0, (rus.)\n克裏福德A皮科夫.數學之戀.湖南科技出版社.", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的延伸閱讀", "Tag": "算法设计"}
{"Answer": "\n\n^ 斐波那契数列与组合数的一个关系及推广.   [2014-01-04]. （原始内容存档于2019-05-02）. \n\n^ Douady, S; Couder, Y. Phyllotaxis as a Dynamical Self Organizing Process (PDF). Journal of Theoretical Biology. 1996, 178 (3): 255–74. doi:10.1006/jtbi.1996.0026. （原始内容 (PDF)存档于2006-05-26）. \n\n^ Jones, Judy; Wilson, William. Science. An Incomplete Education. Ballantine Books. 2006: 544. ISBN 978-0-7394-7582-9. \n\n^ Brousseau, A. Fibonacci Statistics in Conifers. Fibonacci Quarterly（英语：Fibonacci Quarterly）. 1969, (7): 525–32. \n\n^ Marks for the da Vinci Code: B–, Maths (Computer Science For Fun: CS4FN),   [2022-10-30], （原始内容存档于2009-05-31） \n\n^ Scott, T.C.; Marketos, P., On the Origin of the Fibonacci Sequence (PDF), MacTutor History of Mathematics archive, University of St Andrews, 2014-03  [2022-10-30], （原始内容存档 (PDF)于2019-09-18） \n\n^ Livio 2003，第110頁.\n\n^ Livio 2003，第112–13頁.\n\n^ Varenne, Franck. Formaliser le vivant - Lois, Théories, Modèles. Hermann. 2010-11-16: 28  [2022-10-30]. ISBN 9782705678128. （原始内容存档于2022-10-30）. \n\n^ The Secret of the Fibonacci Sequence in Trees. 美國自然史博物館. 2011  [2019-02-04]. （原始内容存档于2013-05-04）. \n\n^ 11.0 11.1 11.2 李晨滔、馮勁敏. 費氏數列的性質整理 (PDF). 桃園縣立大園國際高中.   [2018-01-28]. （原始内容存档 (PDF)于2019-06-25）. \n\n^ Sloane, N.J.A. (编). Sequence A005478. The On-Line Encyclopedia of Integer Sequences. OEIS Foundation. \n\n^ Weisstein, Eric W. (编). Fibonacci Prime. at MathWorld--A Wolfram Web Resource. Wolfram Research, Inc. （英语）. \n\n^ Honsberger, Ross. Mathematical Gems III. AMS Dolciani Mathematical Expositions. 1985, (9): 133. ISBN 978-0-88385-318-4. \n\n^ JOHN H. E. COHN. Square Fibonacci Numbers, Etc.. Bedford College, University of London, London, N.W.1.   [2019-05-12]. （原始内容存档于2012-06-30）. Theorem 3. If Fn = x2, then n = 0, ±1, 2 or 12. \n\n^ Cohn, J. H. E., On square Fibonacci numbers, The Journal of the London Mathematical Society, 1964, 39: 537–540, MR 0163867, doi:10.1112/jlms/s1-39.1.537 \n\n^ Pethő, Attila. Diophantine properties of linear recursive sequences II. Acta Mathematica Academiae Paedagogicae Nyíregyháziensis. 2001, 17: 81–96. MR 1887650. \n\n^ Bugeaud, Y; Mignotte, M; Siksek, S. Classical and modular approaches to exponential Diophantine equations. I. Fibonacci and Lucas perfect powers. Ann. Math. 2006, 2 (163): 969–1018. Bibcode:2004math......3046B. MR 2215137. S2CID 10266596. arXiv:math/0403046 . doi:10.4007/annals.2006.163.969. \n\n^ Luo, Ming. On triangular Fibonacci numbers (PDF). Fibonacci Quart. 1989, 27 (2): 98–108  [2022-10-29]. MR 0995557. （原始内容存档 (PDF)于2022-10-29）. \n\n^ Luca, Florian. Perfect Fibonacci and Lucas numbers. Rendiconti del Circolo Matematico di Palermo. 2000, 49 (2): 313–18. ISSN 1973-4409. MR 1765401. S2CID 121789033. doi:10.1007/BF02904236. \n\n^ Broughan, Kevin A.; González, Marcos J.; Lewis, Ryan H.; Luca, Florian; Mejía Huguet, V. Janitzio; Togbé, Alain. There are no multiply-perfect Fibonacci numbers. Integers. 2011, 11a: A7  [2022-10-29]. MR 2988067. （原始内容存档于2022-01-23）. \n\n^ Luca, Florian; Mejía Huguet, V. Janitzio. On Perfect numbers which are ratios of two Fibonacci numbers. Annales Mathematicae at Informaticae. 2010, 37: 107–24. ISSN 1787-6117. MR 2753031. \n\n^ Sloane, N.J.A. (编). Sequence A001175. The On-Line Encyclopedia of Integer Sequences. OEIS Foundation. \n\n^ Freyd, Peter; Brown, Kevin S. Problems and Solutions: Solutions: E3410. The American Mathematical Monthly. 1993, 99 (3): 278–79. JSTOR 2325076. doi:10.2307/2325076. \n\n^ Knuth, Donald E. The Art of Computer Programming. 1: Fundamental Algorithms 3rd. Addison–Wesley. 1997: 343. ISBN 978-0-201-89683-1. \n\n^ Adelson-Velsky, Georgy; Landis, Evgenii. An algorithm for the organization of information. Proceedings of the USSR Academy of Sciences（英语：Proceedings of the USSR Academy of Sciences）. 1962, 146: 263–266 （俄语）.  Myron J. Ricci 的英文翻譯 （页面存档备份，存于互联网档案馆）載於 Soviet Mathematics - Doklady, 3:1259–1263, 1962.\n\nLivio, Mario. The Golden Ratio: The Story of Phi, the World's Most Astonishing Number First trade paperback. New York City: Broadway Books. 2003 [2002]  [2022-10-30]. ISBN 0-7679-0816-3. （原始内容存档于2023-03-13）. ", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的參考文獻", "Tag": "算法设计"}
{"Answer": "\n^ 1.0 1.1 這可以透過\n  \n    \n      \n        \n          φ\n          \n            2\n          \n        \n        =\n        1\n        +\n        φ\n      \n    \n    {\\displaystyle \\varphi ^{2}=1+\\varphi }\n  \n與\n  \n    \n      \n        \n          \n            1\n            φ\n          \n        \n        =\n        φ\n        −\n        1\n      \n    \n    {\\displaystyle {\\frac {1}{\\varphi }}=\\varphi -1}\n  \n與\n  \n    \n      \n        \n          \n            1\n            \n              1\n              −\n              φ\n            \n          \n        \n        =\n        −\n        φ\n      \n    \n    {\\displaystyle {\\frac {1}{1-\\varphi }}=-\\varphi }\n  \n此三個等式，以及費氏數列的的遞歸定義，以數學歸納法證明。\n\n^ 例如當\n  \n    \n      \n        (\n        m\n        ,\n        n\n        ,\n        k\n        )\n        =\n        (\n        4\n        ,\n        −\n        8\n        ,\n        6\n        )\n      \n    \n    {\\displaystyle (m,n,k)=(4,-8,6)}\n  \n時，\n  \n    \n      \n        \n          F\n          \n            −\n            8\n          \n        \n        \n          F\n          \n            −\n            2\n          \n        \n        −\n        \n          F\n          \n            4\n          \n        \n        \n          F\n          \n            −\n            14\n          \n        \n        =\n        (\n        −\n        21\n        )\n        ×\n        (\n        −\n        1\n        )\n        −\n        3\n        ×\n        (\n        −\n        377\n        )\n        =\n        (\n        −\n        1\n        \n          )\n          \n            −\n            14\n          \n        \n        \n          F\n          \n            12\n          \n        \n        \n          F\n          \n            6\n          \n        \n        =\n        1\n        ×\n        144\n        ×\n        8\n        =\n        1152\n      \n    \n    {\\displaystyle F_{-8}F_{-2}-F_{4}F_{-14}=(-21)\\times (-1)-3\\times (-377)=(-1)^{-14}F_{12}F_{6}=1\\times 144\\times 8=1152}\n  \n\n\n^ 亦即「頭尾兩項乘積」與「中間兩項乘積」恆相差1\n\n^ 利用指數律\n  \n    \n      \n        \n          φ\n          \n            m\n            +\n            n\n          \n        \n        =\n        \n          φ\n          \n            m\n          \n        \n        ×\n        \n          φ\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\varphi ^{m+n}=\\varphi ^{m}\\times \\varphi ^{n}}\n  \n、性質\n  \n    \n      \n        \n          φ\n          \n            2\n          \n        \n        =\n        1\n        +\n        φ\n      \n    \n    {\\displaystyle \\varphi ^{2}=1+\\varphi }\n  \n，以及「若\n  \n    \n      \n        a\n        ,\n        b\n        ,\n        c\n        ,\n        d\n      \n    \n    {\\displaystyle a,b,c,d}\n  \n是有理數，\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n是無理數，且滿足\n  \n    \n      \n        a\n        +\n        b\n        x\n        =\n        c\n        +\n        d\n        x\n      \n    \n    {\\displaystyle a+bx=c+dx}\n  \n，則\n  \n    \n      \n        a\n        =\n        c\n        ,\n        b\n        =\n        d\n      \n    \n    {\\displaystyle a=c,b=d}\n  \n」證明。\n\n", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的註釋", "Tag": "算法设计"}
{"Answer": "齊肯多夫定理", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的參見", "Tag": "算法设计"}
{"Answer": "費波那契數，孫智宏（pdf）\nPeriods of Fibonacci Sequences Mod m at MathPages\nScientists find clues to the formation of Fibonacci spirals in nature （页面存档备份，存于互联网档案馆）\n\nFibonacci Sequence，In Our Time (BBC Radio 4)（英语：BBC Radio 4）的《In Our Time》節目。(現在聆聽)\nHazewinkel, Michiel (编), Fibonacci numbers, 数学百科全书, Springer, 2001, ISBN 978-1-55608-010-4 ", "Konwledge_Point": "斐波那契数", "Question": "什么是斐波那契数的外部連結", "Tag": "算法设计"}
{"Answer": "素性测试或素数判定，是檢驗一個給定的整數是否為質數的测试。\n", "Konwledge_Point": "素性测试", "Question": "什么是素性测试", "Tag": "算法设计"}
{"Answer": "主条目：素数質數是除了自身和1以外，没有其它素数因子的自然数。自从欧几里得证明了有无穷个素数以后，人们就企图寻找一个可以构造所有素数的公式，寻找判定一个自然数是不是素数的方法。因为素数的地位非常重要。\n", "Konwledge_Point": "素性测试", "Question": "什么是素性测试的素数", "Tag": "算法设计"}
{"Answer": "鉴别一个自然数是素数还是合数，这个问题在中世纪就引起人们注意，当时人们试图寻找質数公式，到了高斯时代，基本上确认了简单的質数公式是不存在的，因此，高斯认为对素性判定是一个相当困难的问题。从此以后，这个问题吸引了大批数学家。\n質性判斷演算法可分為兩大類，確定性演算法及隨機演算法。前者可給出確定的結果但通常較慢，後者則反之。詳見以下列表。\n", "Konwledge_Point": "素性测试", "Question": "什么是素性测试的素数判定的历史", "Tag": "算法设计"}
{"Answer": "試除法（埃拉托斯特尼篩法）\n嘗試從 \n  \n    \n      \n        2\n      \n    \n    {\\displaystyle 2}\n  \n 到 \n  \n    \n      \n        \n          \n            N\n          \n        \n      \n    \n    {\\displaystyle {\\sqrt {N}}}\n  \n 的整數是否整除 \n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n。// 以 C 語言實現埃拉托斯特尼篩法\n// 用以判斷質數的 is_prime 副函式\nint is_prime(int x)\n{\n    if(x < 2) return 0;            // 1 不是質數，且不考慮負整數與 0，故輸入 x<=1 時回傳 0\n    for(int i = 2; i * i <= x; ++i)\n        if(x % i == 0) return 0;    // 一旦出現整除，回傳 0\n    return 1;                       // 迴圈跑完後都沒有整除，回傳 1\n}\n威尔逊定理\n当且仅当\n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n为質數时：\n  \n    \n      \n        (\n        p\n        −\n        1\n        )\n        !\n         \n        ≡\n         \n        −\n        1\n         \n        (\n        \n          \n            mod\n          \n        \n         \n        p\n        )\n      \n    \n    {\\displaystyle (p-1)!\\ \\equiv \\ -1\\ ({\\mbox{mod}}\\ p)}\n  \n卢卡斯-莱默检验法\nAKS質數測試\nPRIMES is in P這篇論文提到的方法，是第一個多項式時間的質數測試演算法。", "Konwledge_Point": "素性测试", "Question": "什么是素性测试的確定型演算法", "Tag": "算法设计"}
{"Answer": "费马素性检验\n利用費馬小定理來測試。\n米勒-拉賓檢驗\n歐拉-雅科比測試\n對於n，挑選随机的\n  \n    \n      \n        a\n        <\n        n\n      \n    \n    {\\displaystyle a<n}\n  \n，測試\n  \n    \n      \n        (\n        \n          \n            a\n            n\n          \n        \n        )\n        =\n        \n          a\n          \n            (\n            n\n            −\n            1\n            )\n            \n              /\n            \n            2\n          \n        \n        \n        mod\n        \n        \n        n\n      \n    \n    {\\displaystyle ({a \\over n})=a^{(n-1)/2}\\mod n}\n  \n，这里\n  \n    \n      \n        (\n        \n          \n            a\n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle ({a \\over n})}\n  \n为雅可比符号。如果N為質數，等式一定成立；如果N為合數，等式有一半的機率不成立。", "Konwledge_Point": "素性测试", "Question": "什么是素性测试的隨機演算法", "Tag": "算法设计"}
{"Answer": "素数公式\n费马小定理\n埃拉托斯特尼筛法\n卢卡斯-莱默检验法\n米勒-拉宾检验\n试除法\n费马素性检验\n孪生素数\n三胞胎素数\n四胞胎素数\n素数判定法则\n表兄弟素数\n六素数\nX²+1素数", "Konwledge_Point": "素性测试", "Question": "什么是素性测试的参见", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "素性测试", "Question": "什么是素性测试的外部链接", "Tag": "算法设计"}
{"Answer": "背包问题（英語：Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中，背包的空间有限，但我们需要最大化背包内所装物品的价值。背包问题通常出现在资源分配中，决策者必须分别从一组不可分割的项目或任务中进行选择，而这些项目又有时间或预算的限制。\n背包问题历史悠久，甚至可以追溯到1897年。[1]“背包问题”一词最早出现于数学家托拜厄斯·丹齐格的早期研究中，[2]他研究的问题是如何打包行李，要求最大化所选行李的价值且不能超载。\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题", "Tag": "算法设计"}
{"Answer": "背包问题出现在现实世界很多领域的决策过程中，诸如寻找节约原料的生产方式[3]、选择投资项目及投资组合[4]、选择证券化的资产[5]以及为默克尔-赫尔曼[6]和其他背包密码系统生成密钥。\n背包問題的一個早期應用是測驗編製與測驗賦分，受測試者可以選擇他們所需回答的問題。举个例子，受测者需要回答12道题，每道题10分，这时受测者只需要答对10道题就能得到满分100分。但是假如说每道题的赋分不同，问题的选择工作将会变得比较困难。对此，费尔曼和魏斯构建了一个系统，该系统分发给学生一张总分为125分且每道题赋分不等的考卷，学生则去尽力回答所有的问题。利用背包算法，可以算出每个学生可能获得的最高分数。[7]\n1999年石溪大学算法库的一项研究表明，在75个算法问题中，背包问题在最受欢迎的问题中排名第19，在最常用的问题中排名第三，仅次于后缀树和集装优化问题。[8]\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的应用", "Tag": "算法设计"}
{"Answer": "我们有n种物品，物品j的重量为wj，价格为pj。\n我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为W。\n如果限定每种物品只能选择0个或1个，则问题称为0-1背包问题。\n可以用公式表示为：\n最大化\n  \n    \n      \n        \n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          p\n          \n            j\n          \n        \n        \n        \n          x\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\qquad \\sum _{j=1}^{n}p_{j}\\,x_{j}}\n  \n\n受限于\n  \n    \n      \n        \n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          w\n          \n            j\n          \n        \n        \n        \n          x\n          \n            j\n          \n        \n         \n        ⩽\n         \n        W\n        ,\n        \n        \n        \n          x\n          \n            j\n          \n        \n         \n        ∈\n         \n        {\n        0\n        ,\n        1\n        }\n      \n    \n    {\\displaystyle \\qquad \\sum _{j=1}^{n}w_{j}\\,x_{j}\\ \\leqslant \\ W,\\quad \\quad x_{j}\\ \\in \\ \\{0,1\\}}\n  \n如果限定物品j最多只能选择bj个，则问题称为有界背包问题。\n可以用公式表示为：\n最大化\n  \n    \n      \n        \n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          p\n          \n            j\n          \n        \n        \n        \n          x\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\qquad \\sum _{j=1}^{n}p_{j}\\,x_{j}}\n  \n\n受限于\n  \n    \n      \n        \n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          w\n          \n            j\n          \n        \n        \n        \n          x\n          \n            j\n          \n        \n         \n        ⩽\n         \n        W\n        ,\n        \n        \n        \n          x\n          \n            j\n          \n        \n         \n        ∈\n         \n        {\n        0\n        ,\n        1\n        ,\n        …\n        ,\n        \n          b\n          \n            j\n          \n        \n        }\n      \n    \n    {\\displaystyle \\qquad \\sum _{j=1}^{n}w_{j}\\,x_{j}\\ \\leqslant \\ W,\\quad \\quad x_{j}\\ \\in \\ \\{0,1,\\ldots ,b_{j}\\}}\n  \n如果不限定每种物品的数量，则问题称为无界背包问题。\n各类复杂的背包问题总可以变换为简单的0-1背包问题进行求解。\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的定义", "Tag": "算法设计"}
{"Answer": "在计算机科学领域，人们对背包问题感兴趣的原因在于：\n利用动态规划，背包问题存在一个伪多项式时间算法\n把上面算法作为子程序，背包问题存在完全逼近多项式时间方案\n作为NP完全问题，背包问题没有一种既准确又快速（多项式时间）的算法", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的计算复杂度", "Tag": "算法设计"}
{"Answer": "无界背包问题[编辑]如果重量w1, ..., wn和W都是非负数，那么用动态规划，可以用伪多项式时间解决背包问题。下面描述了无界背包问题的解法。\n简便起见，我们假定重量都是正数（wj > 0）。在总重量不超过W的前提下，我们希望总价格最高。对于Y ≤ W，我们将在总重量不超过Y的前提下，总价格所能达到的最高值定义为A(Y)。A(W)即为问题的答案。\n显然，A(Y)满足：\nA(0) = 0\nA(Y) = max { A(Y - 1), { pj + A(Y - wj) | wj ≤ Y } }其中，pj为第j种物品的价格。\n关于第二个公式的一个解释：总重量为Y时背包的最高价值可能有两种情况，第一种是该重量无法被完全填满，这对应于表达式A(Y - 1)。第二种是刚好填满，这对应于一个包含一系列刚好填满的可能性的集合，其中的可能性是指当最后放进包中的物品恰好是重量为wj的物品时背包填满并达到最高价值。而这时的背包价值等于重量为wj物品的价值pj和当没有放入该物品时背包的最高价值之和。故归纳为表达式pj + A(Y - wj)。最后把所有上述情况中背包价值的最大值求出就得到了A(Y)的值。\n如果总重量为0，总价值也为0。然后依次计算A(0), A(1), ..., A(W)，并把每一步骤的结果存入表中供后续步骤使用，完成这些步骤后A(W)即为最终结果。由于每次计算A(Y)都需要检查n种物品，并且需要计算W个A(Y)值，因此动态规划解法的时间复杂度为O(nW)。如果把w1, ..., wn, W都除以它们的最大公因数，算法的时间将得到很大的提升。\n尽管背包问题的时间复杂度为O(nW)，但它仍然是一个NP完全问题。这是因为W同问题的输入大小并不成线性关系。原因在于问题的输入大小仅仅取决于表达输入所需的比特数。事实上，\n  \n    \n      \n        \n          ⌊\n          \n            l\n            o\n            \n              g\n              \n                2\n              \n            \n            W\n          \n          ⌋\n        \n        +\n        1\n      \n    \n    {\\displaystyle \\left\\lfloor log_{2}W\\right\\rfloor +1}\n  \n，即表达W所需的比特数，同问题的输入长度成线性关系。\n0-1背包问题[编辑]类似的方法可以解决0-1背包问题，算法同样需要伪多项式时间。我们同样假定\n  \n    \n      \n        \n          w\n          \n            1\n          \n        \n        ,\n        \n          w\n          \n            2\n          \n        \n        ,\n        …\n        ,\n        \n          w\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle w_{1},w_{2},\\dots ,w_{n}}\n  \n和\n  \n    \n      \n        W\n      \n    \n    {\\displaystyle W}\n  \n都是正整数。我们将在总重量不超过\n  \n    \n      \n        Y\n      \n    \n    {\\displaystyle Y}\n  \n的前提下，前\n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n种物品的总价格所能达到的最高值定义为\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n      \n    \n    {\\displaystyle A(j,Y)}\n  \n。\n\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n      \n    \n    {\\displaystyle A(j,Y)}\n  \n的递推关系为：\n\n  \n    \n      \n        A\n        (\n        0\n        ,\n        Y\n        )\n        =\n        0\n      \n    \n    {\\displaystyle A(0,Y)=0}\n  \n\n如果\n  \n    \n      \n        \n          w\n          \n            j\n          \n        \n        >\n        Y\n      \n    \n    {\\displaystyle w_{j}>Y}\n  \n，则\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n        =\n        A\n        (\n        j\n        −\n        1\n        ,\n        Y\n        )\n      \n    \n    {\\displaystyle A(j,Y)=A(j-1,Y)}\n  \n\n如果\n  \n    \n      \n        \n          w\n          \n            j\n          \n        \n        ≤\n        Y\n      \n    \n    {\\displaystyle w_{j}\\leq Y}\n  \n，则\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n        =\n        max\n        {\n        A\n        (\n        j\n        −\n        1\n        ,\n        Y\n        )\n        ,\n        \n          p\n          \n            j\n          \n        \n        +\n        A\n        (\n        j\n        −\n        1\n        ,\n        Y\n        −\n        \n          w\n          \n            j\n          \n        \n        )\n        }\n      \n    \n    {\\displaystyle A(j,Y)=\\max \\lbrace A(j-1,Y),p_{j}+A(j-1,Y-w_{j})\\rbrace }\n  \n通过计算\n  \n    \n      \n        A\n        (\n        n\n        ,\n        W\n        )\n      \n    \n    {\\displaystyle A(n,W)}\n  \n即得到最终结果。\n为提高算法性能，我们把先前计算的结果存入表中。因此算法需要的时间和空间都为\n  \n    \n      \n        O\n        (\n        n\n        W\n        )\n      \n    \n    {\\displaystyle O(nW)}\n  \n，通过对算法的改进，空间的消耗可以降至\n  \n    \n      \n        O\n        (\n        W\n        )\n      \n    \n    {\\displaystyle O(W)}\n  \n。\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的动态规划解法", "Tag": "算法设计"}
{"Answer": "如果重量w1, ..., wn和W都是非负数，那么用动态规划，可以用伪多项式时间解决背包问题。下面描述了无界背包问题的解法。\n简便起见，我们假定重量都是正数（wj > 0）。在总重量不超过W的前提下，我们希望总价格最高。对于Y ≤ W，我们将在总重量不超过Y的前提下，总价格所能达到的最高值定义为A(Y)。A(W)即为问题的答案。\n显然，A(Y)满足：\nA(0) = 0\nA(Y) = max { A(Y - 1), { pj + A(Y - wj) | wj ≤ Y } }其中，pj为第j种物品的价格。\n关于第二个公式的一个解释：总重量为Y时背包的最高价值可能有两种情况，第一种是该重量无法被完全填满，这对应于表达式A(Y - 1)。第二种是刚好填满，这对应于一个包含一系列刚好填满的可能性的集合，其中的可能性是指当最后放进包中的物品恰好是重量为wj的物品时背包填满并达到最高价值。而这时的背包价值等于重量为wj物品的价值pj和当没有放入该物品时背包的最高价值之和。故归纳为表达式pj + A(Y - wj)。最后把所有上述情况中背包价值的最大值求出就得到了A(Y)的值。\n如果总重量为0，总价值也为0。然后依次计算A(0), A(1), ..., A(W)，并把每一步骤的结果存入表中供后续步骤使用，完成这些步骤后A(W)即为最终结果。由于每次计算A(Y)都需要检查n种物品，并且需要计算W个A(Y)值，因此动态规划解法的时间复杂度为O(nW)。如果把w1, ..., wn, W都除以它们的最大公因数，算法的时间将得到很大的提升。\n尽管背包问题的时间复杂度为O(nW)，但它仍然是一个NP完全问题。这是因为W同问题的输入大小并不成线性关系。原因在于问题的输入大小仅仅取决于表达输入所需的比特数。事实上，\n  \n    \n      \n        \n          ⌊\n          \n            l\n            o\n            \n              g\n              \n                2\n              \n            \n            W\n          \n          ⌋\n        \n        +\n        1\n      \n    \n    {\\displaystyle \\left\\lfloor log_{2}W\\right\\rfloor +1}\n  \n，即表达W所需的比特数，同问题的输入长度成线性关系。\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的动态规划解法的无界背包问题", "Tag": "算法设计"}
{"Answer": "类似的方法可以解决0-1背包问题，算法同样需要伪多项式时间。我们同样假定\n  \n    \n      \n        \n          w\n          \n            1\n          \n        \n        ,\n        \n          w\n          \n            2\n          \n        \n        ,\n        …\n        ,\n        \n          w\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle w_{1},w_{2},\\dots ,w_{n}}\n  \n和\n  \n    \n      \n        W\n      \n    \n    {\\displaystyle W}\n  \n都是正整数。我们将在总重量不超过\n  \n    \n      \n        Y\n      \n    \n    {\\displaystyle Y}\n  \n的前提下，前\n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n种物品的总价格所能达到的最高值定义为\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n      \n    \n    {\\displaystyle A(j,Y)}\n  \n。\n\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n      \n    \n    {\\displaystyle A(j,Y)}\n  \n的递推关系为：\n\n  \n    \n      \n        A\n        (\n        0\n        ,\n        Y\n        )\n        =\n        0\n      \n    \n    {\\displaystyle A(0,Y)=0}\n  \n\n如果\n  \n    \n      \n        \n          w\n          \n            j\n          \n        \n        >\n        Y\n      \n    \n    {\\displaystyle w_{j}>Y}\n  \n，则\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n        =\n        A\n        (\n        j\n        −\n        1\n        ,\n        Y\n        )\n      \n    \n    {\\displaystyle A(j,Y)=A(j-1,Y)}\n  \n\n如果\n  \n    \n      \n        \n          w\n          \n            j\n          \n        \n        ≤\n        Y\n      \n    \n    {\\displaystyle w_{j}\\leq Y}\n  \n，则\n  \n    \n      \n        A\n        (\n        j\n        ,\n        Y\n        )\n        =\n        max\n        {\n        A\n        (\n        j\n        −\n        1\n        ,\n        Y\n        )\n        ,\n        \n          p\n          \n            j\n          \n        \n        +\n        A\n        (\n        j\n        −\n        1\n        ,\n        Y\n        −\n        \n          w\n          \n            j\n          \n        \n        )\n        }\n      \n    \n    {\\displaystyle A(j,Y)=\\max \\lbrace A(j-1,Y),p_{j}+A(j-1,Y-w_{j})\\rbrace }\n  \n通过计算\n  \n    \n      \n        A\n        (\n        n\n        ,\n        W\n        )\n      \n    \n    {\\displaystyle A(n,W)}\n  \n即得到最终结果。\n为提高算法性能，我们把先前计算的结果存入表中。因此算法需要的时间和空间都为\n  \n    \n      \n        O\n        (\n        n\n        W\n        )\n      \n    \n    {\\displaystyle O(nW)}\n  \n，通过对算法的改进，空间的消耗可以降至\n  \n    \n      \n        O\n        (\n        W\n        )\n      \n    \n    {\\displaystyle O(W)}\n  \n。\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的动态规划解法的0-1背包问题", "Tag": "算法设计"}
{"Answer": "推广的背包问题有二次背包问题、多维背包问题、多目标背包问题等。\n二次背包问题是背包问题的一种推广形式：\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的二次背包问题", "Tag": "算法设计"}
{"Answer": "\n\n^ Mathews, G. B. On the partition of numbers (PDF). Proceedings of the London Mathematical Society. 1897-06-25, 28: 486–490  [2022-05-05]. doi:10.1112/plms/s1-28.1.486. （原始内容 (PDF)存档于2012-05-26）. \n\n^ Dantzig, Tobias. Number : the language of science The Masterpiece Science. New York: Plume Book. 2007. ISBN 9780452288119. \n\n^ Kellerer, Hans; Pferschy, Ulrich; Pisinger, David. Knapsack problems. Berlin: Springer. 2004: 449  [2022-05-05]. ISBN 978-3-540-40286-2. \n\n^ Kellerer, Hans; Pferschy, Ulrich; Pisinger, David. Knapsack problems. Berlin: Springer. 2004: 461  [2022-05-05]. ISBN 978-3-540-40286-2. \n\n^ Kellerer, Hans; Pferschy, Ulrich; Pisinger, David. Knapsack problems. Berlin: Springer. 2004: 465  [2022-05-05]. ISBN 978-3-540-40286-2. \n\n^ Kellerer, Hans; Pferschy, Ulrich; Pisinger, David. Knapsack problems. Berlin: Springer. 2004: 472  [2022-05-05]. ISBN 978-3-540-40286-2. \n\n^ Feuerman, Martin; Weiss, Harvey. A Mathematical Programming Model for Test Construction and Scoring. Management Science. April 1973, 19 (8): 961–966. JSTOR 2629127. doi:10.1287/mnsc.19.8.961. \n\n^ Skiena, S. S. Who is Interested in Algorithms and Why? Lessons from the Stony Brook Algorithm Repository. ACM SIGACT News. September 1999, 30 (3): 65–74. CiteSeerX 10.1.1.41.8357 . ISSN 0163-5700. S2CID 15619060. doi:10.1145/333623.333627. \n\n", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的参考文献", "Tag": "算法设计"}
{"Answer": "二次背包问题源代码链接 （页面存档备份，存于互联网档案馆）", "Konwledge_Point": "背包问题", "Question": "什么是背包问题的外部链接", "Tag": "算法设计"}
{"Answer": "猜數字是一种益智游戏，遊戲人數為兩人，或一人與一個運算機器。\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B", "Tag": "算法设计"}
{"Answer": "一個人設定一組四碼的数字作為謎底，另一方猜。每猜一个数，出数者就要根据这个数字给出提示，提示以XAYB形式呈現，直到猜中為止。其中X表示位置正确的数的个数，而Y表示数字正确而位置不对的数的个数。\n例如，當謎底為8123，而猜謎者猜1052時，出題者必須提示0A2B。\n例如，當謎底為5637，而猜謎者猜4931時，出題者必須提示1A0B。\n含重复数字的猜数字[编辑]有一种使用范围比较狭窄的猜数字，是允许重复数字存在的猜数字，但由于其规则较复杂，故没有得到广泛的推广。其规则如下：\n除了上面的规则外，如果有出现重复的数字，则重复的数字每个也只能算一次，且以最优的结果为准，\n如正确答案为5543，猜的人猜5255，则在这里不能认为猜测的第一个5对正确答案第二个，根据最优结果为准的原理和每个数字只能有一次的规则，两个比较后应该为1A1B，第一个5位置正确，记为1A；猜测数字中的第三个5或第四个5和答案的第二个5匹配，只能记为1B。当然，如果有猜5267中的第一个5不能与答案中的第二个5匹配，因此只能记作1A0B。\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的玩法", "Tag": "算法设计"}
{"Answer": "有一种使用范围比较狭窄的猜数字，是允许重复数字存在的猜数字，但由于其规则较复杂，故没有得到广泛的推广。其规则如下：\n除了上面的规则外，如果有出现重复的数字，则重复的数字每个也只能算一次，且以最优的结果为准，\n如正确答案为5543，猜的人猜5255，则在这里不能认为猜测的第一个5对正确答案第二个，根据最优结果为准的原理和每个数字只能有一次的规则，两个比较后应该为1A1B，第一个5位置正确，记为1A；猜测数字中的第三个5或第四个5和答案的第二个5匹配，只能记为1B。当然，如果有猜5267中的第一个5不能与答案中的第二个5匹配，因此只能记作1A0B。\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的玩法的含重复数字的猜数字", "Tag": "算法设计"}
{"Answer": "對於第一種玩法而言，有以下的解法：\n计算机解[编辑]通常采用的计算机解是通过排除法，即遍历所有可能的数，将不符合要求的数剃掉。[1]\n下面是一个计算机处理的例子：\nfor (int i = 0; i < Array.Count; i++) \n{\n    if (请求提示(Array[i]) == 全A)\n        return Array[i];\n}\n这个代码采用C#的语法，其中Array表示所有可能的数字的集合。这个例子为了方便说明，结合了语言的描述。\n这样的方法充分利用了计算机计算速度快的优势，使用穷举法，并不进行推理。数字越长猜测时间越长。\n推理解[编辑]计算机解是根据这种方法推广的。这种解法的中心思想是假设猜的这个数字是正确答案，即如果它为正确答案，那么这个数应该符合已经猜测的数及其结果。如已经有\n1234 0A0B\n那么下一步就不能猜含有1234中任一数字的数，因为如果正确答案含1234中任一數字；則出題者不會說1234是0A0B。\n再假設如果出題者說 5678 是 0A1B 的話，則正確答案必須只包含5、6、7、8其中僅僅一個數字，且如果有5、6、7、8的話，5的位置必須不在(左邊數起)第一個位置、6的位置必須不在(左邊數起)第二個位置、7的位置必須不在(左邊數起)第三個位置、8的位置必須不在(左邊數起)第四個位置。\n再假設如果出題者說 1357 是 1A0B 的話，則正確答案必須只包含1、3、5、7其中僅僅一個數字，且如果有1、3、5、7的話，1的位置必須在(左邊數起)第一個位置、3的位置必須在(左邊數起)第二個位置、5的位置必須在(左邊數起)第三個位置、7的位置必須在(左邊數起)第四個位置。\n基于这个解法，根据个人思维风格和起始数字选择的不同，以及对出题者出数风格的猜测，經過一些計算機程式的大量模擬，猜到答案的平均次數大約為5.3次。顯然地，如果運氣夠好，有機會可以在一次、兩次猜到答案；運氣不好之時，花費八次猜測才找到答案也不無可能。\n使用这种解法需要考虑的时间很久，不是很適合人們使用；特別是在限時賽中，人們很難檢視所有可能的候選答案，然後選擇其中最佳者。事實上，有興趣的數學研究者，提出一種證明方法，證明了四位數(數字不重複、零可以開頭)的猜數字遊戲，在最佳狀況下，可以用至多七次的猜測找到對手的答案，而平均來說，只要花5.2131次的猜測來完成一次的遊戲。[2][3]\n代入解[编辑]即在推理出不可能的數字後，將餘下可能的數字依序帶入。\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的解法", "Tag": "算法设计"}
{"Answer": "通常采用的计算机解是通过排除法，即遍历所有可能的数，将不符合要求的数剃掉。[1]\n下面是一个计算机处理的例子：\nfor (int i = 0; i < Array.Count; i++) \n{\n    if (请求提示(Array[i]) == 全A)\n        return Array[i];\n}\n这个代码采用C#的语法，其中Array表示所有可能的数字的集合。这个例子为了方便说明，结合了语言的描述。\n这样的方法充分利用了计算机计算速度快的优势，使用穷举法，并不进行推理。数字越长猜测时间越长。\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的解法的计算机解", "Tag": "算法设计"}
{"Answer": "计算机解是根据这种方法推广的。这种解法的中心思想是假设猜的这个数字是正确答案，即如果它为正确答案，那么这个数应该符合已经猜测的数及其结果。如已经有\n1234 0A0B\n那么下一步就不能猜含有1234中任一数字的数，因为如果正确答案含1234中任一數字；則出題者不會說1234是0A0B。\n再假設如果出題者說 5678 是 0A1B 的話，則正確答案必須只包含5、6、7、8其中僅僅一個數字，且如果有5、6、7、8的話，5的位置必須不在(左邊數起)第一個位置、6的位置必須不在(左邊數起)第二個位置、7的位置必須不在(左邊數起)第三個位置、8的位置必須不在(左邊數起)第四個位置。\n再假設如果出題者說 1357 是 1A0B 的話，則正確答案必須只包含1、3、5、7其中僅僅一個數字，且如果有1、3、5、7的話，1的位置必須在(左邊數起)第一個位置、3的位置必須在(左邊數起)第二個位置、5的位置必須在(左邊數起)第三個位置、7的位置必須在(左邊數起)第四個位置。\n基于这个解法，根据个人思维风格和起始数字选择的不同，以及对出题者出数风格的猜测，經過一些計算機程式的大量模擬，猜到答案的平均次數大約為5.3次。顯然地，如果運氣夠好，有機會可以在一次、兩次猜到答案；運氣不好之時，花費八次猜測才找到答案也不無可能。\n使用这种解法需要考虑的时间很久，不是很適合人們使用；特別是在限時賽中，人們很難檢視所有可能的候選答案，然後選擇其中最佳者。事實上，有興趣的數學研究者，提出一種證明方法，證明了四位數(數字不重複、零可以開頭)的猜數字遊戲，在最佳狀況下，可以用至多七次的猜測找到對手的答案，而平均來說，只要花5.2131次的猜測來完成一次的遊戲。[2][3]\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的解法的推理解", "Tag": "算法设计"}
{"Answer": "即在推理出不可能的數字後，將餘下可能的數字依序帶入。\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的解法的代入解", "Tag": "算法设计"}
{"Answer": "\n\n^ 電腦(1A2B)猜數字遊戲的策略. 陳麒全、林新富、陳鴻宜.   [2021-08-20]. （原始内容存档于2021-08-20）. \n\n^ Optimal algorithms for bulls and cows game. (PDF).   [2012-08-17]. （原始内容存档 (PDF)于2013-05-20）. \n\n^ http://www.cs.nccu.edu.tw/~chaolin/papers/science3203.pdf （页面存档备份，存于互联网档案馆） 劉昭麟. 數學、資訊科學與數字遊戲, 科學月刊，第32卷第3期，第250到255頁， 財團法人臺北市科學出版事業基金會,2001.\n\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的參考資料", "Tag": "算法设计"}
{"Answer": "著名的桌上遊戲Master Mind （页面存档备份，存于互联网档案馆）（珠機妙算），就是這種遊戲形式的實物道具版本，只是把所要猜的由數字改為顏色。\n", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的其他", "Tag": "算法设计"}
{"Answer": "游戏\n智力游戏\n人工智能\nMastermind", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的参看", "Tag": "算法设计"}
{"Answer": "4digits，开源的猜数字游戏 （页面存档备份，存于互联网档案馆）\nMaster Mind式樣 （页面存档备份，存于互联网档案馆）", "Konwledge_Point": "1A2B", "Question": "什么是1A2B的外部連結", "Tag": "算法设计"}
{"Answer": "零和博弈，又称零和游戏或零和赛局，（英語：Zero-sum game）与非零和博弈相对，是博弈论的一个概念，属非合作博弈。零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有所得，其他方必有所失。在零和博弈中，博弈各方是不合作的。非零和博弈表示在不同策略组合下各博弈方的得益之和是不确定的变量，故又称之为变和博弈。如果某些战略的选取可以使各方利益之和变大，同时又能使各方的利益得到增加，那么，就可能出现参加方相互合作的局面。因此，非零和博弈中，博弈各方存在合作的可能性。国际经济中许多问题都属于非零和博弈问题，即国际经济中各方的利益并不是必然相互冲突的。零和博弈的例子有賭博、期貨和選舉等。\n", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈", "Tag": "算法设计"}
{"Answer": "在零和屬性（如果我方得益，敵方必然蒙受損失）下，是指結果是零和的情況下會出現帕累托最優的現象[1]。反過來說，全體參加者可得益或受損的情況被稱為非零和博弈。如果一個國家利用其過剩的香蕉與另一國家剩餘的蘋果進行貿易，因為兩方都從交易中受惠，這是一個非零和的例子。\n這個概念最早是在博弈論（game theory）上發展，因此零和情況通常被稱為零和遊戲（zero-sum game）。\n", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的定義", "Tag": "算法设计"}
{"Answer": "在一個有限零和遊戲之中，不同的博弈理論如納什均衡和極小化極大算法都給予同樣的解決辦法。玩家需使用一個混合策略。\n範例[编辑]", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的解決方案", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的解決方案的範例", "Tag": "算法设计"}
{"Answer": "主条目：非零和博弈經濟學[编辑]許多經濟形勢並不是零和博弈，由於有價值的商品和服務可以創建、銷毀或分配，以上任何一種狀況將創造一個淨損失或得益。假設對手的行為是合理的，任何商業交易都是非零和博弈，因為每一方必須考慮它接受的貨物是比它交付的商品更有價值。經濟交流必須對交易雙方有利，而且不能是零和博弈，這樣每一方都可以克服各自的交易成本。\n心理學[编辑]最常見的例子就是社會心理學中的社會陷阱，在某些情況下，我們可以追求個人的利益，從而加強我們的集體幸福。\n", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的非零和博弈", "Tag": "算法设计"}
{"Answer": "許多經濟形勢並不是零和博弈，由於有價值的商品和服務可以創建、銷毀或分配，以上任何一種狀況將創造一個淨損失或得益。假設對手的行為是合理的，任何商業交易都是非零和博弈，因為每一方必須考慮它接受的貨物是比它交付的商品更有價值。經濟交流必須對交易雙方有利，而且不能是零和博弈，這樣每一方都可以克服各自的交易成本。\n", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的非零和博弈的經濟學", "Tag": "算法设计"}
{"Answer": "最常見的例子就是社會心理學中的社會陷阱，在某些情況下，我們可以追求個人的利益，從而加強我們的集體幸福。\n", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的非零和博弈的心理學", "Tag": "算法设计"}
{"Answer": "在幽默的範疇裏，零和博弈被引申為「快樂守恒定律」（Conservation of Happiness），意思是「有人快樂，就必定有人失落」，也就是「快樂必須要建築於別人的痛苦身上」。\n", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的引申", "Tag": "算法设计"}
{"Answer": "\n\n^ Samuel Bowles: Microeconomics: Behavior, Institutions, and Evolution, Princeton University Press, pp. 33–36 (2004) ISBN 0691091633\n\n", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的参考文献", "Tag": "算法设计"}
{"Answer": "雙贏\n策略聯盟\n絕對利益\n比較優勢\n自由貿易", "Konwledge_Point": "零和博弈", "Question": "什么是零和博弈的参见", "Tag": "算法设计"}
{"Answer": "在人工智能中，搜索问题一般包括两个重要的问题：\n搜索什么：通常指目标\n在哪里搜索：即搜索空间，通常指一系列状态的汇集，因此也称为状态空间", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)", "Tag": "算法设计"}
{"Answer": "按是否使用啟發式信息分\n啟發式搜索\n盲目搜索按问题的表示方式分\n状态空间搜索\n与/或树搜索", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索方式", "Tag": "算法设计"}
{"Answer": "宽度优先搜索[编辑]宽度优先搜索算法是沿着树的宽度遍历树的节点，如果发现目标，则算法中止。属于盲目搜索。\n深度优先搜索[编辑]深度优先搜索沿着树的最大深度方向生成节点并与目标节点进行比较，只有当上次访问的节点不是目标节点，而且没有其他节点可以生成的时候，才转到上次访问节点的父节点，然后搜索该节点的其他子节点。因此深度优先搜索也称为回溯搜索。它既不是完备的，也不是最优的。有时候，某些特定的问题会产生大量重复的节点。例如“八数码”问题就是这样的，当每次运用向上、向下、向左、向右移动空格的算符时，可能产生与已经产生的节点重复的节点。当再次搜索到这个重复节点时，由于应用的算符基本一致，还会产生重复，所以为了节约时间和存储空间，往往在深度优先算法中设立一个机制，用来删除这些重复的节点，以提高效率。\n迭代加深搜索（ID搜索）[编辑]对深度优先搜索进行了一定改进，对搜索树的深度进行控制，即有界深度优先搜索。\n在程序找到目标之前，通过迭代不断增大以保证完备性和最优性。虽然会有不少重复搜索，但是鉴于每增加一次d，则搜索的时间复杂度会以指数级别增加，所以重复搜索的时间可以忽略，亦可以与A*算法结合（即IDA*搜索算法）来剪枝。\n迭代加深搜索通常用于那种搜索树又深又宽、但是解并不是很深的情况，这时广度优先搜索会超空间，而深度优先搜索会超时。这时迭代加深搜索很有用，可是说是在用递归方法在实现广度优先搜索。\n啟發式OR图搜索算法[编辑]爬山算法\n模拟退火算法\n最好优先\n通用图\nA*AND-OR图啟發式搜索[编辑]一个特殊问题：博弈论\n约束满足搜索[编辑]搜索策略还可以指在使用搜索引擎中所使用的策略，它通常是搜索之母，一个好的搜索过程必定有一个好的搜索策略来支持。\n", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索策略", "Tag": "算法设计"}
{"Answer": "宽度优先搜索算法是沿着树的宽度遍历树的节点，如果发现目标，则算法中止。属于盲目搜索。\n", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索策略的宽度优先搜索", "Tag": "算法设计"}
{"Answer": "深度优先搜索沿着树的最大深度方向生成节点并与目标节点进行比较，只有当上次访问的节点不是目标节点，而且没有其他节点可以生成的时候，才转到上次访问节点的父节点，然后搜索该节点的其他子节点。因此深度优先搜索也称为回溯搜索。它既不是完备的，也不是最优的。有时候，某些特定的问题会产生大量重复的节点。例如“八数码”问题就是这样的，当每次运用向上、向下、向左、向右移动空格的算符时，可能产生与已经产生的节点重复的节点。当再次搜索到这个重复节点时，由于应用的算符基本一致，还会产生重复，所以为了节约时间和存储空间，往往在深度优先算法中设立一个机制，用来删除这些重复的节点，以提高效率。\n", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索策略的深度优先搜索", "Tag": "算法设计"}
{"Answer": "对深度优先搜索进行了一定改进，对搜索树的深度进行控制，即有界深度优先搜索。\n在程序找到目标之前，通过迭代不断增大以保证完备性和最优性。虽然会有不少重复搜索，但是鉴于每增加一次d，则搜索的时间复杂度会以指数级别增加，所以重复搜索的时间可以忽略，亦可以与A*算法结合（即IDA*搜索算法）来剪枝。\n迭代加深搜索通常用于那种搜索树又深又宽、但是解并不是很深的情况，这时广度优先搜索会超空间，而深度优先搜索会超时。这时迭代加深搜索很有用，可是说是在用递归方法在实现广度优先搜索。\n", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索策略的迭代加深搜索（ID搜索）", "Tag": "算法设计"}
{"Answer": "爬山算法\n模拟退火算法\n最好优先\n通用图\nA*", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索策略的啟發式OR图搜索算法", "Tag": "算法设计"}
{"Answer": "一个特殊问题：博弈论\n", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索策略的AND-OR图啟發式搜索", "Tag": "算法设计"}
{"Answer": "搜索策略还可以指在使用搜索引擎中所使用的策略，它通常是搜索之母，一个好的搜索过程必定有一个好的搜索策略来支持。\n", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的搜索策略的约束满足搜索", "Tag": "算法设计"}
{"Answer": "完备性\n时间复杂性\n空间复杂性\n最优性", "Konwledge_Point": "搜索 (计算机)", "Question": "什么是搜索 (计算机)的评价准则", "Tag": "算法设计"}
{"Answer": "《算法少女》（日语：算法少女／さんぽうしょうじょ Sanpō shōjo */?），是一本出版于1775年（安永4年）的和算书籍。本书是日本传统算学书籍中唯一一本以女性名义编写的。\n本书在日本国立国会图书馆有扫描本公开[2]。在1935年曾由古典数学书院发行誊写版[3]。2009年筑摩书房出版了《阅读和算书“算法少女”》，其中收录了《算法少女》原文的影印版以及现代日语翻译、解法的解说[4]。\n以本书为题材，儿童文学作家远藤宽子（日语：遠藤寛子 (作家)）创作了同名小说《算法少女（日语：算法少女 (小説)）》。[5][6]\n", "Konwledge_Point": "算法少女", "Question": "什么是算法少女", "Tag": "算法设计"}
{"Answer": "根据本书的序文，本书是在父亲的协助下由女儿编写的，使用了笔名。父亲自称壶中隐者，俳人谷素外（日语：谷素外）所写后记中称其为“医师平氏”，女儿署名平氏，印章为“章子”[2][4]。当时的和算书籍常常是以弟子的名义发表老师的研究内容，故而可以推断本书事实上的作者应该是壶中隐者[7]。不过也有观点认为，本书实际作者是女儿章子。不论如何，本书作为仅有的一本作者为女性的古代和算书籍[8][9]，在日本文化史上也是有贵重价值的。[1]:21\n壶中隐者的身份在本书刊行后一个半世纪中并不为人所知，但在1930年代确认为医师千叶桃三[7][10]:517,518[11]:583。\n", "Konwledge_Point": "算法少女", "Question": "什么是算法少女的作者", "Tag": "算法设计"}
{"Answer": "  中篇第三问本书以文言文和日文书写。分为序言（父、女）、圆周率的历史、正文（上、中、下）、圆周率求法、后记5部分。其中序言中父亲名义的部分、圆周率历史的最后部分、正文的中篇、圆周率求法为文言文写成，其余部分为日文[2]。大体上文言文的部分为以父亲名义所写，日文的部分为女儿名义[1]:21。\n书中以女儿名义记述了父亲进行数学研究的履历、当时大阪数学界的情况以及自己向父亲学习数学的情形。[1]:21,22\n书中提到了圆周率的值和求解方法。古时认为圆周率为3。之后是3.16。进而是更精确的355/113，该值的求法是在圆里内接正四边形、正八边形、正十六边形……直到正十余万边形，并写明该算法出自关孝和的《括要算法》。最后书中给出了一种不通过内接正多边形，直接求圆周率值的方法。壶中隐者称此术玄妙，为了避免像古人一样“人死技绝”，故而著书立说“与天下后世共之也”[2]。[1]:22\n", "Konwledge_Point": "算法少女", "Question": "什么是算法少女的内容", "Tag": "算法设计"}
{"Answer": "本书出版后16年，1791（宽政3年），数学家藤田贞资（日语：藤田貞資）撰写了《算法少女之评》[12]一文批评《算法少女》。他认为，书中所述圆周率的求法抄袭自有马赖徸著于1769年的和算书《拾玑算法》。[1]:23[a]\n数学家会田安明在1804年的《算法约术三条之题》[15]中认为《算法少女》书中的圆周率求法并非抄袭自《拾玑算法》。[1]:23\n", "Konwledge_Point": "算法少女", "Question": "什么是算法少女的和算家的评论", "Tag": "算法设计"}
{"Answer": "以本书为题材，儿童文学作家远藤宽子（日语：遠藤寛子 (作家)）于1973年发表了同名小说《算法少女（日语：算法少女 (小説)）》，并于次年获得了产经儿童出版文化奖[16]。小说的主人公设定为本书的写作者，书中名为“千葉あき”（罗马字：Chiba Aki），あき为“章”字的训读[1]:21。\n小说《算法少女》又进一步被改编为同名漫画和动画。漫画《算法少女》连载于2010-2014年，于2012年发行单行本1卷[17]。动画《算法少女》制作始于2009年，在2016年发布[18][19]。\n", "Konwledge_Point": "算法少女", "Question": "什么是算法少女的衍生作品", "Tag": "算法设计"}
{"Answer": "\n\n^ 藤田贞资曾经是有马赖徸的家臣，受其资助[13]:91,92[14]\n\n\n", "Konwledge_Point": "算法少女", "Question": "什么是算法少女的注释", "Tag": "算法设计"}
{"Answer": "\n\n^ 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 遠藤寛子. 日本数学協会 , 编. 『算法少女』という本のこと. 数学文化 (日本評論社). 2005, 4. ISBN 978-4535602342. NCID AA11860695. \n\n^ 2.0 2.1 2.2 2.3 千葉桃三（撰）; 千叶章子（编）. 算法少女. 山崎金兵衛. 1775. \n\n^ 千葉桃三（撰）; 千叶章子（编）. 算法少女. 古典数学書院. 1935. NCID BA66006260. \n\n^ 4.0 4.1 小寺裕（日语：小寺裕）. 和算書「算法少女」を読む. ちくま学芸文庫 Math&Science. 筑摩書房. 2009-11-10. ISBN 978-4-480-09255-7. NCID BB00152043. \n\n^ 遠藤寛子; 箕田源二郎（插图）. 算法少女. 少年少女歴史小説シリーズ. 岩崎書店. 1973: 211. ISBN 4-265-93009-3. NCID BN1298899X. \n\n^ 遠藤寛子; 箕田源二郎（插图）. 算法少女. ちくま学芸文庫 Math & Science. 筑摩書房. 2006: 272. ISBN 4-480-09013-4. NCID BA78052163. \n\n^ 7.0 7.1 三上義夫. 算法少女著者考. 東京物理学校雑誌 (東京物理学校同窓会). 1934,. 506,507. NCID AN00164413. \n\n^ 三上義夫. 数学史叢話. 共立社. 1934. NCID BA47067927. \n\n^ 遠藤寛子. 「算法少女」この不思議の書をめぐって. Webちくま. （原始内容存档于2017-02-27）. \n\n^ 藤原松三郎. 明治前日本数学史 5. 日本学士院日本科学史刊行会. 1960. NCID BA43511151. \n\n^ 藤原松三郎（日语：藤原松三郎）. 明治前日本数学史 4. 日本学士院日本科学史刊行会. 1959. NCID BA43511151. \n\n^ 藤田貞資. 算法少女之評. 古典数学書院（誊写）. 1938. NCID BA65948153. \n\n^ 藤原松三郎. 明治前日本數學史 2. 日本学士院日本科学史刊行会. 1956. NCID BA43511151. \n\n^ 世界大百科事典 第２版 有馬頼徸. 株式会社平凡社. （原始内容存档于2018-03-28）. \n\n^ 会田安明. 算法約術三條之題 下. 1804. \n\n^ 過去の受賞作品. 産経新聞. （原始内容存档于2018-01-02）. \n\n^ 算法少女. リイド社.   [2018-06-14]. ISBN 9784845842100. NCID BB1092551X. \n\n^ Production Note. 赤の女王. （原始内容存档于2018-02-04）. \n\n^ 算法少女. TSUTAYA. （原始内容存档于2018年5月25日）. \n\n", "Konwledge_Point": "算法少女", "Question": "什么是算法少女的参考来源", "Tag": "算法设计"}
{"Answer": "网站和算序林上的《算法少女》序、跋原文及汉文序言的现代日文翻译（存档版）\nGoolge Books提供的部分《算法少女》漫画内容", "Konwledge_Point": "算法少女", "Question": "什么是算法少女的外部链接", "Tag": "算法设计"}
{"Answer": "在有向图的数学理论中，如果一个图的每一个顶点都可从该图其他任意一点到达，则称该图是强连通的。在任意有向图中能够实现强连通的部分我们称其为强连通分量。判断一个图是否为强连通以及找到一个图强连通分量只需要线性时间（Θ(V + E)）。\n", "Konwledge_Point": "强连通分量", "Question": "什么是强连通分量", "Tag": "算法设计"}
{"Answer": "如果有向图的每一对顶点之间在每个方向上都有一条路径，则称该有向图为强连通图。也就是说，顶点对中的第一个顶点到第二个顶点存在一条路径，从第二个顶点到第一个顶点存在另一条路径。在本身可能不是强连通的有向图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中，如果一对顶点\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n和\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n之间在每个方向上都有一条路径，则称它们是强连通的。\n强连通的二元关系是一个等价关系，其等价类的导出子图称为强连通分量。同样地，有向图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的强连通分量是一个强连通的子图，并且在这个子图上是最大的，这意味着在不破坏\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的强连通特性的情况下，任何来自\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的额外边或顶点都不能包含在子图中。强连通分量的集合构成了\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n的顶点集的一个子集。\n  黄色有向无环图是通过将蓝色有向图的每个强连通分量压缩成一个单一的黄色顶点而形成的如果将每个强连通分量收缩为单个顶点，则得到的图是一个有向无环图。当且仅当有向图不包含具有多个顶点的强连通子图时，它就是无环的，这是因为如果有向图是强连通的，则每个非单调强连通分量至少包含一个有向环。\n", "Konwledge_Point": "强连通分量", "Question": "什么是强连通分量的定义", "Tag": "算法设计"}
{"Answer": "基于DFS的线性时间算法[编辑]几种基于深度优先搜索并能在线性时间内计算强连通分量的算法。\nKosaraju算法使用了两次深度优先搜索。在原始图中，第一次搜索用于决定第二个深度优先搜索的外层循环的顺序，该循环测试已经访问过的顶点，如果没有，则用递归的手段搜索它们。第二次深度优先搜索是在原始图的转置图上进行，每个递归搜索都能找到一个新的强连通分量。[1]这种算法以其首次提出者S·拉奥·科萨拉朱（英语：S. Rao Kosaraju）的名字命名，但是并没有被发表，直到1981年才被米查·沙里尔发表。[2]\nTarjan演算法:由羅伯特·塔揚于1972年发表[3]，是一种深度优先搜索方式。", "Konwledge_Point": "强连通分量", "Question": "什么是强连通分量的算法", "Tag": "算法设计"}
{"Answer": "几种基于深度优先搜索并能在线性时间内计算强连通分量的算法。\nKosaraju算法使用了两次深度优先搜索。在原始图中，第一次搜索用于决定第二个深度优先搜索的外层循环的顺序，该循环测试已经访问过的顶点，如果没有，则用递归的手段搜索它们。第二次深度优先搜索是在原始图的转置图上进行，每个递归搜索都能找到一个新的强连通分量。[1]这种算法以其首次提出者S·拉奥·科萨拉朱（英语：S. Rao Kosaraju）的名字命名，但是并没有被发表，直到1981年才被米查·沙里尔发表。[2]\nTarjan演算法:由羅伯特·塔揚于1972年发表[3]，是一种深度优先搜索方式。", "Konwledge_Point": "强连通分量", "Question": "什么是强连通分量的算法的基于DFS的线性时间算法", "Tag": "算法设计"}
{"Answer": "寻找强连通分量的算法可以用来解决2-SAT（英语：2-satisfiability）问题（由带有对于变量对的值的限制的布尔变量构成的系统）：如Aspvall，Plass & Tarjan (1979)所示，一个2-SAT（英语：2-satisfiability）实例是无解的，当且仅当有一个变量v使得v和它的互补被包含在实例的隐含图的同一个强连通分量中。[4]\n强连通分量也被用来计算Dulmage–Mendelsohn 分解（英语：Dulmage–Mendelsohn decomposition），一种二分图的边的分类，根据它们能否作为图中的完美匹配。[5]\n", "Konwledge_Point": "强连通分量", "Question": "什么是强连通分量的应用", "Tag": "算法设计"}
{"Answer": "\n\n^ Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. .mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:\"\\\"\"\"\\\"\"\"'\"\"'\"}.mw-parser-output .citation .cs1-lock-free a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}ISBN 0-262-03293-7. Section 22.5, pp. 552–557.\n\n^ Sharir, Micha, A strong-connectivity algorithm and its applications in data flow analysis, Computers & Mathematics with Applications, 1981, 7: 67–72, doi:10.1016/0898-1221(81)90008-0  \n\n^ Tarjan, R. E., Depth-first search and linear graph algorithms, SIAM Journal on Computing, 1972, 1 (2): 146–160, doi:10.1137/0201010 \n\n^ Aspvall, Bengt; Plass, Michael F.; Tarjan, Robert E., A linear-time algorithm for testing the truth of certain quantified boolean formulas, Information Processing Letters, 1979, 8 (3): 121–123, doi:10.1016/0020-0190(79)90002-4 .\n\n^ Dulmage, A. L. & Mendelsohn, N. S., Coverings of bipartite graphs, Can. J. Math., 1958, 10: 517–534, S2CID 123363425, doi:10.4153/cjm-1958-052-0 .\n\n", "Konwledge_Point": "强连通分量", "Question": "什么是强连通分量的参考文献", "Tag": "算法设计"}
{"Answer": "Aspvall, Bengt; Plass, Michael F.; Tarjan, Robert E., A linear-time algorithm for testing the truth of certain quantified boolean formulas, Information Processing Letters, 1979, 8 (3): 121–123, doi:10.1016/0020-0190(79)90002-4 .\nThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 22.5, pp. 552–557.\n", "Konwledge_Point": "强连通分量", "Question": "什么是强连通分量的外部链接", "Tag": "算法设计"}
{"Answer": "贪心算法（英語：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。[1]比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。\n贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。\n贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。\n贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。在不同情況，選擇最優的解，可能會導致辛普森悖論（Simpson's Paradox），不一定出現最優的解。\n貪心算法在数据科学領域被广泛應用，特別是金融工程。其中一個貪心算法例子就是Ensemble method。\n", "Konwledge_Point": "贪心算法", "Question": "什么是贪心算法", "Tag": "算法设计"}
{"Answer": "建立数学模型来描述问题。\n把求解的问题分成若干个子问题。\n对每一子问题求解，得到子问题的局部最优解。\n把子问题的解局部最优解合成原来解问题的一个解。实现该算法的过程：\n从问题的某一初始解出发；while 能朝给定总目标前进一步 do，求出可行解的一个解元素；\n最后，由所有解元素组合成问题的一个可行解。\n", "Konwledge_Point": "贪心算法", "Question": "什么是贪心算法的细节", "Tag": "算法设计"}
{"Answer": "對於大部分的問題，貪心法通常都不能找出最佳解（不過也有例外），因為他們一般沒有測試所有可能的解。貪心法容易過早做決定，因而沒法達到最佳解。例如，所有對圖著色問題。\n贪心法在系统故障诊断策略生成乃至高校的排课系统中都可使用。[2][1]", "Konwledge_Point": "贪心算法", "Question": "什么是贪心算法的應用", "Tag": "算法设计"}
{"Answer": "最小生成樹的算法如Prim算法、Kruskal算法均为贪心算法，其中Prim算法是对图上的节点贪心，而Kruskal算法是对图上的边贪心。\n", "Konwledge_Point": "贪心算法", "Question": "什么是贪心算法的举例", "Tag": "算法设计"}
{"Answer": "动态规划\n最长公共子序列\nFloyd-Warshall算法\nViterbi算法", "Konwledge_Point": "贪心算法", "Question": "什么是贪心算法的参见", "Tag": "算法设计"}
{"Answer": "\n\n^ 1.0 1.1 曦辉, 邓. 浅谈贪心算法在排课系统中的应用. 电脑与电信 (广东省广州市: 广东省对外科技交流中心). 2011. ISSN 1008-6609. （原始内容存档于2021-04-11） （中文（简体））. \n\n^ 孙煜; 刘松风; 马力. 贪心算法在系统故障诊断策略生成中的应用. 计算机系统应用 (北京市: 中国科学院软件研究所). 2011. ISSN 1003-3254. （原始内容存档于2021-04-11） （中文（简体））. \n\n", "Konwledge_Point": "贪心算法", "Question": "什么是贪心算法的参考文献", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "贪心算法", "Question": "什么是贪心算法的外部链接", "Tag": "算法设计"}
{"Answer": "霍夫曼編碼（英語：Huffman Coding），又譯為哈夫曼编码、赫夫曼编码，是一種用於无损数据压缩的熵編碼（權編碼）演算法。由美國計算機科學家大衛·霍夫曼（David Albert Huffman）在1952年發明。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码", "Tag": "算法设计"}
{"Answer": "在计算机資料處理中，霍夫曼編碼使用變長編碼表對源符號（如文件中的一個字母）進行編碼，其中變長編碼表是通過一種評估來源符號出現機率的方法得到的，出現機率高的字母使用較短的編碼，反之出現機率低的則使用較長的編碼，這便使編碼之後的字符串的平均長度、期望值降低，從而達到無損壓縮數據的目的。\n例如，在英文中，e的出現機率最高，而z的出現機率則最低。當利用霍夫曼編碼對一篇英文文章進行壓縮時，e極有可能用一個位元來表示，而z則可能花去25個位元（不是26）。用普通的表示方法時，每個英文字母均占用一個字節，即8個位元。二者相比，e使用了一般編碼的1/8的長度，z則使用了3倍多。倘若我們能實現對於英文中各個字母出現機率的較準確的估算，就可以大幅度提高無損壓縮的比例。\n霍夫曼樹又稱最優二叉樹，是一種帶權路徑長度最短的二叉樹。所謂樹的帶權路徑長度，就是樹中所有的葉結點的權值乘上其到根結點的路徑長度（若根結點爲0層，葉結點到根結點的路徑長度爲葉結點的層數）。樹的路徑長度是從樹根到每一結點的路徑長度之和，記爲WPL=（W1*L1+W2*L2+W3*L3+...+Wn*Ln），N個權值Wi（i=1,2,...n）構成一棵有N個葉結點的二叉樹，相應的葉結點的路徑長度爲Li（i=1,2,...n）。可以證明霍夫曼樹的WPL是最小的。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的簡介", "Tag": "算法设计"}
{"Answer": "1951年，霍夫曼在麻省理工學院（MIT）攻讀博士學位，他和修讀信息論課程的同學得選擇是完成學期報告還是期末考試。導師羅伯特·法諾（Robert Fano）出的學期報告題目是：尋找最有效的二進制編碼。由於無法證明哪個已有編碼是最有效的，霍夫曼放棄對已有編碼的研究，轉向新的探索，最終發現了基於有序頻率二叉樹編碼的想法，並很快證明了這個方法是最有效的。霍夫曼使用自底向上的方法構建二叉樹，避免了次優算法香農-范諾編碼（Shannon–Fano coding）的最大弊端──自頂向下構建樹。\n1952年，於論文《一種構建極小多餘編碼的方法》（A Method for the Construction of Minimum-Redundancy Codes）中發表了這個編碼方法。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的歷史", "Tag": "算法设计"}
{"Answer": "  Fig.1  Fig.2霍夫曼編碼演算步驟, 左右树排列顺序可以加限制或不加限制  Fig.3廣義[编辑]給定一組符號（Symbol）和其對應的權重值（weight），其權重通常表示成概率（%）。欲知一組二元的前置碼，其二元碼的長度為最短。狹義[编辑]輸入符號集合\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            \n              s\n              \n                1\n              \n            \n            ,\n            \n              s\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              s\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{s_{1},s_{2},\\cdots ,s_{n}\\right\\}}\n  \n，其S集合的大小為\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n。\n權重集合\n  \n    \n      \n        W\n        =\n        \n          {\n          \n            \n              w\n              \n                1\n              \n            \n            ,\n            \n              w\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              w\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle W=\\left\\{w_{1},w_{2},\\cdots ,w_{n}\\right\\}}\n  \n，其W集合不為負數且\n  \n    \n      \n        \n          w\n          \n            i\n          \n        \n        =\n        \n          w\n          e\n          i\n          g\n          h\n          t\n        \n        \n          (\n          \n            s\n            \n              i\n            \n          \n          )\n        \n        ,\n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle w_{i}=\\mathrm {weight} \\left(s_{i}\\right),1\\leq i\\leq n}\n  \n。輸出一組編碼\n  \n    \n      \n        C\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n        =\n        \n          {\n          \n            \n              c\n              \n                1\n              \n            \n            ,\n            \n              c\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              c\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle C\\left(S,W\\right)=\\left\\{c_{1},c_{2},\\cdots ,c_{n}\\right\\}}\n  \n，其C集合是一組二進制編碼且\n  \n    \n      \n        \n          c\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle c_{i}}\n  \n為\n  \n    \n      \n        \n          s\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle s_{i}}\n  \n相對應的編碼，\n  \n    \n      \n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle 1\\leq i\\leq n}\n  \n。目標設\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          \n            w\n            \n              i\n            \n          \n          ×\n          \n            l\n            e\n            n\n            g\n            t\n            h\n          \n          \n            (\n            \n              c\n              \n                i\n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle L\\left(C\\right)=\\sum _{i=1}^{n}{w_{i}\\times \\mathrm {length} \\left(c_{i}\\right)}}\n  \n為\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n的加權的路徑長，對所有編碼\n  \n    \n      \n        T\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n      \n    \n    {\\displaystyle T\\left(S,W\\right)}\n  \n，則\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        ≤\n        L\n        \n          (\n          T\n          )\n        \n      \n    \n    {\\displaystyle L\\left(C\\right)\\leq L\\left(T\\right)}\n  \n範例[编辑]霍夫曼樹常處理符號編寫工作。根據整組資料中符號出現的頻率高低，決定如何給符號編碼。如果符號出現的頻率越高，則給符號的碼越短，相反符號的號碼越長。假設我們要給一個英文單字\"F O R G E T\"進行霍夫曼編碼，而每個英文字母出現的頻率分別列在Fig.1。\n演算過程[编辑]（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法", "Tag": "算法设计"}
{"Answer": "給定一組符號（Symbol）和其對應的權重值（weight），其權重通常表示成概率（%）。欲知一組二元的前置碼，其二元碼的長度為最短。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的廣義", "Tag": "算法设计"}
{"Answer": "輸入符號集合\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            \n              s\n              \n                1\n              \n            \n            ,\n            \n              s\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              s\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{s_{1},s_{2},\\cdots ,s_{n}\\right\\}}\n  \n，其S集合的大小為\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n。\n權重集合\n  \n    \n      \n        W\n        =\n        \n          {\n          \n            \n              w\n              \n                1\n              \n            \n            ,\n            \n              w\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              w\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle W=\\left\\{w_{1},w_{2},\\cdots ,w_{n}\\right\\}}\n  \n，其W集合不為負數且\n  \n    \n      \n        \n          w\n          \n            i\n          \n        \n        =\n        \n          w\n          e\n          i\n          g\n          h\n          t\n        \n        \n          (\n          \n            s\n            \n              i\n            \n          \n          )\n        \n        ,\n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle w_{i}=\\mathrm {weight} \\left(s_{i}\\right),1\\leq i\\leq n}\n  \n。輸出一組編碼\n  \n    \n      \n        C\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n        =\n        \n          {\n          \n            \n              c\n              \n                1\n              \n            \n            ,\n            \n              c\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              c\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle C\\left(S,W\\right)=\\left\\{c_{1},c_{2},\\cdots ,c_{n}\\right\\}}\n  \n，其C集合是一組二進制編碼且\n  \n    \n      \n        \n          c\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle c_{i}}\n  \n為\n  \n    \n      \n        \n          s\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle s_{i}}\n  \n相對應的編碼，\n  \n    \n      \n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle 1\\leq i\\leq n}\n  \n。目標設\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          \n            w\n            \n              i\n            \n          \n          ×\n          \n            l\n            e\n            n\n            g\n            t\n            h\n          \n          \n            (\n            \n              c\n              \n                i\n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle L\\left(C\\right)=\\sum _{i=1}^{n}{w_{i}\\times \\mathrm {length} \\left(c_{i}\\right)}}\n  \n為\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n的加權的路徑長，對所有編碼\n  \n    \n      \n        T\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n      \n    \n    {\\displaystyle T\\left(S,W\\right)}\n  \n，則\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        ≤\n        L\n        \n          (\n          T\n          )\n        \n      \n    \n    {\\displaystyle L\\left(C\\right)\\leq L\\left(T\\right)}\n  \n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的狹義", "Tag": "算法设计"}
{"Answer": "霍夫曼樹常處理符號編寫工作。根據整組資料中符號出現的頻率高低，決定如何給符號編碼。如果符號出現的頻率越高，則給符號的碼越短，相反符號的號碼越長。假設我們要給一個英文單字\"F O R G E T\"進行霍夫曼編碼，而每個英文字母出現的頻率分別列在Fig.1。\n演算過程[编辑]（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的範例", "Tag": "算法设计"}
{"Answer": "（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。實現方法[编辑]", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的範例的演算過程", "Tag": "算法设计"}
{"Answer": "資料壓縮[编辑]實現霍夫曼編碼的方式主要是創建一個二元樹和其節點。這些樹的節點可以儲存在陣列裡，陣列的大小為符號（symbols）數的大小n，而節點分别是終端節點（葉節點）與非終端節點（內部節點）。\n一開始，所有的節點都是終端節點，節點內有三個欄位：\n1.符號（Symbol）\n2.權重（Weight、Probabilities、Frequency）\n3.指向父節點的鏈結（Link to its parent node）\n而非終端節點內有四個欄位：\n1.權重（Weight、Probabilities、Frequency）\n2.指向兩個子節點的 鏈結（Links to two child node）  \n3.指向父節點的鏈結（Link to its parent node）\n基本上，我們用'0'與'1'分別代表指向左子節點與右子節點，最後為完成的二元樹共有n個終端節點與n-1個非終端節點，去除了不必要的符號並產生最佳的編碼長度。\n過程中，每個終端節點都包含著一個權重（Weight、Probabilities、Frequency），兩兩終端節點結合會產生一個新節點，新節點的權重是由兩個權重最小的終端節點權重之總和，並持續進行此過程直到只剩下一個節點為止。\n實現霍夫曼樹的方式有很多種，可以使用優先佇列（Priority Queue）簡單達成這個過程，給與權重較低的符號較高的優先順序（Priority），演算法如下：\n⒈把n個終端節點加入優先佇列，則n個節點都有一個優先權Pi，1 ≤ i ≤ n\n⒉如果佇列內的節點數>1，則：\n⑴從佇列中移除兩個最小的Pi節點，即連續做兩次remove（min（Pi）, Priority_Queue)⑵產生一個新節點，此節點為（1）之移除節點之父節點，而此節點的權重值為（1）兩節點之權重和⑶把（2）產生之節點加入優先佇列中⒊最後在優先佇列裡的點為樹的根節點（root）\n而此演算法的時間複雜度（ Time Complexity）為O（n log n）；因為有n個終端節點，所以樹總共有2n-1個節點，使用優先佇列每個迴圈須O（log n）。\n此外，有一個更快的方式使時間複雜度降至線性時間（Linear Time）O（n），就是使用兩個佇列（Queue）創件霍夫曼樹。第一個佇列用來儲存n個符號（即n個終端節點）的權重，第二個佇列用來儲存兩兩權重的合（即非終端節點）。此法可保證第二個佇列的前端（Front）權重永遠都是最小值，且方法如下：\n⒈把n個終端節點加入第一個佇列（依照權重大小排列，最小在前端）\n⒉如果佇列內的節點數>1，則：\n⑴從佇列前端移除兩個最低權重的節點⑵將（1）中移除的兩個節點權重相加合成一個新節點⑶加入第二個佇列⒊最後在第一個佇列的節點為根節點\n雖然使用此方法比使用優先佇列的時間複雜度還低，但是注意此法的第1項，節點必須依照權重大小加入佇列中，如果節點加入順序不按大小，則需要經過排序，則至少花了O（n log n）的時間複雜度計算。\n但是在不同的狀況考量下，時間複雜度並非是最重要的，如果我們今天考慮英文字母的出現頻率，變數n就是英文字母的26個字母，則使用哪一種演算法時間複雜度都不會影響很大，因為n不是一筆龐大的數字。\n資料解壓縮[编辑]簡單來說，霍夫曼碼樹的解壓縮就是將得到的前置碼（Prefix Huffman code）轉換回符號，通常藉由樹的追蹤（Traversal），將接收到的位元串（Bits stream）一步一步還原。但是要追蹤樹之前，必須要先重建霍夫曼樹；某些情況下，如果每個符號的權重可以被事先預測，那麼霍夫曼樹就可以預先重建，並且儲存並重複使用，否則，傳送端必須預先傳送霍夫曼樹的相關資訊給接收端。\n最簡單的方式，就是預先統計各符號的權重並加入至壓縮之位元串，但是此法的運算量花費相當大，並不適合實際的應用。若是使用Canonical encoding，則可精準得知樹重建的資料量只占B2^B位元（其中B為每個符號的位元數（bits））。如果簡單將接收到的位元串一個位元一個位元的重建，例如：'0'表示父節點，'1'表示終端節點，若每次讀取到1時，下8個位元則會被解讀是終端節點（假設資料為8-bit字母），則霍夫曼樹則可被重建，以此方法，資料量的大小可能為2~320位元組不等。雖然還有很多方法可以重建霍夫曼樹，但因為壓縮的資料串包含\"trailing bits\"，所以還原時一定要考慮何時停止，不要還原到錯誤的值，如在資料壓縮時時加上每筆資料的長度等。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的實現方法", "Tag": "算法设计"}
{"Answer": "實現霍夫曼編碼的方式主要是創建一個二元樹和其節點。這些樹的節點可以儲存在陣列裡，陣列的大小為符號（symbols）數的大小n，而節點分别是終端節點（葉節點）與非終端節點（內部節點）。\n一開始，所有的節點都是終端節點，節點內有三個欄位：\n1.符號（Symbol）\n2.權重（Weight、Probabilities、Frequency）\n3.指向父節點的鏈結（Link to its parent node）\n而非終端節點內有四個欄位：\n1.權重（Weight、Probabilities、Frequency）\n2.指向兩個子節點的 鏈結（Links to two child node）  \n3.指向父節點的鏈結（Link to its parent node）\n基本上，我們用'0'與'1'分別代表指向左子節點與右子節點，最後為完成的二元樹共有n個終端節點與n-1個非終端節點，去除了不必要的符號並產生最佳的編碼長度。\n過程中，每個終端節點都包含著一個權重（Weight、Probabilities、Frequency），兩兩終端節點結合會產生一個新節點，新節點的權重是由兩個權重最小的終端節點權重之總和，並持續進行此過程直到只剩下一個節點為止。\n實現霍夫曼樹的方式有很多種，可以使用優先佇列（Priority Queue）簡單達成這個過程，給與權重較低的符號較高的優先順序（Priority），演算法如下：\n⒈把n個終端節點加入優先佇列，則n個節點都有一個優先權Pi，1 ≤ i ≤ n\n⒉如果佇列內的節點數>1，則：\n⑴從佇列中移除兩個最小的Pi節點，即連續做兩次remove（min（Pi）, Priority_Queue)⑵產生一個新節點，此節點為（1）之移除節點之父節點，而此節點的權重值為（1）兩節點之權重和⑶把（2）產生之節點加入優先佇列中⒊最後在優先佇列裡的點為樹的根節點（root）\n而此演算法的時間複雜度（ Time Complexity）為O（n log n）；因為有n個終端節點，所以樹總共有2n-1個節點，使用優先佇列每個迴圈須O（log n）。\n此外，有一個更快的方式使時間複雜度降至線性時間（Linear Time）O（n），就是使用兩個佇列（Queue）創件霍夫曼樹。第一個佇列用來儲存n個符號（即n個終端節點）的權重，第二個佇列用來儲存兩兩權重的合（即非終端節點）。此法可保證第二個佇列的前端（Front）權重永遠都是最小值，且方法如下：\n⒈把n個終端節點加入第一個佇列（依照權重大小排列，最小在前端）\n⒉如果佇列內的節點數>1，則：\n⑴從佇列前端移除兩個最低權重的節點⑵將（1）中移除的兩個節點權重相加合成一個新節點⑶加入第二個佇列⒊最後在第一個佇列的節點為根節點\n雖然使用此方法比使用優先佇列的時間複雜度還低，但是注意此法的第1項，節點必須依照權重大小加入佇列中，如果節點加入順序不按大小，則需要經過排序，則至少花了O（n log n）的時間複雜度計算。\n但是在不同的狀況考量下，時間複雜度並非是最重要的，如果我們今天考慮英文字母的出現頻率，變數n就是英文字母的26個字母，則使用哪一種演算法時間複雜度都不會影響很大，因為n不是一筆龐大的數字。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的實現方法的資料壓縮", "Tag": "算法设计"}
{"Answer": "簡單來說，霍夫曼碼樹的解壓縮就是將得到的前置碼（Prefix Huffman code）轉換回符號，通常藉由樹的追蹤（Traversal），將接收到的位元串（Bits stream）一步一步還原。但是要追蹤樹之前，必須要先重建霍夫曼樹；某些情況下，如果每個符號的權重可以被事先預測，那麼霍夫曼樹就可以預先重建，並且儲存並重複使用，否則，傳送端必須預先傳送霍夫曼樹的相關資訊給接收端。\n最簡單的方式，就是預先統計各符號的權重並加入至壓縮之位元串，但是此法的運算量花費相當大，並不適合實際的應用。若是使用Canonical encoding，則可精準得知樹重建的資料量只占B2^B位元（其中B為每個符號的位元數（bits））。如果簡單將接收到的位元串一個位元一個位元的重建，例如：'0'表示父節點，'1'表示終端節點，若每次讀取到1時，下8個位元則會被解讀是終端節點（假設資料為8-bit字母），則霍夫曼樹則可被重建，以此方法，資料量的大小可能為2~320位元組不等。雖然還有很多方法可以重建霍夫曼樹，但因為壓縮的資料串包含\"trailing bits\"，所以還原時一定要考慮何時停止，不要還原到錯誤的值，如在資料壓縮時時加上每筆資料的長度等。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的實現方法的資料解壓縮", "Tag": "算法设计"}
{"Answer": "考量到不同的應用領域以及該領域的平均性質，將會使用不同的通用機率，又或者，這個機率是可以從被壓縮文本中的實際頻率所取得。\n最佳化[编辑]原始的霍夫曼演算法是一個符號與符號間已知輸入機率分佈的最佳編碼方式，也就是說將不相關的符號個別編碼為如此的資料串流。然而，當符號間的限制被捨棄或是質量機率函數是未知的時候，如此方式則並非最佳化。此外，當這些符號之間不是互相獨立，且分佈不相同的時候，單一一個符號可能不足以實現最佳化。在這種情況之下，算術編碼可能比起霍夫曼編碼會有更佳的壓縮能力。\n雖然上述兩種方法都可以組合任意數量的符號以實現更高效的編碼效果，並且通常適應於實際的輸入統計層面，但儘管最簡單的版本比霍夫曼編碼更慢且更複雜，算術編碼不會顯著增加其計算或算法複雜度。當輸入概率不是精確已知或在流內顯著變化時，這種靈活性特別有用。然而，霍夫曼編碼通常更快，並且算術編碼在歷史上是專利問題的一些主題。因此，許多技術歷來避免使用有利於霍夫曼和其他前綴編碼技術的算術編碼。截至2010年中期，隨著早期專利的到期，這種替代霍夫曼編碼的最常用技術已經進入公有領域。\n對於具有均勻概率分佈的一組符號，以及作為2的冪之成員，霍夫曼編碼等同於簡單的二進位制編碼，例如 ASCII 編碼。這反映了如此的事實：無論壓縮方法是什麼，這種輸入都不可能進行壓縮，或只是說對數據無所作為，比起壓縮才是最佳選擇。\n在任何情況下，霍夫曼編碼在所有方法中是最佳的方式，其中每個輸入符號是具有二元機率的已知獨立且相同分佈的隨機變量。前綴碼，特別是霍夫曼編碼，往往在小字母表上產生較差的效率，其中概率通常落在這些最佳（二元）點之間。當最可能符號的概率遠超過0.5時，可能發生霍夫曼編碼的最壞情況，使低效率的上限無限制。\n在使用霍夫曼編碼的同時，有兩種相關的方法可以解決這種特定的低效問題。將固定數量的符號組合在一起（阻塞）通常會增加（並且永不減少）壓縮。隨著塊的大小接近無窮大，霍夫曼編碼理論上接近熵限制，即最佳壓縮。然而，阻塞任意大的符號組是不切實際的，因為霍夫曼代碼的複雜性在要編碼的可能性的數量上是線性的，這是在塊的大小中呈指數的數字。這限制了在實踐中完成的阻塞量。\n廣泛使用的實際替代方案是行程編碼。該技術在熵編碼之前增加一步，特別是對重複符號進行執行次數的計數，然後對其進行編碼。對於伯努力（Bernoulli）過程的簡單情況，哥倫（Golomb）編碼在編碼遊程長度的前綴碼中是最佳的，這是通過霍夫曼編碼技術證明的事實。使用改進的霍夫曼編碼的傳真機採用類似的方法。但是，遊程編碼並不像其他壓縮技術那樣適應許多輸入類型。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的基本性質", "Tag": "算法设计"}
{"Answer": "原始的霍夫曼演算法是一個符號與符號間已知輸入機率分佈的最佳編碼方式，也就是說將不相關的符號個別編碼為如此的資料串流。然而，當符號間的限制被捨棄或是質量機率函數是未知的時候，如此方式則並非最佳化。此外，當這些符號之間不是互相獨立，且分佈不相同的時候，單一一個符號可能不足以實現最佳化。在這種情況之下，算術編碼可能比起霍夫曼編碼會有更佳的壓縮能力。\n雖然上述兩種方法都可以組合任意數量的符號以實現更高效的編碼效果，並且通常適應於實際的輸入統計層面，但儘管最簡單的版本比霍夫曼編碼更慢且更複雜，算術編碼不會顯著增加其計算或算法複雜度。當輸入概率不是精確已知或在流內顯著變化時，這種靈活性特別有用。然而，霍夫曼編碼通常更快，並且算術編碼在歷史上是專利問題的一些主題。因此，許多技術歷來避免使用有利於霍夫曼和其他前綴編碼技術的算術編碼。截至2010年中期，隨著早期專利的到期，這種替代霍夫曼編碼的最常用技術已經進入公有領域。\n對於具有均勻概率分佈的一組符號，以及作為2的冪之成員，霍夫曼編碼等同於簡單的二進位制編碼，例如 ASCII 編碼。這反映了如此的事實：無論壓縮方法是什麼，這種輸入都不可能進行壓縮，或只是說對數據無所作為，比起壓縮才是最佳選擇。\n在任何情況下，霍夫曼編碼在所有方法中是最佳的方式，其中每個輸入符號是具有二元機率的已知獨立且相同分佈的隨機變量。前綴碼，特別是霍夫曼編碼，往往在小字母表上產生較差的效率，其中概率通常落在這些最佳（二元）點之間。當最可能符號的概率遠超過0.5時，可能發生霍夫曼編碼的最壞情況，使低效率的上限無限制。\n在使用霍夫曼編碼的同時，有兩種相關的方法可以解決這種特定的低效問題。將固定數量的符號組合在一起（阻塞）通常會增加（並且永不減少）壓縮。隨著塊的大小接近無窮大，霍夫曼編碼理論上接近熵限制，即最佳壓縮。然而，阻塞任意大的符號組是不切實際的，因為霍夫曼代碼的複雜性在要編碼的可能性的數量上是線性的，這是在塊的大小中呈指數的數字。這限制了在實踐中完成的阻塞量。\n廣泛使用的實際替代方案是行程編碼。該技術在熵編碼之前增加一步，特別是對重複符號進行執行次數的計數，然後對其進行編碼。對於伯努力（Bernoulli）過程的簡單情況，哥倫（Golomb）編碼在編碼遊程長度的前綴碼中是最佳的，這是通過霍夫曼編碼技術證明的事實。使用改進的霍夫曼編碼的傳真機採用類似的方法。但是，遊程編碼並不像其他壓縮技術那樣適應許多輸入類型。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的基本性質的最佳化", "Tag": "算法设计"}
{"Answer": "霍夫曼編碼有衍生出許多的許多變化，其中一些使用類似霍夫曼的算法，而其他一些算法找到最佳前綴碼（例如，對輸出施加不同的限制）。注意，在後一種情況下，該方法不需要像霍夫曼那樣，實際上甚至不需要到多項式複雜度。\n多元樹霍夫曼編碼[编辑]多元樹霍夫曼編碼演算法使用字母集 {0, 1, ... , n − 1} ，來構建一棵 n 元樹。霍夫曼在他的原始論文中考慮了這種方法。這與二進制（n=2）算法僅有的差別，就是它每次把 n 個最低權的符號合併，而不僅是兩個最低權的符號。倘若 n ≥ 2, 則並非所有源字集都可以正確地形成用於霍夫曼編碼的多元樹。在這些情況下，必須添加額外的零概率佔位符。這是因為該樹必須為滿的 n 叉樹，所以每次合併會令符號數恰好減少 (n -1), 故這樣的 n 叉樹存在當且僅當源字的數量模 (n -1) 餘 1. 對於二進制編碼，任何大小的集合都可以形成這樣的二叉樹，因為 n -1 = 1.\n自適應霍夫曼編碼[编辑]自適應霍夫曼編碼的變化，涉及基於源符號序列中的最近實際頻率動態地計算概率，以及改變編碼樹結構以匹配更新的概率估計。它在實踐中很少使用，因為更新樹的成本使其比優化的自適應算術編碼慢，後者更靈活並且具有更好的壓縮。\n霍夫曼模板演算法[编辑]在霍夫曼編碼的實現中，通常會使用權重表示數值概率，但是上面給出的算法不需要這樣;它只需要權重形成一個完全有序的可交換么半群，這意味著一種訂購權重和添加權重的方法。霍夫曼模板算法使人們能夠使用任何類型的權重（成本，頻率，權重對，非數字權重）和許多組合方法之一（不僅僅是加法），這個問題首先應用於電路設計。\n長度限制霍夫曼編碼/最小變異霍夫曼編碼[编辑]長度限制霍夫曼編碼[编辑]長度受限的霍夫曼編碼是一種變體，其目標仍然是實現最小加權路徑長度，但是存在另外的限制，即每個碼字的長度必須小於給定常數。包合併算法通過一種與霍夫曼演算法非常相似的簡單貪婪方法解決了這個問題。\n不相等成本霍夫曼編碼[编辑]在標準的霍夫曼編碼問題中，假設集合中構成碼字的每個符號具有相同的傳輸成本：長度為N位的碼字總是具有N的成本，無論多少這些數字是0，有多少是1，等等。在這個假設下工作時，最小化消息的總成本和最小化數字總數是相同的。\n具有不等字母成本的霍夫曼編碼是沒有這種假設的概括：由於傳輸介質的特性，編碼字母表的字母可能具有不均勻的長度。一個例子是摩爾斯電碼的編碼字母表，其中'破折號'比'點'需要更長的發送時間，因此傳輸時間中破折號的成本更高。目標仍然是最小化加權平均碼字長度，但僅僅最小化消息使用的符號數量已經不夠了。沒有算法以與傳統霍夫曼編碼相同的方式或相同的效率來解決這個問題，儘管它已經由卡普（Karp）解決，其解決方案已經針對哥林（Golin）的整數成本的情況進行了改進。\n最佳字母二元樹[编辑]在標準霍夫曼編碼問題中，假設任何碼字可以對應於任何輸入符號。在字母表中，輸入和輸出的字母順序必須相同。\n規範霍夫曼編碼[编辑]如果對應於按字母順序排列的輸入的權重是按數字順序排列的，則霍夫曼代碼具有與最佳字母代碼相同的長度，這可以從計算這些長度中找到，從而不需要使用胡 - 塔克（Hu-Tucker）編碼。由數字（重新）有序輸入產生的代碼有時被稱為規範霍夫曼代碼，並且由於易於編碼/解碼，通常是實踐中使用的代碼。用於找到該代碼的技術有時被稱為霍夫曼 - 香農 - 法諾編碼，因為它像霍夫曼編碼一樣是最優的，但是在重量概率上是字母的，例如香農 - 法諾編碼。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化", "Tag": "算法设计"}
{"Answer": "多元樹霍夫曼編碼演算法使用字母集 {0, 1, ... , n − 1} ，來構建一棵 n 元樹。霍夫曼在他的原始論文中考慮了這種方法。這與二進制（n=2）算法僅有的差別，就是它每次把 n 個最低權的符號合併，而不僅是兩個最低權的符號。倘若 n ≥ 2, 則並非所有源字集都可以正確地形成用於霍夫曼編碼的多元樹。在這些情況下，必須添加額外的零概率佔位符。這是因為該樹必須為滿的 n 叉樹，所以每次合併會令符號數恰好減少 (n -1), 故這樣的 n 叉樹存在當且僅當源字的數量模 (n -1) 餘 1. 對於二進制編碼，任何大小的集合都可以形成這樣的二叉樹，因為 n -1 = 1.\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的多元樹霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "自適應霍夫曼編碼的變化，涉及基於源符號序列中的最近實際頻率動態地計算概率，以及改變編碼樹結構以匹配更新的概率估計。它在實踐中很少使用，因為更新樹的成本使其比優化的自適應算術編碼慢，後者更靈活並且具有更好的壓縮。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的自適應霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "在霍夫曼編碼的實現中，通常會使用權重表示數值概率，但是上面給出的算法不需要這樣;它只需要權重形成一個完全有序的可交換么半群，這意味著一種訂購權重和添加權重的方法。霍夫曼模板算法使人們能夠使用任何類型的權重（成本，頻率，權重對，非數字權重）和許多組合方法之一（不僅僅是加法），這個問題首先應用於電路設計。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的霍夫曼模板演算法", "Tag": "算法设计"}
{"Answer": "長度限制霍夫曼編碼[编辑]長度受限的霍夫曼編碼是一種變體，其目標仍然是實現最小加權路徑長度，但是存在另外的限制，即每個碼字的長度必須小於給定常數。包合併算法通過一種與霍夫曼演算法非常相似的簡單貪婪方法解決了這個問題。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的長度限制霍夫曼編碼/最小變異霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "長度受限的霍夫曼編碼是一種變體，其目標仍然是實現最小加權路徑長度，但是存在另外的限制，即每個碼字的長度必須小於給定常數。包合併算法通過一種與霍夫曼演算法非常相似的簡單貪婪方法解決了這個問題。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的長度限制霍夫曼編碼/最小變異霍夫曼編碼的長度限制霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "在標準的霍夫曼編碼問題中，假設集合中構成碼字的每個符號具有相同的傳輸成本：長度為N位的碼字總是具有N的成本，無論多少這些數字是0，有多少是1，等等。在這個假設下工作時，最小化消息的總成本和最小化數字總數是相同的。\n具有不等字母成本的霍夫曼編碼是沒有這種假設的概括：由於傳輸介質的特性，編碼字母表的字母可能具有不均勻的長度。一個例子是摩爾斯電碼的編碼字母表，其中'破折號'比'點'需要更長的發送時間，因此傳輸時間中破折號的成本更高。目標仍然是最小化加權平均碼字長度，但僅僅最小化消息使用的符號數量已經不夠了。沒有算法以與傳統霍夫曼編碼相同的方式或相同的效率來解決這個問題，儘管它已經由卡普（Karp）解決，其解決方案已經針對哥林（Golin）的整數成本的情況進行了改進。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的不相等成本霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "在標準霍夫曼編碼問題中，假設任何碼字可以對應於任何輸入符號。在字母表中，輸入和輸出的字母順序必須相同。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的最佳字母二元樹", "Tag": "算法设计"}
{"Answer": "如果對應於按字母順序排列的輸入的權重是按數字順序排列的，則霍夫曼代碼具有與最佳字母代碼相同的長度，這可以從計算這些長度中找到，從而不需要使用胡 - 塔克（Hu-Tucker）編碼。由數字（重新）有序輸入產生的代碼有時被稱為規範霍夫曼代碼，並且由於易於編碼/解碼，通常是實踐中使用的代碼。用於找到該代碼的技術有時被稱為霍夫曼 - 香農 - 法諾編碼，因為它像霍夫曼編碼一樣是最優的，但是在重量概率上是字母的，例如香農 - 法諾編碼。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的規範霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "設符號集合\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            \n              s\n              \n                1\n              \n            \n            ,\n            \n              s\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              s\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{s_{1},s_{2},\\cdots ,s_{n}\\right\\}}\n  \n，\n  \n    \n      \n        P\n        \n          (\n          \n            s\n            \n              j\n            \n          \n          )\n        \n      \n    \n    {\\displaystyle P\\left(s_{j}\\right)}\n  \n为\n  \n    \n      \n        \n          s\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle s_{j}}\n  \n發生的機率\n，\n  \n    \n      \n        L\n        \n          (\n          \n            s\n            \n              j\n            \n          \n          )\n        \n      \n    \n    {\\displaystyle L\\left(s_{j}\\right)}\n  \n为\n  \n    \n      \n        \n          s\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle s_{j}}\n  \n編碼的長度\n熵（Entropy）:亂度\n  \n    \n      \n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        −\n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            J\n          \n        \n        \n          P\n          \n            (\n            \n              s\n              \n                j\n              \n            \n            )\n          \n          ×\n          ln\n          ⁡\n          \n            P\n            \n              (\n              \n                s\n                \n                  j\n                \n              \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle entropy=-\\sum _{j=1}^{J}{P\\left(s_{j}\\right)\\times \\ln {P\\left(s_{j}\\right)}}}\n  \nex:\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        1\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        0\n      \n    \n    {\\displaystyle P(S_{0})=1,entropy=0}\n  \n\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            1\n          \n        \n        )\n        =\n        0.5\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        0.6931\n      \n    \n    {\\displaystyle P(S_{0})=P(S_{1})=0.5,entropy=0.6931}\n  \n\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            1\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            2\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            3\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            4\n          \n        \n        )\n        =\n        0.2\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        1.6094\n      \n    \n    {\\displaystyle P(S_{0})=P(S_{1})=P(S_{2})=P(S_{3})=P(S_{4})=0.2,entropy=1.6094}\n  \n\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            1\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            2\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            3\n          \n        \n        )\n        =\n        0.1\n        ,\n        P\n        (\n        \n          S\n          \n            4\n          \n        \n        )\n        =\n        0.6\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        1.2275\n      \n    \n    {\\displaystyle P(S_{0})=P(S_{1})=P(S_{2})=P(S_{3})=0.1,P(S_{4})=0.6,entropy=1.2275}\n  \n\n第三與第四個範例，同樣是五種組合，機率分布越集中，則亂度越少\n霍夫曼碼平均長度\n  \n    \n      \n        m\n        e\n        a\n        n\n        \n          (\n          L\n          )\n        \n        =\n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            J\n          \n        \n        \n          P\n          \n            (\n            \n              s\n              \n                j\n              \n            \n            )\n          \n          ×\n           \n          L\n          \n            (\n            \n              s\n              \n                j\n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle mean\\left(L\\right)=\\sum _{j=1}^{J}{P\\left(s_{j}\\right)\\times \\ L\\left(s_{j}\\right)}}\n  \n霍夫曼碼的長度Shannon編碼定理： \n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n ≤ \n  \n    \n      \n        m\n        e\n        a\n        n\n        \n          (\n          L\n          )\n        \n      \n    \n    {\\displaystyle mean\\left(L\\right)}\n  \n ≤ \n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n \n  \n    \n      \n        +\n        1\n      \n    \n    {\\displaystyle +1}\n  \n ，若使用\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n進位的編碼霍夫曼碼的平均編碼長度：設\n  \n    \n      \n        b\n        =\n        m\n        e\n        a\n        n\n        \n          (\n          L\n          )\n        \n        N\n      \n    \n    {\\displaystyle b=mean\\left(L\\right)N}\n  \n，\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n為資料長度\n\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n\n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n ≤ \n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n ≤ \n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n\n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n \n  \n    \n      \n        +\n        N\n      \n    \n    {\\displaystyle +N}\n  \n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的資料長度", "Tag": "算法设计"}
{"Answer": "霍夫曼樹常處理符號編寫工作。根據整組資料中符號出現的頻率高低，決定如何給符號編碼。如果符號出現的頻率越高，則給符號的碼越短，相反符號的號碼越長。假設我們要給一個英文單字\"F O R G E T\"進行霍夫曼編碼，而每個英文字母出現的頻率分別列在Fig.1。\n演算過程[编辑]（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的範例", "Tag": "算法设计"}
{"Answer": "// 以下為C++程式碼，在G++下編譯通過\n// 僅用於示範如何根據權值建構霍夫曼樹，\n// 沒有經過性能上的優化及加上完善的異常處理。\n#include <cstdlib>\n#include <iostream>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nconst int size = 10;\nstruct node {                               // 霍夫曼樹節點結構\n    unsigned key;                           // 保存權值\n    node *lchild;                           // 左孩子指針\n    node *rchild;                           // 右孩子指針\n};\ndeque<node *> forest;\ndeque<bool> code;                           // 此處也可使用bitset\nnode *ptr;\nint frequency[size] = {0};\n\nvoid printCode(deque<bool> ptr);            // 用於輸出霍夫曼編碼\n\nbool compare( node *a, node *b) {\n    return a->key < b->key;\n}\nint main(int argc, char *argv[]) {\n    for (int i = 0; i < size; i++) {\n        cin >> frequency[i];                // 輸入10個權值\n        ptr = new node;\n        ptr->key = frequency[i];\n        ptr->lchild = NULL;\n        ptr->rchild = NULL;\n        forest.push_back(ptr);\n    } // 形成森林，森林中的每一棵樹都是一個節點\n    // 從森林構建霍夫曼樹\n    for (int i = 0; i < size - 1; i++) {\n        sort(forest.begin(), forest.end(), compare);\n        ptr = new node;\n        // 以下代碼使用下標索引隊列元素，具有潛在危險，使用時請注意\n        ptr->key = forest[0]->key + forest[1]->key;\n        ptr->lchild = forest[0];\n        ptr->rchild = forest[1];\n        forest.pop_front();\n        forest.pop_front();\n        forest.push_back(ptr);\n    }\n    ptr = forest.front(); // ptr是一個指向根的指針\n    system(\"PAUSE\");\n    return EXIT_SUCCESS;\n}\n\nvoid printCode(deque<bool> ptr) {\n    // deque<bool>\n    for (int i = 0; i < ptr.size(); i++) {\n        if (ptr[i])\n            cout << \"1\";\n        else\n            cout << \"0\";\n    }\n}\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的示範程式", "Tag": "算法设计"}
{"Answer": "huffman.h文件\n#ifndef __HUFFMAN_H__\n#define __HUFFMAN_H__\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define START printf(\"=====start=====\\n\")\n#define END printf(\"=====end=====\\n\")\n#define toByte(n) ((n) / 8 + ((n) % 8 > 0))\n\ntypedef struct HuffListNode HuffListNode,*hufflistnodep;\ntypedef struct HuffNode HuffNode,*huffnodep;\ntypedef struct HuffTree HuffTree,*hufftreep;\ntypedef struct HuffCode HuffCode,*huffcodep;\ntypedef struct HuffList HuffList,*hufflistp;\ntypedef struct HuffResult HuffResult,*huffresultp;\ntypedef struct HuffCode HuffBuf,*huffbufp;  //缓存类型\n\nstruct HuffListNode{\n    huffnodep node;     //huffman节点\n    hufflistnodep next; //后继节点\n};  //huffman频率节点\n\nstruct HuffList{\n    hufflistnodep head;         //头结点\n    int keys[256];              //键值字典\n    int size;                   //链表长度\n};\n\nstruct HuffNode{\n    int key;            //键\n    int weight;         //权重\n    huffnodep left;     //左节点\n    huffnodep right;    //右节点\n};  //huffman节点\n\nstruct HuffCode{\n    char* code; //huffman code\n    int size;   //huffman code size\n};\n\nstruct HuffTree{\n    huffnodep root;         //根\n    huffcodep codes[256];   //key对应的代码\n    int size;               //大小\n};  //huffman树\n\nstruct HuffResult{\n    char* code;      //生成的代码\n    hufftreep tree;  //对应的霍夫曼树\n};\n\n#ifndef __BOOLEAN__\n#define __BOOLEAN__\ntypedef enum{\n    FALSE = 0,\n    TRUE = 1,\n}Boolean;\n#endif\n\nhuffnodep huffnode(int key,int weight); //初始化huffman节点\nhufflistp hufflist();   //初始化hufflist\nBoolean insertHuffNode(hufflistp list,huffnodep node);  //向指定的节点链表添加一个节点\nhuffnodep shiftHuffNode(hufflistp list);    //删除第一个节点\nhufftreep hufftree(hufflistp list);   //构建一棵huffman tree\nhuffbufp getFileBuf(const char* filename); //获取文件的buf\nhufftreep genhuffcodes(hufftreep tree,huffnodep node,char codes[],int idx);  //获取当前节点之下的节点的huffman编码\nhufflistp getHuffListByFile(const char* filename); //根据文件创建huffman链表\nhufflistp getHuffListByBuf(huffbufp buf); //根据文件buf创建huffman链表\nhuffcodep getHuffCode(hufftreep tree,int key);  //获取指定键值的huffcode\nhuffresultp getHuffCodesByFile(const char* filename);     //获取文件的huffman code\nhuffresultp getHuffCodesByBuf(huffbufp buf);    //通过buf获取codes\nhuffbufp getOriginBuf(huffresultp result);       //从result中解析出原始的字符串\nhuffbufp str2bin(char* str); //二进制字符串转二进制数组\nint putOriginToFile(huffresultp result,const char* filename);   //将result存储到filename中\nchar* bin2str(huffbufp buf);    //二进制数组转二进制字符串\nhuffbufp readHuffFile(const char* filename); //解析huff文件\n#endif\nhuffman.c文件:\n#include \"huffman.h\"\n\nhuffnodep huffnode(int key,int weight){\n    huffnodep ret = (huffnodep)malloc(sizeof(HuffNode));\n    ret->key = key;\n    ret->weight = weight;\n    ret->left = ret->right = NULL;\n\n    return ret;\n}\n\nhufflistp hufflist(){\n    hufflistp ret = (hufflistp)malloc(sizeof(HuffList));\n    ret->head = NULL;\n    memset(ret->keys,0,sizeof(ret->keys[0])*256);\n    ret->size = 0;\n\n    return ret;\n}\n\nBoolean insertHuffNode(hufflistp list,huffnodep node){\n    if(list == NULL || node == NULL || node->weight <= -256) return FALSE;\n    hufflistnodep cur = list->head;\n    hufflistnodep* rootp = &(list->head);\n    hufflistnodep* last = NULL; //当前指针的前驱指针\n    hufflistnodep tmp = (hufflistnodep)malloc(sizeof(HuffListNode));\n    tmp->node = node;\n    tmp->next = NULL;\n    if(node->key >= 0 && node->key < 256){\n        list->keys[node->key] = node->weight;   //添加key到keys字典\n    }\n    list->size++;\n\n    for(;cur != NULL  && cur->node->weight < node->weight; cur = cur->next){\n        last = rootp;\n        rootp = &(cur->next);\n    }\n\n    tmp->next = cur;\n    if(last == NULL){   //第一个元素\n        list->head = tmp;\n    }else{  //向当前节点前面插入tmp节点\n        (*last)->next = tmp;\n    }\n\n    return TRUE;\n}\n\nhuffnodep shiftHuffNode(hufflistp list){\n    if(list == NULL || list->head == NULL) return NULL;\n    huffnodep ret = list->head->node;\n    hufflistnodep next = list->head->next;\n    free(list->head);\n    list->head = next;\n    list->size--;\n\n    return ret;\n}\n\n//通过huffman list构建\nhufftreep hufftree(hufflistp list){\n    hufftreep tree = (hufftreep)malloc(sizeof(HuffTree));\n    tree->root = NULL;\n    tree->size = 0;\n    memset(tree->codes,0,sizeof(tree->codes));\n\n    huffnodep a = NULL;\n    huffnodep b = NULL;\n    huffnodep c = NULL;\n    tree->size = 2 * list->size - 1;\n    while(list->size > 1){  //hufflistp长度大于1\n        a = shiftHuffNode(list);\n        b = shiftHuffNode(list);\n        c = huffnode(-256,a->weight+b->weight);    //新的节点\n        c->left = a;\n        c->right = b;\n        insertHuffNode(list,c); //将c压回list\n    }\n    tree->root = c;\n\n    //生成所有key的huffman编码\n    char codes[8092];   //huffman编辑路径\n\n    return genhuffcodes(tree,tree->root,codes,0);\n}\n\n//获取文件内容的BUF\nhuffbufp getFileBuf(const char* filename){\n    FILE* fp = fopen(filename,\"r\");\n    if(fp == NULL) return NULL;\n    fseek(fp,0L,SEEK_END);\n    int len = ftell(fp);\n    rewind(fp); //重设\n    huffbufp ret = (huffbufp)malloc(sizeof(HuffBuf));\n    ret->code = (char*)malloc(len+1);\n    ret->size = len;\n    fread(ret->code,1,len,fp);\n    fclose(fp);\n\n    return ret;\n}\n\nhufftreep genhuffcodes(hufftreep tree,huffnodep node,char codes[],int idx){\n    if(tree == NULL || node == NULL){   //到达底部\n        return NULL;\n    }\n\n    if(node->left == NULL && node->right == NULL){  //叶子节点\n        int key = node->key;\n        huffcodep code = (huffcodep)malloc(sizeof(HuffCode));\n        code->code = (char*)malloc(idx+1);\n        code->size = idx;\n        memcpy(code->code,codes,code->size);\n        code->code[code->size] = '\\0';\n        tree->codes[key] = code;\n    }{\n        codes[idx] = '1'; //右\n        genhuffcodes(tree,node->right,codes,idx+1);\n        codes[idx] = '0'; //左\n        genhuffcodes(tree,node->left,codes,idx+1);\n    }\n\n    return tree;\n}\n\n//通过文件生成huffman list\nhufflistp getHuffListByFile(const char* filename){\n    huffbufp buf = getFileBuf(filename);\n    if(buf == NULL) return NULL;\n\n    hufflistp list = getHuffListByBuf(buf);\n    free(buf->code);\n    buf->code = NULL;\n    free(buf);\n    buf = NULL;\n\n    return list;\n}\n\nhufflistp getHuffListByBuf(huffbufp buf){\n    if(buf == NULL || buf->code == NULL) return NULL;\n\n    char* code = buf->code;\n\n    hufflistp list = hufflist();\n    for(int i = 0; code[i] != '\\0'; i++){\n        unsigned char ch = code[i];\n        list->keys[ch]++;\n    }\n\n    for(int i = 0; i < 256; i++){\n        if(list->keys[i] > 0){   //插入存在的字符\n            insertHuffNode(list,huffnode(i,list->keys[i]));\n        }\n    }\n\n    return list;\n}\n\nhuffcodep getHuffCode(hufftreep tree,int key){\n    if(key < 256 && key >= 0 && tree->codes[key] > 0){\n        return tree->codes[key];\n    }\n    return NULL;\n}\n\nhuffresultp getHuffCodesByFile(const char* filename){\n    huffbufp buf = getFileBuf(filename);   //文件缓存\n    return getHuffCodesByBuf(buf);\n}\n\nhuffresultp getHuffCodesByBuf(huffbufp buf){\n    huffresultp result = (huffresultp)malloc(sizeof(HuffResult));\n    result->code = NULL;\n\n    if(buf == NULL) return NULL;\n\n    hufflistp list = getHuffListByBuf(buf); //huffman list\n\n    result->tree = hufftree(list);\n    int buf_len = buf->size;\n    int len = 0;\n    for(int i = 0; buf->code[i] != '\\0'; i++){\n        int key = (unsigned char)buf->code[i];\n        huffcodep code = getHuffCode(result->tree,key);\n        if(code == NULL){\n            printf(\"LLL:%c{%d}\\n\",key,key);\n            return NULL;\n        }\n        len+=code->size;\n    }\n    result->code = (char*)malloc(len+1);\n    result->code[0] = '\\0';\n    for(int i = 0; buf->code[i] != '\\0'; i++){\n        unsigned char key = buf->code[i];\n        huffcodep code = getHuffCode(result->tree,key);\n        strncat(result->code,code->code,code->size);\n    }\n\n    return result;\n}\n\nhuffbufp getOriginBuf(huffresultp result){\n    if(result == NULL || result->code == NULL || result->tree == NULL) return NULL;\n    hufftreep tree = result->tree;\n    char* code = result->code;\n    int len = 0;\n    for(int i = 0; code[i] != '\\0';){\n        huffnodep root = tree->root;    //根节点\n        while(root->left != NULL && root->right != NULL && code[i] != '\\0'){   //双子节点存在\n            root = (code[i] == '0' ? root->left : root->right);\n            i++;\n        }\n        if((root->left != NULL || root->right != NULL) && code[i] == '\\0'){ //错误\n            return NULL;\n        }\n        len++;\n        // printf(\"解析:%c{%s}\\n\",root->key,tree->codes[root->key]->code);\n    }\n\n    huffbufp ret = (huffbufp)malloc(sizeof(HuffBuf));\n    ret->code = (char*)malloc(len+1);\n    ret->code[0] = '\\0';\n    ret->size = len;\n\n    int idx = 0;\n    for(int i = 0; code[i] != '\\0';){\n        huffnodep root = tree->root;    //根节点\n        while(root->left != NULL && root->right != NULL && code[i] != '\\0'){   //双子节点存在\n            root = (code[i] == '0' ? root->left : root->right);\n            i++;\n        }\n        ret->code[idx++] = root->key;\n    }\n    ret->code[idx] = '\\0';\n\n    return ret;\n}\n\nint putOriginToFile(huffresultp result,const char* filename){\n    if(result == NULL) return 0;\n    // printf(\"res1[%d]:%s\\n\",(int)strlen(result->code),result->code);\n    // huffbufp b = str2bin(result->code);\n    // printf(\"%d\\n\",b->size);\n    // printf(\"res2:%s\\n\",bin2str(b));\n    // return 0;\n\n    huffbufp buf = str2bin(result->code);   //huffman code转成buf\n    int i = 0;\n    int len = 0;    \n    for(i = 0; i < 256; i++){\n        if(result->tree->codes[i] > 0){ //\n            len+= 5+result->tree->codes[i]->size;   //key[1]:len[4]:size\n        }\n    }\n    huffbufp keys = (huffbufp)malloc(sizeof(HuffBuf));\n    keys->code = (char*)malloc(len);\n    keys->size = 0;\n    //获取keys\n    int idx = 0;\n    for(i = 0; i < 256; i++){\n        if(result->tree->codes[i] > 0){ //\n            keys->code[idx++] = i;    //key\n            int len = result->tree->codes[i]->size;\n            memcpy(keys->code+idx,&len,4);    //key size\n            // printf(\"%c[%d]:%d{%s}\\n\",i,i,len,result->tree->codes[i]->code);\n            idx+=4;\n            huffbufp tmp = str2bin(result->tree->codes[i]->code);\n            // printf(\"%d,%d\\n\",tmp->code[0],tmp->size);\n            int tsize = toByte(tmp->size);\n            memcpy(keys->code+idx,tmp->code,tsize);\n            idx+=tsize;\n        }\n    }\n\n    keys->size = idx;   //诸多键的总空间\n    \n    //写出标准文件\n    //HUF\\n\n    //size: 4b\n    //keys\n    //size: 4b\n    //codes\n    FILE* fp = fopen(filename,\"w\");\n    if(fp == NULL) return -1;\n    fwrite(\"HUF\\n\",1,4,fp);\n    fwrite(&idx,1,4,fp);    //size\n    fwrite(keys->code,1,keys->size,fp); //写入code\n    fwrite(&(buf->size),1,4,fp);    //size\n    fwrite(buf->code,1,toByte(buf->size),fp);\n    fclose(fp);\n\n    return 4+4+keys->size+4+buf->size;\n}\n\n\nhuffbufp str2bin(char* str){ //二进制字符串转二进制数组\n    // printf(\"bin:%s\\n\",str);\n    if(str == NULL) return NULL;\n    huffbufp buf = (huffbufp)malloc(sizeof(HuffBuf));\n    int l = strlen(str);\n    int size = (l / 8) + (l % 8 > 0);\n\n    buf->code = (char*)malloc(l);\n    memset(buf->code,0,l);\n    for(int i = 0; i < l; i++){\n        int idx = i/8;\n        int bi = i%8;\n        buf->code[idx] |= (str[i] == '0' ? 0:1) << bi;\n    }\n    buf->size = l;\n\n    return buf;\n}\n\nchar* bin2str(huffbufp buf){\n    char* ret = (char*)malloc(buf->size+1);\n    for(int i = 0; i < buf->size; i++){\n        int idx = i / 8;\n        int offset = i % 8;\n        ret[i] = (buf->code[idx] & (0x01 << offset)) ? '1' : '0';\n    }\n    ret[buf->size] = '\\0';\n\n    return ret;\n}\n\nhuffbufp readHuffFile(const char* filename){\n    huffbufp buf = getFileBuf(filename);\n    if(buf == NULL) return NULL;\n\n    if(memcmp(buf->code,\"HUF\\n\",4) != 0) return NULL;   //文件不以BUF\\n开头\n    huffresultp result = (huffresultp)malloc(sizeof(HuffResult));\n    //BUF\\n\n    //key size\n    int key_size = *(int*)(buf->code+4);\n    int base = 8; //偏移量\n    hufftreep tree = (hufftreep)malloc(sizeof(HuffTree));\n    tree->root = NULL;\n    tree->size = 0;\n    huffcodep* codes = tree->codes;   //key对应代码\n    memset(codes,0,sizeof(huffcodep)*256);\n    \n    int oft = 0;\n    for(;oft < key_size;){\n        int offset = base+oft;\n        unsigned char key = buf->code[offset];\n        // printf(\"%d[%c]\\n\",key,key);\n        int size = *(int*)(buf->code+offset+1); //长度\n        int byte = toByte(size);\n        huffbufp htmp = (huffbufp)malloc(sizeof(HuffBuf));\n        //键对应代码\n        htmp->code = buf->code+offset+5;    //缓存代码\n        htmp->size = size;  //缓存大小\n        // printf(\"[%c]%d\\n\",key,key);\n        huffcodep tmp = (huffcodep)malloc(sizeof(HuffCode));\n        tmp->size = size;   //key的大小\n        tmp->code = bin2str(htmp);\n        tree->codes[key] = tmp;\n        tree->size++;   //树的大小增加\n        huffnodep root = tree->root;\n        if(root == NULL){\n            tree->root = huffnode(-256,0);\n            root = tree->root;\n        }\n        for(int i = 0; i < tmp->size; i++){\n            char ch = tmp->code[i];\n            huffnodep node = NULL;\n            if(ch == '0'){\n                node = root->left;\n                if(node == NULL){\n                    node = huffnode(-256,0);\n                }\n                root->left = node;\n            }else{\n                node = root->right;\n                if(node == NULL){\n                    node = huffnode(-256,0);\n                }\n                root->right = node;\n            }\n            if(i == tmp->size - 1)\n                node->key = key;\n            root = node;\n        }\n        oft+=5+byte;\n    }\n\n    huffbufp tmp = (huffbufp)malloc(sizeof(HuffBuf));\n    tmp->code = buf->code+base+oft+4;\n    tmp->size = *(int*)(buf->code+base+oft);\n    // printf(\"tmp size:%d\\n\",tmp->size);\n    result->tree = tree;\n    result->code = bin2str(tmp);\n    // printf(\"%s\\n\",result->code);\n\n    // for(int i = 0; i < 256; i++){\n    //     if(codes[i]!=NULL){\n    //         printf(\"%c[%d]:%s\\n\",i,i,codes[i]->code);\n    //     }\n    // }\n\n    return getOriginBuf(result);\n}\n程序演示主文件:\n#include\"huffman.h\"\n\nint main(){\n    huffbufp buf = (huffbufp)malloc(sizeof(HuffBuf));\n\n    buf->code = \"this is just a test!\";\n    buf->size = strlen(buf->code);\n    huffresultp result = getHuffCodesByBuf(buf);    //获取编码结果\n    printf(\"huffman: %s\\n\",result->code);\n\n    huffbufp origin = getOriginBuf(result); //通过编码获取原始数据\n    printf(\"origin: %s\\n\",origin->code);\n\n    return 0;\n}\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的霍夫曼编码C代码", "Tag": "算法设计"}
{"Answer": "\nThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. .mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:\"\\\"\"\"\\\"\"\"'\"\"'\"}.mw-parser-output .citation .cs1-lock-free a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}ISBN 0-262-03293-7. Section 16.3, pp. 385–392.\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的參考文獻", "Tag": "算法设计"}
{"Answer": "有關霍夫曼壓縮技術的原文：D.A. Huffman, \"A method for the construction of minimum-redundancy codes\", Proceedings of the I.R.E., sept 1952, pp 1098-1102\n霍夫曼树图形演示 （页面存档备份，存于互联网档案馆）\nAnimation of the Huffman Algorithm: Algorithm Simulation by Simon Mescal\nBackground story: Profile: David A. Huffman, Scientific American, Sept. 1991, pp. 54-58\nn-ary Huffman Template Algorithm\nHuffman codes' connection with Fibonacci and Lucas numbers （页面存档备份，存于互联网档案馆）\nFibonacci connection between Huffman codes and Wythoff array\nSloane A098950 Minimizing k-ordered sequences of maximum height Huffman tree\nComputing Huffman codes on a Turing Machine\nMordecai J. Golin, Claire Kenyon, Neal E. Young \"Huffman coding with unequal letter costs （页面存档备份，存于互联网档案馆）\", STOC 2002 （页面存档备份，存于互联网档案馆）: 785-791\nHuffman Coding, implemented in python", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的外部連結", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "集合覆盖问题", "Question": "什么是集合覆盖问题", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "霍恩子句", "Question": "什么是霍恩子句", "Tag": "算法设计"}
{"Answer": "統計學上，中位數（英語：Median），又稱中央值[1]、中值，是一個樣本、種群或概率分佈中之一個數值，其可將數值集合劃分爲数量相等的上下兩部分。對於有限的數集，可以通過把所有觀察值高低排序後找出正中間的一個作爲中位數。如果觀察值有偶數個，則中位數不唯一，通常取最中間的兩個數值的平均數作爲中位數。\n一個數集中最多有一半的數值小於中位數，也最多有一半的數值大於中位數。如果大於和小於中位數的數值個數均少於一半，那麽數集中必有若干值等同於中位數。\n设连续随机变量X的分布函数为F(X)，那么满足条件P(X≤m)=F(m)=1/2的数称为X或分布F的中位数。\n对于一组有限个数的数据来说，其中位数是这样的一种数：这群数据的一半的数据比它大，而另外一半数据比它小。\n计算有限个数的数据的中位数的方法是：把所有的同类数据按照大小的顺序排列。如果数据的个数是奇数，则中间那个数据就是这群数据的中位数；如果数据的个数是偶数，则中间那2个数据的算术平均值就是这群数据的中位数。\n", "Konwledge_Point": "中位數", "Question": "什么是中位數", "Tag": "算法设计"}
{"Answer": "實數\n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n        ,\n        \n          x\n          \n            2\n          \n        \n        ,\n        …\n        ,\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x_{1},x_{2},\\dots ,x_{n}}\n  \n按大小順序（順序，降序皆可）排列為\n  \n    \n      \n        \n          x\n          \n            1\n          \n          ′\n        \n        ,\n        \n          x\n          \n            2\n          \n          ′\n        \n        ,\n        …\n        ,\n        \n          x\n          \n            n\n          \n          ′\n        \n      \n    \n    {\\displaystyle x'_{1},x'_{2},\\dots ,x'_{n}}\n  \n、\n實數數列\n  \n    \n      \n        x\n        =\n        (\n        \n          x\n          \n            1\n          \n        \n        ,\n        \n          x\n          \n            2\n          \n        \n        ,\n        …\n        ,\n        \n          x\n          \n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle x=(x_{1},x_{2},\\dots ,x_{n})}\n  \n的中位數 \n  \n    \n      \n        \n          \n            Q\n          \n          \n            \n              1\n              2\n            \n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle \\mathrm {Q} _{\\frac {1}{2}}(x)}\n  \n 為\n\n  \n    \n      \n        \n          \n            Q\n          \n          \n            \n              1\n              2\n            \n          \n        \n        (\n        x\n        )\n        =\n        \n          \n            {\n            \n              \n                \n                  \n                    x\n                    \n                      \n                        \n                          n\n                          +\n                          1\n                        \n                        2\n                      \n                    \n                    ′\n                  \n                  ,\n                \n                \n                  \n                    \n                      if \n                    \n                  \n                  n\n                  \n                    \n                       is odd number.\n                    \n                  \n                \n              \n              \n                \n                  \n                    \n                      1\n                      2\n                    \n                  \n                  (\n                  \n                    x\n                    \n                      \n                        n\n                        2\n                      \n                    \n                    ′\n                  \n                  +\n                  \n                    x\n                    \n                      \n                        \n                          n\n                          2\n                        \n                      \n                      +\n                      1\n                    \n                    ′\n                  \n                  )\n                  ,\n                \n                \n                  \n                    \n                      if \n                    \n                  \n                  n\n                  \n                    \n                       is even number.\n                    \n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle \\mathrm {Q} _{\\frac {1}{2}}(x)={\\begin{cases}x'_{\\frac {n+1}{2}},&{\\mbox{if }}n{\\mbox{ is odd number.}}\\\\{\\frac {1}{2}}(x'_{\\frac {n}{2}}+x'_{{\\frac {n}{2}}+1}),&{\\mbox{if }}n{\\mbox{ is even number.}}\\end{cases}}}\n  \n其中 odd number 表示奇數，even number 表示偶數。\n\n", "Konwledge_Point": "中位數", "Question": "什么是中位數的公式", "Tag": "算法设计"}
{"Answer": "中位數在敘述統計學上和平均数、众数並列為數據的集中趨勢。三者的位置排序亦對應著偏度的正負偏態意義。一般而言，平均數是最常被使用做為數據的集中趨勢，但如果有極端值存在，平均數的代表性降低，則中位數就是最佳的集中趨勢代表。因此，在各國的每人所得分布上，通常以中位數代表集中趨勢，而非平均數[2]。\n中位數通常出現在描述统计学和無母數統計，有母數的統計分析很少提及。中位數為集中趨勢時，對應的離散趨勢係數為平均絕對離差（Mean absolute deviation, MAD）或是四位位距(Q3 - Q1)。不過如果論及母體中位數的統計量時，仍需根據統計分析對抽樣分配的要求，尋找母體中位數統計量的期望值與變異數，再依照點估計的充分、不偏、效率、一致性進行討論。而母體中位數的統計量通常是樣本中位數。因此，樣本中位數的期望值與變異數就值得被討論，進行基礎研究。\n常態分配下的中位數[编辑]常態分配下的平均數、中位數、眾數都是同一個位置。目前最為世人熟知的是平均數的抽樣分配會是常態分配，期望值為母體平均數\n  \n    \n      \n        μ\n      \n    \n    {\\displaystyle \\mu }\n  \n且變異數為母體變異數(\n  \n    \n      \n        \n          σ\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\sigma _{2}}\n  \n)。統計學對常態分配的母體平均數統計量說明甚多，並發展完善。那麼中位數可基於機率分配模擬器和數值分析發展，在n個獨立隨機變數來自常態分配可生成n個隨機樣本，則E(樣本中位數)=\n  \n    \n      \n        μ\n      \n    \n    {\\displaystyle \\mu }\n  \n且Var(樣本中位數)=\n  \n    \n      \n        \n          σ\n          \n            2\n          \n        \n        k\n        (\n        n\n        )\n      \n    \n    {\\displaystyle \\sigma _{2}k(n)}\n  \n，其中，k(n)受到樣本個數(n)影響。當樣本個數介於2至200時，兩者的關係不明顯，但可計算出樣本個數和k(n)的關聯表[3]。\n", "Konwledge_Point": "中位數", "Question": "什么是中位數的中位數特性", "Tag": "算法设计"}
{"Answer": "常態分配下的平均數、中位數、眾數都是同一個位置。目前最為世人熟知的是平均數的抽樣分配會是常態分配，期望值為母體平均數\n  \n    \n      \n        μ\n      \n    \n    {\\displaystyle \\mu }\n  \n且變異數為母體變異數(\n  \n    \n      \n        \n          σ\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\sigma _{2}}\n  \n)。統計學對常態分配的母體平均數統計量說明甚多，並發展完善。那麼中位數可基於機率分配模擬器和數值分析發展，在n個獨立隨機變數來自常態分配可生成n個隨機樣本，則E(樣本中位數)=\n  \n    \n      \n        μ\n      \n    \n    {\\displaystyle \\mu }\n  \n且Var(樣本中位數)=\n  \n    \n      \n        \n          σ\n          \n            2\n          \n        \n        k\n        (\n        n\n        )\n      \n    \n    {\\displaystyle \\sigma _{2}k(n)}\n  \n，其中，k(n)受到樣本個數(n)影響。當樣本個數介於2至200時，兩者的關係不明顯，但可計算出樣本個數和k(n)的關聯表[3]。\n", "Konwledge_Point": "中位數", "Question": "什么是中位數的中位數特性的常態分配下的中位數", "Tag": "算法设计"}
{"Answer": "\n\n^ median - 中央值；中位數；正中的 - 國家教育研究院雙語詞彙. 國家教育研究院.   [2022-04-21]. （原始内容存档于2018-11-24） （中文（臺灣））. \n\n^ 台北市政府主計處，台北市家庭所得概況，民國106年。(連結 （页面存档备份，存于互联网档案馆）)\n\n^ (PDF) Source code of how to run sample median's variance. ResearchGate.   [2021-10-21]. doi:10.13140/rg.2.2.16784.23041 （英语）. \n\n^ (PDF) The Relationships between Variances of Normal Distribution and Sample Median: Sample size from 200 to 1000. ResearchGate.   [2021-10-31]. doi:10.13140/rg.2.2.12462.13124/1 （英语）. \n\n", "Konwledge_Point": "中位數", "Question": "什么是中位數的參考交獻", "Tag": "算法设计"}
{"Answer": "Calculating the median\nA problem involving the mean, the median, and the mode.（页面存档备份，存于互联网档案馆）\nmathworld: Statistical Median（页面存档备份，存于互联网档案馆）本條目含有来自PlanetMath《Median of a distribution》的內容，版权遵守知识共享协议：署名-相同方式共享协议。\n", "Konwledge_Point": "中位數", "Question": "什么是中位數的外部链接", "Tag": "算法设计"}
{"Answer": "单纯形法（simplex algorithm）在数学优化领域中常用于线性规划问题的数值求解，由喬治·伯納德·丹齊格发明。\n下山单纯形法（Nelder-Mead method）与单纯形法名称相似，但二者关联不大。该方法由Nelder和Mead于1965年发明，是用于优化多维无约束问题的一种数值方法，属于更普遍的搜索算法的类别。这两种方法都使用了单纯形的概念。单纯形是 \n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n 维中的 \n  \n    \n      \n        N\n        +\n        1\n      \n    \n    {\\displaystyle N+1}\n  \n 个顶点的凸包，是一个多胞体：直线上的一个线段，平面上的一个三角形，三维空间中的一个四面体等等，都是单纯形。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法", "Tag": "算法设计"}
{"Answer": "假设有n个变量和m个约束。线性规划的标准形式如下：\n\n  \n    \n      \n        \n          \n            \n              \n              \n              \n                max\n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        c\n                      \n                      \n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n              \n            \n            \n              \n              \n                s\n                .\n                t\n                .\n              \n              \n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        1\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n                ≤\n                \n                  \n                    \n                      b\n                    \n                    \n                      1\n                    \n                  \n                \n                ,\n              \n            \n            \n              \n              \n              \n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        2\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                  ≤\n                  \n                    \n                      \n                        b\n                      \n                      \n                        2\n                      \n                    \n                  \n                  ,\n                \n              \n            \n            \n              \n              \n                \n                .\n                .\n                .\n              \n            \n            \n              \n              \n              \n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        m\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n                ≤\n                \n                  \n                    \n                      b\n                    \n                    \n                      m\n                    \n                  \n                \n              \n            \n            \n              \n              \n              \n                \n                  \n                    \n                      x\n                    \n                    \n                      1\n                    \n                  \n                \n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      2\n                      ,\n                    \n                  \n                \n                .\n                .\n                .\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      n\n                    \n                  \n                \n                ≥\n                0\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}&&\\max \\sum \\limits _{1\\leq k\\leq n}{{{c}_{k}}{{x}_{k}}}\\\\&s.t.&\\sum \\limits _{1\\leq k\\leq n}{{{A}_{1,k}}{{x}_{k}}}\\leq {{b}_{1}},\\\\&&\\sum \\limits _{1\\leq k\\leq n}{{{A}_{2,k}}{{x}_{k}}\\leq {{b}_{2}},}\\\\&...\\\\&&\\sum \\limits _{1\\leq k\\leq n}{{{A}_{m,k}}{{x}_{k}}}\\leq {{b}_{m}}\\\\&&{{x}_{1}},{{x}_{2,}}...,{{x}_{n}}\\geq 0\\end{aligned}}}\n  \n所有其他形式的线性规划方程组都可以按照下列方式转化成标准形式：\n目标函数并非最大化：将所有\n  \n    \n      \n        \n          \n            \n              c\n            \n            \n              k\n            \n          \n        \n      \n    \n    {\\displaystyle {{c}_{k}}}\n  \n取负。\n约束条件中存在大于或等于约束：将约束两边取负。\n约束条件中存在等式：将其拆分为两个不等式（一个大于等于，一个小于等于）\n有的变量没有非负约束：加入新变量\n  \n    \n      \n        \n          x\n          ′\n        \n        ,\n        \n          x\n          ″\n        \n        (\n        \n          x\n          ′\n        \n        ,\n        \n          x\n          ″\n        \n        >=\n        0\n        )\n      \n    \n    {\\displaystyle x',x''(x',x''>=0)}\n  \n并用\n  \n    \n      \n        \n          x\n          ′\n        \n        −\n        \n          x\n          ″\n        \n      \n    \n    {\\displaystyle x'-x''}\n  \n替换原来的变量\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的标准形式", "Tag": "算法设计"}
{"Answer": "可以将标准形式的线性规划转化为松弛形式，以方便运算。\n在原来n个变量，m个约束的线性规划中，加入m个新的变量，将原来的不等式化为等式：\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              j\n            \n          \n        \n        =\n        \n          \n            \n              b\n            \n            \n              j\n            \n          \n        \n        −\n        \n          ∑\n          \n            1\n            ≤\n            k\n            ≤\n            n\n          \n        \n        \n          \n            \n              \n                A\n              \n              \n                j\n                ,\n                k\n              \n            \n          \n          \n            \n              \n                x\n              \n              \n                k\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+j}}={{b}_{j}}-\\sum \\limits _{1\\leq k\\leq n}{{{A}_{j,k}}{{x}_{k}}}}\n  \n\n当然，此时\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              j\n            \n          \n        \n        ≥\n        0\n      \n    \n    {\\displaystyle {{x}_{n+j}}\\geq 0}\n  \n依然成立。\n我们将\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              1\n            \n          \n        \n        ,\n        \n          \n            \n              x\n            \n            \n              2\n            \n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          \n            \n              x\n            \n            \n              n\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{1}},{{x}_{2}},...,{{x}_{n}}}\n  \n这些变量称为非基变量，它们构成的集合记为N。将\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              1\n            \n          \n        \n        ,\n        \n          \n            \n              x\n            \n            \n              n\n              +\n              2\n            \n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          \n            \n              x\n            \n            \n              n\n              +\n              m\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+1}},{{x}_{n+2}},...,{{x}_{n+m}}}\n  \n这些变量称为基变量，它们构成的集合记为B。简单地理解，非基变量能够由基变量唯一确定。\n在这样的定义下，线性规划的松弛形式可以写为如下形式：\n\n  \n    \n      \n        \n          \n            \n              \n              \n                \n                max\n                \n                  ∑\n                  \n                    k\n                    ∈\n                    N\n                  \n                \n                \n                  \n                    \n                      \n                        c\n                      \n                      \n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n              \n            \n            \n              \n              \n                s\n                .\n                t\n                .\n              \n            \n            \n              \n              \n                ∀\n                1\n                ≤\n                i\n                ≤\n                n\n                +\n                m\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      i\n                    \n                  \n                \n                ≥\n                0\n              \n            \n            \n              \n              \n                ∀\n                j\n                ∈\n                B\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      j\n                    \n                  \n                \n                =\n                \n                  \n                    \n                      b\n                    \n                    \n                      j\n                    \n                  \n                \n                −\n                \n                  ∑\n                  \n                    k\n                    ∈\n                    N\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        j\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}&\\max \\sum \\limits _{k\\in N}{{{c}_{k}}{{x}_{k}}}\\\\&s.t.\\\\&\\forall 1\\leq i\\leq n+m,{{x}_{i}}\\geq 0\\\\&\\forall j\\in B,{{x}_{j}}={{b}_{j}}-\\sum \\limits _{k\\in N}{{{A}_{j,k}}{{x}_{k}}}\\\\\\end{aligned}}}\n  \n\n因此，线性规划的松弛形式可以由\n  \n    \n      \n        c\n        ,\n        A\n        ,\n        b\n        ,\n        N\n        ,\n        B\n      \n    \n    {\\displaystyle c,A,b,N,B}\n  \n唯一确定，\n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n  \n是长度为n的向量，\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n是长度为m的向量，\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是m*(n+m)的矩阵。\n  \n    \n      \n        N\n        ,\n        B\n      \n    \n    {\\displaystyle N,B}\n  \n是整数集合，分别表示非基变量集合以及基变量集合。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的松弛形式", "Tag": "算法设计"}
{"Answer": "转轴操作是单纯形法中的核心操作，其作用是将一个基变量与一个非基变量进行互换。可以将转轴操作理解为从单纯形上的一个顶点走向另一个顶点。\n设变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}}\n  \n属于B（基变量），变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n属于N（非基变量），执行转轴操作pivot(d,e)之后，\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}}\n  \n将变为非基变量，相应地\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n将变为基变量。\n具体地说，一开始我们有\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n        =\n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n        −\n        \n          ∑\n          \n            k\n            ∈\n            N\n          \n        \n        \n          \n            \n              \n                A\n              \n              \n                d\n                ,\n                k\n              \n            \n          \n          \n            \n              \n                x\n              \n              \n                k\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}={{b}_{d}}-\\sum \\limits _{k\\in N}{{{A}_{d,k}}{{x}_{k}}}}\n  \n\n移项，得\n\n  \n    \n      \n        \n          A\n          \n            d\n            ,\n            e\n          \n        \n        \n          x\n          \n            e\n          \n        \n        =\n        \n          b\n          \n            d\n          \n        \n        −\n        \n          ∑\n          \n            k\n            ∈\n            N\n            ,\n            k\n            ≠\n            e\n          \n        \n        \n          A\n          \n            d\n            ,\n            k\n          \n        \n        \n          x\n          \n            k\n          \n        \n        −\n        \n          \n            x\n          \n          \n            n\n            +\n            d\n          \n        \n      \n    \n    {\\displaystyle A_{d,e}x_{e}=b_{d}-\\sum \\limits _{k\\in N,k\\neq e}A_{d,k}x_{k}-{x}_{n+d}}\n  \n\n如果\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        ≠\n        0\n      \n    \n    {\\displaystyle {{A}_{d,e}}\\neq 0}\n  \n，我们有\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n        =\n        \n          \n            \n              \n                b\n              \n              \n                d\n              \n            \n            \n              \n                A\n              \n              \n                d\n                ,\n                e\n              \n            \n          \n        \n        −\n        (\n        \n          ∑\n          \n            k\n            ∈\n            N\n            ,\n            k\n            ≠\n            e\n          \n        \n        \n          \n            \n              \n                \n                  A\n                \n                \n                  d\n                  ,\n                  k\n                \n              \n              \n                \n                  A\n                \n                \n                  d\n                  ,\n                  e\n                \n              \n            \n          \n          \n            \n              \n                x\n              \n              \n                k\n              \n            \n          \n          )\n        \n        −\n        \n          \n            1\n            \n              \n                A\n              \n              \n                d\n                ,\n                e\n              \n            \n          \n        \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}={\\frac {{b}_{d}}{{A}_{d,e}}}-(\\sum \\limits _{k\\in N,k\\neq e}{{\\frac {{A}_{d,k}}{{A}_{d,e}}}{{x}_{k}})}-{\\frac {1}{{A}_{d,e}}}{{x}_{n+d}}}\n  \n\n将此式代入其他的约束等式以及目标函数，我们就实现了\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}}\n  \n与\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n在基变量和非基变量上的互换。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的转轴操作", "Tag": "算法设计"}
{"Answer": "单纯形法的一般解题步骤可归纳如下：\n把线性规划问题的约束方程组表达成典范型方程组，找出基本可行解作为初始基本可行解。\n若基本可行解不存在，即约束条件有矛盾，则问题无解。\n若基本可行解存在，从初始基可行解作为起点，根据最优性条件和可行性条件，引入非基变量取代某一基变量，找出目标函数值更优的另一基本可行解。\n按步骤3进行迭代,直到对应检验数满足最优性条件（这时目标函数值不能再改善），即得到问题的最优解。\n若迭代过程中发现问题的目标函数值无界，则终止迭代。", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的方法步骤", "Tag": "算法设计"}
{"Answer": "如果b向量所有元素非负，则显然我们只需要令所有的变量等于0，就可以得到一个可行解。在这种情况下，通过下述最优化过程，我们可以得到该线性规划的最优解，或者指出该线性规划的最优解为无穷大（不存在）。\n任取一个非基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n，使得\n  \n    \n      \n        \n          \n            \n              c\n            \n            \n              e\n            \n          \n        \n        >\n        0\n      \n    \n    {\\displaystyle {{c}_{e}}>0}\n  \n。\n选取一个基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{d}}}\n  \n，使得\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        >\n        0\n      \n    \n    {\\displaystyle {{A}_{d,e}}>0}\n  \n，且最小化\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n        \n          /\n        \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        \n      \n    \n    {\\displaystyle {{b}_{d}}/{{A}_{d,e}}\\;}\n  \n\n执行转轴操作pivot(d, e)，并转到第一步继续算法。根据\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n        \n          /\n        \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        \n      \n    \n    {\\displaystyle {{b}_{d}}/{{A}_{d,e}}\\;}\n  \n的最小性不难证明pivot(d, e)不会破坏b的非负性。因此将所有变量取0值仍然是可行解。同时，根据\n  \n    \n      \n        Δ\n        v\n        =\n        \n          \n            \n              c\n            \n            \n              e\n            \n          \n        \n        \n          \n            \n              \n                b\n              \n              \n                d\n              \n            \n            \n              \n                A\n              \n              \n                d\n                ,\n                e\n              \n            \n          \n        \n        ≥\n        0\n      \n    \n    {\\displaystyle \\Delta v={{c}_{e}}{\\frac {{b}_{d}}{{A}_{d,e}}}\\geq 0}\n  \n，我们发现v一定是不降的。这就达到了更新解的目的。\n不难发现，算法终止有两种情况：\n对于所有的非基变量，c均非正。\n对于某一个e，所有的\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{A}_{d,e}}}\n  \n均非正。可以证明，对于第一种情况，我们已经得到了该线性规划的最优解。当前的v即为答案。严格证明比较复杂，但是直观上是很容易理解的。因为所有的非基变量都是非负的，而所有的c都是非正的，因此只要某个非基变量不为0，就会使得目标函数更小。\n对于第二种情况来说，很容易证明此时线性规划的最优解是无穷大。只要让其他所有变量均为0，变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n为正无穷。由于所有的\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{A}_{d,e}}}\n  \n都非正，因此非基变量的非负性得到保证。同时由于\n  \n    \n      \n        \n          \n            \n              c\n            \n            \n              e\n            \n          \n        \n        >\n        0\n      \n    \n    {\\displaystyle {{c}_{e}}>0}\n  \n，目标函数值为正无穷。\n实例[编辑]例：解最优化问题：\n\n  \n    \n      \n        min\n        \n        Z\n        =\n        −\n        \n          x\n          \n            1\n          \n        \n        −\n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\min \\quad Z=-x_{1}-x_{2}}\n  \n\n\n  \n    \n      \n        s\n        .\n        t\n        .\n        \n        2\n        \n          x\n          \n            1\n          \n        \n        +\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            3\n          \n        \n        =\n        12\n        ,\n      \n    \n    {\\displaystyle s.t.\\quad 2x_{1}+x_{2}+x_{3}=12,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            1\n          \n        \n        +\n        2\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            4\n          \n        \n        =\n        9\n        ,\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{1}+2x_{2}+x_{4}=9,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            i\n          \n        \n        ≥\n        0\n        ,\n        i\n        =\n        1\n        ,\n        2\n        ,\n        3\n        ,\n        4.\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{i}\\geq 0,i=1,2,3,4.}\n  \n\n列单纯形表（即矩阵）：\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的最优化过程", "Tag": "算法设计"}
{"Answer": "例：解最优化问题：\n\n  \n    \n      \n        min\n        \n        Z\n        =\n        −\n        \n          x\n          \n            1\n          \n        \n        −\n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\min \\quad Z=-x_{1}-x_{2}}\n  \n\n\n  \n    \n      \n        s\n        .\n        t\n        .\n        \n        2\n        \n          x\n          \n            1\n          \n        \n        +\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            3\n          \n        \n        =\n        12\n        ,\n      \n    \n    {\\displaystyle s.t.\\quad 2x_{1}+x_{2}+x_{3}=12,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            1\n          \n        \n        +\n        2\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            4\n          \n        \n        =\n        9\n        ,\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{1}+2x_{2}+x_{4}=9,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            i\n          \n        \n        ≥\n        0\n        ,\n        i\n        =\n        1\n        ,\n        2\n        ,\n        3\n        ,\n        4.\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{i}\\geq 0,i=1,2,3,4.}\n  \n\n列单纯形表（即矩阵）：\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的最优化过程的实例", "Tag": "算法设计"}
{"Answer": "如果b向量并不全为非负，则我们需要通过初始化过程来找到一个可行解，然后才可以使用最优化过程进行优化。当然，此时原线性规划不一定存在可行解。\n具体的方法是，加入一个新的非基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n，并在原线性规划的基础上构造一个新的辅助的线性规划。\n\n  \n    \n      \n        \n          \n            \n              \n              \n                \n                max\n                −\n                \n                  \n                    \n                      x\n                    \n                    \n                      0\n                    \n                  \n                \n              \n            \n            \n              \n              \n                s\n                .\n                t\n                .\n              \n            \n            \n              \n              \n                ∀\n                0\n                ≤\n                i\n                ≤\n                n\n                +\n                m\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      i\n                    \n                  \n                \n                ≥\n                0\n              \n            \n            \n              \n              \n                ∀\n                j\n                ∈\n                B\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      j\n                    \n                  \n                \n                =\n                \n                  \n                    \n                      b\n                    \n                    \n                      j\n                    \n                  \n                \n                −\n                (\n                \n                  ∑\n                  \n                    k\n                    ∈\n                    N\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        j\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n                )\n                +\n                \n                  \n                    \n                      x\n                    \n                    \n                      0\n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}&\\max -{{x}_{0}}\\\\&s.t.\\\\&\\forall 0\\leq i\\leq n+m,{{x}_{i}}\\geq 0\\\\&\\forall j\\in B,{{x}_{j}}={{b}_{j}}-(\\sum \\limits _{k\\in N}{{{A}_{j,k}}{{x}_{k}}})+{{x}_{0}}\\\\\\end{aligned}}}\n  \n\n注意这里N集合并不包含\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n。\n然后，选择一个基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{d}}}\n  \n使得\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{b}_{d}}}\n  \n最小，执行转轴操作pivot(d, 0)。不难证明该操作过后所有的b值全部非负。然后，使用前文中所述的最优化过程求解该辅助线性规划。\n由于\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n非负，因此该线性规划的答案非正。如果答案为负数，则说明原线性规划不可能让所有的基变量都非负，因此原线性规划无可行解。否则，只要令所有变量为0，并去掉\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n变量，就可以得到可行解。\n在从辅助线性规划转化到原来的线性规划的过程中，如果\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n已经是非基变量，则可以将其从约束条件和目标函数中直接去掉。否则，需要任取一个非基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n执行pivot(0, e)，将\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n变为非基变量。由于此时\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n是基变量且\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle {{x}_{0}}=0}\n  \n，故\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              0\n            \n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle {{b}_{0}}=0}\n  \n一定成立，因此这个转轴操作不会破坏b向量的非负性。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的初始化过程", "Tag": "算法设计"}
{"Answer": "在采用Bland's法则选择用于转轴操作的d和e（相同值的情况下取字典序最小）之后，可以证明单纯形法一定能够在有限步之后终止，但是最坏情况算法的时间复杂度为指數函數级别的，而且可以构造出让单纯形法的时间复杂度达到指数级别的具体实例。不过实践证明在绝大多数情况下单纯形法的效率非常令人满意。\n单纯形法的最坏时间复杂度为指数级别，并不意味着线性规划不存在多项式级别的算法。椭球算法和内点算法均为解决线性规划的多项式时间算法。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的效率分析", "Tag": "算法设计"}
{"Answer": "Greenberg, Harvey J., Klee-Minty Polytope Shows Exponential Time Complexity of Simplex Method University of Colorado at Denver (1997) PDF download （页面存档备份，存于互联网档案馆）\nFrederick S. Hillier and Gerald J. Lieberman: Introduction to Operations Research, 8th edition. McGraw-Hill. ISBN 0-07-123828-X\nThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 29.3: The simplex algorithm, pp.790–804.\nIOI2007国家集训队论文，《浅谈信息学竞赛中的线性规划——简洁高效的单纯形法实现与应用》，作者：李宇骞", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的参考", "Tag": "算法设计"}
{"Answer": "Nelder-Mead方法", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的参看", "Tag": "算法设计"}
{"Answer": "线性规划和单纯形法简介 （页面存档备份，存于互联网档案馆） 作者Spyros Reveliotis（乔治亚理工）。\n分步单纯形法求解器 （页面存档备份，存于互联网档案馆） 可以求解线性规划问题。\n基于Java的交互式单纯形工具 由Argonne国家实验室提供。\n单纯形法 作者Elmer G. Wiens。演示算法细节，使用了单纯形表。\n单纯形法教程 作者Stefan Waner，hofstra.edu。\n单纯形法分解 Mazoo学习网志.", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的外部链接", "Tag": "算法设计"}
{"Answer": "单纯形法（simplex algorithm）在数学优化领域中常用于线性规划问题的数值求解，由喬治·伯納德·丹齊格发明。\n下山单纯形法（Nelder-Mead method）与单纯形法名称相似，但二者关联不大。该方法由Nelder和Mead于1965年发明，是用于优化多维无约束问题的一种数值方法，属于更普遍的搜索算法的类别。这两种方法都使用了单纯形的概念。单纯形是 \n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n 维中的 \n  \n    \n      \n        N\n        +\n        1\n      \n    \n    {\\displaystyle N+1}\n  \n 个顶点的凸包，是一个多胞体：直线上的一个线段，平面上的一个三角形，三维空间中的一个四面体等等，都是单纯形。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法", "Tag": "算法设计"}
{"Answer": "假设有n个变量和m个约束。线性规划的标准形式如下：\n\n  \n    \n      \n        \n          \n            \n              \n              \n              \n                max\n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        c\n                      \n                      \n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n              \n            \n            \n              \n              \n                s\n                .\n                t\n                .\n              \n              \n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        1\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n                ≤\n                \n                  \n                    \n                      b\n                    \n                    \n                      1\n                    \n                  \n                \n                ,\n              \n            \n            \n              \n              \n              \n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        2\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                  ≤\n                  \n                    \n                      \n                        b\n                      \n                      \n                        2\n                      \n                    \n                  \n                  ,\n                \n              \n            \n            \n              \n              \n                \n                .\n                .\n                .\n              \n            \n            \n              \n              \n              \n                \n                  ∑\n                  \n                    1\n                    ≤\n                    k\n                    ≤\n                    n\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        m\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n                ≤\n                \n                  \n                    \n                      b\n                    \n                    \n                      m\n                    \n                  \n                \n              \n            \n            \n              \n              \n              \n                \n                  \n                    \n                      x\n                    \n                    \n                      1\n                    \n                  \n                \n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      2\n                      ,\n                    \n                  \n                \n                .\n                .\n                .\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      n\n                    \n                  \n                \n                ≥\n                0\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}&&\\max \\sum \\limits _{1\\leq k\\leq n}{{{c}_{k}}{{x}_{k}}}\\\\&s.t.&\\sum \\limits _{1\\leq k\\leq n}{{{A}_{1,k}}{{x}_{k}}}\\leq {{b}_{1}},\\\\&&\\sum \\limits _{1\\leq k\\leq n}{{{A}_{2,k}}{{x}_{k}}\\leq {{b}_{2}},}\\\\&...\\\\&&\\sum \\limits _{1\\leq k\\leq n}{{{A}_{m,k}}{{x}_{k}}}\\leq {{b}_{m}}\\\\&&{{x}_{1}},{{x}_{2,}}...,{{x}_{n}}\\geq 0\\end{aligned}}}\n  \n所有其他形式的线性规划方程组都可以按照下列方式转化成标准形式：\n目标函数并非最大化：将所有\n  \n    \n      \n        \n          \n            \n              c\n            \n            \n              k\n            \n          \n        \n      \n    \n    {\\displaystyle {{c}_{k}}}\n  \n取负。\n约束条件中存在大于或等于约束：将约束两边取负。\n约束条件中存在等式：将其拆分为两个不等式（一个大于等于，一个小于等于）\n有的变量没有非负约束：加入新变量\n  \n    \n      \n        \n          x\n          ′\n        \n        ,\n        \n          x\n          ″\n        \n        (\n        \n          x\n          ′\n        \n        ,\n        \n          x\n          ″\n        \n        >=\n        0\n        )\n      \n    \n    {\\displaystyle x',x''(x',x''>=0)}\n  \n并用\n  \n    \n      \n        \n          x\n          ′\n        \n        −\n        \n          x\n          ″\n        \n      \n    \n    {\\displaystyle x'-x''}\n  \n替换原来的变量\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的标准形式", "Tag": "算法设计"}
{"Answer": "可以将标准形式的线性规划转化为松弛形式，以方便运算。\n在原来n个变量，m个约束的线性规划中，加入m个新的变量，将原来的不等式化为等式：\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              j\n            \n          \n        \n        =\n        \n          \n            \n              b\n            \n            \n              j\n            \n          \n        \n        −\n        \n          ∑\n          \n            1\n            ≤\n            k\n            ≤\n            n\n          \n        \n        \n          \n            \n              \n                A\n              \n              \n                j\n                ,\n                k\n              \n            \n          \n          \n            \n              \n                x\n              \n              \n                k\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+j}}={{b}_{j}}-\\sum \\limits _{1\\leq k\\leq n}{{{A}_{j,k}}{{x}_{k}}}}\n  \n\n当然，此时\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              j\n            \n          \n        \n        ≥\n        0\n      \n    \n    {\\displaystyle {{x}_{n+j}}\\geq 0}\n  \n依然成立。\n我们将\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              1\n            \n          \n        \n        ,\n        \n          \n            \n              x\n            \n            \n              2\n            \n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          \n            \n              x\n            \n            \n              n\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{1}},{{x}_{2}},...,{{x}_{n}}}\n  \n这些变量称为非基变量，它们构成的集合记为N。将\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              1\n            \n          \n        \n        ,\n        \n          \n            \n              x\n            \n            \n              n\n              +\n              2\n            \n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          \n            \n              x\n            \n            \n              n\n              +\n              m\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+1}},{{x}_{n+2}},...,{{x}_{n+m}}}\n  \n这些变量称为基变量，它们构成的集合记为B。简单地理解，非基变量能够由基变量唯一确定。\n在这样的定义下，线性规划的松弛形式可以写为如下形式：\n\n  \n    \n      \n        \n          \n            \n              \n              \n                \n                max\n                \n                  ∑\n                  \n                    k\n                    ∈\n                    N\n                  \n                \n                \n                  \n                    \n                      \n                        c\n                      \n                      \n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n              \n            \n            \n              \n              \n                s\n                .\n                t\n                .\n              \n            \n            \n              \n              \n                ∀\n                1\n                ≤\n                i\n                ≤\n                n\n                +\n                m\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      i\n                    \n                  \n                \n                ≥\n                0\n              \n            \n            \n              \n              \n                ∀\n                j\n                ∈\n                B\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      j\n                    \n                  \n                \n                =\n                \n                  \n                    \n                      b\n                    \n                    \n                      j\n                    \n                  \n                \n                −\n                \n                  ∑\n                  \n                    k\n                    ∈\n                    N\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        j\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}&\\max \\sum \\limits _{k\\in N}{{{c}_{k}}{{x}_{k}}}\\\\&s.t.\\\\&\\forall 1\\leq i\\leq n+m,{{x}_{i}}\\geq 0\\\\&\\forall j\\in B,{{x}_{j}}={{b}_{j}}-\\sum \\limits _{k\\in N}{{{A}_{j,k}}{{x}_{k}}}\\\\\\end{aligned}}}\n  \n\n因此，线性规划的松弛形式可以由\n  \n    \n      \n        c\n        ,\n        A\n        ,\n        b\n        ,\n        N\n        ,\n        B\n      \n    \n    {\\displaystyle c,A,b,N,B}\n  \n唯一确定，\n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n  \n是长度为n的向量，\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n是长度为m的向量，\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是m*(n+m)的矩阵。\n  \n    \n      \n        N\n        ,\n        B\n      \n    \n    {\\displaystyle N,B}\n  \n是整数集合，分别表示非基变量集合以及基变量集合。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的松弛形式", "Tag": "算法设计"}
{"Answer": "转轴操作是单纯形法中的核心操作，其作用是将一个基变量与一个非基变量进行互换。可以将转轴操作理解为从单纯形上的一个顶点走向另一个顶点。\n设变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}}\n  \n属于B（基变量），变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n属于N（非基变量），执行转轴操作pivot(d,e)之后，\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}}\n  \n将变为非基变量，相应地\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n将变为基变量。\n具体地说，一开始我们有\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n        =\n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n        −\n        \n          ∑\n          \n            k\n            ∈\n            N\n          \n        \n        \n          \n            \n              \n                A\n              \n              \n                d\n                ,\n                k\n              \n            \n          \n          \n            \n              \n                x\n              \n              \n                k\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}={{b}_{d}}-\\sum \\limits _{k\\in N}{{{A}_{d,k}}{{x}_{k}}}}\n  \n\n移项，得\n\n  \n    \n      \n        \n          A\n          \n            d\n            ,\n            e\n          \n        \n        \n          x\n          \n            e\n          \n        \n        =\n        \n          b\n          \n            d\n          \n        \n        −\n        \n          ∑\n          \n            k\n            ∈\n            N\n            ,\n            k\n            ≠\n            e\n          \n        \n        \n          A\n          \n            d\n            ,\n            k\n          \n        \n        \n          x\n          \n            k\n          \n        \n        −\n        \n          \n            x\n          \n          \n            n\n            +\n            d\n          \n        \n      \n    \n    {\\displaystyle A_{d,e}x_{e}=b_{d}-\\sum \\limits _{k\\in N,k\\neq e}A_{d,k}x_{k}-{x}_{n+d}}\n  \n\n如果\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        ≠\n        0\n      \n    \n    {\\displaystyle {{A}_{d,e}}\\neq 0}\n  \n，我们有\n\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n        =\n        \n          \n            \n              \n                b\n              \n              \n                d\n              \n            \n            \n              \n                A\n              \n              \n                d\n                ,\n                e\n              \n            \n          \n        \n        −\n        (\n        \n          ∑\n          \n            k\n            ∈\n            N\n            ,\n            k\n            ≠\n            e\n          \n        \n        \n          \n            \n              \n                \n                  A\n                \n                \n                  d\n                  ,\n                  k\n                \n              \n              \n                \n                  A\n                \n                \n                  d\n                  ,\n                  e\n                \n              \n            \n          \n          \n            \n              \n                x\n              \n              \n                k\n              \n            \n          \n          )\n        \n        −\n        \n          \n            1\n            \n              \n                A\n              \n              \n                d\n                ,\n                e\n              \n            \n          \n        \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}={\\frac {{b}_{d}}{{A}_{d,e}}}-(\\sum \\limits _{k\\in N,k\\neq e}{{\\frac {{A}_{d,k}}{{A}_{d,e}}}{{x}_{k}})}-{\\frac {1}{{A}_{d,e}}}{{x}_{n+d}}}\n  \n\n将此式代入其他的约束等式以及目标函数，我们就实现了\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              n\n              +\n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{n+d}}}\n  \n与\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n在基变量和非基变量上的互换。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的转轴操作", "Tag": "算法设计"}
{"Answer": "单纯形法的一般解题步骤可归纳如下：\n把线性规划问题的约束方程组表达成典范型方程组，找出基本可行解作为初始基本可行解。\n若基本可行解不存在，即约束条件有矛盾，则问题无解。\n若基本可行解存在，从初始基可行解作为起点，根据最优性条件和可行性条件，引入非基变量取代某一基变量，找出目标函数值更优的另一基本可行解。\n按步骤3进行迭代,直到对应检验数满足最优性条件（这时目标函数值不能再改善），即得到问题的最优解。\n若迭代过程中发现问题的目标函数值无界，则终止迭代。", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的方法步骤", "Tag": "算法设计"}
{"Answer": "如果b向量所有元素非负，则显然我们只需要令所有的变量等于0，就可以得到一个可行解。在这种情况下，通过下述最优化过程，我们可以得到该线性规划的最优解，或者指出该线性规划的最优解为无穷大（不存在）。\n任取一个非基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n，使得\n  \n    \n      \n        \n          \n            \n              c\n            \n            \n              e\n            \n          \n        \n        >\n        0\n      \n    \n    {\\displaystyle {{c}_{e}}>0}\n  \n。\n选取一个基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{d}}}\n  \n，使得\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        >\n        0\n      \n    \n    {\\displaystyle {{A}_{d,e}}>0}\n  \n，且最小化\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n        \n          /\n        \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        \n      \n    \n    {\\displaystyle {{b}_{d}}/{{A}_{d,e}}\\;}\n  \n\n执行转轴操作pivot(d, e)，并转到第一步继续算法。根据\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n        \n          /\n        \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n        \n      \n    \n    {\\displaystyle {{b}_{d}}/{{A}_{d,e}}\\;}\n  \n的最小性不难证明pivot(d, e)不会破坏b的非负性。因此将所有变量取0值仍然是可行解。同时，根据\n  \n    \n      \n        Δ\n        v\n        =\n        \n          \n            \n              c\n            \n            \n              e\n            \n          \n        \n        \n          \n            \n              \n                b\n              \n              \n                d\n              \n            \n            \n              \n                A\n              \n              \n                d\n                ,\n                e\n              \n            \n          \n        \n        ≥\n        0\n      \n    \n    {\\displaystyle \\Delta v={{c}_{e}}{\\frac {{b}_{d}}{{A}_{d,e}}}\\geq 0}\n  \n，我们发现v一定是不降的。这就达到了更新解的目的。\n不难发现，算法终止有两种情况：\n对于所有的非基变量，c均非正。\n对于某一个e，所有的\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{A}_{d,e}}}\n  \n均非正。可以证明，对于第一种情况，我们已经得到了该线性规划的最优解。当前的v即为答案。严格证明比较复杂，但是直观上是很容易理解的。因为所有的非基变量都是非负的，而所有的c都是非正的，因此只要某个非基变量不为0，就会使得目标函数更小。\n对于第二种情况来说，很容易证明此时线性规划的最优解是无穷大。只要让其他所有变量均为0，变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n为正无穷。由于所有的\n  \n    \n      \n        \n          \n            \n              A\n            \n            \n              d\n              ,\n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{A}_{d,e}}}\n  \n都非正，因此非基变量的非负性得到保证。同时由于\n  \n    \n      \n        \n          \n            \n              c\n            \n            \n              e\n            \n          \n        \n        >\n        0\n      \n    \n    {\\displaystyle {{c}_{e}}>0}\n  \n，目标函数值为正无穷。\n实例[编辑]例：解最优化问题：\n\n  \n    \n      \n        min\n        \n        Z\n        =\n        −\n        \n          x\n          \n            1\n          \n        \n        −\n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\min \\quad Z=-x_{1}-x_{2}}\n  \n\n\n  \n    \n      \n        s\n        .\n        t\n        .\n        \n        2\n        \n          x\n          \n            1\n          \n        \n        +\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            3\n          \n        \n        =\n        12\n        ,\n      \n    \n    {\\displaystyle s.t.\\quad 2x_{1}+x_{2}+x_{3}=12,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            1\n          \n        \n        +\n        2\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            4\n          \n        \n        =\n        9\n        ,\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{1}+2x_{2}+x_{4}=9,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            i\n          \n        \n        ≥\n        0\n        ,\n        i\n        =\n        1\n        ,\n        2\n        ,\n        3\n        ,\n        4.\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{i}\\geq 0,i=1,2,3,4.}\n  \n\n列单纯形表（即矩阵）：\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的最优化过程", "Tag": "算法设计"}
{"Answer": "例：解最优化问题：\n\n  \n    \n      \n        min\n        \n        Z\n        =\n        −\n        \n          x\n          \n            1\n          \n        \n        −\n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\min \\quad Z=-x_{1}-x_{2}}\n  \n\n\n  \n    \n      \n        s\n        .\n        t\n        .\n        \n        2\n        \n          x\n          \n            1\n          \n        \n        +\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            3\n          \n        \n        =\n        12\n        ,\n      \n    \n    {\\displaystyle s.t.\\quad 2x_{1}+x_{2}+x_{3}=12,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            1\n          \n        \n        +\n        2\n        \n          x\n          \n            2\n          \n        \n        +\n        \n          x\n          \n            4\n          \n        \n        =\n        9\n        ,\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{1}+2x_{2}+x_{4}=9,}\n  \n\n\n  \n    \n      \n        \n        \n        \n        \n          x\n          \n            i\n          \n        \n        ≥\n        0\n        ,\n        i\n        =\n        1\n        ,\n        2\n        ,\n        3\n        ,\n        4.\n      \n    \n    {\\displaystyle \\quad \\quad \\quad x_{i}\\geq 0,i=1,2,3,4.}\n  \n\n列单纯形表（即矩阵）：\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的最优化过程的实例", "Tag": "算法设计"}
{"Answer": "如果b向量并不全为非负，则我们需要通过初始化过程来找到一个可行解，然后才可以使用最优化过程进行优化。当然，此时原线性规划不一定存在可行解。\n具体的方法是，加入一个新的非基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n，并在原线性规划的基础上构造一个新的辅助的线性规划。\n\n  \n    \n      \n        \n          \n            \n              \n              \n                \n                max\n                −\n                \n                  \n                    \n                      x\n                    \n                    \n                      0\n                    \n                  \n                \n              \n            \n            \n              \n              \n                s\n                .\n                t\n                .\n              \n            \n            \n              \n              \n                ∀\n                0\n                ≤\n                i\n                ≤\n                n\n                +\n                m\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      i\n                    \n                  \n                \n                ≥\n                0\n              \n            \n            \n              \n              \n                ∀\n                j\n                ∈\n                B\n                ,\n                \n                  \n                    \n                      x\n                    \n                    \n                      j\n                    \n                  \n                \n                =\n                \n                  \n                    \n                      b\n                    \n                    \n                      j\n                    \n                  \n                \n                −\n                (\n                \n                  ∑\n                  \n                    k\n                    ∈\n                    N\n                  \n                \n                \n                  \n                    \n                      \n                        A\n                      \n                      \n                        j\n                        ,\n                        k\n                      \n                    \n                  \n                  \n                    \n                      \n                        x\n                      \n                      \n                        k\n                      \n                    \n                  \n                \n                )\n                +\n                \n                  \n                    \n                      x\n                    \n                    \n                      0\n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}&\\max -{{x}_{0}}\\\\&s.t.\\\\&\\forall 0\\leq i\\leq n+m,{{x}_{i}}\\geq 0\\\\&\\forall j\\in B,{{x}_{j}}={{b}_{j}}-(\\sum \\limits _{k\\in N}{{{A}_{j,k}}{{x}_{k}}})+{{x}_{0}}\\\\\\end{aligned}}}\n  \n\n注意这里N集合并不包含\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n。\n然后，选择一个基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{d}}}\n  \n使得\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              d\n            \n          \n        \n      \n    \n    {\\displaystyle {{b}_{d}}}\n  \n最小，执行转轴操作pivot(d, 0)。不难证明该操作过后所有的b值全部非负。然后，使用前文中所述的最优化过程求解该辅助线性规划。\n由于\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n非负，因此该线性规划的答案非正。如果答案为负数，则说明原线性规划不可能让所有的基变量都非负，因此原线性规划无可行解。否则，只要令所有变量为0，并去掉\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n变量，就可以得到可行解。\n在从辅助线性规划转化到原来的线性规划的过程中，如果\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n已经是非基变量，则可以将其从约束条件和目标函数中直接去掉。否则，需要任取一个非基变量\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              e\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{e}}}\n  \n执行pivot(0, e)，将\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n变为非基变量。由于此时\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n      \n    \n    {\\displaystyle {{x}_{0}}}\n  \n是基变量且\n  \n    \n      \n        \n          \n            \n              x\n            \n            \n              0\n            \n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle {{x}_{0}}=0}\n  \n，故\n  \n    \n      \n        \n          \n            \n              b\n            \n            \n              0\n            \n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle {{b}_{0}}=0}\n  \n一定成立，因此这个转轴操作不会破坏b向量的非负性。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的初始化过程", "Tag": "算法设计"}
{"Answer": "在采用Bland's法则选择用于转轴操作的d和e（相同值的情况下取字典序最小）之后，可以证明单纯形法一定能够在有限步之后终止，但是最坏情况算法的时间复杂度为指數函數级别的，而且可以构造出让单纯形法的时间复杂度达到指数级别的具体实例。不过实践证明在绝大多数情况下单纯形法的效率非常令人满意。\n单纯形法的最坏时间复杂度为指数级别，并不意味着线性规划不存在多项式级别的算法。椭球算法和内点算法均为解决线性规划的多项式时间算法。\n", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的效率分析", "Tag": "算法设计"}
{"Answer": "Greenberg, Harvey J., Klee-Minty Polytope Shows Exponential Time Complexity of Simplex Method University of Colorado at Denver (1997) PDF download （页面存档备份，存于互联网档案馆）\nFrederick S. Hillier and Gerald J. Lieberman: Introduction to Operations Research, 8th edition. McGraw-Hill. ISBN 0-07-123828-X\nThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 29.3: The simplex algorithm, pp.790–804.\nIOI2007国家集训队论文，《浅谈信息学竞赛中的线性规划——简洁高效的单纯形法实现与应用》，作者：李宇骞", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的参考", "Tag": "算法设计"}
{"Answer": "Nelder-Mead方法", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的参看", "Tag": "算法设计"}
{"Answer": "线性规划和单纯形法简介 （页面存档备份，存于互联网档案馆） 作者Spyros Reveliotis（乔治亚理工）。\n分步单纯形法求解器 （页面存档备份，存于互联网档案馆） 可以求解线性规划问题。\n基于Java的交互式单纯形工具 由Argonne国家实验室提供。\n单纯形法 作者Elmer G. Wiens。演示算法细节，使用了单纯形表。\n单纯形法教程 作者Stefan Waner，hofstra.edu。\n单纯形法分解 Mazoo学习网志.", "Konwledge_Point": "单纯形法", "Question": "什么是单纯形法的外部链接", "Tag": "算法设计"}
{"Answer": "算术基本定理，又称为正整數的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2個或以上的質數的积，而且这些質因子按大小排列之后，写法僅有一種方式。\n例如：\n  \n    \n      \n        6936\n        =\n        \n          2\n          \n            3\n          \n        \n        ×\n        3\n        ×\n        \n          17\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle 6936=2^{3}\\times 3\\times 17^{2}}\n  \n，\n  \n    \n      \n        1200\n        =\n        \n          2\n          \n            4\n          \n        \n        ×\n        3\n        ×\n        \n          5\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle 1200=2^{4}\\times 3\\times 5^{2}}\n  \n，\n  \n    \n      \n        5207\n        =\n        41\n        ×\n        127\n      \n    \n    {\\displaystyle 5207=41\\times 127}\n  \n。\n算术基本定理的内容由两部分构成：\n分解的存在性：\n分解的唯一性，即若不考虑排列的顺序，正整数分解为素數乘积的方式是唯一的。算术基本定理是初等數論中一个基本的定理，也是许多其他定理的逻辑支撑点和出发点。\n", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        ∀\n        A\n        ∈\n        \n          N\n        \n        ,\n        \n        A\n        >\n        1\n        \n        ∃\n        \n          ∏\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          p\n          \n            i\n          \n          \n            \n              a\n              \n                i\n              \n            \n          \n        \n        =\n        A\n      \n    \n    {\\displaystyle \\forall A\\in \\mathbb {N} ,\\,A>1\\quad \\exists \\prod _{i=1}^{n}p_{i}^{a_{i}}=A}\n  \n. 其中 \n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n        <\n        \n          p\n          \n            2\n          \n        \n        <\n        \n          p\n          \n            3\n          \n        \n        <\n        ⋯\n        <\n        \n          p\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle p_{1}<p_{2}<p_{3}<\\cdots <p_{n}}\n  \n 而且 \n  \n    \n      \n        \n          p\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle p_{i}}\n  \n 是一个質数，\n  \n    \n      \n        \n          a\n          \n            i\n          \n        \n        ∈\n        \n          \n            Z\n          \n          \n            +\n          \n        \n      \n    \n    {\\displaystyle a_{i}\\in \\mathbb {Z} ^{+}}\n  \n.\n這種表示的方法存在，而且是唯一的。\n", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理的定理陳述", "Tag": "算法设计"}
{"Answer": "算术基本定理的最早证明是由欧几里得给出的。准确的说，欧几里得证明了在一般整环上看与算术基本定理等价的命题：若質數\n  \n    \n      \n        p\n        \n          |\n        \n        a\n        b\n      \n    \n    {\\displaystyle p|ab}\n  \n，则不是 \n  \n    \n      \n        p\n        \n          |\n        \n        a\n      \n    \n    {\\displaystyle p|a}\n  \n，就是\n  \n    \n      \n        p\n        \n          |\n        \n        b\n      \n    \n    {\\displaystyle p|b}\n  \n。然而，在欧几里得的时代，并没有发展出幂运算和指数的写法，甚至连四个整数的乘积这种算式都被认为是没有意义的，所以欧几里得并没有给出算术基本定理的现代陈述。\n存在性[编辑]用反證法：假設存在大於 \n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n 的自然數不能寫成質數的乘積，把最小的那個稱為 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n。\n\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 不可爲質數，因爲 \n  \n    \n      \n        n\n        =\n        n\n      \n    \n    {\\displaystyle n=n}\n  \n 可被寫成質數的乘積。因此 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 一定是合數，但每個合數都可以分解成兩個嚴格小於自身而大於 \n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n 的自然數的積。設 \n\n  \n    \n      \n        n\n        =\n        a\n        ×\n        b\n      \n    \n    {\\displaystyle n=a\\times b}\n  \n ，則根據假設，由於 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 是最小的不能被寫成質數乘積的自然數，所以 \n  \n    \n      \n        a\n        =\n        \n          p\n          \n            1\n          \n        \n        \n          p\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          p\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle a=p_{1}p_{2}...p_{j}}\n  \n 和 \n  \n    \n      \n        b\n        =\n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          q\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle b=q_{1}q_{2}...q_{j}}\n  \n 都能被寫成質數的乘積。然而 \n  \n    \n      \n        n\n        =\n        a\n        b\n        =\n        \n          p\n          \n            1\n          \n        \n        \n          p\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          p\n          \n            j\n          \n        \n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          q\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle n=ab=p_{1}p_{2}...p_{j}q_{1}q_{2}...q_{j}}\n  \n 也可以寫成質數的乘積，由此產生矛盾，故大於 \n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n 的自然數必可寫成質數的乘積。\n唯一性[编辑]歐幾里得引理：若質數\n  \n    \n      \n        p\n        \n          |\n        \n        a\n        b\n      \n    \n    {\\displaystyle p|ab}\n  \n，则不是 \n  \n    \n      \n        p\n        \n          |\n        \n        a\n      \n    \n    {\\displaystyle p|a}\n  \n，就是\n  \n    \n      \n        p\n        \n          |\n        \n        b\n      \n    \n    {\\displaystyle p|b}\n  \n。\n引理的证明：若\n  \n    \n      \n        p\n        \n          |\n        \n        a\n      \n    \n    {\\displaystyle p|a}\n  \n 则证明完毕。若\n  \n    \n      \n        p\n        ∤\n        a\n      \n    \n    {\\displaystyle p\\nmid a}\n  \n，那么两者的最大公约数为1。根据貝祖等式，存在\n  \n    \n      \n        (\n        m\n        ,\n        n\n        )\n      \n    \n    {\\displaystyle (m,n)}\n  \n 使得\n  \n    \n      \n        m\n        a\n        +\n        n\n        p\n        =\n        1\n      \n    \n    {\\displaystyle ma+np=1}\n  \n。于是\n  \n    \n      \n        b\n        =\n        b\n        (\n        m\n        a\n        +\n        n\n        p\n        )\n        =\n        a\n        b\n        m\n        +\n        b\n        n\n        p\n      \n    \n    {\\displaystyle b=b(ma+np)=abm+bnp}\n  \n。\n由于\n  \n    \n      \n        p\n        \n          |\n        \n        a\n        b\n      \n    \n    {\\displaystyle p|ab}\n  \n，上式右边两项都可以被p整除。所以\n  \n    \n      \n        p\n        \n          |\n        \n        b\n      \n    \n    {\\displaystyle p|b}\n  \n。\n再用反證法：假設有些大于1的自然數可以以多于一种的方式寫成多个質數的乘積，那么假设\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n是其中最小的一個。\n首先\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n不是質数。將\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n用兩種方法寫出：\n  \n    \n      \n        n\n        =\n        \n          p\n          \n            1\n          \n        \n        \n          p\n          \n            2\n          \n        \n        \n          p\n          \n            3\n          \n        \n        ⋯\n        \n          p\n          \n            r\n          \n        \n        =\n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle n=p_{1}p_{2}p_{3}\\cdots p_{r}=q_{1}q_{2}q_{3}\\cdots q_{s}}\n  \n 。根據引理，質数\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n        \n          |\n        \n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle p_{1}|q_{1}q_{2}q_{3}\\cdots q_{s}}\n  \n ，所以\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n        ,\n        \n          q\n          \n            2\n          \n        \n        ,\n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle q_{1},q_{2},q_{3}\\cdots q_{s}}\n  \n 中有一個能被\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n整除，不妨设为\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle q_{1}}\n  \n。但\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle q_{1}}\n  \n也是質数，因此\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n        =\n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle q_{1}=p_{1}}\n  \n 。所以，比\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n小的正整数\n  \n    \n      \n        \n          n\n          ′\n        \n        =\n        \n          p\n          \n            2\n          \n        \n        \n          p\n          \n            3\n          \n        \n        ⋯\n        \n          p\n          \n            r\n          \n        \n      \n    \n    {\\displaystyle n'=p_{2}p_{3}\\cdots p_{r}}\n  \n也可以写成\n  \n    \n      \n        \n          q\n          \n            2\n          \n        \n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle q_{2}q_{3}\\cdots q_{s}}\n  \n 。这与\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 的最小性矛盾！\n因此唯一性得证。\n", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理的證明", "Tag": "算法设计"}
{"Answer": "用反證法：假設存在大於 \n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n 的自然數不能寫成質數的乘積，把最小的那個稱為 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n。\n\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 不可爲質數，因爲 \n  \n    \n      \n        n\n        =\n        n\n      \n    \n    {\\displaystyle n=n}\n  \n 可被寫成質數的乘積。因此 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 一定是合數，但每個合數都可以分解成兩個嚴格小於自身而大於 \n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n 的自然數的積。設 \n\n  \n    \n      \n        n\n        =\n        a\n        ×\n        b\n      \n    \n    {\\displaystyle n=a\\times b}\n  \n ，則根據假設，由於 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 是最小的不能被寫成質數乘積的自然數，所以 \n  \n    \n      \n        a\n        =\n        \n          p\n          \n            1\n          \n        \n        \n          p\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          p\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle a=p_{1}p_{2}...p_{j}}\n  \n 和 \n  \n    \n      \n        b\n        =\n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          q\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle b=q_{1}q_{2}...q_{j}}\n  \n 都能被寫成質數的乘積。然而 \n  \n    \n      \n        n\n        =\n        a\n        b\n        =\n        \n          p\n          \n            1\n          \n        \n        \n          p\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          p\n          \n            j\n          \n        \n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        .\n        .\n        .\n        \n          q\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle n=ab=p_{1}p_{2}...p_{j}q_{1}q_{2}...q_{j}}\n  \n 也可以寫成質數的乘積，由此產生矛盾，故大於 \n  \n    \n      \n        1\n      \n    \n    {\\displaystyle 1}\n  \n 的自然數必可寫成質數的乘積。\n", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理的證明的存在性", "Tag": "算法设计"}
{"Answer": "歐幾里得引理：若質數\n  \n    \n      \n        p\n        \n          |\n        \n        a\n        b\n      \n    \n    {\\displaystyle p|ab}\n  \n，则不是 \n  \n    \n      \n        p\n        \n          |\n        \n        a\n      \n    \n    {\\displaystyle p|a}\n  \n，就是\n  \n    \n      \n        p\n        \n          |\n        \n        b\n      \n    \n    {\\displaystyle p|b}\n  \n。\n引理的证明：若\n  \n    \n      \n        p\n        \n          |\n        \n        a\n      \n    \n    {\\displaystyle p|a}\n  \n 则证明完毕。若\n  \n    \n      \n        p\n        ∤\n        a\n      \n    \n    {\\displaystyle p\\nmid a}\n  \n，那么两者的最大公约数为1。根据貝祖等式，存在\n  \n    \n      \n        (\n        m\n        ,\n        n\n        )\n      \n    \n    {\\displaystyle (m,n)}\n  \n 使得\n  \n    \n      \n        m\n        a\n        +\n        n\n        p\n        =\n        1\n      \n    \n    {\\displaystyle ma+np=1}\n  \n。于是\n  \n    \n      \n        b\n        =\n        b\n        (\n        m\n        a\n        +\n        n\n        p\n        )\n        =\n        a\n        b\n        m\n        +\n        b\n        n\n        p\n      \n    \n    {\\displaystyle b=b(ma+np)=abm+bnp}\n  \n。\n由于\n  \n    \n      \n        p\n        \n          |\n        \n        a\n        b\n      \n    \n    {\\displaystyle p|ab}\n  \n，上式右边两项都可以被p整除。所以\n  \n    \n      \n        p\n        \n          |\n        \n        b\n      \n    \n    {\\displaystyle p|b}\n  \n。\n再用反證法：假設有些大于1的自然數可以以多于一种的方式寫成多个質數的乘積，那么假设\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n是其中最小的一個。\n首先\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n不是質数。將\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n用兩種方法寫出：\n  \n    \n      \n        n\n        =\n        \n          p\n          \n            1\n          \n        \n        \n          p\n          \n            2\n          \n        \n        \n          p\n          \n            3\n          \n        \n        ⋯\n        \n          p\n          \n            r\n          \n        \n        =\n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle n=p_{1}p_{2}p_{3}\\cdots p_{r}=q_{1}q_{2}q_{3}\\cdots q_{s}}\n  \n 。根據引理，質数\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n        \n          |\n        \n        \n          q\n          \n            1\n          \n        \n        \n          q\n          \n            2\n          \n        \n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle p_{1}|q_{1}q_{2}q_{3}\\cdots q_{s}}\n  \n ，所以\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n        ,\n        \n          q\n          \n            2\n          \n        \n        ,\n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle q_{1},q_{2},q_{3}\\cdots q_{s}}\n  \n 中有一個能被\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n整除，不妨设为\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle q_{1}}\n  \n。但\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle q_{1}}\n  \n也是質数，因此\n  \n    \n      \n        \n          q\n          \n            1\n          \n        \n        =\n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle q_{1}=p_{1}}\n  \n 。所以，比\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n小的正整数\n  \n    \n      \n        \n          n\n          ′\n        \n        =\n        \n          p\n          \n            2\n          \n        \n        \n          p\n          \n            3\n          \n        \n        ⋯\n        \n          p\n          \n            r\n          \n        \n      \n    \n    {\\displaystyle n'=p_{2}p_{3}\\cdots p_{r}}\n  \n也可以写成\n  \n    \n      \n        \n          q\n          \n            2\n          \n        \n        \n          q\n          \n            3\n          \n        \n        ⋯\n        \n          q\n          \n            s\n          \n        \n      \n    \n    {\\displaystyle q_{2}q_{3}\\cdots q_{s}}\n  \n 。这与\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 的最小性矛盾！\n因此唯一性得证。\n", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理的證明的唯一性", "Tag": "算法设计"}
{"Answer": "在一般的數域中，並不存在相應的定理；事實上，在虛二次域 \n  \n    \n      \n        \n          Q\n        \n        (\n        \n          \n            −\n            D\n          \n        \n        )\n        \n        (\n        D\n        ∈\n        \n          N\n        \n        )\n      \n    \n    {\\displaystyle \\mathbb {Q} ({\\sqrt {-D}})\\quad (D\\in \\mathbb {N} )}\n  \n 之中，只有少數幾個能滿足，最大的一個 \n  \n    \n      \n        D\n      \n    \n    {\\displaystyle D}\n  \n 是 \n  \n    \n      \n        D\n        =\n        163\n      \n    \n    {\\displaystyle D=163}\n  \n。例如，\n  \n    \n      \n        6\n      \n    \n    {\\displaystyle 6}\n  \n可以以兩種方式在 \n  \n    \n      \n        \n          Z\n        \n        [\n        \n          \n            −\n            5\n          \n        \n        ]\n      \n    \n    {\\displaystyle \\mathbb {Z} [{\\sqrt {-5}}]}\n  \n 中表成整數乘積：\n  \n    \n      \n        2\n        ×\n        3\n      \n    \n    {\\displaystyle 2\\times 3}\n  \n 和 \n  \n    \n      \n        (\n        1\n        +\n        \n          \n            −\n            5\n          \n        \n        )\n        (\n        1\n        −\n        \n          \n            −\n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle (1+{\\sqrt {-5}})(1-{\\sqrt {-5}})}\n  \n。同樣的，在分圓整數中一般也不存在唯一分解性，而這恰恰是人們在証明費馬大定理時所遇到的陷阱之一。\n歐幾里得在普通整數 \n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbb {Z} }\n  \n 中証明了算術基本定理──每個整數可唯一地分解為素數的乘積，高斯則在複整數 \n  \n    \n      \n        \n          Z\n        \n        [\n        \n          \n            −\n            1\n          \n        \n        ]\n      \n    \n    {\\displaystyle \\mathbb {Z} [{\\sqrt {-1}}]}\n  \n 中得出並証明，只要不計四個可逆元素 \n  \n    \n      \n        (\n        ±\n        1\n        ,\n        ±\n        i\n        )\n      \n    \n    {\\displaystyle (\\pm 1,\\pm i)}\n  \n 之作用，那麼這個唯一分解定理在 \n  \n    \n      \n        \n          Z\n        \n        [\n        \n          \n            −\n            1\n          \n        \n        ]\n      \n    \n    {\\displaystyle \\mathbb {Z} [{\\sqrt {-1}}]}\n  \n 也成立。高斯還指出，包括費馬大定理在內的普通素數的許多定理都可能擴大到複數域。\n", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理的相關", "Tag": "算法设计"}
{"Answer": "对于二次方程：\n  \n    \n      \n        a\n        \n          x\n          \n            2\n          \n        \n        +\n        b\n        x\n        +\n        c\n        =\n        0\n        \n        \n          (\n          \n            a\n            ≠\n            0\n          \n          )\n        \n      \n    \n    {\\displaystyle ax^{2}+bx+c=0\\qquad \\left(a\\neq 0\\right)}\n  \n，它的根可以表示为：\n\n  \n    \n      \n        \n          x\n          \n            1\n            ,\n            2\n          \n        \n        =\n        \n          \n            \n              −\n              b\n              ±\n              \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                  −\n                  4\n                  a\n                  c\n                   \n                \n              \n            \n            \n              2\n              a\n            \n          \n        \n      \n    \n    {\\displaystyle x_{1,2}={\\frac {-b\\pm {\\sqrt {b^{2}-4ac\\ }}}{2a}}}\n  \n\n因为负数不能开平方，\n  \n    \n      \n        \n          b\n          \n            2\n          \n        \n        −\n        4\n        a\n        c\n      \n    \n    {\\displaystyle b^{2}-4ac}\n  \n的符号就很重要，如果为正，有两个根；如果为0，只有一个根；如果为负，没有实根。欧拉的素数公式：\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          x\n          \n            2\n          \n        \n        +\n        x\n        +\n        41\n        \n        \n          (\n          \n            a\n            ≠\n            0\n          \n          )\n        \n      \n    \n    {\\displaystyle f(x)=x^{2}+x+41\\qquad \\left(a\\neq 0\\right)}\n  \n\n\n  \n    \n      \n        \n          b\n          \n            2\n          \n        \n        −\n        4\n        a\n        c\n        =\n        1\n        −\n        164\n        =\n        −\n        163\n      \n    \n    {\\displaystyle b^{2}-4ac=1-164=-163}\n  \n\n两个复数解為:\n\n  \n    \n      \n        \n          x\n          \n            1\n            ,\n            2\n          \n        \n        =\n        \n          \n            \n              −\n              1\n              ±\n              \n                \n                  163\n                \n              \n              i\n            \n            2\n          \n        \n      \n    \n    {\\displaystyle x_{1,2}={\\frac {-1\\pm {\\sqrt {163}}i}{2}}}\n  \n\n\n  \n    \n      \n        a\n        +\n        b\n        \n          \n            \n              −\n              d\n            \n            \n\n            \n          \n        \n      \n    \n    {\\displaystyle a+b{\\sqrt[{}]{-d}}}\n  \n哪个\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n值可以得到唯一分解定理？\n\n  \n    \n      \n        d\n        =\n        1\n        ,\n        2\n        ,\n        3\n      \n    \n    {\\displaystyle d=1,2,3}\n  \n皆可得到定理，但當\n  \n    \n      \n        d\n        =\n        5\n      \n    \n    {\\displaystyle d=5}\n  \n时不能。因为在这个数系中6这个数有两种形式的因子分解（分解至不可分约的情形）。\n\n  \n    \n      \n        6\n        =\n        2\n        ×\n        3\n      \n    \n    {\\displaystyle 6=2\\times 3}\n  \n；\n  \n    \n      \n        6\n        =\n        (\n        1\n        +\n        \n          \n            −\n            5\n          \n        \n        )\n        (\n        1\n        −\n        \n          \n            −\n            5\n          \n        \n        )\n      \n    \n    {\\displaystyle 6=(1+{\\sqrt {-5}})(1-{\\sqrt {-5}})}\n  \n。在高斯时代，已知有9个\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n使得\n  \n    \n      \n        a\n        +\n        b\n        \n          \n            \n              −\n              d\n            \n            \n\n            \n          \n        \n      \n    \n    {\\displaystyle a+b{\\sqrt[{}]{-d}}}\n  \n所产生的数有唯一因子分解（\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n，\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n如上面指出那样取值）。\n\n  \n    \n      \n        d\n        =\n        1\n        ,\n        2\n        ,\n        3\n        ,\n        7\n        ,\n        11\n        ,\n        19\n        ,\n        43\n        ,\n        67\n        ,\n        163\n      \n    \n    {\\displaystyle d=1,2,3,7,11,19,43,67,163}\n  \n高斯认为\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n的數量不會超過10個，但是没有人能够证明。\n1952年，业余数学家，退休的瑞士工程师庫爾特·黑格納（英语：Kurt Heegner）（Kurt Heegner）发表了他的证明，声称第10个高斯类数不存在。但是没有人相信他。世界又等待了15年之后才知道这个定理：麻省理工学院的斯塔克（Harold Stark）和剑桥大学的阿兰贝克（AlanBaker）独立用不同方法证明了第10个\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n值不存在。两个人重新检查了希格内尔的工作，发现他的证明是正确的。\n为了紀念长期被忽视的希格内尔，上述的9個數被稱為黑格纳数，一些曲线上的点被命名为希格内尔点。\n参见《数学新的黄金时代》和其它数学书籍。\n", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理的高斯类数", "Tag": "算法设计"}
{"Answer": "（英文） Fundamental Theorem of Arithmetic - Wolfram Demonstrations Project （页面存档备份，存于互联网档案馆）", "Konwledge_Point": "算术基本定理", "Question": "什么是算术基本定理的外部連結", "Tag": "算法设计"}
{"Answer": "在计算机科学中，最长递增子序列（longest increasing subsequence）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。许多与数学、算法、随机矩阵理论（英语：random matrix theory）、表示论相关的研究都会涉及最长递增子序列。[1]解决最长递增子序列问题的算法最低要求O(n log n)的時間複雜度，这里n表示输入序列的规模。[2]\n", "Konwledge_Point": "最长递增子序列", "Question": "什么是最长递增子序列", "Tag": "算法设计"}
{"Answer": "对于以下的原始序列\n0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15最长递增子序列为\n0, 2, 6, 9, 11, 15.值得注意的是原始序列的最长递增子序列并不一定唯一，对于该原始序列，实际上还有以下三个最长递增子序列\n0, 4, 6, 9, 11, 15\n0, 4, 6, 9, 13, 15\n0, 2, 6, 9, 13, 15\n", "Konwledge_Point": "最长递增子序列", "Question": "什么是最长递增子序列的例子", "Tag": "算法设计"}
{"Answer": "最长递增子序列问题与最长公共子序列问题密切相关，后者具有动态规划解决方案（时间复杂度为O(n 2)）：序列S的最长递增子序列是S和T的最长公共子序列，其中T是对S进行排序的结果。但对于特殊情况，输入是整数 1, 2, ..., n, 的排列，解决方案可以进一步改进，从而使时间复杂度降为O(n log n)[3] 。\n排列图（permutation graph)中的最大团是由'定义该图的排列中最长的递减子序列'定义的, 求最长的递减子序列在计算复杂度上（通过对所有数取它的负数）等同于求最长的递增子序列。 因此，最长递增子序列算法可用于有效地解决排列图中的分团问题[4]。\n", "Konwledge_Point": "最长递增子序列", "Question": "什么是最长递增子序列的相关算法", "Tag": "算法设计"}
{"Answer": "下面概述的算法使用数组和二分查找算法有效地解决了最长递增子序列问题。 它依次处理序列元素，保存当前找到的最长的递增子序列， 比如: [X[0]，X [1]]。在处理X[i]之后，算法会将值存储在两个数组中：\nM[j]  — 存储值最小的X [k]的索引k，以使在范围k≤i上，以X [k]结尾的长度为j的子序列增加。 注意：j ≤ (i+1)，因为j≥1表示递增子序列的长度，而k≥0表示其终止的索引。\nP[k]  — 将X [k]的前任索引存储在以X [k]结尾的最长递增子序列中。另外，该算法还存储了一个变量L，该变量L表示到目前为止找到的最长的递增子序列的长度。 下面的算法使用基于零的编号，为了清楚起见，M用M [0]填充，而M [0]未使用，因此M [j]对应于长度j的子序列。 实际的实现可以跳过M [0]并相应地调整索引。\n请注意，在算法的任何时候，序列\nX[M[1]], X[M[2]], ..., X[M[L]]是递增的。 因为，如果长度j≥2的子序列以X [M [j]]结尾，则长度j-1的子序列以较小的值结尾：即以X [P [M]结尾的子序列 [j]]。 因此，我们可以使用二分查找在O(log n)时间内完成搜索。\n伪代码如下：\n  A demo of the code.P = array of length N\nM = array of length N + 1\n\nL = 0\nfor i in range 0 to N-1:\n    // Binary search for the largest positive j ≤ L\n    // such that X[M[j]] <= X[i]\n    lo = 1\n    hi = L\n    while lo ≤ hi:\n        mid = ceil((lo+hi)/2)\n        if X[M[mid]] < X[i]:\n            lo = mid+1\n        else:\n            hi = mid-1\n\n    // After searching, lo is 1 greater than the\n    // length of the longest prefix of X[i]\n    newL = lo\n\n    // The predecessor of X[i] is the last index of \n    // the subsequence of length newL-1\n    P[i] = M[newL-1]\n    M[newL] = i\n    \n    if newL > L:\n        // If we found a subsequence longer than any we've\n        // found yet, update L\n        L = newL\n\n// Reconstruct the longest increasing subsequence\nS = array of length L\nk = M[L]\nfor i in range L-1 to 0:\n    S[i] = X[k]\n    k = P[k]\n\nreturn S\n由于该算法对每个序列元素都执行二分查找，因此时间复杂度为O(n log n)。 弗雷德曼 Fredman (1975)讨论了该算法的一种变体，他将其归功于高德纳。 在他研究的变体中，该算法在进行二分查找之前，测试每个值X [i]是否可以在常数时间内扩展当前最长的递增序列。 通过这种修改，算法在最坏的情况下只会进行n log2 n − n log2log2 n + O(n)个比较，对于比较算法（最高为O(n) 项中的恒定因子）而言，这是最佳选择[5]。\n", "Konwledge_Point": "最长递增子序列", "Question": "什么是最长递增子序列的高效的算法", "Tag": "算法设计"}
{"Answer": "\n\n^ Aldous, David; Diaconis, Persi, Longest increasing subsequences: from patience sorting to the Baik–Deift–Johansson theorem, Bulletin of the American Mathematical Society, 1999, 36 (04): 413–432, doi:10.1090/S0273-0979-99-00796-X .\n\n^ Schensted, C., Longest increasing and decreasing subsequences, Canadian Journal of Mathematics, 1961, 13: 179–191, MR 0121305, doi:10.4153/CJM-1961-015-3 .\n\n^ Hunt, J.; Szymanski, T., A fast algorithm for computing longest common subsequences, Communications of the ACM, 1977, 20 (5): 350–353, doi:10.1145/359581.359603. \n\n^ Golumbic, M. C., Algorithmic Graph Theory and Perfect Graphs, Computer Science and Applied Mathematics, Academic Press: 159, 1980 .\n\n^ Fredman, Michael L., On computing the length of longest increasing subsequences, Discrete Mathematics, 1975, 11 (1): 29–35, doi:10.1016/0012-365X(75)90103-X .\n\n", "Konwledge_Point": "最长递增子序列", "Question": "什么是最长递增子序列的参考文献", "Tag": "算法设计"}
{"Answer": "对集合S的完美散列函数是一个将S的每个元素映射到一系列无冲突的整数的哈希函数。一个完美散列函数的应用与其他哈希函数的应用基本一致，但不需要任何冲突解决方案。在数学术语中，这是一个完全单射函数.\n", "Konwledge_Point": "完美散列", "Question": "什么是完美散列", "Tag": "算法设计"}
{"Answer": "对于特定集合S的完美散列函数能在常数时间中被计算出，其映射值在一个相对小的范围内，能被一个随机化算法发现，该算法的操作次数与S的大小成正比.[1]任何适合在哈希表中使用的完美散列函数需要至少与S的大小成正比的位数。\n一个值的位数被限定范围的完美散列函数能应用于高效查找操作中：假定查找键(key)与集合S（或与集合S关联的值）对应，然后将完美散列函数应用于查找键，得到哈希值（一个整数），然后在查找表中取出该整数对应的值。在集合S极少更新且查询频率非常多的情况下，使用完美hash函数是非常有效的。对集合S更新频率的限定是由于对任何集合S的修改，都将导致该完美散列函数退化为非完美散列函数。每次集合S被修改后自动更新hash函数的解决方案被称为dynamic perfect hashing，但这类方法非常复杂，难以实现。一个简单的允许动态更新集合S的完美散列函数的替代品叫cuckoo hashing。\n", "Konwledge_Point": "完美散列", "Question": "什么是完美散列的特性及使用", "Tag": "算法设计"}
{"Answer": "最小完美散列函数是一个能将n个键（key）映射到n个连续的整数的完美散列函数。 产生的值通常为 [0..n−1] 或 [1..n]。正式表述如下：设j和k是有限集合K的两个元素。F是一个最小完美散列函数iff F(j)=F(k)只在j=k的情况下成立(单射)；并且存在整数a，使得F的范围为a..a+|K|−1。已经在数学上证明，通用的完美hash函数至少需要每个键（key）1.44 比特（bit）[2] 。而当前已知的最小完美hash散列函数每个键需要2.6 比特[3]。\n对一个最小完美散列函数F，若键以a1, a2, ..., an次序给出，对任意键aj and ak, j<k，意味着F(aj)<F(ak).[4] Order-preserving minimal perfect hash functions require necessarily Ω(n log n) bits to be represented.[5]，我们称该最小完美散列函数F是保序的。\n若对一个最小完美散列函数F，其应用变换后得到的值保持了键（key）的字典序，我们称该最小完美散列函数F为单调的。在此情况下，函数产生的值就是输入的键在所有可能的有序键序列中的位置。若被hash的键被存储于有序数组中，已实现一种策略，对每个键存储少量附加位（bits），以取得更快计算hash值的优势。[6]\n\n", "Konwledge_Point": "完美散列", "Question": "什么是完美散列的最小完美散列函数", "Tag": "算法设计"}
{"Answer": "Dynamic perfect hashing\nPearson hashing\nSuccinct data structure\nUniversal hashing", "Konwledge_Point": "完美散列", "Question": "什么是完美散列的请参阅", "Tag": "算法设计"}
{"Answer": "\n\n^ Fredman, M. L.; Komlós, J. N.; Szemerédi, E. Storing a Sparse Table with 0(1) Worst Case Access Time. Journal of the ACM. 1984, 31 (3): 538. doi:10.1145/828.1884. \n\n^ Belazzougui, D.; Botelho, F. C.; Dietzfelbinger, M. Hash, Displace, and Compress. Algorithms - ESA 2009 (PDF). LNCS 5757. 2009: 682  [2016-02-13]. ISBN 978-3-642-04127-3. doi:10.1007/978-3-642-04128-0_61. （原始内容存档 (PDF)于2011-07-24）. \n\n^ Baeza-Yates, Ricardo; Poblete, Patricio V., Searching, Atallah, Mikhail J.; Blanton, Marina  (编), Algorithms and Theory of Computation Handbook: General Concepts and Techniques 2nd, CRC Press, 2010, ISBN 9781584888239 . See in particular p. 2-10\n\n^ Jenkins, Bob, order-preserving minimal perfect hashing, Black, Paul E.  (编), Dictionary of Algorithms and Data Structures, U.S. National Institute of Standards and Technology, 14 April 2009  [2013-03-05], （原始内容存档于2009-01-30） \n\n^ Fox, E. A.; Chen, Q. F.; Daoud, A. M.; Heath, L. S. Order preserving minimal perfect hash functions and information retrieval. Proceedings of the 13th annual international ACM SIGIR conference on Research and development in information retrieval  - SIGIR '90. 1990: 279. ISBN 0897914082. doi:10.1145/96749.98233. \n\n^ Belazzougui, Djamal; Boldi, Paolo; Pagh, Rasmus; Vigna, Sebastiano, Theory and practice of monotone minimal perfect hashing, Journal of Experimental Algorithmics, November 2008, 16, Art. no. 3.2, 26pp, doi:10.1145/1963190.2025378 .\n\n", "Konwledge_Point": "完美散列", "Question": "什么是完美散列的索引", "Tag": "算法设计"}
{"Answer": "Richard J. Cichelli. Minimal Perfect Hash Functions Made Simple, Communications of the ACM, Vol. 23, Number 1, January 1980.\nThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 11.5: Perfect hashing, pp. 245–249.\nFabiano C. Botelho, Rasmus Pagh and Nivio Ziviani. \"Perfect Hashing for Data Management Applications\".\nFabiano C. Botelho and Nivio Ziviani. \"External perfect hashing for very large key sets\"（页面存档备份，存于互联网档案馆）. 16th ACM Conference on Information and Knowledge Management (CIKM07), Lisbon, Portugal, November 2007.\nDjamal Belazzougui, Paolo Boldi, Rasmus Pagh, and Sebastiano Vigna. \"Monotone minimal perfect hashing: Searching a sorted table with O(1) accesses\". In Proceedings of the 20th Annual ACM-SIAM Symposium On Discrete Mathematics (SODA), New York, 2009. ACM Press.\nDjamal Belazzougui, Paolo Boldi, Rasmus Pagh, and Sebastiano Vigna. \"Theory and practise of monotone minimal perfect hashing\". In Proceedings of the Tenth Workshop on Algorithm Engineering and Experiments (ALENEX). SIAM, 2009.\nDouglas C. Schmidt, GPERF: A Perfect Hash Function Generator, C++ Report, SIGS, Vol. 10, No. 10, November/December, 1998.", "Konwledge_Point": "完美散列", "Question": "什么是完美散列的延伸内容", "Tag": "算法设计"}
{"Answer": "Minimal Perfect Hashing（页面存档备份，存于互联网档案馆） by Bob Jenkins\ngperf（页面存档备份，存于互联网档案馆） is an Open Source C and C++ perfect hash generator\ncmph（页面存档备份，存于互联网档案馆） is Open Source implementing many perfect hashing methods\nSux4J（页面存档备份，存于互联网档案馆） is Open Source implementing perfect hashing, including monotone minimal perfect hashing in Java\nMPHSharp is Open Source implementing many perfect hashing methods in C#", "Konwledge_Point": "完美散列", "Question": "什么是完美散列的外部链接", "Tag": "算法设计"}
{"Answer": "\n戴克斯特拉算法（英語：Dijkstra's algorithm），又稱迪杰斯特拉算法、Dijkstra算法[6]，是由荷兰计算机科学家艾茲赫尔·戴克斯特拉在1956年发现的算法，并于3年后在期刊上发表[7][8][9]。戴克斯特拉算法使用类似廣度优先搜索的方法解决赋权图[9]的单源最短路径问题[10][1][2]。\n该算法存在很多变体：戴克斯特拉的原始版本仅适用于找到两个顶点之间的最短路径[9]，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树[1]。\n该算法解决了圖 \n  \n    \n      \n        G\n        =\n        ⟨\n        V\n        ,\n        E\n        ⟩\n      \n    \n    {\\displaystyle G=\\langle V,E\\rangle }\n  \n上带权的单源最短路径问题[1][11]:196–206。具体来说，戴克斯特拉算法设置了一顶点集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n，在集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中所有的顶点与源点\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n之间的最终最短路径权值均已确定[1]。算法反复选择最短路径估计最小的点\n  \n    \n      \n        u\n        ∈\n        \n          V\n          −\n          S\n        \n      \n    \n    {\\displaystyle u\\in {V-S}}\n  \n并将\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n加入\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中[1]。该算法常用于路由算法或者作为其他图算法的一个子模块[12]。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该演算法可以用来找到两个城市之间的最短路径[8][2]。\n应当注意，绝大多数的戴克斯特拉算法不能有效处理带有负权边的图[1][13]。\n戴克斯特拉算法在计算机科学的人工智能等领域也被称为均一开销搜索，并被认为是最良优先搜索（英语：best-first search）的一个特例[10]。\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法", "Tag": "算法设计"}
{"Answer": "  上圖為戴克斯特拉演算法應用示意圖。起點以左下角的紅點，目標是右上角的綠點，中間灰色的倒L型為障礙物。藍色空圈表示\"暫定\"，用以搜索下一步；已經填充顏色的表示探訪過，圖中顏色以紅到綠，越綠表示離起點越遠。所有節點都被均勻的探索。戴克斯特拉算法通過保留目前為止所找到的每個頂點\n  \n    \n      \n        v\n        ∈\n        V\n      \n    \n    {\\displaystyle v\\in V}\n  \n從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑來工作[1][2]。初始時，原點\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n的路径权重被賦為 0 （即原点的实际最短路径=0）[1][2]。同時把所有其他頂點的路徑長度設為無窮大，即表示我們不知道任何通向這些頂點的路徑[1]。當算法結束時，\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n 中儲存的便是從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑，或者如果路徑不存在的話是無窮大[1]。\n松弛操作是戴克斯特拉算法的基礎操作：如果存在一條從\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的邊，那麼從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的一条新路径是將邊\n  \n    \n      \n        w\n        (\n        u\n        ,\n        v\n        )\n        ∈\n        E\n      \n    \n    {\\displaystyle w(u,v)\\in E}\n  \n添加到從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的路徑尾部來拓展一條從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的路径[1][9]。這條路徑的長度是\n  \n    \n      \n        d\n        [\n        u\n        ]\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle d[u]+w(u,v)}\n  \n[1]。如果這個值比目前已知的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n的值要小，那么可以用这个值來替代當前\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n中的值[1]。松弛邊的操作一直執行到所有的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n都代表從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑的长度值[1]。\n算法維護兩個頂點集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n和\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n[1][9]。集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n保留所有已知实际最短路径值的頂點，而集合\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n則保留其他所有頂點[1][9]。集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n初始狀態為空，而後每一步都有一個頂點從\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n移動到\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n[1][9]。這個被選擇的頂點是\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中擁有最小的\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n值的頂點[1][2]。當一個頂點\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n從\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中轉移到了\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中，算法對\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的每条外接邊\n  \n    \n      \n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle w(u,v)}\n  \n進行松弛[1]。\n《算法导论》中给出了以下伪代码[1]：该伪代码计算并保留图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中原点\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到每一顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短距离\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n。其中，函数\n  \n    \n      \n        E\n        x\n        t\n        r\n        a\n        c\n        t\n        −\n        M\n        i\n        n\n        (\n        Q\n        )\n      \n    \n    {\\displaystyle Extract-Min(Q)}\n  \n将頂點集合\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中有最小\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n值的頂點\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n从\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中删除并返回\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n[1]。\n 1  function Dijkstra(G, w, s)\n 2   INITIALIZE-SINGLE-SOURCE(G, s)                //实际上的操作是将每个除原点外的顶点的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n置为无穷大，\n  \n    \n      \n        d\n        [\n        s\n        ]\n        =\n        0\n      \n    \n    {\\displaystyle d[s]=0}\n  \n\n 3   \n  \n    \n      \n        S\n        ←\n        ∅\n      \n    \n    {\\displaystyle S\\leftarrow \\emptyset }\n  \n\n 4   \n  \n    \n      \n        Q\n        ←\n        s\n      \n    \n    {\\displaystyle Q\\leftarrow s}\n  \n                                //\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n是顶点\n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n的一个优先队列，以顶点的最短路径估计排序\n 5   while(\n  \n    \n      \n        Q\n        ≠\n        ∅\n      \n    \n    {\\displaystyle Q\\not =\\emptyset }\n  \n)\n 6       do \n  \n    \n      \n        u\n        ←\n        E\n        X\n        T\n        R\n        A\n        C\n        T\n        −\n        M\n        I\n        N\n        (\n        Q\n        )\n      \n    \n    {\\displaystyle u\\leftarrow EXTRACT-MIN(Q)}\n  \n          //选取\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n为\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中最短路径估计最小的顶点\n 7       \n  \n    \n      \n        S\n        ←\n        S\n        ∪\n        u\n      \n    \n    {\\displaystyle S\\leftarrow S\\cup u}\n  \n\n 8       for each vertex v \n  \n    \n      \n        ∈\n        A\n        d\n        j\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle \\in Adj[u]}\n  \n\n 9            do RELAX(u, v, w)            //松弛成功的结点会被加入到队列中\n如果我們只對在\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n和\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n之間尋找一條最短路徑的話，我們可以在第5或第6行添加條件如果滿足\n  \n    \n      \n        u\n        =\n        t\n      \n    \n    {\\displaystyle u=t}\n  \n的話終止程序[1][2]。\n在肯尼·罗森所著的《离散数学及其应用》中给出了如下的另一份伪代码[2]：\n 1 procedure Dijkstra(G：边全为正权的图）\n 2   {G带有顶点\n  \n    \n      \n        a\n        =\n        \n          v\n          \n            0\n          \n        \n        ,\n        \n          v\n          \n            1\n          \n        \n        ,\n        \n          v\n          \n            2\n          \n        \n        .\n        .\n        .\n      \n    \n    {\\displaystyle a=v_{0},v_{1},v_{2}...}\n  \n和若干边\n  \n    \n      \n        w\n        (\n        \n          v\n          \n            i\n          \n        \n        ,\n        \n          v\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle w(v_{i},v_{j})}\n  \n}\n 3    for \n  \n    \n      \n        i\n        :=\n        1\n      \n    \n    {\\displaystyle i:=1}\n  \n to n\n 4       \n  \n    \n      \n        D\n        (\n        \n          v\n          \n            i\n          \n        \n        )\n        :=\n        ∞\n      \n    \n    {\\displaystyle D(v_{i}):=\\infty }\n  \n\n 5    \n  \n    \n      \n        D\n        (\n        a\n        )\n        :=\n        0\n      \n    \n    {\\displaystyle D(a):=0}\n  \n\n 6    \n  \n    \n      \n        S\n        :=\n        ∅\n      \n    \n    {\\displaystyle S:=\\emptyset }\n  \n\n 7    while \n  \n    \n      \n        z\n        ∉\n        S\n      \n    \n    {\\displaystyle z\\notin S}\n  \n\n 8    begin\n 9          \n  \n    \n      \n        u\n        :=\n      \n    \n    {\\displaystyle u:=}\n  \n不属于\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n的\n  \n    \n      \n        D\n        (\n        u\n        )\n      \n    \n    {\\displaystyle D(u)}\n  \n最小的一个顶点\n 10        \n  \n    \n      \n        S\n        :=\n        S\n        ∪\n        {\n        u\n        }\n      \n    \n    {\\displaystyle S:=S\\cup \\{u\\}}\n  \n\n 11        for 所有不属于\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n的顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n\n 12            if \n  \n    \n      \n        D\n        (\n        u\n        )\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n        <\n        D\n        (\n        v\n        )\n      \n    \n    {\\displaystyle D(u)+w(u,v)<D(v)}\n  \n then \n  \n    \n      \n        D\n        (\n        v\n        )\n        :=\n        D\n        (\n        u\n        )\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle D(v):=D(u)+w(u,v)}\n  \n\n 13    end{\n  \n    \n      \n        D\n        (\n        z\n        )\n        =\n      \n    \n    {\\displaystyle D(z)=}\n  \n从a到z的最短路长度}\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法描述", "Tag": "算法设计"}
{"Answer": "我們可以用大O符號將该算法的運行時間表示為邊數\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n和頂點數\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n的函數[1]。\n对于任何基于顶点集\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n的实现，算法的运行时间是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        ⋅\n        d\n        \n          k\n          \n            Q\n          \n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        ⋅\n        e\n        \n          m\n          \n            Q\n          \n        \n        )\n      \n    \n    {\\displaystyle O(|E|\\cdot dk_{Q}+|V|\\cdot em_{Q})}\n  \n，其中\n  \n    \n      \n        d\n        \n          k\n          \n            Q\n          \n        \n      \n    \n    {\\displaystyle dk_{Q}}\n  \n和\n  \n    \n      \n        e\n        \n          m\n          \n            Q\n          \n        \n      \n    \n    {\\displaystyle em_{Q}}\n  \n分别表示完成键的降序排列时间和从\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中提取最小键值的时间[1]。\n对于没有任何优化的戴克斯特拉算法，实际上等价于每次遍历了整个图的所有结点来找到Q中满足条件的元素（即寻找最小的頂點是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|)}\n  \n的），此外实际上还需要遍历所有的边一遍，因此算法的复杂度是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          \n            |\n          \n          \n            2\n          \n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|^{2}+|E|)}\n  \n[2]。\n對於邊數少於\n  \n    \n      \n        \n          |\n        \n        V\n        \n          \n            |\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle |V|^{2}}\n  \n的稀疏圖來說，可以用鄰接表來更有效的實現该算法[1]。\n可以使用一個二叉堆或者斐波納契堆用作優先隊列來尋找最小的頂點（\n  \n    \n      \n        E\n        x\n        t\n        r\n        a\n        c\n        t\n        −\n        M\n        i\n        n\n      \n    \n    {\\displaystyle Extract-Min}\n  \n）以优化算法[14][15]。當用到二叉堆的時候，算法所需的時間為\n  \n    \n      \n        O\n        (\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n        log\n        ⁡\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O((|E|+|V|)\\log |V|)}\n  \n[14]，斐波納契堆能提高一些性能，讓算法運行時間達到\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        log\n        ⁡\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|E|+|V|\\log |V|)}\n  \n[4][15]。然而，使用斐波納契堆进行编程，有时会由于算法常数过大而导致速度没有显著提高[16]。\n下面是一些戴克斯特拉算法经典实现的复杂度比较：\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的時間複雜度", "Tag": "算法设计"}
{"Answer": "  艾兹赫尔·戴克斯特拉，戴克斯特拉算法的发现者戴克斯特拉本人在他的论文中给出了一份简单的证明[9]。\n《算法导论》使用循环不变式（数学归纳法）给出了如下的一份证明[1]：\n已知一带权图\n  \n    \n      \n        G\n        =<\n        V\n        ,\n        E\n        >\n      \n    \n    {\\displaystyle G=<V,E>}\n  \n，其加权函数\n  \n    \n      \n        w\n      \n    \n    {\\displaystyle w}\n  \n的值非负，源点为\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n。对该图运行戴克斯特拉算法，对所有\n  \n    \n      \n        u\n        ∈\n        V\n      \n    \n    {\\displaystyle u\\in V}\n  \n有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。其中\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n表示u点的最短路径估计，\n  \n    \n      \n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle \\delta (s,u)}\n  \n表示\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n点的最短路径。\n证明：证明如下的循环不变式成立即可：在每次执行EXTRACT-MIN时，对每个顶点\n  \n    \n      \n        u\n        ∈\n        S\n      \n    \n    {\\displaystyle u\\in S}\n  \n，有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n成立即可。由于上界性质，在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n加入了\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n之后，一旦有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n，则在后面的每次循环中都不会改变这个性质。\n初始化：第一次循环前，\n  \n    \n      \n        S\n        =\n        ∅\n      \n    \n    {\\displaystyle S=\\emptyset }\n  \n，因此循环不变式显然成立。\n保持：实际上要证明每一轮循环中加入到\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中的结点满足\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。利用反证法，假设\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n是第一个不满足此条件的结点，考虑循环开始前的状况，首先\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n一定不等于\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n，这是显然的。其次\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n一定有到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的路径，否则路径为无穷大。那么假设在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n进入时，有最短路径\n  \n    \n      \n        p\n        =\n        s\n        −\n        >\n        u\n      \n    \n    {\\displaystyle p=s->u}\n  \n，假设该路径上存在两个点\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n，\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n。\n  \n    \n      \n        y\n        ∈\n        V\n        −\n        S\n      \n    \n    {\\displaystyle y\\in V-S}\n  \n、\n  \n    \n      \n        x\n        ∈\n        S\n      \n    \n    {\\displaystyle x\\in S}\n  \n，且x是y的前驱，路径\n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n可以分解为\n  \n    \n      \n        s\n        −\n        \n          p\n          \n            1\n          \n        \n        −\n        >\n        x\n        −\n        >\n        y\n        −\n        \n          p\n          \n            2\n          \n        \n        −\n        >\n        u\n      \n    \n    {\\displaystyle s-p_{1}->x->y-p_{2}->u}\n  \n（此处\n  \n    \n      \n        −\n        \n          p\n          \n            1\n          \n        \n        −\n        >\n      \n    \n    {\\displaystyle -p_{1}->}\n  \n表示经过\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n这条路径，后同），其中路径\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n和路径\n  \n    \n      \n        \n          p\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle p_{2}}\n  \n可以为空。由于\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n是第一个不满足\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n的，又因为\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n是满足该条件的，而且\n  \n    \n      \n        (\n        x\n        ,\n        y\n        )\n      \n    \n    {\\displaystyle (x,y)}\n  \n一定已经被松弛过了，所以\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n是满足该条件的。\n现在只需要推出矛盾，即可证明u不存在：\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n之前出现，而且图中所有权值非负，因此有\n  \n    \n      \n        δ\n        (\n        s\n        ,\n        y\n        )\n        ≤\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle \\delta (s,y)\\leq \\delta (s,u)}\n  \n，所以：\n  \n    \n      \n        d\n        [\n        y\n        ]\n        ≤\n        δ\n        (\n        s\n        ,\n        y\n        )\n        ≤\n        δ\n        (\n        s\n        ,\n        u\n        )\n        ≤\n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[y]\\leq \\delta (s,y)\\leq \\delta (s,u)\\leq d[u]}\n  \n，但是由于\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n和\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n同时在\n  \n    \n      \n        V\n        −\n        S\n      \n    \n    {\\displaystyle V-S}\n  \n中，因此\n  \n    \n      \n        d\n        [\n        u\n        ]\n        ≤\n        d\n        [\n        y\n        ]\n      \n    \n    {\\displaystyle d[u]\\leq d[y]}\n  \n，因此必有\n  \n    \n      \n        d\n        [\n        y\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        y\n        )\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n        =\n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[y]=\\delta (s,y)=\\delta (s,u)=d[u]}\n  \n，也就证明了\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n点不可能不满足该条件，上述假设为假，原命题得证。\n终止：终止时，\n  \n    \n      \n        Q\n        =\n        ∅\n      \n    \n    {\\displaystyle Q=\\emptyset }\n  \n，由于\n  \n    \n      \n        Q\n        =\n        V\n        −\n        S\n      \n    \n    {\\displaystyle Q=V-S}\n  \n，因此\n  \n    \n      \n        V\n        =\n        S\n      \n    \n    {\\displaystyle V=S}\n  \n，因此对所有\n  \n    \n      \n        u\n        ∈\n        V\n      \n    \n    {\\displaystyle u\\in V}\n  \n有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法正确性证明", "Tag": "算法设计"}
{"Answer": "从鹿特丹到格罗宁根的最短路径是什么？实际上，这就是对于任意两座城市之间的最短路问题。解决这个问题实际上大概只花了我20分钟：一天早上，我和我的未婚妻在阿姆斯特丹购物，累了，我们便坐在咖啡馆的露台上喝咖啡，然后我就试了一下能否用一个算法解决最短路问题。正如我所说，这是一个20分钟的发现。不过实际上，我在3年后的1959年才把这个算法发表在论文上。即使现在来看这篇论文的可读性也非常高，这个算法之所以如此优雅，其中一个原因就是我没用笔纸就设计了它。后来我才知道，没用笔纸设计的优点之一是你不得不避免所有可避免的复杂问题。令我惊讶的是，这个算法最终成为我成名的基石之一。——艾兹赫尔·戴克斯特拉在2001年的采访中提到戴克斯特拉算法的发现历程[8]戴克斯特拉1956年在荷兰数学和计算机科学研究学会担任程序员时为了展示新型计算机ARMAC的功能曾思考过最短路径问题的解法[22]。他的目标是让不去实际计算的人也能理解这个问题和解决的方法，于是他在发现了这个算法之后在ARMAC上做了简单实验[8]。1959年，他正式将此算法发表在期刊上，该算法也成为了戴克斯特拉成名的基石之一[8][9]。\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法起源与历史", "Tag": "算法设计"}
{"Answer": "  一个多区域OSPF网络，在OSPF中使用本算法计算最短路径链路状态路由协议（英语：Link-state routing protocol）中需要计算最短路时常常要用到该算法，该算法在開放最短路徑優先和中间系统到中间系统协议中的相关应用是其在網絡路由中的典型實現[12]。\n戴克斯特拉算法及其改进算法应用广泛，尤其是在寻路、交通、规划中[23][24][25][26]。\n如果有已知信息可用來估計某一點到目標點的距離，則可改用A*搜尋算法，以減小最短路徑的搜索範圍，戴克斯特拉算法本身也可以看作是A*搜索算法的一个特例[27][28]。\n戴克斯特拉算法本身采用了与Prim算法类似的贪心策略[9][29][30][31]。快速行进算法与戴克斯特拉算法同样有相似之处[32]。\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法相关应用", "Tag": "算法设计"}
{"Answer": "以下是该算法使用堆优化的一个C++实现参考[33]：\n#include<bits/stdc++.h> \nusing namespace std; \n# define INF 0x3f3f3f3f \n  \n// iPair ==> Integer Pair（整数对）\ntypedef pair<int, int> iPair; \n  \n// 加边\nvoid addEdge(vector <pair<int, int> > adj[], int u, \n                                     int v, int wt) \n{ \n    adj[u].push_back(make_pair(v, wt)); \n    adj[v].push_back(make_pair(u, wt)); \n} \n   \n  \n// 计算最短路\nvoid shortestPath(vector<pair<int,int> > adj[], int V, int src) \n{ \n    // 关于stl中的优先队列如何实现，参考下方网址：\n    // http://geeksquiz.com/implement-min-heap-using-stl/ \n    priority_queue< iPair, vector <iPair> , greater<iPair> > pq; \n  \n    // 距离置为正无穷大\n    vector<int> dist(V, INF); \n    vector<bool> visited(V, false);\n\n    // 插入源点，距离为0\n    pq.push(make_pair(0, src)); \n    dist[src] = 0; \n  \n    /* 循环直到优先队列为空 */\n    while (!pq.empty()) \n    { \n        // 每次从优先队列中取出顶点事实上是这一轮最短路径权值确定的点\n        int u = pq.top().second; \n        pq.pop(); \n        if (visited[u]) {\n            continue;\n        }\n        visited[u] = true;\n        // 遍历所有边\n        for (auto x : adj[u]) \n        { \n            // 得到顶点边号以及边权\n            int v = x.first; \n            int weight = x.second; \n  \n            //可以松弛\n            if (dist[v] > dist[u] + weight) \n            { \n                // 松弛 \n                dist[v] = dist[u] + weight; \n                pq.push(make_pair(dist[v], v)); \n            } \n        } \n    } \n  \n    // 打印最短路\n    printf(\"Vertex Distance from Source\\n\"); \n    for (int i = 0; i < V; ++i) \n        printf(\"%d \\t\\t %d\\n\", i, dist[i]); \n} \nint main() \n{ \n    int V = 9; \n    vector<iPair > adj[V]; \n    addEdge(adj, 0, 1, 4); \n    addEdge(adj, 0, 7, 8); \n    addEdge(adj, 1, 2, 8); \n    addEdge(adj, 1, 7, 11); \n    addEdge(adj, 2, 3, 7); \n    addEdge(adj, 2, 8, 2); \n    addEdge(adj, 2, 5, 4); \n    addEdge(adj, 3, 4, 9); \n    addEdge(adj, 3, 5, 14); \n    addEdge(adj, 4, 5, 10); \n    addEdge(adj, 5, 6, 2); \n    addEdge(adj, 6, 7, 1); \n    addEdge(adj, 6, 8, 6); \n    addEdge(adj, 7, 8, 7); \n  \n    shortestPath(adj, V, 0); \n  \n    return 0; \n}\n以下是该算法Python的一个实现:\nimport sys\nmax = sys.maxsize\n\nvertices_number = 6\nadjacency_matrix = [\n    [0, 1, 10, -1, -1, 2],\n    [10, 0, 1, -1, -1, -1],\n    [1, 10, 0, -1, -1, -1],\n    [-1, -1, 2, 0, 1, 10],\n    [-1, -1, -1, 10, 0, 1],\n    [-1, -1, -1, 1, 10, 0]]\nstart = []\ndest = [\"2\", \"5\"]\nkey = []\n\n\ndef init_keys(s: int):\n    global key\n    key = [ max ] * vertices_number\n    key[s] = 0\n\n\ndef dijkstra(from_vertex, dest_vertex):\n    fid = int(from_vertex) - 1\n    tid = int(dest_vertex) - 1\n    init_keys(fid)\n    rel = [fid]\n    min_vertex = fid\n    hop_path = {}\n\n    while len(rel) <= vertices_number and min_vertex != tid:\n        for i in range(vertices_number):\n            if i != min_vertex and i not in rel and \\\n                adjacency_matrix[min_vertex][i] > 0 \\\n                and key[i] > key[min_vertex] + adjacency_matrix[min_vertex][i]:\n                key[i] = key[min_vertex] + adjacency_matrix[min_vertex][i]\n                hop_path.update({i + 1: {\"from\": min_vertex + 1, \"cost\": adjacency_matrix[min_vertex][i]}})\n\n        if min_vertex not in rel:\n            rel.append(min_vertex)\n\n        min_vertex = tid\n        for i in range(vertices_number):\n            if i not in rel and key[i] < key[min_vertex]:\n                min_vertex = i\n\n    if len(hop_path) == 0 or int(dest_vertex) not in hop_path:\n        return -1, -1\n    else:\n        next_hop = int(dest_vertex)\n        path_str = dest_vertex\n        while hop_path[next_hop][\"from\"] != int(from_vertex):\n            cost = hop_path[next_hop][\"cost\"]\n            next_hop = hop_path[next_hop][\"from\"]\n            path_str =  \"{} -({})-> {}\".format(str(next_hop), cost ,path_str)\n        path_str =  \"{} -({})-> {}\".format(str(hop_path[next_hop][\"from\"]), hop_path[next_hop][\"cost\"], path_str)\n\n        return key[tid], path_str\n\n\n\ndef find_shortest_router():\n    for s in start:\n        print(\"Forwarding Table for {}\".format(s))\n        print(\"{:>10} {:>10}       {}\".format(\"To\", \"Cost\", \"Path\"))\n        for d in dest:\n            c, n = dijkstra(s, d)\n            print(\"{:>10} {:>10}       {}\".format(d, c, n))\n\n\ndef main():\n    for i in range(1, vertices_number + 1):\n        if str(i) not in dest:\n            start.append(str(i))\n    find_shortest_router()\n\nif __name__ == '__main__':\n    main()\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的参考源程序", "Tag": "算法设计"}
{"Answer": "\n\n信息技术主题\n计算机程序设计主题图论\nA*搜尋演算法\n贝尔曼-福特算法\n宽度优先搜索\nFlood fill\nFloyd-Warshall算法\n最长路径问题", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的参见", "Tag": "算法设计"}
{"Answer": "参考文献[编辑]\n\n^ 1.00 1.01 1.02 1.03 1.04 1.05 1.06 1.07 1.08 1.09 1.10 1.11 1.12 1.13 1.14 1.15 1.16 1.17 1.18 1.19 1.20 1.21 1.22 1.23 1.24 1.25 1.26 1.27 1.28 1.29 Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms Second. MIT Press and McGraw–Hill. 2001: 595–601. ISBN 0-262-03293-7. \n\n^ 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 Rosen, Kenneth H. Discrete Mathematics and Its Applications. McGraw-Hill College. 2002. ISBN 0-07-293033-0. \n\n^ 有争议，见：Moshe Sniedovich. Dijkstra's algorithm revisited: the dynamic programming connexion. Control and Cybernetics. 2006, 35: 599–620  [2020-03-04]. （原始内容存档于2020-03-04）. 等\n\n^ 4.0 4.1 4.2 4.3 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. 25th Annual Symposium on Foundations of Computer Science. IEEE: 338–346. 1984. doi:10.1109/SFCS.1984.715934. \n\n^ Andrew V. Goldberg; Robert E. Tarjan. Expected performance of Dijkstra’s shortest path algorithm. NEC Research Institute Report. 1996年  [2019-12-12]. （原始内容存档于2021-11-22）.  引文使用过时参数coauthors (帮助)\n\n^ 乐阳、龚健雅. Dijkstra最短路径算法的一种高效率实现. 《科学技术创新》. 2020, (17): 75–77  [2020-06-30]. （原始内容存档于2021-02-13）. \n\n^ Richards, Hamilton. Edsger Wybe Dijkstra. A.M. Turing Award. Association for Computing Machinery.   [2017-10-16]. （原始内容存档于2017-10-21）. At the Mathematical Centre a major project was building the ARMAC computer. For its official inauguration in 1956, Dijkstra devised a program to solve a problem interesting to a nontechnical audience: Given a network of roads connecting cities, what is the shortest route between two designated cities? \n\n^ 8.0 8.1 8.2 8.3 8.4 Frana, Phil. An Interview with Edsger W. Dijkstra. Communications of the ACM. August 2010, 53 (8): 41–47. doi:10.1145/1787234.1787249. \n\n^ 9.00 9.01 9.02 9.03 9.04 9.05 9.06 9.07 9.08 9.09 9.10 Dijkstra, E. W. A note on two problems in connexion with graphs (PDF). Numerische Mathematik. 1959, 1: 269–271  [2020-01-27]. doi:10.1007/BF01386390. （原始内容存档 (PDF)于2020-01-23）. \n\n^ 10.0 10.1 Felner, Ariel. Position Paper: Dijkstra's Algorithm versus Uniform Cost Search or a Case Against Dijkstra's Algorithm. Proc. 4th Int'l Symp. on Combinatorial Search. 2011  [2020-02-18]. （原始内容存档于2020-02-18）. \n\n^ Mehlhorn, Kurt; Sanders, Peter. Chapter 10. Shortest Paths (PDF). Algorithms and Data Structures: The Basic Toolbox. Springer. 2008  [2020-02-14]. ISBN 978-3-540-77977-3. doi:10.1007/978-3-540-77978-0. （原始内容存档 (PDF)于2021-02-24）. \n\n^ 12.0 12.1 H. Ishikawa, S. Shimizu, Y. Arakawa, N. Yamanaka, K. Shiba. New Parallel Shortest Path Searching Algorithm based on Dynamically Reconfigurable Processor DAPDNA-2. IEEE. 13 August 2007  [2020-03-21]. doi:10.1109/ICC.2007.332. （原始内容存档于2020-12-18）. \n\n^ Yefim, Dinitz; Rotem, Itzhak. Hybrid Bellman–Ford–Dijkstra algorithm,. Journal of Discrete Algorithms. 2017, 42: 35–44. doi:10.1016/j.jda.2017.01.001. \n\n^ 14.0 14.1 14.2 Johnson, Donald B. Efficient algorithms for shortest paths in sparse networks. Journal of the ACM. 1977, 24 (1): 1–13. doi:10.1145/321992.321993. \n\n^ 15.0 15.1 15.2 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. Journal of the Association for Computing Machinery. 1987, 34 (3): 596–615  [2018-04-03]. doi:10.1145/28869.28874. （原始内容存档于2006-04-28）. \n\n^ Skiena, Steven. The Algorithm Design Manual (PDF) 2. Springer. 2008-07-26: 212  [2015-04-11]. ISBN 978-0073523408. doi:10.1007/978-1-84800-070-4. （原始内容 (PDF)存档于2015-06-09） （英语）. \n\n^ Leyzorek, M.; Gray, R. S.; Johnson, A. A.; Ladew, W. C.; Meaker, Jr., S. R.; Petry, R. M.; Seitz, R. N. Investigation of Model Techniques — First Annual Report — 6 June 1956 — 1 July 1957 — A Study of Model Techniques for Communication Systems. Cleveland, Ohio: Case Institute of Technology. 1957. \n\n^ 见Pollack, Maurice; Wiebenson, Walter. Solution of the Shortest-Route Problem—A Review. Oper. Res. March–April 1960, 8 (2): 224–230. doi:10.1287/opre.8.2.224.   Attributes Dijkstra's algorithm to Minty (\"private communication\") on p.225.\n\n^ Whiting, P. D.; Hillier, J. A. A Method for Finding the Shortest Route through a Road Network. Operational Research Quarterly. March–June 1960, 11 (1/2): 37–40. doi:10.1057/jors.1960.32. \n\n^ Johnson, Donald B. A priority queue in which initialization and queue operations take .mw-parser-output .serif{font-family:Times,serif}O(log log D) time. Mathematical Systems Theory. December 1981, 15 (1): 295–309. MR 0683047. doi:10.1007/BF01786986. \n\n^ Karlsson, Rolf G.; Poblete, Patricio V. An O(m log log D) algorithm for shortest paths. Discrete Applied Mathematics. 1983, 6 (1): 91–93. MR 0700028. doi:10.1016/0166-218X(83)90104-X. \n\n^ ARMAC. Unsung Heroes in Dutch Computing History. 2007. （原始内容存档于2013-11-13）. \n\n^ Sven Peyer; Dieter Rautenbach,Jens Vygen. A generalization of Dijkstra's shortest path algorithm with applications to VLSI routing. Journal of Discrete Algorithms. 2007, 7 (4): 377–390. doi:10.1016/j.jda.2007.08.003.  引文使用过时参数coauthors (帮助)\n\n^ Ismail Rakip Karas，Sait Demir. Dijkstra algorithm interactive training software development for network analysis applications in GIS (PDF). Energy Education Science and Technology Part A: Energy Science and Research. 2011, 28: 445–452  [2020-03-04]. （原始内容存档 (PDF)于2020-03-04）. \n\n^ Dean Djokic,David R. Maidment. Application of GIS Network Routines for Water Flow and Transport. Journal of Water Resources Planning and Management. 1993, 119 (2). doi:10.1061/(ASCE)0733-9496(1993)119:2(229). \n\n^ 江琦浩. 迪杰斯特拉算法在企业成本控制研究中的应用. 中国商贸. 2012, (03X)  [2020-12-24]. （原始内容存档于2021-02-13）. \n\n^ De Smith, Michael John; Goodchild, Michael F.; Longley, Paul, Geospatial Analysis: A Comprehensive Guide to Principles, Techniques and Software Tools, Troubadour Publishing Ltd: 344, 2007  [2020-03-04], ISBN 9781905886609, （原始内容存档于2017-02-27） .\n\n^ Hetland, Magnus Lie, Python Algorithms: Mastering Basic Algorithms in the Python Language, Apress: 214, 2010  [2020-03-04], ISBN 9781430232377, （原始内容存档于2017-02-28） .\n\n^ Tarjan, Robert Endre, Data Structures and Network Algorithms, CBMS_NSF Regional Conference Series in Applied Mathematics 44, Society for Industrial and Applied Mathematics: 75, 1983, The third classical minimum spanning tree algorithm was discovered by Jarník and rediscovered by Prim and Dikstra; it is commonly known as Prim's algorithm. \n\n^ Prim, R.C. Shortest connection networks and some generalizations (PDF). Bell System Technical Journal. 1957, 36 (6): 1389–1401  [18 July 2017]. Bibcode:1957BSTJ...36.1389P. doi:10.1002/j.1538-7305.1957.tb01515.x. （原始内容 (PDF)存档于18 July 2017）. \n\n^ V. Jarník: O jistém problému minimálním [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 6, 1930, pp. 57–63. (in Czech)\n\n^ Danielsson, Per-Erik; Lin, Qingfen. A Modified Fast Marching Method. Image Analysis. 24 June 2003: 1154–1161  [2020-03-25]. （原始内容存档于2021-02-13）.  引文使用过时参数coauthors (帮助)\n\n^ geeksforgeeks. Dijkstra’s Shortest Path Algorithm using priority_queue of STL. geeksforgeeks.   [2020-05-11]. （原始内容存档于2021-02-13）. \n\n扩展阅读[编辑]\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms second. MIT Press、S&P Global. 2001: 595–601. ISBN 0-262-03293-7. \nDial, Robert B. Algorithm 360: Shortest-path forest with topological ordering [H]. CACM. 1969, 12 (11): 632–633. doi:10.1145/363269.363610. \nZhan, F. Benjamin; Noon, Charles E. Shortest Path Algorithms: An Evaluation Using Real Road Networks. Transportation Science. February 1998, 32 (1): 65–73. doi:10.1287/trsc.32.1.65. \nKnuth, D.E. A Generalization of Dijkstra's Algorithm. Information Processing Letters. 1977, 6 (1): 1–5. doi:10.1016/0020-0190(77)90002-3. \nAhuja, Ravindra K.; Mehlhorn, Kurt; Orlin, James B.; Tarjan, Robert E. Faster Algorithms for the Shortest Path Problem. Journal of Association for Computing Machinery (ACM). April 1990, 37 (2): 213–223. doi:10.1145/77600.77615. \nRaman, Rajeev. Recent results on the single-source shortest paths problem. SIGACT News. 1997, 28 (2): 81–87. doi:10.1145/261342.261352. \nThorup, Mikkel. On RAM priority Queues. SIAM Journal on Computing. 2000, 30 (1): 86–109. doi:10.1137/S0097539795288246. \nThorup, Mikkel. Undirected single-source shortest paths with positive integer weights in linear time. journal of the ACM. 1999, 46 (3): 362–394  [2017-11-01]. doi:10.1145/316542.316548. （原始内容存档于2017-09-21）. \nZHANG Lin-guang,FANG Jin-yun,SHEN Pai-wei. An Improved Dijkstra Algorithm Based on Pairing Heap. Journal of Image and Graphics. 2007-05. \n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的參考", "Tag": "算法设计"}
{"Answer": "\n\n^ 1.00 1.01 1.02 1.03 1.04 1.05 1.06 1.07 1.08 1.09 1.10 1.11 1.12 1.13 1.14 1.15 1.16 1.17 1.18 1.19 1.20 1.21 1.22 1.23 1.24 1.25 1.26 1.27 1.28 1.29 Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms Second. MIT Press and McGraw–Hill. 2001: 595–601. ISBN 0-262-03293-7. \n\n^ 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 Rosen, Kenneth H. Discrete Mathematics and Its Applications. McGraw-Hill College. 2002. ISBN 0-07-293033-0. \n\n^ 有争议，见：Moshe Sniedovich. Dijkstra's algorithm revisited: the dynamic programming connexion. Control and Cybernetics. 2006, 35: 599–620  [2020-03-04]. （原始内容存档于2020-03-04）. 等\n\n^ 4.0 4.1 4.2 4.3 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. 25th Annual Symposium on Foundations of Computer Science. IEEE: 338–346. 1984. doi:10.1109/SFCS.1984.715934. \n\n^ Andrew V. Goldberg; Robert E. Tarjan. Expected performance of Dijkstra’s shortest path algorithm. NEC Research Institute Report. 1996年  [2019-12-12]. （原始内容存档于2021-11-22）.  引文使用过时参数coauthors (帮助)\n\n^ 乐阳、龚健雅. Dijkstra最短路径算法的一种高效率实现. 《科学技术创新》. 2020, (17): 75–77  [2020-06-30]. （原始内容存档于2021-02-13）. \n\n^ Richards, Hamilton. Edsger Wybe Dijkstra. A.M. Turing Award. Association for Computing Machinery.   [2017-10-16]. （原始内容存档于2017-10-21）. At the Mathematical Centre a major project was building the ARMAC computer. For its official inauguration in 1956, Dijkstra devised a program to solve a problem interesting to a nontechnical audience: Given a network of roads connecting cities, what is the shortest route between two designated cities? \n\n^ 8.0 8.1 8.2 8.3 8.4 Frana, Phil. An Interview with Edsger W. Dijkstra. Communications of the ACM. August 2010, 53 (8): 41–47. doi:10.1145/1787234.1787249. \n\n^ 9.00 9.01 9.02 9.03 9.04 9.05 9.06 9.07 9.08 9.09 9.10 Dijkstra, E. W. A note on two problems in connexion with graphs (PDF). Numerische Mathematik. 1959, 1: 269–271  [2020-01-27]. doi:10.1007/BF01386390. （原始内容存档 (PDF)于2020-01-23）. \n\n^ 10.0 10.1 Felner, Ariel. Position Paper: Dijkstra's Algorithm versus Uniform Cost Search or a Case Against Dijkstra's Algorithm. Proc. 4th Int'l Symp. on Combinatorial Search. 2011  [2020-02-18]. （原始内容存档于2020-02-18）. \n\n^ Mehlhorn, Kurt; Sanders, Peter. Chapter 10. Shortest Paths (PDF). Algorithms and Data Structures: The Basic Toolbox. Springer. 2008  [2020-02-14]. ISBN 978-3-540-77977-3. doi:10.1007/978-3-540-77978-0. （原始内容存档 (PDF)于2021-02-24）. \n\n^ 12.0 12.1 H. Ishikawa, S. Shimizu, Y. Arakawa, N. Yamanaka, K. Shiba. New Parallel Shortest Path Searching Algorithm based on Dynamically Reconfigurable Processor DAPDNA-2. IEEE. 13 August 2007  [2020-03-21]. doi:10.1109/ICC.2007.332. （原始内容存档于2020-12-18）. \n\n^ Yefim, Dinitz; Rotem, Itzhak. Hybrid Bellman–Ford–Dijkstra algorithm,. Journal of Discrete Algorithms. 2017, 42: 35–44. doi:10.1016/j.jda.2017.01.001. \n\n^ 14.0 14.1 14.2 Johnson, Donald B. Efficient algorithms for shortest paths in sparse networks. Journal of the ACM. 1977, 24 (1): 1–13. doi:10.1145/321992.321993. \n\n^ 15.0 15.1 15.2 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. Journal of the Association for Computing Machinery. 1987, 34 (3): 596–615  [2018-04-03]. doi:10.1145/28869.28874. （原始内容存档于2006-04-28）. \n\n^ Skiena, Steven. The Algorithm Design Manual (PDF) 2. Springer. 2008-07-26: 212  [2015-04-11]. ISBN 978-0073523408. doi:10.1007/978-1-84800-070-4. （原始内容 (PDF)存档于2015-06-09） （英语）. \n\n^ Leyzorek, M.; Gray, R. S.; Johnson, A. A.; Ladew, W. C.; Meaker, Jr., S. R.; Petry, R. M.; Seitz, R. N. Investigation of Model Techniques — First Annual Report — 6 June 1956 — 1 July 1957 — A Study of Model Techniques for Communication Systems. Cleveland, Ohio: Case Institute of Technology. 1957. \n\n^ 见Pollack, Maurice; Wiebenson, Walter. Solution of the Shortest-Route Problem—A Review. Oper. Res. March–April 1960, 8 (2): 224–230. doi:10.1287/opre.8.2.224.   Attributes Dijkstra's algorithm to Minty (\"private communication\") on p.225.\n\n^ Whiting, P. D.; Hillier, J. A. A Method for Finding the Shortest Route through a Road Network. Operational Research Quarterly. March–June 1960, 11 (1/2): 37–40. doi:10.1057/jors.1960.32. \n\n^ Johnson, Donald B. A priority queue in which initialization and queue operations take .mw-parser-output .serif{font-family:Times,serif}O(log log D) time. Mathematical Systems Theory. December 1981, 15 (1): 295–309. MR 0683047. doi:10.1007/BF01786986. \n\n^ Karlsson, Rolf G.; Poblete, Patricio V. An O(m log log D) algorithm for shortest paths. Discrete Applied Mathematics. 1983, 6 (1): 91–93. MR 0700028. doi:10.1016/0166-218X(83)90104-X. \n\n^ ARMAC. Unsung Heroes in Dutch Computing History. 2007. （原始内容存档于2013-11-13）. \n\n^ Sven Peyer; Dieter Rautenbach,Jens Vygen. A generalization of Dijkstra's shortest path algorithm with applications to VLSI routing. Journal of Discrete Algorithms. 2007, 7 (4): 377–390. doi:10.1016/j.jda.2007.08.003.  引文使用过时参数coauthors (帮助)\n\n^ Ismail Rakip Karas，Sait Demir. Dijkstra algorithm interactive training software development for network analysis applications in GIS (PDF). Energy Education Science and Technology Part A: Energy Science and Research. 2011, 28: 445–452  [2020-03-04]. （原始内容存档 (PDF)于2020-03-04）. \n\n^ Dean Djokic,David R. Maidment. Application of GIS Network Routines for Water Flow and Transport. Journal of Water Resources Planning and Management. 1993, 119 (2). doi:10.1061/(ASCE)0733-9496(1993)119:2(229). \n\n^ 江琦浩. 迪杰斯特拉算法在企业成本控制研究中的应用. 中国商贸. 2012, (03X)  [2020-12-24]. （原始内容存档于2021-02-13）. \n\n^ De Smith, Michael John; Goodchild, Michael F.; Longley, Paul, Geospatial Analysis: A Comprehensive Guide to Principles, Techniques and Software Tools, Troubadour Publishing Ltd: 344, 2007  [2020-03-04], ISBN 9781905886609, （原始内容存档于2017-02-27） .\n\n^ Hetland, Magnus Lie, Python Algorithms: Mastering Basic Algorithms in the Python Language, Apress: 214, 2010  [2020-03-04], ISBN 9781430232377, （原始内容存档于2017-02-28） .\n\n^ Tarjan, Robert Endre, Data Structures and Network Algorithms, CBMS_NSF Regional Conference Series in Applied Mathematics 44, Society for Industrial and Applied Mathematics: 75, 1983, The third classical minimum spanning tree algorithm was discovered by Jarník and rediscovered by Prim and Dikstra; it is commonly known as Prim's algorithm. \n\n^ Prim, R.C. Shortest connection networks and some generalizations (PDF). Bell System Technical Journal. 1957, 36 (6): 1389–1401  [18 July 2017]. Bibcode:1957BSTJ...36.1389P. doi:10.1002/j.1538-7305.1957.tb01515.x. （原始内容 (PDF)存档于18 July 2017）. \n\n^ V. Jarník: O jistém problému minimálním [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 6, 1930, pp. 57–63. (in Czech)\n\n^ Danielsson, Per-Erik; Lin, Qingfen. A Modified Fast Marching Method. Image Analysis. 24 June 2003: 1154–1161  [2020-03-25]. （原始内容存档于2021-02-13）.  引文使用过时参数coauthors (帮助)\n\n^ geeksforgeeks. Dijkstra’s Shortest Path Algorithm using priority_queue of STL. geeksforgeeks.   [2020-05-11]. （原始内容存档于2021-02-13）. \n\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的參考的参考文献", "Tag": "算法设计"}
{"Answer": "\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms second. MIT Press、S&P Global. 2001: 595–601. ISBN 0-262-03293-7. \nDial, Robert B. Algorithm 360: Shortest-path forest with topological ordering [H]. CACM. 1969, 12 (11): 632–633. doi:10.1145/363269.363610. \nZhan, F. Benjamin; Noon, Charles E. Shortest Path Algorithms: An Evaluation Using Real Road Networks. Transportation Science. February 1998, 32 (1): 65–73. doi:10.1287/trsc.32.1.65. \nKnuth, D.E. A Generalization of Dijkstra's Algorithm. Information Processing Letters. 1977, 6 (1): 1–5. doi:10.1016/0020-0190(77)90002-3. \nAhuja, Ravindra K.; Mehlhorn, Kurt; Orlin, James B.; Tarjan, Robert E. Faster Algorithms for the Shortest Path Problem. Journal of Association for Computing Machinery (ACM). April 1990, 37 (2): 213–223. doi:10.1145/77600.77615. \nRaman, Rajeev. Recent results on the single-source shortest paths problem. SIGACT News. 1997, 28 (2): 81–87. doi:10.1145/261342.261352. \nThorup, Mikkel. On RAM priority Queues. SIAM Journal on Computing. 2000, 30 (1): 86–109. doi:10.1137/S0097539795288246. \nThorup, Mikkel. Undirected single-source shortest paths with positive integer weights in linear time. journal of the ACM. 1999, 46 (3): 362–394  [2017-11-01]. doi:10.1145/316542.316548. （原始内容存档于2017-09-21）. \nZHANG Lin-guang,FANG Jin-yun,SHEN Pai-wei. An Improved Dijkstra Algorithm Based on Pairing Heap. Journal of Image and Graphics. 2007-05. \n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的參考的扩展阅读", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的外部連結", "Tag": "算法设计"}
{"Answer": "递推关系（英語：Recurrence relation），在數學上也就是差分方程（Difference equation），是一種递推地定義一個序列的方程式：序列的每一項目是定義為前若干項的函數。\n像斐波那契数即為递推关系\n\n  \n    \n      \n        \n          x\n          \n            n\n            +\n            2\n          \n        \n        =\n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        +\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x_{n+2}=x_{n+1}+x_{n}}\n  \n某些簡單定義的遞迴關係式可能會表現出非常複雜的（混沌的）性質，他們屬於數學中的非線性分析領域。\n所謂解一個遞迴關係式，也就是求其解析解，即關於n的非遞迴函數。\n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式", "Tag": "算法设计"}
{"Answer": "等差數列[编辑]\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        1\n        ,\n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          x\n          \n            n\n          \n        \n        +\n        2\n      \n    \n    {\\displaystyle x_{0}=1,x_{n+1}=x_{n}+2}\n  \n為等差數列\n  \n    \n      \n        1\n        ,\n        3\n        ,\n        5\n        ,\n        7\n        ,\n        .\n        .\n        .\n        .\n        .\n      \n    \n    {\\displaystyle 1,3,5,7,.....}\n  \n\n一般地，\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        a\n        ,\n         \n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          x\n          \n            n\n          \n        \n        +\n        d\n      \n    \n    {\\displaystyle x_{0}=a,\\ x_{n+1}=x_{n}+d}\n  \n為等差數列，其中\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n為首項，\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n為公差。等比數列[编辑]\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        1\n        ,\n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        2\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x_{0}=1,x_{n+1}=2x_{n}}\n  \n為等比數列\n  \n    \n      \n        1\n        ,\n        2\n        ,\n        4\n        ,\n        8\n        ,\n        .\n        .\n        .\n        .\n        .\n      \n    \n    {\\displaystyle 1,2,4,8,.....}\n  \n\n一般地，\n  \n    \n      \n        a\n        ≠\n        0\n      \n    \n    {\\displaystyle a\\neq 0}\n  \n且\n  \n    \n      \n        r\n        ≠\n        0\n      \n    \n    {\\displaystyle r\\neq 0}\n  \n，\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        a\n        ,\n         \n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        r\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x_{0}=a,\\ x_{n+1}=rx_{n}}\n  \n為等比數列，其中\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n為首項，\n  \n    \n      \n        r\n      \n    \n    {\\displaystyle r}\n  \n為公比。階乘[编辑]\n  \n    \n      \n        0\n        !\n        =\n        1\n      \n    \n    {\\displaystyle 0!=1}\n  \n\n\n  \n    \n      \n        n\n        !\n        =\n        n\n        ×\n        (\n        n\n        −\n        1\n        )\n        !\n      \n    \n    {\\displaystyle n!=n\\times (n-1)!}\n  \n\n因此最小的幾個階乘為\n  \n    \n      \n        1\n        ,\n        1\n        ,\n        2\n        ,\n        6\n        ,\n        24\n        ,\n        120\n        ,\n        720\n        ,\n        5040\n        ,\n        .\n        .\n        .\n        .\n        .\n      \n    \n    {\\displaystyle 1,1,2,6,24,120,720,5040,.....}\n  \n、倒数和[编辑]設\n  \n    \n      \n        \n          x\n          \n            k\n          \n        \n        =\n        \n          x\n          \n            k\n          \n        \n        +\n        \n          x\n          \n            −\n            k\n          \n        \n      \n    \n    {\\displaystyle x_{k}=x^{k}+x^{-k}}\n  \n，則\n\n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n        =\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{1}=x_{1}}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            2\n          \n        \n        =\n        (\n        \n          x\n          \n            1\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{2}=(x_{1})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            3\n          \n        \n        =\n        \n          x\n          \n            1\n          \n        \n        ⋅\n        \n          x\n          \n            2\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{3}=x_{1}\\cdot x_{2}-x_{1}}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            4\n          \n        \n        =\n        (\n        \n          x\n          \n            2\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{4}=(x_{2})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            5\n          \n        \n        =\n        \n          x\n          \n            2\n          \n        \n        ⋅\n        \n          x\n          \n            3\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{5}=x_{2}\\cdot x_{3}-x_{1}}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            6\n          \n        \n        =\n        (\n        \n          x\n          \n            3\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{6}=(x_{3})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            7\n          \n        \n        =\n        \n          x\n          \n            3\n          \n        \n        ⋅\n        \n          x\n          \n            4\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{7}=x_{3}\\cdot x_{4}-x_{1}}\n  \n\n\n  \n    \n      \n        ⋯\n        ⋯\n      \n    \n    {\\displaystyle \\cdots \\cdots }\n  \n\n\n  \n    \n      \n        \n          x\n          \n            2\n            k\n          \n        \n        =\n        (\n        \n          x\n          \n            k\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{2k}=(x_{k})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            2\n            k\n            +\n            1\n          \n        \n        =\n        \n          x\n          \n            k\n          \n        \n        ⋅\n        \n          x\n          \n            k\n            +\n            1\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{2k+1}=x_{k}\\cdot x_{k+1}-x_{1}}\n  \n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的遞迴關係式的例子", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        1\n        ,\n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          x\n          \n            n\n          \n        \n        +\n        2\n      \n    \n    {\\displaystyle x_{0}=1,x_{n+1}=x_{n}+2}\n  \n為等差數列\n  \n    \n      \n        1\n        ,\n        3\n        ,\n        5\n        ,\n        7\n        ,\n        .\n        .\n        .\n        .\n        .\n      \n    \n    {\\displaystyle 1,3,5,7,.....}\n  \n\n一般地，\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        a\n        ,\n         \n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          x\n          \n            n\n          \n        \n        +\n        d\n      \n    \n    {\\displaystyle x_{0}=a,\\ x_{n+1}=x_{n}+d}\n  \n為等差數列，其中\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n為首項，\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n為公差。", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的遞迴關係式的例子的等差數列", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        1\n        ,\n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        2\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x_{0}=1,x_{n+1}=2x_{n}}\n  \n為等比數列\n  \n    \n      \n        1\n        ,\n        2\n        ,\n        4\n        ,\n        8\n        ,\n        .\n        .\n        .\n        .\n        .\n      \n    \n    {\\displaystyle 1,2,4,8,.....}\n  \n\n一般地，\n  \n    \n      \n        a\n        ≠\n        0\n      \n    \n    {\\displaystyle a\\neq 0}\n  \n且\n  \n    \n      \n        r\n        ≠\n        0\n      \n    \n    {\\displaystyle r\\neq 0}\n  \n，\n  \n    \n      \n        \n          x\n          \n            0\n          \n        \n        =\n        a\n        ,\n         \n        \n          x\n          \n            n\n            +\n            1\n          \n        \n        =\n        r\n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x_{0}=a,\\ x_{n+1}=rx_{n}}\n  \n為等比數列，其中\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n為首項，\n  \n    \n      \n        r\n      \n    \n    {\\displaystyle r}\n  \n為公比。", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的遞迴關係式的例子的等比數列", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        0\n        !\n        =\n        1\n      \n    \n    {\\displaystyle 0!=1}\n  \n\n\n  \n    \n      \n        n\n        !\n        =\n        n\n        ×\n        (\n        n\n        −\n        1\n        )\n        !\n      \n    \n    {\\displaystyle n!=n\\times (n-1)!}\n  \n\n因此最小的幾個階乘為\n  \n    \n      \n        1\n        ,\n        1\n        ,\n        2\n        ,\n        6\n        ,\n        24\n        ,\n        120\n        ,\n        720\n        ,\n        5040\n        ,\n        .\n        .\n        .\n        .\n        .\n      \n    \n    {\\displaystyle 1,1,2,6,24,120,720,5040,.....}\n  \n、", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的遞迴關係式的例子的階乘", "Tag": "算法设计"}
{"Answer": "設\n  \n    \n      \n        \n          x\n          \n            k\n          \n        \n        =\n        \n          x\n          \n            k\n          \n        \n        +\n        \n          x\n          \n            −\n            k\n          \n        \n      \n    \n    {\\displaystyle x_{k}=x^{k}+x^{-k}}\n  \n，則\n\n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n        =\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{1}=x_{1}}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            2\n          \n        \n        =\n        (\n        \n          x\n          \n            1\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{2}=(x_{1})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            3\n          \n        \n        =\n        \n          x\n          \n            1\n          \n        \n        ⋅\n        \n          x\n          \n            2\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{3}=x_{1}\\cdot x_{2}-x_{1}}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            4\n          \n        \n        =\n        (\n        \n          x\n          \n            2\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{4}=(x_{2})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            5\n          \n        \n        =\n        \n          x\n          \n            2\n          \n        \n        ⋅\n        \n          x\n          \n            3\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{5}=x_{2}\\cdot x_{3}-x_{1}}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            6\n          \n        \n        =\n        (\n        \n          x\n          \n            3\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{6}=(x_{3})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            7\n          \n        \n        =\n        \n          x\n          \n            3\n          \n        \n        ⋅\n        \n          x\n          \n            4\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{7}=x_{3}\\cdot x_{4}-x_{1}}\n  \n\n\n  \n    \n      \n        ⋯\n        ⋯\n      \n    \n    {\\displaystyle \\cdots \\cdots }\n  \n\n\n  \n    \n      \n        \n          x\n          \n            2\n            k\n          \n        \n        =\n        (\n        \n          x\n          \n            k\n          \n        \n        \n          )\n          \n            2\n          \n        \n        −\n        2\n      \n    \n    {\\displaystyle x_{2k}=(x_{k})^{2}-2}\n  \n\n\n  \n    \n      \n        \n          x\n          \n            2\n            k\n            +\n            1\n          \n        \n        =\n        \n          x\n          \n            k\n          \n        \n        ⋅\n        \n          x\n          \n            k\n            +\n            1\n          \n        \n        −\n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{2k+1}=x_{k}\\cdot x_{k+1}-x_{1}}\n  \n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的遞迴關係式的例子的倒数和", "Tag": "算法设计"}
{"Answer": "線性字眼的意思是序列的每一項目是被定義為前一項的一種線性函數。係數和常數可能視n而定，甚至是非線性地。\n一種特別的情況是當係數並不依照n而定。\n齊次意思為关系的常數項為零。\n為了要得到線性遞迴唯一的解，必須有一些起始條件，就是序列的第一個數字無法依照該序列的其他數字而定時，且必須設定為某些數值。\n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的常係數線性齊次遞迴關係式", "Tag": "算法设计"}
{"Answer": "線性遞迴關係式的解通常是由系統的方法中找出來，通常藉由使用生成函數（形式冪級數）或藉由觀察rn是一種對r的特定數值之解的事實。且因關係式為線性方程，另一種方法是以矩陣表示此一遞迴關係式，並透過矩陣對角化等技巧求出關係式的通項。\n二階遞迴關係式的形式：\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        A\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        B\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n        \n      \n    \n    {\\displaystyle a_{n}=Aa_{n-1}+Ba_{n-2}\\,}\n  \n我們擁有解為rn：\n\n  \n    \n      \n        \n          r\n          \n            n\n          \n        \n        =\n        A\n        \n          r\n          \n            n\n            −\n            1\n          \n        \n        +\n        B\n        \n          r\n          \n            n\n            −\n            2\n          \n        \n        \n      \n    \n    {\\displaystyle r^{n}=Ar^{n-1}+Br^{n-2}\\,}\n  \n兩邊除以\n  \n    \n      \n        \n          r\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle r^{n-2}}\n  \n我們可以得到：\n\n  \n    \n      \n        \n          r\n          \n            2\n          \n        \n        =\n        A\n        r\n        +\n        B\n        \n      \n    \n    {\\displaystyle r^{2}=Ar+B\\,}\n  \n\n\n  \n    \n      \n        \n          r\n          \n            2\n          \n        \n        −\n        A\n        r\n        −\n        B\n        =\n        0\n        \n      \n    \n    {\\displaystyle r^{2}-Ar-B=0\\,}\n  \n這就是遞迴關係式的特徵方程。解出r可獲得兩個根（roots）\n  \n    \n      \n        \n          λ\n          \n            1\n          \n        \n        ,\n        \n          λ\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\lambda _{1},\\lambda _{2}}\n  \n，且如果兩個根是不同的，我們可得到解為\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        C\n        \n          λ\n          \n            1\n          \n          \n            n\n          \n        \n        +\n        D\n        \n          λ\n          \n            2\n          \n          \n            n\n          \n        \n        \n      \n    \n    {\\displaystyle a_{n}=C\\lambda _{1}^{n}+D\\lambda _{2}^{n}\\,}\n  \n而如果兩個根是相同的（當A2+4B=0），我們得到\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        C\n        \n          λ\n          \n            n\n          \n        \n        +\n        D\n        n\n        \n          λ\n          \n            n\n          \n        \n        \n      \n    \n    {\\displaystyle a_{n}=C\\lambda ^{n}+Dn\\lambda ^{n}\\,}\n  \nC和D都是常數。以上結果皆可由直接代入得證，或以矩陣對角化的技巧推導出。\n換句話說，將這種\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        A\n        \n          a\n          \n            n\n            −\n            1\n          \n        \n        +\n        B\n        \n          a\n          \n            n\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{n}=Aa_{n-1}+Ba_{n-2}}\n  \n形式的方程式，用2代入n後，就得到上述的\n  \n    \n      \n        \n          r\n          \n            2\n          \n        \n        =\n        A\n        r\n        +\n        B\n      \n    \n    {\\displaystyle r^{2}=Ar+B}\n  \n。常數\"C\"和\"D\"可以從\"邊界條件（side conditions）\"中得到，通常會像是「已知\n  \n    \n      \n        \n          a\n          \n            0\n          \n        \n        =\n        \n          c\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle a_{0}=c_{1}}\n  \n, \n  \n    \n      \n        \n          a\n          \n            1\n          \n        \n        =\n        \n          c\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle a_{1}=c_{2}}\n  \n」。\n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的解線性遞迴關係式", "Tag": "算法设计"}
{"Answer": "斐波那契数是使用一種線性遞迴關係式來定義：\n\n  \n    \n      \n        \n          F\n          \n            0\n          \n        \n        =\n        0\n        \n      \n    \n    {\\displaystyle F_{0}=0\\,}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            1\n          \n        \n        =\n        1\n        \n      \n    \n    {\\displaystyle F_{1}=1\\,}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        +\n        \n          F\n          \n            n\n            −\n            2\n          \n        \n        \n      \n    \n    {\\displaystyle F_{n}=F_{n-1}+F_{n-2}\\,}\n  \n設若：\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        \n          /\n        \n        \n          F\n          \n            n\n            −\n            1\n          \n        \n        \n      \n    \n    {\\displaystyle F_{n}/F_{n-1}\\,}\n  \n當n趨於無限大之極限值存在，則其值為\n  \n    \n      \n        \n          1\n          +\n          \n            \n              5\n            \n          \n        \n        \n          2\n          \n        \n      \n    \n    {\\displaystyle 1+{\\sqrt {5}} \\over 2\\,}\n  \n \n  \n    \n      \n        =\n        Φ\n      \n    \n    {\\displaystyle =\\Phi }\n  \n恰為黃金分割值，1.618....，另一值則為0.618....，兩值互為倒數，也就是說1.618....分之1=0.618....，反之亦然。\n\n  \n    \n      \n        \n          F\n          \n            n\n          \n        \n        =\n        \n          \n            \n              Φ\n              \n                n\n              \n            \n            \n              \n                5\n              \n            \n          \n        \n        −\n        \n          \n            \n              (\n              1\n              −\n              Φ\n              \n                )\n                \n                  n\n                \n              \n            \n            \n              \n                5\n              \n            \n          \n        \n      \n    \n    {\\displaystyle F_{n}={\\Phi ^{n} \\over {\\sqrt {5}}}-{(1-\\Phi )^{n} \\over {\\sqrt {5}}}}\n  \n起始條件為：\n\n  \n    \n      \n        \n          F\n          \n            0\n          \n        \n        =\n        0\n        \n      \n    \n    {\\displaystyle F_{0}=0\\,}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            1\n          \n        \n        =\n        1\n        \n      \n    \n    {\\displaystyle F_{1}=1\\,}\n  \n因此，斐波那契数的序列為：\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 ...", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的範例：斐波那契数（Fibonacci Number）", "Tag": "算法设计"}
{"Answer": "对于常系数非齐次线性递推关系，我们可以用待定系数法（英语：Method of undetermined coefficients）来求出它的一个特解，而它的通解就是这个特解与对应的齐次递推关系的通解的和。也可以使用迭代法求解，但只能得到确切的数值解，不能直接以解析式作答，该方法可利用计算机求解。\n时域经典法求解[编辑]一般情况下，常系数线性差分方程可以写作：\n\n  \n    \n      \n        \n          ∑\n          \n            k\n            =\n            0\n          \n          \n            N\n          \n        \n        \n          a\n          \n            k\n          \n        \n        y\n        (\n        n\n        −\n        k\n        )\n        =\n        \n          ∑\n          \n            r\n            =\n            0\n          \n          \n            M\n          \n        \n        \n          b\n          \n            r\n          \n        \n        x\n        (\n        n\n        −\n        r\n        )\n      \n    \n    {\\displaystyle \\sum _{k=0}^{N}a_{k}y(n-k)=\\sum _{r=0}^{M}b_{r}x(n-r)}\n  \n则对应的齐次方程形式为：\n\n  \n    \n      \n        \n          ∑\n          \n            k\n            =\n            0\n          \n          \n            N\n          \n        \n        \n          a\n          \n            k\n          \n        \n        y\n        (\n        n\n        −\n        k\n        )\n        =\n        0\n      \n    \n    {\\displaystyle \\sum _{k=0}^{N}a_{k}y(n-k)=0}\n  \n则特征方程为：\n\n  \n    \n      \n        \n          ∑\n          \n            k\n            =\n            0\n          \n          \n            N\n          \n        \n        \n          a\n          \n            k\n          \n        \n        \n          α\n          \n            N\n            −\n            k\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle \\sum _{k=0}^{N}a_{k}\\alpha ^{N-k}=0}\n  \n当特征根非重根时，齐次解为：\n\n  \n    \n      \n        \n          y\n          \n            h\n          \n        \n        (\n        n\n        )\n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            N\n          \n        \n        \n          C\n          \n            i\n          \n        \n        \n          α\n          \n            i\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{h}(n)=\\sum _{i=1}^{N}C_{i}\\alpha _{i}^{n}}\n  \n当特征根为重根时，若\n  \n    \n      \n        \n          α\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{1}}\n  \n为特征方程的\n  \n    \n      \n        K\n      \n    \n    {\\displaystyle K}\n  \n重根，齐次解为：\n\n  \n    \n      \n        \n          y\n          \n            h\n          \n        \n        (\n        n\n        )\n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            K\n          \n        \n        \n          n\n          \n            K\n            −\n            i\n          \n        \n        \n          α\n          \n            1\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{h}(n)=\\sum _{i=1}^{K}n^{K-i}\\alpha _{1}^{n}}\n  \n特解\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        D\n        (\n        n\n        )\n      \n    \n    {\\displaystyle y_{p}(n)=D(n)}\n  \n的形式由激励函数\n  \n    \n      \n        x\n        (\n        n\n        )\n      \n    \n    {\\displaystyle x(n)}\n  \n的形式决定。\n一般情况，当激励函数x(n)代入方程。\n方程右方出现\n  \n    \n      \n        \n          n\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle n^{k}}\n  \n的形式，则特解选择\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        \n          A\n          \n            0\n          \n        \n        \n          n\n          \n            k\n          \n        \n        +\n        \n          A\n          \n            1\n          \n        \n        \n          n\n          \n            k\n            −\n            1\n          \n        \n        +\n        ⋯\n        +\n        \n          A\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=A_{0}n^{k}+A_{1}n^{k-1}+\\cdots +A_{k}}\n  \n当方程右方出现\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle a^{n}}\n  \n的形式，则特解选择\n当a不是特征根时\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        A\n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=Aa^{n}}\n  \n当a是特征根时\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        (\n        \n          A\n          \n            1\n          \n        \n        n\n        +\n        \n          A\n          \n            0\n          \n        \n        )\n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=(A_{1}n+A_{0})a^{n}}\n  \n当a为r重根时\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        (\n        \n          A\n          \n            r\n          \n        \n        \n          n\n          \n            r\n          \n        \n        +\n        \n          A\n          \n            r\n            −\n            1\n          \n        \n        \n          n\n          \n            r\n            −\n            1\n          \n        \n        +\n        ⋯\n        +\n        \n          A\n          \n            1\n          \n        \n        n\n        +\n        \n          A\n          \n            0\n          \n        \n        )\n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=(A_{r}n^{r}+A_{r-1}n^{r-1}+\\cdots +A_{1}n+A_{0})a^{n}}\n  \n将特解带入原方程，求出待定系数。根据边界条件，可求出齐次节待定系数。\n例子[编辑]我们用待定系数法来解以下的常系数非齐次线性递推关系：\n\n  \n    \n      \n        \n          a\n          \n            n\n            +\n            1\n          \n        \n        =\n        2\n        \n          a\n          \n            n\n          \n        \n        +\n        \n          3\n          \n            n\n          \n        \n        +\n        5\n        n\n        \n      \n    \n    {\\displaystyle a_{n+1}=2a_{n}+3^{n}+5n\\,}\n  \n对应的齐次递推关系\n\n  \n    \n      \n        \n          b\n          \n            n\n            +\n            1\n          \n        \n        =\n        2\n        \n          b\n          \n            n\n          \n        \n        \n      \n    \n    {\\displaystyle b_{n+1}=2b_{n}\\,}\n  \n的齐次解是：\n\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            1\n          \n        \n        \n          2\n          \n            n\n          \n        \n        \n      \n    \n    {\\displaystyle b_{n}=c_{1}2^{n}\\,}\n  \n我们猜测特解的形式为：\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            2\n          \n        \n        \n          3\n          \n            n\n          \n        \n        +\n        \n          c\n          \n            3\n          \n        \n        n\n        +\n        \n          c\n          \n            4\n          \n        \n        \n      \n    \n    {\\displaystyle a_{n}=c_{2}3^{n}+c_{3}n+c_{4}\\,}\n  \n代入原递推关系中，我们便得到：\n\n  \n    \n      \n        \n          c\n          \n            2\n          \n        \n        \n          3\n          \n            n\n            +\n            1\n          \n        \n        +\n        \n          c\n          \n            3\n          \n        \n        (\n        n\n        +\n        1\n        )\n        +\n        \n          c\n          \n            4\n          \n        \n        =\n        2\n        (\n        \n          c\n          \n            2\n          \n        \n        \n          3\n          \n            n\n          \n        \n        +\n        \n          c\n          \n            3\n          \n        \n        n\n        +\n        \n          c\n          \n            4\n          \n        \n        )\n        +\n        \n          3\n          \n            n\n          \n        \n        +\n        5\n        n\n        \n      \n    \n    {\\displaystyle c_{2}3^{n+1}+c_{3}(n+1)+c_{4}=2(c_{2}3^{n}+c_{3}n+c_{4})+3^{n}+5n\\,}\n  \n比较等式两端的\n  \n    \n      \n        \n          3\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle 3^{n}}\n  \n项的系数，可得：\n\n  \n    \n      \n        3\n        \n          c\n          \n            2\n          \n        \n        =\n        2\n        \n          c\n          \n            2\n          \n        \n        +\n        1\n        \n      \n    \n    {\\displaystyle 3c_{2}=2c_{2}+1\\,}\n  \n\n  \n    \n      \n        \n          c\n          \n            2\n          \n        \n        =\n        1\n        \n      \n    \n    {\\displaystyle c_{2}=1\\,}\n  \n比较等式两端的\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n项的系数，可得：\n\n  \n    \n      \n        \n          c\n          \n            3\n          \n        \n        =\n        2\n        \n          c\n          \n            3\n          \n        \n        +\n        5\n        \n      \n    \n    {\\displaystyle c_{3}=2c_{3}+5\\,}\n  \n\n  \n    \n      \n        \n          c\n          \n            3\n          \n        \n        =\n        −\n        5\n        \n      \n    \n    {\\displaystyle c_{3}=-5\\,}\n  \n比较等式两端的常数项，可得：\n\n  \n    \n      \n        \n          c\n          \n            3\n          \n        \n        +\n        \n          c\n          \n            4\n          \n        \n        =\n        2\n        \n          c\n          \n            4\n          \n        \n        \n      \n    \n    {\\displaystyle c_{3}+c_{4}=2c_{4}\\,}\n  \n\n  \n    \n      \n        \n          c\n          \n            4\n          \n        \n        =\n        \n          c\n          \n            3\n          \n        \n        =\n        −\n        5\n        \n      \n    \n    {\\displaystyle c_{4}=c_{3}=-5\\,}\n  \n因此原递推关系的通解为：\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            1\n          \n        \n        \n          2\n          \n            n\n          \n        \n        +\n        \n          3\n          \n            n\n          \n        \n        −\n        5\n        n\n        −\n        5\n        \n      \n    \n    {\\displaystyle a_{n}=c_{1}2^{n}+3^{n}-5n-5\\,}\n  \n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的常系数非齐次线性递推关系", "Tag": "算法设计"}
{"Answer": "一般情况下，常系数线性差分方程可以写作：\n\n  \n    \n      \n        \n          ∑\n          \n            k\n            =\n            0\n          \n          \n            N\n          \n        \n        \n          a\n          \n            k\n          \n        \n        y\n        (\n        n\n        −\n        k\n        )\n        =\n        \n          ∑\n          \n            r\n            =\n            0\n          \n          \n            M\n          \n        \n        \n          b\n          \n            r\n          \n        \n        x\n        (\n        n\n        −\n        r\n        )\n      \n    \n    {\\displaystyle \\sum _{k=0}^{N}a_{k}y(n-k)=\\sum _{r=0}^{M}b_{r}x(n-r)}\n  \n则对应的齐次方程形式为：\n\n  \n    \n      \n        \n          ∑\n          \n            k\n            =\n            0\n          \n          \n            N\n          \n        \n        \n          a\n          \n            k\n          \n        \n        y\n        (\n        n\n        −\n        k\n        )\n        =\n        0\n      \n    \n    {\\displaystyle \\sum _{k=0}^{N}a_{k}y(n-k)=0}\n  \n则特征方程为：\n\n  \n    \n      \n        \n          ∑\n          \n            k\n            =\n            0\n          \n          \n            N\n          \n        \n        \n          a\n          \n            k\n          \n        \n        \n          α\n          \n            N\n            −\n            k\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle \\sum _{k=0}^{N}a_{k}\\alpha ^{N-k}=0}\n  \n当特征根非重根时，齐次解为：\n\n  \n    \n      \n        \n          y\n          \n            h\n          \n        \n        (\n        n\n        )\n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            N\n          \n        \n        \n          C\n          \n            i\n          \n        \n        \n          α\n          \n            i\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{h}(n)=\\sum _{i=1}^{N}C_{i}\\alpha _{i}^{n}}\n  \n当特征根为重根时，若\n  \n    \n      \n        \n          α\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{1}}\n  \n为特征方程的\n  \n    \n      \n        K\n      \n    \n    {\\displaystyle K}\n  \n重根，齐次解为：\n\n  \n    \n      \n        \n          y\n          \n            h\n          \n        \n        (\n        n\n        )\n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            K\n          \n        \n        \n          n\n          \n            K\n            −\n            i\n          \n        \n        \n          α\n          \n            1\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{h}(n)=\\sum _{i=1}^{K}n^{K-i}\\alpha _{1}^{n}}\n  \n特解\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        D\n        (\n        n\n        )\n      \n    \n    {\\displaystyle y_{p}(n)=D(n)}\n  \n的形式由激励函数\n  \n    \n      \n        x\n        (\n        n\n        )\n      \n    \n    {\\displaystyle x(n)}\n  \n的形式决定。\n一般情况，当激励函数x(n)代入方程。\n方程右方出现\n  \n    \n      \n        \n          n\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle n^{k}}\n  \n的形式，则特解选择\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        \n          A\n          \n            0\n          \n        \n        \n          n\n          \n            k\n          \n        \n        +\n        \n          A\n          \n            1\n          \n        \n        \n          n\n          \n            k\n            −\n            1\n          \n        \n        +\n        ⋯\n        +\n        \n          A\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=A_{0}n^{k}+A_{1}n^{k-1}+\\cdots +A_{k}}\n  \n当方程右方出现\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle a^{n}}\n  \n的形式，则特解选择\n当a不是特征根时\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        A\n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=Aa^{n}}\n  \n当a是特征根时\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        (\n        \n          A\n          \n            1\n          \n        \n        n\n        +\n        \n          A\n          \n            0\n          \n        \n        )\n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=(A_{1}n+A_{0})a^{n}}\n  \n当a为r重根时\n\n  \n    \n      \n        \n          y\n          \n            p\n          \n        \n        (\n        n\n        )\n        =\n        (\n        \n          A\n          \n            r\n          \n        \n        \n          n\n          \n            r\n          \n        \n        +\n        \n          A\n          \n            r\n            −\n            1\n          \n        \n        \n          n\n          \n            r\n            −\n            1\n          \n        \n        +\n        ⋯\n        +\n        \n          A\n          \n            1\n          \n        \n        n\n        +\n        \n          A\n          \n            0\n          \n        \n        )\n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{p}(n)=(A_{r}n^{r}+A_{r-1}n^{r-1}+\\cdots +A_{1}n+A_{0})a^{n}}\n  \n将特解带入原方程，求出待定系数。根据边界条件，可求出齐次节待定系数。\n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的常系数非齐次线性递推关系的时域经典法求解", "Tag": "算法设计"}
{"Answer": "我们用待定系数法来解以下的常系数非齐次线性递推关系：\n\n  \n    \n      \n        \n          a\n          \n            n\n            +\n            1\n          \n        \n        =\n        2\n        \n          a\n          \n            n\n          \n        \n        +\n        \n          3\n          \n            n\n          \n        \n        +\n        5\n        n\n        \n      \n    \n    {\\displaystyle a_{n+1}=2a_{n}+3^{n}+5n\\,}\n  \n对应的齐次递推关系\n\n  \n    \n      \n        \n          b\n          \n            n\n            +\n            1\n          \n        \n        =\n        2\n        \n          b\n          \n            n\n          \n        \n        \n      \n    \n    {\\displaystyle b_{n+1}=2b_{n}\\,}\n  \n的齐次解是：\n\n  \n    \n      \n        \n          b\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            1\n          \n        \n        \n          2\n          \n            n\n          \n        \n        \n      \n    \n    {\\displaystyle b_{n}=c_{1}2^{n}\\,}\n  \n我们猜测特解的形式为：\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            2\n          \n        \n        \n          3\n          \n            n\n          \n        \n        +\n        \n          c\n          \n            3\n          \n        \n        n\n        +\n        \n          c\n          \n            4\n          \n        \n        \n      \n    \n    {\\displaystyle a_{n}=c_{2}3^{n}+c_{3}n+c_{4}\\,}\n  \n代入原递推关系中，我们便得到：\n\n  \n    \n      \n        \n          c\n          \n            2\n          \n        \n        \n          3\n          \n            n\n            +\n            1\n          \n        \n        +\n        \n          c\n          \n            3\n          \n        \n        (\n        n\n        +\n        1\n        )\n        +\n        \n          c\n          \n            4\n          \n        \n        =\n        2\n        (\n        \n          c\n          \n            2\n          \n        \n        \n          3\n          \n            n\n          \n        \n        +\n        \n          c\n          \n            3\n          \n        \n        n\n        +\n        \n          c\n          \n            4\n          \n        \n        )\n        +\n        \n          3\n          \n            n\n          \n        \n        +\n        5\n        n\n        \n      \n    \n    {\\displaystyle c_{2}3^{n+1}+c_{3}(n+1)+c_{4}=2(c_{2}3^{n}+c_{3}n+c_{4})+3^{n}+5n\\,}\n  \n比较等式两端的\n  \n    \n      \n        \n          3\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle 3^{n}}\n  \n项的系数，可得：\n\n  \n    \n      \n        3\n        \n          c\n          \n            2\n          \n        \n        =\n        2\n        \n          c\n          \n            2\n          \n        \n        +\n        1\n        \n      \n    \n    {\\displaystyle 3c_{2}=2c_{2}+1\\,}\n  \n\n  \n    \n      \n        \n          c\n          \n            2\n          \n        \n        =\n        1\n        \n      \n    \n    {\\displaystyle c_{2}=1\\,}\n  \n比较等式两端的\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n项的系数，可得：\n\n  \n    \n      \n        \n          c\n          \n            3\n          \n        \n        =\n        2\n        \n          c\n          \n            3\n          \n        \n        +\n        5\n        \n      \n    \n    {\\displaystyle c_{3}=2c_{3}+5\\,}\n  \n\n  \n    \n      \n        \n          c\n          \n            3\n          \n        \n        =\n        −\n        5\n        \n      \n    \n    {\\displaystyle c_{3}=-5\\,}\n  \n比较等式两端的常数项，可得：\n\n  \n    \n      \n        \n          c\n          \n            3\n          \n        \n        +\n        \n          c\n          \n            4\n          \n        \n        =\n        2\n        \n          c\n          \n            4\n          \n        \n        \n      \n    \n    {\\displaystyle c_{3}+c_{4}=2c_{4}\\,}\n  \n\n  \n    \n      \n        \n          c\n          \n            4\n          \n        \n        =\n        \n          c\n          \n            3\n          \n        \n        =\n        −\n        5\n        \n      \n    \n    {\\displaystyle c_{4}=c_{3}=-5\\,}\n  \n因此原递推关系的通解为：\n\n  \n    \n      \n        \n          a\n          \n            n\n          \n        \n        =\n        \n          c\n          \n            1\n          \n        \n        \n          2\n          \n            n\n          \n        \n        +\n        \n          3\n          \n            n\n          \n        \n        −\n        5\n        n\n        −\n        5\n        \n      \n    \n    {\\displaystyle a_{n}=c_{1}2^{n}+3^{n}-5n-5\\,}\n  \n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的常系数非齐次线性递推关系的例子", "Tag": "算法设计"}
{"Answer": "数值求解常微分方程时，经常会遇到递归关系。例如，求解如下初值问题时\n\n  \n    \n      \n        \n          y\n          ′\n        \n        (\n        t\n        )\n        =\n        f\n        (\n        t\n        ,\n        y\n        (\n        t\n        )\n        )\n        ,\n        \n        y\n        (\n        \n          t\n          \n            0\n          \n        \n        )\n        =\n        \n          y\n          \n            0\n          \n        \n        ,\n        \n        \n      \n    \n    {\\displaystyle y'(t)=f(t,y(t)),\\qquad y(t_{0})=y_{0},\\qquad \\qquad }\n  \n如采用欧拉法和步长h，可以通过如下递归关系计算\n  \n    \n      \n        \n          y\n          \n            0\n          \n        \n        =\n        y\n        (\n        \n          t\n          \n            0\n          \n        \n        )\n      \n    \n    {\\displaystyle y_{0}=y(t_{0})}\n  \n, \n  \n    \n      \n        \n          y\n          \n            1\n          \n        \n        =\n        y\n        (\n        \n          t\n          \n            0\n          \n        \n        +\n        h\n        )\n        ,\n      \n    \n    {\\displaystyle y_{1}=y(t_{0}+h),}\n  \n \n  \n    \n      \n        \n          y\n          \n            2\n          \n        \n        =\n        y\n        (\n        \n          t\n          \n            0\n          \n        \n        +\n        2\n        h\n        )\n        ,\n        .\n        .\n        .\n      \n    \n    {\\displaystyle y_{2}=y(t_{0}+2h),...}\n  \n\n\n  \n    \n      \n        \n          y\n          \n            n\n            +\n            1\n          \n        \n        =\n        \n          y\n          \n            n\n          \n        \n        +\n        h\n        f\n        (\n        \n          t\n          \n            n\n          \n        \n        ,\n        \n          y\n          \n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle y_{n+1}=y_{n}+hf(t_{n},y_{n})}\n  \n线性一阶微分方程组可以用离散化条目中介绍的方法解析地精确离散化。\n", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的與微分方程的關係", "Tag": "算法设计"}
{"Answer": "递归\n差分\n主定理——分析算法複雜度的方法，從遞歸式得出通項的大小估計\n圆点段证明（Circle points segments proof）\n母函数——形式冪級數，其系數隱含某數列的資訊", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的參考", "Tag": "算法设计"}
{"Answer": "Difference and Functional Equations: Exact Solutions （页面存档备份，存于互联网档案馆） at EqWorld - The World of Mathematical Equations.\nDifference and Functional Equations: Methods （页面存档备份，存于互联网档案馆） at EqWorld - The World of Mathematical Equations.", "Konwledge_Point": "遞迴關係式", "Question": "什么是遞迴關係式的外部連結", "Tag": "算法设计"}
{"Answer": "快速傅里叶变换（英語：Fast Fourier Transform, FFT），是快速计算序列的离散傅里叶变换（DFT）或其逆变换的方法[1]。傅里叶分析将信号从原始域（通常是时间或空间）转换到頻域的表示或者逆过来转换。FFT会通过把DFT矩阵分解为稀疏（大多为零）因子之积来快速计算此类变换。[2]  因此，它能够将计算DFT的复杂度从只用DFT定义计算需要的 \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n，降低到 \n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n，其中 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 为数据大小。\n快速傅里叶变换广泛的应用于工程、科学和数学领域。这里的基本思想在1965年才得到普及，但早在1805年就已推导出来。[3] 1994年美國數學家吉爾伯特·斯特朗把FFT描述为“我们一生中最重要的数值算法”[4]，它还被IEEE科学与工程计算期刊列入20世纪十大算法。[5]\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换", "Tag": "算法设计"}
{"Answer": "用FFT计算DFT会得到与直接用DFT定义计算相同的结果；最重要的区别是FFT更快。（由于捨入誤差的存在，许多FFT算法还会比直接运用定义求值精确很多，后面会讨论到这一点。）\n令 x0, ...., xN-1 為复数。DFT由下式定义\n\n  \n    \n      \n        \n          X\n          \n            k\n          \n        \n        =\n        \n          ∑\n          \n            n\n            =\n            0\n          \n          \n            N\n            −\n            1\n          \n        \n        \n          x\n          \n            n\n          \n        \n        \n          e\n          \n            −\n            \n              i\n              2\n              π\n              k\n              \n                \n                  n\n                  N\n                \n              \n            \n          \n        \n        \n        k\n        =\n        0\n        ,\n        …\n        ,\n        N\n        −\n        1.\n      \n    \n    {\\displaystyle X_{k}=\\sum _{n=0}^{N-1}x_{n}e^{-{i2\\pi k{\\frac {n}{N}}}}\\qquad k=0,\\dots ,N-1.}\n  \n直接按这个定义求值需要 O(N2) 次运算：Xk 共有 N 个输出，每个输出需要 N 项求和。直接使用DFT運算需使用N個複數乘法(4N 個實數乘法)與N-1個複數加法(2N-2個實數加法)，因此，計算使用DFT所有N點的值需要N2複數乘法與N2-N 個複數加法。FFT则是能够在 O(N log N) 次操作计算出相同结果的任何方法。更准确的说，所有已知的FFT算法都需要 O(N log N) 次运算（技术上O只标记上界），虽然还没有已知的证据证明更低的复杂度是不可能的。[6]\n要说明FFT节省时间的方式，就得考虑复数相乘和相加的次数。直接计算DFT的值涉及到 N2 次复数相乘和 N(N−1) 次复数相加（可以通过削去琐碎运算（如乘以1）来节省 O(N) 次运算）。众所周知的基2库利-图基算法，N 为2的幂，可以只用 (N/2)log2(N) 次复数乘法（再次忽略乘以1的简化）和 Nlog2(N) 次加法就可以得到相同结果。在实际中，现代计算机通常的实际性能通常不受算术运算的速度和对复杂主体的分析主导[7]，但是从 O(N2) 到 O(N log N) 的总体改进仍然能够体现出来。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的定义和速度", "Tag": "算法设计"}
{"Answer": "假設一個M*N型矩阵S可分解成列向量以及行向量相乘：\n\n  \n    \n      \n        \n          S\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {S} ={\\begin{bmatrix}a_{1}\\\\a_{2}\\\\\\vdots \\\\a_{m}\\end{bmatrix}}{\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}}\n  \n\n若\n  \n    \n      \n        \n          \n            \n              [\n              \n                \n                  \n                    \n                      a\n                      \n                        1\n                      \n                    \n                  \n                  \n                    \n                      a\n                      \n                        2\n                      \n                    \n                  \n                  \n                    ⋯\n                  \n                  \n                    \n                      a\n                      \n                        m\n                      \n                    \n                  \n                \n              \n              ]\n            \n          \n          \n            T\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}a_{1}&a_{2}&\\cdots &a_{m}\\end{bmatrix}}^{T}}\n  \n有\n  \n    \n      \n        \n          M\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle M_{0}}\n  \n個相異的非平凡值（\n  \n    \n      \n        \n          a\n          \n            m\n          \n        \n        ≠\n        ±\n        \n          2\n          \n            k\n          \n        \n        ,\n        \n          a\n          \n            m\n          \n        \n        ≠\n        ±\n        \n          2\n          \n            k\n          \n        \n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle a_{m}\\neq \\pm 2^{k},a_{m}\\neq \\pm 2^{k}a_{n}}\n  \n where \n  \n    \n      \n        m\n        ≠\n        n\n      \n    \n    {\\displaystyle m\\neq n}\n  \n）　\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}}\n  \n有\n  \n    \n      \n        \n          N\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle N_{0}}\n  \n個相異的非平凡值\n則S共需要\n  \n    \n      \n        \n          M\n          \n            0\n          \n        \n        ∗\n        \n          N\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle M_{0}*N_{0}}\n  \n個乘法。\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  Z\n                  [\n                  1\n                  ]\n                \n              \n              \n                \n                  Z\n                  [\n                  2\n                  ]\n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  Z\n                  [\n                  N\n                  ]\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          S\n        \n        \n          \n            [\n            \n              \n                \n                  X\n                  [\n                  1\n                  ]\n                \n              \n              \n                \n                  X\n                  [\n                  2\n                  ]\n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  X\n                  [\n                  N\n                  ]\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  X\n                  [\n                  1\n                  ]\n                \n              \n              \n                \n                  X\n                  [\n                  2\n                  ]\n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  X\n                  [\n                  N\n                  ]\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}Z[1]\\\\Z[2]\\\\\\vdots \\\\Z[N]\\end{bmatrix}}=\\mathbf {S} {\\begin{bmatrix}X[1]\\\\X[2]\\\\\\vdots \\\\X[N]\\end{bmatrix}}={\\begin{bmatrix}a_{1}\\\\a_{2}\\\\\\vdots \\\\a_{m}\\end{bmatrix}}{\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}{\\begin{bmatrix}X[1]\\\\X[2]\\\\\\vdots \\\\X[N]\\end{bmatrix}}}\n  \n\nStep 1：\n  \n    \n      \n        \n          Z\n          \n            a\n          \n        \n        =\n        \n          b\n          \n            1\n          \n        \n        X\n        [\n        1\n        ]\n        +\n        \n          b\n          \n            2\n          \n        \n        X\n        [\n        2\n        ]\n        +\n        ⋯\n        +\n        \n          b\n          \n            n\n          \n        \n        X\n        [\n        N\n        ]\n      \n    \n    {\\displaystyle Z_{a}=b_{1}X[1]+b_{2}X[2]+\\cdots +b_{n}X[N]}\n  \n\nStep 2：\n  \n    \n      \n        Z\n        [\n        1\n        ]\n        =\n        \n          a\n          \n            1\n          \n        \n        \n          Z\n          \n            a\n          \n        \n        ,\n        Z\n        [\n        2\n        ]\n        =\n        \n          a\n          \n            2\n          \n        \n        \n          Z\n          \n            a\n          \n        \n        ,\n        ⋯\n        ,\n        Z\n        [\n        N\n        ]\n        =\n        \n          a\n          \n            m\n          \n        \n        \n          Z\n          \n            a\n          \n        \n      \n    \n    {\\displaystyle Z[1]=a_{1}Z_{a},Z[2]=a_{2}Z_{a},\\cdots ,Z[N]=a_{m}Z_{a}}\n  \n\n簡化理論的變型：\n\n  \n    \n      \n        \n          S\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        +\n        \n          \n            S\n          \n          \n            1\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {S} ={\\begin{bmatrix}a_{1}\\\\a_{2}\\\\\\vdots \\\\a_{m}\\end{bmatrix}}{\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}+\\mathbf {S} _{1}}\n  \n\n\n  \n    \n      \n        \n          S\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle S_{1}}\n  \n也是一個M*N的矩陣。\n若\n  \n    \n      \n        \n          S\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle S_{1}}\n  \n有\n  \n    \n      \n        \n          P\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle P_{1}}\n  \n個值不等於0，則\n  \n    \n      \n        \n          S\n        \n      \n    \n    {\\displaystyle \\mathbf {S} }\n  \n的乘法量上限為\n  \n    \n      \n        \n          M\n          \n            0\n          \n        \n        +\n        \n          N\n          \n            0\n          \n        \n        +\n        \n          P\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle M_{0}+N_{0}+P_{1}}\n  \n。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的一般的簡化理論", "Tag": "算法设计"}
{"Answer": "假設\n  \n    \n      \n        N\n        =\n        \n          P\n          \n            1\n          \n        \n        ×\n        \n          P\n          \n            2\n          \n        \n        ×\n        ⋯\n        ×\n        \n          P\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=P_{1}\\times P_{2}\\times \\cdots \\times P_{k}}\n  \n，其中\n  \n    \n      \n        \n          P\n          \n            1\n          \n        \n        ,\n        \n          P\n          \n            2\n          \n        \n        ,\n        ⋯\n        ,\n        \n          P\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle P_{1},P_{2},\\cdots ,P_{k}}\n  \n彼此互質\n\n  \n    \n      \n        \n          \n            P\n            \n              k\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {P_{k}} }\n  \n點DFT的乘法量為\n  \n    \n      \n        \n          \n            B\n            \n              k\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B_{k}} }\n  \n，則\n  \n    \n      \n        \n          N\n        \n      \n    \n    {\\displaystyle \\mathbf {N} }\n  \n點DFT的乘法量為：\n\n  \n    \n      \n        \n          \n            N\n            \n              P\n              \n                1\n              \n            \n          \n        \n        \n          B\n          \n            1\n          \n        \n        +\n        \n          \n            N\n            \n              P\n              \n                2\n              \n            \n          \n        \n        \n          B\n          \n            2\n          \n        \n        +\n        ⋯\n        ⋯\n        +\n        \n          \n            N\n            \n              P\n              \n                k\n              \n            \n          \n        \n        \n          B\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{P_{1}}}B_{1}+{\\frac {N}{P_{2}}}B_{2}+\\cdots \\cdots +{\\frac {N}{P_{k}}}B_{k}}\n  \n假設\n  \n    \n      \n        \n          N\n          =\n          \n            P\n            \n              c\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {N=P^{c}} }\n  \n，P是一個質數。\n若\n  \n    \n      \n        \n          \n            N\n            \n              1\n            \n          \n          =\n          \n            P\n            \n              a\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {N_{1}=P^{a}} }\n  \n點的DFT需要的乘法量為\n  \n    \n      \n        \n          \n            B\n            \n              1\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B_{1}} }\n  \n\n且\n  \n    \n      \n        \n          n\n          \n            1\n          \n        \n        ×\n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n_{1}\\times n_{2}}\n  \n當中（\n  \n    \n      \n        \n          n\n          \n            1\n          \n        \n        =\n        0\n        ,\n        1\n        ,\n        ⋯\n        ,\n        \n          N\n          \n            1\n          \n        \n        −\n        1\n        ,\n        \n        \n          n\n          \n            2\n          \n        \n        =\n        0\n        ,\n        1\n        ,\n        ⋯\n        ,\n        \n          N\n          \n            2\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle n_{1}=0,1,\\cdots ,N_{1}-1,\\quad n_{2}=0,1,\\cdots ,N_{2}-1}\n  \n）\n有\n  \n    \n      \n        \n          D\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle D_{1}}\n  \n個值不為\n  \n    \n      \n        \n          \n            N\n            12\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{12}}}\n  \n及\n  \n    \n      \n        \n          \n            N\n            8\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{8}}}\n  \n的倍數，\n有\n  \n    \n      \n        \n          D\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle D_{2}}\n  \n個值為\n  \n    \n      \n        \n          \n            N\n            12\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{12}}}\n  \n及\n  \n    \n      \n        \n          \n            N\n            8\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{8}}}\n  \n的倍數，但不為\n  \n    \n      \n        \n          \n            N\n            4\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{4}}}\n  \n的倍數，\n則N點DFT的乘法量為：\n\n  \n    \n      \n        \n          \n            N\n            \n              2\n            \n          \n          \n            B\n            \n              1\n            \n          \n          +\n          \n            N\n            \n              1\n            \n          \n          \n            B\n            \n              2\n            \n          \n          +\n          3\n          \n            D\n            \n              1\n            \n          \n          +\n          2\n          \n            D\n            \n              2\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {N_{2}B_{1}+N_{1}B_{2}+3D_{1}+2D_{2}} }\n  \n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的快速傅立葉變換乘法量的計算", "Tag": "算法设计"}
{"Answer": "主条目：库利－图基快速傅里叶变换算法库利-图基算法是最常见的FFT算法。这一方法以分治法为策略递归地将长度为\n  \n    \n      \n        N\n        =\n        \n          N\n          \n            1\n          \n        \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N=N_{1}N_{2}}\n  \n的离散傅里叶变换分解为长度为\n  \n    \n      \n        \n          N\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle N_{1}}\n  \n的\n  \n    \n      \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N_{2}}\n  \n个较短序列的离散傅里叶变换，以及与\n  \n    \n      \n        \n          O\n        \n        (\n        N\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (N)}\n  \n个旋转因子的复数乘法。\n这种方法以及FFT的基本思路在1965年J. W. Cooley和J. W. Tukey合作发表An algorithm for the machine calculation of complex Fourier series之后开始为人所知。但后来发现，实际上这两位作者只是重新发明了高斯在1805年就已经提出的算法（此算法在历史上数次以各种形式被再次提出）。\n库利-图基算法最有名的应用，是将序列长为N 的DFT分割为两个长为N/2 的子序列的DFT，因此这一应用只适用于序列长度为2的幂的DFT计算，即基2-FFT。实际上，如同高斯和Cooley与Tukey都指出的那样，Cooley-Tukey算法也可以用于序列长度N 为任意因数分解形式的DFT，即混合基FFT，而且还可以应用于其他诸如分裂基FFT等变种。尽管Cooley-Tukey算法的基本思路是采用递归的方法进行计算，大多数传统的算法实现都将显式的递归算法改写为非递归的形式。另外，因为Cooley-Tukey算法是将DFT分解为较小长度的多个DFT，因此它可以同任一种其他的DFT算法联合使用。\n设计思想[编辑]下面，我们用N次单位根\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n来表示\n  \n    \n      \n        \n          e\n          \n            −\n            j\n            \n              \n                \n                  2\n                  π\n                \n                N\n              \n            \n          \n        \n      \n    \n    {\\displaystyle e^{-j{\\frac {2\\pi }{N}}}}\n  \n。\n\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n的性质：\n周期性，\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n具有周期\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n，即\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            N\n          \n        \n        =\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+N}=W_{N}^{k}}\n  \n\n对称性：\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+{\\frac {N}{2}}}=-W_{N}^{k}}\n  \n。\n若\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n的约数，\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            m\n            k\n            n\n          \n        \n        =\n        \n          W\n          \n            \n              N\n              m\n            \n          \n          \n            k\n            n\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{mkn}=W_{\\frac {N}{m}}^{kn}}\n  \n为了简单起见，我们下面设待变换序列长度\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            r\n          \n        \n      \n    \n    {\\displaystyle n=2^{r}}\n  \n。根据上面单位根的对称性，求级数\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          ∑\n          \n            n\n            =\n            0\n          \n          \n            N\n            −\n            1\n          \n        \n        \n          W\n          \n            N\n          \n          \n            k\n            n\n          \n        \n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{k}=\\sum _{n=0}^{N-1}W_{N}^{kn}x_{n}}\n  \n时，可以将求和区间分为两部分：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  y\n                  \n                    k\n                  \n                \n                =\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n                +\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                    +\n                    1\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                  \n                \n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                    +\n                    1\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  F\n                  \n                    e\n                    v\n                    e\n                    n\n                  \n                \n                (\n                k\n                )\n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  F\n                  \n                    o\n                    d\n                    d\n                  \n                \n                (\n                k\n                )\n              \n              \n              \n              \n              \n              \n              \n                (\n                i\n                ∈\n                \n                  Z\n                \n                )\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{matrix}y_{k}=\\sum _{n=2t}W_{N}^{kn}x_{n}+\\sum _{n=2t+1}W_{N}^{kn}x_{n}\\\\=\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t}+W_{N}^{k}\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t+1}\\\\=F_{even}(k)+W_{N}^{k}F_{odd}(k)&&&&&&(i\\in \\mathbb {Z} )\\end{matrix}}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n是两个分别关于序列\n  \n    \n      \n        \n          \n            {\n            \n              x\n              \n                n\n              \n            \n            }\n          \n          \n            0\n          \n          \n            N\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle \\left\\{x_{n}\\right\\}_{0}^{N-1}}\n  \n奇数号和偶数号序列N/2点变换。由此式只能计算出\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle y_{k}}\n  \n的前N/2个点，对于后N/2个点，注意\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n都是周期为N/2的函数，由单位根的对称性，于是有以下变换公式：\n\n  \n    \n      \n        \n          y\n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k+{\\frac {N}{2}}}=F_{even}(k)-W_{N}^{k}F_{odd}(k)}\n  \n\n\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        +\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k}=F_{even}(k)+W_{N}^{k}F_{odd}(k)}\n  \n。这样，一个N点变换就分解成了两个N/2点变换。照这样可继续分解下去。这就是库利-图基快速傅里叶变换算法的基本原理。根据主定理不难分析出此时算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        N\n        log\n        ⁡\n        N\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (N\\log N)}\n  \n\n算法实现[编辑]蝶形结网络和位反转（Bit Reversal）：首先将\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle n=2^{N}}\n  \n个输入点列按二进制进行编号，然后对各个编号按位倒置并按此重新排序。例如，对于一个8点变换，\n001倒置以后变成 100\n000 → 000\n001 → 100\n010 → 010\n011 → 110\n100 → 001\n101 → 101\n110 → 011\n111 → 111\n倒置后的编号为{0,4,2,6,1,5,3,7}。\n然后将这n个点列作为输入传送到蝶形结网络中，注意将因子\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k}}\n  \n逐层加入到蝶形网络中。算法复杂度[编辑]由于按蝶形结网络计算n点变换要进行log n层计算，每层计算n个点的变换，故算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (n\\log n)}\n  \n。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法", "Tag": "算法设计"}
{"Answer": "下面，我们用N次单位根\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n来表示\n  \n    \n      \n        \n          e\n          \n            −\n            j\n            \n              \n                \n                  2\n                  π\n                \n                N\n              \n            \n          \n        \n      \n    \n    {\\displaystyle e^{-j{\\frac {2\\pi }{N}}}}\n  \n。\n\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n的性质：\n周期性，\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n具有周期\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n，即\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            N\n          \n        \n        =\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+N}=W_{N}^{k}}\n  \n\n对称性：\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+{\\frac {N}{2}}}=-W_{N}^{k}}\n  \n。\n若\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n的约数，\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            m\n            k\n            n\n          \n        \n        =\n        \n          W\n          \n            \n              N\n              m\n            \n          \n          \n            k\n            n\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{mkn}=W_{\\frac {N}{m}}^{kn}}\n  \n为了简单起见，我们下面设待变换序列长度\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            r\n          \n        \n      \n    \n    {\\displaystyle n=2^{r}}\n  \n。根据上面单位根的对称性，求级数\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          ∑\n          \n            n\n            =\n            0\n          \n          \n            N\n            −\n            1\n          \n        \n        \n          W\n          \n            N\n          \n          \n            k\n            n\n          \n        \n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{k}=\\sum _{n=0}^{N-1}W_{N}^{kn}x_{n}}\n  \n时，可以将求和区间分为两部分：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  y\n                  \n                    k\n                  \n                \n                =\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n                +\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                    +\n                    1\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                  \n                \n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                    +\n                    1\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  F\n                  \n                    e\n                    v\n                    e\n                    n\n                  \n                \n                (\n                k\n                )\n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  F\n                  \n                    o\n                    d\n                    d\n                  \n                \n                (\n                k\n                )\n              \n              \n              \n              \n              \n              \n              \n                (\n                i\n                ∈\n                \n                  Z\n                \n                )\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{matrix}y_{k}=\\sum _{n=2t}W_{N}^{kn}x_{n}+\\sum _{n=2t+1}W_{N}^{kn}x_{n}\\\\=\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t}+W_{N}^{k}\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t+1}\\\\=F_{even}(k)+W_{N}^{k}F_{odd}(k)&&&&&&(i\\in \\mathbb {Z} )\\end{matrix}}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n是两个分别关于序列\n  \n    \n      \n        \n          \n            {\n            \n              x\n              \n                n\n              \n            \n            }\n          \n          \n            0\n          \n          \n            N\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle \\left\\{x_{n}\\right\\}_{0}^{N-1}}\n  \n奇数号和偶数号序列N/2点变换。由此式只能计算出\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle y_{k}}\n  \n的前N/2个点，对于后N/2个点，注意\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n都是周期为N/2的函数，由单位根的对称性，于是有以下变换公式：\n\n  \n    \n      \n        \n          y\n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k+{\\frac {N}{2}}}=F_{even}(k)-W_{N}^{k}F_{odd}(k)}\n  \n\n\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        +\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k}=F_{even}(k)+W_{N}^{k}F_{odd}(k)}\n  \n。这样，一个N点变换就分解成了两个N/2点变换。照这样可继续分解下去。这就是库利-图基快速傅里叶变换算法的基本原理。根据主定理不难分析出此时算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        N\n        log\n        ⁡\n        N\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (N\\log N)}\n  \n\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法的设计思想", "Tag": "算法设计"}
{"Answer": "蝶形结网络和位反转（Bit Reversal）：首先将\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle n=2^{N}}\n  \n个输入点列按二进制进行编号，然后对各个编号按位倒置并按此重新排序。例如，对于一个8点变换，\n001倒置以后变成 100\n000 → 000\n001 → 100\n010 → 010\n011 → 110\n100 → 001\n101 → 101\n110 → 011\n111 → 111\n倒置后的编号为{0,4,2,6,1,5,3,7}。\n然后将这n个点列作为输入传送到蝶形结网络中，注意将因子\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k}}\n  \n逐层加入到蝶形网络中。", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法的算法实现", "Tag": "算法设计"}
{"Answer": "由于按蝶形结网络计算n点变换要进行log n层计算，每层计算n个点的变换，故算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (n\\log n)}\n  \n。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法的算法复杂度", "Tag": "算法设计"}
{"Answer": "在Cooley-Tukey算法之外还有其他DFT的快速演算法。对于长度\n  \n    \n      \n        N\n        =\n        \n          N\n          \n            1\n          \n        \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N=N_{1}N_{2}}\n  \n且\n  \n    \n      \n        \n          N\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle N_{1}}\n  \n与\n  \n    \n      \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N_{2}}\n  \n互质的序列，可以采用基于中国剩余定理的互质因子算法将N长序列的DFT分解为两个子序列的DFT。与Cooley-Tukey算法不同的是，互质因子算法不需要旋转因子。\nRader-Brenner算法是类似于Cooley-Tukey算法，但是采用的旋转因子都是纯虚数，以增加加法运算和降低了数值稳定性为代价减少了乘法运算。这方法之后被split-radix variant of Cooley-Tukey所取代，与Rader-Brenner演算法相比，有一样多的乘法量，却有较少的加法量，且不牺牲数值的准确性。\nBruun以及QFT演算法是不断的把DFT分成许多较小的DFT运算。（Rader-Brenner以及QFT演算法是为了2的指数所设计的演算法，但依然可以适用在可分解的整数上。Bruun演算法则可以运用在可被分成偶数个运算的数字）。尤其是Bruun演算法，把FFT看成是\n  \n    \n      \n        \n          z\n          \n            N\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle z^{N}-1}\n  \n，并把它分解成\n  \n    \n      \n        \n          z\n          \n            M\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle z^{M-1}}\n  \n与\n  \n    \n      \n        \n          z\n          \n            2\n            M\n          \n        \n        +\n        a\n        \n          z\n          \n            M\n          \n        \n        +\n        1\n      \n    \n    {\\displaystyle z^{2M}+az^{M}+1}\n  \n的形式。\n另一个从多项式观点的快速傅立叶变换法是Winograd算法。此演算法把\n  \n    \n      \n        \n          z\n          \n            N\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle z^{N}-1}\n  \n分解成cyclotomic多项式，而这些多项式的系数通常为1，0，-1。这样只需要很少的乘法量（如果有需要的话），所以winograd是可以得到最少乘法量的快速傅立叶演算法，对于较小的数字，可以找出有效率的算方式。更精确地说，winograd演算法让DFT可以用\n  \n    \n      \n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle 2^{k}}\n  \n点的DFT来简化，但减少乘法量的同时，也增加了非常多的加法量。Winograd也可以利用剩余值定理来简化DFT。\nRader演算法提出了利用点数为N（N为质数）的DFT进行长度为N-1的回旋摺积来表示原本的DFT，如此就可利用摺积用一对基本的FFT来计算DFT。另一个prime-size的FFT演算法为chirp-Z演算法。此法也是将DFT用摺积来表示，此法与Rader演算法相比，能运用在更一般的转换上，其转换的基础为Z转换（Rabiner et al., 1969）。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的其他算法", "Tag": "算法设计"}
{"Answer": "在许多的运用当中，要进行DFT的资料是纯实数，如此一来经过DFT的结果会满足对称性：\n\n  \n    \n      \n        \n          \n            X\n          \n          \n            N\n            −\n            k\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {X} _{N-k}}\n  \n=\n  \n    \n      \n        \n          \n            X\n          \n          \n            k\n          \n          \n            ∗\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {X} _{k}^{*}}\n  \n而有一些演算法是专门为这种情形设计的（e.g. Sorensen, 1987）。另一些则是利用旧有的演算法（e.g. Cooley-Tukey），删去一些不必要的演算步骤，如此省下了记忆体的使用，也省下了时间。另一方面，也可以把一个偶数长度且纯实数的DFT，用长度为原本一半的复数型态DFT来表示（实数项为原本纯实数资料的偶数项，虚数项则为奇数项）。\n在Matlab上用一次N點FFT計算兩個N點實數信號x,y的FFT:\nfunction [X,Y] = Real2FFT( x,y )\n\n% N-point FFT is used for 2 real signals both with length N\n\nN = length(x);\n\nz = x+y*i ;\n\nZ = fft(z);\n\nX = 0.5*(Z+conj(Z(1+mod(0:-1:1-N,N))));\n\nY = 0.5*(Z-conj(Z(1+mod(0:-1:1-N,N))))/i;\n\nend\n一度人们认为，用离散哈特利转换（Discrete Hartley Transform）来处理纯实数的DFT会更有效率，但接着人们发现，对于同样点数的纯实数DFT，经过设计的FFT，可以比DHT省下更多的运算。Bruun演算法是第一个试着从减少实数输入的DFT运算量的演算法，但此法并没有成为人们普遍使用的方法。\n对于实数输入，且输入为偶对称或奇对称的情形，可以更进一步的省下时间以及记忆体，此时DFT可以用离散余弦转换或离散正弦转换来代替（Discrete cosine/sine transforms）。由于DCT/DST也可以设计出FFT的演算法，故在此种情形下，此方法取代了对DFT设计的FFT演算法。\nDFT可以应用在频谱分析以及做摺积的运算，而在此处，不同应用可以用不同的演算法来取代，列表如下：\n用来做频谱分析的情况下，DFT可用下列的演算法代替：\nDCT\nDST\nDHT\n正交基底的扩展（orthogonal basis expantion）包括正交多项式（orthogonal polynomials）以及CDMA.\nWalsh（Hadamard）转换\nHaar转换\n小波（wavelet）转换\n时频分布（time-frequency distribution）用来做摺积的情况下，DFT可用下列的演算法代替：\nDCT\nDST\nDHT\n直接做摺积（direct computing）\n分段式DFT摺积（sectioned DFT convolution）\n威諾格拉德快速傅立葉變換演算法\n沃尔什（Walsh、Hadamard）转换\n数论转换", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的实数或对称资料专用的演算法", "Tag": "算法设计"}
{"Answer": "長久以來，人們對於求出快速傅立葉變換的複雜度下限以及需要多少的運算量感到很有興趣，而實際上也還有許多問題需要解決。即使是用較簡單的情形，即\n  \n    \n      \n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle 2^{k}}\n  \n點的DFT，也還沒能夠嚴謹的證明出FFT至少需要\n  \n    \n      \n        Ω\n        (\n        N\n        log\n        ⁡\n        N\n        )\n      \n    \n    {\\displaystyle \\Omega (N\\log N)}\n  \n（不比\n  \n    \n      \n        N\n        log\n        ⁡\n        N\n      \n    \n    {\\displaystyle N\\log N}\n  \n小）的運算量，目前也沒有發現複雜度更低的演算法。通常數學運算量的多寡會是運算效率好壞最主要的因素，但在現實中，有許多因素也會有很大的影響，如快取記憶體以及CPU均有很大的影響。\n在1978年，Winograd率先導出一個較嚴謹的FFT所需乘法量的下限：\n  \n    \n      \n        Θ\n        (\n        N\n        )\n      \n    \n    {\\displaystyle \\Theta (N)}\n  \n。當\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n時，DFT只需要\n  \n    \n      \n        4\n        N\n        −\n        2\n        \n          log\n          \n            2\n          \n          \n            2\n          \n        \n        ⁡\n        N\n        −\n        2\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n        −\n        4\n      \n    \n    {\\displaystyle 4N-2\\log _{2}^{2}N-2\\log _{2}N-4}\n  \n次無理實數的乘法即可以計算出來。更詳盡，且也能趨近此下限的演算法也一一被提出（Heideman & Burrus, 1986; Duhamel, 1990）。很可惜的是，這些演算法，都需要很大量的加法計算，目前的硬體無法克服這個問題。\n對於所需加法量的數目，雖然我們可以在某些受限制的假設下，推得其下限，但目前並沒有一個精確的下限被推導出來。1973年，Morgenstern在乘法常數趨近巨大的情形下（對大部分的FFT演算法為真，但不是全部）推導出加法量的下限：\n  \n    \n      \n        Ω\n        \n          (\n          \n            N\n            log\n            ⁡\n            N\n          \n          )\n        \n      \n    \n    {\\displaystyle \\Omega \\left(N\\log N\\right)}\n  \n。Pan（1986）在假設FFT演算法的不同步的情形有其極限下證明出加法量的下限\n  \n    \n      \n        Ω\n        (\n        N\n        l\n        o\n        g\n        N\n        )\n      \n    \n    {\\displaystyle \\Omega (NlogN)}\n  \n，但一般來說，此假設相當的不明確。長度為\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n的情形下，在某些假設下，Papadimitriou（1979）提出使用Cooley-Tukey演算法所需的複數加法量\n  \n    \n      \n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n      \n    \n    {\\displaystyle N\\log _{2}N}\n  \n是最少的。到目前為止，在長度為\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n情況，還沒有任何FFT的演算法可以讓複數的加法量比\n  \n    \n      \n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n      \n    \n    {\\displaystyle N\\log _{2}N}\n  \n還少。\n還有一個問題是如何把乘法量與加法量的總和最小化，有時候稱作\"演算複雜度\"（在這裡考慮的是實際的運算量，而不是漸近複雜度）。同樣的，沒有一個嚴謹下限被證明出來。從1968年開始，\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n點DFT而言，split-radix FFT演算法需要最少的運算量，在\n  \n    \n      \n        N\n        >\n        1\n      \n    \n    {\\displaystyle N>1}\n  \n的情形下，其需要\n  \n    \n      \n        4\n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n        −\n        6\n        N\n        +\n        8\n      \n    \n    {\\displaystyle 4N\\log _{2}N-6N+8}\n  \n個乘法運算以及加法運算。最近有人導出更低的運算量：\n  \n    \n      \n        \n          \n            34\n            9\n          \n        \n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n      \n    \n    {\\displaystyle {\\frac {34}{9}}N\\log _{2}N}\n  \n。（Johnson and Frigo, 2007; Lundy and Van Buskirk, 2007）\n大多數嘗試要降低或者證明FFT複雜度下限的人都把焦點放在複數資料輸入的情況，因其為最簡單的情形。但是，複數資料輸入的FFT演算法，與實數資料輸入的FFT演算法，離散餘弦轉換（DCT），離散哈特列轉換（DHT），以及其他的演算法，均有很大的關連性。故任何一個演算法，在複雜度上有任何的改善的話，其他的演算法複雜度也會馬上獲得改善（Duhamel & Vetterli, 1990）。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的複雜度以及運算量的極限", "Tag": "算法设计"}
{"Answer": "當輸入信號長度為N時:\nN = 1~60\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的快速演算法查表", "Tag": "算法设计"}
{"Answer": "离散傅里叶变换\n并行快速傅里叶变换\n快速數論變換", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的参阅", "Tag": "算法设计"}
{"Answer": "\n\n^ 杨毅明. 数字信号处理（第2版）. 北京: 机械工业出版社. 2017年: 第95页. ISBN 9787111576235. \n\n^ Charles Van Loan, Computational Frameworks for the Fast Fourier Transform (SIAM, 1992).\n\n^ Heideman, M. T.; Johnson, D. H.; Burrus, C. S. Gauss and the history of the fast Fourier transform. IEEE ASSP Magazine. 1984, 1 (4): 14–21. doi:10.1109/MASSP.1984.1162257. \n\n^ Strang, Gilbert. Wavelets. American Scientist. May–June 1994, 82 (3): 253. JSTOR 29775194. \n\n^ Dongarra, J.; Sullivan, F. Guest Editors Introduction to the top 10 algorithms. Computing in Science Engineering. January 2000, 2 (1): 22–23. ISSN 1521-9615. doi:10.1109/MCISE.2000.814652. \n\n^ Johnson and Frigo, 2007\n\n^ Frigo & Johnson, 2005\n\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的参考资料", "Tag": "算法设计"}
{"Answer": "\nBrenner, N.; Rader, C. A New Principle for Fast Fourier Transformation. IEEE Acoustics, Speech & Signal Processing. 1976, 24 (3): 264–266. doi:10.1109/TASSP.1976.1162805. \nBrigham, E. O. The Fast Fourier Transform. New York: Prentice-Hall. 2002. \nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. 30. (Polynomials and the FFT). Introduction to Algorithms 2. MIT Press and McGraw-Hill. 2001. ISBN 0-262-03293-7. \nDuhamel, Pierre. Algorithms meeting the lower bounds on the multiplicative complexity of length-2n DFTs and their connection with practical algorithms. IEEE Trans. Acoust. Speech. Sig. Proc. 1990, 38 (9): 1504–151. doi:10.1109/29.60070. \nDuhamel, P.; Vetterli, M. Fast Fourier transforms: a tutorial review and a state of the art. Signal Processing. 1990, 19: 259–299. doi:10.1016/0165-1684(90)90158-U. \nEdelman, A.; McCorquodale, P.; Toledo, S. The Future Fast Fourier Transform?. SIAM J. Sci. Computing. 1999, 20: 1094–1114. doi:10.1137/S1064827597316266. \nD. F. Elliott, & K. R. Rao, 1982, Fast transforms: Algorithms, analyses, applications. New York: Academic Press.\nFunda Ergün, 1995, Testing multivariate linear functions: Overcoming the generator bottleneck, Proc. 27th ACM Symposium on the Theory of Computing: 407–416.\nFrigo, M.; Johnson, S. G. The Design and Implementation of FFTW3 (PDF). Proceedings of the IEEE. 2005, 93: 216–231  [2008-06-22]. doi:10.1109/jproc.2004.840301. （原始内容存档 (PDF)于2019-07-16）. \nH. Guo and C. S. Burrus, 1996, Fast approximate Fourier transform via wavelets transform, Proc. SPIE Intl. Soc. Opt. Eng. 2825: 250–259.\nH. Guo, G. A. Sitton, C. S. Burrus, 1994, The Quick Discrete Fourier Transform, Proc. IEEE Conf. Acoust. Speech and Sig. Processing (ICASSP) 3: 445–448.\nSteve Haynal and Heidi Haynal, \"Generating and Searching Families of FFT Algorithms\", Journal on Satisfiability, Boolean Modeling and Computation vol. 7, pp. 145–187 (2011).\nHeideman, Michael T.; Burrus, C. Sidney. On the number of multiplications necessary to compute a length-2n DFT. IEEE Trans. Acoust. Speech. Sig. Proc. 1986, 34 (1): 91–95. doi:10.1109/TASSP.1986.1164785. \nJohnson, S. G.; Frigo, M. A modified split-radix FFT with fewer arithmetic operations (PDF). IEEE Trans. Signal Processing. 2007, 55 (1): 111–119  [2008-06-22]. doi:10.1109/tsp.2006.882087. （原始内容存档 (PDF)于2021-02-25）. \nT. Lundy and J. Van Buskirk, 2007. \"A new matrix approach to real FFTs and convolutions of length 2k,\" Computing 80 (1): 23–45.\nKent, Ray D. and Read, Charles (2002). Acoustic Analysis of Speech. ISBN 978-0-7693-0112-9. Cites Strang, G. (1994)/May–June). Wavelets. American Scientist, 82, 250–255.\nMorgenstern, Jacques. Note on a lower bound of the linear complexity of the fast Fourier transform. J. ACM. 1973, 20 (2): 305–306. doi:10.1145/321752.321761. \nMohlenkamp, M. J. A fast transform for spherical harmonics (PDF). J. Fourier Anal. Appl. 1999, 5 (2–3): 159–184. doi:10.1007/BF01261607. （原始内容 (PDF)存档于2007年2月6日）. \nNussbaumer, H. J. Digital filtering using polynomial transforms. Electronics Lett. 1977, 13 (13): 386–387. doi:10.1049/el:19770280. \nV. Pan, 1986, The trade-off between the additive complexity and the asyncronicity of linear and bilinear algorithms, Information Proc. Lett. 22: 11–14.\nChristos H. Papadimitriou, 1979, Optimality of the fast Fourier transform, J. ACM 26: 95–102.\nD. Potts, G. Steidl, and M. Tasche, 2001. \"Fast Fourier transforms for nonequispaced data: A tutorial\", in: J.J. Benedetto and P. Ferreira (Eds.), Modern Sampling Theory: Mathematics and Applications (Birkhauser).\nPress, W.H.; Teukolsky, S.A.; Vetterling, W.T.; Flannery, B.P., Chapter 12. Fast Fourier Transform, Numerical Recipes: The Art of Scientific Computing 3, New York: Cambridge University Press, 2007  [2015-12-11], ISBN 978-0-521-88068-8, （原始内容存档于2011-08-11） \nRokhlin, Vladimir; Tygert, Mark. Fast algorithms for spherical harmonic expansions. SIAM J. Sci. Computing. 2006, 27 (6): 1903–1928. doi:10.1137/050623073. \nSchatzman, James C. Accuracy of the discrete Fourier transform and the fast Fourier transform. SIAM J. Sci. Comput. 1996, 17: 1150–1166. doi:10.1137/s1064827593247023. \nShentov, O. V.; Mitra, S. K.; Heute, U.; Hossen, A. N. Subband DFT. I. Definition, interpretations and extensions. Signal Processing. 1995, 41 (3): 261–277. doi:10.1016/0165-1684(94)00103-7. \nSorensen, H. V.; Jones, D. L.; Heideman, M. T.; Burrus, C. S. Real-valued fast Fourier transform algorithms. IEEE Trans. Acoust. Speech Sig. Processing. 1987, 35 (35): 849–863. doi:10.1109/TASSP.1987.1165220.  See also Sorensen, H.; Jones, D.; Heideman, M.; Burrus, C. Corrections to \"Real-valued fast Fourier transform algorithms\". IEEE Transactions on Acoustics, Speech, and Signal Processing. 1987, 35 (9): 1353–1353. doi:10.1109/TASSP.1987.1165284. \nWelch, Peter D. A fixed-point fast Fourier transform error analysis. IEEE Trans. Audio Electroacoustics. 1969, 17 (2): 151–157. doi:10.1109/TAU.1969.1162035. \nWinograd, S. On computing the discrete Fourier transform. Math. Computation. 1978, 32 (141): 175–199. JSTOR 2006266. doi:10.1090/S0025-5718-1978-0468306-4. \n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的延伸阅读", "Tag": "算法设计"}
{"Answer": "在图论和理论计算机科学中，最长路径问题是指在给定的图中找出长度最长的道路。一条不具有任何重复顶点的路径被称为简单路径。无权图中路径的长度就是边的数量，而有权图中路径长度是边权重之和。不同的是，与此相反的最短路径问题（不含负权环）可以在多项式时间内解决。而最长路径问题是NP困难的，这意味着除非P = NP，否则对应于任意的图，没有办法在多项式时间内解决该问题。更强的结果表明这个问题也難以近似地得出答案。但是，有一个线性时间的方法可以用于有向无环图，这对于发现调度问题中的关键路径有重要的作用。\n", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题", "Tag": "算法设计"}
{"Answer": "可以从哈密顿路径问题规约到未加权最长路径问题，这显示出后者屬於NP-困难類別：当且仅当图G的最长路径的长度是n−1时（n是圖中顶点的数量），图G有哈密顿路径。 由于哈密顿路径问题是NP完全的，此规约表明最长路径问题的决定版本也是NP完全的。在该决定问题中，输入是图G和数k；如果G中存在至少一條由k条或更多条边的路径，则输出为“是”，否则为“否”。[1]\n如果可以在多项式时间内解决最长路径问题，则可以通过找到最长路径，然后将其长度与数k进行比较来将其用于解决该决定问题。因此，最长的路径问题是NP难的。问题“在给定图中是否存在具有至少k条边的简单路径”是NP完全的。[2]\n在具有非负边权的加权完全图中，加权最长路径问题与旅行推销员问题相同，因为最长路径总是包括所有顶点。[3]\n", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的NP-困难性", "Tag": "算法设计"}
{"Answer": "在加权图G中两个给定顶点s和t之间的最长路径，与通过将G中每个权重改变为其相反数所导出的图-G中的最短路径相同。因此，如果在-G中找到最短路径，则在G中也可以找到最长路径。[4]\n对于大多数图而言，此变换并无用途，因为它在-G中产生了负环。但是如果G是有向无环图（DAG），则不会有负环，并且通过对-G中的最短路径应用线性时间算法，可以在线性时间里找到G的最长路径，因-G也是有向无环图。[5]\n对于给定DAG中的每个顶点v，可以通过以下步骤获得以v结尾的最长路径的长度：\n找到给定DAG的拓扑排序。\n对于DAG的每个顶点v，在拓扑排序中，通过检查连入的邻接点，并将这一个邻接点记录的最大长度加1来计算以v结尾的最长路径的长度。如果v没有连入的邻接点，则将以v结尾的最长路径的长度设置为零。在所有情况下，记录下这个数，以便算法的后续步骤访问它。完成此操作后，可以从记录值最大的顶点v开始，然后向后找记录值最大的连入邻接点，最后反转这条路径就是结果。这和在-G上运行最短路算法等价。\n关键路径[编辑]关键路径方法是進行工程項目計劃時常用的一種估算項目所需時間的方法。使用時，需要构造有向无环图，其中顶点表示项目里程碑，边表示達到某一个里程碑之后，要通向另一个里程碑所必須的活动；通过估计完成相应活动将花费的时间，算出每条边的边权。在这样的图中，从第一个里程碑到最后一个里程碑的最长路径是关键路径，它描述了完成项目的总时间。[5]\n有向无环图的最长路径也可以用于分层图绘制（英语：layered graph drawing）：将有向无环图G的每个顶点v分到层数是以v结尾的最长路径长度的层，这种层分配使G的层数最小。[6]\n", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的无环图", "Tag": "算法设计"}
{"Answer": "关键路径方法是進行工程項目計劃時常用的一種估算項目所需時間的方法。使用時，需要构造有向无环图，其中顶点表示项目里程碑，边表示達到某一个里程碑之后，要通向另一个里程碑所必須的活动；通过估计完成相应活动将花费的时间，算出每条边的边权。在这样的图中，从第一个里程碑到最后一个里程碑的最长路径是关键路径，它描述了完成项目的总时间。[5]\n有向无环图的最长路径也可以用于分层图绘制（英语：layered graph drawing）：将有向无环图G的每个顶点v分到层数是以v结尾的最长路径长度的层，这种层分配使G的层数最小。[6]\n", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的无环图的关键路径", "Tag": "算法设计"}
{"Answer": "迪杰斯特拉在20世纪60年代提出了一种用于在树中找到最长路径的线性时间算法，而该算法的正式证明于2002年出版。[7]此外，最长路径可以在加权树上，块图（英语：Block graph）上，仙人掌图（英语：Cactus graph）上，[8]二分置换图（英语：Permutation graph）上，[9]和托勒密图（英语：Ptolemaic graph）上[10]以多项式时间计算。\n对于区间图（英语：Interval graph），已知 \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            4\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{4})}\n  \n时间的算法，其使用动态规划方法。[11]这种动态规划方法已被用于获得Circular-arc 图（英语：Circular-arc graph）[12]和可比性补图（即可比性图（英语：Comparability graph）的补图，也包含置换图（英语：Permutation graph））[13]的多项式时间算法，两者具有相同的运行时间 \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            4\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{4})}\n  \n。后一种算法基于可比性补图的词典深度优先搜索（LDFS）顶点排序的特殊属性。[14]对于共同可比性图，还已知有较高运行时间 \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            7\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{7})}\n  \n的另一种多项式时间算法，其基于由输入的可比性补图的补图定义的偏序关系的哈斯图。[15]\n此外，最长路径问题可以在树宽有界或团宽有界的任何图上在多项式时间内解决，例如距离-遗传图（英语：Distance-hereditary graph）。最后，在哈密顿路径问题是NP难的所有图上显然最长路径问题也是NP难的，例如在分割图（英语：Split graph），圆图（英语：Circle graph）和平面图上。\n", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的图的特例", "Tag": "算法设计"}
{"Answer": "当通过路径长度参数化时，最长路径问题是固定参数易处理的。例如，可以通过执行以下步骤的算法，以输入图大小的线性时间求解最长路径问题（但对于路径长度呈指数时间）：\n对图进行深度优先搜索。设\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n是得到的深度优先搜索树（英语：Trémaux tree）的深度。\n使用深度优先搜索树的根到叶路径的顺序，按照搜索遍历的顺序，构建图的路径分解（英语：Pathwidth），路径宽度为\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n。\n将动态规划应用于此路径分解以找到最长的路径 ，时间是\n  \n    \n      \n        O\n        (\n        d\n        !\n        \n          2\n          \n            d\n          \n        \n        n\n        )\n      \n    \n    {\\displaystyle O(d!2^{d}n)}\n  \n，其中\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n是图中顶点的数量。由于输出路径的长度至少与\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n一样大，因此运行时间也受 \n  \n    \n      \n        O\n        (\n        ℓ\n        !\n        \n          2\n          \n            ℓ\n          \n        \n        n\n        )\n      \n    \n    {\\displaystyle O(\\ell !2^{\\ell }n)}\n  \n的限制，其中\n  \n    \n      \n        ℓ\n      \n    \n    {\\displaystyle \\ell }\n  \n是最长路径的长度。[16]\n", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的参数化复杂性", "Tag": "算法设计"}
{"Answer": "Gallai-Hasse-Roy-Vitaver定理（英语：Gallai–Hasse–Roy–Vitaver theorem），最长路径与图着色的对偶关系\n最长无交叉骑士路径（英语：Longest uncrossed knight's path）\n盒中蛇（英语：Snake-in-the-box）问题中，超立方体图（英语：Hypercube graph）中的最长诱导路径（英语：Induced path）", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的参见", "Tag": "算法设计"}
{"Answer": "\n^ Schrijver, Alexander, Combinatorial Optimization: Polyhedra and Efficiency, Volume 1, Algorithms and Combinatorics 24, Springer: 114, 2003, ISBN 9783540443896 .\n\n^ Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford, Introduction To Algorithms 2nd, MIT Press: 978, 2001, ISBN 9780262032933 .\n\n^ Lawler, Eugene L., Combinatorial Optimization: Networks and Matroids, Courier Dover Publications: 64, 2001, ISBN 9780486414539 .\n\n^ 王建新; 杨志彪; 陈建二. 最长路径问题研究进展. 计算机科学. 2010-03-02, 36 (12): 1-4,31  [2022-08-15]. doi:10.3969/j.issn.1002-137X.2009.12.001. \n\n^ 5.0 5.1 Sedgewick, Robert; Wayne, Kevin Daniel, Algorithms 4th, Addison-Wesley Professional: 661–666, 2011, ISBN 9780321573513 .\n\n^ Di Battista, Giuseppe; Eades, Peter; Tamassia, Roberto; Tollis, Ioannis G., Layered Drawings of Digraphs, Graph Drawing: Algorithms for the Visualization of Graphs, Prentice Hall: 265–302, 1998, ISBN 978-0-13-301615-4 .\n\n^ Bulterman, R.W.; van der Sommen, F.W.; Zwaan, G.; Verhoeff, T.; van Gasteren, A.J.M., On computing a longest path in a tree, Information Processing Letters, 2002, 81 (2): 93–96, doi:10.1016/S0020-0190(01)00198-3 .\n\n^ Uehara, Ryuhei; Uno, Yushi, Efficient algorithms for the longest path problem, Isaac 2004, Lecture Notes in Computer Science, 2004, 3341: 871–883, ISBN 978-3-540-24131-7, doi:10.1007/978-3-540-30551-4_74 .\n\n^ Uehara, Ryuhei; Valiente, Gabriel, Linear structure of bipartite permutation graphs and the longest path problem, Information Processing Letters, 2007, 103 (2): 71–77, CiteSeerX 10.1.1.101.96 , doi:10.1016/j.ipl.2007.02.010 .\n\n^ Takahara, Yoshihiro; Teramoto, Sachio; Uehara, Ryuhei, Longest path problems on Ptolemaic graphs, IEICE Transactions, 2008, 91–D (2): 170–177, doi:10.1093/ietisy/e91-d.2.170  .\n\n^ Ioannidou, Kyriaki; Mertzios, George B.; Nikolopoulos, Stavros D., The longest path problem has a polynomial solution on interval graphs, Algorithmica, 2011, 61 (2): 320–341, CiteSeerX 10.1.1.224.4927 , S2CID 7577817, doi:10.1007/s00453-010-9411-3 .\n\n^ Mertzios, George B.; Bezakova, Ivona, Computing and counting longest paths on circular-arc graphs in polynomial time, Discrete Applied Mathematics, 2014, 164 (2): 383–399, CiteSeerX 10.1.1.224.779 , doi:10.1016/j.dam.2012.08.024 .\n\n^ Mertzios, George B.; Corneil, Derek G., A simple polynomial algorithm for the longest path problem on cocomparability graphs, SIAM Journal on Discrete Mathematics, 2012, 26 (3): 940–963, S2CID 4645245, arXiv:1004.4560 , doi:10.1137/100793529 .\n\n^ Corneil, Derek G.; Krueger, Richard, A unified view of graph searching, SIAM Journal on Discrete Mathematics, 2008, 22 (4): 1259–1276, doi:10.1137/050623498 .\n\n^ Ioannidou, Kyriaki; Nikolopoulos, Stavros D., The longest path problem is polynomial on cocomparability graphs (PDF), Algorithmica, 2011, 65: 177–205  [2022-08-15], CiteSeerX 10.1.1.415.9996 , S2CID 7271040, doi:10.1007/s00453-011-9583-5, （原始内容存档 (PDF)于2022-08-15） .\n\n^ Bodlaender, Hans L., On linear time minor tests with depth-first search, Journal of Algorithms, 1993, 14 (1): 1–23, MR 1199244, doi:10.1006/jagm.1993.1001 . For an earlier FPT algorithm with slightly better dependence on the path length, but worse dependence on the size of the graph, see Monien, B., How to find long paths efficiently, Analysis and design of algorithms for combinatorial problems (Udine, 1982), North-Holland Math. Stud. 109, Amsterdam: North-Holland: 239–254, 1985, ISBN 9780444876997, MR 0808004, doi:10.1016/S0304-0208(08)73110-4 .\n\n", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的参考文献", "Tag": "算法设计"}
{"Answer": "\"Find the Longest Path （页面存档备份，存于互联网档案馆）\", song by Dan Barrett", "Konwledge_Point": "最长路径问题", "Question": "什么是最长路径问题的外部链接", "Tag": "算法设计"}
{"Answer": "模算數或稱同餘運算（英語：Modular arithmetic）是一個整数的算术系統，其中數字超過一定值後（稱為模/餘數）後會「捲回」到較小的數值，模算數最早是出現在卡爾·弗里德里希·高斯在1801年出版的《算术研究》一書中。\n模算數常見的應用是在十二小時制，將一天分為二個以十二小時計算的單位。假設現在七點，八小時後會是三點。用一般的算術加法，會得到7 + 8 = 15，但在十二小時制中，超過十二小時會歸零，不存在「十五點」。類似的情形，若時鐘目前是十二時，二十一小時後會是九點，而不是三十三點。小時數超過十二後會再回到一，為模12的模算數系統。依照上述的定義，12和12本身同餘，也和0同餘，因此12:00的時間也可以稱為是0:00，因為模12時，12和0同餘。\n", "Konwledge_Point": "模算數", "Question": "什么是模算數", "Tag": "算法设计"}
{"Answer": "  此章节介紹的是mod n的表示法。关于二元的mod運算，请见「模除」。模算數可以在導入整數的同餘關係後，通过经典算数的运算法则来推导模运算的运算法则。若有两个正整数\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n和\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n，并且二數的差值\n  \n    \n      \n        a\n        −\n        b\n      \n    \n    {\\displaystyle a-b}\n  \n為\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的整數倍數，我们就可以说\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n和\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n在模\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n下同餘。数学式表达为：[1]\n\n  \n    \n      \n        a\n        ≡\n        b\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n        \n      \n    \n    {\\displaystyle a\\equiv b{\\pmod {n}}\\,}\n  \n例如\n\n  \n    \n      \n        38\n        ≡\n        14\n        \n          \n          (\n          mod\n          \n          12\n          )\n        \n        \n      \n    \n    {\\displaystyle 38\\equiv 14{\\pmod {12}}\\,}\n  \n因為38 − 14 = 24，是12的倍數。\n上述的概念也對負數有效：\n\n  \n    \n      \n        \n          \n            \n              \n                −\n                8\n              \n              \n                \n                ≡\n                7\n                \n                  \n                  (\n                  mod\n                  \n                  5\n                  )\n                \n              \n            \n            \n              \n                2\n              \n              \n                \n                ≡\n                −\n                3\n                \n                  \n                  (\n                  mod\n                  \n                  5\n                  )\n                \n              \n            \n            \n              \n                −\n                3\n              \n              \n                \n                ≡\n                −\n                8\n                \n                  \n                  (\n                  mod\n                  \n                  5\n                  )\n                \n                .\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}-8&\\equiv 7{\\pmod {5}}\\\\2&\\equiv -3{\\pmod {5}}\\\\-3&\\equiv -8{\\pmod {5}}.\\end{aligned}}}\n  \n而同餘關係也可以用計算带余除法中的余数来理解。若正整数\n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n和\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n在除以\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n后的余数相同，\n  \n    \n      \n        a\n        ≡\n        b\n        \n          mod\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle a\\equiv b{\\bmod {m}}}\n  \n。例如：\n\n  \n    \n      \n        38\n        ≡\n        14\n        \n          \n          (\n          mod\n          \n          12\n          )\n        \n        \n      \n    \n    {\\displaystyle 38\\equiv 14{\\pmod {12}}\\,}\n  \n因為38和14除以12時，餘數都為2。這是因為38 − 14 = 24是12的整數倍。\n", "Konwledge_Point": "模算數", "Question": "什么是模算數的同餘關係", "Tag": "算法设计"}
{"Answer": "如果\n  \n    \n      \n        a\n        ≡\n        b\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle a\\equiv b{\\pmod {n}}}\n  \n，\n  \n    \n      \n        p\n        ≡\n        q\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle p\\equiv q{\\pmod {n}}}\n  \n，\n  \n    \n      \n        c\n      \n    \n    {\\displaystyle c}\n  \n为任何正整数，\n那么我们有以下运算定律：[2]\n\n  \n    \n      \n        a\n        +\n        c\n        ≡\n        b\n        +\n        c\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle a+c\\equiv b+c{\\pmod {n}}}\n  \n\n\n  \n    \n      \n        a\n        −\n        c\n        ≡\n        b\n        −\n        c\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle a-c\\equiv b-c{\\pmod {n}}}\n  \n\n\n  \n    \n      \n        a\n        c\n        ≡\n        b\n        c\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle ac\\equiv bc{\\pmod {n}}}\n  \n\n\n  \n    \n      \n        \n          a\n          \n            c\n          \n        \n        ≡\n        \n          b\n          \n            c\n          \n        \n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle a^{c}\\equiv b^{c}{\\pmod {n}}}\n  \n\n\n  \n    \n      \n        a\n        +\n        p\n        ≡\n        b\n        +\n        q\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle a+p\\equiv b+q{\\pmod {n}}}\n  \n\n\n  \n    \n      \n        a\n        p\n        ≡\n        b\n        q\n        \n          \n          (\n          mod\n          \n          n\n          )\n        \n      \n    \n    {\\displaystyle ap\\equiv bq{\\pmod {n}}}\n  \n综上所述，我们在模算数里可以使用除除法以外的任何四则运算\n", "Konwledge_Point": "模算數", "Question": "什么是模算數的运算定律", "Tag": "算法设计"}
{"Answer": "模算數在数论、群论、环论、紐結理論、抽象代数、電腦代數（英语：computer algebra）、密码学、计算机科学及化學中都有使用[3]，也出現在視覺藝術及音乐。\n模算數是数论的基礎之一，也提供了群论、环论及抽象代数中一些重要的範例。\n模算數也常作為識別碼的校验码。例如国际银行账户号码（IBAN）就用模97的餘數來避免輸入編號時的錯誤。\n在密碼學中，模算數是 RSA及迪菲-赫爾曼等公开密钥加密系統的基礎，也提到了和 椭圆曲线有關的有限域，用在許多的对称密钥算法中，包括高级加密标准（AES）、國際資料加密演算法（IDEA）、及RC4。RSA和迪菲-赫爾曼密鑰交換用到了模冪。\n在電腦代數中，模算數常用來限制中間計算的整數係數大小，也限制計算中用到的資料。模算數用在多項式分解（英语：polynomial factorization）中（其中所有已知有效率的演算法都用到了模算數），而針對整數及有理數的多項式最大公因式（英语：polynomial greatest common divisor）、线性代数及Gröbner基（英语：Gröbner basis），最有效率解法都用到了模算數。\n計算機科學中，模算數會以位操作的方式表示，也和其他定長度、循環式的数据结构有關。許多编程语言及计算器中都有模除，而XOR是二個位元在模2下的和。\n化學中，表示化合物編號的CAS号，最後一碼是校验码，是將CAS号前二位數乘以1、下一位乘以2，再下一位乘以3……，最後對10取餘數而得。\n音樂上，模12的模算數用在十二平均律的系統中，其中有純八度及異名同音的情形（，例如升音符的C音和降音符的D音會視為是同一個音）。\n去九法是徒手計算時快速的檢查工具，是以模9的模算數為基礎，而且其中最重要的性質是 10 ≡ 1 (mod 9)。\n模7的模算數在許多計算特定日期是星期幾的演算法中出現，特別是蔡勒公式及判决日法则（英语：doomsday algorithm）中。\n模算數也用在像法律（像分配數（英语：Apportionment (politics)））、经济学（像博弈论），若一些社会科学的分析會強調資源的比例分割（英语：Proportional (fair division)）及分配，也會用到模算數。\n", "Konwledge_Point": "模算數", "Question": "什么是模算數的應用", "Tag": "算法设计"}
{"Answer": "\n\n^ Emanuel Lazar. Math 170 lecture notes (PDF). UPenn: 73. April 30, 2016  [2021-10-23]. （原始内容存档 (PDF)于2021-10-23）. \n\n^ Sandor Lehoczky; Richard Rusczky. David Patrick , 编. the Art of Problem Solving Vol. 1 7. : 44. ISBN 0977304566 （英语）. \n\n^ Sharky Kesa;  et al. Modular Arithmetic. Brillant.   [2021-10-23]. （原始内容存档于2021-10-26）.  引文格式1维护：显式使用等标签 (link)\n\n", "Konwledge_Point": "模算數", "Question": "什么是模算數的參考資料", "Tag": "算法设计"}
{"Answer": "\n布尔环\n環形緩衝區\n同餘關係\n除法\n有限域\n勒让德符号\n模冪\n模反元素\n模除\n数论\n皮萨诺周期（模n下的斐波那契序列）\n原根\n二次互反律\n二次剩余\n两元素布尔代数\n和模算數有關的群論主題：\n循環群\n整数模n乘法群\n其他和模算數有關的重要定理：\n卡邁克爾函數\n中国剩余定理\n欧拉定理 (数论)\n费马小定理\n拉格朗日定理 (群論)\n", "Konwledge_Point": "模算數", "Question": "什么是模算數的相關條目", "Tag": "算法设计"}
{"Answer": "外蒙古独立（蒙古語：Үндэсний эрх чөлөөний хувьсгал，也称为「蒙古民族革命」）是指外蒙古地区于20世纪上半葉脫離中国獨立成为主权国家的历史事件[1]。外蒙古包括今日蒙古国以及圖瓦地区，蒙古国是国际社会广泛承认的独立主权国家，而唐努乌梁海（今图瓦共和国）地区则被俄罗斯控制。自辛亥革命清朝崩潰后，外蒙古實際處於獨立狀態。1921年在蘇聯紅軍的介入下，中華民國政府尚能掌握內蒙古，而外蒙古再次成為不受其管轄的獨立地區。外蒙古前後多次宣布獨立，中華民國與蘇聯簽訂《中蘇友好同盟條約》，今蒙古國（1924年成立）則在二戰末期獲得中方確認。\n雖曾獲得中華民國與中華人民共和國的承認，不過中華民國政府撤往台灣後於冷戰期間曾有爭議，冷戰結束後則均已確認獨立地位。唐努乌梁海部分則至今仍有爭議，但俄羅斯方面認為蒙古人民共和国独立时，唐努圖瓦已一併脫離，這一部分被并入俄罗斯苏维埃联邦社会主义共和国（即现俄罗斯联邦），另一部分则并入當時的蒙古人民共和国庫蘇古爾省，今日俄蒙國界便因此而定。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的歷史背景", "Tag": "算法设计"}
{"Answer": "1911年的外蒙古版图在清朝的位置，位于沙俄势力范围内1905年日俄戰爭，1907年兩國和好簽訂合約，俄國承認日本在朝鮮之「優越地位」，日本承認俄國在外蒙古的「一切權利」[4]。\n1910年，日韓併合，日俄簽訂第二次密約，俄國尊重日本對朝鮮的行動，日本也同樣尊重俄國在外蒙古與伊犁的一切行動[5]。\n1912年，日本與俄國簽訂第三次密約，設立中國東西內蒙古分界線，俄國承認東內蒙為日本勢力範圍，日本承認西內蒙為俄國勢力範圍，以東經116度27分為日俄界線，日本从俄國取得進軍熱河的默許[6]。\n清朝在蒙古开展“新政”，经费全部摊派到当地，牧民“不堪其扰，相率逃避。近城（指库伦）各旗，为之一空”[7]， 土谢图汗和车臣汗盟长以及哲布尊丹巴管理的沙毕纳尔的商卓特巴，于1910年（宣统二年）联名向库伦办事大臣和乌里雅苏台将军呈报，称“蒙古人民已经忧心忡忡地接到了几道要他们执行新政的命令，我们可怜的、为各种赋税弄得一贫如洗的盟和沙毕的台吉和牧民们，已经到了他们再也无法支持的地步了。历次颁布的命令，没有一个对蒙古人是有利的……我们希望继续古老的生活方式”[8]。俄国也通过驻华公使向清朝表达了抗议，清廷指示库伦办事大臣变通执行。\n第一次宣佈獨立[编辑]  《俄蒙协约》签字期间合影宣统三年（1911年）7月，外蒙古獨立首倡者土謝圖汗部親王杭達多爾濟率團出訪俄國，得到俄國軍事支援。辛亥革命后，清朝统治逐渐瓦解，杭達多爾濟等人認為時機成熟。11月初，以土谢图汗部盟长、左翼后旗札萨克镇国公察克都尔扎布为首的“临时总理喀尔喀事务衙门”在库伦成立。11月30日，俄、蒙军队包围库伦办事大臣衙门，解除清军武装，并将庫倫办事大臣三多及其随从人员押送出境。12月29日[9]，杭達多爾濟、車林齊密特等王公喇嘛在库伦宣布獨立，擁立外蒙古第八世哲布尊丹巴呼图克图為皇帝，哲布尊丹巴在库伦登基，自称“博格达汗”（日光皇帝），年号共戴，建立“大蒙古国”[7]。清政府得知后电令库伦帮办大臣朋楚克车林劝谕库伦取消独立，12月21日任命在京的车臣汗部盟长多尔济帕拉穆和新任科布多办事大臣桂芳为“查办库伦事件大臣”，由于俄蒙方面阻挠未能成行[10]。\n1912年11月18日蒙古国外务部致法国、英国、德国、美国、比利时、日本、丹麦、荷兰、奥匈帝國各国外交部宣告独立的照会1912年1月，俄罗斯帝国驻乌里雅苏台领事协助札萨克图汗索特那木拉布坦发动叛乱，札萨克图汗饬令驅逐清朝乌里雅苏台将军奎芳、乌里雅苏台参赞大臣荣恩等人，限“于七日内将仓库、银、缎、军装等项，一律交蒙参赞接收，自备资斧回籍”。奎芳拒不答应，在俄罗斯帝国领事协助下派一队哥萨克骑兵强行将奎芳押解出境[11]。5月，黑喇嘛丹毕坚赞、马克思尔扎布、达木丁苏隆和海山等人率外蒙古军队进攻科布多[12]，新疆都督杨增新救援失败，城池陷落（蒙古語：Ховдыг чөлөөлөх байлдаан）。\n1912年初，沙俄驻呼伦贝尔领事乌萨蒂操纵和指使额鲁特旗总管胜福、陈巴尔虎旗总管车和扎、索伦旗总管成德等人，调集附近各旗蒙兵一千人，以“大清帝国义军”的名义发动叛乱。1月15日，进入呼伦（今海拉尔市）城内，成立“自治政府”。哲布尊丹巴授胜福以“参赞大臣”头衔，作为其驻呼伦的“总督”。\n  那木囊苏伦和乌泰前往圣彼得堡寻求俄国支持“大蒙古国”将独立宣言及时告知内蒙古各盟、旗，内蒙古部分地区也举行武装暴动，在乌泰等内蒙古王公策动下，库伦政府决定出兵南下，用武力占领内蒙古。北京政府为了控制内蒙古也动用武力。1913年初，蒙古军分五路向内蒙古进攻，取得普遍胜利[13]。1913年10月止，蒙古军队基本上控制了内蒙古西部各盟、旗，但同时开始面临后方补给停止的局面。同月下旬，北洋軍开始反击，蒙古军无法再展开军事行动，年底开始从内蒙古撤军。蒙古军失败的主要原因是武器短缺和俄国政府极力反对这场战争。这场持续一年的战争给内蒙古地区造成重大灾难，民间称其为\"牛年之乱（蒙古語：Таван замын байлдаан）\"（Үхэр жилийн үймээн)[14]。\n1912年11月3日，俄国前任驻华公使廓索维茨（俄语：Коростовец, Иван Яковлевич）在库伦与“哲布尊丹巴政府”签订《俄蒙协约》及《俄蒙协约专条》[15]，俄国以支持蒙古自治换取在外蒙享有排他性商业地位，对中国在外蒙主权只字未提，引起中国不满。经过谈判，1913年9月18日，中国外长孙宝琦同俄国驻华公使库朋斯齐（俄语：Крупенский, Василий Николаевич）达成《中俄声明文件》，中国不在外蒙驻兵、殖民、设官，承认外蒙自治，承认《俄蒙协约》及其专条，换回俄国承认中国在外蒙的宗主权，基于宗主权而衍生出俄国承认外蒙古为中国领土一部分。中国对蒙权力已由主权改为宗主权[16]。\n短暫自治及被占領[编辑]主条目：占領外蒙古  中華民國（北洋政府）佔領外蒙古和唐努烏梁海的範圍（1920年）1915年6月7日，中、俄、蒙在恰克图签定《恰克图协定》，将此声明具体化。据此，同年6月9日，外蒙古宣布取消“独立的大蒙古国與共戴年號”。中华民国大总统袁世凯册封第八世哲布尊丹巴为“呼图克图汗”，并赦免独立运动人士。外蒙古取消独立，实行自治。此时外蒙古上层的僧俗两派斗争趋于白热化，哲布尊丹巴呼图克图派人毒死了“外务大臣”杭达多尔济与赛音诺颜部亲王那木囊苏伦，压制了世俗王公的势力。[17]\n1917年俄国爆发十月革命后，俄国势力大幅撤离外蒙[18]，苏维埃俄国政府在1917年和1919年两次发表对华宣言，宣布废除沙俄与中国签订的不平等条约。1918年9月在外蒙古自治政府要求下，北洋政府派遣少量军队进驻库伦协防。\n1919年7月25日，苏维埃俄国发表《第一次对华宣言》，称外蒙古是一个独立的国家，要求与之建立外交关系。[19]\n1919年2月、3月間召開大烏里會議名為「蒙古國體運動」又稱「泛蒙古主義」或「泛蒙運動」，主張內外蒙古結合並與呼倫貝爾（政務廳廳長凌陞）、布里亞特等勢力組聯合政府布里亚特-蒙古国。5月、6月泛蒙運動到達高峰，在海拉爾建立政府，逼迫外蒙古表明立場[20]。\n  徐树铮1919年10月1日，外蒙古自治政府外交部長車林與庫倫都護使陳毅會談達成共識，特派庫倫都護使衙門秘書黃成垿帶著六十三條外蒙撤治善後條例到北京，表達外蒙希望恢復前清舊制（有條件撤治，回到前清絕對宗主權）[21]，取消國際條約裡中國在國防、外交上的約束限制，但外蒙仍保有相當的自治權。徐樹錚所屬皖系曾向日本大量借款以備中國內戰使用引發輿論批評[註 1]，得知外蒙撤治消息急於爭功隨即向外蒙增兵。[22]10月29日徐樹錚到達庫倫，軟禁陳毅十日脅迫他修改六十三條，最後徐樹錚自己新增八條，挾持「內閣總理」巴德瑪多爾濟簽字，外蒙變成「無條件撤治」[23]。陳毅遭軍隊押送回北京。全面否定《中俄声明》。同年11月17日，外蒙古正式上書中華民國大總統徐世昌，呈請廢除俄蒙一切條約。11月22日以《中國大總統公告》下令取消外蒙古自治，恢复旧制[24]。同时取消《中俄声明》和《恰克图协定》，北京政府在庫倫設立「中華民國西北籌邊使公署」，由徐樹錚部在外蒙古駐防。但徐樹錚在外蒙古期间，不顾其传统习俗，全面推行新政改革，致使外蒙古上層集团对北洋政府的统治更加不满[25]。呼倫貝爾原本希望參與外蒙獨立運動，遭俄國反對。北洋政府隨後與俄國簽訂呼倫貝爾條件八款，俄國取得區域經濟利益，並限制中國在此主權[26]。\n第二次宣佈獨立[编辑]  苏赫-巴托尔在特洛伊茨科萨夫斯克（今恰克图）由於外蒙古無法忍受徐樹錚的行為，開始派員聯絡蘇俄紅軍（蘇赫-巴托爾為代表到伊爾庫次克與共產国际接洽）、帝俄白軍（恩琴）及日本（哈爾濱日本領館），尋求援助把中國人趕出外蒙，哲布尊丹巴甚至寫信給日本天皇，希望日方協助其恢復獨立[27]。\n1919年帝俄白軍將領謝米諾夫及恩琴聚集西伯利亞東部，協同布里雅特蒙古、呼倫貝爾、外蒙古等人士，驅逐滯留在外蒙古的中國官員，以民族自決、獨立建國為口號，並在日军的支持下再次宣佈獨立[28]。\n1920年，日本派山田大佐為參謀長，成立對蒙顧問團遊說外蒙喇嘛王公支持恩琴男爵[29]。11月，恩琴（約800人的殘兵，自稱亞洲騎兵師（俄语：Азиатская конная дивизия））第一次進軍庫倫戰敗[30]。\n1921年1月，恩琴透過蒙古人的內應帶八世哲布尊丹巴[註 2]離開庫倫，並取得許多王公喇嘛的支持。8月唐努烏梁海設立图瓦人民共和国[31][32]。\n1920年7月，爆发直皖战争，徐樹錚率军返回内地，战败，旋遭通緝，逃入日本使館。庫伦僅留守部份兵力。原皖系第三旅第七、第八團因直皖戰爭失利軍心不穩。1921年2月4日，恩琴的亞洲騎兵師在日本关东军的支持下攻入库伦。由于中国国内处于第一次直奉戰爭前夕，各派军阀无暇分身，只得坐视外蒙古地区的军事冲突。中国驻军撤离库伦，部分在高在田的率领下返回内地，部分跟随陈毅转移到买卖城，准备再战。\n2月22日，八世哲布尊丹巴为领袖的「大蒙古国」政府重新成立。1921年3月1日，第三國際派沙洛克維克夫（И. Сороковиков）和波雷索夫（俄语：Борисов, Сергей Степанович）支援外蒙革命，並撮合蘇赫-巴托爾和喬巴山在恰克圖成立蒙古人民黨。3月18日，蒙古人民党军队另外在苏俄红军的支持下攻占买卖城，击败了当地守军，中國在外蒙古的勢力自此完全消失。外蒙古恢复了事实上的独立[33]。\n成立蒙古人民共和国[编辑]主条目：蒙古人民革命  大蒙古國國旗（1921年－1924年）1921年5月25日由蘇赫-巴托爾和喬巴山做嚮導，蘇俄聯合赤塔遠東共和國的紅軍共二師兵力從伊爾庫次克出兵干预；另一方面因華盛頓會議的關係，日軍自延吉、琿春撤軍，恩琴失去日方支持[34]。7月6日蘇聯紅軍开入库伦，恩琴被俘。1921年7月11日，外蒙古建立亲苏的君主立宪政府，博克多汗重新登基。北洋政府下令命张作霖收复外蒙。张仅作了敷衍，并没有出兵至外蒙。11月25日外蒙古建立“人民政府（蒙古語：Ардын түр засгийн газар）”，并与苏联订立了《苏蒙修好条约（蒙古語：Монгол-Оросын 1921 оны гэрээ）》[35]。北京政府发布了一份声明，谴责外蒙古企图分裂中华民国的行径，不承认外蒙古的独立。\n1923年1月26日，中华民国非常大总统孙中山和苏联代表越飞在上海秘密发表《孙文越飞宣言》，同意苏军留驻外蒙[36]。\n1924年4月17日，蒙古君主哲布尊丹巴活佛逝世。1924年5月31日，北洋政府与苏联签订的《中蘇解決懸案大綱協定》，不承认外蒙古獨立，並要求蘇方撤軍。但該條約並沒有被很好執行，當時報紙稱蘇軍在外蒙重要據點均有駐軍[37]。\n1924年11月26日，在蘇聯第三國際支持與行動下，蒙古人民黨宣布废除君主立宪制，成立蒙古人民共和国，定都库伦，改城名为乌兰巴托，以1911年作独立纪元，允许蘇聯驻军，自此確立了外蒙古成為蘇聯共產黨的衛星國[38]。但中國及英、美等当时主要國家政府皆未承認。\n中華民國北洋政府於1922年5月1日向蘇聯政府表達嚴重抗議：「蘇聯政府對中國歷次通牒曾宣言，所有往日俄國各前政府與中國所定條約均為無效[註 3]，並放棄對中國領土之侵略，今蘇聯政府乃背反前言，擅與蒙古私訂條約，此等行為直與帝俄政府時代對華如出一轍，須知蒙古係屬中華民國領土，本國政府實難容忍，為此特向執事嚴重抗議，所有蘇聯政府與蒙古私訂無論何種條約，中國政府決不承認[39]。」\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的清末和北洋政府时期", "Tag": "算法设计"}
{"Answer": "  《俄蒙协约》签字期间合影宣统三年（1911年）7月，外蒙古獨立首倡者土謝圖汗部親王杭達多爾濟率團出訪俄國，得到俄國軍事支援。辛亥革命后，清朝统治逐渐瓦解，杭達多爾濟等人認為時機成熟。11月初，以土谢图汗部盟长、左翼后旗札萨克镇国公察克都尔扎布为首的“临时总理喀尔喀事务衙门”在库伦成立。11月30日，俄、蒙军队包围库伦办事大臣衙门，解除清军武装，并将庫倫办事大臣三多及其随从人员押送出境。12月29日[9]，杭達多爾濟、車林齊密特等王公喇嘛在库伦宣布獨立，擁立外蒙古第八世哲布尊丹巴呼图克图為皇帝，哲布尊丹巴在库伦登基，自称“博格达汗”（日光皇帝），年号共戴，建立“大蒙古国”[7]。清政府得知后电令库伦帮办大臣朋楚克车林劝谕库伦取消独立，12月21日任命在京的车臣汗部盟长多尔济帕拉穆和新任科布多办事大臣桂芳为“查办库伦事件大臣”，由于俄蒙方面阻挠未能成行[10]。\n1912年11月18日蒙古国外务部致法国、英国、德国、美国、比利时、日本、丹麦、荷兰、奥匈帝國各国外交部宣告独立的照会1912年1月，俄罗斯帝国驻乌里雅苏台领事协助札萨克图汗索特那木拉布坦发动叛乱，札萨克图汗饬令驅逐清朝乌里雅苏台将军奎芳、乌里雅苏台参赞大臣荣恩等人，限“于七日内将仓库、银、缎、军装等项，一律交蒙参赞接收，自备资斧回籍”。奎芳拒不答应，在俄罗斯帝国领事协助下派一队哥萨克骑兵强行将奎芳押解出境[11]。5月，黑喇嘛丹毕坚赞、马克思尔扎布、达木丁苏隆和海山等人率外蒙古军队进攻科布多[12]，新疆都督杨增新救援失败，城池陷落（蒙古語：Ховдыг чөлөөлөх байлдаан）。\n1912年初，沙俄驻呼伦贝尔领事乌萨蒂操纵和指使额鲁特旗总管胜福、陈巴尔虎旗总管车和扎、索伦旗总管成德等人，调集附近各旗蒙兵一千人，以“大清帝国义军”的名义发动叛乱。1月15日，进入呼伦（今海拉尔市）城内，成立“自治政府”。哲布尊丹巴授胜福以“参赞大臣”头衔，作为其驻呼伦的“总督”。\n  那木囊苏伦和乌泰前往圣彼得堡寻求俄国支持“大蒙古国”将独立宣言及时告知内蒙古各盟、旗，内蒙古部分地区也举行武装暴动，在乌泰等内蒙古王公策动下，库伦政府决定出兵南下，用武力占领内蒙古。北京政府为了控制内蒙古也动用武力。1913年初，蒙古军分五路向内蒙古进攻，取得普遍胜利[13]。1913年10月止，蒙古军队基本上控制了内蒙古西部各盟、旗，但同时开始面临后方补给停止的局面。同月下旬，北洋軍开始反击，蒙古军无法再展开军事行动，年底开始从内蒙古撤军。蒙古军失败的主要原因是武器短缺和俄国政府极力反对这场战争。这场持续一年的战争给内蒙古地区造成重大灾难，民间称其为\"牛年之乱（蒙古語：Таван замын байлдаан）\"（Үхэр жилийн үймээн)[14]。\n1912年11月3日，俄国前任驻华公使廓索维茨（俄语：Коростовец, Иван Яковлевич）在库伦与“哲布尊丹巴政府”签订《俄蒙协约》及《俄蒙协约专条》[15]，俄国以支持蒙古自治换取在外蒙享有排他性商业地位，对中国在外蒙主权只字未提，引起中国不满。经过谈判，1913年9月18日，中国外长孙宝琦同俄国驻华公使库朋斯齐（俄语：Крупенский, Василий Николаевич）达成《中俄声明文件》，中国不在外蒙驻兵、殖民、设官，承认外蒙自治，承认《俄蒙协约》及其专条，换回俄国承认中国在外蒙的宗主权，基于宗主权而衍生出俄国承认外蒙古为中国领土一部分。中国对蒙权力已由主权改为宗主权[16]。\n短暫自治及被占領[编辑]主条目：占領外蒙古  中華民國（北洋政府）佔領外蒙古和唐努烏梁海的範圍（1920年）1915年6月7日，中、俄、蒙在恰克图签定《恰克图协定》，将此声明具体化。据此，同年6月9日，外蒙古宣布取消“独立的大蒙古国與共戴年號”。中华民国大总统袁世凯册封第八世哲布尊丹巴为“呼图克图汗”，并赦免独立运动人士。外蒙古取消独立，实行自治。此时外蒙古上层的僧俗两派斗争趋于白热化，哲布尊丹巴呼图克图派人毒死了“外务大臣”杭达多尔济与赛音诺颜部亲王那木囊苏伦，压制了世俗王公的势力。[17]\n1917年俄国爆发十月革命后，俄国势力大幅撤离外蒙[18]，苏维埃俄国政府在1917年和1919年两次发表对华宣言，宣布废除沙俄与中国签订的不平等条约。1918年9月在外蒙古自治政府要求下，北洋政府派遣少量军队进驻库伦协防。\n1919年7月25日，苏维埃俄国发表《第一次对华宣言》，称外蒙古是一个独立的国家，要求与之建立外交关系。[19]\n1919年2月、3月間召開大烏里會議名為「蒙古國體運動」又稱「泛蒙古主義」或「泛蒙運動」，主張內外蒙古結合並與呼倫貝爾（政務廳廳長凌陞）、布里亞特等勢力組聯合政府布里亚特-蒙古国。5月、6月泛蒙運動到達高峰，在海拉爾建立政府，逼迫外蒙古表明立場[20]。\n  徐树铮1919年10月1日，外蒙古自治政府外交部長車林與庫倫都護使陳毅會談達成共識，特派庫倫都護使衙門秘書黃成垿帶著六十三條外蒙撤治善後條例到北京，表達外蒙希望恢復前清舊制（有條件撤治，回到前清絕對宗主權）[21]，取消國際條約裡中國在國防、外交上的約束限制，但外蒙仍保有相當的自治權。徐樹錚所屬皖系曾向日本大量借款以備中國內戰使用引發輿論批評[註 1]，得知外蒙撤治消息急於爭功隨即向外蒙增兵。[22]10月29日徐樹錚到達庫倫，軟禁陳毅十日脅迫他修改六十三條，最後徐樹錚自己新增八條，挾持「內閣總理」巴德瑪多爾濟簽字，外蒙變成「無條件撤治」[23]。陳毅遭軍隊押送回北京。全面否定《中俄声明》。同年11月17日，外蒙古正式上書中華民國大總統徐世昌，呈請廢除俄蒙一切條約。11月22日以《中國大總統公告》下令取消外蒙古自治，恢复旧制[24]。同时取消《中俄声明》和《恰克图协定》，北京政府在庫倫設立「中華民國西北籌邊使公署」，由徐樹錚部在外蒙古駐防。但徐樹錚在外蒙古期间，不顾其传统习俗，全面推行新政改革，致使外蒙古上層集团对北洋政府的统治更加不满[25]。呼倫貝爾原本希望參與外蒙獨立運動，遭俄國反對。北洋政府隨後與俄國簽訂呼倫貝爾條件八款，俄國取得區域經濟利益，並限制中國在此主權[26]。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的清末和北洋政府时期的第一次宣佈獨立", "Tag": "算法设计"}
{"Answer": "主条目：占領外蒙古  中華民國（北洋政府）佔領外蒙古和唐努烏梁海的範圍（1920年）1915年6月7日，中、俄、蒙在恰克图签定《恰克图协定》，将此声明具体化。据此，同年6月9日，外蒙古宣布取消“独立的大蒙古国與共戴年號”。中华民国大总统袁世凯册封第八世哲布尊丹巴为“呼图克图汗”，并赦免独立运动人士。外蒙古取消独立，实行自治。此时外蒙古上层的僧俗两派斗争趋于白热化，哲布尊丹巴呼图克图派人毒死了“外务大臣”杭达多尔济与赛音诺颜部亲王那木囊苏伦，压制了世俗王公的势力。[17]\n1917年俄国爆发十月革命后，俄国势力大幅撤离外蒙[18]，苏维埃俄国政府在1917年和1919年两次发表对华宣言，宣布废除沙俄与中国签订的不平等条约。1918年9月在外蒙古自治政府要求下，北洋政府派遣少量军队进驻库伦协防。\n1919年7月25日，苏维埃俄国发表《第一次对华宣言》，称外蒙古是一个独立的国家，要求与之建立外交关系。[19]\n1919年2月、3月間召開大烏里會議名為「蒙古國體運動」又稱「泛蒙古主義」或「泛蒙運動」，主張內外蒙古結合並與呼倫貝爾（政務廳廳長凌陞）、布里亞特等勢力組聯合政府布里亚特-蒙古国。5月、6月泛蒙運動到達高峰，在海拉爾建立政府，逼迫外蒙古表明立場[20]。\n  徐树铮1919年10月1日，外蒙古自治政府外交部長車林與庫倫都護使陳毅會談達成共識，特派庫倫都護使衙門秘書黃成垿帶著六十三條外蒙撤治善後條例到北京，表達外蒙希望恢復前清舊制（有條件撤治，回到前清絕對宗主權）[21]，取消國際條約裡中國在國防、外交上的約束限制，但外蒙仍保有相當的自治權。徐樹錚所屬皖系曾向日本大量借款以備中國內戰使用引發輿論批評[註 1]，得知外蒙撤治消息急於爭功隨即向外蒙增兵。[22]10月29日徐樹錚到達庫倫，軟禁陳毅十日脅迫他修改六十三條，最後徐樹錚自己新增八條，挾持「內閣總理」巴德瑪多爾濟簽字，外蒙變成「無條件撤治」[23]。陳毅遭軍隊押送回北京。全面否定《中俄声明》。同年11月17日，外蒙古正式上書中華民國大總統徐世昌，呈請廢除俄蒙一切條約。11月22日以《中國大總統公告》下令取消外蒙古自治，恢复旧制[24]。同时取消《中俄声明》和《恰克图协定》，北京政府在庫倫設立「中華民國西北籌邊使公署」，由徐樹錚部在外蒙古駐防。但徐樹錚在外蒙古期间，不顾其传统习俗，全面推行新政改革，致使外蒙古上層集团对北洋政府的统治更加不满[25]。呼倫貝爾原本希望參與外蒙獨立運動，遭俄國反對。北洋政府隨後與俄國簽訂呼倫貝爾條件八款，俄國取得區域經濟利益，並限制中國在此主權[26]。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的清末和北洋政府时期的第一次宣佈獨立的短暫自治及被占領", "Tag": "算法设计"}
{"Answer": "  苏赫-巴托尔在特洛伊茨科萨夫斯克（今恰克图）由於外蒙古無法忍受徐樹錚的行為，開始派員聯絡蘇俄紅軍（蘇赫-巴托爾為代表到伊爾庫次克與共產国际接洽）、帝俄白軍（恩琴）及日本（哈爾濱日本領館），尋求援助把中國人趕出外蒙，哲布尊丹巴甚至寫信給日本天皇，希望日方協助其恢復獨立[27]。\n1919年帝俄白軍將領謝米諾夫及恩琴聚集西伯利亞東部，協同布里雅特蒙古、呼倫貝爾、外蒙古等人士，驅逐滯留在外蒙古的中國官員，以民族自決、獨立建國為口號，並在日军的支持下再次宣佈獨立[28]。\n1920年，日本派山田大佐為參謀長，成立對蒙顧問團遊說外蒙喇嘛王公支持恩琴男爵[29]。11月，恩琴（約800人的殘兵，自稱亞洲騎兵師（俄语：Азиатская конная дивизия））第一次進軍庫倫戰敗[30]。\n1921年1月，恩琴透過蒙古人的內應帶八世哲布尊丹巴[註 2]離開庫倫，並取得許多王公喇嘛的支持。8月唐努烏梁海設立图瓦人民共和国[31][32]。\n1920年7月，爆发直皖战争，徐樹錚率军返回内地，战败，旋遭通緝，逃入日本使館。庫伦僅留守部份兵力。原皖系第三旅第七、第八團因直皖戰爭失利軍心不穩。1921年2月4日，恩琴的亞洲騎兵師在日本关东军的支持下攻入库伦。由于中国国内处于第一次直奉戰爭前夕，各派军阀无暇分身，只得坐视外蒙古地区的军事冲突。中国驻军撤离库伦，部分在高在田的率领下返回内地，部分跟随陈毅转移到买卖城，准备再战。\n2月22日，八世哲布尊丹巴为领袖的「大蒙古国」政府重新成立。1921年3月1日，第三國際派沙洛克維克夫（И. Сороковиков）和波雷索夫（俄语：Борисов, Сергей Степанович）支援外蒙革命，並撮合蘇赫-巴托爾和喬巴山在恰克圖成立蒙古人民黨。3月18日，蒙古人民党军队另外在苏俄红军的支持下攻占买卖城，击败了当地守军，中國在外蒙古的勢力自此完全消失。外蒙古恢复了事实上的独立[33]。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的清末和北洋政府时期的第二次宣佈獨立", "Tag": "算法设计"}
{"Answer": "主条目：蒙古人民革命  大蒙古國國旗（1921年－1924年）1921年5月25日由蘇赫-巴托爾和喬巴山做嚮導，蘇俄聯合赤塔遠東共和國的紅軍共二師兵力從伊爾庫次克出兵干预；另一方面因華盛頓會議的關係，日軍自延吉、琿春撤軍，恩琴失去日方支持[34]。7月6日蘇聯紅軍开入库伦，恩琴被俘。1921年7月11日，外蒙古建立亲苏的君主立宪政府，博克多汗重新登基。北洋政府下令命张作霖收复外蒙。张仅作了敷衍，并没有出兵至外蒙。11月25日外蒙古建立“人民政府（蒙古語：Ардын түр засгийн газар）”，并与苏联订立了《苏蒙修好条约（蒙古語：Монгол-Оросын 1921 оны гэрээ）》[35]。北京政府发布了一份声明，谴责外蒙古企图分裂中华民国的行径，不承认外蒙古的独立。\n1923年1月26日，中华民国非常大总统孙中山和苏联代表越飞在上海秘密发表《孙文越飞宣言》，同意苏军留驻外蒙[36]。\n1924年4月17日，蒙古君主哲布尊丹巴活佛逝世。1924年5月31日，北洋政府与苏联签订的《中蘇解決懸案大綱協定》，不承认外蒙古獨立，並要求蘇方撤軍。但該條約並沒有被很好執行，當時報紙稱蘇軍在外蒙重要據點均有駐軍[37]。\n1924年11月26日，在蘇聯第三國際支持與行動下，蒙古人民黨宣布废除君主立宪制，成立蒙古人民共和国，定都库伦，改城名为乌兰巴托，以1911年作独立纪元，允许蘇聯驻军，自此確立了外蒙古成為蘇聯共產黨的衛星國[38]。但中國及英、美等当时主要國家政府皆未承認。\n中華民國北洋政府於1922年5月1日向蘇聯政府表達嚴重抗議：「蘇聯政府對中國歷次通牒曾宣言，所有往日俄國各前政府與中國所定條約均為無效[註 3]，並放棄對中國領土之侵略，今蘇聯政府乃背反前言，擅與蒙古私訂條約，此等行為直與帝俄政府時代對華如出一轍，須知蒙古係屬中華民國領土，本國政府實難容忍，為此特向執事嚴重抗議，所有蘇聯政府與蒙古私訂無論何種條約，中國政府決不承認[39]。」\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的清末和北洋政府时期的成立蒙古人民共和国", "Tag": "算法设计"}
{"Answer": "抗战期间[编辑]主条目：苏日战争和二戰時期的外蒙古蒙古人民共和国国旗（1924年－1930年）蒙古人民共和国国旗（1930年－1940年）蒙古人民共和国国旗（1940年－1945年）中華民國國民政府一直处于内外交困的处境中，从国民革命军北伐、中原大戰、第一次国共内战，到1931年九一八事件和1937年全面抗日战争爆发，无力处理外蒙古问题。其间1928年國民革命軍在外蒙古东部边界与苏军发生了小规模战斗，之后再没有进入外蒙古。直到1992年苏联解体后，苏联军队彻底从蒙古国撤走，蒙古才實際獲得獨立。与此同时，在乔巴山等人的领导下，蒙古人民共和国实行了苏联式的政治经济制度。\n1939年，苏、蒙联军与日本、满洲国的军队因蒙满边境问题爆发諾門罕戰役，之后因欧洲战事而停战。1941年3月，日本外務大臣松冈洋右訪蘇，蘇聯外交部次長在3月27日對中國駐蘇大使說：“史達林接見松冈，是純禮貌問題。”4月11日“蘇聯不為自己而犧牲友邦的利益，蘇聯政府對松冈是照例接待。”但是，就在兩天后的4月13日，苏联就同日本签订了《苏日中立条约》，并发表联合声明说：为了维护两国的友好关系，苏联保证尊重“满洲国”的领土完整和不可侵犯；日本保证尊重“蒙古人民共和国”的领土完整和不可侵犯。对此，中華民國外交部部長王宠惠声明“《苏日中立条约》，对于中国绝对无效。”\n在此期间，内蒙古的德王试图使内蒙古也独立，还建立了实际上受日本人控制的傀儡政权蒙疆聯合自治政府，但随着日本的投降和苏、蒙联军的参战，该傀儡政府也垮台，内蒙古很快被中國共產黨控制，1947年中共根據民族区域自治理論領導成立了中國第一个民族区域自治政权内蒙古自治政府。\n中華民國駐蘇大使邵力子曾说：“我在1943年春间，曾提出有关中苏邦交的建议……关于中苏之间的许多应解决的问题，我所建议的几乎多与中苏友好协定所包含的相类似。因为那时我认为这些问题必须加以合理的解决，尤其是承认外蒙古的独立，和中山先生建国大纲所定扶助弱小民族使之自治自决的精神，完全符合。”[40]\n《中蘇友好同盟條約》與承認獨立[编辑]主条目：雅尔塔协定和中蘇友好同盟條約第二次世界大戰末，同盟國為爭取蘇聯對日本宣戰，美、英兩國在未通知中華民國以及其他盟國之下，於1945年2月11日與蘇聯签定涉及外蒙古以及中國主权的《雅尔塔协定》（又稱“雅爾達密約”）。其中規定：“外蒙（蒙古人民共和國）的現狀應予保持。”1945年，史達林曾对蔣經國说过：“老實告訴你，我之所以要外蒙古，完全是站在軍事的戰略觀點而要這塊地方的。”[41]“倘使有一个军事力量[註 4]从外蒙古向苏联进攻，西伯利亚铁路一被切断，俄國就完了。”[41][42][43]。这也是他坚决要求外蒙古独立的主要原因。但美國總統羅斯福曾面請中華民國駐美大使魏道明，謂在維持外蒙現狀之下，中國外蒙古成为两个邻居[42]。當時中國政府亦認為对外蒙古鞭长莫及[44]。\n  雅尔塔会议中的丘吉尔、罗斯福和斯大林8月8日，德国投降正好三个月，美国对日本使用原子弹之后，苏联在和中国谈判成功之前，对日本宣战。一百五十万苏军在蒙古集结后进攻中国东北、朝鲜等地的日本关东军。其间外蒙古提供后勤并派军队参加了苏军对日军在内蒙古的作战。中蘇在就外蒙古問題舉行談判時，史達林堅稱外蒙今日已是“人民共和國”，其現狀即獨立[42]。談判開始時，中方堅拒承認外蒙獨立，史達林則稱，外蒙問題如無法獲致解決，則條約不能訂立[45]。談判中，蔣經國對史達林說：「我們的國民一定不會原諒我們，在這樣情形之下，國民一定會起來反對政府。」史達林回答：「倘使你本國有力量，自己可以打日本，我自然不會提出要求。今天，你沒有這個力量，還要講這些話，就等於廢話！」[41]\n為繼續取得同盟國對中國戰區的支持，以及避免苏联使得新疆伊寧事變擴大、援助中国共产党和在东北驻军不撤走，1945年8月14日，经过与苏联两个多月的谈判，中華民國政府最終做出妥協。宋子文、王世杰等在國民政府主席蔣中正的授权下與苏联政府签订《中苏友好同盟条约》，同意“苏联出兵击败日本后，三个月内（从东北）撤完、在苏联尊重东北的主权、领土完整；不干涉新疆的内部事务”等条件下，允許將依公正之公民投票的結果決定是否承認蒙古人民共和國。宋子文拒絕簽字，并辭掉外交部長一職，最后該條約由王世杰簽字。[46]同日，中蘇兩國外交部互致照會[47]：\n.mw-parser-output .templatequote{margin-top:0;overflow:hidden}.mw-parser-output .templatequote .templatequotecite{line-height:1em;text-align:left;padding-left:2em;margin-top:0}.mw-parser-output .templatequote .templatequotecite cite{font-size:small}\n中苏关于外蒙古问题的换文\n甲：紀錄 \n斯大林統帥與宋院長子文在一九四五年七月十一日第五次會談時曾討論蘇聯參加對日本作戰後其軍隊由中國領土撤退之問題。斯大林統帥不願在蘇聯軍隊進入東三省之協定內，加入在日本戰敗後三個月內將蘇聯軍隊撤退一節，但斯大林統帥聲明在日本投降以後，蘇聯軍隊當於三星期內開始撤退。\n宋院長詢及撤退完畢需要若干時間。斯大林統帥謂彼意撤軍可於不超過兩個月之期間內完竣。 \n宋院長繼詢是否確在三個月以內撤完。斯大林統帥最多三個月足為完成撤退之期。 \n中華民國三十四年 \n八月十四日 \n西曆一九四五年 \n王世杰 (簽字) \n莫洛托夫 (簽字) \n乙、中华民国政府文\n部长阁下：茲因外蒙古人民一再表示其獨立之願望，中國政府聲明，於日本戰敗後，如外蒙古之公民投票證實此項願望，中國政府當承認外蒙古之獨立，即以其現在之邊界為邊界。\n上開之聲明，於民國三十四年八月十四日簽訂之中蘇友好同盟條約批准後，發生拘束力。\n本部长顺向贵部长表示崇高之敬意。此照苏联外交人民委员部莫洛托夫部长。\n中华民国三十四年八月十四日\n西历一九四五年八月十四日\n丙、苏维埃社会主义共和国联盟文\n部长阅下：核准阁下照会，内开：“兹因外蒙古人民一再表示其独立之愿望，中国政府声明，于日本战败后，如外蒙古之公民投票证实此项愿望，中国政府当承认外蒙古之独立，即以其现在之边界为边界。\n上开之声明，于民国三十四年八月十四日签订之中苏友好同盟条约批准后，发生拘束力。”\n苏联政府对中华民国政府上项照会，业经奉悉，表示满意，兹并声明苏联政府将尊重蒙古人民共和国（外蒙）之政治独立与领土完整。\n本部长顺向贵部长表示崇高之敬意。此照中华民国国民政府外交部王部长世杰\n西历一九四五年八月十四日\n中华民国三十四年八月十四日\n\n王世杰回國稱該條約可保中蘇三十年的和平，于是8月24日立法院在孫科主持下，以95人贊成，4人反對（以起立方式表決）通過《中蘇友好同盟條約》。\n同日，蔣中正在中央常會和國防最高委員會聯席會議上的演講稱： 「 外蒙自北京政府時代民國十一年起，在事實上已脫離了祖國而宣告獨立，如今已屆二十五年，我們早已明了我們如不能以國民革命的原則，和本黨壹貫的傳統政策用斷然的決心來解決這個問題，勢將引起永久的紛爭，對於國內安定與世界和平，都將因此要發生重大的影響，今當日本帝國主義已告失敗，東亞和平秩序，初見端倪之際，我們認為這是解決這壹重大問題的時機，如果外蒙以友好的精神循合法的程序，提出他獨立的願望，我們政府自當予以承認。」[48]\n10月20日外蒙舉行公民投票，中國政府派雷法章前去參觀。雷法章奉蔣中正之命，「不與外蒙當局進行任何交涉」；關于投票，雷法章「只宜細心觀察，但不得干涉或發表任何聲明」。外蒙人民「在政府人員監督之下，以公開之簽字方式表示贊成與否」，[49]投票結果顯示，98.5%的投票公民赞成外蒙古从中国独立出去。[50]\n1945年11月15日，苏联违反条约，拒不从东北撤军，扶持东北根据地和东北民主联军，继续向中国施加压力。1945年底，副外长洛索夫斯基在蒋经国访苏前给斯大林的报告中作了全面论述：“第一，中国政府必须承认蒙古人民共和国独立；第二，中国必须保证长春铁路沿线的安全，……”。\n（中央社重庆五日电）国府于一月五日发表承认外蒙独立之公告如下：外蒙古人民于民国卅四年十月廿日举行公民投票，中央曾派内政部次长雷法章前往观察，近据外蒙古投票事务人员之报告，公民投票结果，已证实外蒙古人民赞成独立，兹照国防最高委员会之审议，法定承认外蒙古之独立，除由行政院转饬内政部将此项决议正式通知外蒙古政府外，特此公告。“”《国民政府公告》（1946年1月6日）1946年1月5日，中华民国国民政府承认蒙古人民共和國独立[51]。\n雷法章事后声称此次“公民投票”：“其办理投票事务人员，对于人民投票名为引导，实系监视，且甚为严密”“此项公民投票据称为外蒙古人民重向世界表示独立愿望之行动，……人民实难表示自由之意志。”[49]中華民國政府同蘇聯交惡後，中華民國代表蔣廷黻曾於1947年8月27日於聯合國安理會開會時表示質疑此投票之公正性，發言稱：「吾人認為此事是吾人所不能接受之過份簡單的歷史，當適當時機來臨後，我國政府有從事進一步觀察之權利。」\n1949年10月1日，中华人民共和国成立，1949年10月2日，蘇聯公開承認中華人民共和國并與之建交。12月7日中華民國政府播迁台湾，中華民國外交部在1949年11月7日《與蘇聯斷絕邦交之聲明》中稱，《中蘇友好同盟條約》簽訂后，中國政府一向恪守該條約產生之一切義務，但是蘇聯卻違反條約，[52][53]。蘇聯屢次違約，但国民政府卻「為顧慮美國關係，遲未采取行動」[54]。1950年苏联和中华人民共和国签署了《中苏友好同盟互助条约》而废除了《中蘇友好同盟條約》。\n  蒙古人民共和国国旗（1945年－1992年）  蒙古人民共和国国徽（1960年－1991年）1952年，中華民國向聯合國控告蘇聯違反《中蘇友好同盟條約》中“不援助中共”等条件，聯合國大會2月1日以25票贊成，9票反對，24票棄權，通過聯合國大會505號決議譴責蘇聯，是為「控蘇案」。1952年10月13日，蒋中正在国民党的中央会议上，沉重地检讨说：「承認外蒙獨立的決策，雖然是中央正式通過一致贊成的，但我本人願負其全責。這是我個人的決策，是我的責任，亦是我的罪愆」。蔣還稱，放弃外蒙古「實在是一個幼稚的幻想，絕非謀國之道」；蔣中正還表示自己「對總理、對革命、對國家和人民應該引咎自責」。1953年2月20日美國總統艾森豪對國會正式否認雅爾達秘密協定的存在，中华民国政府2月23日宣布《中蘇友好同盟條約》失效，从而推翻对蒙古人民共和国的独立承认。2月25日，外交部正式廢除《中蘇友好同盟條約》。[54]\n蒙古加入联合国[编辑]主条目：聯合國安全理事會第166號決議1946年7月13日，中国驻美公使谭绍华博士向美国国务院电话通报：中国政府不支持（does not feel that it is in a position to work for or to support）外蒙进入联合国[55]。8月6日，中華民國駐聯合國代表徐淑希表示外蒙古加入联合国时机未到：“蒙古人民共和国在数月之前，尚为中国之一部分，称为外蒙古。其独立乃由选举之故，国民政府将为欢迎其加入联合国之一国家，吾人固竭诚期望其加入此国际机构。……国民政府于适当之时间到来时，侪以全力支持外蒙古要求入会申请。”[56]\n1946年外蒙古等五國申請加入联合国，中华民国赞成，英国、美国反对，外蒙的入会要求被安理會否決[57]，聯合國大會因此在1946年11月19日通過35號決議[58]，建議安理會重新審查五國的申請[59]。\n1947年7月28日，中華民國駐聯合國代表徐淑希在联合国安理會发表演說，指責蒙古人民共和国軍隊入侵中國新疆，反對外蒙古加入聯合國[60]。同年8月18日，安理会第186次会议，中华民国代表蒋廷黻以北塔山事件为由投票反对蒙古加入联合国。[61]这在聯合國大會引起安理會是否越權的討論[62]。\n1948年10月，朝鲜民主主义人民共和国承认蒙古人民共和国，1949年5月，阿尔巴尼亚也与蒙古建交。\n1955年12月13日，中华民国代表在安理會對联合国大會3502號草案中，蒙古人民共和国加入联合国的部分行使否決權，理由是全蒙古是中国的一部分[63][64][65][66][67]。\n1961年10月25日，联合国安理会以9票赞成，0票反对，1票（美国）弃权的表决结果，通过了聯合國安理會166號決議，建議聯合國大會接受蒙古國加入聯合國。中华民国未参加投票表决。10月27日，联合国大会通过第1630号决议案，接纳蒙古人民共和国加入联合国，中华民国未参加表决[68][69]。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的國民政府與外蒙古", "Tag": "算法设计"}
{"Answer": "主条目：苏日战争和二戰時期的外蒙古蒙古人民共和国国旗（1924年－1930年）蒙古人民共和国国旗（1930年－1940年）蒙古人民共和国国旗（1940年－1945年）中華民國國民政府一直处于内外交困的处境中，从国民革命军北伐、中原大戰、第一次国共内战，到1931年九一八事件和1937年全面抗日战争爆发，无力处理外蒙古问题。其间1928年國民革命軍在外蒙古东部边界与苏军发生了小规模战斗，之后再没有进入外蒙古。直到1992年苏联解体后，苏联军队彻底从蒙古国撤走，蒙古才實際獲得獨立。与此同时，在乔巴山等人的领导下，蒙古人民共和国实行了苏联式的政治经济制度。\n1939年，苏、蒙联军与日本、满洲国的军队因蒙满边境问题爆发諾門罕戰役，之后因欧洲战事而停战。1941年3月，日本外務大臣松冈洋右訪蘇，蘇聯外交部次長在3月27日對中國駐蘇大使說：“史達林接見松冈，是純禮貌問題。”4月11日“蘇聯不為自己而犧牲友邦的利益，蘇聯政府對松冈是照例接待。”但是，就在兩天后的4月13日，苏联就同日本签订了《苏日中立条约》，并发表联合声明说：为了维护两国的友好关系，苏联保证尊重“满洲国”的领土完整和不可侵犯；日本保证尊重“蒙古人民共和国”的领土完整和不可侵犯。对此，中華民國外交部部長王宠惠声明“《苏日中立条约》，对于中国绝对无效。”\n在此期间，内蒙古的德王试图使内蒙古也独立，还建立了实际上受日本人控制的傀儡政权蒙疆聯合自治政府，但随着日本的投降和苏、蒙联军的参战，该傀儡政府也垮台，内蒙古很快被中國共產黨控制，1947年中共根據民族区域自治理論領導成立了中國第一个民族区域自治政权内蒙古自治政府。\n中華民國駐蘇大使邵力子曾说：“我在1943年春间，曾提出有关中苏邦交的建议……关于中苏之间的许多应解决的问题，我所建议的几乎多与中苏友好协定所包含的相类似。因为那时我认为这些问题必须加以合理的解决，尤其是承认外蒙古的独立，和中山先生建国大纲所定扶助弱小民族使之自治自决的精神，完全符合。”[40]\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的國民政府與外蒙古的抗战期间", "Tag": "算法设计"}
{"Answer": "主条目：雅尔塔协定和中蘇友好同盟條約第二次世界大戰末，同盟國為爭取蘇聯對日本宣戰，美、英兩國在未通知中華民國以及其他盟國之下，於1945年2月11日與蘇聯签定涉及外蒙古以及中國主权的《雅尔塔协定》（又稱“雅爾達密約”）。其中規定：“外蒙（蒙古人民共和國）的現狀應予保持。”1945年，史達林曾对蔣經國说过：“老實告訴你，我之所以要外蒙古，完全是站在軍事的戰略觀點而要這塊地方的。”[41]“倘使有一个军事力量[註 4]从外蒙古向苏联进攻，西伯利亚铁路一被切断，俄國就完了。”[41][42][43]。这也是他坚决要求外蒙古独立的主要原因。但美國總統羅斯福曾面請中華民國駐美大使魏道明，謂在維持外蒙現狀之下，中國外蒙古成为两个邻居[42]。當時中國政府亦認為对外蒙古鞭长莫及[44]。\n  雅尔塔会议中的丘吉尔、罗斯福和斯大林8月8日，德国投降正好三个月，美国对日本使用原子弹之后，苏联在和中国谈判成功之前，对日本宣战。一百五十万苏军在蒙古集结后进攻中国东北、朝鲜等地的日本关东军。其间外蒙古提供后勤并派军队参加了苏军对日军在内蒙古的作战。中蘇在就外蒙古問題舉行談判時，史達林堅稱外蒙今日已是“人民共和國”，其現狀即獨立[42]。談判開始時，中方堅拒承認外蒙獨立，史達林則稱，外蒙問題如無法獲致解決，則條約不能訂立[45]。談判中，蔣經國對史達林說：「我們的國民一定不會原諒我們，在這樣情形之下，國民一定會起來反對政府。」史達林回答：「倘使你本國有力量，自己可以打日本，我自然不會提出要求。今天，你沒有這個力量，還要講這些話，就等於廢話！」[41]\n為繼續取得同盟國對中國戰區的支持，以及避免苏联使得新疆伊寧事變擴大、援助中国共产党和在东北驻军不撤走，1945年8月14日，经过与苏联两个多月的谈判，中華民國政府最終做出妥協。宋子文、王世杰等在國民政府主席蔣中正的授权下與苏联政府签订《中苏友好同盟条约》，同意“苏联出兵击败日本后，三个月内（从东北）撤完、在苏联尊重东北的主权、领土完整；不干涉新疆的内部事务”等条件下，允許將依公正之公民投票的結果決定是否承認蒙古人民共和國。宋子文拒絕簽字，并辭掉外交部長一職，最后該條約由王世杰簽字。[46]同日，中蘇兩國外交部互致照會[47]：\n.mw-parser-output .templatequote{margin-top:0;overflow:hidden}.mw-parser-output .templatequote .templatequotecite{line-height:1em;text-align:left;padding-left:2em;margin-top:0}.mw-parser-output .templatequote .templatequotecite cite{font-size:small}\n中苏关于外蒙古问题的换文\n甲：紀錄 \n斯大林統帥與宋院長子文在一九四五年七月十一日第五次會談時曾討論蘇聯參加對日本作戰後其軍隊由中國領土撤退之問題。斯大林統帥不願在蘇聯軍隊進入東三省之協定內，加入在日本戰敗後三個月內將蘇聯軍隊撤退一節，但斯大林統帥聲明在日本投降以後，蘇聯軍隊當於三星期內開始撤退。\n宋院長詢及撤退完畢需要若干時間。斯大林統帥謂彼意撤軍可於不超過兩個月之期間內完竣。 \n宋院長繼詢是否確在三個月以內撤完。斯大林統帥最多三個月足為完成撤退之期。 \n中華民國三十四年 \n八月十四日 \n西曆一九四五年 \n王世杰 (簽字) \n莫洛托夫 (簽字) \n乙、中华民国政府文\n部长阁下：茲因外蒙古人民一再表示其獨立之願望，中國政府聲明，於日本戰敗後，如外蒙古之公民投票證實此項願望，中國政府當承認外蒙古之獨立，即以其現在之邊界為邊界。\n上開之聲明，於民國三十四年八月十四日簽訂之中蘇友好同盟條約批准後，發生拘束力。\n本部长顺向贵部长表示崇高之敬意。此照苏联外交人民委员部莫洛托夫部长。\n中华民国三十四年八月十四日\n西历一九四五年八月十四日\n丙、苏维埃社会主义共和国联盟文\n部长阅下：核准阁下照会，内开：“兹因外蒙古人民一再表示其独立之愿望，中国政府声明，于日本战败后，如外蒙古之公民投票证实此项愿望，中国政府当承认外蒙古之独立，即以其现在之边界为边界。\n上开之声明，于民国三十四年八月十四日签订之中苏友好同盟条约批准后，发生拘束力。”\n苏联政府对中华民国政府上项照会，业经奉悉，表示满意，兹并声明苏联政府将尊重蒙古人民共和国（外蒙）之政治独立与领土完整。\n本部长顺向贵部长表示崇高之敬意。此照中华民国国民政府外交部王部长世杰\n西历一九四五年八月十四日\n中华民国三十四年八月十四日\n\n王世杰回國稱該條約可保中蘇三十年的和平，于是8月24日立法院在孫科主持下，以95人贊成，4人反對（以起立方式表決）通過《中蘇友好同盟條約》。\n同日，蔣中正在中央常會和國防最高委員會聯席會議上的演講稱： 「 外蒙自北京政府時代民國十一年起，在事實上已脫離了祖國而宣告獨立，如今已屆二十五年，我們早已明了我們如不能以國民革命的原則，和本黨壹貫的傳統政策用斷然的決心來解決這個問題，勢將引起永久的紛爭，對於國內安定與世界和平，都將因此要發生重大的影響，今當日本帝國主義已告失敗，東亞和平秩序，初見端倪之際，我們認為這是解決這壹重大問題的時機，如果外蒙以友好的精神循合法的程序，提出他獨立的願望，我們政府自當予以承認。」[48]\n10月20日外蒙舉行公民投票，中國政府派雷法章前去參觀。雷法章奉蔣中正之命，「不與外蒙當局進行任何交涉」；關于投票，雷法章「只宜細心觀察，但不得干涉或發表任何聲明」。外蒙人民「在政府人員監督之下，以公開之簽字方式表示贊成與否」，[49]投票結果顯示，98.5%的投票公民赞成外蒙古从中国独立出去。[50]\n1945年11月15日，苏联违反条约，拒不从东北撤军，扶持东北根据地和东北民主联军，继续向中国施加压力。1945年底，副外长洛索夫斯基在蒋经国访苏前给斯大林的报告中作了全面论述：“第一，中国政府必须承认蒙古人民共和国独立；第二，中国必须保证长春铁路沿线的安全，……”。\n（中央社重庆五日电）国府于一月五日发表承认外蒙独立之公告如下：外蒙古人民于民国卅四年十月廿日举行公民投票，中央曾派内政部次长雷法章前往观察，近据外蒙古投票事务人员之报告，公民投票结果，已证实外蒙古人民赞成独立，兹照国防最高委员会之审议，法定承认外蒙古之独立，除由行政院转饬内政部将此项决议正式通知外蒙古政府外，特此公告。“”《国民政府公告》（1946年1月6日）1946年1月5日，中华民国国民政府承认蒙古人民共和國独立[51]。\n雷法章事后声称此次“公民投票”：“其办理投票事务人员，对于人民投票名为引导，实系监视，且甚为严密”“此项公民投票据称为外蒙古人民重向世界表示独立愿望之行动，……人民实难表示自由之意志。”[49]中華民國政府同蘇聯交惡後，中華民國代表蔣廷黻曾於1947年8月27日於聯合國安理會開會時表示質疑此投票之公正性，發言稱：「吾人認為此事是吾人所不能接受之過份簡單的歷史，當適當時機來臨後，我國政府有從事進一步觀察之權利。」\n1949年10月1日，中华人民共和国成立，1949年10月2日，蘇聯公開承認中華人民共和國并與之建交。12月7日中華民國政府播迁台湾，中華民國外交部在1949年11月7日《與蘇聯斷絕邦交之聲明》中稱，《中蘇友好同盟條約》簽訂后，中國政府一向恪守該條約產生之一切義務，但是蘇聯卻違反條約，[52][53]。蘇聯屢次違約，但国民政府卻「為顧慮美國關係，遲未采取行動」[54]。1950年苏联和中华人民共和国签署了《中苏友好同盟互助条约》而废除了《中蘇友好同盟條約》。\n  蒙古人民共和国国旗（1945年－1992年）  蒙古人民共和国国徽（1960年－1991年）1952年，中華民國向聯合國控告蘇聯違反《中蘇友好同盟條約》中“不援助中共”等条件，聯合國大會2月1日以25票贊成，9票反對，24票棄權，通過聯合國大會505號決議譴責蘇聯，是為「控蘇案」。1952年10月13日，蒋中正在国民党的中央会议上，沉重地检讨说：「承認外蒙獨立的決策，雖然是中央正式通過一致贊成的，但我本人願負其全責。這是我個人的決策，是我的責任，亦是我的罪愆」。蔣還稱，放弃外蒙古「實在是一個幼稚的幻想，絕非謀國之道」；蔣中正還表示自己「對總理、對革命、對國家和人民應該引咎自責」。1953年2月20日美國總統艾森豪對國會正式否認雅爾達秘密協定的存在，中华民国政府2月23日宣布《中蘇友好同盟條約》失效，从而推翻对蒙古人民共和国的独立承认。2月25日，外交部正式廢除《中蘇友好同盟條約》。[54]\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的國民政府與外蒙古的《中蘇友好同盟條約》與承認獨立", "Tag": "算法设计"}
{"Answer": "主条目：聯合國安全理事會第166號決議1946年7月13日，中国驻美公使谭绍华博士向美国国务院电话通报：中国政府不支持（does not feel that it is in a position to work for or to support）外蒙进入联合国[55]。8月6日，中華民國駐聯合國代表徐淑希表示外蒙古加入联合国时机未到：“蒙古人民共和国在数月之前，尚为中国之一部分，称为外蒙古。其独立乃由选举之故，国民政府将为欢迎其加入联合国之一国家，吾人固竭诚期望其加入此国际机构。……国民政府于适当之时间到来时，侪以全力支持外蒙古要求入会申请。”[56]\n1946年外蒙古等五國申請加入联合国，中华民国赞成，英国、美国反对，外蒙的入会要求被安理會否決[57]，聯合國大會因此在1946年11月19日通過35號決議[58]，建議安理會重新審查五國的申請[59]。\n1947年7月28日，中華民國駐聯合國代表徐淑希在联合国安理會发表演說，指責蒙古人民共和国軍隊入侵中國新疆，反對外蒙古加入聯合國[60]。同年8月18日，安理会第186次会议，中华民国代表蒋廷黻以北塔山事件为由投票反对蒙古加入联合国。[61]这在聯合國大會引起安理會是否越權的討論[62]。\n1948年10月，朝鲜民主主义人民共和国承认蒙古人民共和国，1949年5月，阿尔巴尼亚也与蒙古建交。\n1955年12月13日，中华民国代表在安理會對联合国大會3502號草案中，蒙古人民共和国加入联合国的部分行使否決權，理由是全蒙古是中国的一部分[63][64][65][66][67]。\n1961年10月25日，联合国安理会以9票赞成，0票反对，1票（美国）弃权的表决结果，通过了聯合國安理會166號決議，建議聯合國大會接受蒙古國加入聯合國。中华民国未参加投票表决。10月27日，联合国大会通过第1630号决议案，接纳蒙古人民共和国加入联合国，中华民国未参加表决[68][69]。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的國民政府與外蒙古的蒙古加入联合国", "Tag": "算法设计"}
{"Answer": "参见：中華民國—蒙古國關係法律關係[编辑]中華民國行憲前聲索外蒙古的法規以及草案有：\n民國元年（1912年），中華民國臨時約法第三條：「中華民國領土為二十二行省、內外蒙古、西藏青海。」\n民國20年（1931年），中華民國訓政時期約法第一條：「中華民國領土為各省及蒙古西藏。」\n同年制定公布蒙古盟部旗組織法時，第四條第二項提到車臣、土謝圖、三音諾顏、扎薩克圖、塞音濟雅哈圖、唐努烏梁海[註 5]、青塞特奇勒圖、烏拉恩素珠克圖、巴圖塞特奇勒圖各部，而第八條以及第九條提到蒙古地方。\n民國25年（1936年），五五憲草第四條：「中華民國領土為……、新疆、蒙古、西藏等固有之疆域。」\n民國35年（1946年），中華民國承認蒙古人民共和國獨立時，尚未舉行國大代表選舉乃至於制憲，故憲法中之固有疆域已不包括蒙古國。\n民國36年（1947年），內政部發布《中華民國行政區域簡表》凡例八：「蒙古地方雖經我政府於民國35年1月5日承認其獨立，但詳確疆界，尚待勘定。」關于國民政府放棄了對外蒙古的主權，顧維鈞這樣寫道：[70]\n\n「 我仍然無法理解為什麼我們在莫斯科的代表團認為非得向蘇聯做出超過需要之外的讓步不可。即使從英國的觀點來看，中國在外蒙問題上是能夠不讓步的，美國的國務卿貝爾納斯也持有同樣的看法。這是貝爾納斯在1945年9月從莫斯科來參加倫敦五國外長會議時在倫敦對我說的。然後他問我為什麼我們做出了不必要的讓步，他指的是蒙古。我雖不理解為什麼這樣做，但覺得這個評論進一步證實了艾登(英國的外相)對我說的話是有理由的。我對中國在莫斯科所采取的立場自然是極感失望的，我設想一定有不得不這樣做的理由。我希望有朝一日能夠公開當年我們的重慶政府為什麼決定不惜任何代價與蘇聯締結這個條約的全部理由。」  1947年中華民國全圖，當中的外蒙古部分標註「已經我國承認其獨立。」民國36年（1947年）12月25日施行中華民國憲法以及公布訓政結束程序法時，憲法第四條：「中華民國領土，依其固有之疆域，非經國民大會之決議，不得變更之。」\n制憲國民大會代表中的「蒙古代表」是指境內蒙古族的代表，主要來自塞北四省、新疆、青海的蒙古盟旗：\n\n蒙古西藏之代表四十名，在蒙古方面（一）由錫林郭勒盟，烏蘭察布盟，伊克昭盟，青海左翼盟，青海右翼盟，察哈爾部及阿拉善特別旗，額濟納特別旗，土默特特別旗選出者九名。（二）由巴圖塞特奇勒圖中路盟，烏拉恩素珠球克圖四路盟，及青塞特奇勒圖盟選出者三名。（三）由哲里木盟，卓索圖昭盟，昭烏達盟，呼倫貝爾部，及伊克明安特別旗選出者五名，（四）由其他蒙古盟旗選出者七名當時，雲南省代表段克昌等曾提案將固有疆域改為列舉方式[71]：\n本條擬修改為「中華民國為江蘇、浙江、安徽、江西、湖北、湖南、四川、西康、河北、山東、山西、河南、陝西、甘肅、青海、褔建、廣東、廣西、雲南、貴州、新疆、察哈爾、綏遠、寧夏、遼寧、安東、遼北、吉林、松江、合江、黑龍江、嫩江、興安、熱河、台灣、蒙古、西藏、及其他固有之彊域，非經國民大會議決，不能變更之。」行憲後，第一屆國民大會代表、立法委員及監察委員都是由生活在上述幾省中的蒙胞或其代表依憲法選出。\n民國42年（1953年），立法院決議廢止「中蘇友好同盟條約」、撤銷對蒙古獨立的外交承認。\n  1979年5月《第一屆國民大會第六次會議實錄》所附的《中華民國全圖》國民大會秘書處自民國68年（1979年）5月至民國80年（1991年）10月所編的《會議實錄》所附的《中華民國全圖》都宣稱法理的中華民國疆域包括外蒙古。[72]\n  1986年起沿用原中華民國公告疆域行政區劃的中華民國海軍陸戰隊#隊旗，包含中國大陸、外蒙古、唐努烏梁海等地中國國民黨的蔣經國政府期間製訂的《陸海空軍軍旗條例》1986年附圖二之九，2002年附圖二之八，以至2022年附圖二之七，中華民國海軍陸戰隊#隊旗，沿用原中華民國公告疆域行政區劃像秋海棠。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的中華民國與外蒙古關係", "Tag": "算法设计"}
{"Answer": "中華民國行憲前聲索外蒙古的法規以及草案有：\n民國元年（1912年），中華民國臨時約法第三條：「中華民國領土為二十二行省、內外蒙古、西藏青海。」\n民國20年（1931年），中華民國訓政時期約法第一條：「中華民國領土為各省及蒙古西藏。」\n同年制定公布蒙古盟部旗組織法時，第四條第二項提到車臣、土謝圖、三音諾顏、扎薩克圖、塞音濟雅哈圖、唐努烏梁海[註 5]、青塞特奇勒圖、烏拉恩素珠克圖、巴圖塞特奇勒圖各部，而第八條以及第九條提到蒙古地方。\n民國25年（1936年），五五憲草第四條：「中華民國領土為……、新疆、蒙古、西藏等固有之疆域。」\n民國35年（1946年），中華民國承認蒙古人民共和國獨立時，尚未舉行國大代表選舉乃至於制憲，故憲法中之固有疆域已不包括蒙古國。\n民國36年（1947年），內政部發布《中華民國行政區域簡表》凡例八：「蒙古地方雖經我政府於民國35年1月5日承認其獨立，但詳確疆界，尚待勘定。」關于國民政府放棄了對外蒙古的主權，顧維鈞這樣寫道：[70]\n\n「 我仍然無法理解為什麼我們在莫斯科的代表團認為非得向蘇聯做出超過需要之外的讓步不可。即使從英國的觀點來看，中國在外蒙問題上是能夠不讓步的，美國的國務卿貝爾納斯也持有同樣的看法。這是貝爾納斯在1945年9月從莫斯科來參加倫敦五國外長會議時在倫敦對我說的。然後他問我為什麼我們做出了不必要的讓步，他指的是蒙古。我雖不理解為什麼這樣做，但覺得這個評論進一步證實了艾登(英國的外相)對我說的話是有理由的。我對中國在莫斯科所采取的立場自然是極感失望的，我設想一定有不得不這樣做的理由。我希望有朝一日能夠公開當年我們的重慶政府為什麼決定不惜任何代價與蘇聯締結這個條約的全部理由。」  1947年中華民國全圖，當中的外蒙古部分標註「已經我國承認其獨立。」民國36年（1947年）12月25日施行中華民國憲法以及公布訓政結束程序法時，憲法第四條：「中華民國領土，依其固有之疆域，非經國民大會之決議，不得變更之。」\n制憲國民大會代表中的「蒙古代表」是指境內蒙古族的代表，主要來自塞北四省、新疆、青海的蒙古盟旗：\n\n蒙古西藏之代表四十名，在蒙古方面（一）由錫林郭勒盟，烏蘭察布盟，伊克昭盟，青海左翼盟，青海右翼盟，察哈爾部及阿拉善特別旗，額濟納特別旗，土默特特別旗選出者九名。（二）由巴圖塞特奇勒圖中路盟，烏拉恩素珠球克圖四路盟，及青塞特奇勒圖盟選出者三名。（三）由哲里木盟，卓索圖昭盟，昭烏達盟，呼倫貝爾部，及伊克明安特別旗選出者五名，（四）由其他蒙古盟旗選出者七名當時，雲南省代表段克昌等曾提案將固有疆域改為列舉方式[71]：\n本條擬修改為「中華民國為江蘇、浙江、安徽、江西、湖北、湖南、四川、西康、河北、山東、山西、河南、陝西、甘肅、青海、褔建、廣東、廣西、雲南、貴州、新疆、察哈爾、綏遠、寧夏、遼寧、安東、遼北、吉林、松江、合江、黑龍江、嫩江、興安、熱河、台灣、蒙古、西藏、及其他固有之彊域，非經國民大會議決，不能變更之。」行憲後，第一屆國民大會代表、立法委員及監察委員都是由生活在上述幾省中的蒙胞或其代表依憲法選出。\n民國42年（1953年），立法院決議廢止「中蘇友好同盟條約」、撤銷對蒙古獨立的外交承認。\n  1979年5月《第一屆國民大會第六次會議實錄》所附的《中華民國全圖》國民大會秘書處自民國68年（1979年）5月至民國80年（1991年）10月所編的《會議實錄》所附的《中華民國全圖》都宣稱法理的中華民國疆域包括外蒙古。[72]\n  1986年起沿用原中華民國公告疆域行政區劃的中華民國海軍陸戰隊#隊旗，包含中國大陸、外蒙古、唐努烏梁海等地中國國民黨的蔣經國政府期間製訂的《陸海空軍軍旗條例》1986年附圖二之九，2002年附圖二之八，以至2022年附圖二之七，中華民國海軍陸戰隊#隊旗，沿用原中華民國公告疆域行政區劃像秋海棠。\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的中華民國與外蒙古關係的法律關係", "Tag": "算法设计"}
{"Answer": "1922年，中共创始人之一的李大钊曾公开向北洋政府请愿，要求正式承认苏联政府，并且支持蘇聯武裝力量驻兵外蒙古。据北洋政府外长顾维钧回忆，當時李激昂地宣稱“把外蒙置于苏俄统治下，那里的人民可以生活得更好”。[87]1920年代末期，当時由李立三、周恩来等人领导的「中华蘇維埃共和国政府」曾指出說：「最無恥地，到現在國民黨政府還不承認外蒙古是獨立自主的人民共和國，而把外蒙古看成中華民國的附庸」（一九二九年《布爾塞維克》第十期）。\n1931年11月7日公布的《中华苏维埃共和国宪法大纲》主张“中华苏维埃政权承认中国境内少数民族的民族自决权，一直承认到各弱小民族有同中国脱离，自己成立独立的国家的权利。蒙古、回、藏、苗、黎、高丽人等，凡是居住在中国的地域的，他们有完全自决权：加入或脱离中国苏维埃联邦，或建立自己的自治区域。”[88]\n1935年11月，毛泽东在一次会议上指出：“日本帝国主义不但要灭亡中国，并且还想进攻苏联的西伯利亚和灭亡蒙古人民共和国。我们的胜利告诉他们：‘假如日本帝国主义进攻你们的话，我们是要打它的侧翼和后路的。’”[89]\n1939年12月《中国革命与中国共产党》一书的第一章明确提出，现在中国的国境：在东北、西北和西境的一部与社会主义苏维埃共和国联盟接壤。而1952年4月出版的《毛泽东选集》第二卷〈中国革命和中国共产党〉一章中加上了，“正北面，和蒙古人民共和国接壤”（原始版本1939年12月《中国革命与中国共产党》一书的第一章中並沒有這句話）[90][91][92]。\n1940年1月，《日支新關係調整要綱》祕文在香港披露，日本意圖以滿洲國、吳越平原為根據地，來交換承認外蒙、新疆、西藏為蘇俄勢力範圍。\n1941年4月，蘇聯與日本簽署《蘇日中立條約》、《共同宣言》，其宣言內有：「……蘇聯誓當尊重滿州國之領土完整與神聖不可侵犯性，日本誓當尊重蒙古人民共和國之領土完整與神聖不可侵犯性」。中国共产党則對《蘇日中立條約》表態：「却保证了外蒙不受侵犯，这不但对外蒙有利，即对全中国争取解放也是有利的。说到东四省的收复，原是我们自己的事」[93]，並為此發表社論[94]。\n1947年6月－1948年7月的北塔山事件中，中国共产党支持苏联和蒙古的立场，声称此次边界冲突是国民党挑衅、美国驻迪化领事馆所策划。1947年7月，中国共产党在吐鲁番、鄯善和托克逊三县组织群众集会和示威游行，抗议国民政府针对蒙古的军事行动，约500名平民在新疆警备总司令部的镇压中丧生。\n1949年1月，毛泽东曾非正式地试图通过阿那斯塔斯·伊萬諾維奇·米高揚向苏联提出要求，希望外蒙古回归中国，成为革命后新中国领土的一部分，但遭到拒绝[95]。毛泽东随后表示“不保护大汉族沙文主义路线，不再提出蒙古统一的问题。”[96]3月5日毛澤東在七屆二中全會上表示：不承認國民黨時代的任何外國外交機關和外交人員的合法地位，不承認國民黨時代的一切條約。中蘇后來發表公告稱：“1945年8月14日中苏签订的条约约定均已失去效力，但双方政府确认，蒙古人民共和国的独立地位已因1945年的公民投票及中华人民共和国业已与其建立外交关系而获得了充分保证。”[97]\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的中華民國與外蒙古關係的中華民國大陸時期中國共產黨對外蒙古的態度", "Tag": "算法设计"}
{"Answer": "参见：中國－蒙古國關係中华人民共和国成立后，宣布继承中华民国的国际法地位[98]，在中华民国已经于1946年承认蒙古人民共和国的基础上发展对蒙外交[99]，1949年10月16日，周恩来总理兼外长复函蒙古总理兼外长乔巴山，两国建立大使级外交关系[99]。\n1949年8月14日，人民日报第一版刊載郭沫若在8月12日為《中苏同盟四周年:中苏友好同盟条约四周年纪念日在北平新华广播电台对全国的广播词》[100]的文作，名為《我们应该怎样认识外蒙古独立》，支持及承認蒙古人民共和国的独立地位[101]，1950年2月24日人民日報發表了中共黨史學家胡華的文章，名為《关于承认和保证蒙古人民共和国的独立地位》[102]，該文提到：「承認蒙古獨立，對每個真正愛國的中國人來說，是天經地義的事，值得歡呼的事。只有國民黨反動派才痛恨蒙古獨立，......侮蔑人民的蒙古，侮蔑蘇聯說：‘蒙古獨立是中國領土的喪失’」[103]\n[104][105][106][107]。\n1949年到1950年，毛泽东和苏联签署新的友好协议。斯大林和毛泽东共同宣称废除国民党的“不平等条约”。1950年毛泽东出访苏联，為爭取蘇聯的外交支持，签订《中苏友好同盟互助条约》。[108] 1961年中国人民邮政发行邮票庆贺“蒙古人民革命四十週年”。[109][110]\n1952年4月出版的《毛泽东选集》第二卷〈中国革命和中国共产党〉一章中明确提出，“正北面，和蒙古人民共和国接壤”（原始版本1939年12月《中国革命与中国共产党》一书的第一章中並沒有這句話）[90][91][92]。\n1954年，赫魯曉夫來華參加中華人民共和國建國五週年之際，毛澤東透過周恩來向赫魯曉夫詢問如何看待外蒙古併入中國。赫魯曉夫表示蒙古同志「不會歡迎你們的建議」[111]。\n1960年5月31日，在乌兰巴托签订《中蒙友好互助条约》，同年10月12日生效。1962年12月26日，中华人民共和国总理周恩来与蒙古人民共和国部长会议主席尤睦佳·泽登巴尔在北京签订《中蒙边界条约》，1963年3月25日在乌兰巴托互换批准书后生效，以实际控制线为基础划定边界。1960年代中苏决裂后，蒙古试图保持中立，后来被迫倒向苏联，把大约7000名中国的援建人员驱逐回国。\n1989年2月，中共領導人鄧小平對美國總統乔治·H·W·布什抱怨，雅爾達會議不但使外蒙從中國分離出去，而且使中國東北成為蘇聯勢力範圍。[112][113][114]為實現中蘇關係正常化，蘇聯領導人戈巴契夫於1989年春夏之交訪華。期間鄧小平在1989年5月16日對訪華的戈巴契夫說：“六十年代，在整个中苏、中蒙边界上苏联加强军事设施，导弹不断增加，相当于苏联全部导弹的三分之一，军队不断增加，包括派军队到蒙古，总数达到了一百万人。……真正的实质问题是不平等，中国人感到受屈辱。”[115]\n  蒙古国国旗（2011年起）苏联撤军后，中蒙关系缓和。1990年，蒙古代表团28年来第一次正式访问中国。1994年两国签订《中蒙友好合作关系条约》，表示互相尊重国家主权和领土完整。[116]\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的後續", "Tag": "算法设计"}
{"Answer": "\n^ 南方代表曾以參加歐戰為名向日本大量借款，擴編「參戰軍」，但歐戰結束都已結束仍參而不戰，實際用於內戰，中國南北議和後，1919年6月17日提出西北籌邊計畫。\n\n^ 宣統末年，因疾雙眼失明。\n\n^ 1919年蘇維埃第五次會議裡，蘇聯外交部長格奧爾基·契切林宣佈蘇方放棄在中國一切特權；7月，列夫·米哈伊洛維奇·加拉罕正式簽署加拉罕宣言，願放棄帝俄時代从中國一切所得。\n\n^ 蔣經國追問這個軍事力量是不是美國，史達林朗然回答：“當然!”\n\n^ 上述盟部分布于今蒙古国和俄罗斯联邦境内。\n\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的注释", "Tag": "算法设计"}
{"Answer": "蒙古历史\n民族解放运动\n1917年－1923年革命\n蒙古獨立史", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的參見", "Tag": "算法设计"}
{"Answer": "引用[编辑]\n\n^ Мянга есөн зуун хорин нэгэн оны Үндэсний ардчилсан хувьсгал [蒙古民族民主革命]. Монголын түүх.   [2019-06-26]. （原始内容存档于2019-06-26） （蒙古语）. \n\n^ ［俄］巴尔苏科夫《穆拉维约夫--阿穆尔斯基伯爵》第2卷，第111页。东正教出版社，1891年\n\n^ БАЗАРОВ, Виктор Борисович. РОССИЙСКАЯ ПОЛИТИКА В ОТНОШЕНИИ МОНГОЛИИ В НАЧАЛЕ ХХ в.. ВЛАСТЬ.   [2017]. （原始内容存档于2021-06-24） （俄语）. \n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第5-6頁\n\n^ 薛人仰主編，周昆田著，蒙藏民族史略，台灣中華書局，1982年6月版，第48頁\n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第13-14頁\n\n^ 7.0 7.1 梁鹤年. 《库伦独立始末记》. \n\n^ 陈崇祖. 外蒙古近世史 第二版. 1926: 253. \n\n^ 周学军; 白剑光. 《库伦独立始末记》订误. 内蒙古社会科学. 2000年, (第6期)  [2019-06-25]. （原始内容存档于2019-07-22）.  引文使用过时参数coauthors (帮助)\n\n^ 《宣统政纪》. : 卷六五、卷六九. \n\n^ А.А. Сизова. КОНСУЛЬСКАЯ СЛУЖБА РОССИИ в МОНГОЛИИ (1861–1917) (PDF). МОСКВА. 2015  [2022-04-23]. ISBN 978-5-02-036596-4. （原始内容存档 (PDF)于2021-06-24） （俄语）. \n\n^ Ховдыг чөлөөлөх байлдаан. Tolgoilogch.mn.   [2021-06-20]. （原始内容存档于2021-01-25） （蒙古语）. \n\n^ 阿拉坦巴根. 1913年锡林郭勒—察哈尔战事初探. 2008  [2019-09-27]. （原始内容存档于2019-09-27）. \n\n^ 周太平. 关于“牛年之乱”的一个考察. 《蒙古史研究》. 2007, (第九辑). \n\n^ 杜亞泉《獨立後之庫倫及俄蒙協約》\n\n^ 袁世凯签订《中俄蒙协约》始末. 星岛环球网. 2010-02-08  [2013-07-11]. （原始内容存档于2010-04-16） （中文（简体））. \n\n^ С.Чулуун. МОНГОЛЫН ТУСГААР ТОГТНОЛ НОЁДЫН ҮХЭЛ (1911-1919) [蒙古獨立諸侯之死]. Tagtaa solution. Түүхийн хүрээлэнгийн захирал.   [2021-06-27]. （原始内容存档于2022-03-31） （蒙古语）. \n\n^ Хишигт Н. Гадаад Монголын  өөртөө засах засгийг устгасан түүхийн асуудалд-//МУИС. НШУС “Түүх YII”. УБ: Эрдэм  шинжилгээний  бичиг. 2008: 139–149 （蒙古语）. \n\n^ 不是一次孤立事件：中苏边界冲突的缘起和结果_cctv.com提供. news.cctv.com.   [2021-11-18]. （原始内容存档于2021-11-18）. \n\n^ 董樹藩 主編，李毓澍 著，從蒙共六十年來演變對外蒙現況的探討，1985年5月版，(中華民國)蒙藏委員會出版，第2-3頁\n\n^ 曹心宝. 徐树铮与皖系兴亡研究. 广西师范大学出版社. 2016  [2021-06-27]. ISBN 978-7549581085. （原始内容存档于2021-06-28）. \n\n^ HIROSHI FUTAKI. A Re-examination of the Establishment of the Mongolian People's Party, Centring on Dogsom's Memoir. Inner Asia. 2000, (Vol. 2, No. 1, celebrating the 80th birthday of Urgunge Onon): 37–60  [2021-06-27]. （原始内容存档于2021-06-28）. \n\n^ 董樹藩 主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第26-29頁、第34-36頁\n\n^ 劉學銚，外蒙古問題，南天書局，2001年3月，ISBN 9576385687，38頁\n\n^ 唐德剛《袁氏當國》一書中曾提到「錯在老徐（徐樹錚）」\n\n^ 董樹藩主編，論內外蒙分界問題，1985年2月版，(中華民國)蒙藏委員會出版，第5-6頁\n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第44-45頁\n\n^ 劉學銚，外蒙古問題，南天書局，2001年3月，ISBN 9576385687，第41頁、第103頁\n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第46頁\n\n^ Pershin, D. P. (Dmitriĭ Petrovich). Барон Унгерн, Урга и Алтан-Булак: Записки очевидца о смутном времени во Внешней (Халхаской) Монголии в первой трети ХХ века. Издательский дом \"Агни\". 1999  [2021-06-20]. ISBN 9785898500030. （原始内容存档于2021-01-18） （俄语）. \n\n^ 薛人仰主編，周昆田著，蒙藏民族史略，台灣中華書局，1982年6月版，第44頁\n\n^ 俄境内现唐代古城 斯大林侵占中国领土往事揭秘. 环球网.   [2021-11-18]. （原始内容存档于2022-03-09）. \n\n^ Eric Her. THE “GREAT GAME”: MONGOLIA BETWEEN RUSSIA AND CHINA. The Mongolian Journal of International Affairs. 1997  [2021-06-20]. （原始内容存档于2019-04-28）. \n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第47-49頁\n\n^ Орлов А.С; Георгиева Н.Г; Георгиев В.А. Советско-монгольское соглашение 1921 г., 5 ноября. Исторический словарь. 2012, (2-е изд): 478  [2021-06-20]. （原始内容存档于2020-12-05） （俄语）. \n\n^ THE SUN-JOFFE AGREEMENT (1923). Alphahistory. \n\n^ 王春良; 李威. 论苏联是怎样把中国的外蒙古分裂出去的. 聊城大学学报(社会科学版). 2009, (05): 53–64  [2022-04-16]. ISSN 1672-1217. doi:10.16284/j.cnki.cn37-1401/c.2009.05.019. （原始内容存档于2022-04-16）. \n\n^ 董樹藩主編，論內外蒙分界問題，1985年2月版，(中華民國)蒙藏委員會出版，第10頁\n\n^ 劉學銚，外蒙古問題，南天書局，2001年3月，ISBN 9576385687，56頁\n\n^ 据新华社1949年8月15日电\n\n^ 41.0 41.1 41.2 《風雨中的寧靜》，蔣經國\n\n^ 42.0 42.1 42.2 《中蘇友好同盟條約之簽訂與其內幕真相》，梁敬錞\n\n^ 斯大林迫使中国接受外蒙古独立：没力量别讲废话 （页面存档备份，存于互联网档案馆），星岛环球网，2006-12-19，2007年7月23日查阅\n\n^ 王世杰、胡慶育. 《中國不平等條約之廢除》. 雅爾達協定規定：“外蒙（蒙古人民共和國）的現狀應予保持。”我方認為這只是申明當時的情勢：即蒙古自稱獨立，中國中央政府保持沉默。 \n\n^ 王世杰、胡慶育《中國不平等條約之廢除》\n\n^ 《蒋经国传》，江南\n\n^ 秦孝仪主编，中华民国重要史料初编——对日抗战时期，第七编，战后中国（一），臺灣臺北：中国国民党中央委员会党史委员会，1981年，第166页\n\n^ 蔣中正. 完成民族主義維護國際和平. 《總統蔣公思想言論總集》.   [2020-01-15]. （原始内容存档于2021-10-28）. \n\n^ 49.0 49.1 《奉派赴外蒙參觀公民投票之經過》，雷法章\n\n^ Nohlen, D, Grotz, F & Hartmann, C (2001) Elections in Asia: A data handbook, Volume II, p491 ISBN 978-0-19-924959-6\n\n^ 国民政府发表公告承认外蒙独立，中央日报（上海版），第2版\n\n^ 《與蘇聯斷絕邦交之聲明》，1949年11月7日，中華民國外交部\n\n^ 1967年11月4日，《中央日報》：「今年九月三日和十月四日，莫斯科電臺華語廣播一再聲稱：蘇俄為支持共匪，曾于中日戰爭剛結束的時候，在中國東北給予毛匪澤東以大量的武器，并列舉武器的種類與數量，廣播中并稱：蘇俄派兵前往東北，其目的是在阻止中華民國軍隊進入東北，與輔助毛匪澤東造反，而將日軍繳交大批武器給予共匪，并與共匪合作，攫取政府軍的重要據點。」\n\n^ 54.0 54.1 邵毓麟. 《奉派駐韓外交代表又無疾而終》. 《傳記文學》. Vol. 第三十一卷 no. 第六期. \n\n^ 美国国务院档案. 美国国务院.   [2017-06-10]. （原始内容存档于2021-07-03）. \n\n^ 揭秘外蒙古独立始末. 世界军事网.   [2013-04-13]. （原始内容存档于2013-04-27）. \n\n^ S/PV.57 - C - S/PV.57 -Desktop. undocs.org: 六七.   [2021-09-17]. （原始内容存档于2022-02-28）. \n\n^ A/RES/35(I). \n\n^ General Assembly Resolutions 1st Session. 聯合國. resolution 35 (I):Question of the Re-examination by the Security Council of Certain Application for Admission to Membership in the United Nations.   [2013-05-16]. （原始内容存档于2013-03-09）. （英文）\n\n^ 徐淑希演說　認外蒙無入會資格 (pdf). 大公報. 1947年7月30日  [2013年4月16日]. （原始内容存档于2014年3月31日）. \n\n^ S/PV.186 - C - S/PV.186. undocs.org.   [2020-03-01]. （原始内容存档于2020-02-20）. \n\n^ 聯合國1946-1947年年鑑 (PDF). 聯合國.   [2013-04-16]. （原始内容 (PDF)存档于2009-05-21）. （英文）\n\n^ 因常任理事国投反对票而未获通过的决议草案或修正案各段 (PDF). 聯合國.   [2013-02-07]. （原始内容存档 (PDF)于2014-03-23）. \n\n^ The veto and how to use it. BBC News Online.   [2013-02-07]. （原始内容存档于2010-07-26）. （英文）\n\n^ Changing Pattern in the Use of Veto in the Security Council. Global Policy Forum.   [2013-02-07]. （原始内容存档于2013-05-08）. （英文）\n\n^ Subjects of UN Security Council Vetoes. Global Policy Forum.   [2013-02-07]. （原始内容存档于2013-01-16）. （英文）\n\n^ S/PV.704 - C - S/PV.704. undocs.org.   [2020-03-01]. （原始内容存档于2021-05-30）. \n\n^ Text of the Resolution. 联合国官网.   [2019-10-03]. （原始内容存档于2019-07-04）. \n\n^ A/PV.1043 - C - A/PV.1043. undocs.org.   [2020-03-01]. （原始内容存档于2019-10-03）. \n\n^ 《顧維鈞回憶錄》\n\n^ 制憲國民大會的雲南籍代表及貢獻. 台北市雲南省同鄉會.   [2020-09-06]. （原始内容存档于2022-02-05）. \n\n^ 立法院國會圖書館電子藏書：國民大會歷次會議實錄 （页面存档备份，存于互联网档案馆）：《第一屆國民大會第六次會議實錄》，1979年5月；《第一屆國民大會第七次會議實錄》，1985年5月；《第一屆國民大會第八次會議實錄》，1991年4月；《第一屆國民大會第二次臨時會實錄》，1991年10月 ：《中華民國全圖》\n\n^ 司法院. 司法院全球資訊網. 司法院. 2019-05-06  [2020-06-04]. （原始内容存档于2020-05-28）. \n\n^ 邱政宗. 中華民國立法院法制局研究成果《外蒙古定位後續問題評析》. 2002年3月 [民國91年3月]. （原始内容存档于2018-02-03）. \n\n^ 官方地圖 將標示蒙古為國家 （页面存档备份，存于互联网档案馆）, 自由時報, 2002年10月3日\n\n^ Mongolian office to ride into Taipei by end of the year, Taipei Times, 2002-10-11  [2008-02-05], （原始内容存档于2018-10-01） \n\n^ 駐外館處. 中華民國外交部.   [2016-09-02]. （原始内容存档于2017-06-21）. \n\n^ 駐華外國機構. 中華民國外交部.   [2016-09-02]. （原始内容存档于2021-01-09）. \n\n^ 蒙古國 （页面存档备份，存于互联网档案馆），中華民國外交部\n\n^ 行政院大陸委員會：有關外蒙古是否為中華民國領土問題說明新聞參考資料 （页面存档备份，存于互联网档案馆）\n\n^ 內政部函：「一、本部前曾於民國87年出版「中華民國全圖」，後因考量銷售量偏低、圖資內容不符現況，目前已停止銷售。」\n\n^ 台当局弃用「中华民国全图」.   [2012-10-17]. （原始内容存档于2012-04-23）. \n\n^ 大陸地圖 得依中國現狀標示 （页面存档备份，存于互联网档案馆）, 自由時報, 2002年11月30日\n\n^ 官方地圖 將標示蒙古為國家 （页面存档备份，存于互联网档案馆）, 自由時報, 2002年10月3日\n\n^ 蒙藏委員會 今併入文化部.   [2017-09-30]. （原始内容存档于2017-09-21）. \n\n^ 中央通訊社. 蒙藏委員會 最快8月底裁撤. 聯合新聞網. 2017年8月14日  [2017年9月30日]. （原始内容存档于2017年9月30日）. \n\n^ [失效連結]袁南生. 晚清以来的外交与新的心态. 学习时报. 2012-01-16: 第12版：参考文摘 （中文（中国大陆））. 1922年8月，外交总长顾维钧对来访的苏俄副外交人民委员越飞表示，中苏建交的先决条件是苏军从外蒙古撤离。顾维钧的立场毫无疑问是正确的，但奇怪的是，苏军侵入面积等于43个台湾、140个香港的外蒙古，国人舆论却并不站在顾维钧这一边，相反却要求北京政府“无条件与苏俄建交”。此时，不但北京大学生上街示威，新闻机构对外交部大加鞭挞，李大钊也亲自找到顾维钧，对顾的立场表示愤慨，甚至说“把外蒙置于苏俄的统治之下，那里的人民有可能生活得更好”，孙中山也对顾的做法表示反对，到了最后，居然连以吴佩孚为首的各地军阀将领都发电报到外交部，指责顾维钧。 [永久失效連結]顾维均回忆录\n\n^  中華蘇維埃共和國憲法大綱. 维基文库. 1931年 （中文）. \n\n^ 谈毛泽东眼里的中国抗战. 中国经济网.   [2021-11-19]. （原始内容存档于2021-11-19）. \n\n^ 90.0 90.1 《毛泽东选集，第二卷》 第2版. 人民出版社. 1991年6月  [2014-08-07]. （原始内容存档于2015-10-16）. 。見竹內實編《毛澤東集·第七卷·延安期Ⅲ》收錄的該篇文章以及該文1944年毛選版和1950年代人民出版社版毛選的對比。\n\n^ 91.0 91.1 中國革命與中國共產黨（未刪節本）. 马克思主义文库. 1939年12月15日  [2014年8月7日]. （原始内容存档于2014年8月8日）. \n\n^ 92.0 92.1 劉益濤. 《中國革命和中國共產黨》. 中共黨史出版社. 2007年6月15日  [2014年8月7日]. （原始内容存档于2016年3月4日）. \n\n^ 中国共产党对苏日中立条约发表意见. 新華網.   [2013-02-08]. （原始内容存档于2010-09-21）. \n\n^ 1941年(民國30年)4月15日，重慶新華日報社論，……這絲毫不能也沒有變更中國的領土主權，這本是蘇日過去的關係上長久已存在的事實\n\n^ 据中国历史学家沈志华所编《朝鲜战争：俄罗斯国家解密档案》中引述的《米高扬就1949年1-2月中国之行给苏共中央主席团的报告》所说：“关于蒙古。毛泽东主动问我们如何对待外蒙和内蒙的统一。我回答说，我们不主张这样的统一，因为这可能导致中国失去一大块领土。毛泽东说，他认为外蒙和内蒙可以联合起来并入中国版图。我对他说，这是不可能的，因为蒙古人民共和国已享有独立，日本投降之后中国政府承认了外蒙的独立。蒙古人民共和国有自己的军队，有自己的文化，以及文化和经济发展的道路，它早就领略了独立的滋味，任何时候都未必会自愿放弃独立。如果什么时候它和内蒙合并，那一定是成立统一的独立的蒙古。”（摘自 俄档案：毛泽东曾两次要求外蒙古回归中国 （页面存档备份，存于互联网档案馆））\n\n^ 据中国历史学家沈志华所编《朝鲜战争：俄罗斯国家解密档案》中引述的《米高扬就1949年1-2月中国之行给苏共中央主席团的报告》  俄档案：毛泽东曾两次要求外蒙古回归中国 （页面存档备份，存于互联网档案馆）\n\n^ 《師哲回憶錄》\n\n^ 从联合国2758号决议看台湾的“中华民国”地位. 联合早报. \n\n^ 99.0 99.1 马保奉：新中国建交内情（五）（礼仪漫谈）——与朝、蒙、越建交 （页面存档备份，存于互联网档案馆）. 人民日报海外版\n\n^ 中苏同盟四周年——中苏友好同盟条约四周年纪念日在北平 新华广播电台对全国的广播词. laoziliao.net.   [2020-03-01]. （原始内容存档于2021-12-19）. \n\n^ 郭沫若：我们应该怎样认识外蒙古独立？ （页面存档备份，存于互联网档案馆）\n\n^ 关于承认和保证蒙古人民共和国的独立地位. laoziliao.net.   [2020-03-01]. （原始内容存档于2021-12-19）. \n\n^ 摘自人民日报1949年8月14日第一版刊登的郭沫若写于8月12日的文章《中苏同盟四周年——中苏友好同盟条约四周年纪念日在北平新华广播电台对全国的广播词》。我们应该怎样认识外蒙古独立？ （页面存档备份，存于互联网档案馆）\n\n^ 胡華:中苏问题讲话，pp.29-34\n\n^ 胡華：我們應不應該承認外蒙獨立？.   [2019-08-25]. （原始内容存档于2016-03-09）. \n\n^ 胡華. 《人民日报》：关于承认和保证蒙古人民共和国的独立地位. 共识网. 2010-08-21  [2017-06-28]. （原始内容存档于2016-06-14）. \n\n^ 人民日報早年文章聲稱釣魚島屬於日本. RFI - 法國國際廣播電台. 2012-08-22  [2022-04-23]. （原始内容存档于2021-12-19）. \n\n^ 1949年12月至1950年3月，歷時89日，毛澤東為了與斯大林簽訂《中蘇友好同盟互助條約》，曾對周恩來說：「我們還要搞一個聲明。中華人民共和國成立時，我們已經宣布過舊中國與外國簽定的一切國際協定、條約一概不予承認。但外蒙古獨立是一個例外。外蒙古獨立是國民黨政府辦理的，但是我們尊重蒙古人民1945年的公民投票，他們一致擁護獨立。現在雙方政府經過談判確認蒙古人民共和國的獨立地位。蘇聯也表示支持中國這一立場，同時也希望蒙古發表聲明表個態。」周說：「這樣做比較好。」見汪東興著，〈隨毛主席第一次出訪蘇聯〉，刊《汪東興日記》，第195頁\n\n^ 郵票上的五星紅旗. 中国邮政报. 2017-10-02  [2017-11-13]. （原始内容存档于2017-11-14）. \n\n^ 纪89邮票，庆祝蒙古人民革命四十周年,价格,图片,最新. 百分邮票收藏网.   [2017-11-13]. （原始内容存档于2017-11-14）. \n\n^ 毛泽东两次提出外蒙回归.   [2013-04-14]. （原始内容存档于2016-03-04）. \n\n^ George Bush; Brent Scowcroft. A World Transformed. Knopf. 1998年: 第95-96頁. ISBN 978-0-679-43248-7. （英文）\n\n^ David M. Lampton. 同床異夢: 處理1989至2000年之中美外交. 計秋楓譯. 香港中文大學. 2003年: 第6頁  [2014-04-08]. ISBN 978-962-996-108-4. （原始内容存档于2014-09-25）. \n\n^ John Tkacik. Briefing :: Mongolia Moves Toward Europe. 美國: 欧洲安全与合作委員會（英语：Commission on Security and Cooperation in Europe）. 2011-10-12  [2014-04-07]. （原始内容存档于2014-04-08）. But it was interesting to me that 25 years later, in 1989, Deng Xiaoping made just the exact argument to George H. W. Bush.  You know, this is an exchange that picks up an entire page of George Bush's memoir, “A World Transformed.”  But interesting to me is that Mongolia is not even in the index of “A World Transformed.”  Got that entire page, Deng Xiaoping complaining to George Bush about Yalta, the Russians taking over Yalta – taking over Mongolia under cover of Yalta. （英文）\n\n^ 《结束过去，开辟未来》 （页面存档备份，存于互联网档案馆），鄧小平文選 （页面存档备份，存于互联网档案馆）\n\n^ 中蒙庆祝《中蒙友好合作关系条约》修订15周年. 中国政府网.   [2019-06-23]. （原始内容存档于2019-06-23）. \n\n来源[编辑]\n书籍\n［俄］巴尔苏科夫：《穆拉维约夫——阿穆尔斯基伯爵》\n陈春华：《俄国外交文书选译：关于蒙古问题》\n唐德剛：《袁氏當國》\n梁敬錞：《中蘇友好同盟條約之簽訂與其內幕真相》\n王世杰、胡慶育：《中國不平等條約之廢除》，中央文物供应社， 1967年\n蔣經國：《風雨中的寧靜》\n李敖：《蔣介石研究》\n江南：《蒋经国传》\n雷法章：《奉派赴外蒙參觀公民投票之經過》\n蔣廷黻：《三年控蘇的奮鬥》，中央日報，1952年4月10日: 頁3\n沈志华 编：《朝鲜战争：俄罗斯国家解密档案》\n《顧維鈞回憶錄》\n《師哲回憶錄》\n《鄧小平文選》\n哥倫比亞百科全書：蒙古（英文）\n不列顛百科全書：蒙古（英文）\n蒙古研究：卡尔梅克的假喇嘛（页面存档备份，存于互联网档案馆）（俄文）\n其他文章\n張啟雄：〈民初中俄蒙恰克圖會議的名分論爭與交涉──外蒙國號帝號年號及政府名義的改廢（页面存档备份，存于互联网档案馆）〉\n張啟雄：〈中華思想下的「外蒙主權」談判──民初陸庫北京會議（页面存档备份，存于互联网档案馆）〉\n張啟雄：〈「獨立外蒙」的國家認同與主權歸屬交涉（页面存档备份，存于互联网档案馆）〉\n冯建勇：〈民族主义、国家利益与地缘政治之纠葛——1919～1924年外蒙古“二次独立”问题研究（页面存档备份，存于互联网档案馆）〉\n苏俄操纵外蒙古独立的经过. 贵阳市政协办公厅.   [2014-05-06]. （原始内容存档于2014-05-06）. \n军史：沙俄送军队让外蒙古独立. 搜狐军事.   [2014-05-06]. （原始内容存档于2020-07-15）. \n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的参考文献", "Tag": "算法设计"}
{"Answer": "\n\n^ Мянга есөн зуун хорин нэгэн оны Үндэсний ардчилсан хувьсгал [蒙古民族民主革命]. Монголын түүх.   [2019-06-26]. （原始内容存档于2019-06-26） （蒙古语）. \n\n^ ［俄］巴尔苏科夫《穆拉维约夫--阿穆尔斯基伯爵》第2卷，第111页。东正教出版社，1891年\n\n^ БАЗАРОВ, Виктор Борисович. РОССИЙСКАЯ ПОЛИТИКА В ОТНОШЕНИИ МОНГОЛИИ В НАЧАЛЕ ХХ в.. ВЛАСТЬ.   [2017]. （原始内容存档于2021-06-24） （俄语）. \n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第5-6頁\n\n^ 薛人仰主編，周昆田著，蒙藏民族史略，台灣中華書局，1982年6月版，第48頁\n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第13-14頁\n\n^ 7.0 7.1 梁鹤年. 《库伦独立始末记》. \n\n^ 陈崇祖. 外蒙古近世史 第二版. 1926: 253. \n\n^ 周学军; 白剑光. 《库伦独立始末记》订误. 内蒙古社会科学. 2000年, (第6期)  [2019-06-25]. （原始内容存档于2019-07-22）.  引文使用过时参数coauthors (帮助)\n\n^ 《宣统政纪》. : 卷六五、卷六九. \n\n^ А.А. Сизова. КОНСУЛЬСКАЯ СЛУЖБА РОССИИ в МОНГОЛИИ (1861–1917) (PDF). МОСКВА. 2015  [2022-04-23]. ISBN 978-5-02-036596-4. （原始内容存档 (PDF)于2021-06-24） （俄语）. \n\n^ Ховдыг чөлөөлөх байлдаан. Tolgoilogch.mn.   [2021-06-20]. （原始内容存档于2021-01-25） （蒙古语）. \n\n^ 阿拉坦巴根. 1913年锡林郭勒—察哈尔战事初探. 2008  [2019-09-27]. （原始内容存档于2019-09-27）. \n\n^ 周太平. 关于“牛年之乱”的一个考察. 《蒙古史研究》. 2007, (第九辑). \n\n^ 杜亞泉《獨立後之庫倫及俄蒙協約》\n\n^ 袁世凯签订《中俄蒙协约》始末. 星岛环球网. 2010-02-08  [2013-07-11]. （原始内容存档于2010-04-16） （中文（简体））. \n\n^ С.Чулуун. МОНГОЛЫН ТУСГААР ТОГТНОЛ НОЁДЫН ҮХЭЛ (1911-1919) [蒙古獨立諸侯之死]. Tagtaa solution. Түүхийн хүрээлэнгийн захирал.   [2021-06-27]. （原始内容存档于2022-03-31） （蒙古语）. \n\n^ Хишигт Н. Гадаад Монголын  өөртөө засах засгийг устгасан түүхийн асуудалд-//МУИС. НШУС “Түүх YII”. УБ: Эрдэм  шинжилгээний  бичиг. 2008: 139–149 （蒙古语）. \n\n^ 不是一次孤立事件：中苏边界冲突的缘起和结果_cctv.com提供. news.cctv.com.   [2021-11-18]. （原始内容存档于2021-11-18）. \n\n^ 董樹藩 主編，李毓澍 著，從蒙共六十年來演變對外蒙現況的探討，1985年5月版，(中華民國)蒙藏委員會出版，第2-3頁\n\n^ 曹心宝. 徐树铮与皖系兴亡研究. 广西师范大学出版社. 2016  [2021-06-27]. ISBN 978-7549581085. （原始内容存档于2021-06-28）. \n\n^ HIROSHI FUTAKI. A Re-examination of the Establishment of the Mongolian People's Party, Centring on Dogsom's Memoir. Inner Asia. 2000, (Vol. 2, No. 1, celebrating the 80th birthday of Urgunge Onon): 37–60  [2021-06-27]. （原始内容存档于2021-06-28）. \n\n^ 董樹藩 主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第26-29頁、第34-36頁\n\n^ 劉學銚，外蒙古問題，南天書局，2001年3月，ISBN 9576385687，38頁\n\n^ 唐德剛《袁氏當國》一書中曾提到「錯在老徐（徐樹錚）」\n\n^ 董樹藩主編，論內外蒙分界問題，1985年2月版，(中華民國)蒙藏委員會出版，第5-6頁\n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第44-45頁\n\n^ 劉學銚，外蒙古問題，南天書局，2001年3月，ISBN 9576385687，第41頁、第103頁\n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第46頁\n\n^ Pershin, D. P. (Dmitriĭ Petrovich). Барон Унгерн, Урга и Алтан-Булак: Записки очевидца о смутном времени во Внешней (Халхаской) Монголии в первой трети ХХ века. Издательский дом \"Агни\". 1999  [2021-06-20]. ISBN 9785898500030. （原始内容存档于2021-01-18） （俄语）. \n\n^ 薛人仰主編，周昆田著，蒙藏民族史略，台灣中華書局，1982年6月版，第44頁\n\n^ 俄境内现唐代古城 斯大林侵占中国领土往事揭秘. 环球网.   [2021-11-18]. （原始内容存档于2022-03-09）. \n\n^ Eric Her. THE “GREAT GAME”: MONGOLIA BETWEEN RUSSIA AND CHINA. The Mongolian Journal of International Affairs. 1997  [2021-06-20]. （原始内容存档于2019-04-28）. \n\n^ 董樹藩主編，李毓澍，論外蒙古的獨立問題，1985年2月版，(中華民國)蒙藏委員會出版，第47-49頁\n\n^ Орлов А.С; Георгиева Н.Г; Георгиев В.А. Советско-монгольское соглашение 1921 г., 5 ноября. Исторический словарь. 2012, (2-е изд): 478  [2021-06-20]. （原始内容存档于2020-12-05） （俄语）. \n\n^ THE SUN-JOFFE AGREEMENT (1923). Alphahistory. \n\n^ 王春良; 李威. 论苏联是怎样把中国的外蒙古分裂出去的. 聊城大学学报(社会科学版). 2009, (05): 53–64  [2022-04-16]. ISSN 1672-1217. doi:10.16284/j.cnki.cn37-1401/c.2009.05.019. （原始内容存档于2022-04-16）. \n\n^ 董樹藩主編，論內外蒙分界問題，1985年2月版，(中華民國)蒙藏委員會出版，第10頁\n\n^ 劉學銚，外蒙古問題，南天書局，2001年3月，ISBN 9576385687，56頁\n\n^ 据新华社1949年8月15日电\n\n^ 41.0 41.1 41.2 《風雨中的寧靜》，蔣經國\n\n^ 42.0 42.1 42.2 《中蘇友好同盟條約之簽訂與其內幕真相》，梁敬錞\n\n^ 斯大林迫使中国接受外蒙古独立：没力量别讲废话 （页面存档备份，存于互联网档案馆），星岛环球网，2006-12-19，2007年7月23日查阅\n\n^ 王世杰、胡慶育. 《中國不平等條約之廢除》. 雅爾達協定規定：“外蒙（蒙古人民共和國）的現狀應予保持。”我方認為這只是申明當時的情勢：即蒙古自稱獨立，中國中央政府保持沉默。 \n\n^ 王世杰、胡慶育《中國不平等條約之廢除》\n\n^ 《蒋经国传》，江南\n\n^ 秦孝仪主编，中华民国重要史料初编——对日抗战时期，第七编，战后中国（一），臺灣臺北：中国国民党中央委员会党史委员会，1981年，第166页\n\n^ 蔣中正. 完成民族主義維護國際和平. 《總統蔣公思想言論總集》.   [2020-01-15]. （原始内容存档于2021-10-28）. \n\n^ 49.0 49.1 《奉派赴外蒙參觀公民投票之經過》，雷法章\n\n^ Nohlen, D, Grotz, F & Hartmann, C (2001) Elections in Asia: A data handbook, Volume II, p491 ISBN 978-0-19-924959-6\n\n^ 国民政府发表公告承认外蒙独立，中央日报（上海版），第2版\n\n^ 《與蘇聯斷絕邦交之聲明》，1949年11月7日，中華民國外交部\n\n^ 1967年11月4日，《中央日報》：「今年九月三日和十月四日，莫斯科電臺華語廣播一再聲稱：蘇俄為支持共匪，曾于中日戰爭剛結束的時候，在中國東北給予毛匪澤東以大量的武器，并列舉武器的種類與數量，廣播中并稱：蘇俄派兵前往東北，其目的是在阻止中華民國軍隊進入東北，與輔助毛匪澤東造反，而將日軍繳交大批武器給予共匪，并與共匪合作，攫取政府軍的重要據點。」\n\n^ 54.0 54.1 邵毓麟. 《奉派駐韓外交代表又無疾而終》. 《傳記文學》. Vol. 第三十一卷 no. 第六期. \n\n^ 美国国务院档案. 美国国务院.   [2017-06-10]. （原始内容存档于2021-07-03）. \n\n^ 揭秘外蒙古独立始末. 世界军事网.   [2013-04-13]. （原始内容存档于2013-04-27）. \n\n^ S/PV.57 - C - S/PV.57 -Desktop. undocs.org: 六七.   [2021-09-17]. （原始内容存档于2022-02-28）. \n\n^ A/RES/35(I). \n\n^ General Assembly Resolutions 1st Session. 聯合國. resolution 35 (I):Question of the Re-examination by the Security Council of Certain Application for Admission to Membership in the United Nations.   [2013-05-16]. （原始内容存档于2013-03-09）. （英文）\n\n^ 徐淑希演說　認外蒙無入會資格 (pdf). 大公報. 1947年7月30日  [2013年4月16日]. （原始内容存档于2014年3月31日）. \n\n^ S/PV.186 - C - S/PV.186. undocs.org.   [2020-03-01]. （原始内容存档于2020-02-20）. \n\n^ 聯合國1946-1947年年鑑 (PDF). 聯合國.   [2013-04-16]. （原始内容 (PDF)存档于2009-05-21）. （英文）\n\n^ 因常任理事国投反对票而未获通过的决议草案或修正案各段 (PDF). 聯合國.   [2013-02-07]. （原始内容存档 (PDF)于2014-03-23）. \n\n^ The veto and how to use it. BBC News Online.   [2013-02-07]. （原始内容存档于2010-07-26）. （英文）\n\n^ Changing Pattern in the Use of Veto in the Security Council. Global Policy Forum.   [2013-02-07]. （原始内容存档于2013-05-08）. （英文）\n\n^ Subjects of UN Security Council Vetoes. Global Policy Forum.   [2013-02-07]. （原始内容存档于2013-01-16）. （英文）\n\n^ S/PV.704 - C - S/PV.704. undocs.org.   [2020-03-01]. （原始内容存档于2021-05-30）. \n\n^ Text of the Resolution. 联合国官网.   [2019-10-03]. （原始内容存档于2019-07-04）. \n\n^ A/PV.1043 - C - A/PV.1043. undocs.org.   [2020-03-01]. （原始内容存档于2019-10-03）. \n\n^ 《顧維鈞回憶錄》\n\n^ 制憲國民大會的雲南籍代表及貢獻. 台北市雲南省同鄉會.   [2020-09-06]. （原始内容存档于2022-02-05）. \n\n^ 立法院國會圖書館電子藏書：國民大會歷次會議實錄 （页面存档备份，存于互联网档案馆）：《第一屆國民大會第六次會議實錄》，1979年5月；《第一屆國民大會第七次會議實錄》，1985年5月；《第一屆國民大會第八次會議實錄》，1991年4月；《第一屆國民大會第二次臨時會實錄》，1991年10月 ：《中華民國全圖》\n\n^ 司法院. 司法院全球資訊網. 司法院. 2019-05-06  [2020-06-04]. （原始内容存档于2020-05-28）. \n\n^ 邱政宗. 中華民國立法院法制局研究成果《外蒙古定位後續問題評析》. 2002年3月 [民國91年3月]. （原始内容存档于2018-02-03）. \n\n^ 官方地圖 將標示蒙古為國家 （页面存档备份，存于互联网档案馆）, 自由時報, 2002年10月3日\n\n^ Mongolian office to ride into Taipei by end of the year, Taipei Times, 2002-10-11  [2008-02-05], （原始内容存档于2018-10-01） \n\n^ 駐外館處. 中華民國外交部.   [2016-09-02]. （原始内容存档于2017-06-21）. \n\n^ 駐華外國機構. 中華民國外交部.   [2016-09-02]. （原始内容存档于2021-01-09）. \n\n^ 蒙古國 （页面存档备份，存于互联网档案馆），中華民國外交部\n\n^ 行政院大陸委員會：有關外蒙古是否為中華民國領土問題說明新聞參考資料 （页面存档备份，存于互联网档案馆）\n\n^ 內政部函：「一、本部前曾於民國87年出版「中華民國全圖」，後因考量銷售量偏低、圖資內容不符現況，目前已停止銷售。」\n\n^ 台当局弃用「中华民国全图」.   [2012-10-17]. （原始内容存档于2012-04-23）. \n\n^ 大陸地圖 得依中國現狀標示 （页面存档备份，存于互联网档案馆）, 自由時報, 2002年11月30日\n\n^ 官方地圖 將標示蒙古為國家 （页面存档备份，存于互联网档案馆）, 自由時報, 2002年10月3日\n\n^ 蒙藏委員會 今併入文化部.   [2017-09-30]. （原始内容存档于2017-09-21）. \n\n^ 中央通訊社. 蒙藏委員會 最快8月底裁撤. 聯合新聞網. 2017年8月14日  [2017年9月30日]. （原始内容存档于2017年9月30日）. \n\n^ [失效連結]袁南生. 晚清以来的外交与新的心态. 学习时报. 2012-01-16: 第12版：参考文摘 （中文（中国大陆））. 1922年8月，外交总长顾维钧对来访的苏俄副外交人民委员越飞表示，中苏建交的先决条件是苏军从外蒙古撤离。顾维钧的立场毫无疑问是正确的，但奇怪的是，苏军侵入面积等于43个台湾、140个香港的外蒙古，国人舆论却并不站在顾维钧这一边，相反却要求北京政府“无条件与苏俄建交”。此时，不但北京大学生上街示威，新闻机构对外交部大加鞭挞，李大钊也亲自找到顾维钧，对顾的立场表示愤慨，甚至说“把外蒙置于苏俄的统治之下，那里的人民有可能生活得更好”，孙中山也对顾的做法表示反对，到了最后，居然连以吴佩孚为首的各地军阀将领都发电报到外交部，指责顾维钧。 [永久失效連結]顾维均回忆录\n\n^  中華蘇維埃共和國憲法大綱. 维基文库. 1931年 （中文）. \n\n^ 谈毛泽东眼里的中国抗战. 中国经济网.   [2021-11-19]. （原始内容存档于2021-11-19）. \n\n^ 90.0 90.1 《毛泽东选集，第二卷》 第2版. 人民出版社. 1991年6月  [2014-08-07]. （原始内容存档于2015-10-16）. 。見竹內實編《毛澤東集·第七卷·延安期Ⅲ》收錄的該篇文章以及該文1944年毛選版和1950年代人民出版社版毛選的對比。\n\n^ 91.0 91.1 中國革命與中國共產黨（未刪節本）. 马克思主义文库. 1939年12月15日  [2014年8月7日]. （原始内容存档于2014年8月8日）. \n\n^ 92.0 92.1 劉益濤. 《中國革命和中國共產黨》. 中共黨史出版社. 2007年6月15日  [2014年8月7日]. （原始内容存档于2016年3月4日）. \n\n^ 中国共产党对苏日中立条约发表意见. 新華網.   [2013-02-08]. （原始内容存档于2010-09-21）. \n\n^ 1941年(民國30年)4月15日，重慶新華日報社論，……這絲毫不能也沒有變更中國的領土主權，這本是蘇日過去的關係上長久已存在的事實\n\n^ 据中国历史学家沈志华所编《朝鲜战争：俄罗斯国家解密档案》中引述的《米高扬就1949年1-2月中国之行给苏共中央主席团的报告》所说：“关于蒙古。毛泽东主动问我们如何对待外蒙和内蒙的统一。我回答说，我们不主张这样的统一，因为这可能导致中国失去一大块领土。毛泽东说，他认为外蒙和内蒙可以联合起来并入中国版图。我对他说，这是不可能的，因为蒙古人民共和国已享有独立，日本投降之后中国政府承认了外蒙的独立。蒙古人民共和国有自己的军队，有自己的文化，以及文化和经济发展的道路，它早就领略了独立的滋味，任何时候都未必会自愿放弃独立。如果什么时候它和内蒙合并，那一定是成立统一的独立的蒙古。”（摘自 俄档案：毛泽东曾两次要求外蒙古回归中国 （页面存档备份，存于互联网档案馆））\n\n^ 据中国历史学家沈志华所编《朝鲜战争：俄罗斯国家解密档案》中引述的《米高扬就1949年1-2月中国之行给苏共中央主席团的报告》  俄档案：毛泽东曾两次要求外蒙古回归中国 （页面存档备份，存于互联网档案馆）\n\n^ 《師哲回憶錄》\n\n^ 从联合国2758号决议看台湾的“中华民国”地位. 联合早报. \n\n^ 99.0 99.1 马保奉：新中国建交内情（五）（礼仪漫谈）——与朝、蒙、越建交 （页面存档备份，存于互联网档案馆）. 人民日报海外版\n\n^ 中苏同盟四周年——中苏友好同盟条约四周年纪念日在北平 新华广播电台对全国的广播词. laoziliao.net.   [2020-03-01]. （原始内容存档于2021-12-19）. \n\n^ 郭沫若：我们应该怎样认识外蒙古独立？ （页面存档备份，存于互联网档案馆）\n\n^ 关于承认和保证蒙古人民共和国的独立地位. laoziliao.net.   [2020-03-01]. （原始内容存档于2021-12-19）. \n\n^ 摘自人民日报1949年8月14日第一版刊登的郭沫若写于8月12日的文章《中苏同盟四周年——中苏友好同盟条约四周年纪念日在北平新华广播电台对全国的广播词》。我们应该怎样认识外蒙古独立？ （页面存档备份，存于互联网档案馆）\n\n^ 胡華:中苏问题讲话，pp.29-34\n\n^ 胡華：我們應不應該承認外蒙獨立？.   [2019-08-25]. （原始内容存档于2016-03-09）. \n\n^ 胡華. 《人民日报》：关于承认和保证蒙古人民共和国的独立地位. 共识网. 2010-08-21  [2017-06-28]. （原始内容存档于2016-06-14）. \n\n^ 人民日報早年文章聲稱釣魚島屬於日本. RFI - 法國國際廣播電台. 2012-08-22  [2022-04-23]. （原始内容存档于2021-12-19）. \n\n^ 1949年12月至1950年3月，歷時89日，毛澤東為了與斯大林簽訂《中蘇友好同盟互助條約》，曾對周恩來說：「我們還要搞一個聲明。中華人民共和國成立時，我們已經宣布過舊中國與外國簽定的一切國際協定、條約一概不予承認。但外蒙古獨立是一個例外。外蒙古獨立是國民黨政府辦理的，但是我們尊重蒙古人民1945年的公民投票，他們一致擁護獨立。現在雙方政府經過談判確認蒙古人民共和國的獨立地位。蘇聯也表示支持中國這一立場，同時也希望蒙古發表聲明表個態。」周說：「這樣做比較好。」見汪東興著，〈隨毛主席第一次出訪蘇聯〉，刊《汪東興日記》，第195頁\n\n^ 郵票上的五星紅旗. 中国邮政报. 2017-10-02  [2017-11-13]. （原始内容存档于2017-11-14）. \n\n^ 纪89邮票，庆祝蒙古人民革命四十周年,价格,图片,最新. 百分邮票收藏网.   [2017-11-13]. （原始内容存档于2017-11-14）. \n\n^ 毛泽东两次提出外蒙回归.   [2013-04-14]. （原始内容存档于2016-03-04）. \n\n^ George Bush; Brent Scowcroft. A World Transformed. Knopf. 1998年: 第95-96頁. ISBN 978-0-679-43248-7. （英文）\n\n^ David M. Lampton. 同床異夢: 處理1989至2000年之中美外交. 計秋楓譯. 香港中文大學. 2003年: 第6頁  [2014-04-08]. ISBN 978-962-996-108-4. （原始内容存档于2014-09-25）. \n\n^ John Tkacik. Briefing :: Mongolia Moves Toward Europe. 美國: 欧洲安全与合作委員會（英语：Commission on Security and Cooperation in Europe）. 2011-10-12  [2014-04-07]. （原始内容存档于2014-04-08）. But it was interesting to me that 25 years later, in 1989, Deng Xiaoping made just the exact argument to George H. W. Bush.  You know, this is an exchange that picks up an entire page of George Bush's memoir, “A World Transformed.”  But interesting to me is that Mongolia is not even in the index of “A World Transformed.”  Got that entire page, Deng Xiaoping complaining to George Bush about Yalta, the Russians taking over Yalta – taking over Mongolia under cover of Yalta. （英文）\n\n^ 《结束过去，开辟未来》 （页面存档备份，存于互联网档案馆），鄧小平文選 （页面存档备份，存于互联网档案馆）\n\n^ 中蒙庆祝《中蒙友好合作关系条约》修订15周年. 中国政府网.   [2019-06-23]. （原始内容存档于2019-06-23）. \n\n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的参考文献的引用", "Tag": "算法设计"}
{"Answer": "\n书籍\n［俄］巴尔苏科夫：《穆拉维约夫——阿穆尔斯基伯爵》\n陈春华：《俄国外交文书选译：关于蒙古问题》\n唐德剛：《袁氏當國》\n梁敬錞：《中蘇友好同盟條約之簽訂與其內幕真相》\n王世杰、胡慶育：《中國不平等條約之廢除》，中央文物供应社， 1967年\n蔣經國：《風雨中的寧靜》\n李敖：《蔣介石研究》\n江南：《蒋经国传》\n雷法章：《奉派赴外蒙參觀公民投票之經過》\n蔣廷黻：《三年控蘇的奮鬥》，中央日報，1952年4月10日: 頁3\n沈志华 编：《朝鲜战争：俄罗斯国家解密档案》\n《顧維鈞回憶錄》\n《師哲回憶錄》\n《鄧小平文選》\n哥倫比亞百科全書：蒙古（英文）\n不列顛百科全書：蒙古（英文）\n蒙古研究：卡尔梅克的假喇嘛（页面存档备份，存于互联网档案馆）（俄文）\n其他文章\n張啟雄：〈民初中俄蒙恰克圖會議的名分論爭與交涉──外蒙國號帝號年號及政府名義的改廢（页面存档备份，存于互联网档案馆）〉\n張啟雄：〈中華思想下的「外蒙主權」談判──民初陸庫北京會議（页面存档备份，存于互联网档案馆）〉\n張啟雄：〈「獨立外蒙」的國家認同與主權歸屬交涉（页面存档备份，存于互联网档案馆）〉\n冯建勇：〈民族主义、国家利益与地缘政治之纠葛——1919～1924年外蒙古“二次独立”问题研究（页面存档备份，存于互联网档案馆）〉\n苏俄操纵外蒙古独立的经过. 贵阳市政协办公厅.   [2014-05-06]. （原始内容存档于2014-05-06）. \n军史：沙俄送军队让外蒙古独立. 搜狐军事.   [2014-05-06]. （原始内容存档于2020-07-15）. \n", "Konwledge_Point": "外蒙古独立", "Question": "什么是外蒙古独立的参考文献的来源", "Tag": "算法设计"}
{"Answer": "优先队列（priority queue）是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列通常使用「堆積」（heap）实现。\n", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列", "Tag": "算法设计"}
{"Answer": "优先队列至少需要支持下述操作：\n插入带优先级的元素（insert_with_priority）\n取出具有最高优先级的元素（pull_highest_priority_element）\n查看最高优先级的元素（peek）：O(1) 时间复杂度其它可选的操作：\n检查优先级高的一批元素\n清空优先队列\n批插入一批元素\n合并多个优先队列\n调整一个元素的优先级", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列的操作", "Tag": "算法设计"}
{"Answer": "初级实现[编辑]有许多简单低效的实现。如用一个有序的数组；或使用无序数组，在每次取出时搜索全集合，这种方法插入的效率为O(1)，但取出时效率为​O(n)。\n典型实现[编辑]出于性能考虑，优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(log n)，构造二叉树的时间复杂度为O(n log n)。\n从计算复杂度的角度，优先级队列等价于排序算法。\n有一些特殊的堆为优先队列的实现提供了额外的性能：二叉堆的插入与提取操作的时间复杂度为O(log n)，并可以常量时间复杂度的peek操作。二项堆提供了几种额外操作。斐波那契堆的插入、提取、修改元素优先级等操作具有分摊常量时间复杂度，[1]，但删除操作的时间复杂度为O(log n)。Brodal queue（英语：Brodal queue）具有最糟糕情况下的常量复杂度但算法相当复杂因而不具有实用性。\n对于整型、浮点型等具有有限值域的元素的数据类型，优先队列有更快的实现。\n", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列的实现", "Tag": "算法设计"}
{"Answer": "有许多简单低效的实现。如用一个有序的数组；或使用无序数组，在每次取出时搜索全集合，这种方法插入的效率为O(1)，但取出时效率为​O(n)。\n", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列的实现的初级实现", "Tag": "算法设计"}
{"Answer": "出于性能考虑，优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(log n)，构造二叉树的时间复杂度为O(n log n)。\n从计算复杂度的角度，优先级队列等价于排序算法。\n有一些特殊的堆为优先队列的实现提供了额外的性能：二叉堆的插入与提取操作的时间复杂度为O(log n)，并可以常量时间复杂度的peek操作。二项堆提供了几种额外操作。斐波那契堆的插入、提取、修改元素优先级等操作具有分摊常量时间复杂度，[1]，但删除操作的时间复杂度为O(log n)。Brodal queue（英语：Brodal queue）具有最糟糕情况下的常量复杂度但算法相当复杂因而不具有实用性。\n对于整型、浮点型等具有有限值域的元素的数据类型，优先队列有更快的实现。\n", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列的实现的典型实现", "Tag": "算法设计"}
{"Answer": "优先队列是计算机科学中的一类\"容器数据类型\"。\n标准模板库（STL）以及1998年的C++标准确定优先队列是标准模板库的容器适配器模板。其实现了一个需要三个参数的最大优先队列：比较函数（缺省情况是小于函数less<T>）、存储数据所用的容器类型（缺省情况是向量vector<T>）以及指向序列开始和结束位置的两个迭代器。和标准模板库中其他的真实容器不同，优先队列不允许使用其元素类型的迭代器，而必须使用优先队列抽象数据类型的迭代器。标准模板库还实现了支持随机访问数据容器的优先队列--二叉最大堆。Boost C++库也在其中实现了堆结构。\nPython的heapq （页面存档备份，存于互联网档案馆）模块实现了在链表基础上的二叉最小堆，queue （页面存档备份，存于互联网档案馆）模块将heapq模块包装实现了PriorityQueue类。\nJava库中的PriorityQueue类实现了最小优先队列。\nGo库中的container/heap （页面存档备份，存于互联网档案馆）模块实现了一个可以在任何兼容数据结构上构建的最小堆。\nPHP标准库包括了一个优先队列SplPriorityQueue （页面存档备份，存于互联网档案馆）。\n苹果的Core Foundation框架包括了一个最小堆结构CFBinaryHeap （页面存档备份，存于互联网档案馆）。\n", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列的库实现", "Tag": "算法设计"}
{"Answer": "优先队列常用于操作系统的任务调度，也是贪心算法的重要组成部分。[2]\n", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列的应用", "Tag": "算法设计"}
{"Answer": "\n\n^ Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 20: Fibonacci Heaps, pp.476–497. Third edition p518.\n\n^ Mikkel Thorup. On RAM priority queues. Proceeding SODA '96 Proceedings of the seventh annual ACM-SIAM symposium on Discrete algorithms. 1996: 59–67  [2019-09-11]. \n\n", "Konwledge_Point": "優先佇列", "Question": "什么是優先佇列的参考文献", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "卢恩算法", "Question": "什么是卢恩算法", "Tag": "算法设计"}
{"Answer": "动态规划（英語：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。\n动态规划常常适用于有重叠子问题[1]和最优子结构（英语：Optimal substructure）性质的问题，动态规划方法所耗时间往往远少于朴素解法。\n动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。\n通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指數增長时特别有用。\n", "Konwledge_Point": "动态规划", "Question": "什么是动态规划", "Tag": "算法设计"}
{"Answer": "动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费不必要的时间。\n动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。\n", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的概述", "Tag": "算法设计"}
{"Answer": "最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态規劃算法解决问题提供了重要线索。\n无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。\n子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态規劃算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的适用情况", "Tag": "算法设计"}
{"Answer": "包括但不限于切割钢条问题、Floyd最短路问题、最大不下降子序列、矩阵链乘、凸多边形三角剖分、背包问题、最长公共子序列、最优二分搜索树等。\n背包问题[编辑]背包问题作为NP完全问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。\n背包问题具有最优子结构和重叠子问题。动态规划一般用于求解背包问题中的整数背包问题（即每种物品所选的个数必须是整数）。\n解整数背包问题：\n设有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n件物品，每件价值记为\n  \n    \n      \n        \n          P\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle P_{i}}\n  \n，每件重量记为\n  \n    \n      \n        \n          W\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle W_{i}}\n  \n，用一个最大重量为\n  \n    \n      \n        W\n      \n    \n    {\\displaystyle W}\n  \n的背包，求装入物品的最大价值。\n在总重量不超过W的前提下，我们希望总价格最高。对于Y ≤ W，我们将在总重量不超过Y的前提下，总价格所能达到的最高值定义为A(Y)。A(W)即为问题的答案。\n显然，A(Y)满足：\nA(0) = 0\nA(Y) = max { A(Y - 1), { pj + A(Y - wj) | wj ≤ Y } }其中，pj为第j种物品的价格。\n对于特例0 1背包问题（即每件物品最多放1件，否则不放入）的问题，我们将在总重量不超过Y的前提下，前j种物品的总价格所能达到的最高值定义为A(j, Y)。\nA(j, Y)的递推关系为：\nA(0, Y) = 0\n如果wj > Y, A(j, Y) = A(j - 1, Y)\n如果wj ≤ Y, A(j, Y) = max { A(j - 1, Y), pj + A(j - 1, Y - wj)}参考Pascal代码\nfor i:=1 to n do\n  for v:=totv downto v[i] do\n    f[v]:=max(f[v],f[v-v[i]]+p[i]);\nwriteln(f[totv]);\n参考C++代码（不含include和数组声明）\n#define max(x,y) (x)>(y)?(x):(y) //max宏函数，也可以自己寫或者使用algorithm\nfor(int i=1;i<=n;i++)\n  for (v=totv;v>=v[i];v--)\n    f[v]=max(f[v],f[v-v[i]]+p[i]);\nprintf(\"%d\",f[totv]); //或std::cout<<f[totv];\n", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的实例", "Tag": "算法设计"}
{"Answer": "背包问题作为NP完全问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。\n背包问题具有最优子结构和重叠子问题。动态规划一般用于求解背包问题中的整数背包问题（即每种物品所选的个数必须是整数）。\n解整数背包问题：\n设有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n件物品，每件价值记为\n  \n    \n      \n        \n          P\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle P_{i}}\n  \n，每件重量记为\n  \n    \n      \n        \n          W\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle W_{i}}\n  \n，用一个最大重量为\n  \n    \n      \n        W\n      \n    \n    {\\displaystyle W}\n  \n的背包，求装入物品的最大价值。\n在总重量不超过W的前提下，我们希望总价格最高。对于Y ≤ W，我们将在总重量不超过Y的前提下，总价格所能达到的最高值定义为A(Y)。A(W)即为问题的答案。\n显然，A(Y)满足：\nA(0) = 0\nA(Y) = max { A(Y - 1), { pj + A(Y - wj) | wj ≤ Y } }其中，pj为第j种物品的价格。\n对于特例0 1背包问题（即每件物品最多放1件，否则不放入）的问题，我们将在总重量不超过Y的前提下，前j种物品的总价格所能达到的最高值定义为A(j, Y)。\nA(j, Y)的递推关系为：\nA(0, Y) = 0\n如果wj > Y, A(j, Y) = A(j - 1, Y)\n如果wj ≤ Y, A(j, Y) = max { A(j - 1, Y), pj + A(j - 1, Y - wj)}参考Pascal代码\nfor i:=1 to n do\n  for v:=totv downto v[i] do\n    f[v]:=max(f[v],f[v-v[i]]+p[i]);\nwriteln(f[totv]);\n参考C++代码（不含include和数组声明）\n#define max(x,y) (x)>(y)?(x):(y) //max宏函数，也可以自己寫或者使用algorithm\nfor(int i=1;i<=n;i++)\n  for (v=totv;v>=v[i];v--)\n    f[v]=max(f[v],f[v-v[i]]+p[i]);\nprintf(\"%d\",f[totv]); //或std::cout<<f[totv];\n历史[编辑]术语“动态规划”最初是在 1940 年代由 理查德·贝尔曼 用来描述解决问题的过程，在这个过程中，人们需要一个接一个地找到最佳决策。到 1953 年，他将其精炼成为现代的含义，特别是指将较小的决策问题嵌套在较大的决策中，[2] 并且该领域随后被电气电子工程师学会认可为系统分析和工程学主题。贝尔曼的贡献以贝尔曼方程的名义被铭记，它是动态规划的核心结果，它以递归 (计算机科学)形式重申了优化问题。\n贝尔曼选择了“动态”这个词来捕捉问题的随时间变化的方面，也因为它听起来令人印象深刻。[3] “规划”一词指的是使用该方法来找到最佳的“程序”，在于军事训练或后勤计划的意义。这种用法与短语 线性规划 和 数学规划 中的用法相同。[4]\n术语起源的上述解释是不足的。正如罗素和诺维格在他们的书中提到上述故事时所写的那样：“这不可能完全正确，因为他的第一篇使用这个词（贝尔曼，1952）的论文出现在威尔逊于 1953 年成为国防部长之前。”[5]此外，还有Harold J. Kushner （页面存档备份，存于互联网档案馆）在演讲中的评论，他记得贝尔曼。他在谈到贝尔曼时引用库什纳的话：“另一方面，当我问他同样的问题时，他回答说他试图通过加上动态来超越乔治·伯纳德·丹齐格的线性规划。也许这两种动机都是正确的。”\n使用动态规划的算法[编辑]最长公共子序列\nFloyd-Warshall算法\nViterbi算法\nKadane's_algorithm[6]\n求解馬可夫決策過程下最佳策略[7]参考[编辑]\n^ S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani, 'Algorithms', p 173, available at http://www.cs.berkeley.edu/~vazirani/algorithms.html （页面存档备份，存于互联网档案馆）\n\n^ Stuart Dreyfus. \"Richard Bellman on the birth of Dynamical Programming\".\n\n^ Eddy, S. R. What is Dynamic Programming?. Nature Biotechnology. 2004, 22 (7): 909–910. PMID 15229554. S2CID 5352062. doi:10.1038/nbt0704-909. \n\n^ Nocedal, J.; Wright, S. J. Numerical Optimization. Springer. 2006: 9. ISBN 9780387303031. \n\n^ Russell, S.; Norvig, P. Artificial Intelligence: A Modern Approach 3rd. Prentice Hall. 2009. ISBN 978-0-13-207148-2. \n\n^ Maximum_subarray_problem.   [2023-01-18]. （原始内容存档于2023-02-04）. \n\n^ Richard S. Sutton; Andrew G. Barto. Reinforcement Learning: An Introduction Second Edition. The MIT Press. 2018: 73  [2020-08-22]. （原始内容存档于2022-01-18）.  引文格式1维护：冗余文本 (link)\n\n外部链接[编辑]", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的实例的实例的背包问题", "Tag": "算法设计"}
{"Answer": "术语“动态规划”最初是在 1940 年代由 理查德·贝尔曼 用来描述解决问题的过程，在这个过程中，人们需要一个接一个地找到最佳决策。到 1953 年，他将其精炼成为现代的含义，特别是指将较小的决策问题嵌套在较大的决策中，[2] 并且该领域随后被电气电子工程师学会认可为系统分析和工程学主题。贝尔曼的贡献以贝尔曼方程的名义被铭记，它是动态规划的核心结果，它以递归 (计算机科学)形式重申了优化问题。\n贝尔曼选择了“动态”这个词来捕捉问题的随时间变化的方面，也因为它听起来令人印象深刻。[3] “规划”一词指的是使用该方法来找到最佳的“程序”，在于军事训练或后勤计划的意义。这种用法与短语 线性规划 和 数学规划 中的用法相同。[4]\n术语起源的上述解释是不足的。正如罗素和诺维格在他们的书中提到上述故事时所写的那样：“这不可能完全正确，因为他的第一篇使用这个词（贝尔曼，1952）的论文出现在威尔逊于 1953 年成为国防部长之前。”[5]此外，还有Harold J. Kushner （页面存档备份，存于互联网档案馆）在演讲中的评论，他记得贝尔曼。他在谈到贝尔曼时引用库什纳的话：“另一方面，当我问他同样的问题时，他回答说他试图通过加上动态来超越乔治·伯纳德·丹齐格的线性规划。也许这两种动机都是正确的。”\n", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的历史", "Tag": "算法设计"}
{"Answer": "最长公共子序列\nFloyd-Warshall算法\nViterbi算法\nKadane's_algorithm[6]\n求解馬可夫決策過程下最佳策略[7]", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的使用动态规划的算法", "Tag": "算法设计"}
{"Answer": "\n^ S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani, 'Algorithms', p 173, available at http://www.cs.berkeley.edu/~vazirani/algorithms.html （页面存档备份，存于互联网档案馆）\n\n^ Stuart Dreyfus. \"Richard Bellman on the birth of Dynamical Programming\".\n\n^ Eddy, S. R. What is Dynamic Programming?. Nature Biotechnology. 2004, 22 (7): 909–910. PMID 15229554. S2CID 5352062. doi:10.1038/nbt0704-909. \n\n^ Nocedal, J.; Wright, S. J. Numerical Optimization. Springer. 2006: 9. ISBN 9780387303031. \n\n^ Russell, S.; Norvig, P. Artificial Intelligence: A Modern Approach 3rd. Prentice Hall. 2009. ISBN 978-0-13-207148-2. \n\n^ Maximum_subarray_problem.   [2023-01-18]. （原始内容存档于2023-02-04）. \n\n^ Richard S. Sutton; Andrew G. Barto. Reinforcement Learning: An Introduction Second Edition. The MIT Press. 2018: 73  [2020-08-22]. （原始内容存档于2022-01-18）.  引文格式1维护：冗余文本 (link)\n\n", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的参考", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "动态规划", "Question": "什么是动态规划的外部链接", "Tag": "算法设计"}
{"Answer": "最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。算法具体的形式包括：\n确定起点的最短路径问题 - 也叫单源最短路问题，即已知起始结点，求最短路径的问题。在边权非负时适合使用Dijkstra算法，若边权为负时则适合使用Bellman-ford算法或者SPFA算法。\n确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。\n确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。\n全局最短路径问题 - 也叫多源最短路问题，求图中所有的最短路径。适合使用Floyd-Warshall算法。用于解决最短路径问题的算法被称做“最短路径算法”，有时被简称作“路径算法”。最常用的路径算法有：\nDijkstra算法\nA*算法\nBellman-Ford算法\nSPFA算法（Bellman-Ford算法的改进版本）\nFloyd-Warshall算法\nJohnson最短路算法（英语：Johnson's algorithm）\n双向搜索", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题", "Tag": "算法设计"}
{"Answer": "无向图[编辑]", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的无向图", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的无权图", "Tag": "算法设计"}
{"Answer": "使用拓扑排序算法可以在有权值的DAG中以线性时间（\n  \n    \n      \n        θ\n        (\n        E\n        +\n        V\n        )\n      \n    \n    {\\displaystyle \\theta (E+V)}\n  \n）求解单源最短路径问题。\n", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的有向无环图", "Tag": "算法设计"}
{"Answer": "假设边缘权重均为整数。\n", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的无负权的有向图", "Tag": "算法设计"}
{"Answer": "\n\n计算机科学主题\n计算机程序设计主题图论\n离散数学\n算法导论\n寻路\nIEEE 802.1aq\n网络流\n最短路徑樹", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的参见", "Tag": "算法设计"}
{"Answer": "最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。算法具体的形式包括：\n确定起点的最短路径问题 - 也叫单源最短路问题，即已知起始结点，求最短路径的问题。在边权非负时适合使用Dijkstra算法，若边权为负时则适合使用Bellman-ford算法或者SPFA算法。\n确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。\n确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。\n全局最短路径问题 - 也叫多源最短路问题，求图中所有的最短路径。适合使用Floyd-Warshall算法。用于解决最短路径问题的算法被称做“最短路径算法”，有时被简称作“路径算法”。最常用的路径算法有：\nDijkstra算法\nA*算法\nBellman-Ford算法\nSPFA算法（Bellman-Ford算法的改进版本）\nFloyd-Warshall算法\nJohnson最短路算法（英语：Johnson's algorithm）\n双向搜索", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题", "Tag": "算法设计"}
{"Answer": "无向图[编辑]", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的无向图", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的无权图", "Tag": "算法设计"}
{"Answer": "使用拓扑排序算法可以在有权值的DAG中以线性时间（\n  \n    \n      \n        θ\n        (\n        E\n        +\n        V\n        )\n      \n    \n    {\\displaystyle \\theta (E+V)}\n  \n）求解单源最短路径问题。\n", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的有向无环图", "Tag": "算法设计"}
{"Answer": "假设边缘权重均为整数。\n", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的单源最短路径算法的无负权的有向图", "Tag": "算法设计"}
{"Answer": "\n\n计算机科学主题\n计算机程序设计主题图论\n离散数学\n算法导论\n寻路\nIEEE 802.1aq\n网络流\n最短路徑樹", "Konwledge_Point": "最短路问题", "Question": "什么是最短路问题的参见", "Tag": "算法设计"}
{"Answer": "数学中，矩阵乘法（英語：matrix multiplication）是一种根据两个矩阵得到第三个矩阵的二元运算，第三个矩阵即前两者的乘积，称为矩阵积（英語：matrix product）。设\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是\n  \n    \n      \n        n\n        ×\n        m\n      \n    \n    {\\displaystyle n\\times m}\n  \n的矩阵，\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是\n  \n    \n      \n        m\n        ×\n        p\n      \n    \n    {\\displaystyle m\\times p}\n  \n的矩阵，则它们的矩阵积\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n是\n  \n    \n      \n        n\n        ×\n        p\n      \n    \n    {\\displaystyle n\\times p}\n  \n的矩阵。\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n中每一行的\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n个元素都与\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n中对应列的\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n个元素对应相乘，这些乘积的和就是\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n中的一个元素。\n矩阵可以用来表示线性映射，矩阵积则可以用来表示线性映射的复合。因此，矩阵乘法是线性代数的基础工具，不仅在数学中有大量应用，在应用数学、物理学、工程学等领域也有广泛使用。[1][2]\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法", "Tag": "算法设计"}
{"Answer": "矩陣相乘最重要的方法是一般矩陣乘積。它只有在第一個矩陣的列数（column，台湾作行數）和第二個矩陣的行数（row，台湾作列數）相同時才有定義。一般單指矩陣乘積時，指的便是一般矩陣乘積。若\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n為\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣，\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n為\n  \n    \n      \n        n\n        ×\n        p\n      \n    \n    {\\displaystyle n\\times p}\n  \n矩陣，則他們的乘積\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n(有時記做\n  \n    \n      \n        A\n        ⋅\n        B\n      \n    \n    {\\displaystyle A\\cdot B}\n  \n）會是一個\n  \n    \n      \n        m\n        ×\n        p\n      \n    \n    {\\displaystyle m\\times p}\n  \n矩陣。其乘積矩陣的元素如下面式子得出：\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          a\n          \n            i\n            r\n          \n        \n        \n          b\n          \n            r\n            j\n          \n        \n        =\n        \n          a\n          \n            i\n            1\n          \n        \n        \n          b\n          \n            1\n            j\n          \n        \n        +\n        \n          a\n          \n            i\n            2\n          \n        \n        \n          b\n          \n            2\n            j\n          \n        \n        +\n        ⋯\n        +\n        \n          a\n          \n            i\n            n\n          \n        \n        \n          b\n          \n            n\n            j\n          \n        \n      \n    \n    {\\displaystyle (AB)_{ij}=\\sum _{r=1}^{n}a_{ir}b_{rj}=a_{i1}b_{1j}+a_{i2}b_{2j}+\\cdots +a_{in}b_{nj}}\n  \n以上是用矩陣單元的代數系統來說明這類乘法的抽象性質。本節以下各種運算法都是這個公式的不同角度理解，運算結果相等：\n由定義直接計算[编辑]左邊的圖表示出要如何計算\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n的\n  \n    \n      \n        (\n        1\n        ,\n        2\n        )\n      \n    \n    {\\displaystyle (1,2)}\n  \n和\n  \n    \n      \n        (\n        3\n        ,\n        3\n        )\n      \n    \n    {\\displaystyle (3,3)}\n  \n元素，當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是個\n  \n    \n      \n        4\n        ×\n        2\n      \n    \n    {\\displaystyle 4\\times 2}\n  \n矩陣和B是個\n  \n    \n      \n        2\n        ×\n        3\n      \n    \n    {\\displaystyle 2\\times 3}\n  \n矩陣時。分別來自兩個矩陣的元素都依箭頭方向而兩兩配對，把每一對中的兩個元素相乘，再把這些乘積加總起來，最後得到的值即為箭頭相交位置的值。\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            1\n            ,\n            2\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            1\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            2\n          \n        \n        =\n        \n          a\n          \n            1\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            2\n          \n        \n        +\n        \n          a\n          \n            1\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle (AB)_{1,2}=\\sum _{r=1}^{2}a_{1,r}b_{r,2}=a_{1,1}b_{1,2}+a_{1,2}b_{2,2}}\n  \n\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            3\n            ,\n            3\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            3\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            3\n          \n        \n        =\n        \n          a\n          \n            3\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            3\n          \n        \n        +\n        \n          a\n          \n            3\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            3\n          \n        \n      \n    \n    {\\displaystyle (AB)_{3,3}=\\sum _{r=1}^{2}a_{3,r}b_{r,3}=a_{3,1}b_{1,3}+a_{3,2}b_{2,3}}\n  \n向量方法[编辑]這種矩陣乘積亦可由稍微不同的觀點來思考：把向量和各係數相乘後相加起來。設\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n是兩個給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        ,\n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&\\dots \\\\a_{2,1}&a_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}&A_{2}&\\dots \\end{bmatrix}},}\n  \n   \n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\\\b_{2,1}&b_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}\\\\B_{2}\\\\\\vdots \\end{bmatrix}}}\n  \n其中\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle a_{x,1}}\n  \n元素所组成的向量(column)，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{x,2}}\n  \n元素所组成的向量，以此类推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{1,x}}\n  \n元素所组成的向量(row)，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{2,x}}\n  \n元素所组成的向量，以此类推。則\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          A\n          \n            1\n          \n        \n        \n          B\n          \n            1\n          \n        \n        +\n        \n          A\n          \n            2\n          \n        \n        \n          B\n          \n            2\n          \n        \n        +\n        …\n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}a_{1,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{1,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\\\a_{2,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{2,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\vdots \\end{bmatrix}}=A_{1}B_{1}+A_{2}B_{2}+\\dots }\n  \n舉個例子來說：\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  0\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  2\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  −\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  3\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            0\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            −\n                            3\n                          \n                          \n                            −\n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            6\n                          \n                          \n                            3\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}1{\\begin{bmatrix}3&1\\end{bmatrix}}+0{\\begin{bmatrix}2&1\\end{bmatrix}}+2{\\begin{bmatrix}1&0\\end{bmatrix}}\\\\-1{\\begin{bmatrix}3&1\\end{bmatrix}}+3{\\begin{bmatrix}2&1\\end{bmatrix}}+1{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}={\\begin{bmatrix}{\\begin{bmatrix}3&1\\end{bmatrix}}+{\\begin{bmatrix}0&0\\end{bmatrix}}+{\\begin{bmatrix}2&0\\end{bmatrix}}\\\\{\\begin{bmatrix}-3&-1\\end{bmatrix}}+{\\begin{bmatrix}6&3\\end{bmatrix}}+{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}}\n  \n\n\n  \n    \n      \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle ={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n左面矩陣的列為為係數表，右邊矩陣為向量表。例如，第一行是[1 0 2]，因此將1乘上第一個向量，0乘上第二個向量，2則乘上第三個向量。\n向量表方法[编辑]一般矩陣乘積也可以想為是行向量和列向量的內積。若\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n為給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&a_{1,3}&\\dots \\\\a_{2,1}&a_{2,2}&a_{2,3}&\\dots \\\\a_{3,1}&a_{3,2}&a_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}}\n  \n且\n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&b_{1,3}&\\dots \\\\b_{2,1}&b_{2,2}&b_{2,3}&\\dots \\\\b_{3,1}&b_{3,2}&b_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}}\n  \n其中，这里\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{1,x}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{2,x}}\n  \n元素所組成的向量，以此類推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle b_{x,1}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle b_{x,2}}\n  \n元素所組成的向量，以此類推。则\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        ×\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}\\times {\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}={\\begin{bmatrix}(A_{1}\\cdot B_{1})&(A_{1}\\cdot B_{2})&(A_{1}\\cdot B_{3})&\\dots \\\\(A_{2}\\cdot B_{1})&(A_{2}\\cdot B_{2})&(A_{2}\\cdot B_{3})&\\dots \\\\(A_{3}\\cdot B_{1})&(A_{3}\\cdot B_{2})&(A_{3}\\cdot B_{3})&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}}\n  \n即\n\n  \n    \n      \n        \n          \n            (\n            \n              A\n              B\n            \n            )\n          \n          \n            i\n            j\n          \n        \n        =\n        \n          A\n          \n            i\n          \n        \n        \n          B\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\left(\\mathbf {AB} \\right)_{ij}=A_{i}B_{j}}\n  \n性質[编辑]矩陣乘法是不可交換的（即\n  \n    \n      \n        A\n        B\n        ≠\n        B\n        A\n      \n    \n    {\\displaystyle AB\\neq BA}\n  \n），除了一些較特別的情況。很清楚可以知道，不可能預期說在改變向量的部份後還能得到相同的結果，而且第一個矩陣的列數必須要和第二個矩陣的行數相同，也可以看出為什麼矩陣相乘的順序會影響其結果。\n雖然矩陣乘法是不可交換的，但\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n和\n  \n    \n      \n        B\n        A\n      \n    \n    {\\displaystyle BA}\n  \n的行列式總會是一樣的（當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是同樣大小的方陣時）。其解釋在行列式條目內。\n當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n可以被解釋為線性算子，其矩陣乘積\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n會對應為兩個線性算子的複合函數，其中B先作用。\n在試算表中做矩陣乘法[编辑]\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n\n\n以 Google Sheet 為例，選取儲存格範圍或者使用陣列，在儲存格輸入=MMULT({1,0,2;-1,3,1},{3,1;2,1;1,0})\n在某些試算表軟體中必須必須按Ctrl+⇧ Shift+↵ Enter 將儲存格內的變數轉換為陣列\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積", "Tag": "算法设计"}
{"Answer": "左邊的圖表示出要如何計算\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n的\n  \n    \n      \n        (\n        1\n        ,\n        2\n        )\n      \n    \n    {\\displaystyle (1,2)}\n  \n和\n  \n    \n      \n        (\n        3\n        ,\n        3\n        )\n      \n    \n    {\\displaystyle (3,3)}\n  \n元素，當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是個\n  \n    \n      \n        4\n        ×\n        2\n      \n    \n    {\\displaystyle 4\\times 2}\n  \n矩陣和B是個\n  \n    \n      \n        2\n        ×\n        3\n      \n    \n    {\\displaystyle 2\\times 3}\n  \n矩陣時。分別來自兩個矩陣的元素都依箭頭方向而兩兩配對，把每一對中的兩個元素相乘，再把這些乘積加總起來，最後得到的值即為箭頭相交位置的值。\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            1\n            ,\n            2\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            1\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            2\n          \n        \n        =\n        \n          a\n          \n            1\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            2\n          \n        \n        +\n        \n          a\n          \n            1\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle (AB)_{1,2}=\\sum _{r=1}^{2}a_{1,r}b_{r,2}=a_{1,1}b_{1,2}+a_{1,2}b_{2,2}}\n  \n\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            3\n            ,\n            3\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            3\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            3\n          \n        \n        =\n        \n          a\n          \n            3\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            3\n          \n        \n        +\n        \n          a\n          \n            3\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            3\n          \n        \n      \n    \n    {\\displaystyle (AB)_{3,3}=\\sum _{r=1}^{2}a_{3,r}b_{r,3}=a_{3,1}b_{1,3}+a_{3,2}b_{2,3}}\n  \n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的由定義直接計算", "Tag": "算法设计"}
{"Answer": "這種矩陣乘積亦可由稍微不同的觀點來思考：把向量和各係數相乘後相加起來。設\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n是兩個給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        ,\n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&\\dots \\\\a_{2,1}&a_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}&A_{2}&\\dots \\end{bmatrix}},}\n  \n   \n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\\\b_{2,1}&b_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}\\\\B_{2}\\\\\\vdots \\end{bmatrix}}}\n  \n其中\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle a_{x,1}}\n  \n元素所组成的向量(column)，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{x,2}}\n  \n元素所组成的向量，以此类推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{1,x}}\n  \n元素所组成的向量(row)，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{2,x}}\n  \n元素所组成的向量，以此类推。則\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          A\n          \n            1\n          \n        \n        \n          B\n          \n            1\n          \n        \n        +\n        \n          A\n          \n            2\n          \n        \n        \n          B\n          \n            2\n          \n        \n        +\n        …\n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}a_{1,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{1,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\\\a_{2,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{2,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\vdots \\end{bmatrix}}=A_{1}B_{1}+A_{2}B_{2}+\\dots }\n  \n舉個例子來說：\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  0\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  2\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  −\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  3\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            0\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            −\n                            3\n                          \n                          \n                            −\n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            6\n                          \n                          \n                            3\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}1{\\begin{bmatrix}3&1\\end{bmatrix}}+0{\\begin{bmatrix}2&1\\end{bmatrix}}+2{\\begin{bmatrix}1&0\\end{bmatrix}}\\\\-1{\\begin{bmatrix}3&1\\end{bmatrix}}+3{\\begin{bmatrix}2&1\\end{bmatrix}}+1{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}={\\begin{bmatrix}{\\begin{bmatrix}3&1\\end{bmatrix}}+{\\begin{bmatrix}0&0\\end{bmatrix}}+{\\begin{bmatrix}2&0\\end{bmatrix}}\\\\{\\begin{bmatrix}-3&-1\\end{bmatrix}}+{\\begin{bmatrix}6&3\\end{bmatrix}}+{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}}\n  \n\n\n  \n    \n      \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle ={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n左面矩陣的列為為係數表，右邊矩陣為向量表。例如，第一行是[1 0 2]，因此將1乘上第一個向量，0乘上第二個向量，2則乘上第三個向量。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的向量方法", "Tag": "算法设计"}
{"Answer": "一般矩陣乘積也可以想為是行向量和列向量的內積。若\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n為給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&a_{1,3}&\\dots \\\\a_{2,1}&a_{2,2}&a_{2,3}&\\dots \\\\a_{3,1}&a_{3,2}&a_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}}\n  \n且\n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&b_{1,3}&\\dots \\\\b_{2,1}&b_{2,2}&b_{2,3}&\\dots \\\\b_{3,1}&b_{3,2}&b_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}}\n  \n其中，这里\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{1,x}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{2,x}}\n  \n元素所組成的向量，以此類推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle b_{x,1}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle b_{x,2}}\n  \n元素所組成的向量，以此類推。则\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        ×\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}\\times {\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}={\\begin{bmatrix}(A_{1}\\cdot B_{1})&(A_{1}\\cdot B_{2})&(A_{1}\\cdot B_{3})&\\dots \\\\(A_{2}\\cdot B_{1})&(A_{2}\\cdot B_{2})&(A_{2}\\cdot B_{3})&\\dots \\\\(A_{3}\\cdot B_{1})&(A_{3}\\cdot B_{2})&(A_{3}\\cdot B_{3})&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}}\n  \n即\n\n  \n    \n      \n        \n          \n            (\n            \n              A\n              B\n            \n            )\n          \n          \n            i\n            j\n          \n        \n        =\n        \n          A\n          \n            i\n          \n        \n        \n          B\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\left(\\mathbf {AB} \\right)_{ij}=A_{i}B_{j}}\n  \n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的向量表方法", "Tag": "算法设计"}
{"Answer": "矩陣乘法是不可交換的（即\n  \n    \n      \n        A\n        B\n        ≠\n        B\n        A\n      \n    \n    {\\displaystyle AB\\neq BA}\n  \n），除了一些較特別的情況。很清楚可以知道，不可能預期說在改變向量的部份後還能得到相同的結果，而且第一個矩陣的列數必須要和第二個矩陣的行數相同，也可以看出為什麼矩陣相乘的順序會影響其結果。\n雖然矩陣乘法是不可交換的，但\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n和\n  \n    \n      \n        B\n        A\n      \n    \n    {\\displaystyle BA}\n  \n的行列式總會是一樣的（當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是同樣大小的方陣時）。其解釋在行列式條目內。\n當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n可以被解釋為線性算子，其矩陣乘積\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n會對應為兩個線性算子的複合函數，其中B先作用。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的性質", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n\n\n以 Google Sheet 為例，選取儲存格範圍或者使用陣列，在儲存格輸入=MMULT({1,0,2;-1,3,1},{3,1;2,1;1,0})\n在某些試算表軟體中必須必須按Ctrl+⇧ Shift+↵ Enter 將儲存格內的變數轉換為陣列\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的在試算表中做矩陣乘法", "Tag": "算法设计"}
{"Answer": "矩陣\n  \n    \n      \n        A\n        =\n        (\n        \n          a\n          \n            i\n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle A=(a_{ij})}\n  \n和純量\n  \n    \n      \n        r\n      \n    \n    {\\displaystyle r}\n  \n的純量乘積\n  \n    \n      \n        r\n        A\n      \n    \n    {\\displaystyle rA}\n  \n的矩陣大小和\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n一樣，\n  \n    \n      \n        r\n        A\n      \n    \n    {\\displaystyle rA}\n  \n的各元素定義如下：\n\n  \n    \n      \n        (\n        r\n        A\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        r\n        ⋅\n        \n          a\n          \n            i\n            j\n          \n        \n         \n      \n    \n    {\\displaystyle (rA)_{ij}=r\\cdot a_{ij}\\ }\n  \n若我們考慮於一個環的矩陣時，上述的乘積有時會稱做左乘積，而右乘積的則定義為\n\n  \n    \n      \n        (\n        A\n        r\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        \n          a\n          \n            i\n            j\n          \n        \n        ⋅\n        r\n         \n      \n    \n    {\\displaystyle (Ar)_{ij}=a_{ij}\\cdot r\\ }\n  \n當環是可交換時，例如實數體或複數體，這兩個乘積是相同的。但無論如何，若環是不可交換的話，如四元數，他們可能會是不同的。例如，\n\n  \n    \n      \n        i\n        \n          \n            [\n            \n              \n                \n                  i\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  j\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  −\n                  1\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  k\n                \n              \n            \n            ]\n          \n        \n        ≠\n        \n          \n            [\n            \n              \n                \n                  −\n                  1\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  −\n                  k\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  i\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  j\n                \n              \n            \n            ]\n          \n        \n        i\n      \n    \n    {\\displaystyle i{\\begin{bmatrix}i&0\\\\0&j\\\\\\end{bmatrix}}={\\begin{bmatrix}-1&0\\\\0&k\\\\\\end{bmatrix}}\\neq {\\begin{bmatrix}-1&0\\\\0&-k\\\\\\end{bmatrix}}={\\begin{bmatrix}i&0\\\\0&j\\\\\\end{bmatrix}}i}\n  \n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的純量乘積", "Tag": "算法设计"}
{"Answer": "参见：阿達瑪乘積_(矩陣)給定兩個相同維度的矩陣可計算有阿達馬乘積（Hadamard product），或稱做逐項乘積、分素乘積（element-wise product, entrywise product）。兩個\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n的阿達馬乘積標記為\n  \n    \n      \n        A\n        ∘\n        B\n      \n    \n    {\\displaystyle A\\circ B}\n  \n，定義為\n\n  \n    \n      \n        (\n        A\n        ∘\n        B\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        \n          a\n          \n            i\n            j\n          \n        \n        \n          b\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle (A\\circ B)_{ij}=a_{ij}b_{ij}}\n  \n的\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣。例如，\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  3\n                \n                \n                  2\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  0\n                \n              \n              \n                \n                  1\n                \n                \n                  2\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n        ∘\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  7\n                \n                \n                  5\n                \n                \n                  0\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  ⋅\n                  0\n                \n                \n                  3\n                  ⋅\n                  0\n                \n                \n                  2\n                  ⋅\n                  2\n                \n              \n              \n                \n                  1\n                  ⋅\n                  7\n                \n                \n                  0\n                  ⋅\n                  5\n                \n                \n                  0\n                  ⋅\n                  0\n                \n              \n              \n                \n                  1\n                  ⋅\n                  2\n                \n                \n                  2\n                  ⋅\n                  1\n                \n                \n                  2\n                  ⋅\n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  0\n                \n                \n                  4\n                \n              \n              \n                \n                  7\n                \n                \n                  0\n                \n                \n                  0\n                \n              \n              \n                \n                  2\n                \n                \n                  2\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&3&2\\\\1&0&0\\\\1&2&2\\end{bmatrix}}\\circ {\\begin{bmatrix}0&0&2\\\\7&5&0\\\\2&1&1\\end{bmatrix}}={\\begin{bmatrix}1\\cdot 0&3\\cdot 0&2\\cdot 2\\\\1\\cdot 7&0\\cdot 5&0\\cdot 0\\\\1\\cdot 2&2\\cdot 1&2\\cdot 1\\end{bmatrix}}={\\begin{bmatrix}0&0&4\\\\7&0&0\\\\2&2&2\\end{bmatrix}}}\n  \n需注意的是，阿達馬乘積是克羅內克乘積的子矩陣。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的阿達馬乘積", "Tag": "算法设计"}
{"Answer": "主条目：克羅內克乘積給定任兩個矩陣\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n和\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n，可以得到兩個矩陣的直積，或稱為克羅內克乘積\n  \n    \n      \n        A\n        ⊗\n        B\n      \n    \n    {\\displaystyle A\\otimes B}\n  \n，其定義如下\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      11\n                    \n                  \n                  B\n                \n                \n                  \n                    a\n                    \n                      12\n                    \n                  \n                  B\n                \n                \n                  ⋯\n                \n                \n                  \n                    a\n                    \n                      1\n                      n\n                    \n                  \n                  B\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                      1\n                    \n                  \n                  B\n                \n                \n                  \n                    a\n                    \n                      m\n                      2\n                    \n                  \n                  B\n                \n                \n                  ⋯\n                \n                \n                  \n                    a\n                    \n                      m\n                      n\n                    \n                  \n                  B\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}a_{11}B&a_{12}B&\\cdots &a_{1n}B\\\\\\vdots &\\vdots &\\ddots &\\vdots \\\\a_{m1}B&a_{m2}B&\\cdots &a_{mn}B\\end{bmatrix}}}\n  \n當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是一\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣和\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是一\n  \n    \n      \n        p\n        ×\n        r\n      \n    \n    {\\displaystyle p\\times r}\n  \n矩陣時，\n  \n    \n      \n        A\n        ⊗\n        B\n      \n    \n    {\\displaystyle A\\otimes B}\n  \n會是一\n  \n    \n      \n        m\n        p\n        ×\n        n\n        r\n      \n    \n    {\\displaystyle mp\\times nr}\n  \n矩陣，而且此一乘積也是不可交換的。\n舉個例子，\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  2\n                \n              \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⊗\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  3\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  ⋅\n                  0\n                \n                \n                  1\n                  ⋅\n                  3\n                \n                \n                  2\n                  ⋅\n                  0\n                \n                \n                  2\n                  ⋅\n                  3\n                \n              \n              \n                \n                  1\n                  ⋅\n                  2\n                \n                \n                  1\n                  ⋅\n                  1\n                \n                \n                  2\n                  ⋅\n                  2\n                \n                \n                  2\n                  ⋅\n                  1\n                \n              \n              \n                \n                  3\n                  ⋅\n                  0\n                \n                \n                  3\n                  ⋅\n                  3\n                \n                \n                  1\n                  ⋅\n                  0\n                \n                \n                  1\n                  ⋅\n                  3\n                \n              \n              \n                \n                  3\n                  ⋅\n                  2\n                \n                \n                  3\n                  ⋅\n                  1\n                \n                \n                  1\n                  ⋅\n                  2\n                \n                \n                  1\n                  ⋅\n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  3\n                \n                \n                  0\n                \n                \n                  6\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n                \n                  4\n                \n                \n                  2\n                \n              \n              \n                \n                  0\n                \n                \n                  9\n                \n                \n                  0\n                \n                \n                  3\n                \n              \n              \n                \n                  6\n                \n                \n                  3\n                \n                \n                  2\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&2\\\\3&1\\\\\\end{bmatrix}}\\otimes {\\begin{bmatrix}0&3\\\\2&1\\\\\\end{bmatrix}}={\\begin{bmatrix}1\\cdot 0&1\\cdot 3&2\\cdot 0&2\\cdot 3\\\\1\\cdot 2&1\\cdot 1&2\\cdot 2&2\\cdot 1\\\\3\\cdot 0&3\\cdot 3&1\\cdot 0&1\\cdot 3\\\\3\\cdot 2&3\\cdot 1&1\\cdot 2&1\\cdot 1\\\\\\end{bmatrix}}={\\begin{bmatrix}0&3&0&6\\\\2&1&4&2\\\\0&9&0&3\\\\6&3&2&1\\end{bmatrix}}}\n  \n若\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n和\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n分別表示兩個線性算子\n  \n    \n      \n        \n          V\n          \n            1\n          \n        \n        →\n        \n          W\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle V_{1}\\to W_{1}}\n  \n和\n  \n    \n      \n        \n          V\n          \n            2\n          \n        \n        →\n        \n          W\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle V_{2}\\to W_{2}}\n  \n，\n  \n    \n      \n        A\n        ⊗\n        B\n      \n    \n    {\\displaystyle A\\otimes B}\n  \n便為其映射的張量乘積，\n  \n    \n      \n        \n          V\n          \n            1\n          \n        \n        ⊗\n        \n          V\n          \n            2\n          \n        \n        →\n        \n          W\n          \n            1\n          \n        \n        ⊗\n        \n          W\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle V_{1}\\otimes V_{2}\\to W_{1}\\otimes W_{2}}\n  \n\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的克羅內克乘積", "Tag": "算法设计"}
{"Answer": "上述三種乘積都符合結合律：\n\n  \n    \n      \n        A\n        (\n        B\n        C\n        )\n        =\n        (\n        A\n        B\n        )\n        C\n      \n    \n    {\\displaystyle A(BC)=(AB)C}\n  \n以及分配律：\n\n  \n    \n      \n        A\n        (\n        B\n        +\n        C\n        )\n        =\n        A\n        B\n        +\n        A\n        C\n      \n    \n    {\\displaystyle A(B+C)=AB+AC}\n  \n\n\n  \n    \n      \n        (\n        A\n        +\n        B\n        )\n        C\n        =\n        A\n        C\n        +\n        B\n        C\n      \n    \n    {\\displaystyle (A+B)C=AC+BC}\n  \n而且和純量乘積相容：\n\n  \n    \n      \n        c\n        (\n        A\n        B\n        )\n        =\n        (\n        c\n        A\n        )\n        B\n      \n    \n    {\\displaystyle c(AB)=(cA)B}\n  \n\n\n  \n    \n      \n        (\n        A\n        c\n        )\n        B\n        =\n        A\n        (\n        c\n        B\n        )\n      \n    \n    {\\displaystyle (Ac)B=A(cB)}\n  \n\n\n  \n    \n      \n        (\n        A\n        B\n        )\n        c\n        =\n        A\n        (\n        B\n        c\n        )\n      \n    \n    {\\displaystyle (AB)c=A(Bc)}\n  \n注意上述三個分開的表示式只有在純量體的乘法及加法是可交換（即純量體為一可交換環）時會相同。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的共同性質", "Tag": "算法设计"}
{"Answer": "Strassen演算法（1969）\nWinograd演算法（1980）\nCoppersmith–Winograd演算法（1990）\n邏輯矩陣\n矩陣鏈乘積\n逆矩陣\n關係複合\nBLAS\n矩陣加法\n矩阵微积分", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的另見", "Tag": "算法设计"}
{"Answer": "WIMS Online Matrix Multiplier （页面存档备份，存于互联网档案馆）\nAnimated Matrix Multiplication Examples (purplemath) （页面存档备份，存于互联网档案馆）Matrix Multipication in Javascript （页面存档备份，存于互联网档案馆）（works in Firefox）", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的外部連結", "Tag": "算法设计"}
{"Answer": "\n\n^ Lerner, R. G.; Trigg, G. L. Encyclopaedia of Physics 2nd. VHC publishers. 1991. ISBN 3-527-26954-1 （英语）. \n\n^ Parker, C. B. McGraw Hill Encyclopaedia of Physics 2nd. 1994. ISBN 0-07-051400-3 （英语）. \n\n其它参考文献包括：\nStrassen, Volker, Gaussian Elimination is not Optimal, Numer. Math. 13, p. 354-356, 1969.\nCoppersmith, D., Winograd S., Matrix multiplication via arithmetic progressions, J. Symbolic Comput. 9, p. 251-280, 1990.\nHorn, Roger; Johnson, Charles: \"Topics in Matrix Analysis\", Cambridge, 1994.\nRobinson, Sara, Toward an Optimal Algorithm for Matrix Multiplication, SIAM News 38(9), November 2005.", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的參考", "Tag": "算法设计"}
{"Answer": "数学中，矩阵乘法（英語：matrix multiplication）是一种根据两个矩阵得到第三个矩阵的二元运算，第三个矩阵即前两者的乘积，称为矩阵积（英語：matrix product）。设\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是\n  \n    \n      \n        n\n        ×\n        m\n      \n    \n    {\\displaystyle n\\times m}\n  \n的矩阵，\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是\n  \n    \n      \n        m\n        ×\n        p\n      \n    \n    {\\displaystyle m\\times p}\n  \n的矩阵，则它们的矩阵积\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n是\n  \n    \n      \n        n\n        ×\n        p\n      \n    \n    {\\displaystyle n\\times p}\n  \n的矩阵。\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n中每一行的\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n个元素都与\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n中对应列的\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n个元素对应相乘，这些乘积的和就是\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n中的一个元素。\n矩阵可以用来表示线性映射，矩阵积则可以用来表示线性映射的复合。因此，矩阵乘法是线性代数的基础工具，不仅在数学中有大量应用，在应用数学、物理学、工程学等领域也有广泛使用。[1][2]\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法", "Tag": "算法设计"}
{"Answer": "矩陣相乘最重要的方法是一般矩陣乘積。它只有在第一個矩陣的列数（column，台湾作行數）和第二個矩陣的行数（row，台湾作列數）相同時才有定義。一般單指矩陣乘積時，指的便是一般矩陣乘積。若\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n為\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣，\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n為\n  \n    \n      \n        n\n        ×\n        p\n      \n    \n    {\\displaystyle n\\times p}\n  \n矩陣，則他們的乘積\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n(有時記做\n  \n    \n      \n        A\n        ⋅\n        B\n      \n    \n    {\\displaystyle A\\cdot B}\n  \n）會是一個\n  \n    \n      \n        m\n        ×\n        p\n      \n    \n    {\\displaystyle m\\times p}\n  \n矩陣。其乘積矩陣的元素如下面式子得出：\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          a\n          \n            i\n            r\n          \n        \n        \n          b\n          \n            r\n            j\n          \n        \n        =\n        \n          a\n          \n            i\n            1\n          \n        \n        \n          b\n          \n            1\n            j\n          \n        \n        +\n        \n          a\n          \n            i\n            2\n          \n        \n        \n          b\n          \n            2\n            j\n          \n        \n        +\n        ⋯\n        +\n        \n          a\n          \n            i\n            n\n          \n        \n        \n          b\n          \n            n\n            j\n          \n        \n      \n    \n    {\\displaystyle (AB)_{ij}=\\sum _{r=1}^{n}a_{ir}b_{rj}=a_{i1}b_{1j}+a_{i2}b_{2j}+\\cdots +a_{in}b_{nj}}\n  \n以上是用矩陣單元的代數系統來說明這類乘法的抽象性質。本節以下各種運算法都是這個公式的不同角度理解，運算結果相等：\n由定義直接計算[编辑]左邊的圖表示出要如何計算\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n的\n  \n    \n      \n        (\n        1\n        ,\n        2\n        )\n      \n    \n    {\\displaystyle (1,2)}\n  \n和\n  \n    \n      \n        (\n        3\n        ,\n        3\n        )\n      \n    \n    {\\displaystyle (3,3)}\n  \n元素，當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是個\n  \n    \n      \n        4\n        ×\n        2\n      \n    \n    {\\displaystyle 4\\times 2}\n  \n矩陣和B是個\n  \n    \n      \n        2\n        ×\n        3\n      \n    \n    {\\displaystyle 2\\times 3}\n  \n矩陣時。分別來自兩個矩陣的元素都依箭頭方向而兩兩配對，把每一對中的兩個元素相乘，再把這些乘積加總起來，最後得到的值即為箭頭相交位置的值。\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            1\n            ,\n            2\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            1\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            2\n          \n        \n        =\n        \n          a\n          \n            1\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            2\n          \n        \n        +\n        \n          a\n          \n            1\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle (AB)_{1,2}=\\sum _{r=1}^{2}a_{1,r}b_{r,2}=a_{1,1}b_{1,2}+a_{1,2}b_{2,2}}\n  \n\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            3\n            ,\n            3\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            3\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            3\n          \n        \n        =\n        \n          a\n          \n            3\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            3\n          \n        \n        +\n        \n          a\n          \n            3\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            3\n          \n        \n      \n    \n    {\\displaystyle (AB)_{3,3}=\\sum _{r=1}^{2}a_{3,r}b_{r,3}=a_{3,1}b_{1,3}+a_{3,2}b_{2,3}}\n  \n向量方法[编辑]這種矩陣乘積亦可由稍微不同的觀點來思考：把向量和各係數相乘後相加起來。設\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n是兩個給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        ,\n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&\\dots \\\\a_{2,1}&a_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}&A_{2}&\\dots \\end{bmatrix}},}\n  \n   \n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\\\b_{2,1}&b_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}\\\\B_{2}\\\\\\vdots \\end{bmatrix}}}\n  \n其中\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle a_{x,1}}\n  \n元素所组成的向量(column)，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{x,2}}\n  \n元素所组成的向量，以此类推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{1,x}}\n  \n元素所组成的向量(row)，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{2,x}}\n  \n元素所组成的向量，以此类推。則\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          A\n          \n            1\n          \n        \n        \n          B\n          \n            1\n          \n        \n        +\n        \n          A\n          \n            2\n          \n        \n        \n          B\n          \n            2\n          \n        \n        +\n        …\n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}a_{1,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{1,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\\\a_{2,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{2,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\vdots \\end{bmatrix}}=A_{1}B_{1}+A_{2}B_{2}+\\dots }\n  \n舉個例子來說：\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  0\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  2\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  −\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  3\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            0\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            −\n                            3\n                          \n                          \n                            −\n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            6\n                          \n                          \n                            3\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}1{\\begin{bmatrix}3&1\\end{bmatrix}}+0{\\begin{bmatrix}2&1\\end{bmatrix}}+2{\\begin{bmatrix}1&0\\end{bmatrix}}\\\\-1{\\begin{bmatrix}3&1\\end{bmatrix}}+3{\\begin{bmatrix}2&1\\end{bmatrix}}+1{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}={\\begin{bmatrix}{\\begin{bmatrix}3&1\\end{bmatrix}}+{\\begin{bmatrix}0&0\\end{bmatrix}}+{\\begin{bmatrix}2&0\\end{bmatrix}}\\\\{\\begin{bmatrix}-3&-1\\end{bmatrix}}+{\\begin{bmatrix}6&3\\end{bmatrix}}+{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}}\n  \n\n\n  \n    \n      \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle ={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n左面矩陣的列為為係數表，右邊矩陣為向量表。例如，第一行是[1 0 2]，因此將1乘上第一個向量，0乘上第二個向量，2則乘上第三個向量。\n向量表方法[编辑]一般矩陣乘積也可以想為是行向量和列向量的內積。若\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n為給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&a_{1,3}&\\dots \\\\a_{2,1}&a_{2,2}&a_{2,3}&\\dots \\\\a_{3,1}&a_{3,2}&a_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}}\n  \n且\n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&b_{1,3}&\\dots \\\\b_{2,1}&b_{2,2}&b_{2,3}&\\dots \\\\b_{3,1}&b_{3,2}&b_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}}\n  \n其中，这里\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{1,x}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{2,x}}\n  \n元素所組成的向量，以此類推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle b_{x,1}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle b_{x,2}}\n  \n元素所組成的向量，以此類推。则\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        ×\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}\\times {\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}={\\begin{bmatrix}(A_{1}\\cdot B_{1})&(A_{1}\\cdot B_{2})&(A_{1}\\cdot B_{3})&\\dots \\\\(A_{2}\\cdot B_{1})&(A_{2}\\cdot B_{2})&(A_{2}\\cdot B_{3})&\\dots \\\\(A_{3}\\cdot B_{1})&(A_{3}\\cdot B_{2})&(A_{3}\\cdot B_{3})&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}}\n  \n即\n\n  \n    \n      \n        \n          \n            (\n            \n              A\n              B\n            \n            )\n          \n          \n            i\n            j\n          \n        \n        =\n        \n          A\n          \n            i\n          \n        \n        \n          B\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\left(\\mathbf {AB} \\right)_{ij}=A_{i}B_{j}}\n  \n性質[编辑]矩陣乘法是不可交換的（即\n  \n    \n      \n        A\n        B\n        ≠\n        B\n        A\n      \n    \n    {\\displaystyle AB\\neq BA}\n  \n），除了一些較特別的情況。很清楚可以知道，不可能預期說在改變向量的部份後還能得到相同的結果，而且第一個矩陣的列數必須要和第二個矩陣的行數相同，也可以看出為什麼矩陣相乘的順序會影響其結果。\n雖然矩陣乘法是不可交換的，但\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n和\n  \n    \n      \n        B\n        A\n      \n    \n    {\\displaystyle BA}\n  \n的行列式總會是一樣的（當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是同樣大小的方陣時）。其解釋在行列式條目內。\n當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n可以被解釋為線性算子，其矩陣乘積\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n會對應為兩個線性算子的複合函數，其中B先作用。\n在試算表中做矩陣乘法[编辑]\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n\n\n以 Google Sheet 為例，選取儲存格範圍或者使用陣列，在儲存格輸入=MMULT({1,0,2;-1,3,1},{3,1;2,1;1,0})\n在某些試算表軟體中必須必須按Ctrl+⇧ Shift+↵ Enter 將儲存格內的變數轉換為陣列\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積", "Tag": "算法设计"}
{"Answer": "左邊的圖表示出要如何計算\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n的\n  \n    \n      \n        (\n        1\n        ,\n        2\n        )\n      \n    \n    {\\displaystyle (1,2)}\n  \n和\n  \n    \n      \n        (\n        3\n        ,\n        3\n        )\n      \n    \n    {\\displaystyle (3,3)}\n  \n元素，當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是個\n  \n    \n      \n        4\n        ×\n        2\n      \n    \n    {\\displaystyle 4\\times 2}\n  \n矩陣和B是個\n  \n    \n      \n        2\n        ×\n        3\n      \n    \n    {\\displaystyle 2\\times 3}\n  \n矩陣時。分別來自兩個矩陣的元素都依箭頭方向而兩兩配對，把每一對中的兩個元素相乘，再把這些乘積加總起來，最後得到的值即為箭頭相交位置的值。\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            1\n            ,\n            2\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            1\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            2\n          \n        \n        =\n        \n          a\n          \n            1\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            2\n          \n        \n        +\n        \n          a\n          \n            1\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle (AB)_{1,2}=\\sum _{r=1}^{2}a_{1,r}b_{r,2}=a_{1,1}b_{1,2}+a_{1,2}b_{2,2}}\n  \n\n\n  \n    \n      \n        (\n        A\n        B\n        \n          )\n          \n            3\n            ,\n            3\n          \n        \n        =\n        \n          ∑\n          \n            r\n            =\n            1\n          \n          \n            2\n          \n        \n        \n          a\n          \n            3\n            ,\n            r\n          \n        \n        \n          b\n          \n            r\n            ,\n            3\n          \n        \n        =\n        \n          a\n          \n            3\n            ,\n            1\n          \n        \n        \n          b\n          \n            1\n            ,\n            3\n          \n        \n        +\n        \n          a\n          \n            3\n            ,\n            2\n          \n        \n        \n          b\n          \n            2\n            ,\n            3\n          \n        \n      \n    \n    {\\displaystyle (AB)_{3,3}=\\sum _{r=1}^{2}a_{3,r}b_{r,3}=a_{3,1}b_{1,3}+a_{3,2}b_{2,3}}\n  \n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的由定義直接計算", "Tag": "算法设计"}
{"Answer": "這種矩陣乘積亦可由稍微不同的觀點來思考：把向量和各係數相乘後相加起來。設\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n是兩個給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        ,\n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&\\dots \\\\a_{2,1}&a_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}&A_{2}&\\dots \\end{bmatrix}},}\n  \n   \n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\\\b_{2,1}&b_{2,2}&\\dots \\\\\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}\\\\B_{2}\\\\\\vdots \\end{bmatrix}}}\n  \n其中\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle a_{x,1}}\n  \n元素所组成的向量(column)，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle a_{x,2}}\n  \n元素所组成的向量，以此类推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{1,x}}\n  \n元素所组成的向量(row)，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle b_{2,x}}\n  \n元素所组成的向量，以此类推。則\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                1\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                  \n                    \n                      [\n                      \n                        \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                1\n                              \n                            \n                          \n                          \n                            \n                              b\n                              \n                                2\n                                ,\n                                2\n                              \n                            \n                          \n                          \n                            …\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  ⋯\n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          A\n          \n            1\n          \n        \n        \n          B\n          \n            1\n          \n        \n        +\n        \n          A\n          \n            2\n          \n        \n        \n          B\n          \n            2\n          \n        \n        +\n        …\n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}a_{1,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{1,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\\\a_{2,1}{\\begin{bmatrix}b_{1,1}&b_{1,2}&\\dots \\end{bmatrix}}+a_{2,2}{\\begin{bmatrix}b_{2,1}&b_{2,2}&\\dots \\end{bmatrix}}+\\cdots \\\\\\vdots \\end{bmatrix}}=A_{1}B_{1}+A_{2}B_{2}+\\dots }\n  \n舉個例子來說：\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  0\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  2\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  −\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  3\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  1\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            3\n                          \n                          \n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            0\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            2\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n              \n                \n                  \n                    \n                      [\n                      \n                        \n                          \n                            −\n                            3\n                          \n                          \n                            −\n                            1\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            6\n                          \n                          \n                            3\n                          \n                        \n                      \n                      ]\n                    \n                  \n                  +\n                  \n                    \n                      [\n                      \n                        \n                          \n                            1\n                          \n                          \n                            0\n                          \n                        \n                      \n                      ]\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}1{\\begin{bmatrix}3&1\\end{bmatrix}}+0{\\begin{bmatrix}2&1\\end{bmatrix}}+2{\\begin{bmatrix}1&0\\end{bmatrix}}\\\\-1{\\begin{bmatrix}3&1\\end{bmatrix}}+3{\\begin{bmatrix}2&1\\end{bmatrix}}+1{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}={\\begin{bmatrix}{\\begin{bmatrix}3&1\\end{bmatrix}}+{\\begin{bmatrix}0&0\\end{bmatrix}}+{\\begin{bmatrix}2&0\\end{bmatrix}}\\\\{\\begin{bmatrix}-3&-1\\end{bmatrix}}+{\\begin{bmatrix}6&3\\end{bmatrix}}+{\\begin{bmatrix}1&0\\end{bmatrix}}\\end{bmatrix}}}\n  \n\n\n  \n    \n      \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle ={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n左面矩陣的列為為係數表，右邊矩陣為向量表。例如，第一行是[1 0 2]，因此將1乘上第一個向量，0乘上第二個向量，2則乘上第三個向量。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的向量方法", "Tag": "算法设计"}
{"Answer": "一般矩陣乘積也可以想為是行向量和列向量的內積。若\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n和\n  \n    \n      \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {B} }\n  \n為給定如下的矩陣：\n\n  \n    \n      \n        \n          A\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    a\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {A} ={\\begin{bmatrix}a_{1,1}&a_{1,2}&a_{1,3}&\\dots \\\\a_{2,1}&a_{2,2}&a_{2,3}&\\dots \\\\a_{3,1}&a_{3,2}&a_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}}\n  \n且\n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      1\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      2\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      3\n                      ,\n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} ={\\begin{bmatrix}b_{1,1}&b_{1,2}&b_{1,3}&\\dots \\\\b_{2,1}&b_{2,2}&b_{2,3}&\\dots \\\\b_{3,1}&b_{3,2}&b_{3,3}&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}={\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}}\n  \n其中，这里\n\n  \n    \n      \n        \n          A\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle A_{1}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            1\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{1,x}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          A\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle A_{2}}\n  \n是由所有\n  \n    \n      \n        \n          a\n          \n            2\n            ,\n            x\n          \n        \n      \n    \n    {\\displaystyle a_{2,x}}\n  \n元素所組成的向量，以此類推。\n\n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            1\n          \n        \n      \n    \n    {\\displaystyle b_{x,1}}\n  \n元素所組成的向量，\n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n是由所有\n  \n    \n      \n        \n          b\n          \n            x\n            ,\n            2\n          \n        \n      \n    \n    {\\displaystyle b_{x,2}}\n  \n元素所組成的向量，以此類推。则\n\n  \n    \n      \n        \n          A\n          B\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    A\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  \n                    A\n                    \n                      3\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n            \n            ]\n          \n        \n        ×\n        \n          \n            [\n            \n              \n                \n                  \n                    B\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      2\n                    \n                  \n                \n                \n                  \n                    B\n                    \n                      3\n                    \n                  \n                \n                \n                  …\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      1\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      2\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      1\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      2\n                    \n                  \n                  )\n                \n                \n                  (\n                  \n                    A\n                    \n                      3\n                    \n                  \n                  ⋅\n                  \n                    B\n                    \n                      3\n                    \n                  \n                  )\n                \n                \n                  …\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {AB} ={\\begin{bmatrix}A_{1}\\\\A_{2}\\\\A_{3}\\\\\\vdots \\end{bmatrix}}\\times {\\begin{bmatrix}B_{1}&B_{2}&B_{3}&\\dots \\end{bmatrix}}={\\begin{bmatrix}(A_{1}\\cdot B_{1})&(A_{1}\\cdot B_{2})&(A_{1}\\cdot B_{3})&\\dots \\\\(A_{2}\\cdot B_{1})&(A_{2}\\cdot B_{2})&(A_{2}\\cdot B_{3})&\\dots \\\\(A_{3}\\cdot B_{1})&(A_{3}\\cdot B_{2})&(A_{3}\\cdot B_{3})&\\dots \\\\\\vdots &\\vdots &\\vdots &\\ddots \\end{bmatrix}}}\n  \n即\n\n  \n    \n      \n        \n          \n            (\n            \n              A\n              B\n            \n            )\n          \n          \n            i\n            j\n          \n        \n        =\n        \n          A\n          \n            i\n          \n        \n        \n          B\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\left(\\mathbf {AB} \\right)_{ij}=A_{i}B_{j}}\n  \n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的向量表方法", "Tag": "算法设计"}
{"Answer": "矩陣乘法是不可交換的（即\n  \n    \n      \n        A\n        B\n        ≠\n        B\n        A\n      \n    \n    {\\displaystyle AB\\neq BA}\n  \n），除了一些較特別的情況。很清楚可以知道，不可能預期說在改變向量的部份後還能得到相同的結果，而且第一個矩陣的列數必須要和第二個矩陣的行數相同，也可以看出為什麼矩陣相乘的順序會影響其結果。\n雖然矩陣乘法是不可交換的，但\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n和\n  \n    \n      \n        B\n        A\n      \n    \n    {\\displaystyle BA}\n  \n的行列式總會是一樣的（當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是同樣大小的方陣時）。其解釋在行列式條目內。\n當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n可以被解釋為線性算子，其矩陣乘積\n  \n    \n      \n        A\n        B\n      \n    \n    {\\displaystyle AB}\n  \n會對應為兩個線性算子的複合函數，其中B先作用。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的性質", "Tag": "算法设计"}
{"Answer": "\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  −\n                  1\n                \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⋅\n        \n          \n            [\n            \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  5\n                \n                \n                  1\n                \n              \n              \n                \n                  4\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&0&2\\\\-1&3&1\\end{bmatrix}}\\cdot {\\begin{bmatrix}3&1\\\\2&1\\\\1&0\\end{bmatrix}}={\\begin{bmatrix}5&1\\\\4&2\\end{bmatrix}}}\n  \n\n\n以 Google Sheet 為例，選取儲存格範圍或者使用陣列，在儲存格輸入=MMULT({1,0,2;-1,3,1},{3,1;2,1;1,0})\n在某些試算表軟體中必須必須按Ctrl+⇧ Shift+↵ Enter 將儲存格內的變數轉換為陣列\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的一般矩陣乘積的在試算表中做矩陣乘法", "Tag": "算法设计"}
{"Answer": "矩陣\n  \n    \n      \n        A\n        =\n        (\n        \n          a\n          \n            i\n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle A=(a_{ij})}\n  \n和純量\n  \n    \n      \n        r\n      \n    \n    {\\displaystyle r}\n  \n的純量乘積\n  \n    \n      \n        r\n        A\n      \n    \n    {\\displaystyle rA}\n  \n的矩陣大小和\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n一樣，\n  \n    \n      \n        r\n        A\n      \n    \n    {\\displaystyle rA}\n  \n的各元素定義如下：\n\n  \n    \n      \n        (\n        r\n        A\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        r\n        ⋅\n        \n          a\n          \n            i\n            j\n          \n        \n         \n      \n    \n    {\\displaystyle (rA)_{ij}=r\\cdot a_{ij}\\ }\n  \n若我們考慮於一個環的矩陣時，上述的乘積有時會稱做左乘積，而右乘積的則定義為\n\n  \n    \n      \n        (\n        A\n        r\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        \n          a\n          \n            i\n            j\n          \n        \n        ⋅\n        r\n         \n      \n    \n    {\\displaystyle (Ar)_{ij}=a_{ij}\\cdot r\\ }\n  \n當環是可交換時，例如實數體或複數體，這兩個乘積是相同的。但無論如何，若環是不可交換的話，如四元數，他們可能會是不同的。例如，\n\n  \n    \n      \n        i\n        \n          \n            [\n            \n              \n                \n                  i\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  j\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  −\n                  1\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  k\n                \n              \n            \n            ]\n          \n        \n        ≠\n        \n          \n            [\n            \n              \n                \n                  −\n                  1\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  −\n                  k\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  i\n                \n                \n                  0\n                \n              \n              \n                \n                  0\n                \n                \n                  j\n                \n              \n            \n            ]\n          \n        \n        i\n      \n    \n    {\\displaystyle i{\\begin{bmatrix}i&0\\\\0&j\\\\\\end{bmatrix}}={\\begin{bmatrix}-1&0\\\\0&k\\\\\\end{bmatrix}}\\neq {\\begin{bmatrix}-1&0\\\\0&-k\\\\\\end{bmatrix}}={\\begin{bmatrix}i&0\\\\0&j\\\\\\end{bmatrix}}i}\n  \n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的純量乘積", "Tag": "算法设计"}
{"Answer": "参见：阿達瑪乘積_(矩陣)給定兩個相同維度的矩陣可計算有阿達馬乘積（Hadamard product），或稱做逐項乘積、分素乘積（element-wise product, entrywise product）。兩個\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n、\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n的阿達馬乘積標記為\n  \n    \n      \n        A\n        ∘\n        B\n      \n    \n    {\\displaystyle A\\circ B}\n  \n，定義為\n\n  \n    \n      \n        (\n        A\n        ∘\n        B\n        \n          )\n          \n            i\n            j\n          \n        \n        =\n        \n          a\n          \n            i\n            j\n          \n        \n        \n          b\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle (A\\circ B)_{ij}=a_{ij}b_{ij}}\n  \n的\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣。例如，\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  3\n                \n                \n                  2\n                \n              \n              \n                \n                  1\n                \n                \n                  0\n                \n                \n                  0\n                \n              \n              \n                \n                  1\n                \n                \n                  2\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n        ∘\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  0\n                \n                \n                  2\n                \n              \n              \n                \n                  7\n                \n                \n                  5\n                \n                \n                  0\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  ⋅\n                  0\n                \n                \n                  3\n                  ⋅\n                  0\n                \n                \n                  2\n                  ⋅\n                  2\n                \n              \n              \n                \n                  1\n                  ⋅\n                  7\n                \n                \n                  0\n                  ⋅\n                  5\n                \n                \n                  0\n                  ⋅\n                  0\n                \n              \n              \n                \n                  1\n                  ⋅\n                  2\n                \n                \n                  2\n                  ⋅\n                  1\n                \n                \n                  2\n                  ⋅\n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  0\n                \n                \n                  4\n                \n              \n              \n                \n                  7\n                \n                \n                  0\n                \n                \n                  0\n                \n              \n              \n                \n                  2\n                \n                \n                  2\n                \n                \n                  2\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&3&2\\\\1&0&0\\\\1&2&2\\end{bmatrix}}\\circ {\\begin{bmatrix}0&0&2\\\\7&5&0\\\\2&1&1\\end{bmatrix}}={\\begin{bmatrix}1\\cdot 0&3\\cdot 0&2\\cdot 2\\\\1\\cdot 7&0\\cdot 5&0\\cdot 0\\\\1\\cdot 2&2\\cdot 1&2\\cdot 1\\end{bmatrix}}={\\begin{bmatrix}0&0&4\\\\7&0&0\\\\2&2&2\\end{bmatrix}}}\n  \n需注意的是，阿達馬乘積是克羅內克乘積的子矩陣。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的阿達馬乘積", "Tag": "算法设计"}
{"Answer": "主条目：克羅內克乘積給定任兩個矩陣\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n和\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n，可以得到兩個矩陣的直積，或稱為克羅內克乘積\n  \n    \n      \n        A\n        ⊗\n        B\n      \n    \n    {\\displaystyle A\\otimes B}\n  \n，其定義如下\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      11\n                    \n                  \n                  B\n                \n                \n                  \n                    a\n                    \n                      12\n                    \n                  \n                  B\n                \n                \n                  ⋯\n                \n                \n                  \n                    a\n                    \n                      1\n                      n\n                    \n                  \n                  B\n                \n              \n              \n                \n                  ⋮\n                \n                \n                  ⋮\n                \n                \n                  ⋱\n                \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                      1\n                    \n                  \n                  B\n                \n                \n                  \n                    a\n                    \n                      m\n                      2\n                    \n                  \n                  B\n                \n                \n                  ⋯\n                \n                \n                  \n                    a\n                    \n                      m\n                      n\n                    \n                  \n                  B\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}a_{11}B&a_{12}B&\\cdots &a_{1n}B\\\\\\vdots &\\vdots &\\ddots &\\vdots \\\\a_{m1}B&a_{m2}B&\\cdots &a_{mn}B\\end{bmatrix}}}\n  \n當\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n是一\n  \n    \n      \n        m\n        ×\n        n\n      \n    \n    {\\displaystyle m\\times n}\n  \n矩陣和\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n是一\n  \n    \n      \n        p\n        ×\n        r\n      \n    \n    {\\displaystyle p\\times r}\n  \n矩陣時，\n  \n    \n      \n        A\n        ⊗\n        B\n      \n    \n    {\\displaystyle A\\otimes B}\n  \n會是一\n  \n    \n      \n        m\n        p\n        ×\n        n\n        r\n      \n    \n    {\\displaystyle mp\\times nr}\n  \n矩陣，而且此一乘積也是不可交換的。\n舉個例子，\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  1\n                \n                \n                  2\n                \n              \n              \n                \n                  3\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        ⊗\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  3\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  1\n                  ⋅\n                  0\n                \n                \n                  1\n                  ⋅\n                  3\n                \n                \n                  2\n                  ⋅\n                  0\n                \n                \n                  2\n                  ⋅\n                  3\n                \n              \n              \n                \n                  1\n                  ⋅\n                  2\n                \n                \n                  1\n                  ⋅\n                  1\n                \n                \n                  2\n                  ⋅\n                  2\n                \n                \n                  2\n                  ⋅\n                  1\n                \n              \n              \n                \n                  3\n                  ⋅\n                  0\n                \n                \n                  3\n                  ⋅\n                  3\n                \n                \n                  1\n                  ⋅\n                  0\n                \n                \n                  1\n                  ⋅\n                  3\n                \n              \n              \n                \n                  3\n                  ⋅\n                  2\n                \n                \n                  3\n                  ⋅\n                  1\n                \n                \n                  1\n                  ⋅\n                  2\n                \n                \n                  1\n                  ⋅\n                  1\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  0\n                \n                \n                  3\n                \n                \n                  0\n                \n                \n                  6\n                \n              \n              \n                \n                  2\n                \n                \n                  1\n                \n                \n                  4\n                \n                \n                  2\n                \n              \n              \n                \n                  0\n                \n                \n                  9\n                \n                \n                  0\n                \n                \n                  3\n                \n              \n              \n                \n                  6\n                \n                \n                  3\n                \n                \n                  2\n                \n                \n                  1\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}1&2\\\\3&1\\\\\\end{bmatrix}}\\otimes {\\begin{bmatrix}0&3\\\\2&1\\\\\\end{bmatrix}}={\\begin{bmatrix}1\\cdot 0&1\\cdot 3&2\\cdot 0&2\\cdot 3\\\\1\\cdot 2&1\\cdot 1&2\\cdot 2&2\\cdot 1\\\\3\\cdot 0&3\\cdot 3&1\\cdot 0&1\\cdot 3\\\\3\\cdot 2&3\\cdot 1&1\\cdot 2&1\\cdot 1\\\\\\end{bmatrix}}={\\begin{bmatrix}0&3&0&6\\\\2&1&4&2\\\\0&9&0&3\\\\6&3&2&1\\end{bmatrix}}}\n  \n若\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n和\n  \n    \n      \n        B\n      \n    \n    {\\displaystyle B}\n  \n分別表示兩個線性算子\n  \n    \n      \n        \n          V\n          \n            1\n          \n        \n        →\n        \n          W\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle V_{1}\\to W_{1}}\n  \n和\n  \n    \n      \n        \n          V\n          \n            2\n          \n        \n        →\n        \n          W\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle V_{2}\\to W_{2}}\n  \n，\n  \n    \n      \n        A\n        ⊗\n        B\n      \n    \n    {\\displaystyle A\\otimes B}\n  \n便為其映射的張量乘積，\n  \n    \n      \n        \n          V\n          \n            1\n          \n        \n        ⊗\n        \n          V\n          \n            2\n          \n        \n        →\n        \n          W\n          \n            1\n          \n        \n        ⊗\n        \n          W\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle V_{1}\\otimes V_{2}\\to W_{1}\\otimes W_{2}}\n  \n\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的克羅內克乘積", "Tag": "算法设计"}
{"Answer": "上述三種乘積都符合結合律：\n\n  \n    \n      \n        A\n        (\n        B\n        C\n        )\n        =\n        (\n        A\n        B\n        )\n        C\n      \n    \n    {\\displaystyle A(BC)=(AB)C}\n  \n以及分配律：\n\n  \n    \n      \n        A\n        (\n        B\n        +\n        C\n        )\n        =\n        A\n        B\n        +\n        A\n        C\n      \n    \n    {\\displaystyle A(B+C)=AB+AC}\n  \n\n\n  \n    \n      \n        (\n        A\n        +\n        B\n        )\n        C\n        =\n        A\n        C\n        +\n        B\n        C\n      \n    \n    {\\displaystyle (A+B)C=AC+BC}\n  \n而且和純量乘積相容：\n\n  \n    \n      \n        c\n        (\n        A\n        B\n        )\n        =\n        (\n        c\n        A\n        )\n        B\n      \n    \n    {\\displaystyle c(AB)=(cA)B}\n  \n\n\n  \n    \n      \n        (\n        A\n        c\n        )\n        B\n        =\n        A\n        (\n        c\n        B\n        )\n      \n    \n    {\\displaystyle (Ac)B=A(cB)}\n  \n\n\n  \n    \n      \n        (\n        A\n        B\n        )\n        c\n        =\n        A\n        (\n        B\n        c\n        )\n      \n    \n    {\\displaystyle (AB)c=A(Bc)}\n  \n注意上述三個分開的表示式只有在純量體的乘法及加法是可交換（即純量體為一可交換環）時會相同。\n", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的共同性質", "Tag": "算法设计"}
{"Answer": "Strassen演算法（1969）\nWinograd演算法（1980）\nCoppersmith–Winograd演算法（1990）\n邏輯矩陣\n矩陣鏈乘積\n逆矩陣\n關係複合\nBLAS\n矩陣加法\n矩阵微积分", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的另見", "Tag": "算法设计"}
{"Answer": "WIMS Online Matrix Multiplier （页面存档备份，存于互联网档案馆）\nAnimated Matrix Multiplication Examples (purplemath) （页面存档备份，存于互联网档案馆）Matrix Multipication in Javascript （页面存档备份，存于互联网档案馆）（works in Firefox）", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的外部連結", "Tag": "算法设计"}
{"Answer": "\n\n^ Lerner, R. G.; Trigg, G. L. Encyclopaedia of Physics 2nd. VHC publishers. 1991. ISBN 3-527-26954-1 （英语）. \n\n^ Parker, C. B. McGraw Hill Encyclopaedia of Physics 2nd. 1994. ISBN 0-07-051400-3 （英语）. \n\n其它参考文献包括：\nStrassen, Volker, Gaussian Elimination is not Optimal, Numer. Math. 13, p. 354-356, 1969.\nCoppersmith, D., Winograd S., Matrix multiplication via arithmetic progressions, J. Symbolic Comput. 9, p. 251-280, 1990.\nHorn, Roger; Johnson, Charles: \"Topics in Matrix Analysis\", Cambridge, 1994.\nRobinson, Sara, Toward an Optimal Algorithm for Matrix Multiplication, SIAM News 38(9), November 2005.", "Konwledge_Point": "矩陣乘法", "Question": "什么是矩陣乘法的參考", "Tag": "算法设计"}
{"Answer": "长度是一维空间的度量，是国际单位制的七种基础度量之一[1]。\n", "Konwledge_Point": "长度", "Question": "什么是长度", "Tag": "算法设计"}
{"Answer": "在几何体中长度通常指最长的一维。通常在量度二維空間中量度直線邊長時，稱呼長度數值較大的為長，不比其值大或者在「側邊」的為寬，而表達方式通常為長乘寬。所以寬度其實也是長度量度的一種，故此在三維空間中量度「垂直長度」的高都是长度。\n在字典中，长度被解释为“两端之间的距离”[2]。这个距离既可以是直线，也可以是曲线；既可以在平面上，也可以在三维空间中。\n在广义的长度中，人们也用“长度”这一更形象的度量来表示其他抽象的度量（尤其是时间度量），但一般只用到长度相关的形容词而不会用长度度量的单位。如时间的长度、寿命长度等等[3]。\n", "Konwledge_Point": "长度", "Question": "什么是长度的概述", "Tag": "算法设计"}
{"Answer": "通常，用“长”和“短”来大致形容长度的大小，如“长木棒”/“短木棒”。在特定范围也会用特定的形容词来表述，如表示地理距离用“远”和“近”，描述人的身高用“高”和“矮”，还有纸张厚度等等。本质上这些均为长度。同样其他度量用长度来表示也可以使用对应的形容词，如时间的长短等。[3]\n用形容词来描述长度均有一个相对的概念，没有哪个形容长度的词语是不成对出现的。有长才有短，有高就有矮。一个人跟某些人比可以称作高，但跟另一些人比可能又变为“矮”。用古语的话说，就是“尺有所短，寸有所长”，当然此成语已不局限于字面意义[4]。\n", "Konwledge_Point": "长度", "Question": "什么是长度的长度的描述", "Tag": "算法设计"}
{"Answer": "单位化的长度可以作为绝对的度量。作为日常生活中最重要的度量之一，长度的度量单位有很多种。\n国际单位制中将米（符号m）作为标准单位[1]，因而“1米”有多长需要科学而严谨的定义。最新一米定义于1983年国际度量衡大会重新制定，此次定义时使用了自然中随处可见的光，并且在70年代光速的测定已非常精确，所以最终定义为光在真空中行进299 792 458分之1秒的距离为一标准米。故此，一旦光速得到更精准的量度，改变的数值会是米而非光速。\n与米相关的单位有很多，从相当于10-24米的攸米（ym）到千米（km）乃至京米（Gm）均有各自的单位和换算方式。常用的长度单位则有：千米、米、厘米、毫米、微米、纳米。\n早期的英里、英尺不与公制单位挂钩而是有另一套标准[5]，但为了精确起见现已经将英制单位与公制挂钩了。另外，航海中常用海里，现已经改与公制挂钩，1海里为1.852千米。\n汉语中，同样一个单位可能有不同的称呼，如中文公尺就是米，公分就是厘米，这些称呼在日常生活中也比较常见[6][7]。\n光年，指光在真空中一年時間内传播的距離。秒差距，1秒差距= 3.2616 光年。在台灣，「公分」等於厘米，即一百分之一米，而非「分」傳統意義的十分之一，原因是借用舊制的排列次序：里>引>丈>尺>寸>分>釐\n", "Konwledge_Point": "长度", "Question": "什么是长度的长度的单位", "Tag": "算法设计"}
{"Answer": "在人们主观意识中，在任何环境下同一个物体长度应该是不变的。但是在相对论理论体系中，长度与质量、时间等一样，具有相对性，取决于速度、位置等因素。\n", "Konwledge_Point": "长度", "Question": "什么是长度的相对论中的长度", "Tag": "算法设计"}
{"Answer": "\n^ 1.0 1.1 International System of Units（SI）.   [2010-12-13]. （原始内容存档于2006-06-15）. \n\n^ 新华字典.   [2010-12-13]. （原始内容存档于2020-09-30）. \n\n^ 3.0 3.1 长字的释义.   [2010-12-14]. （原始内容存档于2021-04-28）. \n\n^ 尺有所短，寸有所长.   [2010-12-14]. （原始内容存档于2016-03-04）. \n\n^ 英制尺寸的由来.   [2010-12-14]. （原始内容存档于2010-12-18）. \n\n^ 公尺.   [2010-12-14]. （原始内容存档于2020-09-30）. \n\n^ 公分.   [2010-12-14]. （原始内容存档于2020-09-30）. \n\n", "Konwledge_Point": "长度", "Question": "什么是长度的参考文献", "Tag": "算法设计"}
{"Answer": "距离\n曲线\n面积\n体积", "Konwledge_Point": "长度", "Question": "什么是长度的参阅", "Tag": "算法设计"}
{"Answer": "二分图最佳带權匹配问题是指在给定带权二分图上求出一个最大匹配的问题，使得所有匹配边权值之和最大。这个问题也被称为二分图最优匹配。[1]\n此类问题通常使用KM算法或转换为一个网络费用流问题进行求解。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配", "Tag": "算法设计"}
{"Answer": "一个带权二分图 \n  \n    \n      \n        G\n        =\n        (\n        X\n        ,\n        Y\n        ,\n        E\n        )\n      \n    \n    {\\displaystyle G=(X,Y,E)}\n  \n 中的边 \n  \n    \n      \n        (\n        u\n        ,\n        v\n        )\n        ∈\n        E\n      \n    \n    {\\displaystyle (u,v)\\in E}\n  \n 都带有一个权值 \n  \n    \n      \n        f\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle f(u,v)}\n  \n。该二分图的一个最佳带权匹配是它所有匹配中，所有匹配边权值之和中最大的一个。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的定义", "Tag": "算法设计"}
{"Answer": "KM算法[编辑]直接使用KM算法求解。\n最小费用最大流[编辑]通过建立模型，使用费用流算法解决。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的求解方法", "Tag": "算法设计"}
{"Answer": "直接使用KM算法求解。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的求解方法的KM算法", "Tag": "算法设计"}
{"Answer": "通过建立模型，使用费用流算法解决。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的求解方法的最小费用最大流", "Tag": "算法设计"}
{"Answer": "C++[编辑]#include <cstdio>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint const MAX = 1000;\nint const inf = INT_MAX;\n\nint w[MAX][MAX];\nint link[MAX];//代表当前与Y集合中配对的X集合中的点\nint visx[MAX], visy[MAX];\nint lx[MAX], ly[MAX];\nint n, m;//代表X和Y中元素的个数\n \nint can(int t)\n{\n    visx[t] = 1;\n    for(int i = 1; i <= m; i++){\n        if(!visy[i] && lx[t] + ly[i] == w[t][i]){//这里“lx[t]+ly[i]==w[t][i]”决定了这是在相等子图中找增广路的前提，非常重要\n            visy[i] = 1;\n            if(link[i] == -1 || can(link[i])){\n                link[i] = t;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint km(void)\n{\n    int sum = 0; memset(ly, 0, sizeof(ly));\n    for(int i = 1; i <= n; i++){//把各个lx的值都设为当前w[i][j]的最大值\n        lx[i] = -inf;\n        for(int j = 1; j <= n; j++){\n            if(lx[i] < w[i][j])\n                lx[i] = w[i][j];\n        }\n    }\n\n    memset(link, -1, sizeof(link));\n    for(int i = 1; i <= n; i++){\n        while(1){\n            memset(visx, 0, sizeof(visx));\n            memset(visy, 0, sizeof(visy));\n            if(can(i))//如果它能够形成一条增广路径，那么就break\n                break;\n            int d = inf;//否则，后面应该加入新的边,这里应该先计算d值\n            for(int j = 1; j <= n; j++)//对于搜索过的路径上的XY点，设该路径上的X顶点集为S，Y顶点集为T，对所有在S中的点xi及不在T中的点yj\n                if(visx[j])\n                    for(int k = 1; k <= m; k++)\n                       if(!visy[k])\n                            d = min(d, lx[j] + ly[k] - w[j][k]);\n            if(d == inf)\n            return -1;//找不到可以加入的边，返回失败（即找不到完美匹配）\n            for (int j = 1; j <= n; j++)\n                if (visx[j])\n                    lx[j] -= d;\n            for(int j = 1; j <= m; j++)\n                if(visy[j])\n                    ly[j] += d;\n            }\n    }\n    for(int i = 1; i <= m; i++)\n        if(link[i] > -1)\n            sum += w[link[i]][i];\n    return sum;\n}\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的参考程序", "Tag": "算法设计"}
{"Answer": "#include <cstdio>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint const MAX = 1000;\nint const inf = INT_MAX;\n\nint w[MAX][MAX];\nint link[MAX];//代表当前与Y集合中配对的X集合中的点\nint visx[MAX], visy[MAX];\nint lx[MAX], ly[MAX];\nint n, m;//代表X和Y中元素的个数\n \nint can(int t)\n{\n    visx[t] = 1;\n    for(int i = 1; i <= m; i++){\n        if(!visy[i] && lx[t] + ly[i] == w[t][i]){//这里“lx[t]+ly[i]==w[t][i]”决定了这是在相等子图中找增广路的前提，非常重要\n            visy[i] = 1;\n            if(link[i] == -1 || can(link[i])){\n                link[i] = t;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint km(void)\n{\n    int sum = 0; memset(ly, 0, sizeof(ly));\n    for(int i = 1; i <= n; i++){//把各个lx的值都设为当前w[i][j]的最大值\n        lx[i] = -inf;\n        for(int j = 1; j <= n; j++){\n            if(lx[i] < w[i][j])\n                lx[i] = w[i][j];\n        }\n    }\n\n    memset(link, -1, sizeof(link));\n    for(int i = 1; i <= n; i++){\n        while(1){\n            memset(visx, 0, sizeof(visx));\n            memset(visy, 0, sizeof(visy));\n            if(can(i))//如果它能够形成一条增广路径，那么就break\n                break;\n            int d = inf;//否则，后面应该加入新的边,这里应该先计算d值\n            for(int j = 1; j <= n; j++)//对于搜索过的路径上的XY点，设该路径上的X顶点集为S，Y顶点集为T，对所有在S中的点xi及不在T中的点yj\n                if(visx[j])\n                    for(int k = 1; k <= m; k++)\n                       if(!visy[k])\n                            d = min(d, lx[j] + ly[k] - w[j][k]);\n            if(d == inf)\n            return -1;//找不到可以加入的边，返回失败（即找不到完美匹配）\n            for (int j = 1; j <= n; j++)\n                if (visx[j])\n                    lx[j] -= d;\n            for(int j = 1; j <= m; j++)\n                if(visy[j])\n                    ly[j] += d;\n            }\n    }\n    for(int i = 1; i <= m; i++)\n        if(link[i] > -1)\n            sum += w[link[i]][i];\n    return sum;\n}\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的参考程序的C++", "Tag": "算法设计"}
{"Answer": "\n\n^ 李煜东. suan fa jing sai jing jie zhi nan. zhong yuan chu ban chuang mei ji tuan - he nan dian zi ying xiang chu ban she. ISBN 978-7-89388-198-5. \n\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的参考文献", "Tag": "算法设计"}
{"Answer": "图论中的经典问题哈密顿路径问题（台湾作漢米頓路徑問題）（Hamiltonian path problem）与哈密顿环问题（台湾作漢米頓環問題）（Hamiltonian cycle problem）分别是来确定在一个给定的图上是否存在哈密顿路径（一条经过图上每个顶点的路径）和哈密顿环（一条经过图上每个顶点的环）。两个问题皆为NP完全。[1]\n", "Konwledge_Point": "哈密顿路径问题", "Question": "什么是哈密顿路径问题", "Tag": "算法设计"}
{"Answer": "哈密顿环问题与哈密顿路径问题之间有着很简单的关系：\n给定图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n ,通过加入新顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n 并将新顶点与所有其他顶点连接起来，我们得到了图\n  \n    \n      \n        H\n      \n    \n    {\\displaystyle H}\n  \n。 在图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n 之上的哈密顿路径问题与在\n  \n    \n      \n        H\n      \n    \n    {\\displaystyle H}\n  \n之上的哈密顿环问题等价。因此寻找哈密顿路径的速度不可能比寻找哈密顿环的速度快很多。\n从另一个方向来看，给定图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n，给定图上一个顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n，通过加入新顶点给定图\n  \n    \n      \n        \n          v\n          ′\n        \n      \n    \n    {\\displaystyle v'}\n  \n,并且让\n  \n    \n      \n        \n          v\n          ′\n        \n      \n    \n    {\\displaystyle v'}\n  \n的邻居等于\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的邻居，再增加两个度为1的新顶点，并让他们分别与\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n和\n  \n    \n      \n        \n          v\n          ′\n        \n      \n    \n    {\\displaystyle v'}\n  \n相连，得到图\n  \n    \n      \n        H\n      \n    \n    {\\displaystyle H}\n  \n，则图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n上的哈密顿环问题与图\n  \n    \n      \n        H\n      \n    \n    {\\displaystyle H}\n  \n上的哈密顿路径问题等价。[2]\n", "Konwledge_Point": "哈密顿路径问题", "Question": "什么是哈密顿路径问题的哈密顿环问题与哈密顿路径问题之间的关系", "Tag": "算法设计"}
{"Answer": "在一个阶数为\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的图中，可能成为哈密顿路径的顶点序列最多有有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n!个（在完全图的情况下恰好为\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n!个)，因此暴力搜索所有可能的顶点序列是非常慢的。\n一个早期的在有向图上寻找哈密顿环的算法是Martello的枚举算法[3] \n由Frank Rubin[4]\n提供的搜索过程将图的边分为3种类型：必须在路径上的边、不能在路径上的边和未定边。在搜索的过程中，一个决策规则的集合将未定边进行分类，并且决定是否继续进行搜索。这个算法将图分成几个部分，在它们上问题能够被单独地解决。\n另外，Bellman, Held, and Karp 的动态规划算法可以在O(n2 2n)时间内解决问题。在这个方法中，对每个顶点集\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n和其中的每一个顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n ，均做出如下的判定：是否有一条经过\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中每个顶点，并且在\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n结束的路径，对于每一对\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n和\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n，当且仅当存在\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的邻居\n  \n    \n      \n        w\n      \n    \n    {\\displaystyle w}\n  \n满足存在一条路径经过\n  \n    \n      \n        S\n        −\n        v\n      \n    \n    {\\displaystyle S-v}\n  \n的所有顶点，并在\n  \n    \n      \n        w\n      \n    \n    {\\displaystyle w}\n  \n上结束的路径时，存在路径经过\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中每个顶点，并且在\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n结束。这个充要条件已经可以之前的动态规划计算中确认。[5][6]\nAndreas Björklund通过inclusion–exclusion principle将哈密尔顿环的计数问题规约成一个更简单，圈覆盖的计数问题，后者可以被通过计算某些矩阵的行列式解决。通过这个方法，并通过蒙特卡洛算法，对任意\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n阶图，可以在O(1.657n)时间内解决。对于二分图，这个算法可以被进一步提升至ο(1.415n)。[7]\n对于最大度小于等于3的图，一个回溯搜索的方法可以在 O(1.251n)时间内找到哈密顿环。[8]\n哈密顿环和哈密顿路径也可以通过SAT solver找到。\n", "Konwledge_Point": "哈密顿路径问题", "Question": "什么是哈密顿路径问题的算法", "Tag": "算法设计"}
{"Answer": "哈密顿环和哈密顿路径问题是FNP问题，它的决定性问题 是检测是否存在一条哈密顿环或哈密顿路径。有向图和无向图上的哈密顿环问题是 卡普的二十一个NP-完全问题中的其中两个。对于一些特殊类型的图来说，它们仍然是NP完全的。例如：\n二分图,[9]\n最大度为3的无向平面图,[10]\n入度和出度最大为2的有向平面图,[11]\n无桥的无向的平面3-正则二分图，\n3-顶点连通，3-正则的二分图，[12]\nsquare grid graph的子图,[13]\nsquare grid graph的3-正则子图.[14]然而，对于某些类型的图，哈密顿环和哈密顿路径问题可以在多项式时间内解决：\n根据Tutte的结论，4-顶点连通 平面图总是存在哈密顿环，并且可以在线性时间内找到哈密顿环。[15] by computing a so-called Tutte path.\nTutte通过证明2-正则平面图包含Tutte路径，证明了以上的结论。对2-正则平面图来说，其Tutte路径可以在平方时间内找到，[16], 这可能可以被用来寻找一般平面图上的哈密顿环和较长的环。将以上提供的条件汇总起来，3-正则，3-定点连通的二分图是否总是存在哈密顿环这一问题仍然是开放的,在这个情况下这一问题不是NP完全的，详见 Barnette's conjecture.\n在所有顶点的度都是奇数的途中，一个与握手引理有关的结论说明对于任意一条边来说，经过它的哈密顿环的个数总是偶数，因此如果存在一条哈密顿环，则一定存在另一条 [17] 然而，找到第二条哈密顿换并不是一个简单的计算问题。Papadimitriou定义了一个 复杂性类复杂性类 PPA来描述这一类问题。 [18]\n", "Konwledge_Point": "哈密顿路径问题", "Question": "什么是哈密顿路径问题的复杂度", "Tag": "算法设计"}
{"Answer": "Hamiltonian Page : Hamiltonian cycle and path problems, their generalizations and variations\n^ Michael R. Garey and David S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman, 1979, ISBN 978-0-7167-1045-5  A1.3: GT37–39, pp. 199–200.\n\n^ Reduction from Hamiltonian cycle to Hamiltonian path\n\n^ Martello, Silvano, An Enumerative Algorithm for Finding Hamiltonian Circuits in a Directed Graph, ACM Transactions on Mathematical Software, 1983, 9 (1): 131–138, doi:10.1145/356022.356030 \n\n^ Rubin, Frank, A Search Procedure for Hamilton Paths and Circuits, Journal of the ACM, 1974, 21 (4): 576–80, doi:10.1145/321850.321854 \n\n^ Bellman, R., Dynamic programming treatment of the travelling salesman problem, Journal of the ACM, 1962, 9: 61–63, doi:10.1145/321105.321111 .\n\n^ Held, M.; Karp, R. M., A dynamic programming approach to sequencing problems (PDF), J. SIAM, 1962, 10 (1): 196–210  [2020-10-03], doi:10.1137/0110015, hdl:10338.dmlcz/103900, （原始内容存档 (PDF)于2019-09-22） 。\n\n^ Björklund, Andreas, Determinant sums for undirected Hamiltonicity, Proc. 51st IEEE Symposium on Foundations of Computer Science (FOCS '10): 173–182, 2010, ISBN 978-1-4244-8525-3, arXiv:1008.0541 , doi:10.1109/FOCS.2010.24 。\n\n^ Iwama, Kazuo; Nakashima, Takuya, An improved exact algorithm for cubic graph TSP, Proc. 13th Annual International Conference on Computing and Combinatorics (COCOON 2007), Lecture Notes in Computer Science 4598: 108–117, 2007, ISBN 978-3-540-73544-1, doi:10.1007/978-3-540-73545-8_13 。\n\n^ Proof that the existence of a Hamilton Path in a bipartite graph is NP-complete. Computer Science Stack Exchange.   [2019-03-18]. \n\n^ Garey, M. R.; Johnson, D. S.; Stockmeyer, L., Some simplified NP-complete problems, Proc. 6th ACM Symposium on Theory of Computing (STOC '74): 47–63, 1974, doi:10.1145/800119.803884 .\n\n^ Plesńik, J., The NP-completeness of the Hamiltonian cycle problem in planar digraphs with degree bound two (PDF), Information Processing Letters, 1979, 8 (4): 199–201  [2020-10-03], doi:10.1016/0020-0190(79)90023-1, （原始内容存档 (PDF)于2020-11-25） .\n\n^ Akiyama, Takanori; Nishizeki, Takao; Saito, Nobuji, NP-completeness of the Hamiltonian cycle problem for bipartite graphs, Journal of Information Processing, 1980–1981, 3 (2): 73–76, MR 0596313 .\n\n^ Itai, Alon; Papadimitriou, Christos; Szwarcfiter, Jayme, Hamilton Paths in Grid Graphs, SIAM Journal on Computing, 1982, 4 (11): 676–686, doi:10.1137/0211056 .\n\n^ Buro, Michael, Simple Amazons endgames and their connection to Hamilton circuits in cubic subgrid graphs (PDF), Conference on Computers and Games, Lecture Notes in Computer Science 2063: 250–261, 2000  [2020-10-03], ISBN 978-3-540-43080-3, doi:10.1007/3-540-45579-5_17, （原始内容存档 (PDF)于2020-11-06） .\n\n^ Chiba, Norishige; Nishizeki, Takao, The Hamiltonian cycle problem is linear-time solvable for 4-connected planar graphs, Journal of Algorithms, 1989, 10 (2): 187–211, doi:10.1016/0196-6774(89)90012-6 \n\n^ Schmid, Andreas; Schmidt, Jens M., Computing Tutte Paths, Proceedings of the 45th International Colloquium on Automata, Languages and Programming (ICALP'18), to appear., 2018 \n\n^ Thomason, A. G., Hamiltonian cycles and uniquely edge colourable graphs, Advances in Graph Theory (Cambridge Combinatorial Conf., Trinity College, Cambridge, 1977), Annals of Discrete Mathematics 3: 259–268, 1978, ISBN 9780720408430, MR 0499124, doi:10.1016/S0167-5060(08)70511-9 .\n\n^ Papadimitriou, Christos H., On the complexity of the parity argument and other inefficient proofs of existence, Journal of Computer and System Sciences, 1994, 48 (3): 498–532, MR 1279412, doi:10.1016/S0022-0000(05)80063-7 .\n\n", "Konwledge_Point": "哈密顿路径问题", "Question": "什么是哈密顿路径问题的外部連結", "Tag": "算法设计"}
