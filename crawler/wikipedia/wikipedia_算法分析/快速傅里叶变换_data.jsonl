{"Answer": "快速傅里叶变换（英語：Fast Fourier Transform, FFT），是快速计算序列的离散傅里叶变换（DFT）或其逆变换的方法[1]。傅里叶分析将信号从原始域（通常是时间或空间）转换到頻域的表示或者逆过来转换。FFT会通过把DFT矩阵分解为稀疏（大多为零）因子之积来快速计算此类变换。[2]  因此，它能够将计算DFT的复杂度从只用DFT定义计算需要的 \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n，降低到 \n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n，其中 \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n 为数据大小。\n快速傅里叶变换广泛的应用于工程、科学和数学领域。这里的基本思想在1965年才得到普及，但早在1805年就已推导出来。[3] 1994年美國數學家吉爾伯特·斯特朗把FFT描述为“我们一生中最重要的数值算法”[4]，它还被IEEE科学与工程计算期刊列入20世纪十大算法。[5]\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换", "Tag": "算法设计"}
{"Answer": "用FFT计算DFT会得到与直接用DFT定义计算相同的结果；最重要的区别是FFT更快。（由于捨入誤差的存在，许多FFT算法还会比直接运用定义求值精确很多，后面会讨论到这一点。）\n令 x0, ...., xN-1 為复数。DFT由下式定义\n\n  \n    \n      \n        \n          X\n          \n            k\n          \n        \n        =\n        \n          ∑\n          \n            n\n            =\n            0\n          \n          \n            N\n            −\n            1\n          \n        \n        \n          x\n          \n            n\n          \n        \n        \n          e\n          \n            −\n            \n              i\n              2\n              π\n              k\n              \n                \n                  n\n                  N\n                \n              \n            \n          \n        \n        \n        k\n        =\n        0\n        ,\n        …\n        ,\n        N\n        −\n        1.\n      \n    \n    {\\displaystyle X_{k}=\\sum _{n=0}^{N-1}x_{n}e^{-{i2\\pi k{\\frac {n}{N}}}}\\qquad k=0,\\dots ,N-1.}\n  \n直接按这个定义求值需要 O(N2) 次运算：Xk 共有 N 个输出，每个输出需要 N 项求和。直接使用DFT運算需使用N個複數乘法(4N 個實數乘法)與N-1個複數加法(2N-2個實數加法)，因此，計算使用DFT所有N點的值需要N2複數乘法與N2-N 個複數加法。FFT则是能够在 O(N log N) 次操作计算出相同结果的任何方法。更准确的说，所有已知的FFT算法都需要 O(N log N) 次运算（技术上O只标记上界），虽然还没有已知的证据证明更低的复杂度是不可能的。[6]\n要说明FFT节省时间的方式，就得考虑复数相乘和相加的次数。直接计算DFT的值涉及到 N2 次复数相乘和 N(N−1) 次复数相加（可以通过削去琐碎运算（如乘以1）来节省 O(N) 次运算）。众所周知的基2库利-图基算法，N 为2的幂，可以只用 (N/2)log2(N) 次复数乘法（再次忽略乘以1的简化）和 Nlog2(N) 次加法就可以得到相同结果。在实际中，现代计算机通常的实际性能通常不受算术运算的速度和对复杂主体的分析主导[7]，但是从 O(N2) 到 O(N log N) 的总体改进仍然能够体现出来。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的定义和速度", "Tag": "算法设计"}
{"Answer": "假設一個M*N型矩阵S可分解成列向量以及行向量相乘：\n\n  \n    \n      \n        \n          S\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {S} ={\\begin{bmatrix}a_{1}\\\\a_{2}\\\\\\vdots \\\\a_{m}\\end{bmatrix}}{\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}}\n  \n\n若\n  \n    \n      \n        \n          \n            \n              [\n              \n                \n                  \n                    \n                      a\n                      \n                        1\n                      \n                    \n                  \n                  \n                    \n                      a\n                      \n                        2\n                      \n                    \n                  \n                  \n                    ⋯\n                  \n                  \n                    \n                      a\n                      \n                        m\n                      \n                    \n                  \n                \n              \n              ]\n            \n          \n          \n            T\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}a_{1}&a_{2}&\\cdots &a_{m}\\end{bmatrix}}^{T}}\n  \n有\n  \n    \n      \n        \n          M\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle M_{0}}\n  \n個相異的非平凡值（\n  \n    \n      \n        \n          a\n          \n            m\n          \n        \n        ≠\n        ±\n        \n          2\n          \n            k\n          \n        \n        ,\n        \n          a\n          \n            m\n          \n        \n        ≠\n        ±\n        \n          2\n          \n            k\n          \n        \n        \n          a\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle a_{m}\\neq \\pm 2^{k},a_{m}\\neq \\pm 2^{k}a_{n}}\n  \n where \n  \n    \n      \n        m\n        ≠\n        n\n      \n    \n    {\\displaystyle m\\neq n}\n  \n）　\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}}\n  \n有\n  \n    \n      \n        \n          N\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle N_{0}}\n  \n個相異的非平凡值\n則S共需要\n  \n    \n      \n        \n          M\n          \n            0\n          \n        \n        ∗\n        \n          N\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle M_{0}*N_{0}}\n  \n個乘法。\n\n  \n    \n      \n        \n          \n            [\n            \n              \n                \n                  Z\n                  [\n                  1\n                  ]\n                \n              \n              \n                \n                  Z\n                  [\n                  2\n                  ]\n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  Z\n                  [\n                  N\n                  ]\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          S\n        \n        \n          \n            [\n            \n              \n                \n                  X\n                  [\n                  1\n                  ]\n                \n              \n              \n                \n                  X\n                  [\n                  2\n                  ]\n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  X\n                  [\n                  N\n                  ]\n                \n              \n            \n            ]\n          \n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  X\n                  [\n                  1\n                  ]\n                \n              \n              \n                \n                  X\n                  [\n                  2\n                  ]\n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  X\n                  [\n                  N\n                  ]\n                \n              \n            \n            ]\n          \n        \n      \n    \n    {\\displaystyle {\\begin{bmatrix}Z[1]\\\\Z[2]\\\\\\vdots \\\\Z[N]\\end{bmatrix}}=\\mathbf {S} {\\begin{bmatrix}X[1]\\\\X[2]\\\\\\vdots \\\\X[N]\\end{bmatrix}}={\\begin{bmatrix}a_{1}\\\\a_{2}\\\\\\vdots \\\\a_{m}\\end{bmatrix}}{\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}{\\begin{bmatrix}X[1]\\\\X[2]\\\\\\vdots \\\\X[N]\\end{bmatrix}}}\n  \n\nStep 1：\n  \n    \n      \n        \n          Z\n          \n            a\n          \n        \n        =\n        \n          b\n          \n            1\n          \n        \n        X\n        [\n        1\n        ]\n        +\n        \n          b\n          \n            2\n          \n        \n        X\n        [\n        2\n        ]\n        +\n        ⋯\n        +\n        \n          b\n          \n            n\n          \n        \n        X\n        [\n        N\n        ]\n      \n    \n    {\\displaystyle Z_{a}=b_{1}X[1]+b_{2}X[2]+\\cdots +b_{n}X[N]}\n  \n\nStep 2：\n  \n    \n      \n        Z\n        [\n        1\n        ]\n        =\n        \n          a\n          \n            1\n          \n        \n        \n          Z\n          \n            a\n          \n        \n        ,\n        Z\n        [\n        2\n        ]\n        =\n        \n          a\n          \n            2\n          \n        \n        \n          Z\n          \n            a\n          \n        \n        ,\n        ⋯\n        ,\n        Z\n        [\n        N\n        ]\n        =\n        \n          a\n          \n            m\n          \n        \n        \n          Z\n          \n            a\n          \n        \n      \n    \n    {\\displaystyle Z[1]=a_{1}Z_{a},Z[2]=a_{2}Z_{a},\\cdots ,Z[N]=a_{m}Z_{a}}\n  \n\n簡化理論的變型：\n\n  \n    \n      \n        \n          S\n        \n        =\n        \n          \n            [\n            \n              \n                \n                  \n                    a\n                    \n                      1\n                    \n                  \n                \n              \n              \n                \n                  \n                    a\n                    \n                      2\n                    \n                  \n                \n              \n              \n                \n                  ⋮\n                \n              \n              \n                \n                  \n                    a\n                    \n                      m\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        \n          \n            [\n            \n              \n                \n                  \n                    b\n                    \n                      1\n                    \n                  \n                \n                \n                  \n                    b\n                    \n                      2\n                    \n                  \n                \n                \n                  ⋯\n                \n                \n                  \n                    b\n                    \n                      n\n                    \n                  \n                \n              \n            \n            ]\n          \n        \n        +\n        \n          \n            S\n          \n          \n            1\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {S} ={\\begin{bmatrix}a_{1}\\\\a_{2}\\\\\\vdots \\\\a_{m}\\end{bmatrix}}{\\begin{bmatrix}b_{1}&b_{2}&\\cdots &b_{n}\\end{bmatrix}}+\\mathbf {S} _{1}}\n  \n\n\n  \n    \n      \n        \n          S\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle S_{1}}\n  \n也是一個M*N的矩陣。\n若\n  \n    \n      \n        \n          S\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle S_{1}}\n  \n有\n  \n    \n      \n        \n          P\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle P_{1}}\n  \n個值不等於0，則\n  \n    \n      \n        \n          S\n        \n      \n    \n    {\\displaystyle \\mathbf {S} }\n  \n的乘法量上限為\n  \n    \n      \n        \n          M\n          \n            0\n          \n        \n        +\n        \n          N\n          \n            0\n          \n        \n        +\n        \n          P\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle M_{0}+N_{0}+P_{1}}\n  \n。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的一般的簡化理論", "Tag": "算法设计"}
{"Answer": "假設\n  \n    \n      \n        N\n        =\n        \n          P\n          \n            1\n          \n        \n        ×\n        \n          P\n          \n            2\n          \n        \n        ×\n        ⋯\n        ×\n        \n          P\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=P_{1}\\times P_{2}\\times \\cdots \\times P_{k}}\n  \n，其中\n  \n    \n      \n        \n          P\n          \n            1\n          \n        \n        ,\n        \n          P\n          \n            2\n          \n        \n        ,\n        ⋯\n        ,\n        \n          P\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle P_{1},P_{2},\\cdots ,P_{k}}\n  \n彼此互質\n\n  \n    \n      \n        \n          \n            P\n            \n              k\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {P_{k}} }\n  \n點DFT的乘法量為\n  \n    \n      \n        \n          \n            B\n            \n              k\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B_{k}} }\n  \n，則\n  \n    \n      \n        \n          N\n        \n      \n    \n    {\\displaystyle \\mathbf {N} }\n  \n點DFT的乘法量為：\n\n  \n    \n      \n        \n          \n            N\n            \n              P\n              \n                1\n              \n            \n          \n        \n        \n          B\n          \n            1\n          \n        \n        +\n        \n          \n            N\n            \n              P\n              \n                2\n              \n            \n          \n        \n        \n          B\n          \n            2\n          \n        \n        +\n        ⋯\n        ⋯\n        +\n        \n          \n            N\n            \n              P\n              \n                k\n              \n            \n          \n        \n        \n          B\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{P_{1}}}B_{1}+{\\frac {N}{P_{2}}}B_{2}+\\cdots \\cdots +{\\frac {N}{P_{k}}}B_{k}}\n  \n假設\n  \n    \n      \n        \n          N\n          =\n          \n            P\n            \n              c\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {N=P^{c}} }\n  \n，P是一個質數。\n若\n  \n    \n      \n        \n          \n            N\n            \n              1\n            \n          \n          =\n          \n            P\n            \n              a\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {N_{1}=P^{a}} }\n  \n點的DFT需要的乘法量為\n  \n    \n      \n        \n          \n            B\n            \n              1\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B_{1}} }\n  \n\n且\n  \n    \n      \n        \n          n\n          \n            1\n          \n        \n        ×\n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n_{1}\\times n_{2}}\n  \n當中（\n  \n    \n      \n        \n          n\n          \n            1\n          \n        \n        =\n        0\n        ,\n        1\n        ,\n        ⋯\n        ,\n        \n          N\n          \n            1\n          \n        \n        −\n        1\n        ,\n        \n        \n          n\n          \n            2\n          \n        \n        =\n        0\n        ,\n        1\n        ,\n        ⋯\n        ,\n        \n          N\n          \n            2\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle n_{1}=0,1,\\cdots ,N_{1}-1,\\quad n_{2}=0,1,\\cdots ,N_{2}-1}\n  \n）\n有\n  \n    \n      \n        \n          D\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle D_{1}}\n  \n個值不為\n  \n    \n      \n        \n          \n            N\n            12\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{12}}}\n  \n及\n  \n    \n      \n        \n          \n            N\n            8\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{8}}}\n  \n的倍數，\n有\n  \n    \n      \n        \n          D\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle D_{2}}\n  \n個值為\n  \n    \n      \n        \n          \n            N\n            12\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{12}}}\n  \n及\n  \n    \n      \n        \n          \n            N\n            8\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{8}}}\n  \n的倍數，但不為\n  \n    \n      \n        \n          \n            N\n            4\n          \n        \n      \n    \n    {\\displaystyle {\\frac {N}{4}}}\n  \n的倍數，\n則N點DFT的乘法量為：\n\n  \n    \n      \n        \n          \n            N\n            \n              2\n            \n          \n          \n            B\n            \n              1\n            \n          \n          +\n          \n            N\n            \n              1\n            \n          \n          \n            B\n            \n              2\n            \n          \n          +\n          3\n          \n            D\n            \n              1\n            \n          \n          +\n          2\n          \n            D\n            \n              2\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {N_{2}B_{1}+N_{1}B_{2}+3D_{1}+2D_{2}} }\n  \n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的快速傅立葉變換乘法量的計算", "Tag": "算法设计"}
{"Answer": "主条目：库利－图基快速傅里叶变换算法库利-图基算法是最常见的FFT算法。这一方法以分治法为策略递归地将长度为\n  \n    \n      \n        N\n        =\n        \n          N\n          \n            1\n          \n        \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N=N_{1}N_{2}}\n  \n的离散傅里叶变换分解为长度为\n  \n    \n      \n        \n          N\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle N_{1}}\n  \n的\n  \n    \n      \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N_{2}}\n  \n个较短序列的离散傅里叶变换，以及与\n  \n    \n      \n        \n          O\n        \n        (\n        N\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (N)}\n  \n个旋转因子的复数乘法。\n这种方法以及FFT的基本思路在1965年J. W. Cooley和J. W. Tukey合作发表An algorithm for the machine calculation of complex Fourier series之后开始为人所知。但后来发现，实际上这两位作者只是重新发明了高斯在1805年就已经提出的算法（此算法在历史上数次以各种形式被再次提出）。\n库利-图基算法最有名的应用，是将序列长为N 的DFT分割为两个长为N/2 的子序列的DFT，因此这一应用只适用于序列长度为2的幂的DFT计算，即基2-FFT。实际上，如同高斯和Cooley与Tukey都指出的那样，Cooley-Tukey算法也可以用于序列长度N 为任意因数分解形式的DFT，即混合基FFT，而且还可以应用于其他诸如分裂基FFT等变种。尽管Cooley-Tukey算法的基本思路是采用递归的方法进行计算，大多数传统的算法实现都将显式的递归算法改写为非递归的形式。另外，因为Cooley-Tukey算法是将DFT分解为较小长度的多个DFT，因此它可以同任一种其他的DFT算法联合使用。\n设计思想[编辑]下面，我们用N次单位根\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n来表示\n  \n    \n      \n        \n          e\n          \n            −\n            j\n            \n              \n                \n                  2\n                  π\n                \n                N\n              \n            \n          \n        \n      \n    \n    {\\displaystyle e^{-j{\\frac {2\\pi }{N}}}}\n  \n。\n\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n的性质：\n周期性，\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n具有周期\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n，即\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            N\n          \n        \n        =\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+N}=W_{N}^{k}}\n  \n\n对称性：\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+{\\frac {N}{2}}}=-W_{N}^{k}}\n  \n。\n若\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n的约数，\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            m\n            k\n            n\n          \n        \n        =\n        \n          W\n          \n            \n              N\n              m\n            \n          \n          \n            k\n            n\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{mkn}=W_{\\frac {N}{m}}^{kn}}\n  \n为了简单起见，我们下面设待变换序列长度\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            r\n          \n        \n      \n    \n    {\\displaystyle n=2^{r}}\n  \n。根据上面单位根的对称性，求级数\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          ∑\n          \n            n\n            =\n            0\n          \n          \n            N\n            −\n            1\n          \n        \n        \n          W\n          \n            N\n          \n          \n            k\n            n\n          \n        \n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{k}=\\sum _{n=0}^{N-1}W_{N}^{kn}x_{n}}\n  \n时，可以将求和区间分为两部分：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  y\n                  \n                    k\n                  \n                \n                =\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n                +\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                    +\n                    1\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                  \n                \n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                    +\n                    1\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  F\n                  \n                    e\n                    v\n                    e\n                    n\n                  \n                \n                (\n                k\n                )\n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  F\n                  \n                    o\n                    d\n                    d\n                  \n                \n                (\n                k\n                )\n              \n              \n              \n              \n              \n              \n              \n                (\n                i\n                ∈\n                \n                  Z\n                \n                )\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{matrix}y_{k}=\\sum _{n=2t}W_{N}^{kn}x_{n}+\\sum _{n=2t+1}W_{N}^{kn}x_{n}\\\\=\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t}+W_{N}^{k}\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t+1}\\\\=F_{even}(k)+W_{N}^{k}F_{odd}(k)&&&&&&(i\\in \\mathbb {Z} )\\end{matrix}}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n是两个分别关于序列\n  \n    \n      \n        \n          \n            {\n            \n              x\n              \n                n\n              \n            \n            }\n          \n          \n            0\n          \n          \n            N\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle \\left\\{x_{n}\\right\\}_{0}^{N-1}}\n  \n奇数号和偶数号序列N/2点变换。由此式只能计算出\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle y_{k}}\n  \n的前N/2个点，对于后N/2个点，注意\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n都是周期为N/2的函数，由单位根的对称性，于是有以下变换公式：\n\n  \n    \n      \n        \n          y\n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k+{\\frac {N}{2}}}=F_{even}(k)-W_{N}^{k}F_{odd}(k)}\n  \n\n\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        +\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k}=F_{even}(k)+W_{N}^{k}F_{odd}(k)}\n  \n。这样，一个N点变换就分解成了两个N/2点变换。照这样可继续分解下去。这就是库利-图基快速傅里叶变换算法的基本原理。根据主定理不难分析出此时算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        N\n        log\n        ⁡\n        N\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (N\\log N)}\n  \n\n算法实现[编辑]蝶形结网络和位反转（Bit Reversal）：首先将\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle n=2^{N}}\n  \n个输入点列按二进制进行编号，然后对各个编号按位倒置并按此重新排序。例如，对于一个8点变换，\n001倒置以后变成 100\n000 → 000\n001 → 100\n010 → 010\n011 → 110\n100 → 001\n101 → 101\n110 → 011\n111 → 111\n倒置后的编号为{0,4,2,6,1,5,3,7}。\n然后将这n个点列作为输入传送到蝶形结网络中，注意将因子\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k}}\n  \n逐层加入到蝶形网络中。算法复杂度[编辑]由于按蝶形结网络计算n点变换要进行log n层计算，每层计算n个点的变换，故算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (n\\log n)}\n  \n。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法", "Tag": "算法设计"}
{"Answer": "下面，我们用N次单位根\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n来表示\n  \n    \n      \n        \n          e\n          \n            −\n            j\n            \n              \n                \n                  2\n                  π\n                \n                N\n              \n            \n          \n        \n      \n    \n    {\\displaystyle e^{-j{\\frac {2\\pi }{N}}}}\n  \n。\n\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n的性质：\n周期性，\n  \n    \n      \n        \n          W\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle W_{N}}\n  \n具有周期\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n，即\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            N\n          \n        \n        =\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+N}=W_{N}^{k}}\n  \n\n对称性：\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k+{\\frac {N}{2}}}=-W_{N}^{k}}\n  \n。\n若\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n是\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n的约数，\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            m\n            k\n            n\n          \n        \n        =\n        \n          W\n          \n            \n              N\n              m\n            \n          \n          \n            k\n            n\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{mkn}=W_{\\frac {N}{m}}^{kn}}\n  \n为了简单起见，我们下面设待变换序列长度\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            r\n          \n        \n      \n    \n    {\\displaystyle n=2^{r}}\n  \n。根据上面单位根的对称性，求级数\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          ∑\n          \n            n\n            =\n            0\n          \n          \n            N\n            −\n            1\n          \n        \n        \n          W\n          \n            N\n          \n          \n            k\n            n\n          \n        \n        \n          x\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle y_{k}=\\sum _{n=0}^{N-1}W_{N}^{kn}x_{n}}\n  \n时，可以将求和区间分为两部分：\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  y\n                  \n                    k\n                  \n                \n                =\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n                +\n                \n                  ∑\n                  \n                    n\n                    =\n                    2\n                    t\n                    +\n                    1\n                  \n                \n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                    n\n                  \n                \n                \n                  x\n                  \n                    n\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                  \n                \n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  ∑\n                  \n                    t\n                  \n                \n                \n                  W\n                  \n                    \n                      N\n                      2\n                    \n                  \n                  \n                    k\n                    t\n                  \n                \n                \n                  x\n                  \n                    2\n                    t\n                    +\n                    1\n                  \n                \n              \n            \n            \n              \n                =\n                \n                  F\n                  \n                    e\n                    v\n                    e\n                    n\n                  \n                \n                (\n                k\n                )\n                +\n                \n                  W\n                  \n                    N\n                  \n                  \n                    k\n                  \n                \n                \n                  F\n                  \n                    o\n                    d\n                    d\n                  \n                \n                (\n                k\n                )\n              \n              \n              \n              \n              \n              \n              \n                (\n                i\n                ∈\n                \n                  Z\n                \n                )\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{matrix}y_{k}=\\sum _{n=2t}W_{N}^{kn}x_{n}+\\sum _{n=2t+1}W_{N}^{kn}x_{n}\\\\=\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t}+W_{N}^{k}\\sum _{t}W_{\\frac {N}{2}}^{kt}x_{2t+1}\\\\=F_{even}(k)+W_{N}^{k}F_{odd}(k)&&&&&&(i\\in \\mathbb {Z} )\\end{matrix}}}\n  \n\n\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n是两个分别关于序列\n  \n    \n      \n        \n          \n            {\n            \n              x\n              \n                n\n              \n            \n            }\n          \n          \n            0\n          \n          \n            N\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle \\left\\{x_{n}\\right\\}_{0}^{N-1}}\n  \n奇数号和偶数号序列N/2点变换。由此式只能计算出\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle y_{k}}\n  \n的前N/2个点，对于后N/2个点，注意\n  \n    \n      \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{odd}(k)}\n  \n和\n  \n    \n      \n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle F_{even}(k)}\n  \n都是周期为N/2的函数，由单位根的对称性，于是有以下变换公式：\n\n  \n    \n      \n        \n          y\n          \n            k\n            +\n            \n              \n                N\n                2\n              \n            \n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        −\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k+{\\frac {N}{2}}}=F_{even}(k)-W_{N}^{k}F_{odd}(k)}\n  \n\n\n  \n    \n      \n        \n          y\n          \n            k\n          \n        \n        =\n        \n          F\n          \n            e\n            v\n            e\n            n\n          \n        \n        (\n        k\n        )\n        +\n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n        \n          F\n          \n            o\n            d\n            d\n          \n        \n        (\n        k\n        )\n      \n    \n    {\\displaystyle y_{k}=F_{even}(k)+W_{N}^{k}F_{odd}(k)}\n  \n。这样，一个N点变换就分解成了两个N/2点变换。照这样可继续分解下去。这就是库利-图基快速傅里叶变换算法的基本原理。根据主定理不难分析出此时算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        N\n        log\n        ⁡\n        N\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (N\\log N)}\n  \n\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法的设计思想", "Tag": "算法设计"}
{"Answer": "蝶形结网络和位反转（Bit Reversal）：首先将\n  \n    \n      \n        n\n        =\n        \n          2\n          \n            N\n          \n        \n      \n    \n    {\\displaystyle n=2^{N}}\n  \n个输入点列按二进制进行编号，然后对各个编号按位倒置并按此重新排序。例如，对于一个8点变换，\n001倒置以后变成 100\n000 → 000\n001 → 100\n010 → 010\n011 → 110\n100 → 001\n101 → 101\n110 → 011\n111 → 111\n倒置后的编号为{0,4,2,6,1,5,3,7}。\n然后将这n个点列作为输入传送到蝶形结网络中，注意将因子\n  \n    \n      \n        \n          W\n          \n            N\n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle W_{N}^{k}}\n  \n逐层加入到蝶形网络中。", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法的算法实现", "Tag": "算法设计"}
{"Answer": "由于按蝶形结网络计算n点变换要进行log n层计算，每层计算n个点的变换，故算法的时间复杂度为\n  \n    \n      \n        \n          O\n        \n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle \\mathrm {O} (n\\log n)}\n  \n。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的库利-图基算法的算法复杂度", "Tag": "算法设计"}
{"Answer": "在Cooley-Tukey算法之外还有其他DFT的快速演算法。对于长度\n  \n    \n      \n        N\n        =\n        \n          N\n          \n            1\n          \n        \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N=N_{1}N_{2}}\n  \n且\n  \n    \n      \n        \n          N\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle N_{1}}\n  \n与\n  \n    \n      \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N_{2}}\n  \n互质的序列，可以采用基于中国剩余定理的互质因子算法将N长序列的DFT分解为两个子序列的DFT。与Cooley-Tukey算法不同的是，互质因子算法不需要旋转因子。\nRader-Brenner算法是类似于Cooley-Tukey算法，但是采用的旋转因子都是纯虚数，以增加加法运算和降低了数值稳定性为代价减少了乘法运算。这方法之后被split-radix variant of Cooley-Tukey所取代，与Rader-Brenner演算法相比，有一样多的乘法量，却有较少的加法量，且不牺牲数值的准确性。\nBruun以及QFT演算法是不断的把DFT分成许多较小的DFT运算。（Rader-Brenner以及QFT演算法是为了2的指数所设计的演算法，但依然可以适用在可分解的整数上。Bruun演算法则可以运用在可被分成偶数个运算的数字）。尤其是Bruun演算法，把FFT看成是\n  \n    \n      \n        \n          z\n          \n            N\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle z^{N}-1}\n  \n，并把它分解成\n  \n    \n      \n        \n          z\n          \n            M\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle z^{M-1}}\n  \n与\n  \n    \n      \n        \n          z\n          \n            2\n            M\n          \n        \n        +\n        a\n        \n          z\n          \n            M\n          \n        \n        +\n        1\n      \n    \n    {\\displaystyle z^{2M}+az^{M}+1}\n  \n的形式。\n另一个从多项式观点的快速傅立叶变换法是Winograd算法。此演算法把\n  \n    \n      \n        \n          z\n          \n            N\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle z^{N}-1}\n  \n分解成cyclotomic多项式，而这些多项式的系数通常为1，0，-1。这样只需要很少的乘法量（如果有需要的话），所以winograd是可以得到最少乘法量的快速傅立叶演算法，对于较小的数字，可以找出有效率的算方式。更精确地说，winograd演算法让DFT可以用\n  \n    \n      \n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle 2^{k}}\n  \n点的DFT来简化，但减少乘法量的同时，也增加了非常多的加法量。Winograd也可以利用剩余值定理来简化DFT。\nRader演算法提出了利用点数为N（N为质数）的DFT进行长度为N-1的回旋摺积来表示原本的DFT，如此就可利用摺积用一对基本的FFT来计算DFT。另一个prime-size的FFT演算法为chirp-Z演算法。此法也是将DFT用摺积来表示，此法与Rader演算法相比，能运用在更一般的转换上，其转换的基础为Z转换（Rabiner et al., 1969）。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的其他算法", "Tag": "算法设计"}
{"Answer": "在许多的运用当中，要进行DFT的资料是纯实数，如此一来经过DFT的结果会满足对称性：\n\n  \n    \n      \n        \n          \n            X\n          \n          \n            N\n            −\n            k\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {X} _{N-k}}\n  \n=\n  \n    \n      \n        \n          \n            X\n          \n          \n            k\n          \n          \n            ∗\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {X} _{k}^{*}}\n  \n而有一些演算法是专门为这种情形设计的（e.g. Sorensen, 1987）。另一些则是利用旧有的演算法（e.g. Cooley-Tukey），删去一些不必要的演算步骤，如此省下了记忆体的使用，也省下了时间。另一方面，也可以把一个偶数长度且纯实数的DFT，用长度为原本一半的复数型态DFT来表示（实数项为原本纯实数资料的偶数项，虚数项则为奇数项）。\n在Matlab上用一次N點FFT計算兩個N點實數信號x,y的FFT:\nfunction [X,Y] = Real2FFT( x,y )\n\n% N-point FFT is used for 2 real signals both with length N\n\nN = length(x);\n\nz = x+y*i ;\n\nZ = fft(z);\n\nX = 0.5*(Z+conj(Z(1+mod(0:-1:1-N,N))));\n\nY = 0.5*(Z-conj(Z(1+mod(0:-1:1-N,N))))/i;\n\nend\n一度人们认为，用离散哈特利转换（Discrete Hartley Transform）来处理纯实数的DFT会更有效率，但接着人们发现，对于同样点数的纯实数DFT，经过设计的FFT，可以比DHT省下更多的运算。Bruun演算法是第一个试着从减少实数输入的DFT运算量的演算法，但此法并没有成为人们普遍使用的方法。\n对于实数输入，且输入为偶对称或奇对称的情形，可以更进一步的省下时间以及记忆体，此时DFT可以用离散余弦转换或离散正弦转换来代替（Discrete cosine/sine transforms）。由于DCT/DST也可以设计出FFT的演算法，故在此种情形下，此方法取代了对DFT设计的FFT演算法。\nDFT可以应用在频谱分析以及做摺积的运算，而在此处，不同应用可以用不同的演算法来取代，列表如下：\n用来做频谱分析的情况下，DFT可用下列的演算法代替：\nDCT\nDST\nDHT\n正交基底的扩展（orthogonal basis expantion）包括正交多项式（orthogonal polynomials）以及CDMA.\nWalsh（Hadamard）转换\nHaar转换\n小波（wavelet）转换\n时频分布（time-frequency distribution）用来做摺积的情况下，DFT可用下列的演算法代替：\nDCT\nDST\nDHT\n直接做摺积（direct computing）\n分段式DFT摺积（sectioned DFT convolution）\n威諾格拉德快速傅立葉變換演算法\n沃尔什（Walsh、Hadamard）转换\n数论转换", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的实数或对称资料专用的演算法", "Tag": "算法设计"}
{"Answer": "長久以來，人們對於求出快速傅立葉變換的複雜度下限以及需要多少的運算量感到很有興趣，而實際上也還有許多問題需要解決。即使是用較簡單的情形，即\n  \n    \n      \n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle 2^{k}}\n  \n點的DFT，也還沒能夠嚴謹的證明出FFT至少需要\n  \n    \n      \n        Ω\n        (\n        N\n        log\n        ⁡\n        N\n        )\n      \n    \n    {\\displaystyle \\Omega (N\\log N)}\n  \n（不比\n  \n    \n      \n        N\n        log\n        ⁡\n        N\n      \n    \n    {\\displaystyle N\\log N}\n  \n小）的運算量，目前也沒有發現複雜度更低的演算法。通常數學運算量的多寡會是運算效率好壞最主要的因素，但在現實中，有許多因素也會有很大的影響，如快取記憶體以及CPU均有很大的影響。\n在1978年，Winograd率先導出一個較嚴謹的FFT所需乘法量的下限：\n  \n    \n      \n        Θ\n        (\n        N\n        )\n      \n    \n    {\\displaystyle \\Theta (N)}\n  \n。當\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n時，DFT只需要\n  \n    \n      \n        4\n        N\n        −\n        2\n        \n          log\n          \n            2\n          \n          \n            2\n          \n        \n        ⁡\n        N\n        −\n        2\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n        −\n        4\n      \n    \n    {\\displaystyle 4N-2\\log _{2}^{2}N-2\\log _{2}N-4}\n  \n次無理實數的乘法即可以計算出來。更詳盡，且也能趨近此下限的演算法也一一被提出（Heideman & Burrus, 1986; Duhamel, 1990）。很可惜的是，這些演算法，都需要很大量的加法計算，目前的硬體無法克服這個問題。\n對於所需加法量的數目，雖然我們可以在某些受限制的假設下，推得其下限，但目前並沒有一個精確的下限被推導出來。1973年，Morgenstern在乘法常數趨近巨大的情形下（對大部分的FFT演算法為真，但不是全部）推導出加法量的下限：\n  \n    \n      \n        Ω\n        \n          (\n          \n            N\n            log\n            ⁡\n            N\n          \n          )\n        \n      \n    \n    {\\displaystyle \\Omega \\left(N\\log N\\right)}\n  \n。Pan（1986）在假設FFT演算法的不同步的情形有其極限下證明出加法量的下限\n  \n    \n      \n        Ω\n        (\n        N\n        l\n        o\n        g\n        N\n        )\n      \n    \n    {\\displaystyle \\Omega (NlogN)}\n  \n，但一般來說，此假設相當的不明確。長度為\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n的情形下，在某些假設下，Papadimitriou（1979）提出使用Cooley-Tukey演算法所需的複數加法量\n  \n    \n      \n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n      \n    \n    {\\displaystyle N\\log _{2}N}\n  \n是最少的。到目前為止，在長度為\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n情況，還沒有任何FFT的演算法可以讓複數的加法量比\n  \n    \n      \n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n      \n    \n    {\\displaystyle N\\log _{2}N}\n  \n還少。\n還有一個問題是如何把乘法量與加法量的總和最小化，有時候稱作\"演算複雜度\"（在這裡考慮的是實際的運算量，而不是漸近複雜度）。同樣的，沒有一個嚴謹下限被證明出來。從1968年開始，\n  \n    \n      \n        N\n        =\n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle N=2^{k}}\n  \n點DFT而言，split-radix FFT演算法需要最少的運算量，在\n  \n    \n      \n        N\n        >\n        1\n      \n    \n    {\\displaystyle N>1}\n  \n的情形下，其需要\n  \n    \n      \n        4\n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n        −\n        6\n        N\n        +\n        8\n      \n    \n    {\\displaystyle 4N\\log _{2}N-6N+8}\n  \n個乘法運算以及加法運算。最近有人導出更低的運算量：\n  \n    \n      \n        \n          \n            34\n            9\n          \n        \n        N\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        N\n      \n    \n    {\\displaystyle {\\frac {34}{9}}N\\log _{2}N}\n  \n。（Johnson and Frigo, 2007; Lundy and Van Buskirk, 2007）\n大多數嘗試要降低或者證明FFT複雜度下限的人都把焦點放在複數資料輸入的情況，因其為最簡單的情形。但是，複數資料輸入的FFT演算法，與實數資料輸入的FFT演算法，離散餘弦轉換（DCT），離散哈特列轉換（DHT），以及其他的演算法，均有很大的關連性。故任何一個演算法，在複雜度上有任何的改善的話，其他的演算法複雜度也會馬上獲得改善（Duhamel & Vetterli, 1990）。\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的複雜度以及運算量的極限", "Tag": "算法设计"}
{"Answer": "當輸入信號長度為N時:\nN = 1~60\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的快速演算法查表", "Tag": "算法设计"}
{"Answer": "离散傅里叶变换\n并行快速傅里叶变换\n快速數論變換", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的参阅", "Tag": "算法设计"}
{"Answer": "\n\n^ 杨毅明. 数字信号处理（第2版）. 北京: 机械工业出版社. 2017年: 第95页. ISBN 9787111576235. \n\n^ Charles Van Loan, Computational Frameworks for the Fast Fourier Transform (SIAM, 1992).\n\n^ Heideman, M. T.; Johnson, D. H.; Burrus, C. S. Gauss and the history of the fast Fourier transform. IEEE ASSP Magazine. 1984, 1 (4): 14–21. doi:10.1109/MASSP.1984.1162257. \n\n^ Strang, Gilbert. Wavelets. American Scientist. May–June 1994, 82 (3): 253. JSTOR 29775194. \n\n^ Dongarra, J.; Sullivan, F. Guest Editors Introduction to the top 10 algorithms. Computing in Science Engineering. January 2000, 2 (1): 22–23. ISSN 1521-9615. doi:10.1109/MCISE.2000.814652. \n\n^ Johnson and Frigo, 2007\n\n^ Frigo & Johnson, 2005\n\n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的参考资料", "Tag": "算法设计"}
{"Answer": "\nBrenner, N.; Rader, C. A New Principle for Fast Fourier Transformation. IEEE Acoustics, Speech & Signal Processing. 1976, 24 (3): 264–266. doi:10.1109/TASSP.1976.1162805. \nBrigham, E. O. The Fast Fourier Transform. New York: Prentice-Hall. 2002. \nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. 30. (Polynomials and the FFT). Introduction to Algorithms 2. MIT Press and McGraw-Hill. 2001. ISBN 0-262-03293-7. \nDuhamel, Pierre. Algorithms meeting the lower bounds on the multiplicative complexity of length-2n DFTs and their connection with practical algorithms. IEEE Trans. Acoust. Speech. Sig. Proc. 1990, 38 (9): 1504–151. doi:10.1109/29.60070. \nDuhamel, P.; Vetterli, M. Fast Fourier transforms: a tutorial review and a state of the art. Signal Processing. 1990, 19: 259–299. doi:10.1016/0165-1684(90)90158-U. \nEdelman, A.; McCorquodale, P.; Toledo, S. The Future Fast Fourier Transform?. SIAM J. Sci. Computing. 1999, 20: 1094–1114. doi:10.1137/S1064827597316266. \nD. F. Elliott, & K. R. Rao, 1982, Fast transforms: Algorithms, analyses, applications. New York: Academic Press.\nFunda Ergün, 1995, Testing multivariate linear functions: Overcoming the generator bottleneck, Proc. 27th ACM Symposium on the Theory of Computing: 407–416.\nFrigo, M.; Johnson, S. G. The Design and Implementation of FFTW3 (PDF). Proceedings of the IEEE. 2005, 93: 216–231  [2008-06-22]. doi:10.1109/jproc.2004.840301. （原始内容存档 (PDF)于2019-07-16）. \nH. Guo and C. S. Burrus, 1996, Fast approximate Fourier transform via wavelets transform, Proc. SPIE Intl. Soc. Opt. Eng. 2825: 250–259.\nH. Guo, G. A. Sitton, C. S. Burrus, 1994, The Quick Discrete Fourier Transform, Proc. IEEE Conf. Acoust. Speech and Sig. Processing (ICASSP) 3: 445–448.\nSteve Haynal and Heidi Haynal, \"Generating and Searching Families of FFT Algorithms\", Journal on Satisfiability, Boolean Modeling and Computation vol. 7, pp. 145–187 (2011).\nHeideman, Michael T.; Burrus, C. Sidney. On the number of multiplications necessary to compute a length-2n DFT. IEEE Trans. Acoust. Speech. Sig. Proc. 1986, 34 (1): 91–95. doi:10.1109/TASSP.1986.1164785. \nJohnson, S. G.; Frigo, M. A modified split-radix FFT with fewer arithmetic operations (PDF). IEEE Trans. Signal Processing. 2007, 55 (1): 111–119  [2008-06-22]. doi:10.1109/tsp.2006.882087. （原始内容存档 (PDF)于2021-02-25）. \nT. Lundy and J. Van Buskirk, 2007. \"A new matrix approach to real FFTs and convolutions of length 2k,\" Computing 80 (1): 23–45.\nKent, Ray D. and Read, Charles (2002). Acoustic Analysis of Speech. ISBN 978-0-7693-0112-9. Cites Strang, G. (1994)/May–June). Wavelets. American Scientist, 82, 250–255.\nMorgenstern, Jacques. Note on a lower bound of the linear complexity of the fast Fourier transform. J. ACM. 1973, 20 (2): 305–306. doi:10.1145/321752.321761. \nMohlenkamp, M. J. A fast transform for spherical harmonics (PDF). J. Fourier Anal. Appl. 1999, 5 (2–3): 159–184. doi:10.1007/BF01261607. （原始内容 (PDF)存档于2007年2月6日）. \nNussbaumer, H. J. Digital filtering using polynomial transforms. Electronics Lett. 1977, 13 (13): 386–387. doi:10.1049/el:19770280. \nV. Pan, 1986, The trade-off between the additive complexity and the asyncronicity of linear and bilinear algorithms, Information Proc. Lett. 22: 11–14.\nChristos H. Papadimitriou, 1979, Optimality of the fast Fourier transform, J. ACM 26: 95–102.\nD. Potts, G. Steidl, and M. Tasche, 2001. \"Fast Fourier transforms for nonequispaced data: A tutorial\", in: J.J. Benedetto and P. Ferreira (Eds.), Modern Sampling Theory: Mathematics and Applications (Birkhauser).\nPress, W.H.; Teukolsky, S.A.; Vetterling, W.T.; Flannery, B.P., Chapter 12. Fast Fourier Transform, Numerical Recipes: The Art of Scientific Computing 3, New York: Cambridge University Press, 2007  [2015-12-11], ISBN 978-0-521-88068-8, （原始内容存档于2011-08-11） \nRokhlin, Vladimir; Tygert, Mark. Fast algorithms for spherical harmonic expansions. SIAM J. Sci. Computing. 2006, 27 (6): 1903–1928. doi:10.1137/050623073. \nSchatzman, James C. Accuracy of the discrete Fourier transform and the fast Fourier transform. SIAM J. Sci. Comput. 1996, 17: 1150–1166. doi:10.1137/s1064827593247023. \nShentov, O. V.; Mitra, S. K.; Heute, U.; Hossen, A. N. Subband DFT. I. Definition, interpretations and extensions. Signal Processing. 1995, 41 (3): 261–277. doi:10.1016/0165-1684(94)00103-7. \nSorensen, H. V.; Jones, D. L.; Heideman, M. T.; Burrus, C. S. Real-valued fast Fourier transform algorithms. IEEE Trans. Acoust. Speech Sig. Processing. 1987, 35 (35): 849–863. doi:10.1109/TASSP.1987.1165220.  See also Sorensen, H.; Jones, D.; Heideman, M.; Burrus, C. Corrections to \"Real-valued fast Fourier transform algorithms\". IEEE Transactions on Acoustics, Speech, and Signal Processing. 1987, 35 (9): 1353–1353. doi:10.1109/TASSP.1987.1165284. \nWelch, Peter D. A fixed-point fast Fourier transform error analysis. IEEE Trans. Audio Electroacoustics. 1969, 17 (2): 151–157. doi:10.1109/TAU.1969.1162035. \nWinograd, S. On computing the discrete Fourier transform. Math. Computation. 1978, 32 (141): 175–199. JSTOR 2006266. doi:10.1090/S0025-5718-1978-0468306-4. \n", "Konwledge_Point": "快速傅里叶变换", "Question": "什么是快速傅里叶变换的延伸阅读", "Tag": "算法设计"}
