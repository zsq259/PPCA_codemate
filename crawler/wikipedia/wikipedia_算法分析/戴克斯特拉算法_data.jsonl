{"Answer": "\n戴克斯特拉算法（英語：Dijkstra's algorithm），又稱迪杰斯特拉算法、Dijkstra算法[6]，是由荷兰计算机科学家艾茲赫尔·戴克斯特拉在1956年发现的算法，并于3年后在期刊上发表[7][8][9]。戴克斯特拉算法使用类似廣度优先搜索的方法解决赋权图[9]的单源最短路径问题[10][1][2]。\n该算法存在很多变体：戴克斯特拉的原始版本仅适用于找到两个顶点之间的最短路径[9]，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树[1]。\n该算法解决了圖 \n  \n    \n      \n        G\n        =\n        ⟨\n        V\n        ,\n        E\n        ⟩\n      \n    \n    {\\displaystyle G=\\langle V,E\\rangle }\n  \n上带权的单源最短路径问题[1][11]:196–206。具体来说，戴克斯特拉算法设置了一顶点集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n，在集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中所有的顶点与源点\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n之间的最终最短路径权值均已确定[1]。算法反复选择最短路径估计最小的点\n  \n    \n      \n        u\n        ∈\n        \n          V\n          −\n          S\n        \n      \n    \n    {\\displaystyle u\\in {V-S}}\n  \n并将\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n加入\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中[1]。该算法常用于路由算法或者作为其他图算法的一个子模块[12]。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该演算法可以用来找到两个城市之间的最短路径[8][2]。\n应当注意，绝大多数的戴克斯特拉算法不能有效处理带有负权边的图[1][13]。\n戴克斯特拉算法在计算机科学的人工智能等领域也被称为均一开销搜索，并被认为是最良优先搜索（英语：best-first search）的一个特例[10]。\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法", "Tag": "算法设计"}
{"Answer": "  上圖為戴克斯特拉演算法應用示意圖。起點以左下角的紅點，目標是右上角的綠點，中間灰色的倒L型為障礙物。藍色空圈表示\"暫定\"，用以搜索下一步；已經填充顏色的表示探訪過，圖中顏色以紅到綠，越綠表示離起點越遠。所有節點都被均勻的探索。戴克斯特拉算法通過保留目前為止所找到的每個頂點\n  \n    \n      \n        v\n        ∈\n        V\n      \n    \n    {\\displaystyle v\\in V}\n  \n從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑來工作[1][2]。初始時，原點\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n的路径权重被賦為 0 （即原点的实际最短路径=0）[1][2]。同時把所有其他頂點的路徑長度設為無窮大，即表示我們不知道任何通向這些頂點的路徑[1]。當算法結束時，\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n 中儲存的便是從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑，或者如果路徑不存在的話是無窮大[1]。\n松弛操作是戴克斯特拉算法的基礎操作：如果存在一條從\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的邊，那麼從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的一条新路径是將邊\n  \n    \n      \n        w\n        (\n        u\n        ,\n        v\n        )\n        ∈\n        E\n      \n    \n    {\\displaystyle w(u,v)\\in E}\n  \n添加到從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的路徑尾部來拓展一條從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的路径[1][9]。這條路徑的長度是\n  \n    \n      \n        d\n        [\n        u\n        ]\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle d[u]+w(u,v)}\n  \n[1]。如果這個值比目前已知的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n的值要小，那么可以用这个值來替代當前\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n中的值[1]。松弛邊的操作一直執行到所有的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n都代表從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑的长度值[1]。\n算法維護兩個頂點集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n和\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n[1][9]。集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n保留所有已知实际最短路径值的頂點，而集合\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n則保留其他所有頂點[1][9]。集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n初始狀態為空，而後每一步都有一個頂點從\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n移動到\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n[1][9]。這個被選擇的頂點是\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中擁有最小的\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n值的頂點[1][2]。當一個頂點\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n從\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中轉移到了\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中，算法對\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的每条外接邊\n  \n    \n      \n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle w(u,v)}\n  \n進行松弛[1]。\n《算法导论》中给出了以下伪代码[1]：该伪代码计算并保留图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中原点\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到每一顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短距离\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n。其中，函数\n  \n    \n      \n        E\n        x\n        t\n        r\n        a\n        c\n        t\n        −\n        M\n        i\n        n\n        (\n        Q\n        )\n      \n    \n    {\\displaystyle Extract-Min(Q)}\n  \n将頂點集合\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中有最小\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n值的頂點\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n从\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中删除并返回\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n[1]。\n 1  function Dijkstra(G, w, s)\n 2   INITIALIZE-SINGLE-SOURCE(G, s)                //实际上的操作是将每个除原点外的顶点的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n置为无穷大，\n  \n    \n      \n        d\n        [\n        s\n        ]\n        =\n        0\n      \n    \n    {\\displaystyle d[s]=0}\n  \n\n 3   \n  \n    \n      \n        S\n        ←\n        ∅\n      \n    \n    {\\displaystyle S\\leftarrow \\emptyset }\n  \n\n 4   \n  \n    \n      \n        Q\n        ←\n        s\n      \n    \n    {\\displaystyle Q\\leftarrow s}\n  \n                                //\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n是顶点\n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n的一个优先队列，以顶点的最短路径估计排序\n 5   while(\n  \n    \n      \n        Q\n        ≠\n        ∅\n      \n    \n    {\\displaystyle Q\\not =\\emptyset }\n  \n)\n 6       do \n  \n    \n      \n        u\n        ←\n        E\n        X\n        T\n        R\n        A\n        C\n        T\n        −\n        M\n        I\n        N\n        (\n        Q\n        )\n      \n    \n    {\\displaystyle u\\leftarrow EXTRACT-MIN(Q)}\n  \n          //选取\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n为\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中最短路径估计最小的顶点\n 7       \n  \n    \n      \n        S\n        ←\n        S\n        ∪\n        u\n      \n    \n    {\\displaystyle S\\leftarrow S\\cup u}\n  \n\n 8       for each vertex v \n  \n    \n      \n        ∈\n        A\n        d\n        j\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle \\in Adj[u]}\n  \n\n 9            do RELAX(u, v, w)            //松弛成功的结点会被加入到队列中\n如果我們只對在\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n和\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n之間尋找一條最短路徑的話，我們可以在第5或第6行添加條件如果滿足\n  \n    \n      \n        u\n        =\n        t\n      \n    \n    {\\displaystyle u=t}\n  \n的話終止程序[1][2]。\n在肯尼·罗森所著的《离散数学及其应用》中给出了如下的另一份伪代码[2]：\n 1 procedure Dijkstra(G：边全为正权的图）\n 2   {G带有顶点\n  \n    \n      \n        a\n        =\n        \n          v\n          \n            0\n          \n        \n        ,\n        \n          v\n          \n            1\n          \n        \n        ,\n        \n          v\n          \n            2\n          \n        \n        .\n        .\n        .\n      \n    \n    {\\displaystyle a=v_{0},v_{1},v_{2}...}\n  \n和若干边\n  \n    \n      \n        w\n        (\n        \n          v\n          \n            i\n          \n        \n        ,\n        \n          v\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle w(v_{i},v_{j})}\n  \n}\n 3    for \n  \n    \n      \n        i\n        :=\n        1\n      \n    \n    {\\displaystyle i:=1}\n  \n to n\n 4       \n  \n    \n      \n        D\n        (\n        \n          v\n          \n            i\n          \n        \n        )\n        :=\n        ∞\n      \n    \n    {\\displaystyle D(v_{i}):=\\infty }\n  \n\n 5    \n  \n    \n      \n        D\n        (\n        a\n        )\n        :=\n        0\n      \n    \n    {\\displaystyle D(a):=0}\n  \n\n 6    \n  \n    \n      \n        S\n        :=\n        ∅\n      \n    \n    {\\displaystyle S:=\\emptyset }\n  \n\n 7    while \n  \n    \n      \n        z\n        ∉\n        S\n      \n    \n    {\\displaystyle z\\notin S}\n  \n\n 8    begin\n 9          \n  \n    \n      \n        u\n        :=\n      \n    \n    {\\displaystyle u:=}\n  \n不属于\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n的\n  \n    \n      \n        D\n        (\n        u\n        )\n      \n    \n    {\\displaystyle D(u)}\n  \n最小的一个顶点\n 10        \n  \n    \n      \n        S\n        :=\n        S\n        ∪\n        {\n        u\n        }\n      \n    \n    {\\displaystyle S:=S\\cup \\{u\\}}\n  \n\n 11        for 所有不属于\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n的顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n\n 12            if \n  \n    \n      \n        D\n        (\n        u\n        )\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n        <\n        D\n        (\n        v\n        )\n      \n    \n    {\\displaystyle D(u)+w(u,v)<D(v)}\n  \n then \n  \n    \n      \n        D\n        (\n        v\n        )\n        :=\n        D\n        (\n        u\n        )\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle D(v):=D(u)+w(u,v)}\n  \n\n 13    end{\n  \n    \n      \n        D\n        (\n        z\n        )\n        =\n      \n    \n    {\\displaystyle D(z)=}\n  \n从a到z的最短路长度}\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法描述", "Tag": "算法设计"}
{"Answer": "我們可以用大O符號將该算法的運行時間表示為邊數\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n和頂點數\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n的函數[1]。\n对于任何基于顶点集\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n的实现，算法的运行时间是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        ⋅\n        d\n        \n          k\n          \n            Q\n          \n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        ⋅\n        e\n        \n          m\n          \n            Q\n          \n        \n        )\n      \n    \n    {\\displaystyle O(|E|\\cdot dk_{Q}+|V|\\cdot em_{Q})}\n  \n，其中\n  \n    \n      \n        d\n        \n          k\n          \n            Q\n          \n        \n      \n    \n    {\\displaystyle dk_{Q}}\n  \n和\n  \n    \n      \n        e\n        \n          m\n          \n            Q\n          \n        \n      \n    \n    {\\displaystyle em_{Q}}\n  \n分别表示完成键的降序排列时间和从\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中提取最小键值的时间[1]。\n对于没有任何优化的戴克斯特拉算法，实际上等价于每次遍历了整个图的所有结点来找到Q中满足条件的元素（即寻找最小的頂點是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|)}\n  \n的），此外实际上还需要遍历所有的边一遍，因此算法的复杂度是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          \n            |\n          \n          \n            2\n          \n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|^{2}+|E|)}\n  \n[2]。\n對於邊數少於\n  \n    \n      \n        \n          |\n        \n        V\n        \n          \n            |\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle |V|^{2}}\n  \n的稀疏圖來說，可以用鄰接表來更有效的實現该算法[1]。\n可以使用一個二叉堆或者斐波納契堆用作優先隊列來尋找最小的頂點（\n  \n    \n      \n        E\n        x\n        t\n        r\n        a\n        c\n        t\n        −\n        M\n        i\n        n\n      \n    \n    {\\displaystyle Extract-Min}\n  \n）以优化算法[14][15]。當用到二叉堆的時候，算法所需的時間為\n  \n    \n      \n        O\n        (\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n        log\n        ⁡\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O((|E|+|V|)\\log |V|)}\n  \n[14]，斐波納契堆能提高一些性能，讓算法運行時間達到\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        log\n        ⁡\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|E|+|V|\\log |V|)}\n  \n[4][15]。然而，使用斐波納契堆进行编程，有时会由于算法常数过大而导致速度没有显著提高[16]。\n下面是一些戴克斯特拉算法经典实现的复杂度比较：\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的時間複雜度", "Tag": "算法设计"}
{"Answer": "  艾兹赫尔·戴克斯特拉，戴克斯特拉算法的发现者戴克斯特拉本人在他的论文中给出了一份简单的证明[9]。\n《算法导论》使用循环不变式（数学归纳法）给出了如下的一份证明[1]：\n已知一带权图\n  \n    \n      \n        G\n        =<\n        V\n        ,\n        E\n        >\n      \n    \n    {\\displaystyle G=<V,E>}\n  \n，其加权函数\n  \n    \n      \n        w\n      \n    \n    {\\displaystyle w}\n  \n的值非负，源点为\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n。对该图运行戴克斯特拉算法，对所有\n  \n    \n      \n        u\n        ∈\n        V\n      \n    \n    {\\displaystyle u\\in V}\n  \n有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。其中\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n表示u点的最短路径估计，\n  \n    \n      \n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle \\delta (s,u)}\n  \n表示\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n点的最短路径。\n证明：证明如下的循环不变式成立即可：在每次执行EXTRACT-MIN时，对每个顶点\n  \n    \n      \n        u\n        ∈\n        S\n      \n    \n    {\\displaystyle u\\in S}\n  \n，有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n成立即可。由于上界性质，在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n加入了\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n之后，一旦有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n，则在后面的每次循环中都不会改变这个性质。\n初始化：第一次循环前，\n  \n    \n      \n        S\n        =\n        ∅\n      \n    \n    {\\displaystyle S=\\emptyset }\n  \n，因此循环不变式显然成立。\n保持：实际上要证明每一轮循环中加入到\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中的结点满足\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。利用反证法，假设\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n是第一个不满足此条件的结点，考虑循环开始前的状况，首先\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n一定不等于\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n，这是显然的。其次\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n一定有到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的路径，否则路径为无穷大。那么假设在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n进入时，有最短路径\n  \n    \n      \n        p\n        =\n        s\n        −\n        >\n        u\n      \n    \n    {\\displaystyle p=s->u}\n  \n，假设该路径上存在两个点\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n，\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n。\n  \n    \n      \n        y\n        ∈\n        V\n        −\n        S\n      \n    \n    {\\displaystyle y\\in V-S}\n  \n、\n  \n    \n      \n        x\n        ∈\n        S\n      \n    \n    {\\displaystyle x\\in S}\n  \n，且x是y的前驱，路径\n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n可以分解为\n  \n    \n      \n        s\n        −\n        \n          p\n          \n            1\n          \n        \n        −\n        >\n        x\n        −\n        >\n        y\n        −\n        \n          p\n          \n            2\n          \n        \n        −\n        >\n        u\n      \n    \n    {\\displaystyle s-p_{1}->x->y-p_{2}->u}\n  \n（此处\n  \n    \n      \n        −\n        \n          p\n          \n            1\n          \n        \n        −\n        >\n      \n    \n    {\\displaystyle -p_{1}->}\n  \n表示经过\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n这条路径，后同），其中路径\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n和路径\n  \n    \n      \n        \n          p\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle p_{2}}\n  \n可以为空。由于\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n是第一个不满足\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n的，又因为\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n是满足该条件的，而且\n  \n    \n      \n        (\n        x\n        ,\n        y\n        )\n      \n    \n    {\\displaystyle (x,y)}\n  \n一定已经被松弛过了，所以\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n是满足该条件的。\n现在只需要推出矛盾，即可证明u不存在：\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n之前出现，而且图中所有权值非负，因此有\n  \n    \n      \n        δ\n        (\n        s\n        ,\n        y\n        )\n        ≤\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle \\delta (s,y)\\leq \\delta (s,u)}\n  \n，所以：\n  \n    \n      \n        d\n        [\n        y\n        ]\n        ≤\n        δ\n        (\n        s\n        ,\n        y\n        )\n        ≤\n        δ\n        (\n        s\n        ,\n        u\n        )\n        ≤\n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[y]\\leq \\delta (s,y)\\leq \\delta (s,u)\\leq d[u]}\n  \n，但是由于\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n和\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n同时在\n  \n    \n      \n        V\n        −\n        S\n      \n    \n    {\\displaystyle V-S}\n  \n中，因此\n  \n    \n      \n        d\n        [\n        u\n        ]\n        ≤\n        d\n        [\n        y\n        ]\n      \n    \n    {\\displaystyle d[u]\\leq d[y]}\n  \n，因此必有\n  \n    \n      \n        d\n        [\n        y\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        y\n        )\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n        =\n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[y]=\\delta (s,y)=\\delta (s,u)=d[u]}\n  \n，也就证明了\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n点不可能不满足该条件，上述假设为假，原命题得证。\n终止：终止时，\n  \n    \n      \n        Q\n        =\n        ∅\n      \n    \n    {\\displaystyle Q=\\emptyset }\n  \n，由于\n  \n    \n      \n        Q\n        =\n        V\n        −\n        S\n      \n    \n    {\\displaystyle Q=V-S}\n  \n，因此\n  \n    \n      \n        V\n        =\n        S\n      \n    \n    {\\displaystyle V=S}\n  \n，因此对所有\n  \n    \n      \n        u\n        ∈\n        V\n      \n    \n    {\\displaystyle u\\in V}\n  \n有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法正确性证明", "Tag": "算法设计"}
{"Answer": "从鹿特丹到格罗宁根的最短路径是什么？实际上，这就是对于任意两座城市之间的最短路问题。解决这个问题实际上大概只花了我20分钟：一天早上，我和我的未婚妻在阿姆斯特丹购物，累了，我们便坐在咖啡馆的露台上喝咖啡，然后我就试了一下能否用一个算法解决最短路问题。正如我所说，这是一个20分钟的发现。不过实际上，我在3年后的1959年才把这个算法发表在论文上。即使现在来看这篇论文的可读性也非常高，这个算法之所以如此优雅，其中一个原因就是我没用笔纸就设计了它。后来我才知道，没用笔纸设计的优点之一是你不得不避免所有可避免的复杂问题。令我惊讶的是，这个算法最终成为我成名的基石之一。——艾兹赫尔·戴克斯特拉在2001年的采访中提到戴克斯特拉算法的发现历程[8]戴克斯特拉1956年在荷兰数学和计算机科学研究学会担任程序员时为了展示新型计算机ARMAC的功能曾思考过最短路径问题的解法[22]。他的目标是让不去实际计算的人也能理解这个问题和解决的方法，于是他在发现了这个算法之后在ARMAC上做了简单实验[8]。1959年，他正式将此算法发表在期刊上，该算法也成为了戴克斯特拉成名的基石之一[8][9]。\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法起源与历史", "Tag": "算法设计"}
{"Answer": "  一个多区域OSPF网络，在OSPF中使用本算法计算最短路径链路状态路由协议（英语：Link-state routing protocol）中需要计算最短路时常常要用到该算法，该算法在開放最短路徑優先和中间系统到中间系统协议中的相关应用是其在網絡路由中的典型實現[12]。\n戴克斯特拉算法及其改进算法应用广泛，尤其是在寻路、交通、规划中[23][24][25][26]。\n如果有已知信息可用來估計某一點到目標點的距離，則可改用A*搜尋算法，以減小最短路徑的搜索範圍，戴克斯特拉算法本身也可以看作是A*搜索算法的一个特例[27][28]。\n戴克斯特拉算法本身采用了与Prim算法类似的贪心策略[9][29][30][31]。快速行进算法与戴克斯特拉算法同样有相似之处[32]。\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的算法相关应用", "Tag": "算法设计"}
{"Answer": "以下是该算法使用堆优化的一个C++实现参考[33]：\n#include<bits/stdc++.h> \nusing namespace std; \n# define INF 0x3f3f3f3f \n  \n// iPair ==> Integer Pair（整数对）\ntypedef pair<int, int> iPair; \n  \n// 加边\nvoid addEdge(vector <pair<int, int> > adj[], int u, \n                                     int v, int wt) \n{ \n    adj[u].push_back(make_pair(v, wt)); \n    adj[v].push_back(make_pair(u, wt)); \n} \n   \n  \n// 计算最短路\nvoid shortestPath(vector<pair<int,int> > adj[], int V, int src) \n{ \n    // 关于stl中的优先队列如何实现，参考下方网址：\n    // http://geeksquiz.com/implement-min-heap-using-stl/ \n    priority_queue< iPair, vector <iPair> , greater<iPair> > pq; \n  \n    // 距离置为正无穷大\n    vector<int> dist(V, INF); \n    vector<bool> visited(V, false);\n\n    // 插入源点，距离为0\n    pq.push(make_pair(0, src)); \n    dist[src] = 0; \n  \n    /* 循环直到优先队列为空 */\n    while (!pq.empty()) \n    { \n        // 每次从优先队列中取出顶点事实上是这一轮最短路径权值确定的点\n        int u = pq.top().second; \n        pq.pop(); \n        if (visited[u]) {\n            continue;\n        }\n        visited[u] = true;\n        // 遍历所有边\n        for (auto x : adj[u]) \n        { \n            // 得到顶点边号以及边权\n            int v = x.first; \n            int weight = x.second; \n  \n            //可以松弛\n            if (dist[v] > dist[u] + weight) \n            { \n                // 松弛 \n                dist[v] = dist[u] + weight; \n                pq.push(make_pair(dist[v], v)); \n            } \n        } \n    } \n  \n    // 打印最短路\n    printf(\"Vertex Distance from Source\\n\"); \n    for (int i = 0; i < V; ++i) \n        printf(\"%d \\t\\t %d\\n\", i, dist[i]); \n} \nint main() \n{ \n    int V = 9; \n    vector<iPair > adj[V]; \n    addEdge(adj, 0, 1, 4); \n    addEdge(adj, 0, 7, 8); \n    addEdge(adj, 1, 2, 8); \n    addEdge(adj, 1, 7, 11); \n    addEdge(adj, 2, 3, 7); \n    addEdge(adj, 2, 8, 2); \n    addEdge(adj, 2, 5, 4); \n    addEdge(adj, 3, 4, 9); \n    addEdge(adj, 3, 5, 14); \n    addEdge(adj, 4, 5, 10); \n    addEdge(adj, 5, 6, 2); \n    addEdge(adj, 6, 7, 1); \n    addEdge(adj, 6, 8, 6); \n    addEdge(adj, 7, 8, 7); \n  \n    shortestPath(adj, V, 0); \n  \n    return 0; \n}\n以下是该算法Python的一个实现:\nimport sys\nmax = sys.maxsize\n\nvertices_number = 6\nadjacency_matrix = [\n    [0, 1, 10, -1, -1, 2],\n    [10, 0, 1, -1, -1, -1],\n    [1, 10, 0, -1, -1, -1],\n    [-1, -1, 2, 0, 1, 10],\n    [-1, -1, -1, 10, 0, 1],\n    [-1, -1, -1, 1, 10, 0]]\nstart = []\ndest = [\"2\", \"5\"]\nkey = []\n\n\ndef init_keys(s: int):\n    global key\n    key = [ max ] * vertices_number\n    key[s] = 0\n\n\ndef dijkstra(from_vertex, dest_vertex):\n    fid = int(from_vertex) - 1\n    tid = int(dest_vertex) - 1\n    init_keys(fid)\n    rel = [fid]\n    min_vertex = fid\n    hop_path = {}\n\n    while len(rel) <= vertices_number and min_vertex != tid:\n        for i in range(vertices_number):\n            if i != min_vertex and i not in rel and \\\n                adjacency_matrix[min_vertex][i] > 0 \\\n                and key[i] > key[min_vertex] + adjacency_matrix[min_vertex][i]:\n                key[i] = key[min_vertex] + adjacency_matrix[min_vertex][i]\n                hop_path.update({i + 1: {\"from\": min_vertex + 1, \"cost\": adjacency_matrix[min_vertex][i]}})\n\n        if min_vertex not in rel:\n            rel.append(min_vertex)\n\n        min_vertex = tid\n        for i in range(vertices_number):\n            if i not in rel and key[i] < key[min_vertex]:\n                min_vertex = i\n\n    if len(hop_path) == 0 or int(dest_vertex) not in hop_path:\n        return -1, -1\n    else:\n        next_hop = int(dest_vertex)\n        path_str = dest_vertex\n        while hop_path[next_hop][\"from\"] != int(from_vertex):\n            cost = hop_path[next_hop][\"cost\"]\n            next_hop = hop_path[next_hop][\"from\"]\n            path_str =  \"{} -({})-> {}\".format(str(next_hop), cost ,path_str)\n        path_str =  \"{} -({})-> {}\".format(str(hop_path[next_hop][\"from\"]), hop_path[next_hop][\"cost\"], path_str)\n\n        return key[tid], path_str\n\n\n\ndef find_shortest_router():\n    for s in start:\n        print(\"Forwarding Table for {}\".format(s))\n        print(\"{:>10} {:>10}       {}\".format(\"To\", \"Cost\", \"Path\"))\n        for d in dest:\n            c, n = dijkstra(s, d)\n            print(\"{:>10} {:>10}       {}\".format(d, c, n))\n\n\ndef main():\n    for i in range(1, vertices_number + 1):\n        if str(i) not in dest:\n            start.append(str(i))\n    find_shortest_router()\n\nif __name__ == '__main__':\n    main()\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的参考源程序", "Tag": "算法设计"}
{"Answer": "\n\n信息技术主题\n计算机程序设计主题图论\nA*搜尋演算法\n贝尔曼-福特算法\n宽度优先搜索\nFlood fill\nFloyd-Warshall算法\n最长路径问题", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的参见", "Tag": "算法设计"}
{"Answer": "参考文献[编辑]\n\n^ 1.00 1.01 1.02 1.03 1.04 1.05 1.06 1.07 1.08 1.09 1.10 1.11 1.12 1.13 1.14 1.15 1.16 1.17 1.18 1.19 1.20 1.21 1.22 1.23 1.24 1.25 1.26 1.27 1.28 1.29 Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms Second. MIT Press and McGraw–Hill. 2001: 595–601. ISBN 0-262-03293-7. \n\n^ 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 Rosen, Kenneth H. Discrete Mathematics and Its Applications. McGraw-Hill College. 2002. ISBN 0-07-293033-0. \n\n^ 有争议，见：Moshe Sniedovich. Dijkstra's algorithm revisited: the dynamic programming connexion. Control and Cybernetics. 2006, 35: 599–620  [2020-03-04]. （原始内容存档于2020-03-04）. 等\n\n^ 4.0 4.1 4.2 4.3 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. 25th Annual Symposium on Foundations of Computer Science. IEEE: 338–346. 1984. doi:10.1109/SFCS.1984.715934. \n\n^ Andrew V. Goldberg; Robert E. Tarjan. Expected performance of Dijkstra’s shortest path algorithm. NEC Research Institute Report. 1996年  [2019-12-12]. （原始内容存档于2021-11-22）.  引文使用过时参数coauthors (帮助)\n\n^ 乐阳、龚健雅. Dijkstra最短路径算法的一种高效率实现. 《科学技术创新》. 2020, (17): 75–77  [2020-06-30]. （原始内容存档于2021-02-13）. \n\n^ Richards, Hamilton. Edsger Wybe Dijkstra. A.M. Turing Award. Association for Computing Machinery.   [2017-10-16]. （原始内容存档于2017-10-21）. At the Mathematical Centre a major project was building the ARMAC computer. For its official inauguration in 1956, Dijkstra devised a program to solve a problem interesting to a nontechnical audience: Given a network of roads connecting cities, what is the shortest route between two designated cities? \n\n^ 8.0 8.1 8.2 8.3 8.4 Frana, Phil. An Interview with Edsger W. Dijkstra. Communications of the ACM. August 2010, 53 (8): 41–47. doi:10.1145/1787234.1787249. \n\n^ 9.00 9.01 9.02 9.03 9.04 9.05 9.06 9.07 9.08 9.09 9.10 Dijkstra, E. W. A note on two problems in connexion with graphs (PDF). Numerische Mathematik. 1959, 1: 269–271  [2020-01-27]. doi:10.1007/BF01386390. （原始内容存档 (PDF)于2020-01-23）. \n\n^ 10.0 10.1 Felner, Ariel. Position Paper: Dijkstra's Algorithm versus Uniform Cost Search or a Case Against Dijkstra's Algorithm. Proc. 4th Int'l Symp. on Combinatorial Search. 2011  [2020-02-18]. （原始内容存档于2020-02-18）. \n\n^ Mehlhorn, Kurt; Sanders, Peter. Chapter 10. Shortest Paths (PDF). Algorithms and Data Structures: The Basic Toolbox. Springer. 2008  [2020-02-14]. ISBN 978-3-540-77977-3. doi:10.1007/978-3-540-77978-0. （原始内容存档 (PDF)于2021-02-24）. \n\n^ 12.0 12.1 H. Ishikawa, S. Shimizu, Y. Arakawa, N. Yamanaka, K. Shiba. New Parallel Shortest Path Searching Algorithm based on Dynamically Reconfigurable Processor DAPDNA-2. IEEE. 13 August 2007  [2020-03-21]. doi:10.1109/ICC.2007.332. （原始内容存档于2020-12-18）. \n\n^ Yefim, Dinitz; Rotem, Itzhak. Hybrid Bellman–Ford–Dijkstra algorithm,. Journal of Discrete Algorithms. 2017, 42: 35–44. doi:10.1016/j.jda.2017.01.001. \n\n^ 14.0 14.1 14.2 Johnson, Donald B. Efficient algorithms for shortest paths in sparse networks. Journal of the ACM. 1977, 24 (1): 1–13. doi:10.1145/321992.321993. \n\n^ 15.0 15.1 15.2 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. Journal of the Association for Computing Machinery. 1987, 34 (3): 596–615  [2018-04-03]. doi:10.1145/28869.28874. （原始内容存档于2006-04-28）. \n\n^ Skiena, Steven. The Algorithm Design Manual (PDF) 2. Springer. 2008-07-26: 212  [2015-04-11]. ISBN 978-0073523408. doi:10.1007/978-1-84800-070-4. （原始内容 (PDF)存档于2015-06-09） （英语）. \n\n^ Leyzorek, M.; Gray, R. S.; Johnson, A. A.; Ladew, W. C.; Meaker, Jr., S. R.; Petry, R. M.; Seitz, R. N. Investigation of Model Techniques — First Annual Report — 6 June 1956 — 1 July 1957 — A Study of Model Techniques for Communication Systems. Cleveland, Ohio: Case Institute of Technology. 1957. \n\n^ 见Pollack, Maurice; Wiebenson, Walter. Solution of the Shortest-Route Problem—A Review. Oper. Res. March–April 1960, 8 (2): 224–230. doi:10.1287/opre.8.2.224.   Attributes Dijkstra's algorithm to Minty (\"private communication\") on p.225.\n\n^ Whiting, P. D.; Hillier, J. A. A Method for Finding the Shortest Route through a Road Network. Operational Research Quarterly. March–June 1960, 11 (1/2): 37–40. doi:10.1057/jors.1960.32. \n\n^ Johnson, Donald B. A priority queue in which initialization and queue operations take .mw-parser-output .serif{font-family:Times,serif}O(log log D) time. Mathematical Systems Theory. December 1981, 15 (1): 295–309. MR 0683047. doi:10.1007/BF01786986. \n\n^ Karlsson, Rolf G.; Poblete, Patricio V. An O(m log log D) algorithm for shortest paths. Discrete Applied Mathematics. 1983, 6 (1): 91–93. MR 0700028. doi:10.1016/0166-218X(83)90104-X. \n\n^ ARMAC. Unsung Heroes in Dutch Computing History. 2007. （原始内容存档于2013-11-13）. \n\n^ Sven Peyer; Dieter Rautenbach,Jens Vygen. A generalization of Dijkstra's shortest path algorithm with applications to VLSI routing. Journal of Discrete Algorithms. 2007, 7 (4): 377–390. doi:10.1016/j.jda.2007.08.003.  引文使用过时参数coauthors (帮助)\n\n^ Ismail Rakip Karas，Sait Demir. Dijkstra algorithm interactive training software development for network analysis applications in GIS (PDF). Energy Education Science and Technology Part A: Energy Science and Research. 2011, 28: 445–452  [2020-03-04]. （原始内容存档 (PDF)于2020-03-04）. \n\n^ Dean Djokic,David R. Maidment. Application of GIS Network Routines for Water Flow and Transport. Journal of Water Resources Planning and Management. 1993, 119 (2). doi:10.1061/(ASCE)0733-9496(1993)119:2(229). \n\n^ 江琦浩. 迪杰斯特拉算法在企业成本控制研究中的应用. 中国商贸. 2012, (03X)  [2020-12-24]. （原始内容存档于2021-02-13）. \n\n^ De Smith, Michael John; Goodchild, Michael F.; Longley, Paul, Geospatial Analysis: A Comprehensive Guide to Principles, Techniques and Software Tools, Troubadour Publishing Ltd: 344, 2007  [2020-03-04], ISBN 9781905886609, （原始内容存档于2017-02-27） .\n\n^ Hetland, Magnus Lie, Python Algorithms: Mastering Basic Algorithms in the Python Language, Apress: 214, 2010  [2020-03-04], ISBN 9781430232377, （原始内容存档于2017-02-28） .\n\n^ Tarjan, Robert Endre, Data Structures and Network Algorithms, CBMS_NSF Regional Conference Series in Applied Mathematics 44, Society for Industrial and Applied Mathematics: 75, 1983, The third classical minimum spanning tree algorithm was discovered by Jarník and rediscovered by Prim and Dikstra; it is commonly known as Prim's algorithm. \n\n^ Prim, R.C. Shortest connection networks and some generalizations (PDF). Bell System Technical Journal. 1957, 36 (6): 1389–1401  [18 July 2017]. Bibcode:1957BSTJ...36.1389P. doi:10.1002/j.1538-7305.1957.tb01515.x. （原始内容 (PDF)存档于18 July 2017）. \n\n^ V. Jarník: O jistém problému minimálním [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 6, 1930, pp. 57–63. (in Czech)\n\n^ Danielsson, Per-Erik; Lin, Qingfen. A Modified Fast Marching Method. Image Analysis. 24 June 2003: 1154–1161  [2020-03-25]. （原始内容存档于2021-02-13）.  引文使用过时参数coauthors (帮助)\n\n^ geeksforgeeks. Dijkstra’s Shortest Path Algorithm using priority_queue of STL. geeksforgeeks.   [2020-05-11]. （原始内容存档于2021-02-13）. \n\n扩展阅读[编辑]\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms second. MIT Press、S&P Global. 2001: 595–601. ISBN 0-262-03293-7. \nDial, Robert B. Algorithm 360: Shortest-path forest with topological ordering [H]. CACM. 1969, 12 (11): 632–633. doi:10.1145/363269.363610. \nZhan, F. Benjamin; Noon, Charles E. Shortest Path Algorithms: An Evaluation Using Real Road Networks. Transportation Science. February 1998, 32 (1): 65–73. doi:10.1287/trsc.32.1.65. \nKnuth, D.E. A Generalization of Dijkstra's Algorithm. Information Processing Letters. 1977, 6 (1): 1–5. doi:10.1016/0020-0190(77)90002-3. \nAhuja, Ravindra K.; Mehlhorn, Kurt; Orlin, James B.; Tarjan, Robert E. Faster Algorithms for the Shortest Path Problem. Journal of Association for Computing Machinery (ACM). April 1990, 37 (2): 213–223. doi:10.1145/77600.77615. \nRaman, Rajeev. Recent results on the single-source shortest paths problem. SIGACT News. 1997, 28 (2): 81–87. doi:10.1145/261342.261352. \nThorup, Mikkel. On RAM priority Queues. SIAM Journal on Computing. 2000, 30 (1): 86–109. doi:10.1137/S0097539795288246. \nThorup, Mikkel. Undirected single-source shortest paths with positive integer weights in linear time. journal of the ACM. 1999, 46 (3): 362–394  [2017-11-01]. doi:10.1145/316542.316548. （原始内容存档于2017-09-21）. \nZHANG Lin-guang,FANG Jin-yun,SHEN Pai-wei. An Improved Dijkstra Algorithm Based on Pairing Heap. Journal of Image and Graphics. 2007-05. \n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的參考", "Tag": "算法设计"}
{"Answer": "\n\n^ 1.00 1.01 1.02 1.03 1.04 1.05 1.06 1.07 1.08 1.09 1.10 1.11 1.12 1.13 1.14 1.15 1.16 1.17 1.18 1.19 1.20 1.21 1.22 1.23 1.24 1.25 1.26 1.27 1.28 1.29 Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms Second. MIT Press and McGraw–Hill. 2001: 595–601. ISBN 0-262-03293-7. \n\n^ 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 Rosen, Kenneth H. Discrete Mathematics and Its Applications. McGraw-Hill College. 2002. ISBN 0-07-293033-0. \n\n^ 有争议，见：Moshe Sniedovich. Dijkstra's algorithm revisited: the dynamic programming connexion. Control and Cybernetics. 2006, 35: 599–620  [2020-03-04]. （原始内容存档于2020-03-04）. 等\n\n^ 4.0 4.1 4.2 4.3 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. 25th Annual Symposium on Foundations of Computer Science. IEEE: 338–346. 1984. doi:10.1109/SFCS.1984.715934. \n\n^ Andrew V. Goldberg; Robert E. Tarjan. Expected performance of Dijkstra’s shortest path algorithm. NEC Research Institute Report. 1996年  [2019-12-12]. （原始内容存档于2021-11-22）.  引文使用过时参数coauthors (帮助)\n\n^ 乐阳、龚健雅. Dijkstra最短路径算法的一种高效率实现. 《科学技术创新》. 2020, (17): 75–77  [2020-06-30]. （原始内容存档于2021-02-13）. \n\n^ Richards, Hamilton. Edsger Wybe Dijkstra. A.M. Turing Award. Association for Computing Machinery.   [2017-10-16]. （原始内容存档于2017-10-21）. At the Mathematical Centre a major project was building the ARMAC computer. For its official inauguration in 1956, Dijkstra devised a program to solve a problem interesting to a nontechnical audience: Given a network of roads connecting cities, what is the shortest route between two designated cities? \n\n^ 8.0 8.1 8.2 8.3 8.4 Frana, Phil. An Interview with Edsger W. Dijkstra. Communications of the ACM. August 2010, 53 (8): 41–47. doi:10.1145/1787234.1787249. \n\n^ 9.00 9.01 9.02 9.03 9.04 9.05 9.06 9.07 9.08 9.09 9.10 Dijkstra, E. W. A note on two problems in connexion with graphs (PDF). Numerische Mathematik. 1959, 1: 269–271  [2020-01-27]. doi:10.1007/BF01386390. （原始内容存档 (PDF)于2020-01-23）. \n\n^ 10.0 10.1 Felner, Ariel. Position Paper: Dijkstra's Algorithm versus Uniform Cost Search or a Case Against Dijkstra's Algorithm. Proc. 4th Int'l Symp. on Combinatorial Search. 2011  [2020-02-18]. （原始内容存档于2020-02-18）. \n\n^ Mehlhorn, Kurt; Sanders, Peter. Chapter 10. Shortest Paths (PDF). Algorithms and Data Structures: The Basic Toolbox. Springer. 2008  [2020-02-14]. ISBN 978-3-540-77977-3. doi:10.1007/978-3-540-77978-0. （原始内容存档 (PDF)于2021-02-24）. \n\n^ 12.0 12.1 H. Ishikawa, S. Shimizu, Y. Arakawa, N. Yamanaka, K. Shiba. New Parallel Shortest Path Searching Algorithm based on Dynamically Reconfigurable Processor DAPDNA-2. IEEE. 13 August 2007  [2020-03-21]. doi:10.1109/ICC.2007.332. （原始内容存档于2020-12-18）. \n\n^ Yefim, Dinitz; Rotem, Itzhak. Hybrid Bellman–Ford–Dijkstra algorithm,. Journal of Discrete Algorithms. 2017, 42: 35–44. doi:10.1016/j.jda.2017.01.001. \n\n^ 14.0 14.1 14.2 Johnson, Donald B. Efficient algorithms for shortest paths in sparse networks. Journal of the ACM. 1977, 24 (1): 1–13. doi:10.1145/321992.321993. \n\n^ 15.0 15.1 15.2 Fredman, Michael Lawrence; Tarjan, Robert E. Fibonacci heaps and their uses in improved network optimization algorithms. Journal of the Association for Computing Machinery. 1987, 34 (3): 596–615  [2018-04-03]. doi:10.1145/28869.28874. （原始内容存档于2006-04-28）. \n\n^ Skiena, Steven. The Algorithm Design Manual (PDF) 2. Springer. 2008-07-26: 212  [2015-04-11]. ISBN 978-0073523408. doi:10.1007/978-1-84800-070-4. （原始内容 (PDF)存档于2015-06-09） （英语）. \n\n^ Leyzorek, M.; Gray, R. S.; Johnson, A. A.; Ladew, W. C.; Meaker, Jr., S. R.; Petry, R. M.; Seitz, R. N. Investigation of Model Techniques — First Annual Report — 6 June 1956 — 1 July 1957 — A Study of Model Techniques for Communication Systems. Cleveland, Ohio: Case Institute of Technology. 1957. \n\n^ 见Pollack, Maurice; Wiebenson, Walter. Solution of the Shortest-Route Problem—A Review. Oper. Res. March–April 1960, 8 (2): 224–230. doi:10.1287/opre.8.2.224.   Attributes Dijkstra's algorithm to Minty (\"private communication\") on p.225.\n\n^ Whiting, P. D.; Hillier, J. A. A Method for Finding the Shortest Route through a Road Network. Operational Research Quarterly. March–June 1960, 11 (1/2): 37–40. doi:10.1057/jors.1960.32. \n\n^ Johnson, Donald B. A priority queue in which initialization and queue operations take .mw-parser-output .serif{font-family:Times,serif}O(log log D) time. Mathematical Systems Theory. December 1981, 15 (1): 295–309. MR 0683047. doi:10.1007/BF01786986. \n\n^ Karlsson, Rolf G.; Poblete, Patricio V. An O(m log log D) algorithm for shortest paths. Discrete Applied Mathematics. 1983, 6 (1): 91–93. MR 0700028. doi:10.1016/0166-218X(83)90104-X. \n\n^ ARMAC. Unsung Heroes in Dutch Computing History. 2007. （原始内容存档于2013-11-13）. \n\n^ Sven Peyer; Dieter Rautenbach,Jens Vygen. A generalization of Dijkstra's shortest path algorithm with applications to VLSI routing. Journal of Discrete Algorithms. 2007, 7 (4): 377–390. doi:10.1016/j.jda.2007.08.003.  引文使用过时参数coauthors (帮助)\n\n^ Ismail Rakip Karas，Sait Demir. Dijkstra algorithm interactive training software development for network analysis applications in GIS (PDF). Energy Education Science and Technology Part A: Energy Science and Research. 2011, 28: 445–452  [2020-03-04]. （原始内容存档 (PDF)于2020-03-04）. \n\n^ Dean Djokic,David R. Maidment. Application of GIS Network Routines for Water Flow and Transport. Journal of Water Resources Planning and Management. 1993, 119 (2). doi:10.1061/(ASCE)0733-9496(1993)119:2(229). \n\n^ 江琦浩. 迪杰斯特拉算法在企业成本控制研究中的应用. 中国商贸. 2012, (03X)  [2020-12-24]. （原始内容存档于2021-02-13）. \n\n^ De Smith, Michael John; Goodchild, Michael F.; Longley, Paul, Geospatial Analysis: A Comprehensive Guide to Principles, Techniques and Software Tools, Troubadour Publishing Ltd: 344, 2007  [2020-03-04], ISBN 9781905886609, （原始内容存档于2017-02-27） .\n\n^ Hetland, Magnus Lie, Python Algorithms: Mastering Basic Algorithms in the Python Language, Apress: 214, 2010  [2020-03-04], ISBN 9781430232377, （原始内容存档于2017-02-28） .\n\n^ Tarjan, Robert Endre, Data Structures and Network Algorithms, CBMS_NSF Regional Conference Series in Applied Mathematics 44, Society for Industrial and Applied Mathematics: 75, 1983, The third classical minimum spanning tree algorithm was discovered by Jarník and rediscovered by Prim and Dikstra; it is commonly known as Prim's algorithm. \n\n^ Prim, R.C. Shortest connection networks and some generalizations (PDF). Bell System Technical Journal. 1957, 36 (6): 1389–1401  [18 July 2017]. Bibcode:1957BSTJ...36.1389P. doi:10.1002/j.1538-7305.1957.tb01515.x. （原始内容 (PDF)存档于18 July 2017）. \n\n^ V. Jarník: O jistém problému minimálním [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 6, 1930, pp. 57–63. (in Czech)\n\n^ Danielsson, Per-Erik; Lin, Qingfen. A Modified Fast Marching Method. Image Analysis. 24 June 2003: 1154–1161  [2020-03-25]. （原始内容存档于2021-02-13）.  引文使用过时参数coauthors (帮助)\n\n^ geeksforgeeks. Dijkstra’s Shortest Path Algorithm using priority_queue of STL. geeksforgeeks.   [2020-05-11]. （原始内容存档于2021-02-13）. \n\n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的參考的参考文献", "Tag": "算法设计"}
{"Answer": "\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford. Section 24.3: Dijkstra's algorithm. Introduction to Algorithms second. MIT Press、S&P Global. 2001: 595–601. ISBN 0-262-03293-7. \nDial, Robert B. Algorithm 360: Shortest-path forest with topological ordering [H]. CACM. 1969, 12 (11): 632–633. doi:10.1145/363269.363610. \nZhan, F. Benjamin; Noon, Charles E. Shortest Path Algorithms: An Evaluation Using Real Road Networks. Transportation Science. February 1998, 32 (1): 65–73. doi:10.1287/trsc.32.1.65. \nKnuth, D.E. A Generalization of Dijkstra's Algorithm. Information Processing Letters. 1977, 6 (1): 1–5. doi:10.1016/0020-0190(77)90002-3. \nAhuja, Ravindra K.; Mehlhorn, Kurt; Orlin, James B.; Tarjan, Robert E. Faster Algorithms for the Shortest Path Problem. Journal of Association for Computing Machinery (ACM). April 1990, 37 (2): 213–223. doi:10.1145/77600.77615. \nRaman, Rajeev. Recent results on the single-source shortest paths problem. SIGACT News. 1997, 28 (2): 81–87. doi:10.1145/261342.261352. \nThorup, Mikkel. On RAM priority Queues. SIAM Journal on Computing. 2000, 30 (1): 86–109. doi:10.1137/S0097539795288246. \nThorup, Mikkel. Undirected single-source shortest paths with positive integer weights in linear time. journal of the ACM. 1999, 46 (3): 362–394  [2017-11-01]. doi:10.1145/316542.316548. （原始内容存档于2017-09-21）. \nZHANG Lin-guang,FANG Jin-yun,SHEN Pai-wei. An Improved Dijkstra Algorithm Based on Pairing Heap. Journal of Image and Graphics. 2007-05. \n", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的參考的扩展阅读", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "戴克斯特拉算法", "Question": "什么是戴克斯特拉算法的外部連結", "Tag": "算法设计"}
