{"Answer": "深度优先搜索算法（英語：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。[1]（p. 603）这种算法不会根据图的结构等信息调整执行策略[來源請求]。\n深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的拓扑排序表[1]（p. 612），利用拓扑排序表可以方便的解决很多相关的图论问题，如无权最长路径问题等等。\n因发明“深度优先搜索算法”，約翰·霍普克洛夫特与罗伯特·塔扬在1986年共同获得计算机领域的最高奖：图灵奖。[2]\n", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索", "Tag": "算法设计"}
{"Answer": "首先将根节点放入stack中。\n从stack中取出第一个节点，并检验它是否为目标。\n如果找到目标，则结束搜寻并回传结果。\n否则将它某一个尚未检验过的直接子节点加入stack中。\n重复步骤2。\n如果不存在未检测过的直接子节点。\n将上一级节点加入stack中。\n重复步骤2。\n重复步骤4。\n若stack为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的演算方法", "Tag": "算法设计"}
{"Answer": "定义一个结构体来表达一個二叉树的节点的结构：\nstruct Node {\n    int self;     // 数据\n    Node *left;   // 左孩子\n    Node *right;  // 右孩子\n};\n那么我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：\n", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的C++的實作", "Tag": "算法设计"}
{"Answer": "\n\n^ 1.0 1.1 Introduction to Algorithms [算法导论]. ISBN 978-7-111-40701-0. \n\n^ Robert E Tarjan - A.M. Turing Award Winner.   [2017-10-29]. （原始内容存档于2017-10-30） （英语）. \n\n", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的参考文献", "Tag": "算法设计"}
{"Answer": "广度优先搜索", "Konwledge_Point": "深度优先搜索", "Question": "什么是深度优先搜索的參見", "Tag": "算法设计"}
