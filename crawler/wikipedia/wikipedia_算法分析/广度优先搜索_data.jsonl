{"Answer": "广度优先搜索算法（英語：Breadth-first search，縮寫：BFS），又譯作寬度優先搜索，或橫向優先搜索，是一種圖形搜索演算法。簡單的說，BFS是從根節點開始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索", "Tag": "算法设计"}
{"Answer": "BFS是一種暴力搜索算法，目的是系統地展開並檢查圖中的所有節點，以找尋結果。換句話說，它並不考慮結果的可能位址，徹底地搜索整張圖，直到找到結果為止。BFS並不使用經驗法則演算法。\n從演算法的觀點，所有因為展開節點而得到的子節點都會被加進一個先進先出的队列中。一般的實作裡，其鄰居節點尚未被檢驗過的節點會被放置在一個被稱為 open 的容器中（例如佇列或是链表），而被檢驗過的節點則被放置在被稱為 closed 的容器中。（open-closed表）\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的作法", "Tag": "算法设计"}
{"Answer": "首先將根節點放入队列中。\n從队列中取出第一個節點，並檢驗它是否為目標。\n如果找到目標，則結束搜尋並回傳結果。\n否則將它所有尚未檢驗過的直接子節點加入队列中。\n若队列為空，表示整張圖都檢查過了——亦即圖中沒有欲搜尋的目標。結束搜尋並回傳「找不到目標」。\n重複步驟2。 s为初始点\n \n  \n    \n      \n        R\n        :=\n        {\n        s\n        }\n        ,\n        Q\n        :=\n        {\n        s\n        }\n        ,\n        T\n        =\n        ∅\n      \n    \n    {\\displaystyle R:=\\{s\\},Q:=\\{s\\},T=\\emptyset }\n  \n\n while \n  \n    \n      \n        Q\n        ≠\n        ∅\n      \n    \n    {\\displaystyle Q\\neq \\emptyset }\n  \n\n     從Q中選一點 v /* 若改選最後插入進Q的點，則為深度遍歷,可以说後進先出。*/\n     if \n  \n    \n      \n        ∃\n        w\n        ∈\n        N\n        (\n        v\n        )\n        ∖\n        R\n      \n    \n    {\\displaystyle \\exists w\\in N(v)\\setminus R}\n  \n then    /* N(v):v的邻接点 */\n         \n  \n    \n      \n        Q\n        :=\n        Q\n        ∪\n        {\n        w\n        }\n      \n    \n    {\\displaystyle Q:=Q\\cup \\{w\\}}\n  \n\n         \n  \n    \n      \n        R\n        :=\n        R\n        ∪\n        {\n        w\n        }\n      \n    \n    {\\displaystyle R:=R\\cup \\{w\\}}\n  \n\n         \n  \n    \n      \n        T\n        :=\n        T\n        ∪\n        {\n        v\n        w\n        }\n      \n    \n    {\\displaystyle T:=T\\cup \\{vw\\}}\n  \n\n     else \n  \n    \n      \n        Q\n        :=\n        Q\n        ∖\n        {\n        w\n        }\n      \n    \n    {\\displaystyle Q:=Q\\setminus \\{w\\}}\n  \n\n return H=(R,T)\nC 的实例[编辑]/*\n    ADDQ (Q, p) - p PUSH 入 Q\n    DELQ (Q) - POP Q 并返回 Q 顶\n    FIRSTADJ (G,v) - v 的第一个邻接点，找不到则返回 -1\n    NEXTADJ (G,v) - v 的下一个邻接点，找不到则返回 -1\n    VISIT (v) - 访问 v\n    visited [] - 是否已访问\n*/\n\n// 广度优先搜索算法\nvoid BFS(VLink G[], int v) {\n    int w;\n    VISIT(v); // 访问 v 并入队\n    visited[v] = 1;\n    ADDQ(Q, v);\n    // 对队列 Q 的各元素\n    while (!EMPTYQ(Q)) {\n        v = DELQ(Q);\n        w = FIRSTADJ(G, v);\n        do {\n            // 进行访问和入队\n            if (visited[w] == 0) {\n                VISIT(w);\n                ADDQ(Q, w);\n                visited[w] = 1;\n            }\n        } while ((w = NEXTADJ(G, v)) != -1);\n    }\n}\n\n// 对图G=(V,E)进行广度优先搜索的主算法\nvoid TRAVEL_BFS(VLink G[], bool visited[], int n) {\n    // 清零标记数组\n    for (int i = 0; i < n; ++i)\n        visited[i] = 0;\n    for (int i = 0; i < n; ++i)\n        if (visited[i] == 0)\n            BFS(G, i);\n}\nC++ 的實作[编辑](這個例子僅針對Binary Tree)\n定义一个结构体来表达一个節點的结构：\nstruct node {\n    int self;     //数据\n    node *left;   //左节点\n    node *right;  //右节点\n};\n那么，我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：\n   A\nB     C\nA是第一个访问的，然后顺序是B和C；然后再是B的子节点，C的子节点。那么我们怎么来保证这个顺序呢？\n这里就应该用queue資料結構，因为queue採用先进先出( first-in-first-out )的顺序。\n使用C++的STL函式庫，下面的程序能帮助理解：\n std::queue<node *> visited, unvisited;\nnode nodes[9];\nnode *current;\n\nunvisited.push(&nodes[0]); // 先把root放入unvisited queue\n\nwhile (!unvisited.empty()) { // 只有unvisited不空\n    current = (unvisited.front()); // 目前應該檢驗的\n    if (current->left != NULL)\n        unvisited.push(current->left); // 把左邊放入queue中\n    if (current->right != NULL) // 右邊壓入。因為QUEUE是一個先進先出的結構构，所以即使後面再壓其他东西，依然會先訪問這個。\n        unvisited.push(current->right);\n    visited.push(current);\n    cout << current->self << endl;\n    unvisited.pop();\n}\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的實作方法", "Tag": "算法设计"}
{"Answer": "/*\n    ADDQ (Q, p) - p PUSH 入 Q\n    DELQ (Q) - POP Q 并返回 Q 顶\n    FIRSTADJ (G,v) - v 的第一个邻接点，找不到则返回 -1\n    NEXTADJ (G,v) - v 的下一个邻接点，找不到则返回 -1\n    VISIT (v) - 访问 v\n    visited [] - 是否已访问\n*/\n\n// 广度优先搜索算法\nvoid BFS(VLink G[], int v) {\n    int w;\n    VISIT(v); // 访问 v 并入队\n    visited[v] = 1;\n    ADDQ(Q, v);\n    // 对队列 Q 的各元素\n    while (!EMPTYQ(Q)) {\n        v = DELQ(Q);\n        w = FIRSTADJ(G, v);\n        do {\n            // 进行访问和入队\n            if (visited[w] == 0) {\n                VISIT(w);\n                ADDQ(Q, w);\n                visited[w] = 1;\n            }\n        } while ((w = NEXTADJ(G, v)) != -1);\n    }\n}\n\n// 对图G=(V,E)进行广度优先搜索的主算法\nvoid TRAVEL_BFS(VLink G[], bool visited[], int n) {\n    // 清零标记数组\n    for (int i = 0; i < n; ++i)\n        visited[i] = 0;\n    for (int i = 0; i < n; ++i)\n        if (visited[i] == 0)\n            BFS(G, i);\n}\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的C 的实例", "Tag": "算法设计"}
{"Answer": "(這個例子僅針對Binary Tree)\n定义一个结构体来表达一个節點的结构：\nstruct node {\n    int self;     //数据\n    node *left;   //左节点\n    node *right;  //右节点\n};\n那么，我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。例如：\n   A\nB     C\nA是第一个访问的，然后顺序是B和C；然后再是B的子节点，C的子节点。那么我们怎么来保证这个顺序呢？\n这里就应该用queue資料結構，因为queue採用先进先出( first-in-first-out )的顺序。\n使用C++的STL函式庫，下面的程序能帮助理解：\n std::queue<node *> visited, unvisited;\nnode nodes[9];\nnode *current;\n\nunvisited.push(&nodes[0]); // 先把root放入unvisited queue\n\nwhile (!unvisited.empty()) { // 只有unvisited不空\n    current = (unvisited.front()); // 目前應該檢驗的\n    if (current->left != NULL)\n        unvisited.push(current->left); // 把左邊放入queue中\n    if (current->right != NULL) // 右邊壓入。因為QUEUE是一個先進先出的結構构，所以即使後面再壓其他东西，依然會先訪問這個。\n        unvisited.push(current->right);\n    visited.push(current);\n    cout << current->self << endl;\n    unvisited.pop();\n}\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的C++ 的實作", "Tag": "算法设计"}
{"Answer": "空間複雜度[编辑]因為所有節點都必須被儲存，因此BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。註：另一種說法稱BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          B\n          \n            M\n          \n        \n        )\n      \n    \n    {\\displaystyle O(B^{M})}\n  \n，其中B是最大分支係數，而M是樹的最長路徑長度。由於對空間的大量需求，因此BFS並不適合解非常大的問題，對於類似的問題，應用IDDFS以達節省空間的效果。\n時間複雜度[编辑]最差情形下，BFS必須尋找所有到可能節點的所有路徑，因此其時間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。\n完全性[编辑]廣度優先搜索演算法具有完全性。這意指無論圖形的種類如何，只要目標存在，則BFS一定會找到。然而，若目標不存在，且圖為無限大，則BFS將不收斂（不會結束）。\n最佳解[编辑]若所有邊的長度相等，廣度優先搜索演算法是最佳解——亦即它找到的第一個解，距離根節點的邊數目一定最少；但對一般的圖來說，BFS並不一定回傳最佳解。這是因為當圖形為加權圖（亦即各邊長度不同）時，BFS仍然回傳從根節點開始，經過邊數目最少的解；而這個解距離根節點的距離不一定最短。這個問題可以使用考慮各邊權值，BFS的改良演算法成本一致搜尋法來解決。然而，若非加權圖形，則所有邊的長度相等，BFS就能找到最近的最佳解。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性", "Tag": "算法设计"}
{"Answer": "因為所有節點都必須被儲存，因此BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。註：另一種說法稱BFS的空間複雜度為\n  \n    \n      \n        O\n        (\n        \n          B\n          \n            M\n          \n        \n        )\n      \n    \n    {\\displaystyle O(B^{M})}\n  \n，其中B是最大分支係數，而M是樹的最長路徑長度。由於對空間的大量需求，因此BFS並不適合解非常大的問題，對於類似的問題，應用IDDFS以達節省空間的效果。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的空間複雜度", "Tag": "算法设计"}
{"Answer": "最差情形下，BFS必須尋找所有到可能節點的所有路徑，因此其時間複雜度為\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|+|E|)}\n  \n，其中\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n是節點的數目，而\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n是圖中邊的數目。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的時間複雜度", "Tag": "算法设计"}
{"Answer": "廣度優先搜索演算法具有完全性。這意指無論圖形的種類如何，只要目標存在，則BFS一定會找到。然而，若目標不存在，且圖為無限大，則BFS將不收斂（不會結束）。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的完全性", "Tag": "算法设计"}
{"Answer": "若所有邊的長度相等，廣度優先搜索演算法是最佳解——亦即它找到的第一個解，距離根節點的邊數目一定最少；但對一般的圖來說，BFS並不一定回傳最佳解。這是因為當圖形為加權圖（亦即各邊長度不同）時，BFS仍然回傳從根節點開始，經過邊數目最少的解；而這個解距離根節點的距離不一定最短。這個問題可以使用考慮各邊權值，BFS的改良演算法成本一致搜尋法來解決。然而，若非加權圖形，則所有邊的長度相等，BFS就能找到最近的最佳解。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的特性的最佳解", "Tag": "算法设计"}
{"Answer": "廣度優先搜索演算法能用來解決圖論中的許多問題，例如：\n尋找圖中所有連接元件（Connected Component）。一個連接元件是圖中的最大相連子圖。\n尋找連接元件中的所有節點。\n尋找非加權圖中任兩點的最短路徑。\n測試一圖是否為二分圖。\n（Reverse）Cuthill–McKee演算法尋找連接元件[编辑]由起點開始，執行廣度優先搜索演算法後所經過的所有節點，即為包含起點的一個連接元件。\n測試是否二分圖[编辑]BFS可以用以測試二分圖。從任一節點開始搜尋，並在搜尋過程中給節點不同的標籤。例如，給開始點標籤0，開始點的所有鄰居標籤1，開始點所有鄰居的鄰居標籤0……以此類推。若在搜尋過程中，任一節點有跟其相同標籤的鄰居，則此圖就不是二分圖。若搜尋結束時這種情形未發生，則此圖為一二分圖。\n應用於電腦遊戲中平面網格[编辑]BFS可用來解決電腦遊戲（例如即時策略遊戲）中找尋路徑的問題。在這個應用中，使用平面網格來代替圖形，而一個格子即是圖中的一個節點。所有節點都與它的鄰居（上、下、左、右、左上、右上、左下、右下）相接。\n值得一提的是，當這樣使用BFS演算法時，首先要先檢驗上、下、左、右的鄰居節點，再檢驗左上、右上、左下、右下的鄰居節點。這是因為BFS趨向於先尋找斜向鄰居節點，而不是四方的鄰居節點，因此找到的路徑將不正確。BFS應該先尋找四方鄰居節點，接著才尋找斜向鄰居節點1。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用", "Tag": "算法设计"}
{"Answer": "由起點開始，執行廣度優先搜索演算法後所經過的所有節點，即為包含起點的一個連接元件。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用的尋找連接元件", "Tag": "算法设计"}
{"Answer": "BFS可以用以測試二分圖。從任一節點開始搜尋，並在搜尋過程中給節點不同的標籤。例如，給開始點標籤0，開始點的所有鄰居標籤1，開始點所有鄰居的鄰居標籤0……以此類推。若在搜尋過程中，任一節點有跟其相同標籤的鄰居，則此圖就不是二分圖。若搜尋結束時這種情形未發生，則此圖為一二分圖。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用的測試是否二分圖", "Tag": "算法设计"}
{"Answer": "BFS可用來解決電腦遊戲（例如即時策略遊戲）中找尋路徑的問題。在這個應用中，使用平面網格來代替圖形，而一個格子即是圖中的一個節點。所有節點都與它的鄰居（上、下、左、右、左上、右上、左下、右下）相接。\n值得一提的是，當這樣使用BFS演算法時，首先要先檢驗上、下、左、右的鄰居節點，再檢驗左上、右上、左下、右下的鄰居節點。這是因為BFS趨向於先尋找斜向鄰居節點，而不是四方的鄰居節點，因此找到的路徑將不正確。BFS應該先尋找四方鄰居節點，接著才尋找斜向鄰居節點1。\n", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的應用的應用於電腦遊戲中平面網格", "Tag": "算法设计"}
{"Answer": "先验算法\n深度優先搜索", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的參見", "Tag": "算法设计"}
{"Answer": "Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein],  Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 22.2: Breadth-first search, pp. 531–539.", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的參考資料", "Tag": "算法设计"}
{"Answer": "（英文） 資料結構與演算法字典：廣度優先搜索 （页面存档备份，存于互联网档案馆）\n（英文） C++ Boost Graph函式庫：廣度優先搜索 （页面存档备份，存于互联网档案馆）\n（英文） 深度與廣度優先搜索：解釋與原始碼 （页面存档备份，存于互联网档案馆）\n（英文） BFS 動畫說明 （页面存档备份，存于互联网档案馆）", "Konwledge_Point": "广度优先搜索", "Question": "什么是广度优先搜索的外部連結", "Tag": "算法设计"}
