{"Answer": "归并排序（英語：Merge sort，或mergesort），是建立在归并操作上的一种有效的排序算法，效率為\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n（大O符号）。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序", "Tag": "算法设计"}
{"Answer": "采用分治法:\n分割：递归地把当前序列平均分割成两半。\n整合：在保持元素顺序的同时将上一步得到的子序列整合到一起（归并）。", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的概述", "Tag": "算法设计"}
{"Answer": "归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。\n递归法（Top-down）[编辑]申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n设定两个指针，最初位置分别为两个已经排序序列的起始位置\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n重复步骤3直到某一指针到达序列尾\n将另一序列剩下的所有元素直接复制到合并序列尾迭代法（Bottom-up）[编辑]原理如下（假设序列共有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n个元素）：\n将序列每相邻两个数字进行归并操作，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        2\n        )\n      \n    \n    {\\displaystyle ceil(n/2)}\n  \n个序列，排序后每个序列包含两/一个元素\n若此时序列数不是1个则将上述序列再次归并，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        4\n        )\n      \n    \n    {\\displaystyle ceil(n/4)}\n  \n个序列，每个序列包含四/三个元素\n重复步骤2，直到所有元素排序完毕，即序列数为1", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的归并操作", "Tag": "算法设计"}
{"Answer": "申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n设定两个指针，最初位置分别为两个已经排序序列的起始位置\n比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n重复步骤3直到某一指针到达序列尾\n将另一序列剩下的所有元素直接复制到合并序列尾", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的归并操作的递归法（Top-down）", "Tag": "算法设计"}
{"Answer": "原理如下（假设序列共有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n个元素）：\n将序列每相邻两个数字进行归并操作，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        2\n        )\n      \n    \n    {\\displaystyle ceil(n/2)}\n  \n个序列，排序后每个序列包含两/一个元素\n若此时序列数不是1个则将上述序列再次归并，形成\n  \n    \n      \n        c\n        e\n        i\n        l\n        (\n        n\n        \n          /\n        \n        4\n        )\n      \n    \n    {\\displaystyle ceil(n/4)}\n  \n个序列，每个序列包含四/三个元素\n重复步骤2，直到所有元素排序完毕，即序列数为1", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的归并操作的迭代法（Bottom-up）", "Tag": "算法设计"}
{"Answer": "C語言[编辑]迭代版：\nint min(int x, int y) {\n    return x < y ? x : y;\n}\nvoid merge_sort(int arr[], int len) {\n    int *a = arr;\n    int *b = (int *) malloc(len * sizeof(int));\n    int seg, start;\n    for (seg = 1; seg < len; seg += seg) {\n        for (start = 0; start < len; start += seg * 2) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        int *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        int i;\n        for (i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    free(b);\n}\n遞歸版：\n// 分治-治\nvoid mergeSort_conquer(int* array, int left, int mid, int right, int* temp) {\n    // [left, mid]和[mid+1, right]两个有序数组\n    int i = left;\n    int j = mid + 1;\n    int index = 0;\n    while (i <= mid && j <= right) {\n        if (array[i] < array[j]) {\n            temp[index++] = array[i++];\n        } else {\n            temp[index++] = array[j++];\n        }\n    }\n    // 剩余元素直接放入temp\n    while (i <= mid) {\n        temp[index++] = array[i++];\n    }\n    while (j <= right) {\n        temp[index++] = array[j++];\n    }\n    // 放回原数组\n    index = 0;\n    while (left <= right) {\n        array[left++] = temp[index++];\n    }\n}\n\n// 分治-分\nvoid mergeSort_divide(int* array, int left, int right, int* temp) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        // 左边归并排序\n        mergeSort_divide(array, left, mid, temp);\n        // 右边归并排序\n        mergeSort_divide(array, mid + 1, right, temp);\n        // 合并两个有序序列\n        mergeSort_conquer(array, left, mid, right, temp);\n    }\n}\n\nvoid mergeSort(int* array, int size) {\n    int* temp = (int*)malloc(sizeof(int) * size);\n    mergeSort_divide(array, 0, size - 1, temp);\n}\nC++[编辑]迭代版：\ntemplate<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"(<)的運算子功能\nvoid merge_sort(T arr[], int len) {\n    T *a = arr;\n    T *b = new T[len];\n    for (int seg = 1; seg < len; seg += seg) {\n        for (int start = 0; start < len; start += seg + seg) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        T *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        for (int i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    delete[] b;\n}\n遞歸版：\nvoid Merge(vector<int> &Array, int front, int mid, int end) {\n    // preconditions:\n    // Array[front...mid] is sorted\n    // Array[mid+1 ... end] is sorted\n    // Copy Array[front ... mid] to LeftSubArray\n    // Copy Array[mid+1 ... end] to RightSubArray\n    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);\n    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);\n    int idxLeft = 0, idxRight = 0;\n    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());\n    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());\n    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]\n    for (int i = front; i <= end; i++) {\n        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) {\n            Array[i] = LeftSubArray[idxLeft];\n            idxLeft++;\n        } else {\n            Array[i] = RightSubArray[idxRight];\n            idxRight++;\n        }\n    }\n}\n\nvoid MergeSort(vector<int> &Array, int front, int end) {\n    if (front >= end)\n        return;\n    int mid = front + (end - front) / 2;\n    MergeSort(Array, front, mid);\n    MergeSort(Array, mid + 1, end);\n    Merge(Array, front, mid, end);\n}\n[1]\nC#[编辑]public static List<int> sort(List<int> lst) {\n    if (lst.Count <= 1)\n        return lst;\n    int mid = lst.Count / 2;\n    List<int> left = new List<int>();  // 定义左侧List\n    List<int> right = new List<int>(); // 定义右侧List\n    // 以下兩個循環把 lst 分為左右兩個 List\n    for (int i = 0; i < mid; i++)\n        left.Add(lst[i]);\n    for (int j = mid; j < lst.Count; j++)\n        right.Add(lst[j]);\n    left = sort(left);\n    right = sort(right);\n    return merge(left, right);\n}\n/// <summary>\n/// 合併兩個已經排好序的List\n/// </summary>\n/// <param name=\"left\">左側List</param>\n/// <param name=\"right\">右側List</param>\n/// <returns></returns>\nstatic List<int> merge(List<int> left, List<int> right) {\n    List<int> temp = new List<int>();\n    while (left.Count > 0 && right.Count > 0) {\n        if (left[0] <= right[0]) {\n            temp.Add(left[0]);\n            left.RemoveAt(0);\n        } else {\n            temp.Add(right[0]);\n            right.RemoveAt(0);\n        }\n    }\n    if (left.Count > 0) {\n        for (int i = 0; i < left.Count; i++)\n            temp.Add(left[i]);\n    }\n    if (right.Count > 0) {\n        for (int i = 0; i < right.Count; i++)\n            temp.Add(right[i]);\n    }\n    return temp;\n}\nRuby[编辑]def merge list\n  return list if list.size < 2\n\n  pivot = list.size / 2\n\n  # Merge\n  lambda { |left, right|\n    final = []\n    until left.empty? or right.empty?\n      final << if left.first < right.first; left.shift else right.shift end\n    end\n    final + left + right\n  }.call merge(list[0...pivot]), merge(list[pivot..-1])\nend\nJava[编辑]遞歸版：\nstatic void merge_sort_recursive(int[] arr, int[] result, int start, int end) {\n\tif (start >= end)\n\t\treturn;\n\tint len = end - start, mid = (len >> 1) + start;\n\tint start1 = start, end1 = mid;\n\tint start2 = mid + 1, end2 = end;\n\tmerge_sort_recursive(arr, result, start1, end1);\n\tmerge_sort_recursive(arr, result, start2, end2);\n\tint k = start;\n\twhile (start1 <= end1 && start2 <= end2)\n\t\tresult[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];\n\twhile (start1 <= end1)\n\t\tresult[k++] = arr[start1++];\n\twhile (start2 <= end2)\n\t\tresult[k++] = arr[start2++];\n\tfor (k = start; k <= end; k++)\n\t\tarr[k] = result[k];\n}\npublic static void merge_sort(int[] arr) {\n\tint len = arr.length;\n\tint[] result = new int[len];\n\tmerge_sort_recursive(arr, result, 0, len - 1);\n}\n迭代版：\npublic static void merge_sort(int[] arr) {\n\tint[] orderedArr = new int[arr.length];\n\tfor (int i = 2; i < arr.length * 2; i *= 2) {\n\t\tfor (int j = 0; j < (arr.length + i - 1) / i; j++) {\n\t\t\tint left = i * j;\n\t\t\tint mid = left + i / 2 >= arr.length ? (arr.length - 1) : (left + i / 2);\n\t\t\tint right = i * (j + 1) - 1 >= arr.length ? (arr.length - 1) : (i * (j + 1) - 1);\n\t\t\tint start = left, l = left, m = mid;\n\t\t\twhile (l < mid && m <= right) {\n\t\t\t\tif (arr[l] < arr[m]) {\n\t\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\t\t} else {\n\t\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (l < mid)\n\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\twhile (m <= right)\n\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\tSystem.arraycopy(orderedArr, left, arr, left, right - left + 1);\n\t\t}\n\t}\n}\nPHP[编辑]function merge_sort($arr) {\n\t$len = count($arr);\n\tif ($len <= 1)\n\t\treturn $arr;\n\t$half = ($len>>1) + ($len & 1);\n\t$arr2d = array_chunk($arr, $half);\n\t$left = merge_sort($arr2d[0]);\n\t$right = merge_sort($arr2d[1]);\n\twhile (count($left) && count($right))\n\t\tif ($left[0] < $right[0])\n\t\t\t$reg[] = array_shift($left);\n\t\telse\n\t\t\t$reg[] = array_shift($right);\n\treturn array_merge($reg, $left, $right);\n}\n\n$arr = array(21, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70);\n$arr = merge_sort($arr);\nfor ($i = 0; $i < count($arr); $i++) {\n\techo $arr[$i] . ' ';\n}\nPython3[编辑]def mergeSort(nums):\n    if len(nums) < 2:\n        return nums\n    mid = len(nums) // 2\n    left = mergeSort(nums[:mid])\n    right = mergeSort(nums[mid:])\n\n    i = j = 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]: \n            result.append(left[i])\n            i += 1\n        else: \n            result.append(right[j])\n            j += 1\n\n    while i < len(left): \n        result.append(left[i]) \n        i += 1\n\n    while j < len(right): \n        result.append(right[j]) \n        j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    nums = [1, 4, 2, 3.6, -1, 0, 25, -34, 8, 9, 1, 0]\n    print(\"original:\", nums)\n    print(\"Sorted:\", mergeSort(nums))\nErlang[编辑]%% @doc 归并排序\ng_sort([]) ->\n    [];\ng_sort([T]) ->\n    [T];\ng_sort(L) ->\n    g_sort(L, length(L)).\n\ng_sort([_, _ | _] = L, Length) ->\n    SplitNum = trunc(Length / 2),\n    {L1, L2} = lists:split(SplitNum, L),\n    g_merge(g_sort(L1, SplitNum), g_sort(L2, Length - SplitNum));\ng_sort(L, _Length) ->\n    L.\n\n%% 已经排好序的两个list合并\ng_merge([], L2) ->\n    L2;\ng_merge(L1, []) ->\n    L1;\ng_merge([T1 | Rest1] = L1, [T2 | Rest2] = L2) ->\n    if\n        T1 =< T2 -> [T1 | g_merge(Rest1, L2)];\n        true -> [T2 | g_merge(L1, Rest2)]\n    end.\nJavascript[编辑]\n递归法function merge(left, right){\n  var result = [];\n  while(left.length > 0 && right.length > 0){\n    if(left[0] < right[0]){\n      result.push(left.shift());\n    }else{\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left, right);\n}\n\nfunction mergeSort(arr){\n  if(arr.length <=1) return arr;\n  var middle = Math.floor(arr.length / 2);\n  var left = arr.slice(0, middle);\n  var right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n迭代法\nGo[编辑]package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc MergeSort(list []int) []int {\n\tvar length = len(list)\n\tif length < 2 {\n\t\treturn list\n\t}\n\tvar mid = length / 2\n\treturn merge(MergeSort(list[:mid]), MergeSort(list[mid:]))\n}\n\nfunc merge(x, y []int) []int {\n\tvar r []int = make([]int, len(x)+len(y))\n\tfor i, j := 0, 0; ; {\n\t\tif i < len(x) && (j == len(y) || x[i] < y[j]) {\n\t\t\tr[i+j] = x[i]\n\t\t\ti++\n\t\t} else if j < len(y) {\n\t\t\tr[i+j] = y[j]\n\t\t\tj++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn r\n}\n\nfunc main() {\n\tvar list []int = []int{56, 48, 58, 94, 87, 4, 5, 61, 5, 8, 74, 9, 84, 15, 94, 9, 4, 31, 41, 68, 7, 4, 6, 94, 16, 9, 8, 4}\n\tfmt.Println(MergeSort(list))\n\tfmt.Println(list)\n\n\tsort.Ints(list)\n\tfmt.Println(list)\n}\n递归版\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc merge(data []int) []int {\n\tsum := len(data)\n\tif sum <= 1 {\n\t\treturn data\n\t}\n\tleft := data[0 : sum/2]\n\tlSize := len(left)\n\tif lSize >= 2 {\n\t\tleft = merge(left)\n\t}\n\tright := data[sum/2:]\n\trSize := len(right)\n\tif rSize >= 2 {\n\t\tright = merge(right)\n\t}\n\tj := 0\n\tt := 0\n\tarr := make([]int, sum)\n\tfmt.Println(left, right, data)\n\tfor i := 0; i < sum; i++ {\n\t\tif j < lSize && t < rSize {\n\t\t\tif left[j] <= right[t] {\n\t\t\t\tarr[i] = left[j]\n\t\t\t\tj++\n\t\t\t} else {\n\t\t\t\tarr[i] = right[t]\n\t\t\t\tt++\n\t\t\t}\t\n\t\t}  else if j >= lSize{\n\t\t\tarr[i] = right[t]\n\t\t\tt++\n\t\t}  else if t >= rSize{\n\t\t\tarr[i] = left[j]\n\t\t\tj++\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc main() {\n\tvar aa = []int{1000, 2, 31, 34, 5, 9, 7, 4, 6, 89, 90, 99, 99, 99, 99, 99}\n\t\n\tvar bb = merge(aa)\n\tfmt.Println(bb)\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例", "Tag": "算法设计"}
{"Answer": "迭代版：\nint min(int x, int y) {\n    return x < y ? x : y;\n}\nvoid merge_sort(int arr[], int len) {\n    int *a = arr;\n    int *b = (int *) malloc(len * sizeof(int));\n    int seg, start;\n    for (seg = 1; seg < len; seg += seg) {\n        for (start = 0; start < len; start += seg * 2) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        int *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        int i;\n        for (i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    free(b);\n}\n遞歸版：\n// 分治-治\nvoid mergeSort_conquer(int* array, int left, int mid, int right, int* temp) {\n    // [left, mid]和[mid+1, right]两个有序数组\n    int i = left;\n    int j = mid + 1;\n    int index = 0;\n    while (i <= mid && j <= right) {\n        if (array[i] < array[j]) {\n            temp[index++] = array[i++];\n        } else {\n            temp[index++] = array[j++];\n        }\n    }\n    // 剩余元素直接放入temp\n    while (i <= mid) {\n        temp[index++] = array[i++];\n    }\n    while (j <= right) {\n        temp[index++] = array[j++];\n    }\n    // 放回原数组\n    index = 0;\n    while (left <= right) {\n        array[left++] = temp[index++];\n    }\n}\n\n// 分治-分\nvoid mergeSort_divide(int* array, int left, int right, int* temp) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        // 左边归并排序\n        mergeSort_divide(array, left, mid, temp);\n        // 右边归并排序\n        mergeSort_divide(array, mid + 1, right, temp);\n        // 合并两个有序序列\n        mergeSort_conquer(array, left, mid, right, temp);\n    }\n}\n\nvoid mergeSort(int* array, int size) {\n    int* temp = (int*)malloc(sizeof(int) * size);\n    mergeSort_divide(array, 0, size - 1, temp);\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的C語言", "Tag": "算法设计"}
{"Answer": "迭代版：\ntemplate<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定\"小於\"(<)的運算子功能\nvoid merge_sort(T arr[], int len) {\n    T *a = arr;\n    T *b = new T[len];\n    for (int seg = 1; seg < len; seg += seg) {\n        for (int start = 0; start < len; start += seg + seg) {\n            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);\n            int k = low;\n            int start1 = low, end1 = mid;\n            int start2 = mid, end2 = high;\n            while (start1 < end1 && start2 < end2)\n                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];\n            while (start1 < end1)\n                b[k++] = a[start1++];\n            while (start2 < end2)\n                b[k++] = a[start2++];\n        }\n        T *temp = a;\n        a = b;\n        b = temp;\n    }\n    if (a != arr) {\n        for (int i = 0; i < len; i++)\n            b[i] = a[i];\n        b = a;\n    }\n    delete[] b;\n}\n遞歸版：\nvoid Merge(vector<int> &Array, int front, int mid, int end) {\n    // preconditions:\n    // Array[front...mid] is sorted\n    // Array[mid+1 ... end] is sorted\n    // Copy Array[front ... mid] to LeftSubArray\n    // Copy Array[mid+1 ... end] to RightSubArray\n    vector<int> LeftSubArray(Array.begin() + front, Array.begin() + mid + 1);\n    vector<int> RightSubArray(Array.begin() + mid + 1, Array.begin() + end + 1);\n    int idxLeft = 0, idxRight = 0;\n    LeftSubArray.insert(LeftSubArray.end(), numeric_limits<int>::max());\n    RightSubArray.insert(RightSubArray.end(), numeric_limits<int>::max());\n    // Pick min of LeftSubArray[idxLeft] and RightSubArray[idxRight], and put into Array[i]\n    for (int i = front; i <= end; i++) {\n        if (LeftSubArray[idxLeft] < RightSubArray[idxRight]) {\n            Array[i] = LeftSubArray[idxLeft];\n            idxLeft++;\n        } else {\n            Array[i] = RightSubArray[idxRight];\n            idxRight++;\n        }\n    }\n}\n\nvoid MergeSort(vector<int> &Array, int front, int end) {\n    if (front >= end)\n        return;\n    int mid = front + (end - front) / 2;\n    MergeSort(Array, front, mid);\n    MergeSort(Array, mid + 1, end);\n    Merge(Array, front, mid, end);\n}\n[1]\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的C++", "Tag": "算法设计"}
{"Answer": "public static List<int> sort(List<int> lst) {\n    if (lst.Count <= 1)\n        return lst;\n    int mid = lst.Count / 2;\n    List<int> left = new List<int>();  // 定义左侧List\n    List<int> right = new List<int>(); // 定义右侧List\n    // 以下兩個循環把 lst 分為左右兩個 List\n    for (int i = 0; i < mid; i++)\n        left.Add(lst[i]);\n    for (int j = mid; j < lst.Count; j++)\n        right.Add(lst[j]);\n    left = sort(left);\n    right = sort(right);\n    return merge(left, right);\n}\n/// <summary>\n/// 合併兩個已經排好序的List\n/// </summary>\n/// <param name=\"left\">左側List</param>\n/// <param name=\"right\">右側List</param>\n/// <returns></returns>\nstatic List<int> merge(List<int> left, List<int> right) {\n    List<int> temp = new List<int>();\n    while (left.Count > 0 && right.Count > 0) {\n        if (left[0] <= right[0]) {\n            temp.Add(left[0]);\n            left.RemoveAt(0);\n        } else {\n            temp.Add(right[0]);\n            right.RemoveAt(0);\n        }\n    }\n    if (left.Count > 0) {\n        for (int i = 0; i < left.Count; i++)\n            temp.Add(left[i]);\n    }\n    if (right.Count > 0) {\n        for (int i = 0; i < right.Count; i++)\n            temp.Add(right[i]);\n    }\n    return temp;\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的C#", "Tag": "算法设计"}
{"Answer": "def merge list\n  return list if list.size < 2\n\n  pivot = list.size / 2\n\n  # Merge\n  lambda { |left, right|\n    final = []\n    until left.empty? or right.empty?\n      final << if left.first < right.first; left.shift else right.shift end\n    end\n    final + left + right\n  }.call merge(list[0...pivot]), merge(list[pivot..-1])\nend\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Ruby", "Tag": "算法设计"}
{"Answer": "遞歸版：\nstatic void merge_sort_recursive(int[] arr, int[] result, int start, int end) {\n\tif (start >= end)\n\t\treturn;\n\tint len = end - start, mid = (len >> 1) + start;\n\tint start1 = start, end1 = mid;\n\tint start2 = mid + 1, end2 = end;\n\tmerge_sort_recursive(arr, result, start1, end1);\n\tmerge_sort_recursive(arr, result, start2, end2);\n\tint k = start;\n\twhile (start1 <= end1 && start2 <= end2)\n\t\tresult[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];\n\twhile (start1 <= end1)\n\t\tresult[k++] = arr[start1++];\n\twhile (start2 <= end2)\n\t\tresult[k++] = arr[start2++];\n\tfor (k = start; k <= end; k++)\n\t\tarr[k] = result[k];\n}\npublic static void merge_sort(int[] arr) {\n\tint len = arr.length;\n\tint[] result = new int[len];\n\tmerge_sort_recursive(arr, result, 0, len - 1);\n}\n迭代版：\npublic static void merge_sort(int[] arr) {\n\tint[] orderedArr = new int[arr.length];\n\tfor (int i = 2; i < arr.length * 2; i *= 2) {\n\t\tfor (int j = 0; j < (arr.length + i - 1) / i; j++) {\n\t\t\tint left = i * j;\n\t\t\tint mid = left + i / 2 >= arr.length ? (arr.length - 1) : (left + i / 2);\n\t\t\tint right = i * (j + 1) - 1 >= arr.length ? (arr.length - 1) : (i * (j + 1) - 1);\n\t\t\tint start = left, l = left, m = mid;\n\t\t\twhile (l < mid && m <= right) {\n\t\t\t\tif (arr[l] < arr[m]) {\n\t\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\t\t} else {\n\t\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (l < mid)\n\t\t\t\torderedArr[start++] = arr[l++];\n\t\t\twhile (m <= right)\n\t\t\t\torderedArr[start++] = arr[m++];\n\t\t\tSystem.arraycopy(orderedArr, left, arr, left, right - left + 1);\n\t\t}\n\t}\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Java", "Tag": "算法设计"}
{"Answer": "function merge_sort($arr) {\n\t$len = count($arr);\n\tif ($len <= 1)\n\t\treturn $arr;\n\t$half = ($len>>1) + ($len & 1);\n\t$arr2d = array_chunk($arr, $half);\n\t$left = merge_sort($arr2d[0]);\n\t$right = merge_sort($arr2d[1]);\n\twhile (count($left) && count($right))\n\t\tif ($left[0] < $right[0])\n\t\t\t$reg[] = array_shift($left);\n\t\telse\n\t\t\t$reg[] = array_shift($right);\n\treturn array_merge($reg, $left, $right);\n}\n\n$arr = array(21, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70);\n$arr = merge_sort($arr);\nfor ($i = 0; $i < count($arr); $i++) {\n\techo $arr[$i] . ' ';\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的PHP", "Tag": "算法设计"}
{"Answer": "def mergeSort(nums):\n    if len(nums) < 2:\n        return nums\n    mid = len(nums) // 2\n    left = mergeSort(nums[:mid])\n    right = mergeSort(nums[mid:])\n\n    i = j = 0\n    result = []\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]: \n            result.append(left[i])\n            i += 1\n        else: \n            result.append(right[j])\n            j += 1\n\n    while i < len(left): \n        result.append(left[i]) \n        i += 1\n\n    while j < len(right): \n        result.append(right[j]) \n        j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    nums = [1, 4, 2, 3.6, -1, 0, 25, -34, 8, 9, 1, 0]\n    print(\"original:\", nums)\n    print(\"Sorted:\", mergeSort(nums))\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Python3", "Tag": "算法设计"}
{"Answer": "%% @doc 归并排序\ng_sort([]) ->\n    [];\ng_sort([T]) ->\n    [T];\ng_sort(L) ->\n    g_sort(L, length(L)).\n\ng_sort([_, _ | _] = L, Length) ->\n    SplitNum = trunc(Length / 2),\n    {L1, L2} = lists:split(SplitNum, L),\n    g_merge(g_sort(L1, SplitNum), g_sort(L2, Length - SplitNum));\ng_sort(L, _Length) ->\n    L.\n\n%% 已经排好序的两个list合并\ng_merge([], L2) ->\n    L2;\ng_merge(L1, []) ->\n    L1;\ng_merge([T1 | Rest1] = L1, [T2 | Rest2] = L2) ->\n    if\n        T1 =< T2 -> [T1 | g_merge(Rest1, L2)];\n        true -> [T2 | g_merge(L1, Rest2)]\n    end.\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Erlang", "Tag": "算法设计"}
{"Answer": "\n递归法function merge(left, right){\n  var result = [];\n  while(left.length > 0 && right.length > 0){\n    if(left[0] < right[0]){\n      result.push(left.shift());\n    }else{\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left, right);\n}\n\nfunction mergeSort(arr){\n  if(arr.length <=1) return arr;\n  var middle = Math.floor(arr.length / 2);\n  var left = arr.slice(0, middle);\n  var right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n迭代法\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Javascript", "Tag": "算法设计"}
{"Answer": "package main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc MergeSort(list []int) []int {\n\tvar length = len(list)\n\tif length < 2 {\n\t\treturn list\n\t}\n\tvar mid = length / 2\n\treturn merge(MergeSort(list[:mid]), MergeSort(list[mid:]))\n}\n\nfunc merge(x, y []int) []int {\n\tvar r []int = make([]int, len(x)+len(y))\n\tfor i, j := 0, 0; ; {\n\t\tif i < len(x) && (j == len(y) || x[i] < y[j]) {\n\t\t\tr[i+j] = x[i]\n\t\t\ti++\n\t\t} else if j < len(y) {\n\t\t\tr[i+j] = y[j]\n\t\t\tj++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn r\n}\n\nfunc main() {\n\tvar list []int = []int{56, 48, 58, 94, 87, 4, 5, 61, 5, 8, 74, 9, 84, 15, 94, 9, 4, 31, 41, 68, 7, 4, 6, 94, 16, 9, 8, 4}\n\tfmt.Println(MergeSort(list))\n\tfmt.Println(list)\n\n\tsort.Ints(list)\n\tfmt.Println(list)\n}\n递归版\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc merge(data []int) []int {\n\tsum := len(data)\n\tif sum <= 1 {\n\t\treturn data\n\t}\n\tleft := data[0 : sum/2]\n\tlSize := len(left)\n\tif lSize >= 2 {\n\t\tleft = merge(left)\n\t}\n\tright := data[sum/2:]\n\trSize := len(right)\n\tif rSize >= 2 {\n\t\tright = merge(right)\n\t}\n\tj := 0\n\tt := 0\n\tarr := make([]int, sum)\n\tfmt.Println(left, right, data)\n\tfor i := 0; i < sum; i++ {\n\t\tif j < lSize && t < rSize {\n\t\t\tif left[j] <= right[t] {\n\t\t\t\tarr[i] = left[j]\n\t\t\t\tj++\n\t\t\t} else {\n\t\t\t\tarr[i] = right[t]\n\t\t\t\tt++\n\t\t\t}\t\n\t\t}  else if j >= lSize{\n\t\t\tarr[i] = right[t]\n\t\t\tt++\n\t\t}  else if t >= rSize{\n\t\t\tarr[i] = left[j]\n\t\t\tj++\n\t\t}\n\t}\n\treturn arr\n}\n\nfunc main() {\n\tvar aa = []int{1000, 2, 31, 34, 5, 9, 7, 4, 6, 89, 90, 99, 99, 99, 99, 99}\n\t\n\tvar bb = merge(aa)\n\tfmt.Println(bb)\n}\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的實作範例的Go", "Tag": "算法设计"}
{"Answer": "比较操作的次数介于\n  \n    \n      \n        (\n        n\n        log\n        ⁡\n        n\n        )\n        \n          /\n        \n        2\n      \n    \n    {\\displaystyle (n\\log n)/2}\n  \n和\n  \n    \n      \n        n\n        log\n        ⁡\n        n\n        −\n        n\n        +\n        1\n      \n    \n    {\\displaystyle n\\log n-n+1}\n  \n。\n赋值操作的次数是\n  \n    \n      \n        (\n        2\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle (2n\\log n)}\n  \n。归并算法的空间复杂度为：\n  \n    \n      \n        Θ\n        (\n        n\n        )\n      \n    \n    {\\displaystyle \\Theta (n)}\n  \n\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的算法复杂度", "Tag": "算法设计"}
{"Answer": "\n\n^ Cormen, Thomas H. （英语：Thomas H. Cormen）; Leiserson, Charles E. （英语：Charles E. Leiserson）; Rivest, Ronald L.; Stein, Clifford. Section 2.3: Designing algorithms. Introduction to Algorithms 3rd. MIT Press and McGraw-Hill. 2009: 29–34 [1990]. ISBN 0-262-03384-4. .\n\n", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的参考文献", "Tag": "算法设计"}
{"Answer": "Dictionary of Algorithms and Data Structures: Merge sort （页面存档备份，存于互联网档案馆）\nMerge sort Algorithm with example program （页面存档备份，存于互联网档案馆）\nMerge Sort Algorithm Simulation\nMergesort For Linked Lists （页面存档备份，存于互联网档案馆）\nMergesort in Java, Python, Perl, C, Ruby", "Konwledge_Point": "归并排序", "Question": "什么是归并排序的外部連結", "Tag": "算法设计"}
