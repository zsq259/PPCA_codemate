{"Answer": "霍夫曼編碼（英語：Huffman Coding），又譯為哈夫曼编码、赫夫曼编码，是一種用於无损数据压缩的熵編碼（權編碼）演算法。由美國計算機科學家大衛·霍夫曼（David Albert Huffman）在1952年發明。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码", "Tag": "算法设计"}
{"Answer": "在计算机資料處理中，霍夫曼編碼使用變長編碼表對源符號（如文件中的一個字母）進行編碼，其中變長編碼表是通過一種評估來源符號出現機率的方法得到的，出現機率高的字母使用較短的編碼，反之出現機率低的則使用較長的編碼，這便使編碼之後的字符串的平均長度、期望值降低，從而達到無損壓縮數據的目的。\n例如，在英文中，e的出現機率最高，而z的出現機率則最低。當利用霍夫曼編碼對一篇英文文章進行壓縮時，e極有可能用一個位元來表示，而z則可能花去25個位元（不是26）。用普通的表示方法時，每個英文字母均占用一個字節，即8個位元。二者相比，e使用了一般編碼的1/8的長度，z則使用了3倍多。倘若我們能實現對於英文中各個字母出現機率的較準確的估算，就可以大幅度提高無損壓縮的比例。\n霍夫曼樹又稱最優二叉樹，是一種帶權路徑長度最短的二叉樹。所謂樹的帶權路徑長度，就是樹中所有的葉結點的權值乘上其到根結點的路徑長度（若根結點爲0層，葉結點到根結點的路徑長度爲葉結點的層數）。樹的路徑長度是從樹根到每一結點的路徑長度之和，記爲WPL=（W1*L1+W2*L2+W3*L3+...+Wn*Ln），N個權值Wi（i=1,2,...n）構成一棵有N個葉結點的二叉樹，相應的葉結點的路徑長度爲Li（i=1,2,...n）。可以證明霍夫曼樹的WPL是最小的。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的簡介", "Tag": "算法设计"}
{"Answer": "1951年，霍夫曼在麻省理工學院（MIT）攻讀博士學位，他和修讀信息論課程的同學得選擇是完成學期報告還是期末考試。導師羅伯特·法諾（Robert Fano）出的學期報告題目是：尋找最有效的二進制編碼。由於無法證明哪個已有編碼是最有效的，霍夫曼放棄對已有編碼的研究，轉向新的探索，最終發現了基於有序頻率二叉樹編碼的想法，並很快證明了這個方法是最有效的。霍夫曼使用自底向上的方法構建二叉樹，避免了次優算法香農-范諾編碼（Shannon–Fano coding）的最大弊端──自頂向下構建樹。\n1952年，於論文《一種構建極小多餘編碼的方法》（A Method for the Construction of Minimum-Redundancy Codes）中發表了這個編碼方法。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的歷史", "Tag": "算法设计"}
{"Answer": "  Fig.1  Fig.2霍夫曼編碼演算步驟, 左右树排列顺序可以加限制或不加限制  Fig.3廣義[编辑]給定一組符號（Symbol）和其對應的權重值（weight），其權重通常表示成概率（%）。欲知一組二元的前置碼，其二元碼的長度為最短。狹義[编辑]輸入符號集合\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            \n              s\n              \n                1\n              \n            \n            ,\n            \n              s\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              s\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{s_{1},s_{2},\\cdots ,s_{n}\\right\\}}\n  \n，其S集合的大小為\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n。\n權重集合\n  \n    \n      \n        W\n        =\n        \n          {\n          \n            \n              w\n              \n                1\n              \n            \n            ,\n            \n              w\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              w\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle W=\\left\\{w_{1},w_{2},\\cdots ,w_{n}\\right\\}}\n  \n，其W集合不為負數且\n  \n    \n      \n        \n          w\n          \n            i\n          \n        \n        =\n        \n          w\n          e\n          i\n          g\n          h\n          t\n        \n        \n          (\n          \n            s\n            \n              i\n            \n          \n          )\n        \n        ,\n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle w_{i}=\\mathrm {weight} \\left(s_{i}\\right),1\\leq i\\leq n}\n  \n。輸出一組編碼\n  \n    \n      \n        C\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n        =\n        \n          {\n          \n            \n              c\n              \n                1\n              \n            \n            ,\n            \n              c\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              c\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle C\\left(S,W\\right)=\\left\\{c_{1},c_{2},\\cdots ,c_{n}\\right\\}}\n  \n，其C集合是一組二進制編碼且\n  \n    \n      \n        \n          c\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle c_{i}}\n  \n為\n  \n    \n      \n        \n          s\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle s_{i}}\n  \n相對應的編碼，\n  \n    \n      \n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle 1\\leq i\\leq n}\n  \n。目標設\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          \n            w\n            \n              i\n            \n          \n          ×\n          \n            l\n            e\n            n\n            g\n            t\n            h\n          \n          \n            (\n            \n              c\n              \n                i\n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle L\\left(C\\right)=\\sum _{i=1}^{n}{w_{i}\\times \\mathrm {length} \\left(c_{i}\\right)}}\n  \n為\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n的加權的路徑長，對所有編碼\n  \n    \n      \n        T\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n      \n    \n    {\\displaystyle T\\left(S,W\\right)}\n  \n，則\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        ≤\n        L\n        \n          (\n          T\n          )\n        \n      \n    \n    {\\displaystyle L\\left(C\\right)\\leq L\\left(T\\right)}\n  \n範例[编辑]霍夫曼樹常處理符號編寫工作。根據整組資料中符號出現的頻率高低，決定如何給符號編碼。如果符號出現的頻率越高，則給符號的碼越短，相反符號的號碼越長。假設我們要給一個英文單字\"F O R G E T\"進行霍夫曼編碼，而每個英文字母出現的頻率分別列在Fig.1。\n演算過程[编辑]（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法", "Tag": "算法设计"}
{"Answer": "給定一組符號（Symbol）和其對應的權重值（weight），其權重通常表示成概率（%）。欲知一組二元的前置碼，其二元碼的長度為最短。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的廣義", "Tag": "算法设计"}
{"Answer": "輸入符號集合\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            \n              s\n              \n                1\n              \n            \n            ,\n            \n              s\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              s\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{s_{1},s_{2},\\cdots ,s_{n}\\right\\}}\n  \n，其S集合的大小為\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n。\n權重集合\n  \n    \n      \n        W\n        =\n        \n          {\n          \n            \n              w\n              \n                1\n              \n            \n            ,\n            \n              w\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              w\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle W=\\left\\{w_{1},w_{2},\\cdots ,w_{n}\\right\\}}\n  \n，其W集合不為負數且\n  \n    \n      \n        \n          w\n          \n            i\n          \n        \n        =\n        \n          w\n          e\n          i\n          g\n          h\n          t\n        \n        \n          (\n          \n            s\n            \n              i\n            \n          \n          )\n        \n        ,\n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle w_{i}=\\mathrm {weight} \\left(s_{i}\\right),1\\leq i\\leq n}\n  \n。輸出一組編碼\n  \n    \n      \n        C\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n        =\n        \n          {\n          \n            \n              c\n              \n                1\n              \n            \n            ,\n            \n              c\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              c\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle C\\left(S,W\\right)=\\left\\{c_{1},c_{2},\\cdots ,c_{n}\\right\\}}\n  \n，其C集合是一組二進制編碼且\n  \n    \n      \n        \n          c\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle c_{i}}\n  \n為\n  \n    \n      \n        \n          s\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle s_{i}}\n  \n相對應的編碼，\n  \n    \n      \n        1\n        ≤\n        i\n        ≤\n        n\n      \n    \n    {\\displaystyle 1\\leq i\\leq n}\n  \n。目標設\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          \n            w\n            \n              i\n            \n          \n          ×\n          \n            l\n            e\n            n\n            g\n            t\n            h\n          \n          \n            (\n            \n              c\n              \n                i\n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle L\\left(C\\right)=\\sum _{i=1}^{n}{w_{i}\\times \\mathrm {length} \\left(c_{i}\\right)}}\n  \n為\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n的加權的路徑長，對所有編碼\n  \n    \n      \n        T\n        \n          (\n          \n            S\n            ,\n            W\n          \n          )\n        \n      \n    \n    {\\displaystyle T\\left(S,W\\right)}\n  \n，則\n  \n    \n      \n        L\n        \n          (\n          C\n          )\n        \n        ≤\n        L\n        \n          (\n          T\n          )\n        \n      \n    \n    {\\displaystyle L\\left(C\\right)\\leq L\\left(T\\right)}\n  \n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的狹義", "Tag": "算法设计"}
{"Answer": "霍夫曼樹常處理符號編寫工作。根據整組資料中符號出現的頻率高低，決定如何給符號編碼。如果符號出現的頻率越高，則給符號的碼越短，相反符號的號碼越長。假設我們要給一個英文單字\"F O R G E T\"進行霍夫曼編碼，而每個英文字母出現的頻率分別列在Fig.1。\n演算過程[编辑]（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的範例", "Tag": "算法设计"}
{"Answer": "（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。實現方法[编辑]", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的範例的演算過程", "Tag": "算法设计"}
{"Answer": "資料壓縮[编辑]實現霍夫曼編碼的方式主要是創建一個二元樹和其節點。這些樹的節點可以儲存在陣列裡，陣列的大小為符號（symbols）數的大小n，而節點分别是終端節點（葉節點）與非終端節點（內部節點）。\n一開始，所有的節點都是終端節點，節點內有三個欄位：\n1.符號（Symbol）\n2.權重（Weight、Probabilities、Frequency）\n3.指向父節點的鏈結（Link to its parent node）\n而非終端節點內有四個欄位：\n1.權重（Weight、Probabilities、Frequency）\n2.指向兩個子節點的 鏈結（Links to two child node）  \n3.指向父節點的鏈結（Link to its parent node）\n基本上，我們用'0'與'1'分別代表指向左子節點與右子節點，最後為完成的二元樹共有n個終端節點與n-1個非終端節點，去除了不必要的符號並產生最佳的編碼長度。\n過程中，每個終端節點都包含著一個權重（Weight、Probabilities、Frequency），兩兩終端節點結合會產生一個新節點，新節點的權重是由兩個權重最小的終端節點權重之總和，並持續進行此過程直到只剩下一個節點為止。\n實現霍夫曼樹的方式有很多種，可以使用優先佇列（Priority Queue）簡單達成這個過程，給與權重較低的符號較高的優先順序（Priority），演算法如下：\n⒈把n個終端節點加入優先佇列，則n個節點都有一個優先權Pi，1 ≤ i ≤ n\n⒉如果佇列內的節點數>1，則：\n⑴從佇列中移除兩個最小的Pi節點，即連續做兩次remove（min（Pi）, Priority_Queue)⑵產生一個新節點，此節點為（1）之移除節點之父節點，而此節點的權重值為（1）兩節點之權重和⑶把（2）產生之節點加入優先佇列中⒊最後在優先佇列裡的點為樹的根節點（root）\n而此演算法的時間複雜度（ Time Complexity）為O（n log n）；因為有n個終端節點，所以樹總共有2n-1個節點，使用優先佇列每個迴圈須O（log n）。\n此外，有一個更快的方式使時間複雜度降至線性時間（Linear Time）O（n），就是使用兩個佇列（Queue）創件霍夫曼樹。第一個佇列用來儲存n個符號（即n個終端節點）的權重，第二個佇列用來儲存兩兩權重的合（即非終端節點）。此法可保證第二個佇列的前端（Front）權重永遠都是最小值，且方法如下：\n⒈把n個終端節點加入第一個佇列（依照權重大小排列，最小在前端）\n⒉如果佇列內的節點數>1，則：\n⑴從佇列前端移除兩個最低權重的節點⑵將（1）中移除的兩個節點權重相加合成一個新節點⑶加入第二個佇列⒊最後在第一個佇列的節點為根節點\n雖然使用此方法比使用優先佇列的時間複雜度還低，但是注意此法的第1項，節點必須依照權重大小加入佇列中，如果節點加入順序不按大小，則需要經過排序，則至少花了O（n log n）的時間複雜度計算。\n但是在不同的狀況考量下，時間複雜度並非是最重要的，如果我們今天考慮英文字母的出現頻率，變數n就是英文字母的26個字母，則使用哪一種演算法時間複雜度都不會影響很大，因為n不是一筆龐大的數字。\n資料解壓縮[编辑]簡單來說，霍夫曼碼樹的解壓縮就是將得到的前置碼（Prefix Huffman code）轉換回符號，通常藉由樹的追蹤（Traversal），將接收到的位元串（Bits stream）一步一步還原。但是要追蹤樹之前，必須要先重建霍夫曼樹；某些情況下，如果每個符號的權重可以被事先預測，那麼霍夫曼樹就可以預先重建，並且儲存並重複使用，否則，傳送端必須預先傳送霍夫曼樹的相關資訊給接收端。\n最簡單的方式，就是預先統計各符號的權重並加入至壓縮之位元串，但是此法的運算量花費相當大，並不適合實際的應用。若是使用Canonical encoding，則可精準得知樹重建的資料量只占B2^B位元（其中B為每個符號的位元數（bits））。如果簡單將接收到的位元串一個位元一個位元的重建，例如：'0'表示父節點，'1'表示終端節點，若每次讀取到1時，下8個位元則會被解讀是終端節點（假設資料為8-bit字母），則霍夫曼樹則可被重建，以此方法，資料量的大小可能為2~320位元組不等。雖然還有很多方法可以重建霍夫曼樹，但因為壓縮的資料串包含\"trailing bits\"，所以還原時一定要考慮何時停止，不要還原到錯誤的值，如在資料壓縮時時加上每筆資料的長度等。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的實現方法", "Tag": "算法设计"}
{"Answer": "實現霍夫曼編碼的方式主要是創建一個二元樹和其節點。這些樹的節點可以儲存在陣列裡，陣列的大小為符號（symbols）數的大小n，而節點分别是終端節點（葉節點）與非終端節點（內部節點）。\n一開始，所有的節點都是終端節點，節點內有三個欄位：\n1.符號（Symbol）\n2.權重（Weight、Probabilities、Frequency）\n3.指向父節點的鏈結（Link to its parent node）\n而非終端節點內有四個欄位：\n1.權重（Weight、Probabilities、Frequency）\n2.指向兩個子節點的 鏈結（Links to two child node）  \n3.指向父節點的鏈結（Link to its parent node）\n基本上，我們用'0'與'1'分別代表指向左子節點與右子節點，最後為完成的二元樹共有n個終端節點與n-1個非終端節點，去除了不必要的符號並產生最佳的編碼長度。\n過程中，每個終端節點都包含著一個權重（Weight、Probabilities、Frequency），兩兩終端節點結合會產生一個新節點，新節點的權重是由兩個權重最小的終端節點權重之總和，並持續進行此過程直到只剩下一個節點為止。\n實現霍夫曼樹的方式有很多種，可以使用優先佇列（Priority Queue）簡單達成這個過程，給與權重較低的符號較高的優先順序（Priority），演算法如下：\n⒈把n個終端節點加入優先佇列，則n個節點都有一個優先權Pi，1 ≤ i ≤ n\n⒉如果佇列內的節點數>1，則：\n⑴從佇列中移除兩個最小的Pi節點，即連續做兩次remove（min（Pi）, Priority_Queue)⑵產生一個新節點，此節點為（1）之移除節點之父節點，而此節點的權重值為（1）兩節點之權重和⑶把（2）產生之節點加入優先佇列中⒊最後在優先佇列裡的點為樹的根節點（root）\n而此演算法的時間複雜度（ Time Complexity）為O（n log n）；因為有n個終端節點，所以樹總共有2n-1個節點，使用優先佇列每個迴圈須O（log n）。\n此外，有一個更快的方式使時間複雜度降至線性時間（Linear Time）O（n），就是使用兩個佇列（Queue）創件霍夫曼樹。第一個佇列用來儲存n個符號（即n個終端節點）的權重，第二個佇列用來儲存兩兩權重的合（即非終端節點）。此法可保證第二個佇列的前端（Front）權重永遠都是最小值，且方法如下：\n⒈把n個終端節點加入第一個佇列（依照權重大小排列，最小在前端）\n⒉如果佇列內的節點數>1，則：\n⑴從佇列前端移除兩個最低權重的節點⑵將（1）中移除的兩個節點權重相加合成一個新節點⑶加入第二個佇列⒊最後在第一個佇列的節點為根節點\n雖然使用此方法比使用優先佇列的時間複雜度還低，但是注意此法的第1項，節點必須依照權重大小加入佇列中，如果節點加入順序不按大小，則需要經過排序，則至少花了O（n log n）的時間複雜度計算。\n但是在不同的狀況考量下，時間複雜度並非是最重要的，如果我們今天考慮英文字母的出現頻率，變數n就是英文字母的26個字母，則使用哪一種演算法時間複雜度都不會影響很大，因為n不是一筆龐大的數字。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的實現方法的資料壓縮", "Tag": "算法设计"}
{"Answer": "簡單來說，霍夫曼碼樹的解壓縮就是將得到的前置碼（Prefix Huffman code）轉換回符號，通常藉由樹的追蹤（Traversal），將接收到的位元串（Bits stream）一步一步還原。但是要追蹤樹之前，必須要先重建霍夫曼樹；某些情況下，如果每個符號的權重可以被事先預測，那麼霍夫曼樹就可以預先重建，並且儲存並重複使用，否則，傳送端必須預先傳送霍夫曼樹的相關資訊給接收端。\n最簡單的方式，就是預先統計各符號的權重並加入至壓縮之位元串，但是此法的運算量花費相當大，並不適合實際的應用。若是使用Canonical encoding，則可精準得知樹重建的資料量只占B2^B位元（其中B為每個符號的位元數（bits））。如果簡單將接收到的位元串一個位元一個位元的重建，例如：'0'表示父節點，'1'表示終端節點，若每次讀取到1時，下8個位元則會被解讀是終端節點（假設資料為8-bit字母），則霍夫曼樹則可被重建，以此方法，資料量的大小可能為2~320位元組不等。雖然還有很多方法可以重建霍夫曼樹，但因為壓縮的資料串包含\"trailing bits\"，所以還原時一定要考慮何時停止，不要還原到錯誤的值，如在資料壓縮時時加上每筆資料的長度等。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的實現方法的資料解壓縮", "Tag": "算法设计"}
{"Answer": "考量到不同的應用領域以及該領域的平均性質，將會使用不同的通用機率，又或者，這個機率是可以從被壓縮文本中的實際頻率所取得。\n最佳化[编辑]原始的霍夫曼演算法是一個符號與符號間已知輸入機率分佈的最佳編碼方式，也就是說將不相關的符號個別編碼為如此的資料串流。然而，當符號間的限制被捨棄或是質量機率函數是未知的時候，如此方式則並非最佳化。此外，當這些符號之間不是互相獨立，且分佈不相同的時候，單一一個符號可能不足以實現最佳化。在這種情況之下，算術編碼可能比起霍夫曼編碼會有更佳的壓縮能力。\n雖然上述兩種方法都可以組合任意數量的符號以實現更高效的編碼效果，並且通常適應於實際的輸入統計層面，但儘管最簡單的版本比霍夫曼編碼更慢且更複雜，算術編碼不會顯著增加其計算或算法複雜度。當輸入概率不是精確已知或在流內顯著變化時，這種靈活性特別有用。然而，霍夫曼編碼通常更快，並且算術編碼在歷史上是專利問題的一些主題。因此，許多技術歷來避免使用有利於霍夫曼和其他前綴編碼技術的算術編碼。截至2010年中期，隨著早期專利的到期，這種替代霍夫曼編碼的最常用技術已經進入公有領域。\n對於具有均勻概率分佈的一組符號，以及作為2的冪之成員，霍夫曼編碼等同於簡單的二進位制編碼，例如 ASCII 編碼。這反映了如此的事實：無論壓縮方法是什麼，這種輸入都不可能進行壓縮，或只是說對數據無所作為，比起壓縮才是最佳選擇。\n在任何情況下，霍夫曼編碼在所有方法中是最佳的方式，其中每個輸入符號是具有二元機率的已知獨立且相同分佈的隨機變量。前綴碼，特別是霍夫曼編碼，往往在小字母表上產生較差的效率，其中概率通常落在這些最佳（二元）點之間。當最可能符號的概率遠超過0.5時，可能發生霍夫曼編碼的最壞情況，使低效率的上限無限制。\n在使用霍夫曼編碼的同時，有兩種相關的方法可以解決這種特定的低效問題。將固定數量的符號組合在一起（阻塞）通常會增加（並且永不減少）壓縮。隨著塊的大小接近無窮大，霍夫曼編碼理論上接近熵限制，即最佳壓縮。然而，阻塞任意大的符號組是不切實際的，因為霍夫曼代碼的複雜性在要編碼的可能性的數量上是線性的，這是在塊的大小中呈指數的數字。這限制了在實踐中完成的阻塞量。\n廣泛使用的實際替代方案是行程編碼。該技術在熵編碼之前增加一步，特別是對重複符號進行執行次數的計數，然後對其進行編碼。對於伯努力（Bernoulli）過程的簡單情況，哥倫（Golomb）編碼在編碼遊程長度的前綴碼中是最佳的，這是通過霍夫曼編碼技術證明的事實。使用改進的霍夫曼編碼的傳真機採用類似的方法。但是，遊程編碼並不像其他壓縮技術那樣適應許多輸入類型。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的基本性質", "Tag": "算法设计"}
{"Answer": "原始的霍夫曼演算法是一個符號與符號間已知輸入機率分佈的最佳編碼方式，也就是說將不相關的符號個別編碼為如此的資料串流。然而，當符號間的限制被捨棄或是質量機率函數是未知的時候，如此方式則並非最佳化。此外，當這些符號之間不是互相獨立，且分佈不相同的時候，單一一個符號可能不足以實現最佳化。在這種情況之下，算術編碼可能比起霍夫曼編碼會有更佳的壓縮能力。\n雖然上述兩種方法都可以組合任意數量的符號以實現更高效的編碼效果，並且通常適應於實際的輸入統計層面，但儘管最簡單的版本比霍夫曼編碼更慢且更複雜，算術編碼不會顯著增加其計算或算法複雜度。當輸入概率不是精確已知或在流內顯著變化時，這種靈活性特別有用。然而，霍夫曼編碼通常更快，並且算術編碼在歷史上是專利問題的一些主題。因此，許多技術歷來避免使用有利於霍夫曼和其他前綴編碼技術的算術編碼。截至2010年中期，隨著早期專利的到期，這種替代霍夫曼編碼的最常用技術已經進入公有領域。\n對於具有均勻概率分佈的一組符號，以及作為2的冪之成員，霍夫曼編碼等同於簡單的二進位制編碼，例如 ASCII 編碼。這反映了如此的事實：無論壓縮方法是什麼，這種輸入都不可能進行壓縮，或只是說對數據無所作為，比起壓縮才是最佳選擇。\n在任何情況下，霍夫曼編碼在所有方法中是最佳的方式，其中每個輸入符號是具有二元機率的已知獨立且相同分佈的隨機變量。前綴碼，特別是霍夫曼編碼，往往在小字母表上產生較差的效率，其中概率通常落在這些最佳（二元）點之間。當最可能符號的概率遠超過0.5時，可能發生霍夫曼編碼的最壞情況，使低效率的上限無限制。\n在使用霍夫曼編碼的同時，有兩種相關的方法可以解決這種特定的低效問題。將固定數量的符號組合在一起（阻塞）通常會增加（並且永不減少）壓縮。隨著塊的大小接近無窮大，霍夫曼編碼理論上接近熵限制，即最佳壓縮。然而，阻塞任意大的符號組是不切實際的，因為霍夫曼代碼的複雜性在要編碼的可能性的數量上是線性的，這是在塊的大小中呈指數的數字。這限制了在實踐中完成的阻塞量。\n廣泛使用的實際替代方案是行程編碼。該技術在熵編碼之前增加一步，特別是對重複符號進行執行次數的計數，然後對其進行編碼。對於伯努力（Bernoulli）過程的簡單情況，哥倫（Golomb）編碼在編碼遊程長度的前綴碼中是最佳的，這是通過霍夫曼編碼技術證明的事實。使用改進的霍夫曼編碼的傳真機採用類似的方法。但是，遊程編碼並不像其他壓縮技術那樣適應許多輸入類型。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的基本性質的最佳化", "Tag": "算法设计"}
{"Answer": "霍夫曼編碼有衍生出許多的許多變化，其中一些使用類似霍夫曼的算法，而其他一些算法找到最佳前綴碼（例如，對輸出施加不同的限制）。注意，在後一種情況下，該方法不需要像霍夫曼那樣，實際上甚至不需要到多項式複雜度。\n多元樹霍夫曼編碼[编辑]多元樹霍夫曼編碼演算法使用字母集 {0, 1, ... , n − 1} ，來構建一棵 n 元樹。霍夫曼在他的原始論文中考慮了這種方法。這與二進制（n=2）算法僅有的差別，就是它每次把 n 個最低權的符號合併，而不僅是兩個最低權的符號。倘若 n ≥ 2, 則並非所有源字集都可以正確地形成用於霍夫曼編碼的多元樹。在這些情況下，必須添加額外的零概率佔位符。這是因為該樹必須為滿的 n 叉樹，所以每次合併會令符號數恰好減少 (n -1), 故這樣的 n 叉樹存在當且僅當源字的數量模 (n -1) 餘 1. 對於二進制編碼，任何大小的集合都可以形成這樣的二叉樹，因為 n -1 = 1.\n自適應霍夫曼編碼[编辑]自適應霍夫曼編碼的變化，涉及基於源符號序列中的最近實際頻率動態地計算概率，以及改變編碼樹結構以匹配更新的概率估計。它在實踐中很少使用，因為更新樹的成本使其比優化的自適應算術編碼慢，後者更靈活並且具有更好的壓縮。\n霍夫曼模板演算法[编辑]在霍夫曼編碼的實現中，通常會使用權重表示數值概率，但是上面給出的算法不需要這樣;它只需要權重形成一個完全有序的可交換么半群，這意味著一種訂購權重和添加權重的方法。霍夫曼模板算法使人們能夠使用任何類型的權重（成本，頻率，權重對，非數字權重）和許多組合方法之一（不僅僅是加法），這個問題首先應用於電路設計。\n長度限制霍夫曼編碼/最小變異霍夫曼編碼[编辑]長度限制霍夫曼編碼[编辑]長度受限的霍夫曼編碼是一種變體，其目標仍然是實現最小加權路徑長度，但是存在另外的限制，即每個碼字的長度必須小於給定常數。包合併算法通過一種與霍夫曼演算法非常相似的簡單貪婪方法解決了這個問題。\n不相等成本霍夫曼編碼[编辑]在標準的霍夫曼編碼問題中，假設集合中構成碼字的每個符號具有相同的傳輸成本：長度為N位的碼字總是具有N的成本，無論多少這些數字是0，有多少是1，等等。在這個假設下工作時，最小化消息的總成本和最小化數字總數是相同的。\n具有不等字母成本的霍夫曼編碼是沒有這種假設的概括：由於傳輸介質的特性，編碼字母表的字母可能具有不均勻的長度。一個例子是摩爾斯電碼的編碼字母表，其中'破折號'比'點'需要更長的發送時間，因此傳輸時間中破折號的成本更高。目標仍然是最小化加權平均碼字長度，但僅僅最小化消息使用的符號數量已經不夠了。沒有算法以與傳統霍夫曼編碼相同的方式或相同的效率來解決這個問題，儘管它已經由卡普（Karp）解決，其解決方案已經針對哥林（Golin）的整數成本的情況進行了改進。\n最佳字母二元樹[编辑]在標準霍夫曼編碼問題中，假設任何碼字可以對應於任何輸入符號。在字母表中，輸入和輸出的字母順序必須相同。\n規範霍夫曼編碼[编辑]如果對應於按字母順序排列的輸入的權重是按數字順序排列的，則霍夫曼代碼具有與最佳字母代碼相同的長度，這可以從計算這些長度中找到，從而不需要使用胡 - 塔克（Hu-Tucker）編碼。由數字（重新）有序輸入產生的代碼有時被稱為規範霍夫曼代碼，並且由於易於編碼/解碼，通常是實踐中使用的代碼。用於找到該代碼的技術有時被稱為霍夫曼 - 香農 - 法諾編碼，因為它像霍夫曼編碼一樣是最優的，但是在重量概率上是字母的，例如香農 - 法諾編碼。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化", "Tag": "算法设计"}
{"Answer": "多元樹霍夫曼編碼演算法使用字母集 {0, 1, ... , n − 1} ，來構建一棵 n 元樹。霍夫曼在他的原始論文中考慮了這種方法。這與二進制（n=2）算法僅有的差別，就是它每次把 n 個最低權的符號合併，而不僅是兩個最低權的符號。倘若 n ≥ 2, 則並非所有源字集都可以正確地形成用於霍夫曼編碼的多元樹。在這些情況下，必須添加額外的零概率佔位符。這是因為該樹必須為滿的 n 叉樹，所以每次合併會令符號數恰好減少 (n -1), 故這樣的 n 叉樹存在當且僅當源字的數量模 (n -1) 餘 1. 對於二進制編碼，任何大小的集合都可以形成這樣的二叉樹，因為 n -1 = 1.\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的多元樹霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "自適應霍夫曼編碼的變化，涉及基於源符號序列中的最近實際頻率動態地計算概率，以及改變編碼樹結構以匹配更新的概率估計。它在實踐中很少使用，因為更新樹的成本使其比優化的自適應算術編碼慢，後者更靈活並且具有更好的壓縮。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的自適應霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "在霍夫曼編碼的實現中，通常會使用權重表示數值概率，但是上面給出的算法不需要這樣;它只需要權重形成一個完全有序的可交換么半群，這意味著一種訂購權重和添加權重的方法。霍夫曼模板算法使人們能夠使用任何類型的權重（成本，頻率，權重對，非數字權重）和許多組合方法之一（不僅僅是加法），這個問題首先應用於電路設計。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的霍夫曼模板演算法", "Tag": "算法设计"}
{"Answer": "長度限制霍夫曼編碼[编辑]長度受限的霍夫曼編碼是一種變體，其目標仍然是實現最小加權路徑長度，但是存在另外的限制，即每個碼字的長度必須小於給定常數。包合併算法通過一種與霍夫曼演算法非常相似的簡單貪婪方法解決了這個問題。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的長度限制霍夫曼編碼/最小變異霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "長度受限的霍夫曼編碼是一種變體，其目標仍然是實現最小加權路徑長度，但是存在另外的限制，即每個碼字的長度必須小於給定常數。包合併算法通過一種與霍夫曼演算法非常相似的簡單貪婪方法解決了這個問題。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的長度限制霍夫曼編碼/最小變異霍夫曼編碼的長度限制霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "在標準的霍夫曼編碼問題中，假設集合中構成碼字的每個符號具有相同的傳輸成本：長度為N位的碼字總是具有N的成本，無論多少這些數字是0，有多少是1，等等。在這個假設下工作時，最小化消息的總成本和最小化數字總數是相同的。\n具有不等字母成本的霍夫曼編碼是沒有這種假設的概括：由於傳輸介質的特性，編碼字母表的字母可能具有不均勻的長度。一個例子是摩爾斯電碼的編碼字母表，其中'破折號'比'點'需要更長的發送時間，因此傳輸時間中破折號的成本更高。目標仍然是最小化加權平均碼字長度，但僅僅最小化消息使用的符號數量已經不夠了。沒有算法以與傳統霍夫曼編碼相同的方式或相同的效率來解決這個問題，儘管它已經由卡普（Karp）解決，其解決方案已經針對哥林（Golin）的整數成本的情況進行了改進。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的不相等成本霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "在標準霍夫曼編碼問題中，假設任何碼字可以對應於任何輸入符號。在字母表中，輸入和輸出的字母順序必須相同。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的最佳字母二元樹", "Tag": "算法设计"}
{"Answer": "如果對應於按字母順序排列的輸入的權重是按數字順序排列的，則霍夫曼代碼具有與最佳字母代碼相同的長度，這可以從計算這些長度中找到，從而不需要使用胡 - 塔克（Hu-Tucker）編碼。由數字（重新）有序輸入產生的代碼有時被稱為規範霍夫曼代碼，並且由於易於編碼/解碼，通常是實踐中使用的代碼。用於找到該代碼的技術有時被稱為霍夫曼 - 香農 - 法諾編碼，因為它像霍夫曼編碼一樣是最優的，但是在重量概率上是字母的，例如香農 - 法諾編碼。\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的變化的規範霍夫曼編碼", "Tag": "算法设计"}
{"Answer": "設符號集合\n  \n    \n      \n        S\n        =\n        \n          {\n          \n            \n              s\n              \n                1\n              \n            \n            ,\n            \n              s\n              \n                2\n              \n            \n            ,\n            ⋯\n            ,\n            \n              s\n              \n                n\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle S=\\left\\{s_{1},s_{2},\\cdots ,s_{n}\\right\\}}\n  \n，\n  \n    \n      \n        P\n        \n          (\n          \n            s\n            \n              j\n            \n          \n          )\n        \n      \n    \n    {\\displaystyle P\\left(s_{j}\\right)}\n  \n为\n  \n    \n      \n        \n          s\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle s_{j}}\n  \n發生的機率\n，\n  \n    \n      \n        L\n        \n          (\n          \n            s\n            \n              j\n            \n          \n          )\n        \n      \n    \n    {\\displaystyle L\\left(s_{j}\\right)}\n  \n为\n  \n    \n      \n        \n          s\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle s_{j}}\n  \n編碼的長度\n熵（Entropy）:亂度\n  \n    \n      \n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        −\n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            J\n          \n        \n        \n          P\n          \n            (\n            \n              s\n              \n                j\n              \n            \n            )\n          \n          ×\n          ln\n          ⁡\n          \n            P\n            \n              (\n              \n                s\n                \n                  j\n                \n              \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle entropy=-\\sum _{j=1}^{J}{P\\left(s_{j}\\right)\\times \\ln {P\\left(s_{j}\\right)}}}\n  \nex:\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        1\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        0\n      \n    \n    {\\displaystyle P(S_{0})=1,entropy=0}\n  \n\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            1\n          \n        \n        )\n        =\n        0.5\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        0.6931\n      \n    \n    {\\displaystyle P(S_{0})=P(S_{1})=0.5,entropy=0.6931}\n  \n\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            1\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            2\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            3\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            4\n          \n        \n        )\n        =\n        0.2\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        1.6094\n      \n    \n    {\\displaystyle P(S_{0})=P(S_{1})=P(S_{2})=P(S_{3})=P(S_{4})=0.2,entropy=1.6094}\n  \n\n\n  \n    \n      \n        P\n        (\n        \n          S\n          \n            0\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            1\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            2\n          \n        \n        )\n        =\n        P\n        (\n        \n          S\n          \n            3\n          \n        \n        )\n        =\n        0.1\n        ,\n        P\n        (\n        \n          S\n          \n            4\n          \n        \n        )\n        =\n        0.6\n        ,\n        e\n        n\n        t\n        r\n        o\n        p\n        y\n        =\n        1.2275\n      \n    \n    {\\displaystyle P(S_{0})=P(S_{1})=P(S_{2})=P(S_{3})=0.1,P(S_{4})=0.6,entropy=1.2275}\n  \n\n第三與第四個範例，同樣是五種組合，機率分布越集中，則亂度越少\n霍夫曼碼平均長度\n  \n    \n      \n        m\n        e\n        a\n        n\n        \n          (\n          L\n          )\n        \n        =\n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            J\n          \n        \n        \n          P\n          \n            (\n            \n              s\n              \n                j\n              \n            \n            )\n          \n          ×\n           \n          L\n          \n            (\n            \n              s\n              \n                j\n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle mean\\left(L\\right)=\\sum _{j=1}^{J}{P\\left(s_{j}\\right)\\times \\ L\\left(s_{j}\\right)}}\n  \n霍夫曼碼的長度Shannon編碼定理： \n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n ≤ \n  \n    \n      \n        m\n        e\n        a\n        n\n        \n          (\n          L\n          )\n        \n      \n    \n    {\\displaystyle mean\\left(L\\right)}\n  \n ≤ \n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n \n  \n    \n      \n        +\n        1\n      \n    \n    {\\displaystyle +1}\n  \n ，若使用\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n進位的編碼霍夫曼碼的平均編碼長度：設\n  \n    \n      \n        b\n        =\n        m\n        e\n        a\n        n\n        \n          (\n          L\n          )\n        \n        N\n      \n    \n    {\\displaystyle b=mean\\left(L\\right)N}\n  \n，\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n為資料長度\n\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n\n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n ≤ \n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n ≤ \n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n\n  \n    \n      \n        \n          e\n          n\n          t\n          r\n          o\n          p\n          y\n        \n        \n          l\n          o\n          g\n          k\n        \n      \n    \n    {\\displaystyle entropy \\over logk}\n  \n \n  \n    \n      \n        +\n        N\n      \n    \n    {\\displaystyle +N}\n  \n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的資料長度", "Tag": "算法设计"}
{"Answer": "霍夫曼樹常處理符號編寫工作。根據整組資料中符號出現的頻率高低，決定如何給符號編碼。如果符號出現的頻率越高，則給符號的碼越短，相反符號的號碼越長。假設我們要給一個英文單字\"F O R G E T\"進行霍夫曼編碼，而每個英文字母出現的頻率分別列在Fig.1。\n演算過程[编辑]（一）進行霍夫曼編碼前，我們先建立一個霍夫曼樹。\n⒈將每個英文字母依照出現頻率由小排到大，最小在左，如Fig.1。\n⒉每個字母都代表一個終端節點（葉節點），比較F.O.R.G.E.T六個字母中每個字母的出現頻率，將最小的兩個字母頻率相加合成一個新的節點。如Fig.2所示，發現F與O的頻率最小，故相加2+3=5。\n⒊比較5.R.G.E.T，發現R與G的頻率最小，故相加4+4=8。\n⒋比較5.8.E.T，發現5與E的頻率最小，故相加5+5=10。\n⒌比較8.10.T，發現8與T的頻率最小，故相加8+7=15。\n⒍最後剩10.15，沒有可以比較的對象，相加10+15=25。最後產生的樹狀圖就是霍夫曼樹，參考Fig.2。\n\n（二）進行編碼\n1.給霍夫曼樹的所有左鏈結'0'與右鏈結'1'。\n2.從樹根至樹葉依序記錄所有字母的編碼，如Fig.3。", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的問題定義與解法的範例", "Tag": "算法设计"}
{"Answer": "// 以下為C++程式碼，在G++下編譯通過\n// 僅用於示範如何根據權值建構霍夫曼樹，\n// 沒有經過性能上的優化及加上完善的異常處理。\n#include <cstdlib>\n#include <iostream>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nconst int size = 10;\nstruct node {                               // 霍夫曼樹節點結構\n    unsigned key;                           // 保存權值\n    node *lchild;                           // 左孩子指針\n    node *rchild;                           // 右孩子指針\n};\ndeque<node *> forest;\ndeque<bool> code;                           // 此處也可使用bitset\nnode *ptr;\nint frequency[size] = {0};\n\nvoid printCode(deque<bool> ptr);            // 用於輸出霍夫曼編碼\n\nbool compare( node *a, node *b) {\n    return a->key < b->key;\n}\nint main(int argc, char *argv[]) {\n    for (int i = 0; i < size; i++) {\n        cin >> frequency[i];                // 輸入10個權值\n        ptr = new node;\n        ptr->key = frequency[i];\n        ptr->lchild = NULL;\n        ptr->rchild = NULL;\n        forest.push_back(ptr);\n    } // 形成森林，森林中的每一棵樹都是一個節點\n    // 從森林構建霍夫曼樹\n    for (int i = 0; i < size - 1; i++) {\n        sort(forest.begin(), forest.end(), compare);\n        ptr = new node;\n        // 以下代碼使用下標索引隊列元素，具有潛在危險，使用時請注意\n        ptr->key = forest[0]->key + forest[1]->key;\n        ptr->lchild = forest[0];\n        ptr->rchild = forest[1];\n        forest.pop_front();\n        forest.pop_front();\n        forest.push_back(ptr);\n    }\n    ptr = forest.front(); // ptr是一個指向根的指針\n    system(\"PAUSE\");\n    return EXIT_SUCCESS;\n}\n\nvoid printCode(deque<bool> ptr) {\n    // deque<bool>\n    for (int i = 0; i < ptr.size(); i++) {\n        if (ptr[i])\n            cout << \"1\";\n        else\n            cout << \"0\";\n    }\n}\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的示範程式", "Tag": "算法设计"}
{"Answer": "huffman.h文件\n#ifndef __HUFFMAN_H__\n#define __HUFFMAN_H__\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define START printf(\"=====start=====\\n\")\n#define END printf(\"=====end=====\\n\")\n#define toByte(n) ((n) / 8 + ((n) % 8 > 0))\n\ntypedef struct HuffListNode HuffListNode,*hufflistnodep;\ntypedef struct HuffNode HuffNode,*huffnodep;\ntypedef struct HuffTree HuffTree,*hufftreep;\ntypedef struct HuffCode HuffCode,*huffcodep;\ntypedef struct HuffList HuffList,*hufflistp;\ntypedef struct HuffResult HuffResult,*huffresultp;\ntypedef struct HuffCode HuffBuf,*huffbufp;  //缓存类型\n\nstruct HuffListNode{\n    huffnodep node;     //huffman节点\n    hufflistnodep next; //后继节点\n};  //huffman频率节点\n\nstruct HuffList{\n    hufflistnodep head;         //头结点\n    int keys[256];              //键值字典\n    int size;                   //链表长度\n};\n\nstruct HuffNode{\n    int key;            //键\n    int weight;         //权重\n    huffnodep left;     //左节点\n    huffnodep right;    //右节点\n};  //huffman节点\n\nstruct HuffCode{\n    char* code; //huffman code\n    int size;   //huffman code size\n};\n\nstruct HuffTree{\n    huffnodep root;         //根\n    huffcodep codes[256];   //key对应的代码\n    int size;               //大小\n};  //huffman树\n\nstruct HuffResult{\n    char* code;      //生成的代码\n    hufftreep tree;  //对应的霍夫曼树\n};\n\n#ifndef __BOOLEAN__\n#define __BOOLEAN__\ntypedef enum{\n    FALSE = 0,\n    TRUE = 1,\n}Boolean;\n#endif\n\nhuffnodep huffnode(int key,int weight); //初始化huffman节点\nhufflistp hufflist();   //初始化hufflist\nBoolean insertHuffNode(hufflistp list,huffnodep node);  //向指定的节点链表添加一个节点\nhuffnodep shiftHuffNode(hufflistp list);    //删除第一个节点\nhufftreep hufftree(hufflistp list);   //构建一棵huffman tree\nhuffbufp getFileBuf(const char* filename); //获取文件的buf\nhufftreep genhuffcodes(hufftreep tree,huffnodep node,char codes[],int idx);  //获取当前节点之下的节点的huffman编码\nhufflistp getHuffListByFile(const char* filename); //根据文件创建huffman链表\nhufflistp getHuffListByBuf(huffbufp buf); //根据文件buf创建huffman链表\nhuffcodep getHuffCode(hufftreep tree,int key);  //获取指定键值的huffcode\nhuffresultp getHuffCodesByFile(const char* filename);     //获取文件的huffman code\nhuffresultp getHuffCodesByBuf(huffbufp buf);    //通过buf获取codes\nhuffbufp getOriginBuf(huffresultp result);       //从result中解析出原始的字符串\nhuffbufp str2bin(char* str); //二进制字符串转二进制数组\nint putOriginToFile(huffresultp result,const char* filename);   //将result存储到filename中\nchar* bin2str(huffbufp buf);    //二进制数组转二进制字符串\nhuffbufp readHuffFile(const char* filename); //解析huff文件\n#endif\nhuffman.c文件:\n#include \"huffman.h\"\n\nhuffnodep huffnode(int key,int weight){\n    huffnodep ret = (huffnodep)malloc(sizeof(HuffNode));\n    ret->key = key;\n    ret->weight = weight;\n    ret->left = ret->right = NULL;\n\n    return ret;\n}\n\nhufflistp hufflist(){\n    hufflistp ret = (hufflistp)malloc(sizeof(HuffList));\n    ret->head = NULL;\n    memset(ret->keys,0,sizeof(ret->keys[0])*256);\n    ret->size = 0;\n\n    return ret;\n}\n\nBoolean insertHuffNode(hufflistp list,huffnodep node){\n    if(list == NULL || node == NULL || node->weight <= -256) return FALSE;\n    hufflistnodep cur = list->head;\n    hufflistnodep* rootp = &(list->head);\n    hufflistnodep* last = NULL; //当前指针的前驱指针\n    hufflistnodep tmp = (hufflistnodep)malloc(sizeof(HuffListNode));\n    tmp->node = node;\n    tmp->next = NULL;\n    if(node->key >= 0 && node->key < 256){\n        list->keys[node->key] = node->weight;   //添加key到keys字典\n    }\n    list->size++;\n\n    for(;cur != NULL  && cur->node->weight < node->weight; cur = cur->next){\n        last = rootp;\n        rootp = &(cur->next);\n    }\n\n    tmp->next = cur;\n    if(last == NULL){   //第一个元素\n        list->head = tmp;\n    }else{  //向当前节点前面插入tmp节点\n        (*last)->next = tmp;\n    }\n\n    return TRUE;\n}\n\nhuffnodep shiftHuffNode(hufflistp list){\n    if(list == NULL || list->head == NULL) return NULL;\n    huffnodep ret = list->head->node;\n    hufflistnodep next = list->head->next;\n    free(list->head);\n    list->head = next;\n    list->size--;\n\n    return ret;\n}\n\n//通过huffman list构建\nhufftreep hufftree(hufflistp list){\n    hufftreep tree = (hufftreep)malloc(sizeof(HuffTree));\n    tree->root = NULL;\n    tree->size = 0;\n    memset(tree->codes,0,sizeof(tree->codes));\n\n    huffnodep a = NULL;\n    huffnodep b = NULL;\n    huffnodep c = NULL;\n    tree->size = 2 * list->size - 1;\n    while(list->size > 1){  //hufflistp长度大于1\n        a = shiftHuffNode(list);\n        b = shiftHuffNode(list);\n        c = huffnode(-256,a->weight+b->weight);    //新的节点\n        c->left = a;\n        c->right = b;\n        insertHuffNode(list,c); //将c压回list\n    }\n    tree->root = c;\n\n    //生成所有key的huffman编码\n    char codes[8092];   //huffman编辑路径\n\n    return genhuffcodes(tree,tree->root,codes,0);\n}\n\n//获取文件内容的BUF\nhuffbufp getFileBuf(const char* filename){\n    FILE* fp = fopen(filename,\"r\");\n    if(fp == NULL) return NULL;\n    fseek(fp,0L,SEEK_END);\n    int len = ftell(fp);\n    rewind(fp); //重设\n    huffbufp ret = (huffbufp)malloc(sizeof(HuffBuf));\n    ret->code = (char*)malloc(len+1);\n    ret->size = len;\n    fread(ret->code,1,len,fp);\n    fclose(fp);\n\n    return ret;\n}\n\nhufftreep genhuffcodes(hufftreep tree,huffnodep node,char codes[],int idx){\n    if(tree == NULL || node == NULL){   //到达底部\n        return NULL;\n    }\n\n    if(node->left == NULL && node->right == NULL){  //叶子节点\n        int key = node->key;\n        huffcodep code = (huffcodep)malloc(sizeof(HuffCode));\n        code->code = (char*)malloc(idx+1);\n        code->size = idx;\n        memcpy(code->code,codes,code->size);\n        code->code[code->size] = '\\0';\n        tree->codes[key] = code;\n    }{\n        codes[idx] = '1'; //右\n        genhuffcodes(tree,node->right,codes,idx+1);\n        codes[idx] = '0'; //左\n        genhuffcodes(tree,node->left,codes,idx+1);\n    }\n\n    return tree;\n}\n\n//通过文件生成huffman list\nhufflistp getHuffListByFile(const char* filename){\n    huffbufp buf = getFileBuf(filename);\n    if(buf == NULL) return NULL;\n\n    hufflistp list = getHuffListByBuf(buf);\n    free(buf->code);\n    buf->code = NULL;\n    free(buf);\n    buf = NULL;\n\n    return list;\n}\n\nhufflistp getHuffListByBuf(huffbufp buf){\n    if(buf == NULL || buf->code == NULL) return NULL;\n\n    char* code = buf->code;\n\n    hufflistp list = hufflist();\n    for(int i = 0; code[i] != '\\0'; i++){\n        unsigned char ch = code[i];\n        list->keys[ch]++;\n    }\n\n    for(int i = 0; i < 256; i++){\n        if(list->keys[i] > 0){   //插入存在的字符\n            insertHuffNode(list,huffnode(i,list->keys[i]));\n        }\n    }\n\n    return list;\n}\n\nhuffcodep getHuffCode(hufftreep tree,int key){\n    if(key < 256 && key >= 0 && tree->codes[key] > 0){\n        return tree->codes[key];\n    }\n    return NULL;\n}\n\nhuffresultp getHuffCodesByFile(const char* filename){\n    huffbufp buf = getFileBuf(filename);   //文件缓存\n    return getHuffCodesByBuf(buf);\n}\n\nhuffresultp getHuffCodesByBuf(huffbufp buf){\n    huffresultp result = (huffresultp)malloc(sizeof(HuffResult));\n    result->code = NULL;\n\n    if(buf == NULL) return NULL;\n\n    hufflistp list = getHuffListByBuf(buf); //huffman list\n\n    result->tree = hufftree(list);\n    int buf_len = buf->size;\n    int len = 0;\n    for(int i = 0; buf->code[i] != '\\0'; i++){\n        int key = (unsigned char)buf->code[i];\n        huffcodep code = getHuffCode(result->tree,key);\n        if(code == NULL){\n            printf(\"LLL:%c{%d}\\n\",key,key);\n            return NULL;\n        }\n        len+=code->size;\n    }\n    result->code = (char*)malloc(len+1);\n    result->code[0] = '\\0';\n    for(int i = 0; buf->code[i] != '\\0'; i++){\n        unsigned char key = buf->code[i];\n        huffcodep code = getHuffCode(result->tree,key);\n        strncat(result->code,code->code,code->size);\n    }\n\n    return result;\n}\n\nhuffbufp getOriginBuf(huffresultp result){\n    if(result == NULL || result->code == NULL || result->tree == NULL) return NULL;\n    hufftreep tree = result->tree;\n    char* code = result->code;\n    int len = 0;\n    for(int i = 0; code[i] != '\\0';){\n        huffnodep root = tree->root;    //根节点\n        while(root->left != NULL && root->right != NULL && code[i] != '\\0'){   //双子节点存在\n            root = (code[i] == '0' ? root->left : root->right);\n            i++;\n        }\n        if((root->left != NULL || root->right != NULL) && code[i] == '\\0'){ //错误\n            return NULL;\n        }\n        len++;\n        // printf(\"解析:%c{%s}\\n\",root->key,tree->codes[root->key]->code);\n    }\n\n    huffbufp ret = (huffbufp)malloc(sizeof(HuffBuf));\n    ret->code = (char*)malloc(len+1);\n    ret->code[0] = '\\0';\n    ret->size = len;\n\n    int idx = 0;\n    for(int i = 0; code[i] != '\\0';){\n        huffnodep root = tree->root;    //根节点\n        while(root->left != NULL && root->right != NULL && code[i] != '\\0'){   //双子节点存在\n            root = (code[i] == '0' ? root->left : root->right);\n            i++;\n        }\n        ret->code[idx++] = root->key;\n    }\n    ret->code[idx] = '\\0';\n\n    return ret;\n}\n\nint putOriginToFile(huffresultp result,const char* filename){\n    if(result == NULL) return 0;\n    // printf(\"res1[%d]:%s\\n\",(int)strlen(result->code),result->code);\n    // huffbufp b = str2bin(result->code);\n    // printf(\"%d\\n\",b->size);\n    // printf(\"res2:%s\\n\",bin2str(b));\n    // return 0;\n\n    huffbufp buf = str2bin(result->code);   //huffman code转成buf\n    int i = 0;\n    int len = 0;    \n    for(i = 0; i < 256; i++){\n        if(result->tree->codes[i] > 0){ //\n            len+= 5+result->tree->codes[i]->size;   //key[1]:len[4]:size\n        }\n    }\n    huffbufp keys = (huffbufp)malloc(sizeof(HuffBuf));\n    keys->code = (char*)malloc(len);\n    keys->size = 0;\n    //获取keys\n    int idx = 0;\n    for(i = 0; i < 256; i++){\n        if(result->tree->codes[i] > 0){ //\n            keys->code[idx++] = i;    //key\n            int len = result->tree->codes[i]->size;\n            memcpy(keys->code+idx,&len,4);    //key size\n            // printf(\"%c[%d]:%d{%s}\\n\",i,i,len,result->tree->codes[i]->code);\n            idx+=4;\n            huffbufp tmp = str2bin(result->tree->codes[i]->code);\n            // printf(\"%d,%d\\n\",tmp->code[0],tmp->size);\n            int tsize = toByte(tmp->size);\n            memcpy(keys->code+idx,tmp->code,tsize);\n            idx+=tsize;\n        }\n    }\n\n    keys->size = idx;   //诸多键的总空间\n    \n    //写出标准文件\n    //HUF\\n\n    //size: 4b\n    //keys\n    //size: 4b\n    //codes\n    FILE* fp = fopen(filename,\"w\");\n    if(fp == NULL) return -1;\n    fwrite(\"HUF\\n\",1,4,fp);\n    fwrite(&idx,1,4,fp);    //size\n    fwrite(keys->code,1,keys->size,fp); //写入code\n    fwrite(&(buf->size),1,4,fp);    //size\n    fwrite(buf->code,1,toByte(buf->size),fp);\n    fclose(fp);\n\n    return 4+4+keys->size+4+buf->size;\n}\n\n\nhuffbufp str2bin(char* str){ //二进制字符串转二进制数组\n    // printf(\"bin:%s\\n\",str);\n    if(str == NULL) return NULL;\n    huffbufp buf = (huffbufp)malloc(sizeof(HuffBuf));\n    int l = strlen(str);\n    int size = (l / 8) + (l % 8 > 0);\n\n    buf->code = (char*)malloc(l);\n    memset(buf->code,0,l);\n    for(int i = 0; i < l; i++){\n        int idx = i/8;\n        int bi = i%8;\n        buf->code[idx] |= (str[i] == '0' ? 0:1) << bi;\n    }\n    buf->size = l;\n\n    return buf;\n}\n\nchar* bin2str(huffbufp buf){\n    char* ret = (char*)malloc(buf->size+1);\n    for(int i = 0; i < buf->size; i++){\n        int idx = i / 8;\n        int offset = i % 8;\n        ret[i] = (buf->code[idx] & (0x01 << offset)) ? '1' : '0';\n    }\n    ret[buf->size] = '\\0';\n\n    return ret;\n}\n\nhuffbufp readHuffFile(const char* filename){\n    huffbufp buf = getFileBuf(filename);\n    if(buf == NULL) return NULL;\n\n    if(memcmp(buf->code,\"HUF\\n\",4) != 0) return NULL;   //文件不以BUF\\n开头\n    huffresultp result = (huffresultp)malloc(sizeof(HuffResult));\n    //BUF\\n\n    //key size\n    int key_size = *(int*)(buf->code+4);\n    int base = 8; //偏移量\n    hufftreep tree = (hufftreep)malloc(sizeof(HuffTree));\n    tree->root = NULL;\n    tree->size = 0;\n    huffcodep* codes = tree->codes;   //key对应代码\n    memset(codes,0,sizeof(huffcodep)*256);\n    \n    int oft = 0;\n    for(;oft < key_size;){\n        int offset = base+oft;\n        unsigned char key = buf->code[offset];\n        // printf(\"%d[%c]\\n\",key,key);\n        int size = *(int*)(buf->code+offset+1); //长度\n        int byte = toByte(size);\n        huffbufp htmp = (huffbufp)malloc(sizeof(HuffBuf));\n        //键对应代码\n        htmp->code = buf->code+offset+5;    //缓存代码\n        htmp->size = size;  //缓存大小\n        // printf(\"[%c]%d\\n\",key,key);\n        huffcodep tmp = (huffcodep)malloc(sizeof(HuffCode));\n        tmp->size = size;   //key的大小\n        tmp->code = bin2str(htmp);\n        tree->codes[key] = tmp;\n        tree->size++;   //树的大小增加\n        huffnodep root = tree->root;\n        if(root == NULL){\n            tree->root = huffnode(-256,0);\n            root = tree->root;\n        }\n        for(int i = 0; i < tmp->size; i++){\n            char ch = tmp->code[i];\n            huffnodep node = NULL;\n            if(ch == '0'){\n                node = root->left;\n                if(node == NULL){\n                    node = huffnode(-256,0);\n                }\n                root->left = node;\n            }else{\n                node = root->right;\n                if(node == NULL){\n                    node = huffnode(-256,0);\n                }\n                root->right = node;\n            }\n            if(i == tmp->size - 1)\n                node->key = key;\n            root = node;\n        }\n        oft+=5+byte;\n    }\n\n    huffbufp tmp = (huffbufp)malloc(sizeof(HuffBuf));\n    tmp->code = buf->code+base+oft+4;\n    tmp->size = *(int*)(buf->code+base+oft);\n    // printf(\"tmp size:%d\\n\",tmp->size);\n    result->tree = tree;\n    result->code = bin2str(tmp);\n    // printf(\"%s\\n\",result->code);\n\n    // for(int i = 0; i < 256; i++){\n    //     if(codes[i]!=NULL){\n    //         printf(\"%c[%d]:%s\\n\",i,i,codes[i]->code);\n    //     }\n    // }\n\n    return getOriginBuf(result);\n}\n程序演示主文件:\n#include\"huffman.h\"\n\nint main(){\n    huffbufp buf = (huffbufp)malloc(sizeof(HuffBuf));\n\n    buf->code = \"this is just a test!\";\n    buf->size = strlen(buf->code);\n    huffresultp result = getHuffCodesByBuf(buf);    //获取编码结果\n    printf(\"huffman: %s\\n\",result->code);\n\n    huffbufp origin = getOriginBuf(result); //通过编码获取原始数据\n    printf(\"origin: %s\\n\",origin->code);\n\n    return 0;\n}\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的霍夫曼编码C代码", "Tag": "算法设计"}
{"Answer": "\nThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. .mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:\"\\\"\"\"\\\"\"\"'\"\"'\"}.mw-parser-output .citation .cs1-lock-free a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url(\"//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png\")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}ISBN 0-262-03293-7. Section 16.3, pp. 385–392.\n", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的參考文獻", "Tag": "算法设计"}
{"Answer": "有關霍夫曼壓縮技術的原文：D.A. Huffman, \"A method for the construction of minimum-redundancy codes\", Proceedings of the I.R.E., sept 1952, pp 1098-1102\n霍夫曼树图形演示 （页面存档备份，存于互联网档案馆）\nAnimation of the Huffman Algorithm: Algorithm Simulation by Simon Mescal\nBackground story: Profile: David A. Huffman, Scientific American, Sept. 1991, pp. 54-58\nn-ary Huffman Template Algorithm\nHuffman codes' connection with Fibonacci and Lucas numbers （页面存档备份，存于互联网档案馆）\nFibonacci connection between Huffman codes and Wythoff array\nSloane A098950 Minimizing k-ordered sequences of maximum height Huffman tree\nComputing Huffman codes on a Turing Machine\nMordecai J. Golin, Claire Kenyon, Neal E. Young \"Huffman coding with unequal letter costs （页面存档备份，存于互联网档案馆）\", STOC 2002 （页面存档备份，存于互联网档案馆）: 785-791\nHuffman Coding, implemented in python", "Konwledge_Point": "霍夫曼编码", "Question": "什么是霍夫曼编码的外部連結", "Tag": "算法设计"}
