{"Answer": "二分图最佳带權匹配问题是指在给定带权二分图上求出一个最大匹配的问题，使得所有匹配边权值之和最大。这个问题也被称为二分图最优匹配。[1]\n此类问题通常使用KM算法或转换为一个网络费用流问题进行求解。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配", "Tag": "算法设计"}
{"Answer": "一个带权二分图 \n  \n    \n      \n        G\n        =\n        (\n        X\n        ,\n        Y\n        ,\n        E\n        )\n      \n    \n    {\\displaystyle G=(X,Y,E)}\n  \n 中的边 \n  \n    \n      \n        (\n        u\n        ,\n        v\n        )\n        ∈\n        E\n      \n    \n    {\\displaystyle (u,v)\\in E}\n  \n 都带有一个权值 \n  \n    \n      \n        f\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle f(u,v)}\n  \n。该二分图的一个最佳带权匹配是它所有匹配中，所有匹配边权值之和中最大的一个。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的定义", "Tag": "算法设计"}
{"Answer": "KM算法[编辑]直接使用KM算法求解。\n最小费用最大流[编辑]通过建立模型，使用费用流算法解决。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的求解方法", "Tag": "算法设计"}
{"Answer": "直接使用KM算法求解。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的求解方法的KM算法", "Tag": "算法设计"}
{"Answer": "通过建立模型，使用费用流算法解决。\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的求解方法的最小费用最大流", "Tag": "算法设计"}
{"Answer": "C++[编辑]#include <cstdio>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint const MAX = 1000;\nint const inf = INT_MAX;\n\nint w[MAX][MAX];\nint link[MAX];//代表当前与Y集合中配对的X集合中的点\nint visx[MAX], visy[MAX];\nint lx[MAX], ly[MAX];\nint n, m;//代表X和Y中元素的个数\n \nint can(int t)\n{\n    visx[t] = 1;\n    for(int i = 1; i <= m; i++){\n        if(!visy[i] && lx[t] + ly[i] == w[t][i]){//这里“lx[t]+ly[i]==w[t][i]”决定了这是在相等子图中找增广路的前提，非常重要\n            visy[i] = 1;\n            if(link[i] == -1 || can(link[i])){\n                link[i] = t;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint km(void)\n{\n    int sum = 0; memset(ly, 0, sizeof(ly));\n    for(int i = 1; i <= n; i++){//把各个lx的值都设为当前w[i][j]的最大值\n        lx[i] = -inf;\n        for(int j = 1; j <= n; j++){\n            if(lx[i] < w[i][j])\n                lx[i] = w[i][j];\n        }\n    }\n\n    memset(link, -1, sizeof(link));\n    for(int i = 1; i <= n; i++){\n        while(1){\n            memset(visx, 0, sizeof(visx));\n            memset(visy, 0, sizeof(visy));\n            if(can(i))//如果它能够形成一条增广路径，那么就break\n                break;\n            int d = inf;//否则，后面应该加入新的边,这里应该先计算d值\n            for(int j = 1; j <= n; j++)//对于搜索过的路径上的XY点，设该路径上的X顶点集为S，Y顶点集为T，对所有在S中的点xi及不在T中的点yj\n                if(visx[j])\n                    for(int k = 1; k <= m; k++)\n                       if(!visy[k])\n                            d = min(d, lx[j] + ly[k] - w[j][k]);\n            if(d == inf)\n            return -1;//找不到可以加入的边，返回失败（即找不到完美匹配）\n            for (int j = 1; j <= n; j++)\n                if (visx[j])\n                    lx[j] -= d;\n            for(int j = 1; j <= m; j++)\n                if(visy[j])\n                    ly[j] += d;\n            }\n    }\n    for(int i = 1; i <= m; i++)\n        if(link[i] > -1)\n            sum += w[link[i]][i];\n    return sum;\n}\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的参考程序", "Tag": "算法设计"}
{"Answer": "#include <cstdio>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint const MAX = 1000;\nint const inf = INT_MAX;\n\nint w[MAX][MAX];\nint link[MAX];//代表当前与Y集合中配对的X集合中的点\nint visx[MAX], visy[MAX];\nint lx[MAX], ly[MAX];\nint n, m;//代表X和Y中元素的个数\n \nint can(int t)\n{\n    visx[t] = 1;\n    for(int i = 1; i <= m; i++){\n        if(!visy[i] && lx[t] + ly[i] == w[t][i]){//这里“lx[t]+ly[i]==w[t][i]”决定了这是在相等子图中找增广路的前提，非常重要\n            visy[i] = 1;\n            if(link[i] == -1 || can(link[i])){\n                link[i] = t;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint km(void)\n{\n    int sum = 0; memset(ly, 0, sizeof(ly));\n    for(int i = 1; i <= n; i++){//把各个lx的值都设为当前w[i][j]的最大值\n        lx[i] = -inf;\n        for(int j = 1; j <= n; j++){\n            if(lx[i] < w[i][j])\n                lx[i] = w[i][j];\n        }\n    }\n\n    memset(link, -1, sizeof(link));\n    for(int i = 1; i <= n; i++){\n        while(1){\n            memset(visx, 0, sizeof(visx));\n            memset(visy, 0, sizeof(visy));\n            if(can(i))//如果它能够形成一条增广路径，那么就break\n                break;\n            int d = inf;//否则，后面应该加入新的边,这里应该先计算d值\n            for(int j = 1; j <= n; j++)//对于搜索过的路径上的XY点，设该路径上的X顶点集为S，Y顶点集为T，对所有在S中的点xi及不在T中的点yj\n                if(visx[j])\n                    for(int k = 1; k <= m; k++)\n                       if(!visy[k])\n                            d = min(d, lx[j] + ly[k] - w[j][k]);\n            if(d == inf)\n            return -1;//找不到可以加入的边，返回失败（即找不到完美匹配）\n            for (int j = 1; j <= n; j++)\n                if (visx[j])\n                    lx[j] -= d;\n            for(int j = 1; j <= m; j++)\n                if(visy[j])\n                    ly[j] += d;\n            }\n    }\n    for(int i = 1; i <= m; i++)\n        if(link[i] > -1)\n            sum += w[link[i]][i];\n    return sum;\n}\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的参考程序的C++", "Tag": "算法设计"}
{"Answer": "\n\n^ 李煜东. suan fa jing sai jing jie zhi nan. zhong yuan chu ban chuang mei ji tuan - he nan dian zi ying xiang chu ban she. ISBN 978-7-89388-198-5. \n\n", "Konwledge_Point": "二分图最佳带权匹配", "Question": "什么是二分图最佳带权匹配的参考文献", "Tag": "算法设计"}
