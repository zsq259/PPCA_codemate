{"Answer": "在计算机科学中，分治法（英語：Divide and conquer）是建基於多項分支遞歸的一种很重要的算法範式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。\n这个技巧是很多高效算法的基础，如排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）。\n另一方面，理解及設計分治法算法的能力需要一定時間去掌握。正如以歸納法去證明一個理論，為了使遞歸能夠推行，很多時候需要用一個較為概括或複雜的問題去取代原有問題。而且並沒有一個系統性的方法去適當地概括問題。\n分治法這個名稱有時亦會用於將問題簡化為只有一個細問題的算法，例如用於在已排序的列中尋找其中一項的折半搜索算法（或是在數值分析中類似的勘根算法）。這些算法比一般的分治算法更能有效地執行。其中，假如算法使用尾部遞歸的話，便能轉換成簡單的迴圈。但在這廣義之下，所有使用遞歸或迴圈的算法均被視作「分治算法」。因此，有些作者考慮「分治法」這個名稱應只用於每個有最少兩個子問題的算法。而只有一個子問題的曾被建議使用減治法這個名稱。\n分治算法通常以數學歸納法來驗證。而它的計算成本則多數以解遞迴關係式來判定。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法", "Tag": "算法设计"}
{"Answer": "折半搜索算法——一個將原來問題連逐地拆細成大約一半大小的單一子問題的分治算法——擁有一段悠長歴史。雖然算法在計算機上的清楚描述出現在1946年約翰莫齊利（John Mauchly）的一篇文章裡，然而利用已排序的物件序列去加快搜尋的構想早已在公元前200年的巴比倫尼亞出現。另一個單一子問題的分治算法是找出2個數的最大公因數的輾轉相除法（透過將數字化小至使子問題變得簡單），於公元前數世紀已經出現。\n一個早期有多個子問題的分治算法是高斯在1805年描述關於快速傅立葉变换的算法，儘管他沒有量化地分析它的操作數目，而快速傅立葉变换直至在一世紀之後被重新發現之前亦沒有廣泛流傳。這個算法現在稱為库利－图基快速傅里叶变换算法。\n至於專門用於計算機之上而且正確地分析的分治算法早期例子，則可以數到约翰·冯·诺伊曼於1945年發明的歸並排序。\n另一個顯著的例子是Anatolii Alexeevitch Karatsuba於1960年發明在\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            \n              log\n              \n                2\n              \n            \n            ⁡\n            3\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{\\log _{2}3})}\n  \n步驟內將兩個n位數相乘的Karatsuba算法。它反證了安德雷·柯爾莫哥洛夫於1956年認為這個乘法需要\n  \n    \n      \n        Ω\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle \\Omega (n^{2})}\n  \n步驟的猜想。\n高德納舉了一個最初並沒有涉及計算機的分治算法例子，就是一般郵局用於分發信件的方法：信件在主要郵局根據不同的地理範圍而分到不同的袋裡，每個袋亦在運送到地區郵局時分到更小的袋裡，如是者直至信件被派發為止。這個方法與早於1929年的打孔卡排序機所用的基数排序相類同。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的早期历史上的先例", "Tag": "算法设计"}
{"Answer": "解决困难问题[编辑]分治算法是一个解决复杂问题的好工具，它可以把问题分解成若干个子问题，把子问题逐个解决，再组合到一起形成大问题的答案。比如，汉诺塔问题如果采用分治算法，可以把高度为n的塔的问题转换成高度为n-1的塔来解决，如此重复，直至问题化简到可以很容易的处理为止。\n算法效率[编辑]人们发现有很多效率很高的分治算法，比如，Karatsuba快速乘法算法、快速排序算法和并行算法、矩阵乘法的施特拉森演算法、快速傅里叶变换等。\n同步性[编辑]修正控制[编辑]", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势", "Tag": "算法设计"}
{"Answer": "分治算法是一个解决复杂问题的好工具，它可以把问题分解成若干个子问题，把子问题逐个解决，再组合到一起形成大问题的答案。比如，汉诺塔问题如果采用分治算法，可以把高度为n的塔的问题转换成高度为n-1的塔来解决，如此重复，直至问题化简到可以很容易的处理为止。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的解决困难问题", "Tag": "算法设计"}
{"Answer": "人们发现有很多效率很高的分治算法，比如，Karatsuba快速乘法算法、快速排序算法和并行算法、矩阵乘法的施特拉森演算法、快速傅里叶变换等。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的算法效率", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的同步性", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "分治法", "Question": "什么是分治法的优势的修正控制", "Tag": "算法设计"}
{"Answer": "循环递归[编辑]在每一层递归上都有三个步骤：\n分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题。\n解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题。\n合并：将各子问题的解合并为原问题的解。显堆栈[编辑]", "Konwledge_Point": "分治法", "Question": "什么是分治法的实现", "Tag": "算法设计"}
{"Answer": "在每一层递归上都有三个步骤：\n分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题。\n解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题。\n合并：将各子问题的解合并为原问题的解。", "Konwledge_Point": "分治法", "Question": "什么是分治法的实现的循环递归", "Tag": "算法设计"}
{"Answer": "", "Konwledge_Point": "分治法", "Question": "什么是分治法的实现的显堆栈", "Tag": "算法设计"}
{"Answer": "分治法在高级语言中主要的一个思想是递归，LISP语言中的体现出了极丰富的分治法。\n以下是归并排序C语言的示例代码，输入参数中，需要排序的数组为array[],起始索引为first，终止索引为last。调用完成后，array[]中从first到last处于升序排列。\n void merge_sort(int array[], unsigned int first, unsigned int last)\n {\n \tint mid = 0;\n \tif(first<last)\n \t{\n \t\tmid = (first+last)/2;\n \t\tmerge_sort(array, first, mid);\n \t\tmerge_sort(array, mid+1,last);\n \t\tmerge(array,first,mid,last);\n \t}\n }\n在程式中可以看出分治法的應用：在merge_sort()中，將原來針對索引first到last的數組排序的問題，分為二份較小的問題\n先針對索引first到mid的數組排序。\n再針對索引mid+1到last的數組排序。最後再進行二個數組的合併。\n", "Konwledge_Point": "分治法", "Question": "什么是分治法的示例", "Tag": "算法设计"}
{"Answer": "分叉会合模型", "Konwledge_Point": "分治法", "Question": "什么是分治法的参见", "Tag": "算法设计"}
