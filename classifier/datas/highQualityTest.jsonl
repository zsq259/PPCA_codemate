{"Answer": "因为列表是引用数据类型，这是浅复制。浅复制分析：python列表的浅复制对于列表中存在可变的可迭代对象如列表，集合，字典这样的存在也是引用的原对象的地址空间，所以会一同改变。对于列表中存在的数值型数据浅复制会直接创建新的地址空间用以保存。", "Knowledge_Point": "程序设计", "Question": "关于python中List赋值的问题学习python时，有发现如下问题，不是很明白其赋值原理，请各位帮忙解答一下，谢谢！1.如上代码\n\n个人感觉\"result\"应该是“nameList”的初始数据，为什么将“nameList”数据修改后，“result”的数据也随之改变？2.如上代码\n\n为什么“print（result）”的结果直接是“None”？", "Tag": "程序设计"}
{"Answer": "初始化可以像你这样，但是除了初始化之外，后面数组名是一个常量，不能赋值", "Knowledge_Point": "程序设计", "Question": "为什么不可以在赋值语句中通过赋值运算符“＝”对字符数组整体赋值下述对C语言字符数组的描述中错误的是 (c )\n\nA．字符数组可以存放字符串\nB．字符数组中的字符串可以整体输入、输出\nC．可以在赋值语句中通过赋值运算符“＝”对字符数组整体赋值\nD．不可以用关系运算符对字符数组中的字符串进行比较\n\n为啥c是错的嘞？\n\n难道s[10]={\"happy\"}这样 的语句不算是通过赋值运算符“＝”对字符数组整体赋值吗？", "Tag": "程序设计"}
{"Answer": "已经定义完毕后操作，是赋值。定义的时候是初始化", "Knowledge_Point": "程序设计", "Question": "C++ 关于赋值运算符的概念性问题今天学习，C++ Primer 书中有这么几句话\n赋值运算符的左侧运算对象必须是一个可修改的左值。int i = 0;const int ci = i;    //初始化而非赋值\n首先初始化和赋值的区别我还是了解的，但不解的在于 const int ci = i;  这里。等号左边是一个不可修改的左值，不满足“赋值运算符的左侧运算对象必须是一个可修改的左值”，说明初始化语句里的等号不是赋值运算符。在我以往的认知里 ’=‘ 就是赋值运算符，赋值运算符就是 ’=‘ ，现在推导出 初始化语句里的等号不是赋值运算符感觉怪怪的。", "Tag": "程序设计"}
{"Answer": "可以通过以下几个方面来提高告警的有效性：\n确定告警的优先级，对于重要的告警及时处理，避免漏报或误报。对告警进行分类，便于快速定位问题，提高处理效率。建立告警处理流程，明确责任人和处理时间，避免漏报或延误。对告警进行监控和分析，及时发现问题并进行优化，提高系统的稳定性和可靠性。", "Knowledge_Point": "程序设计", "Question": "如何提高告警的有效性？监控能力建设过程中，监控指标会越来越全面，产生的告警、预警信息也更为丰富，但是大量的告警似乎不能提高运维的效率，因为需要有效处理的告警比例在降低，请问如何提高告警的有效性，或者怎么样突出告警的优先级和相关性？", "Tag": "程序设计"}
{"Answer": "你新建的是txt，不是cpp\r\n\r\n文件，新建项目，新建一个vc++控制台项目，然后编写代码", "Knowledge_Point": "程序设计", "Question": "Microsoft Visual Studio 2019无法启动程序，系统找不到指定的文件按照书上用Microsoft Visual Studio 2019编写了一个C程序。点击调试的时候报错，显示：\n\n无法启动程序“C：【路径】。“系统找不到指定的文件\n是我的代码出问题了还是什么原因？\n\n", "Tag": "程序设计"}
{"Answer": "可以这么理解，因为a,b,c存储的地址都不一样.而且a，b为f函数内变量，f函数结束调用就释放掉了.\n举个简单的例子题主试试\nvoid f(int b,int c){\n    int tmp = b;\n    b = c;\n    c = tmp;\n}\nf(a，b);\n\n输出下a，b看看值有没有交换", "Knowledge_Point": "程序设计", "Question": "结构体变量和结构体指针作参数为什么一个实参不变，一个变？在结构体变量作参数的时候，c的值在主函数经过调用后再输出，没有变化。可以认为函数f的参数a，f内定义的变量b，和主函数内定义的变量c是相互独立的吗？c的值传递给a，b的值赋值给a，但是c不变，这样理解对吗？\n\n但是结构体指针作参数时主函数中定义的结构体变量c却发生了变化。c的地址传递给a，b的值赋值给a，这里的a能代表c吗？\n", "Tag": "程序设计"}
{"Answer": "这里提示： Field 'remarks' doesn't have a default value没有填入默认值的地方，没有插入元素你把这个字段'remarks'需要插入值，或者你修改一下'remarks'默认值", "Knowledge_Point": "程序设计", "Question": "kettle输出数据一直报这个错误，怎么百度都查不明白2022/10/25 18:29:30 - dwd表输出本地mysql.0 - ERROR (version 8.2.0.0-342, build 8.2.0.0-342 from 2018-11-14 10.30.55 by buildguy) : Because of an error, this step can't continue:2022/10/25 18:29:30 - dwd表输出本地mysql.0 - ERROR (version 8.2.0.0-342, build 8.2.0.0-342 from 2018-11-14 10.30.55 by buildguy) : org.pentaho.di.core.exception.KettleException:2022/10/25 18:29:30 - dwd表输出本地mysql.0 - Error batch inserting rows into table [dwd_f_index_date].2022/10/25 18:29:30 - dwd表输出本地mysql.0 - Errors encountered (first 10):2022/10/25 18:29:30 - dwd表输出本地mysql.0 -2022/10/25 18:29:30 - dwd表输出本地mysql.0 -2022/10/25 18:29:30 - dwd表输出本地mysql.0 - Error updating batch2022/10/25 18:29:30 - dwd表输出本地mysql.0 - Field 'remarks' doesn't have a default value2022/10/25 18:29:30 - dwd表输出本地mysql.0 -2022/10/25 18:29:30 - dwd表输出本地mysql.0 -2022/10/25 18:29:30 - dwd表输出本地mysql.0 -     at org.pentaho.di.trans.steps.tableoutput.TableOutput.writeToTable(TableOutput.java:348)2022/10/25 18:29:30 - dwd表输出本地mysql.0 -     at org.pentaho.di.trans.steps.tableoutput.TableOutput.processRow(TableOutput.java:125)2022/10/25 18:29:30 - dwd表输出本地mysql.0 -     at org.pentaho.di.trans.step.RunThread.run(RunThread.java:62)2022/10/25 18:29:30 - dwd表输出本地mysql.0 -     at java.lang.Thread.run(Thread.java:748)2022/10/25 18:29:30 - dwd表输出本地mysql.0 - Caused by: org.pentaho.di.core.exception.KettleDatabaseBatchException:2022/10/25 18:29:30 - dwd表输出本地mysql.0 - Error updating batch2022/10/25 18:29:30 - dwd表输出本地mysql.0 - Field 'remarks' doesn't have a default value2022/10/25 18:\n", "Tag": "程序设计"}
{"Answer": "\n\n#include <stdio.h>\nint main()\n{\n    int m,n;\n    int power(int a,int b);\n    scanf(\"%d %d\",&m,&n);\n    printf(\"%d\",power(m,n));\n}\nint power(int a,int b)\n{\n    int t;\n    if(b==1)\n    t=a;\n    else\n    t=a*power(a,b-1);\n    return(t);\n}\n", "Knowledge_Point": "程序设计", "Question": "c语言计算m的n次方依次输出键盘输入正整数m和n,然后求出m的0次方一直到m的 n次方，\n输入两个整数，逗号分隔，分别给 变量m和n\n输出共n行，每行一个乘方公式，从0次方到n次方\n输入:5,3输出pow(5,0)=1pow(5,1)=5pow(5,2)=25pow(5,3)=125", "Tag": "程序设计"}
{"Answer": "如果对于奖金部分题意理解没有错误，下面是一个实现：\n#include <stdio.h>  //printf函数头文件 \n\nint main(void){   //程序入口程序main函数 \n    \n    double baseMoney = 1000;  //基本工资 \n    double allMoney = 0;   //总工资 \n    double bonusMoney = 0;   //奖金 \n    \n    double achievement ;   //业绩 \n    printf(\"请输入业绩：\\n\");  //获取业绩的提示信息 \n    scanf(\"%lf\",&achievement) ;  //获取业绩输入 \n    \n    if(achievement<=10000){   //如果业绩小于10000\n        allMoney = baseMoney;    //总工资为基本工资  \n    }else if(achievement<=20000){   //如果业绩大于20000 小于50000 \n        allMoney = baseMoney + (double)(achievement-10000)*0.05; //总工资为基本工资，加上大于10000部分的奖金 \n    }else if(achievement<=50000){  //如果业绩大于20000，小于50000 \n    //则工资为基本工资加上大于20000小于50000部分奖金 ，加10000到20000部分的奖金\n        allMoney = baseMoney + (double)(achievement-20000)*0.06+ 10000*0.05;  \n    }else if(achievement<=100000){  //如果业绩大于50000小于10000\n    // 则工资为基本工资，加上大于50000小于10000部分奖金，加20000到50000部分奖金，加10000到20000部分奖金 \n        allMoney = baseMoney + (double)(achievement-50000)*0.07 + 30000*0.06 + 10000*0.05;\n    }else{  //如果业绩大于100000\n    //则工资为基本工资，加上大于100000部分奖金，加上50000到100000部分奖金，加20000到50000部分奖金，加10000到20000部分奖金 \n        allMoney = baseMoney + (double)(achievement-100000)*0.08 + 50000*0.07+30000*0.06+10000*0.05;\n    }\n    \n    //打印结果 \n    printf(\"业绩为：%.2lf, 应发工资为：%.2lf .\\n\",achievement,allMoney);\n    \n    //main函数退出 \n    return 0;\n    \n} //main函数结束 \n\n", "Knowledge_Point": "程序设计", "Question": "这个分段函数还是有不清楚的地方（8）求解分段函数设某公司的业务员业绩的计算方法为：工资=基本底薪+奖金。其中，奖金的计算为：当业绩在10000元以下时，只发基本底薪1000元；当业绩在10000元以上时，才可以拿奖金。提成比率为：当业绩在20000元以下时，超出10000元的部分可按照5%计算奖金；当业绩在20000元以上50000元以下时，超出20000元部分可按照6%计算奖金；当业绩在50000元以上100000元以下时，超出50000元的部分可以按照7%计算奖金；当业绩在100000元以上时，超出100000元的部分可按照8%计算奖金。编写程序：输入一个业务员的销售额，计算其应发的工资额。要求：每行都要有注释。", "Tag": "程序设计"}
{"Answer": "在python中用三单引号或三双引号，如在代码中没有赋值给任何变量时，就是多行注释，如果赋值给一个变量，那它就是一个多行字符串，可进行字符串一系列操作。", "Knowledge_Point": "程序设计", "Question": "pycharm 中的‘’‘ ’‘’是注释的意思吗学习python时用的pycharm在调节配色方案（string text）的时候发现 调节字符串文本的颜色之后不仅单引号及其内容颜色改变，多行注释''' '''及其内容颜色也变了，然后我看了有关注释的颜色调节貌似没有发现三引号代表注释的调节\n\n用#表示的注释和'''显示的注释颜色不同", "Tag": "程序设计"}
{"Answer": "\nYou can use preg_match_all to match all strings of type @somestring@ using regex @([^@]+)@ and then iterate over a for loop to do the replacement of each such found string in the original string to replace with the actual value from your function gimmeNewVal which returns the value from your given json.\nHere is the PHP code for same,\n$myString = \"@Dear@ name, this is @an example string@.\";\n\nfunction gimmeNewVal($myVal){ // I've replaced your function from this to make it practically runnable so you can revert this function as posted in your post\n    $obj = json_decode('{ \"Dear\":\"newString1\", \"an example string\":\"newString2\" }');\n    return $obj->$myVal;\n}\n\npreg_match_all('/@([^@]+)@/', $myString, $matches);\nfor ($i = 0; $i < count($matches[1]); $i++) {\n    echo $matches[1][$i].' --> '.gimmeNewVal($matches[1][$i]).\"\n\";\n    $myString = preg_replace('/'.$matches[0][$i].'/',gimmeNewVal($matches[1][$i]), $myString);\n\n}\necho \"\nTransformed myString: \".$myString;\n\nPrints the transformed string,\nDear --> newString1\nan example string --> newString2\n\nTransformed myString: newString1 name, this is newString2.\n\nLet me know if this is what you wanted.\n", "Knowledge_Point": "程序设计", "Question": "php替换标签或字符之间的一些字符串\n\nI need to replace some text in a string. I think an example can explain better:\n\n[myFile.json]\n\n{ \"Dear\":\"newString1\", \"an example string\":\"newString2\" }\n\n\n[example.php]\n\n$myString = \"@Dear@ name, this is @an example string@.\";\n\nfunction gimmeNewVal($myVal){\n    $obj = json_decode(file_get_contents('myFile.json'));\n    return $obj->$myVal;\n}\n\necho gimmeNewVal(\"Dear\"); // This print \"newString1\"\n\n\nSo, what I need is to find any strings between the '@' symbol and for each string found I need to replace using the gimmeNewVal() function.\n\nI already tried with preg_* functions but I'm not very able with regex...\n\nThanks for your help\n    ", "Tag": "程序设计"}
{"Answer": "这是一个死循环了for(表达式1; 表达式2; 表达式3){    语句块}表达式2需要写:控制是否继续循环的条件,例如i<2*b", "Knowledge_Point": "程序设计", "Question": "for语句小括号内三个条件合适for里边的格式对不对", "Tag": "程序设计"}
{"Answer": "首先这段代码的功能是执行楼上所说的计算：1！+2！+3！+...+n! 的和\r\n然后运行情况：\r\n（注：for循环中，如果不加大括号，默认的只执行for后的一个语句）\r\n假设：n=4;\r\n1.进入for(i=1;i<=n;i++)中:\r\n   i=1;t=1;\r\n  进入for(j=1;j<=i;j++)中：\r\n      j=1;(满足j<=i)\r\n\t\t\tt=t*j;(注：t=1*1=1)\r\n\t\t\t此次for(j=1;j<=i;j++)中的语句执行完，j++；j=2;不满足j<=i;\r\n\t\tfor(j=1;j<=i;j++)循环结束\r\n 执行sum=sum+t;(注：sum=0+1*1=1*1)\r\n此次for(i=1;i<=n;i++)中的语句执行完，i++；i=2;满足i<=n;\r\n2.再次进入for(i=1;i<=n;i++)循环：\r\n   i=2;t=1;\r\n\t 进入for(j=1;j<=i;j++)中：\r\n\t\tj=1;(满足j<=i)\r\n\t\tt=t*j;(注：t=1*1=1)\r\n\t\t此次for(j=1;j<=i;j++)中的语句执行完，j++；j=2;满足j<=i;\r\n\t\tt=t*j;(注：t=1*1*2=1*2;)\r\n\t\t此次for(j=1;j<=i;j++)中的语句执行完，j++；j=2;不满足j<=i;\r\n\t\t\tfor(j=1;j<=i;j++)循环结束\r\n 执行sum=sum+t;(注：sum=1*1+1*2即sum=1！+2！)\r\n此次for(i=1;i<=n;i++)中的语句执行完，i++；i=2;满足i<=n;\r\n3.再一次进入for(i=1;i<=n;i++)循环：\r\ni=3;t=1;\r\n 进入for(j=1;j<=i;j++)中：\r\n\t\t......\r\n如上循环下去，直到\r\n此次for(i=1;i<=n;i++)中的语句执行完，i++；i=6;不满足i<=n;\r\nfor(i=1;i<=n;i++)循环结束；\r\n\r\n后话：运行情况可通过调试，一步一步的走，看的清楚，希望对你有帮助（求采纳）", "Knowledge_Point": "程序设计", "Question": "for语句的镶嵌是怎么回事？int n,t,i,j,sum=0;\nscanf(\"%d\",&n);\nfor(i=1;i<=n;i++)\n{\n    t=1;\n    for(j=1;j<=i;j++)\n\n    t=t*j;\n\n\n sum=sum+t;\n\n\n}\nprintf(\"%d\",sum);\nsystem(\"pause\");", "Tag": "程序设计"}
{"Answer": "如果在for的代码块中有另一个for就是嵌套，比如\r\nfor (...)\r\n{\r\n...\r\nfor (...)\r\n{\r\n...\r\n}\r\n...\r\n}\r\n\r\n反之就不是嵌套，比如\r\nfor (...)\r\n{\r\n...\r\n...\r\n}\r\n...\r\nfor (...)\r\n{\r\n...\r\n...\r\n}", "Knowledge_Point": "程序设计", "Question": "怎么判断是不是for循环嵌套当程序中出现两个或两个以上for循环语句是，怎么判断是不是for循环嵌套？", "Tag": "程序设计"}
{"Answer": "代码如下，如有帮助，请采纳一下，谢谢。\n\n#include <stdio.h>\n\nvoid fun(int a[],int n,int &sumjs,int &sumos)\n{\n\tsumjs = 0;\n\tsumos = 0;\n\tfor (int i = 0; i < n;i++)\n\t{\n\t\tif(a[i] % 2 == 0)\n\t\t\tsumos += a[i];\n\t\telse\n\t\t\tsumjs += a[i];\n\t}\n}\n\nint main()\n{\n\tint a[] = {1,2,3,4,5,6,7,8,9};\n\tint sumjs,sumos;\n\tfun(a,9,sumjs,sumos);\n\tprintf(\"奇数和=%d；偶数和=%d\\n\",sumjs,sumos);\n\treturn 0;\n}\n ", "Knowledge_Point": "程序设计", "Question": "编一个函数fun，函数的功能是分别求出数组中所有的奇数和与所有的偶数和，并将结果传回主函数输出。编一个函数fun，函数的功能是分别求出数组中所有的奇数和与所有的偶数和，并将结果传回主函数输出。", "Tag": "程序设计"}
{"Answer": "是的，规范的做法就是要调用，派生类初始化自己的部分，然后基类的构造调用基类构造函数", "Knowledge_Point": "程序设计", "Question": " C++中派生类的构造函数一定得调用基类的构造函数吗如题， C++中派生类的构造函数一定得调用基类的构造函数吗\n（小白刚学，大神勿喷）", "Tag": "程序设计"}
{"Answer": "1. 1. 析构函数跟普通成员没有什么不同，只是编译器在会在特定的时候自动调用析构函数(离开作用域或者执行delete操作)；\r\n1. 2. 对于一个成员函数调用（不论是通过对象obj.func还是通过对象指针obj->func），到底是直接调用还是通过虚函数表调用，在编译的时候是确定的，取决于这个函数是不是虚函数；\r\n1. 3. 综上，如果析构不声明为虚函数，那么delete pBase，就被编译器解释为 Base::~Base，否则被编译器解释为 this->virtual_function_table[#析构在虚函数表的偏移]", "Knowledge_Point": "程序设计", "Question": "为什么基类的析构函数不是虚函数时，就不会调用派生类的析构函数我知道，基类的析构函数要生命为虚函数，不然用基类指针删除派生类对象时只会调用基类的析构函数，而不会调用派生类的析构函数，从而发生内存泄露。但是为什么会这样？为什么基类析构函数不是虚函数时，就不会调用派生类析构函数而是虚函数时就会调用派生类析构函数？？？有没有大神指点一下。\n\n看了几位的回答，都不是我想要的。我已经知道了不声明为虚函数，会造成内存泄露。我想知道为什么会造成内存泄露，原因是什么。", "Tag": "程序设计"}
{"Answer": "#include<stdio.h>#include<math.h>int main() {  int y[50],i,min;  int qmin(int y[]);  for(i=0;i<50;i++)    y[i]=600*sin(i*0.16);  min=qmin(y);  printf(\"min=%d\",min);  return 0;}int qmin(int y[])  {int min,i,j;   min=y[0];  for(i=0;i<50;i++)   {if(min>y[i])min=y[i];}  return min;}", "Knowledge_Point": "程序设计", "Question": "编写函数找出数组中的最小数求一维整型数组中的最小元素。要求：主函数定义数组y[50]，y[j]=600sin(j0.16) (j=0,1,2…49)，调用自定义函数qmin求出最小元素，最后在主函数中输出结果。要求必须使用 for语句实现。输入用例无输出用例min=-598", "Tag": "程序设计"}
{"Answer": "先解析第一个引入的js文件内的函数。\r\n之后引入第二个js文件时，会用第二个js文件内的函数覆盖掉之前的同名函数。\r\n```\r\n\n\n\n\r\n```", "Knowledge_Point": "程序设计", "Question": "js 弄了2个一样的函数名，优先解析哪一个？csdn1.js中有函数\n\nfunction csdn(){\n  XXX1\n}\n\ncsdn2.js中也有函数\n\nfunction csdn(){\n  XXX2\n}\n\n那么html同时调用了csdn1.js和csdn2.js，在页面中\n\n\ncsdn();\n\n会先解析哪个函数？", "Tag": "程序设计"}
{"Answer": "子程序没有返回值，在C里面，子程序是特殊的函数，返回直接用return。如果不写，那么程序在执行完子程序最后一行会自动返回。", "Knowledge_Point": "程序设计", "Question": "一个关于子程序的问题，不太懂子程序和函数的区别是什么？子程序返回主程序使用什么语句啊？子程序的作用是什么？", "Tag": "程序设计"}
{"Answer": "不知道你报的什么错，我简单试了一下，如果报的错是：TypeError: not all arguments converted during string formatting的话就把第一行改成year=eval(input('请输入年份:'))", "Knowledge_Point": "程序设计", "Question": "if分支结构判断某一年份是否为闰年代码运行过程中出错，求指点。写了三个if的嵌套结构。万分感谢！\n\n", "Tag": "程序设计"}
{"Answer": "else if(1<=x<10) 改成 else if(1<=x&&x<10)1<=x<=10 需要知道它计算的先后顺序先算1<=x,不管x值为多少，最终只有两个结果，它的值要么是不成立（0）要么是成立（1），再计算 0<=10或者1<=10，这两个结果都是一定成立的，所以会进这个里边", "Knowledge_Point": "程序设计", "Question": "基本语句中的嵌套if语句#include \nusing namespace std;\nint main(void){   float x,y;    cout<<\"input =\";    cin>>x;if (x<1)    y=x;else if(1<=x<10)    y=2x-1;else    y=3x-11;cout<<\"y=\"<<y<<endl;    return 0;}这段代码哪里有问题？为什么输入14输出的是27", "Tag": "程序设计"}
{"Answer": "\nx = int(input())\ny = 0\nif x>5000:\n    if x>10000:\n        if x>20000:\n            y = (x-20000)*0.2+5000*0.03+10000*0.1\n        else:\n            y = (x - 5000) * 0.3 + (x - 10000) * 0.1\n    else:\n        y = (x-5000)*0.3\nprint(y)\n\n", "Knowledge_Point": "程序设计", "Question": "条件语句与循环语句的嵌套用python的条件语句与循环语句对下面该程序框图求值，自己能做到IF从句，但是循环不会嵌套，自学python，求解答", "Tag": "程序设计"}
{"Answer": "就是一个简单的数组循环，像下面循环出来就是三个div\n\n", "Knowledge_Point": "程序设计", "Question": "V-for循环语句应如何详细注解请问以下代码中v-for循环语句如何详细解释说明，是怎么样的循环呢            ", "Tag": "程序设计"}
{"Answer": "在 C 语言中，当你使用数组名访问数组中的某个元素时，实际上是在访问该元素的地址。因此，当你使用数组名调用函数时，实际上是在将数组的首地址作为参数传递给函数。\n在你提到的这两种 scanf 的写法中，第一种写法（scanf(\"%d\", &a)）将数组 a 的地址传递给 scanf 函数，而第二种写法（scanf(\"%d\",a)）则将数组 a 的首地址作为参数传递给 scanf 函数。\n因此，这两种写法在本质上是一样的，最终都会将输入的第一个整数赋值给数组 a 的第一个元素，后面的两个元素都会变为 0。", "Knowledge_Point": "程序设计", "Question": "C语言中给整型数组赋值要加&吗C语言中，对整型数组元素赋值时，例如int a[3] = {1};  scanf(\"%d\", &a);  和  scanf(\"%d\",a);这两种scanf的写法都不会报错，运行后如果输入3个整数，最后都是能将第1个整数赋给数组的第1个元素，后面两个都是0，这是为什么呢，为什么两种写法最后的结果却是一样的呢？", "Tag": "程序设计"}
{"Answer": "赋值还要循环赋值？建议先用list将每列的值装起来，再用这个list循环创建列并赋值", "Knowledge_Point": "程序设计", "Question": "java按模板导出excel，遍历结果给单元格赋值会三层for嵌套如何避免问题遇到的现象和发生背景\n如何遍历list<map>里的数据赋值给单元格\n\n问题相关代码，请勿粘贴截图\n  List<Map<String, Object>> resultList = Service.selectInfoList(dataParams);\n            XSSFWorkbook workBook = null;\n            FileInputStream fis = null;\n            OutputStream ouputStream = null;\n            String classPath = this.getClass().getResource(\"/\").getFile().toString();\n            String srcFilePath = classPath + \"/file/模板.xlsx\"; //模板\n            //创建Excel文件的输入流对象\n            fis = new FileInputStream(srcFilePath);\n            //根据模板创建excel工作簿\n            workBook = new XSSFWorkbook(fis);\n            //获取创建的工作簿第一页\n            XSSFSheet sheet = workBook.getSheetAt(0);\n            //给指定的sheet命名\n            workBook.setSheetName(0, \"管理人员\");\n            CellStyle style = workBook.createCellStyle();  //单元格样式设置\n            style.setBorderRight(BorderStyle.THIN);\n            style.setBorderLeft(BorderStyle.THIN);\n            style.setBorderTop(BorderStyle.THIN);\n            style.setBorderBottom(BorderStyle.THIN);\n         for (int i = 2; i < resultList.size() + 2; i++) {\n                XSSFRow row = sheet.createRow(i);       //建行\n                for (int j = 0; j < resultList.get(i).size(); j++) {\n                    XSSFCell cell = row.createCell(j);          //建单元格\n                    for (String key : resultList.get(i).keySet()) {\n                        cell.setCellValue(nvl(resultList.get(i).get(key)));    //给单元格赋值\n                    }\n                }\n            }\n            response.setContentType(\"application/octet-stream; charset=utf-8\");\n            response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + Encodes.urlEncode(\"市公司本部四级管理人员.xlsx\"));\n            ouputStream = response.getOutputStream();\n            workBook.write(ouputStream);\n            //关闭流\n            ouputStream.flush();\n            ouputStream.close();\n\n我的解答思路和尝试过的方法\n我想要达到的结果", "Tag": "程序设计"}
{"Answer": "外层对i遍历,内层对j遍历对于1~4中的每个i,从1~5遍历j,输出i*j的结果,每五个换一次行即输出1*1...1*52*1...2*5....4*1...4*5代码运行如下有帮助望采纳~\n#include <stdio.h>\nint main()\n{\n    int i, j, n = 0;\n\n    for (i = 1; i <= 4; i++)\n\n        for (j = 1; j <= 5; j++, n++)\n        {\n            if (n % 5 == 0)\n                printf(\"\\n\");\n            printf(\"%d\\t\", i * j);\n        }\n\n    printf(\"\\n\");\n    return 0;\n}\n\n", "Knowledge_Point": "程序设计", "Question": "俩个for循环语句，循环的嵌套语句什么顺序解读include < stdio. h>\nint main( )｛int i,j,n=0;\nfor (i=1;i< =4;i++ )\nfor (j=1;j<=5;j++,n++) ｛if (n%5==0) printf (\"n\");printf (\"%dt\",i* j);｝\nprintf(\"n\" );return 0 ;｝", "Tag": "程序设计"}
{"Answer": "两种方法参考：1 TaskDetail成员变量改为允许空值2 通过AOP拦截 parseArray的转换过程，逢null转\"\"或0", "Knowledge_Point": "程序设计", "Question": "JSON.parseArray转换数组里有空值时抛出异常如图，当我转化这个数组时，因为这个数组里有空值就抛出了异常，我用debug走，发现到了这个转换json这一步就会直接跳转到了这两个页面。\n\n搞不清楚怎么会发生这个跳转，当数组里没空值时不会发生这个情况", "Tag": "程序设计"}
{"Answer": "\n        Integer[] integers = ThreadLocalRandom.current().ints(1, 10).boxed().limit(20).toArray(Integer[]::new);\n        Map<Integer, Long> collect = Arrays.stream(integers).collect(Collectors.groupingBy(Integer::new, Collectors.counting()));\n        List<Integer> nums = collect.entrySet().stream().filter(f -> f.getValue() > 3).map(Map.Entry::getKey).collect(Collectors.toList());\n        // 随机数数组\n        System.out.println(Arrays.toString(integers));\n        // 每个随机数对应出现的次数\n        System.out.println(collect);\n        // 最终出现次数大于3的随机数\n        System.out.println(nums);\n", "Knowledge_Point": "程序设计", "Question": "Java用数组储存若干整数，求出现超过3次的整数问题遇到的现象和发生背景\nJava程序问题用数组存储输入的若干整数（可使用随机类或函数生成一定范围的随机整数），求出现次数超过3次的整数。请问各位这个用java怎么写", "Tag": "程序设计"}
{"Answer": "0、null、NaN、undefined、\"\" 转成布尔值为false 其他则一律返回true；然后就看代码    x++   此时还是1    但是||  或   --------一真则真    y++就不计算了 输出的时候  x在上一步++了  所以 x成了2    y是1                    上面的x++是true    赋值给了c   c就是1了", "Knowledge_Point": "程序设计", "Question": "c语言初学者的小问题，帮一下忙为什么答案是211？\n#include <stdio.h>\nint main()\n{\n    int c, x, y;\n    x = 1;\n    y = 1;\n    c = 0;\n    c = x++ || y++;;\n    printf(\"\\n%d%d%d\\n\", x, y, c);\n}\n\n\n\n211\n赋值运算\n为什么？", "Tag": "程序设计"}
{"Answer": "4×4的矩阵，数组大小应该定义为A[4][4]吧", "Knowledge_Point": "程序设计", "Question": "用C语言实现两个4x4矩阵相乘，系统没有报错，但是结果是错的······\n                                                                                                                  这部分想要实现的功能是：在已经输入的一个二维数组中找到最大值和最小值并且输出，还要写出最大值和最小值所在的行和列数。\n问题：系统编译后没有报错，但是最后现实的结果却是错的，例如：\n这部分要实现的功能是：分别求出这个矩阵的两条对角线之和。问题：但是每次求和是总有一条是错的·······\n\n实在是不知道哪里错了，求各路大神帮帮忙。。。。\n\n有尝试过单步调试，但是它好像直接就跳过子函数了。。。。", "Tag": "程序设计"}
{"Answer": "结果不可预料，和编译器的编译有关。返回值（对于x86 cpu来说）其实就是函数返回的时候 eax 寄存器的值。具体要看函数生成的机器代码是什么", "Knowledge_Point": "程序设计", "Question": "在调用函数中，为何如果没有返回值，图中的p能接受且只能接受调用函数中c的第一次赋值？\n\n如图，忍不住好奇试了试去掉return，居然能输出结果，然后我发现调用函数的两条表达式均有执行，但赋值给p的结果只是运算c = a * b后c的值，这是为什么......", "Tag": "程序设计"}
{"Answer": "\nChances are your path or permissions are wrong; Check the return value from addEmbeddedImage:\nif (!$mail->AddEmbeddedImage($obrazy[$x], 'tel'.$x)) {\n  echo 'Failed to attach '. $obrazy[$x];\n}\n\nIt's probably a good idea to turn the path into an absolute one, for example by saying something like  __DIR__ . '/' . $obrazy[$x] instead of just the relative path.\nIt may be that your current working directory is not where you think it is. Try doing it like this:\nif (!$mail->AddEmbeddedImage(getcwd() . '/' . $obrazy[$x], 'tel'.$x)) {\n  echo 'Failed to attach '. getcwd() . '/' . $obrazy[$x];\n}\n\nThen it will show you the full path of the files it's failing to find, and you can check whether they are correct.\n", "Knowledge_Point": "程序设计", "Question": "PHPMailer使用FOR循环添加图像\n\nI have this PHP code:\n\nfor($x = 0; $x < count($obrazy); $x++) \n{ \n   $mail->AddEmbeddedImage($obrazy[$x], 'tel'.$x); \n}\n\n\nthe variable \"obrazy\" is a table storing path (link to the image) e.g. \"obraz/zdjecie.png\". I need to do this with a loop because the array of obrazy can have a different size each time. The above loop does not work for me, because when I want to show this image in the mail, nothing is displayed.\n\n$iterator = 0;\n\nwhile ($row = mysqli_fetch_array($rezultat)) \n{      \n         $mail->Body = $mail->Body.'//..........\n\n                <img src=\"cid:tel'.$iterator.'\" style=\"\n\n                    width: 160px;\n                    display: block;\n                    float: left;\n\n                \"/> //..........\n           ';\n\n          $iterator++;\n}\n\n\n\"// ......\" means another part of the code that does not matter to the question being asked. The while loop must be because I extract different data from the database. Everything works only the images do not want to be displayed in the email, even if instead of \"$iterator\" I enter the number. Links to the image contained in the table are RELIABLE for the PHP file.\n    ", "Tag": "程序设计"}
{"Answer": "\nYour loop breaks when reader.Read() returns io.EOF. This happens when your input is consumed.\nAt the same time (when io.EOF is returned), the returned record will be nil. Reader.Read():\n\nIf there is no data left to be read, Read returns nil, io.EOF.\n\nSo you assign nil to the record variable, the loop breaks, and you inspect the record variable.\nIf your intent is to hold the last record, store it in a separate variable, and do not \"overwrite\" it with the last nil record:\nvar lastRecord []string\nfor {\n    record, err = reader.Read()\n    // Stop at EOF.\n    if err == io.EOF {\n        break\n    }\n    lastRecord = record\n    fmt.Printf(\"%v\", record) // works fine\n    fmt.Printf(\"%v\n\", record[0]) // works fine too\n}\nfmt.Printf(\"%v\n\", lastRecord) // this will be the last non-nil record\n\n", "Knowledge_Point": "程序设计", "Question": "在Golang中访问for循环之外的变量\n\nI'm trying to read a CSV file to store the values in a variable. However, I couldn't access the variables outside of the for loop \n\nfunc GetKeys(filename string) {\n    var record []string\n    var err error\n    file, err := os.Open(filename)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer file.Close()\n    // Create a new reader.\n    reader := csv.NewReader(bufio.NewReader(file))\n    for {\n        record, err = reader.Read()\n        // Stop at EOF.\n        if err == io.EOF {\n            break\n        }\n        fmt.Printf(\"%v\", record) // works fine\n        fmt.Printf(\"%v\n\", record[0]) // works fine too\n    }\n    fmt.Printf(\"%v\n\", record) // returns empty slice\n}\n\nfunc main() {\n    GetKeys(\"credentials.csv\")\n}\n\n    ", "Tag": "程序设计"}
{"Answer": "range函数的语法为：\nrange(start, stop[, step])\n# start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;\n# stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5\n# step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)\n\n（num,0,-1）的意思就是，这里的 i 从 num 开始，到 0 结束（不含0）步长为 -1.", "Knowledge_Point": "程序设计", "Question": "for循环里的0和-1是什么意思？求解答num=int(input(\"请输入一个整数：\"))for i in range(num,0,-1):    print(('* 'i).center(3num))第二行（num,0,-1）是什么意思", "Tag": "程序设计"}
{"Answer": "少了个=\nif(j == 1)   printf(\"*\");\n", "Knowledge_Point": "程序设计", "Question": "用for循环打印星号三角形，行数由键盘输入 的整数决定。题目：请问我的代码错哪了？\n#include <stdio.h>\nint main() {\nint n,i,j;\n  scanf(\"%d\",&n);\n  for(i=1;i<=n;i++){\n  for(j=n-i+1;j>0;j--){\n    if(j>1)\n      printf(\"* \");\n  if(j=1)printf(\"*\");}\n  printf(\"\\n\");\n  }\n}\n\n\n", "Tag": "程序设计"}
{"Answer": "\nTry to iterate your array collection:\n<ul>\n    {% for item in entity.assessments %}\n        <li>{{ item.name }}</li>\n    {% endfor %}\n</ul>\n\n", "Knowledge_Point": "程序设计", "Question": "Symfony 4 EasyAdmin  - 在树枝模板中渲染关联数据类型\n\nUsing EasyAdmin in my Symfony 4 app.\n\nWorking on show view for the User entity.\n\nI want to display all my related (1-many) entities in the show view for User as lists I can style.\n\nThe default template for this datatype is @EasyAdmin/default/field_association.html.twig.\n\nHow can I reference a list of entities for the user (Bookings, Assessment etc).\n\nI have tried adding {{ entity.assessments }} the user_show.html.twig but I get error:\n\nObject of class Doctrine\\ORM\\PersistentCollection could not be converted to string\n\n\nHow can I render these related (associated) entities in this twig template?\n    ", "Tag": "程序设计"}
{"Answer": "你是要考虑越界的问题吗，可能自动类型转换了；在短整型中，32767=2^15-1，这里已经是短整型能够表示的最大正数了，在计算机组成原理里面会学的，计算机中的数用补码表示，32767+1之后会变成下一阶段的数，进位后就成了负数，当然这里会不会进行类型转换得通过试验进行；32767+1用补码表示为1111 1111 1111 1111（正数的补码为本身）+ 0000 0000 0000 0001（正数的补码为本身），但加起来之后变成1 0000 0000 0000 0000，注意这里进位并不考虑在本次计算中，所以结果会变成最小的负数-32768；注释：这里理解并不透彻，可能有些错误，仅作参考。", "Knowledge_Point": "程序设计", "Question": "基本数据类型在计算机中的表示-关于程序输出结果不懂为什么b会是负号？而且格式不应该是a=多少，b=多少，a，b    为什么答案只有a=，b= ？\n", "Tag": "程序设计"}
{"Answer": "@list 加个别名就可以了，我试过可以了\r\n\r\ndeclare @list table\r\n(\r\nId int,\r\nName navarchar(12)\r\n)\r\ninsert into @list\r\nselect * from tableA\r\nselect * from @list --到这步都是OK的，能得到@list中的数据\r\n--下面我想把@list与tableB表联接起来做查询\r\nselect * from @list A,tableB\r\nwhere A.id = tableB.id", "Knowledge_Point": "程序设计", "Question": "SQL @list临时变量 ，报错信息必须定义变量declare @list table\n(\n  Id int,\nName navarchar(12)\n)\n\ninsert into @list\nselect * from tableA\n\nselect * from @list  --到这步都是OK的，能得到@list中的数据\n\n--下面我想把@list与tableB表联接起来做查询\nselect * from @list,tableB\nwhere @list.id = tableB.id\n\n结果报错了，提示上面where语句中的@list有问题：Must declare the scalar variable \"@list\". \n\n这是为什么呢？我不是已经都定义了吗？", "Tag": "程序设计"}
{"Answer": "\nyou don't need to do this. Mysql handles this automatically, just use\n$query = \"SELECT * FROM `Posts` LIMIT $from, $limit\";\n\n", "Knowledge_Point": "程序设计", "Question": "MySQL中的IF语句，使用THEN和ELSE\n\nI am testing out IF statements in MySQL for the first time and I am coming across an error. \n\nI am trying to firstly, find out how many rows are in the table, then depending on whether the count is less than or equal to five, return all of the rows in the table, or if it isn't, return all posts in the range used within the LIMIT clause. \n\nThe error I am receiving is as follows;\n\n\n  You have an error in your SQL syntax; check the manual that\n  corresponds to your MySQL server version for the right syntax to use\n  near 'IF SELECT COUNT(*) FROM Posts <= 5 THEN SELECT * FROM Posts\n  ELSE SELECT * FR' at line 1\n\n\nPlease can you tell me where I am going wrong? \n\nMax.\n\n$query = mysql_query(\n    \"IF SELECT COUNT(*) FROM `Posts` <= 5 \n     THEN \n         SELECT * FROM `Posts` \n     ELSE \n         SELECT * FROM `Posts` LIMIT $from, $limit\") \n     or die(mysql_error());\n\n    ", "Tag": "程序设计"}
{"Answer": "a=0是赋值，改为a==0才是判断。代码修改如下：\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\nvoid main(){\n    int a;\n    printf(\"游戏开始\\n\");\n    printf(\"这是一个猜拳小游戏，请遵循游戏规则开始进行游戏\\n\");\n    printf(\"石头可以赢过剪刀\\n剪刀可以赢过布\\n布可以赢过石头\\n\");\n    printf(\"输入0，代表玩家本回合使用石头，\\n输入1，代表玩家本回合使用剪刀，\\n输入3，代表玩家本回合使用布\\n\");\n    printf(\"输入0开始游戏，输入1结束游戏\\n\");\n    scanf(\"%d\",&a);\n    printf(\"玩家输入了%d\\n\",a);\n    if (a==0){\n        printf(\"游戏开始！\");\n        game();\n    }\n    else {\n        printf(\"游戏即将结束！\");\n    }\n    return;\n}\n", "Knowledge_Point": "程序设计", "Question": "为什么我的C语言程序无法正确执行if判断？这串代码为什么在执行的时候，无论玩家输入了什么，控制台总是输出游戏即将结束？\n\n#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n\nvoid main(){\n\n    int a;\n    printf(\"游戏开始\\n\");\n    printf(\"这是一个猜拳小游戏，请遵循游戏规则开始进行游戏\\n\");\n    printf(\"石头可以赢过剪刀\\n剪刀可以赢过布\\n布可以赢过石头\\n\");\n    printf(\"输入0，代表玩家本回合使用石头，\\n输入1，代表玩家本回合使用剪刀，\\n输入3，代表玩家本回合使用布\\n\");\n    printf(\"输入0开始游戏，输入1结束游戏\\n\");\n\n    scanf(\"%d\",&a);\n    printf(\"玩家输入了%d\\n\",a);\n    if (a=0){\n        printf(\"游戏开始！\");\n        game();\n    }\n    else {\n        printf(\"游戏即将结束！\");\n    }\n    return;\n}\n\n\n", "Tag": "程序设计"}
{"Answer": "如果只是这个需求，而且不用考虑数据异常。可以新生成一个数组\nlst = [[\"好评\"], [\"差评\"], [\"中评\"], [\"好评\"], [\"中评\"]]\nlst1 = [[1 if m == '好评' else 0 if m == '中评' else -1 for m in n] for n in lst]\n\nprint(lst1)\n\n\n如果要遍历解决\n\nlst = [[\"好评\"], [\"差评\"], [\"中评\"], [\"好评\"], [\"中评\"]]\n\n\nfor i in range(len(lst)):\n    if type(lst[i])==list:\n        for j in range(len(lst[i])):\n            lst[i][j] = 1 if lst[i][j] == '好评' else 0 if lst[i][j] == '中评' else -1\nprint(lst)\n\n", "Knowledge_Point": "程序设计", "Question": "Python怎样将一个一维数组组成的列表中对指定的元素进行修改？请问一下大家：目前得到形如[['好评'],……['差评'],['中评'],['差评'],['好评']]的一维数组列表，需要对其中好评全都修改为1，中评修改为0，差评修改为-1，请问代码应该是怎样去写，目前思路是通过for循环嵌套if语句对数组中内容进行判断，然后分别对好评、中评、差评进行重新赋值，但是代码还是写不出来，有人有更好的办法或者思路的解决方案代码吗？", "Tag": "程序设计"}
{"Answer": "\ngenres is an associative array meaning that the key will only give you the index point of that value. Your values are of type String, not numerical values.\n$genres = ['Adventure', 'Drama', 'Game', 'Harem', 'Martial Arts', 'Seinen'];\n\nSo in this case, at index point 0 (arrays start at 0), we will get Adventure.\n[0] => Adventure\n\nTo get these values out of the array one by one you can do this:\nforeach($genres as $_genre) {\n    echo $_genre;\n}\n\nTo get these values and/or keys from the array one by one you can do this:\nforeach($genres as $_key => $_genre) {\n    echo \"Index: {$_key} - Value: {$_genre}\"\n}\n\nKeys are numerical values, they mark the point of the value in that array. For example, if we wanted to get Game from the array:\n[2] => Game\n\nWe can see that it has an index of 2 and can be called like:\necho $genres[2];\n\n", "Knowledge_Point": "程序设计", "Question": "如何从数组中获取数值？\n\nI have this following segment in my array.\n\n[genres] => Array\n    (\n        [0] => Adventure\n        [1] => Drama\n        [2] => Game\n        [3] => Harem\n        [4] => Martial Arts\n        [5] => Seinen\n    )\n\n\nI am trying to return each of those elements separately. \n\nforeach($t['genres'] as  $tag=>$value) {\n    // I don't know what to do from here\n}\n\n\nCan someone help me on how I can print each unique value?\n    ", "Tag": "程序设计"}
{"Answer": "\n用列表推导式\ndef fun(ls1, ls2):\n    return [(x-y)**2 for x, y in zip(ls2, ls1)]\n", "Knowledge_Point": "程序设计", "Question": "本题要求实现一个函数，对传入的二个列表中的对应数据进行差平方运算，生成一个新的列表并返回。6-6 列表处理本题要求实现一个函数，对传入的二个列表中的对应数据进行差平方运算，生成一个新的列表并返回。函数接口定义：\n在这里描述函数接口。例如：fun(ls1,ls2)ls1、ls2为二个数值型的列表。裁判测试程序样例：\nls1=eval(input())ls2=eval(input())print(fun(ls1,ls2))/* 请在这里填写答案 */输入样例：\n在这里给出一组输入。例如：[1,2,3][4,7,9]输出样例：\n在这里给出相应的输出。例如：[9, 25, 36]", "Tag": "程序设计"}
{"Answer": "用数组、指针作为函数参数，实际是一样的啊\nvoid fun(int *p,int n)\nvoid fun(int p[],int n)\n没有区别", "Knowledge_Point": "程序设计", "Question": "编写程序，用一个函数将一个3*4的整型矩阵转置，分别用数组、指针变量作为函数参数实现编写程序，用一个函数将一个3*4的整型矩阵转置，分别用数组、指针变量作为函数参数实现", "Tag": "程序设计"}
{"Answer": " // 在你的axisLabel里用formatter来做处理\naxisLabel: {\n  formatter: value => {\n    return value / 1000 + 'k'\n  }\n},\n", "Knowledge_Point": "程序设计", "Question": "echarts 仪表盘的数值范围设置单位echarts 仪表盘的数值范围设置成带单位的需要怎么办呢？\n例如把'12000'变成'12K'\n", "Tag": "程序设计"}
{"Answer": "\nstrtotime is converting a string into a timestamp and date is converting a timestamp into a string, you need to reverse date with strtotime like so:\npublic function store(ScheduleRequest $request)\n{\n    $schedule = new Schedules;\n    $schedule->allDay = $request->allDay;\n    $schedule->start = date('Y-m-d H:i:s', strtotime($request->start));\n    $schedule->end = date('Y-m-d H:i:s', strtotime($request->end));\n    $schedule->title = $request->title;\n\n    if ($schedule->save())\n    {\n        return [\n            'success' => 'Data Was Saved Successfully'\n        ];\n    }\n}\n\n", "Knowledge_Point": "程序设计", "Question": "转换DateTime时遇到的格式不正确的数值\n\nI am using the fullCalendar plugin/directive in Angular, and I am currently having an issue when trying to save the date/time into my database.\n\nThese are the values being posted to my server:\n\n{\"title\":\"Hey\",\"start\":\"2015-08-13T00:00:00.000Z\",\"end\":\"2015-08-13T00:00:00.000Z\",\"allDay\":true}\n\n\nNow in my controller I try to convert both date/time string into valid date/time format before saving into my database:\n\npublic function store(ScheduleRequest $request)\n{\n    $schedule = new Schedules;\n    $schedule->allDay = $request->allDay;\n    $schedule->start = strtotime(date('Y-m-d H:i:s', $request->start));\n    $schedule->end = strtotime(date('Y-m-d H:i:s', $request->end));\n    $schedule->title = $request->title;\n\n    if ($schedule->save())\n    {\n        return [\n            'success' => 'Data Was Saved Successfully'\n        ];\n    }\n}\n\n\nThis is the error I get:\n\n\n  A non well formed numeric value encountered\n\n\nI would like to know how to convert both datetime values into valid datetime objects in PHP using the specified format.\n    ", "Tag": "程序设计"}
{"Answer": "你直接敲就行，能执行，不报错因为你多次强制转换类型，而且list套list，IDE会认不出你最里层的结构到底是个什么类型，所以点的时候点不出对应的方法，这很正常毕竟python是解释性的语言，不是所有操作在一开始编译阶段IDE都能搞清楚执行的时候能执行的", "Knowledge_Point": "程序设计", "Question": "有关元组方面出现的问题问题遇到的现象和发生背景\n在python3.10中 创建一个字符串通过split对字符串进行分割 并输出列表将列表中的第三个元素强制改为列表类型也就是列表里套了一个列表随后对这个大列表进行类型转换，转为元组类型对元组内可变元素（被套的小列表）进行操作时 虽然type为list 但是对其操作时报错\n用代码块功能插入代码，请勿粘贴截图\ns='hello|python|123' \na=s.split(sep='|')  #对字符串分割，转化为list格式\na[2]=list(a[2])  # 将第三个元素转为list格式\naa=tuple(a) \nprint(aa[2],type(aa[2]))  # ['1', '2', '3'] <class 'list'>\nprint(len(a[2]))  # 3\n\n运行结果及报错内容\n在aa[2]后输入.append提示框里的操作语句都是对str操作的没有对list的有关操作\n我的解答思路和尝试过的方法\n由于元组内不能更改不可变元素类型，所以就在列表那一步里更改类型更改完在小列表内的元素类型为str 但是应该不影响对整个列表的增删改\n我想要达到的结果\n可以对aa[2]进行增删改操作", "Tag": "程序设计"}
{"Answer": "有错别字，重新说一次：\r\n\r\nemprs[0]和 ps[0]这两个引用都指向了Employer对象,现在你要把ps[0]指向的对象换成person对象，emprs[0]也会同时修改为指向该对象。而emprs[0]是Emloyer对象，这就成了“子类的引用执行父类对象”，这是不可以的。所以报错。", "Knowledge_Point": "程序设计", "Question": "java核心技术中一个关于数组的例子不理解，请教大家Person是Employer的父类，Employer有个新方法setBonus，代码如下   \n\nEmployer[] emprs ={new Employer(\"张三\"),new Employer(\"李四\")};              \nPerson[] ps =emprs;   \nps[0] = new Person(\"小明\");//运行时该行报错ArrayStoreException\nemprs[0].setBonus(2000);\n\n\n书中给出的解释是要保持数组中的元素对象类型一致，\n我不理解的是ps定义的元素的类型是Person，为什么在这里不能ps[0] = new Person(\"小明\")，ps[0]不是只是对new Person(\"小明\")的一个引用吗？他又不是Employer类型，我去给它赋值为Person类型有什么不可？\n\n另外以上代码如果不用数组的形式，就是两个对象这么操作下，是没有错误的。\n\n可能我以上的理解本身有错误，请大家指教指正。", "Tag": "程序设计"}
{"Answer": "每个方法会在 return 执行后结束，你把打印语句写在在了 return 后面，所以编译器认为 return 后面的语句都是无效的", "Knowledge_Point": "程序设计", "Question": "请问这段java代码怎么修改？新手小白在线求救package work;\n\n//定义一个Shape接口，接口中含有一个抽象方法，此抽象方法接收一个double类型的参数\ninterface Shape\n{\n    double area(double x);\n}\n\n//定义一个Square类，实现Shape接口\nclass Square implements Shape\n{\n    double area(double x)\n    {\n        double a=x*x;\n        return a;\n        System.out.println(\"正方形的面积为    \"+a);\n    }\n}\n\n//定义一个Circle类，实现Shape接口\nclass Circle implements Shape\n{\n    double area(double x)\n    {\n        double a=3.14*x*x;\n        return a;\n        System.out.println(\"圆的面积为   \"+a);\n    }\n}\n\npublic class Test02 {\n\n    public static void main(String[] args) \n    {\n        // TODO Auto-generated method stub\n        Square square=new Square();\n        square.area(2.00);\n        Circle circle=new Circle();\n        circle.area(3.00);\n\n    }\n\n}\n\n运行报错提示：\n\nException in thread \"main\" java.lang.Error: Unresolved compilation problem: \n    Cannot reduce the visibility of the inherited method from Shape\n\n    at work.Square.area(Test02.java:12)\n    at work.Test02.main(Test02.java:37)\n ", "Tag": "程序设计"}
{"Answer": "\nYou can do it this way:\n{% if app.request.locale==\"fr\" %}\n\n{% stylesheets '@AtgNewsBundle/Resources/public/css/fr/*' filter='cssrewrite' %}\n\n{% elseif app.request.locale==\"en\" %}\n\n{% stylesheets '@AtgNewsBundle/Resources/public/css/en/*' filter='cssrewrite' %}\n\n{% endif %}\n\n", "Knowledge_Point": "程序设计", "Question": "symfony多语言模板\n\nI have the following structure for the css files \nPublic \n - css \n -- fr\n --- style.css\n -- en\n --- style.css\n\nthe css folder include fr and en folders\n\nand I'm including CSS stylesheets in my template like so:\n\n{% stylesheets '@AtgNewsBundle/Resources/public/css/*' filter='cssrewrite' %}\n<link rel=\"stylesheet\" href=\"{{ asset_url }}\" />\n{% endstylesheets %}\n\n\nso i need to include the fr or en folder as user selection \n\ni tried the following but does not work \n\n{% stylesheets '@AtgNewsBundle/Resources/public/css/{app.request.getLocale()}/*' filter='cssrewrite' %}\n\n{% stylesheets '@AtgNewsBundle/Resources/public/css/{{app.request.getLocale()}}/*' filter='cssrewrite' %}\n\n{% stylesheets '@AtgNewsBundle/Resources/public/css/\"{{app.request.getLocale()}}\"/*' filter='cssrewrite' %}\n\n\nany help please \n    ", "Tag": "程序设计"}
{"Answer": "for里面的j < B.length 改成 j<A.length", "Knowledge_Point": "程序设计", "Question": "微信小程序：for循环，无法把A数组中的元素赋值给B数组如题，循环之后输出数组B，是一个空数组，请问是哪里出问题了呢？\n\nvar A = cloudFilePaths;//A是一个数组\nvar B=[];\nfor(let j=0;j<B.length;j++){\n  B[j]=A[j];\n}\nconsole.log(\"B\", B)\n", "Tag": "程序设计"}
{"Answer": "你好，你的程序出现的问题在你给每个字符串赋值的版块，你以为pcolor+i可以到下一个新的字符串，其实它表达的是你上一个字符串去掉第一个字母，所以你每一次的输入是在第一次输入的基础上的重叠覆盖！为了具体了解，你可以先写一个字符串char pcolor=“red”，然后输出pcolor+1，你会发现输出的是ed，也就是pcolor[1]和pcolor[2]。那么如何更正呢？我建议使用结构去包含字符串。具体可以关注私信我，我们一起交流讨论。", "Knowledge_Point": "程序设计", "Question": "C用动态内存+指针数组实现字符串从小到大排序，求指出错误#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nvoid sort(char *pc,int m);\n\nint main(void)\n{\n    int i=0;\n    int n;\n    int x;\n    char *pcolor;\n    \n    printf(\"输入n个字符串：\\n\");\n    scanf(\"%d\",&n);\n     \n    if((pcolor=(char *)malloc(n*sizeof(char)))==NULL)\n    {\n        printf(\"不能分配内存！\\n\");\n        exit(1);\n    }\n    \n    for(i=0;i<n;i++)\n    {\n        scanf(\"%s\",pcolor+i);\n    }\n    \n    \n    sort(pcolor,n);\n    \n    \n    for(i=0;i<n;i++)\n    {\n        printf(\"%s\\n\",pcolor+i);\n    }\n    \n    free(pcolor);\n    \n    return 0;\n}\n\nvoid sort(char *pc,int m)\n{\n    int j=0,k=0;\n    char *temp;\n    \n    for(j=1;j<m;j++)\n    {\n        for(k=0;k<m-j;k++)\n        {\n            if(strcmp(pc+k,pc+k+1)>0)\n            {\n                temp=pc+k;\n                pc=pc+1;\n                pc=temp-k-1;\n            }\n        }\n    }\n}\n\n结果是这样的，不知道错在哪了，求指点\n", "Tag": "程序设计"}
{"Answer": "#include <stdio.h>\nint add(int a,int b)\n{\n    return a+b;\n}\n\nint main()\n{\n    int a,b;\n    int i,n;\n    scanf(\"%d\",&n);\n    getchar();\n    for (i=0;i<n;i++)\n    {\n        scanf(\"add(%d,%d)\",&a,&b);\n        getchar();\n        printf(\"%d\\n\",a+b);\n    }\n    return 0;\n}\n", "Knowledge_Point": "程序设计", "Question": "c语言函数定义一个add（a,b）=a+b描述定义一个函数add(a,b)=a+b，请输出该函数的的值。\n格式输入格式   输入数据有多组。   首先输入n，接下来输入n组add(a,b);保证a<10&&b<10.   每组数据以回车键结束。\n输出格式 输出函数对应顺序的值，每组数据占一行。\n样例输入 3add(1,7)add(5,2)add(9,9)样例输出 8718        ", "Tag": "程序设计"}
{"Answer": "```\r\n#include \r\n#define N 10\r\nvoid sort(int *a,int N)\r\n{\r\nfor (int i = 0; i < N - 1; i++)\r\n{\r\nint min = i;\r\nfor (int j = i + 1; j < N; j++) if (a[min] > a[j]) min = j;\r\nint t = a[min]; a[min]=a[i];a[i] =t;\r\n}\r\n}\r\n\r\nvoid main()\r\n{ int a[N],i;\r\nprintf(\"Input %d numbers:\\n\",N);\r\nfor(i=0;i<N;i++) /* 从键盘输入数组a的N个元素 /\r\nscanf(\"%d\",&a[i]);\r\nsort(a,N); / 排序 */\r\nprintf(\"The sorted numbers:\\n\");\r\nfor(i=0;i<N;i++)\r\nprintf(\"%4d \",a[i]);\r\n}\r\n```\r\n# 如果问题得到解决的话，请点下采纳，包括之前的问题。", "Knowledge_Point": "程序设计", "Question": "下面的程序完成对长度为N的整型数组a进行从小到大的排序。请分别用选择排序法、冒泡排序法完成函数sort。下面的程序完成对长度为N的整型数组a进行从小到大的排序。请分别用选择排序法、冒泡排序法完成函数sort。\n#include \n#define N 10\n\nvoid main()\n{       int a[N],i;\n        printf(\"Input %d numbers:\\n\",N);\n        for(i=0;i<N;i++)  /* 从键盘输入数组a的N个元素 /\n            scanf(\"%d\",&a[i]);\n        sort(a,N);     / 排序 */\n        printf(\"The sorted numbers:\\n\");\n        for(i=0;i<N;i++)\n            printf(\"%4d \",a[i]);\n}", "Tag": "程序设计"}
{"Answer": "1、一般这种都是有查询条件就添加该列的条件，没有就不添加\nlet AssetNameQ = req.body.AssetNameQ === undefined ? '' : ( ' AND AssetName like ''%' + req.body.AssetNameQ + '%''' )\nlet MeasureTypeQ = req.body.MeasureTypeQ === undefined ? '' : ( ' AND MeasureType = ' + req.body.MeasureTypeQ )\nconsole.log(MeasureTypeQ, typeof MeasureTypeQ)\nsql.query`select *\n            from TB_Asset\n           where 1 = 1 ' + ${AssetNameQ} + ${MeasureTypeQ}\n           order by OperationTime desc`.then(result => {\n    console.log('成功查询辣')\n    res.send(result)\n}).catch(err => console.log('失败啦', err))\n\n", "Knowledge_Point": "程序设计", "Question": "nodejs中写sql语句如何处理参数缺省情况？问题遇到的现象和发生背景\n用nodejs做后台，前端传参来作条件查询。就像这样\nlet AssetNameQ = req.body.AssetNameQ === undefined ? '' : req.body.AssetNameQ\n        let MeasureTypeQ = req.body.MeasureTypeQ === undefined ? '0 or 1=1' : req.body.MeasureTypeQ\n        console.log(MeasureTypeQ, typeof MeasureTypeQ)\n        sql.query`select *\n                  from TB_Asset\n                  where AssetName like '%' + ${AssetNameQ} + '%'\n                    and (MeasureType = ${MeasureTypeQ})\n                  order by OperationTime desc`.then(result => {\n            console.log('成功查询辣')\n            res.send(result)\n        }).catch(err => console.log('失败啦', err))\n\n报错为\n\n\"Conversion failed when converting the nvarchar value '0 or 1=1' to data type tinyint.\"\n\n我想要的是，譬如前端这里查询两个条件，只填了其中一个条件a时，另一个b为空（可以为“”空字符串，也可以为undefined，后端判断下就行）查询语句要如何将条件b给忽略掉呢？因为这里是用的字符串拼接，所以似乎无论如何都只能自动变为nvchar类型，然后转换数值型失败，查询失败。\n请问该怎么处理呢？", "Tag": "程序设计"}
{"Answer": "首先,只要你get方法里面没有复杂逻辑,只是一个简单的return this.id;,是基本可以忽略差异的.但是如果是一个有类似要创建一个对象或者查找的方法,那建议可以只执行一次就执行一次.\n第二,你的这个测试代码没有参考价值.如果要统计时间,就不要写输出语句,输出语句是个耗时操作,打印同一个内容两次执行时间也不一致.如果你的测试可以忽略这个时间误差就没事,但是你这个测试用例明显是不能忽略的.", "Knowledge_Point": "程序设计", "Question": "使用相同变量是每次用get()方法效率高还是使用get后的新变量效率高?获取同一个变量时,是先用get方法获取后取个变量名后使用这个变量名,还是说每次使用的时候都去调用get方法?我纠结的是效率问题以及代码的可读性和简洁性.\n以下是我自己写的测试代码,希望您可以通过代码理解我的意思和疑问:\n\n// 第一种get方式\n    Invoices invoices = new Invoices();\n        invoices.setId(123456789L);\n        System.out.println(\"开始时间\" + System.currentTimeMillis());\n        System.out.println(invoices.getId());\n        System.out.println(invoices.getId());\n        System.out.println(invoices.getId());\n        System.out.println(\"结束时间\" + System.currentTimeMillis());\n\n// 第二种取值后使用的方式\n        Invoices invoices2 = new Invoices();\n        invoices2.setId(123456789L);\n        Long id = invoices2.getId();\n        System.out.println(\"开始时间\" + System.currentTimeMillis());\n        System.out.println(id);\n        System.out.println(id);\n        System.out.println(id);\n        System.out.println(\"结束时间\" + System.currentTimeMillis());\n\n运行多次后发现第二种方式似乎消耗时间更短一点,但是差别不是很大.我的Id是Long类型,这种长数字型才稍微体现了一些性能上的差异,但是如果换成字符串且字符串较短则效率无差异.\n期望您的解答谢谢.", "Tag": "程序设计"}
{"Answer": "class Role:\n    def __init__(self, attackValue, skillName, roleName):\n        self.__attackValue = attackValue   # 普通攻击值，整型\n        self.__skillName = skillName  # 技能攻击名称，字符串\n        self.__roleName = roleName  # 角色名称，字符串\n    def commAttack(self):\n        print('{0}正在使用普通攻击，攻击力为{1}。'.format(self.__roleName, self.__attackValue))\n    def skillAttack(self):\n        print('{0}正在使用特殊攻击“{1}”。'.format(self.__roleName, self.__skillName))\n        \nclass GuanYu(Role):\n    def __init__(self):\n        super().__init__(10, '单刀赴会', \"关羽\" )\n        \nclass LvBu(Role):\n    def __init__(self):\n        super().__init__(15, '贪狼之握', \"吕布\" )\n    def skillAttack(self):\n        print('谁敢战我！！！', end = '')\n        super().skillAttack()\n        \nclass Control:\n    def __init__(self, obj):\n        obj.commAttack()\n        obj.skillAttack()\n\ng = GuanYu()\nl = LvBu()\ncg = Control(p)\ncl = Control(l)\n\n输出：\n关羽正在使用普通攻击，攻击力为10。\n关羽正在使用特殊攻击“单刀赴会”。\n吕布正在使用普通攻击，攻击力为15。\n谁敢战我！！！吕布正在使用特殊攻击“贪狼之握”。\n", "Knowledge_Point": "程序设计", "Question": "python编写程序设计编写程序，按如下要求设计类：\n王者荣耀是一款非常流行的即时对战类游戏，里面有很多的游戏角色可供选择。所有的角色都具有以下操作：普通攻击、技能攻击。\n创建一个基类（Role），该类包括如下成员：\n（1）属性：普通攻击值（attackValue，整数型）,技能攻击名称（skillName，字符串类型），角色名称（roleName，字符串类型），以上三个属性均为私有属性\n（2）方法：普通攻击（commAttack()），技能攻击（skillAttack()）\n           其中：普通攻击方法显示：XXX正在使用普通攻击，攻击力为XXX。”，XXX表示具体英雄的具体角色名与攻击值。\n                 技能攻击方法显示：XXX正在使用特殊攻击“XXX”。XXX表示具体的角色名称与技能攻击名称。\n   创建两个英雄角色，均继承基类\n关羽类（GuanYu）：普通攻击值10，技能攻击名称是“单刀赴会”\n吕布（LvBu）：普通攻击值15，技能攻击名称是“贪狼之握”，当使用吕布的技能攻击时，要显示：谁敢战我！！！吕布正在使用特殊攻击“贪狼之握”。\n创建一个控制类（Control），该类有一个方法，该方法用于接收传入的具体的英雄角色，该方法采用多态技术实现。\n当传入“关羽”时，显示如下信息：\n（1）当调用关羽的普通攻击方法时，在控制台显示：\n     关羽正在使用普通攻击，攻击力为10。\n（2）当调用关羽的技能攻击方法时，在控制台显示：\n     关羽正在使用特殊攻击“单刀赴会”。\n当传入“吕布”时，显示如下信息：\n（1）当调用吕布的普通攻击方法时，在控制台显示：\n     吕布正在使用普通攻击，攻击力为15。\n（2）当调用吕布的技能攻击方法时，在控制台显示：\n     谁敢战我！！！吕布正在使用特殊攻击“贪狼之握”。\n提示：注意在子类中可以使用super()方法使用父类的属性与方法。\n求求了求求了，太难了", "Tag": "程序设计"}
{"Answer": "\n\t    Scanner scan=new Scanner(System.in);\n\n\t\tint m=scan.nextInt();\n\t\tint n=scan.nextInt();\n\t\tint fan = 0,x=m,y=n;\n\t    if(m<n) {              //始终保持m比n大，\n\t    \tfan=m;m=n;n=fan;   \n\t    }\n\t\twhile(m%n!=0) {        //运用辗转相除法求出最大公约数\n\t\t\tfan=m%n;\n\t\t\tm=n;\n\t\t    n=fan;\n\t\t}\n\t\tSystem.out.println(n);\n\t\tSystem.out.print(x*y/n);//x*y除以最大公约数得到最小公倍数\n\n思路：\n1.辗转相除法：\n两整数m和n：\n（1）比较两数大小，若m小于n,交换\n（2） m%n得到余数fan\n（3）若fan为0时，则n是两个数的最大公约数\n（4）若fan不为0时，则m=n，n=fan，再执行（1），继续循环", "Knowledge_Point": "程序设计", "Question": "写两个函数，分别求两个整数的最大公约数和最小公倍数\n\n1.JAVA语言。\n\n2.描述它的解题思路。\n\n3.写出代码并注释。\n\n ", "Tag": "程序设计"}
{"Answer": "# 问题解决的话，请点下采纳\r\n```\r\n#include \r\n\r\nvoid fun(char *s, char *t, char *u)\r\n{\r\n\tint k = 0;\r\n\tfor (int i = 0; t[i]; i++)\r\n\t{\r\n\t\tint flag = 0;\r\n\t\tfor (int j = 0; s[j]; j++)\r\n\t\t{\r\n\t\t\tif (t[i] == s[j])\r\n\t\t\t{\r\n\t\t\t\tflag = 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag) u[k++] = t[i];\r\n\t}\r\n\tu[k] = 0;\r\n}\r\n\r\nint main()\r\n{\r\n\tchar *s = \"ABCDE\";\r\n\tchar *t = \"BDFGG\";\r\n\tchar u[100];\r\n\tfun(s,t,u);\r\n\tprintf(\"%s\\n\", u);\r\n\treturn 0;\r\n}\r\n```", "Knowledge_Point": "程序设计", "Question": "将未在字符串s中出现而在字符串t中出现的字符形成一个新的字符串放在u中，u中字符按原字符串中字符顺序排列，不去掉重复字符？60.\n编程题\n将未在字符串s中出现而在字符串t中出现的字符形成一个新的字符串放在u中，u中字符按原字符串中字符顺序排列，不去掉重复字符。\n测试数据：\ns：ABCDE， t：BDFGG\n运行结果：FGG\n请认真测试程序的正确性。将源代码以文本方式提交，不要直接提交文件。\n【算法提示】\n设计函数void fun(char *s, char *t, char *u)实现要求的功能，函数以字符指针作为参数，通过指针移动进行字符比较：\n设置两个字符指针p和q，p指针指向t串，q指针指向s串；通过移动指针p和q，将t串中的一个字母与s中的每个字母进行比较，若有相同的，则中断，再看t中的下一个，直到最后都没有相同的，放入u中。", "Tag": "程序设计"}
{"Answer": "N==0?func0():(N==1?func1:(N==2?func2():(N==3?func3():......)))就这样三目运算符嵌套", "Knowledge_Point": "程序设计", "Question": "除了if和switch...case还可以怎么判断\n\n下面是我的代码,想了很久只想到这一种,麻烦各位大牛说说看法\n\nint main()\n{\n    int n;\n    printf(\"请输入0-5的数字:\\n\");\n    scanf(\"%d\",&n);\n   while(n==0){F0();break;}\n   while(n==1){F1();break;}\n   while(n==2){F2();break;}\n   while(n==3){F3();break;}\n   while(n==4){F4();break;}\n   while(n==5){F5();break;}\nreturn 0;\n}", "Tag": "程序设计"}
{"Answer": "scanf(\"%d,%d\", &a,&c,&b);\n\n前后数量不一致 scanf(\"%d,%c,%d\", &a,&c,&b);", "Knowledge_Point": "程序设计", "Question": "在什么情况下,switch会不执行里面的case,直接跳过整个switch？？？", "Tag": "程序设计"}
{"Answer": "\nGiven your code, the g case will always evaluate to true:\nvar_dump('g' && ((5==5) || (3==3 || 4==4))); // true\n\nswitch cases use loose comparison and when $letter is g it will be evaluated with true.  Since g is loosley true it will execute that case:\nvar_dump('g' == true);  // true\nvar_dump('g' == false); // false\n\nYou probably need this:\n        case 'g':\n            if(($z || $y)) { echo \"g\"; }\n                break;\n\n", "Knowledge_Point": "程序设计", "Question": "对于Case的多个条件，Switch Statement无法正常工作\n\n$letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']; \n$x = (1==1 || 2==2);\n$y = (3==3 || 4==4);\n$z = (5==5);\n\nforeach ($letters as $key => $letter) {\n        switch ($letter) {\n            case 'a':\n                echo \"a\";\n                    break;\n            case 'b':\n                echo \"b\";\n                    break;\n            case 'c':\n                echo \"c\";\n                    break;\n            case 'd':\n                echo \"d\";\n                    break;\n            case 'e':\n                echo \"e\";\n                    break;\n            case 'f':\n                echo \"f\";\n                    break;\n            case 'g' && ($z || $y):\n                echo \"g\";\n                    break;\n            case 'h' && ($x):\n                echo \"h\";\n                    break;\n        }\n}\n\n\nI don't know why but at the last two cases the 'g' and 'h' It doesn't work properly and gets a double 'g', The result i expect is\n\nabcdefgh but i keep getting abcdefgg, What am I doing wrong?\n    ", "Tag": "程序设计"}
{"Answer": "5\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n    int i,n;\n    cout << \"输入n:\";\n    cin >> n;\n    int a[n];\n    cout << \"输入\"<<n<<\"个数:\";\n    for(i=0; i<n; i++)\n    {\n        cin >> a[i];\n    }\n    int min = 0;\n    for (i = 1; i < n; i++){\n        if (a[i]<a[min])\n            min = i;\n    }\n    cout << \"最小元素是:\" << a[min] << \",位置:\" << min << endl;\n    return 0;\n}\n\n\n\n6\n#include<iostream>\nusing namespace std;\n\nchar *getString()\n{\n    char *p = (char *)malloc(1000);\n    cin.getline(p,1000);\n    return p;\n}\nint main()\n{\n    cout << getString() << endl;\n    return 0;\n}\n", "Knowledge_Point": "程序设计", "Question": "c++请大家们回答一下问题1.从键盘输入一段字符（最多80个字符），分别统计出其中的字母、数字、空格和其他字符的个数，并将小写字母转变为大写字母输出。\n2.从键盘输入n个整数（n<1000），存放在一个一维数组中，输出其中的完全数。\n3.从键盘输入n个整数（n<1000），将这些数存放在一个一维数组中，求数列中所有数值的和及平均值，并从小到大输出所有偶数元素。\n4.从键盘输入一段字符，将字符串首尾互换，并与原字符串相连接后输出。\n 5、  用指针完成程序编写：从键盘输入n个整数（n<100），找出最小元素的位置，并输出。\n6、  设计一个函数char*get String(),从键盘接受一任意长度的字符串（以回车作为结束符），返回接收到的字符串的首地址。7、有10个学生，每个学生的数据包括学号、姓名、英语、数学、物理三门课的成绩，从键盘输入10个学生数据，要求打印出3门课程的总平均成绩，以及最高分的学生的数据（包括学号，姓名，3门课的平均成绩，平均分数）。8、设计一个2×2的矩阵结构体，然后计算一个矩阵A的n次幂。为了避免整型溢出，请输出矩阵中每个元素模109+7的结果。", "Tag": "程序设计"}
{"Answer": "应该答案错了吧，int 4字节，但是实际上总共占用32字节，因为还有补齐原则", "Knowledge_Point": "程序设计", "Question": "C语言结构体所占内存的字节数请问为什么是加上s数组的八个字节啊，题目没看懂怎么算的，晕了", "Tag": "程序设计"}
{"Answer": "你计算的是N！，你循环条件如果是<N的话，只能计算(N-1)!，因为当i加到N的时候会判断是否满足循环条件是否满足。", "Knowledge_Point": "程序设计", "Question": "为什么for循环里边小于号的话是不对的问题遇到的现象和发生背景\n这是一个阶乘的代码，为什么for循环里边小于号的话是不对的，而小于等于是对的，不是i<N时就i ++吗，为什么最后一次就不参与循环了？（可能我对for循环理解还不到位吧）请大家解答，谢谢", "Tag": "程序设计"}
{"Answer": "```\r\nfor(i = -1; i < LEN - 1;i++){\r\n->\r\nfor(i = -1; i < (int)LEN - 1;i++){\r\n```", "Knowledge_Point": "程序设计", "Question": "以下两种for循环的结果为什么不一样？int array[] = {1,2,3,4,5};\n#define LEN (sizeof(array) / sizeof(array[0]))\n\nint main(void)\n{\n    int i, sum = 0;\n    for(i = 0; i < LEN; i++){\n        printf(\"i = %d\\n\", i);\n        sum += array[i];\n    }\n    printf(\"%d\\n\", sum);\n\n    sum = 0;\n    for(i = -1; i < LEN - 1;i++){\n        printf(\"i = %d\\n\", i);\n        sum += array[i+1];\n    }\n    printf(\"%d\\n\", sum);\n    return 0;\n}\n\n\n我自己运行了一下，第一个for循环是对的，但是第二个for都没有开始，请问这是为什么？", "Tag": "程序设计"}
{"Answer": "multi是指针类型\r\n比如 声明一个指针对象可以2种方式\r\n1. node *p1 = new  node\r\n2.  multi  p2 = new node\r\n\r\np1 和  p2均为对象指针", "Knowledge_Point": "程序设计", "Question": "关与c语言中结构体typedef的用法\n\n之前学的都是c++版的数据结构，今天接触c语言数据结构，就是那个typedef后面那个\n\n*multi是什么意思？是类似于typedef node *multi,但是声明multi类型的是什么类型；\n\n\n\n刚开始接触c语言，还望大神指教", "Tag": "程序设计"}
{"Answer": "Node P                                              ---这个定义 的节点对象实例\r\n和 为变量 ANode Q                              ---这个定义了一个指向对象实例的指针\r\n创建空间\r\nP=（Node *）malloc（sizeof（Node））；            所以不能讲指针赋值给一个对象\r\n和 Q=(ANode)malloc（sizeof（ANode））；         定义有错，将4字节的内存强制转换为node指针，极其容易内存越界啊。\r\n\r\n正确用法是ANode   Q=（ANode）malloc（sizeof（Node））；", "Knowledge_Point": "程序设计", "Question": "关于内存分配的问题   关于内存分配，结构体定义式多定义了一个指针的情况\ntypedef struct node{ \n    int a; \n     int b;\n}Node, *ANode;\n那么为变量\nNode P \n和 为变量 ANode Q\n创建空间\nP=（Node *）malloc（sizeof（Node））；\n和 Q=(ANode)malloc（sizeof（ANode））；\n区别在哪里", "Tag": "程序设计"}
{"Answer": "break和continue放循环语句里。if只是作为判断是否break或者continue", "Knowledge_Point": "程序设计", "Question": "break和continue放在if语句里面\n这题这么理解break和continue放在if语句里面", "Tag": "程序设计"}
{"Answer": "使用typeof 看下返回值是否为boolean类型", "Knowledge_Point": "程序设计", "Question": "ajax的success方法中运行if（）语句的问题\n这里无论result返回的是false还是true，都不会执行if()代码块。\n无论result返回的是false还是true，都会执行if（）代码块。\n请问一下各位前辈，这是怎么回事？", "Tag": "程序设计"}
{"Answer": "from string import ascii_letters, digits\nfrom random import choice\n\nchoice_str = ascii_letters + digits\nchoice_list = [x for x in choice_str] #生成从中随机抽取的列表\n\nfor x in range(5): #生成5次\n    result = \"\"\n    \n    for y in range(6): #6位数\n        nres = choice(choice_list) #随机抽取\n        result += nres #拼接\n        \n    print(result) \n\n\n有帮助请采纳！", "Knowledge_Point": "程序设计", "Question": "python 编程 组合数据类型怎么写用组合数据类型的知识怎么写", "Tag": "程序设计"}
{"Answer": "\nint b=2;\nbyte b1=b;//b为int变量，无法直接赋值给byte\nbyte b2=2;//整数型常量且在byte范围内，编译自动默认为byte，通过 \nbyte b3=288;//超出byte范围编译不通过\n如果把一个较小的整数型常量（在byte或short范围内)赋值给byte或short,系统在编译时会自动将这个整数型常量当作byte或short来处理", "Knowledge_Point": "程序设计", "Question": "关于java数据类型转换我是一名java学习的初学者，我涉及到数据类型转换时有一个点把我难住了。\n\n①当要把数据范围大的数据类型赋值给数据范围小的类型的时候需要强制类型转换。\n\n所以就出现了类似 --》 int a = (int) 99.9;等表达式，那byte类型的数据范围比int类型的数据范围小，为何在赋值时不时 --》byte a = （byte）10；？而是直接的 --》 byte a = 10；呢？", "Tag": "程序设计"}
{"Answer": "申明变量，NewNode是Node类型的指针", "Knowledge_Point": "程序设计", "Question": "Node *NewNode = (Node *)malloc(sizeof(Node));等号前面代表什么Node *NewNode = (Node *)malloc(sizeof(Node));", "Tag": "程序设计"}
{"Answer": "晕，这不是引用啊，这是取地址符啊。就是取m1的地址，然后转换成const char*指针&只有在定义变量的时候才是引用的意思", "Knowledge_Point": "程序设计", "Question": "C++：为什么这里需要使用引用？ofs.write((const char *)&m1, sizeof(Maker));如题，为什么在ofs.write和ifs.read的时候需要添加引用？\n如果没有引用的话编译器报错：Error (active)        no suitable conversion function from \"Maker\" to \"const char *\" exist按照编译器报的错，加了引用就有转换的函数了?\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nclass Maker {\npublic:\n    Maker() = default;\n    Maker(const char * name,int age) {\n        strcpy(this->name, name);\n        this->age = age;\n    }\n    void printM() {\n        cout<<this->age<<\" \" << this->name<< endl;\n    }\npublic:\n    char name[64];\n    int age;\n};\nint main()\n{\n    Maker m1(\"小林\", 20);\n    Maker m2(\"布林\", 22);\n    ofstream ofs;\n    ofs.open(\"test.dat\", ios::out |ios::binary );\n    if (!ofs.is_open()) {\n        cout << \"打开文件失败\" << endl;\n    } \n    ofs.write((const char *)&m1, sizeof(Maker));//这里强制类型转换，会产生临时量\n    ofs.write((const char *)&m2, sizeof(Maker));\n    ofs.close();\n    ifstream ifs;\n    ifs.open(\"test.dat\", ios::in | ios::binary);\n    if (!ifs.is_open()) {\n        cout << \"dakaiwenjianshibai\" << endl;\n    }\n    Maker m3;\n    Maker m4;\n    ifs.read((char*)&m3, sizeof(Maker));\n    ifs.read((char*)&m4, sizeof(Maker));\n    m3.printM();\n    m4.printM();\n    system(\"pause\");\n    return 0;\n}\n\n", "Tag": "程序设计"}
{"Answer": "select case when phone1 is null then (\r\ncase when phone2 is null then phone3 else phone2 end\r\n) else phone1 end from users", "Knowledge_Point": "程序设计", "Question": "求sql语句中带有条件的查询我现在有一张users表，有字段uid，uname，address，phone1，phone2，phone3:\n我想在这张表中这样查：\n主要查phone1，但是如果有一条数据的phone1位空的话，就查phone2，如果phone1，phone2都为空就查phone3，这样的SQL语句要怎么写呢，求大神帮忙解答？？？？", "Tag": "程序设计"}
{"Answer": "```\r\n SqlConnection conn = new SqlConnection(连接字符串);\r\nconn.Open();\r\nSqlCommand cmd = new SqlCommand(\"select 部门,sum(工资) as 工资和 from table group by 部门\", conn);\r\nSqlDataReader dr = cmd.ExexuteReader();\r\ndr.Read();\r\nint i1 = int.Parse(dr[\"工资和\"],ToString());\r\ndr.Read();\r\nint i2 = int.Parse(dr[\"工资和\"],ToString());\r\ndr.Read();\r\nint i3 = int.Parse(dr[\"工资和\"],ToString());\r\n```", "Knowledge_Point": "程序设计", "Question": "使用c#语言获取sql查询结果并存入变量.select 部门,sum(工资) from table group by 部门\n上面的sql语句应该是对部门进行分组求工资的总和,\n假如分组后有3个部门,用C#语言如何获取这三个部门的工资总和?\n也就是要获取三个数值.最好把这三个数值存入变量 i1,i2,i3中.\n我是新手,希望高手能说详细些.", "Tag": "程序设计"}
{"Answer": "写了一个：\r\n#define LENGTH 10\r\nvoid exchange(int* a, int* b){\r\n  int t = *a;\r\n  *a = *b;\r\n  *b = t;\r\n}\r\n/*sort to 3 groups*/\r\nvoid main(){\r\n        int a[LENGTH] = {-1,0,0,2,0,4,-11,-89,0,100};\r\n        int i = 0, head = 0, tail = LENGTH -1;\r\n        printf(\"Data:\\n\");\r\n        while(i < LENGTH) printf(\"%d \",a[i++]);\r\n        printf(\"\\n\");\r\n\r\n        i = 0;\r\n        while(i <= tail){\r\n          printf(\"a[%d]:%d\\n\",i, a[i]);\r\n          if(a[i] > 0)\r\n            {\r\n              if (i != tail)\r\n                exchange(&a[i],&a[tail]);\r\n              tail--;\r\n              printf(\"tail:%d\\n\",tail);\r\n            }\r\n          else \r\n          {\r\n            if(a[i] < 0)\r\n            {\r\n              if (i != head)\r\n                exchange(&a[i],&a[head]);\r\n              head++;\r\n              printf(\"head:%d\\n\",head);\r\n            }\r\n            i++;\r\n          }\r\n        }\r\n        \r\n        i = 0;\r\n        printf(\"After:\\n\");\r\n        while(i < LENGTH) printf(\"%d \",a[i++]);\r\n        printf(\"\\n\");\r\n        \r\n}", "Knowledge_Point": "程序设计", "Question": "一个长度为n数组由负数0和正数组成，将其重新排列为前面是负数中间是0后面是正数的结构，要求时间复杂度为n一个长度为n数组由负数0和正数组成，将其重新排列为前面是负数中间是0后面是正数的结构，要求时间复杂度为n", "Tag": "程序设计"}
{"Answer": " 只是一个数值，付给一个short类型的变量而已。[/quote]\r\n\r\n还有了short 本身就是短整型。所以完全可以对其进行整型赋值，不要超出他的精度就可以了", "Knowledge_Point": "程序设计", "Question": "Java中整型字面值常量为什么可以赋值给short如：\n[code=\"java\"]short s = 3;[/code]\n3不是int型吗", "Tag": "程序设计"}
{"Answer": "python语言中，函数没有特别特殊的地位，而是和其他东西一样被视为对象，被称为可调用对象。既然是对象，当然可以进行赋值。从底层角度来讲，一个函数的可执行代码一定对应主存中的一个位置，函数名只是一个入口。那么，入口当然可以随意替换为其他函数体，函数体也可以有多个入口，甚至是没有入口（这种情况相当于对象失去引用，等待被销毁）。", "Knowledge_Point": "程序设计", "Question": "函数之间用等号赋值的含义等号不是赋值符号吗？函数是一种行为，这里用等号链接的具含义是啥？", "Tag": "程序设计"}
{"Answer": "问题已解决。使用了formSelect-v4.js", "Knowledge_Point": "程序设计", "Question": "layui 多选下拉框动态赋值后变为单选下拉框？动态赋值前\n动态赋值后\n\n多选效果没了html\n\n<div class=\"layui-form-item\">\n                <label class=\"layui-form-label\">多选</label>\n                <div class=\"layui-input-block\">\n                    <select multiple=\"multiple\" lay-filter=\"test\" id=\"tag2\">\n                        <option value=\"\">请选择</option>\n                        <option value=\"1\">1</option>\n                        <option value=\"2\">2</option>\n                        <option value=\"3\">3</option>\n                        <option value=\"4\">4</option>\n\n                    </select>\n                </div>\n            </div>\n\njs\n$.each(data, function (index, value) {\n                                $('#tag2').append(new Option(value.content,value.tagid));\n                            });\n", "Tag": "程序设计"}
{"Answer": "\n\n\r\n \t\tSELECT * FROM (SELECT * FROM WARNING_RECORD ORDER BY CREATE_TIME DESC )\r\nWHERE ROWNUM <= 5\t\t\t\r\n \t\t\n", "Knowledge_Point": "程序设计", "Question": "如何配置mybatis的SQL语句比如我要写入这条语句的话，如何配置XML\nSELECT * FROM (SELECT * FROM WARNING_RECORD ORDER BY CREATE_TIME DESC  )\nWHERE ROWNUM <= 5", "Tag": "程序设计"}
{"Answer": "类型改下\r\nint 改为number\r\nvarchar 改为varchar2\r\n等等.SQL语句应该差不多,就是类型不一样", "Knowledge_Point": "程序设计", "Question": "mysql建表语句到oracle怎么写？CREATE TABLE Advertisment (AdId int(8) NOT NULL auto_increment,AderId int(8) default NULL,AdName varchar(50) default NULL,AdKind varchar(30) default NULL,CreateMan varchar(30) default NULL,StartDate date default NULL,EndDate date default NULL,ReleaseMan varchar(30) default NULL,ReleaseDate date default NULL,AdType varchar(30) default NULL,AdPath varchar(100) default NULL,BannerContent text,HotelContent text,Status varchar(10) default NULL,PayStatus varchar(10) default NULL,Memo text,\n  PRIMARY KEY  (AdId),\n  KEY AderId (AderId)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='广告表' AUTO_INCREMENT=1 ;\n[b]问题补充：[/b]\n  KEY AderId (AderId) 这一句呢？你就给一句改完的吧，谢谢", "Tag": "程序设计"}
{"Answer": "多敲代码，没有捷径。", "Knowledge_Point": "程序设计", "Question": "自学java编程如何做会少走弯路呢我现在是一名软件测试人员，我想转行做java开发，平时也看一些java的视频和书籍。但我想尽快的转到java这行，想请教牛人指点一二，拨开我在学习上的云雾，我在此已不胜感激了", "Tag": "程序设计"}
{"Answer": "\n#include<iostream>\nusing namespace std;\nstruct test\n{\n    int a;\n    int b;\n    int c;\n};\nint main()\n{\n    int n;\n    cin >> n;\n    struct test t[n];\n    for(int j=0; j<n; j++)\n        cin >>t[j].a>>t[j].b>>t[j].c;\n    int maxa=t[0].a;\n    int maxb=t[0].b;\n    int maxc=t[0].c;\n    for(int j=1; j<n; j++)\n    {\n        if(t[j].a>maxa) maxa=t[j].a;\n        if(t[j].b>maxb) maxb=t[j].b;\n        if(t[j].c>maxc) maxc=t[j].c;\n    }\n    for(int j=0; j<n; j++)\n        if(t[j].a==maxa&&t[j].b==maxb&&t[j].c==maxc)\n        {\n            cout <<j+1;\n            return 1;\n        }\n    cout << -1;\n    return -1;\n}\n ", "Knowledge_Point": "程序设计", "Question": "难受，做出来全WA了题目描述让你构造一个结构体,包含(int a,int b,int c). 现有 n 个结构体,请输出满足以下条件的结构体的编号:它的 a,b,c 都是 n 个结构体中最大的. 如果不存在则输出 −1.输入格式第一行一个正整数 n 表示结构体数量. 接下来 n 行每行 3 个数,描述一个结构体输出格式一行若干个整数,表示编号或 −1.样例输入31 1 13 2 23 3 3样例输出3做出来全WA呀", "Tag": "程序设计"}
{"Answer": "\n\nor a dereferenced pointer symbol *\n\nThat is the norm, for complex non-value type, in order to avoid making a copy.\nSee Golang book \"Pointers\" for example of struct with pointer(s) in them.\nreturn &DB{db}\n\nThat returns a pointer to the newly created DB instance.\nAs noted in \"Can you “pin” an object in memory with Go?\":\n\nNote that, unlike in C, it's perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns\n\nFrom \"Pointer/Value Subtleties\":\n\nGo is also pass by value, but it has both pointers and value types. Pointers refer to a certain memory location, and allow you to mutate the data at that location\n\n\nFor more, see \"Best practice “returning” structs in Go?\"\n\nUse pointers for big structs or structs you'll have to change, and otherwise use values, because getting things changed by surprise via a pointer is confusing.\n\n", "Knowledge_Point": "程序设计", "Question": "解引用指向结构体中DB的指针\n\nUsually when I see a field declared on a struct it's without a pointer or a dereferenced pointer symbol *, however in several code snippets where I've seen a database field in a struct it's with a pointer dereference as you see below. Why is that necessary?\n\ntype DB struct {\n    *bolt.DB\n}\nfunc Open(path string, mode os.FileMode) (*DB, error) {\n    db, err := bolt.Open(path, mode)\n    if err != nil {\n        return nil, err\n    }\n    return &DB{db}, nil\n}\n\n    ", "Tag": "程序设计"}
{"Answer": "给你看个宝贝：所以按照这个优先级来看，把a=0；b=3；c=1；带入if条件，得到0+23+41 == 10，先算乘除再算加减，得到0+6+4 == 10，算完加法10 == 10，结果为true。", "Knowledge_Point": "程序设计", "Question": "关于Java if判断的问题\nif(a+2*b+4*c==10){i++}\n……\n\n\n上面if语句括号里判断的东西依次顺序是怎么走的。For循环abc的次数等于10就输出if方法题。但是我有点不明白if语句是用什么顺序来判断的呢。比如for嵌套…a=0:b=3:c=1:，在if语句是不是a+2b+41：a=0+2➡️2b+41=10我的猜想就是这样的，请问判断顺序是不是和我想的一样。", "Tag": "程序设计"}
{"Answer": "定时器当中做一个标志位，时间到了置为true 在While判断这个标志位，来实现跑马灯。。", "Knowledge_Point": "程序设计", "Question": "关于定时计数编写延时函数应用于跑马灯的问题,单片机初学者求解单片机C语言跑马灯定时计数器_cror_和_crol_ 是P0.0、P0.1、P0.2三口各接一个电阻再接高电平，之前用普通循环嵌套写的延时函数可用，而这次用定时计数器延时2s的延时函数，配上原先的主程序就出问题了，发现_crol_和_cror_移位函数出问题了，求改错，下面是我的代码:\n#include \"reg51.h\"\n#include \"intrins.h\"\n#define uint unsigned int\n#define uchar unsigned char\nvoid DELAYms( uint x )\n{\nuint t;\n t=x/50;\nwhile(1)\n{\nif(TF0==1)\n  { \n  t--;\n  TF0=0;\n  if(t==0)\nbreak;\nTH0=0x3c;\n    TL0=0xb0;\n  }\n  }\n}\n\nvoid main(void)\n{\n uchar i;\nTMOD=0x01;\n  TH0=0x3c;\n  TL0=0xb0;\n  TR0=1;\nP0=0xfe;\n while(1)\n { \n for(i=0;i<2;i++)\n   {\nDELAYms(2000);\n   P0=_crol_(P0,1);\n   }\n for(i=0;i<2;i++)\n   {\nDELAYms(2000);\n   P0=_cror_(P0,1);\n   }\n }\n}", "Tag": "程序设计"}
{"Answer": "q-p表示两个指针之间有多少个元素，不是内存大小。内存大小需要q-p再乘以指针类型的长度。强行用(int)转换成整型后，q和p就丢失了指针的特性，只是一个整数而已，整数之间相减，自然就等于实际的地址只差了", "Knowledge_Point": "程序设计", "Question": "如何理解指针之间的字节数int num, a[5] = {1, 2, 3, 4, 5};int *p = a, *q;                 //指针p指向元素a[0]q = p + 4;                        //相当于q = p + 4×sizeof(int)，将q指向a[4]num= q – p;                //指针q和p之间的元素个数，值为4num= (int)q – (int)p;     //指针q和p之间的字节数，值为16怎么样理解最后一行", "Tag": "程序设计"}
{"Answer": "首先了解fun函数的作用，fun的作用是交换地址，而不是交换值其次int p = &x 表示p为&x，也就是p为x的地址，p表示x的值接着第一次调用fun是传值调用，并不会改变x，y对应的地址，fun改变的只是x，y副本的地址所以第一次输出35接着是第二次fun函数调用，这次是指针传递，x，y的地址确实被改变，但是值得注意的是虽然x，y的地址交换了但是指针指向不变，也就是所p在x，y的地址交换后仍指向值为3的地址，q同理所以第二次printf输出35回答不易，有用请采纳下🤠", "Knowledge_Point": "程序设计", "Question": "为什么指针*p是x的值？\n我认为在主程序中x把地址赋予了指针P，那么指针p的值应该是X的地址而不是X的值", "Tag": "程序设计"}
{"Answer": "当他为false 时  使用这个注解可以不传这个参数  true时必须传required默认值是true你写成false说明可以不传，不传可不就是空指针吗", "Knowledge_Point": "程序设计", "Question": "服务端接口空指针异常我想从客户端或App上传文件到服务器，但是，接口的地方 ，我写的是@RequestParam，等，它为什么会报空指针呢？\n下面是接收文字信息的地方，\n\n如果没有传值，就会报错，那我在入参时，也没有写required=true呀，怎么报错了呢？", "Tag": "程序设计"}
{"Answer": "```java\r\n    public FileInputStream(String name) throws FileNotFoundException {\r\n        this(name != null ? new File(name) : null);\r\n    }\r\n```\r\n第一行它报的是FileNotFoundException\r\n这个没有错误啊\r\n你的流打开了是不是没有关闭阿", "Knowledge_Point": "程序设计", "Question": "缺省构造函数不能处理隐式超构造函数抛出的异常类型 IOException。必须定义显式构造函数int lastnum = getNum(source.getProperty(\"fileName\"));\n    public static int getNum(String Filename) throws IOException {\n\n    InputStream myxls;\n    myxls = new FileInputStream(Filename);\n    sr = new XSSFWorkbook(myxls);\n    XSSFSheet sheet = sr.getSheetAt(0);// 第一个工作表\n    return sheet.getLastRowNum();// 获取第一个工作表的行数\n}\n\n第一行报错：缺省构造函数不能处理隐式超构造函数抛出的异常类型 IOException。必须定义显式构造函数\n", "Tag": "程序设计"}
{"Answer": "你的程序不满足题意，没有用递归，递归写法如下：\r\n\r\n\r\n```\r\nint f(int n)\r\n{\r\nif (n == 1) return 1;\r\nreturn f(n - 1) * n;\r\n}\r\n```", "Knowledge_Point": "程序设计", "Question": "【问题描述】编写函数f，功能是用递归的方法求n！，函数原型为  int f(int n),在主函数中输入一个正整数n，调用函数f求出n！并在主函数中输出。#include \nlong long int f(int n)\n{\n    int i;\n    long long int m=1;\n    for(i=1;i<=n;i++)\n    m=m*i;\n    return m;\n}\nint main(int argc, char *argv[])\n{\n    int a;\n    scanf(\"%d\",&a);\n    printf(\"%d!=%lld\",a,f(a));\n    return 0;\n}\n求大佬帮助寻找错误", "Tag": "程序设计"}
{"Answer": "是需要画 x - g(f(x))的图像吗？ 在matlab中是比较容易实现的。\n如：\n\nx = linspace(1,10,100);\nfx = @(x)  sin(x)+0.1*x.^0.1;\ngy = @(y)  exp( 0.1 + 0.2*y + sqrt( 0.8+y.^2 ) );\nz =  gy(fx(x));\nplot(x,z)\n\n结果\n\n ", "Knowledge_Point": "程序设计", "Question": "matlab画复合函数的图像f(x)为一个分段函数，g(x)为一个复杂的指数函数", "Tag": "程序设计"}
{"Answer": "\npublic class Main {\n    public static void main(String[] args) {\n         // TODO Auto-generated method stub\n        int n,a,b;\n        n=5;\n        for(a=1; a<=n; a++) {\n            for(b=1; b<=a; b++) {\n                System.out.print(\" \");\n                System.out.print(b);\n            }\n            System.out.println();\n        }\n    }\n}\n\n", "Knowledge_Point": "程序设计", "Question": "用嵌套的for循环打印图案问题遇到的现象和发生背景\n想要的图案是11 21 2 31 2 3 41 2 3 4 5\n问题相关代码，请勿粘贴截图\npublic class hm3 {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        int n,a,b;\n        n=5;\n        for(a=1; a<=n; a++) {\n            for(b=1; b<=a; b++) {\n                System.out.print(\" \");\n                System.out.print(b);\n            }\n        }\n        \n        \n        \n        \n    }\n\n}\n\n\n\n运行结果及报错内容\n我的运行结果是112123123412345", "Tag": "程序设计"}
{"Answer": "v-for循环生成    el-table-column", "Knowledge_Point": "程序设计", "Question": "vue数据循环后放入表格vue数据循环后放入表格，这种数据结构怎么循环让表格可以加载出来啊，name是label表头，values是这一列的数据，因为是数组可能是多条\n\n", "Tag": "程序设计"}
{"Answer": "你都把p->next设置成null了,后面当然就退出while了, 这一行没必要", "Knowledge_Point": "程序设计", "Question": "while嵌套if循环问题只循环一次为什么在这个while嵌套if循环里面，if循环只循环一次呀，要怎么改捏helphelp", "Tag": "程序设计"}
{"Answer": "char sz[9][9]={0};\r\n数组下标范围是0-8\r\n你越界了", "Knowledge_Point": "程序设计", "Question": "c++输出二维数组的问题\n用for循环做了一下又想用数组做一下\n\n#include <iostream>\nusing namespace std;\nvoid main(){\n    int i=0,m=5;\n    char sz[9][9]={0};\n    for(;i<=8;i++){\n        if(i<=4){\n        for(int k=0;k<=i;k++){\n            sz[i][m-k]=sz[i][m+k]='*';}\n        }\n        if(i>4){\n            for(int o=8-i;o>=0;o--){\n                sz[i][m-o]=sz[i][m+o]='*';}\n        }\n    }\n    for(int t=1;t<=9;t++){\n        for(int y=1;y<=9;y++){\n            cout<<sz[t][y];}\n            cout<<'\\n';\n    }\n}\n\n\n\n\n\n但是结果产生了乱码\n自己没找到错误，初学者求助", "Tag": "程序设计"}
{"Answer": "```\r\n$orders=array(\r\narray(\r\n\"ordersn\"=>'2019564842348',\r\n\"proName\"=>'拖鞋',\r\n\"name\"=>'张三',\r\n\"phone\"=>\"1800952442\",\r\n\"proNum\"=>2,\r\n\"proPrice\"=>35.85\r\n),\r\narray(\r\n\"ordersn\"=>'2019564842348',\r\n\"proName\"=>'棉签',\r\n\"name\"=>'张三',\r\n\"phone\"=>\"1800952442\",\r\n\"proNum\"=>1,\r\n\"proPrice\"=>12\r\n),\r\narray(\r\n\"ordersn\"=>'25451548412487',\r\n\"proName\"=>'电脑',\r\n\"name\"=>'李四',\r\n\"phone\"=>\"1564845487\",\r\n\"proNum\"=>1,\r\n\"proPrice\"=>4600\r\n),\r\n);\r\n$returnData = [];\r\nforeach($orders as $k => $v){\r\nif(isset($returnData[$v['ordersn']])){\r\n\t\t$returnData[$v['ordersn']]['product'][] = [\r\n\t\t\t\t'proName'  => $v['proName'],\r\n\t\t\t\t'proNum'   => $v['proNum'],\r\n\t\t\t\t'proPrice' => $v['proPrice'] \r\n\t\t];\r\n\t}else{\r\n\t\t$returnData[$v['ordersn']] = [\r\n\t\t\t'ordersn' => $v['ordersn'],\r\n\t\t\t'product' => [[\r\n\t\t\t\t'proName'  => $v['proName'],\r\n\t\t\t\t'proNum'   => $v['proNum'],\r\n\t\t\t\t'proPrice' => $v['proPrice'] \r\n\t\t\t]],\r\n\t\t\t'name'  => $v['name'],\r\n\t\t\t'phone' => $v['phone']\r\n\t\t];\r\n\t}\r\n}\r\nprint_r(array_values($returnData));die;\r\n```", "Knowledge_Point": "程序设计", "Question": "二维数组根据相同值组成新数组？旧数组：\n\n\n$orders=array(\n                array(\n                        \"ordersn\"=>'2019564842348',\n                        \"proName\"=>'拖鞋',\n                        \"name\"=>'张三',\n                        \"phone\"=>\"1800952442\",\n                        \"proNum\"=>2,\n                        \"proPrice\"=>35.85\n                    ),\n                array(\n                        \"ordersn\"=>'2019564842348',\n                        \"proName\"=>'棉签',\n                        \"name\"=>'张三',\n                        \"phone\"=>\"1800952442\",\n                        \"proNum\"=>1,\n                        \"proPrice\"=>12\n                    ),\n                array(\n                        \"ordersn\"=>'25451548412487',\n                        \"proName\"=>'电脑',\n                        \"name\"=>'李四',\n                        \"phone\"=>\"1564845487\",\n                        \"proNum\"=>1,\n                        \"proPrice\"=>4600\n                    ),\n        );\n\n\n如何通过相同的ordersn组装成新数组:\n\n\n$orders=array(\n    array(\n            \"ordersn\"=>'2019564842348',\n            \"product\"=>array(\n                    array(\n                            \"proName\"=>'拖鞋',\n                            \"proNum\"=>2,\n                            \"proPrice\"=>35.85\n                        ),\n                    array(\n                            \"proName\"=>'棉签',\n                            \"proNum\"=>1,\n                            \"proPrice\"=>12\n                        ),\n                ),\n            \"name\"=>'张三',\n            \"phone\"=>'1800952442'\n        ),\n    array(\n            \"ordersn\"=>'25451548412487',\n            \"product\"=>array(\n                    array(\n                            \"proName\"=>'电脑',\n                            \"proNum\"=>1,\n                            \"proPrice\"=>4600\n                        ),\n                ),\n            \"name\"=>'李四',\n            \"phpone\"=>\"1564845487\",\n        ),\n    );\n\n", "Tag": "程序设计"}
{"Answer": "#include <stdio.h>\n\nint main(void)\n{\n    int m, n;\n    int i, j, k, min = 0, found = 0;\n    scanf(\"%d%d\", &m, &n);\n    int a[m][n];\n    for (i = 0; i < m; i++)\n        for (j = 0; j < n; j++)\n            scanf(\"%d\", &a[i][j]);\n    for (i = 0; i < m; i++)\n    {\n        for (j = 0; j < n; j++)\n            if (a[i][j] > a[i][min])\n                min = j;\n        for (k = 0; k < m; k++)\n            if (a[i][min] > a[k][min])\n                break;\n        if (k == m) {\n            printf(\"Array[%d][%d]=%d\", i, min, a[i][min]);\n            found = 1;\n            break;\n        }\n    }\n    if (!found)\n        printf(\"None\");\n    return 0;\n}\n", "Knowledge_Point": "程序设计", "Question": "c语言鞍点的求法，只有一列的特殊情况#include<stdio.h>int main(void){    /Begin/int m,n;int i,j,k,flag,pos,max;scanf(\"%d %d\",&m,&n);int a[m][n];for(i=0;i<m;i++){    for(j=0;j<n;j++){        scanf(\"%d\",&a[i][j]);    }}for(i=0;i<m;i++){    max=a[i][0];    pos=0;    for(j=0;j<n;j++){        if(a[i][j]>max){            max=a[i][j];            pos=j;        }    }flag=1;    for(k=0;k<n;k++){        if(a[k][pos]<max){            flag=0;        }        if(flag==1){            printf(\"Array[%d][%d]=%d\",k,pos,max);        }break;        if(flag==0){            printf(\"None\");        }    }\n}\n/*********End**********/\nreturn 0;\n\n}\n", "Tag": "程序设计"}
{"Answer": "先提取素数，然后再排序\n//从键盘中输入10个正整数到一个一维数组，将数组中的素数按从小到大的顺序排列后输出\n#include <stdio.h>\nint isprime(int n)\n{\n    int i;\n    if(n<2)\n      return 0;\n    for(i=2;i*i<=n;i++)\n      if(n%i==0)\n        return 0;\n    return 1;\n}\nint main()\n{\n    int a[10];\n    int i,j=0,n=0,t;\n    for(i=0;i<10;i++)\n        scanf(\"%d\",&a[i]);\n    for(i=0;i<10;i++)\n        if(isprime(a[i]))\n           a[n++] = a[i];\n    if(n==0)\n        printf(\"Not Found\");\n    else\n    {\n    for(i=0;i<n-1;i++)\n        for(j=0;j<n-i-1;j++)\n        {\n            if(a[j] > a[j+1])\n            {\n                t = a[j];\n                a[j] = a[j+1];\n                a[j+1] = t;\n            }\n        }\n    for(i=0;i<n;i++)\n        printf(\"%d \",a[i]);\n    }\n    return 0;\n}\n\n", "Knowledge_Point": "程序设计", "Question": "C或者C++，从键盘中输入10个正整数到一个一维数组，将数组中的素数按从小到大的顺序排列后输出C或者C++，从键盘中输入10个正整数到一个一维数组，将数组中的素数按从小到大的顺序排列后输出", "Tag": "程序设计"}
{"Answer": "改动处见注释，供参考：\n#include<stdio.h>\n#define N 20\nint main()\n{\n    int a[N]={ 0 }, b[N]={ 0 };\n    int an,bn,c[N+N];\n    int *i, *j,*k;\n    scanf(\"%d\",&an);   //输入数组a元素个数\n    for(i=a;i<a+an;i++)\n    {\n        scanf(\"%d\",i);\n    }\n    scanf(\"%d\",&bn);   //输入数组b元素个数\n    for(j=b;j<b+bn;j++)\n    {\n        scanf(\"%d\",j);\n    }\n    for(i=a,j=b,k=c;i<a+an && j<b+bn;k++)//(i=a,j=b,k=c;i<a+an,j<b+bn,k<c+an+bn;k++)\n    {\n        if(*i>*j)\n        {\n            *k=*j;\n            j++;\n        }\n        else\n        {\n            *k=*i;\n            i++;\n        }\n    }\n    if(i<a+an)//&& j>=b+bn)\n    {\n        for(;i<a+an;i++,k++)//(i=a+bn,k=c+2*bn;i<a+an,k<c+an+bn;i++,k++)\n        {\n            *k=*i;\n        }\n    }\n    else if(j<b+bn) //&& i>=a+an)\n    {\n        for(;j<b+bn;j++,k++)//(j=b+an,k=c+2*an;j<b+bn,k<c+an+bn;j++,k++)\n        {\n            *k=*j;\n        }\n    }\n    for(k=c;k<c+an+bn;k++)\n    {\n        printf(\"%d \",*k);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n", "Knowledge_Point": "程序设计", "Question": "用指针方法实现将两个有序的数组合并成一个有序数组问题遇到的现象和发生背景\n用指针方法实现将两个有序的数组合并成一个有序数组用指针方法编写程序，分别输入两个按从小到大排序的数组 a 和 b，将这两个有序数组合并，使合并后的数组 c 仍是从小到大有序的。\n用代码块功能插入代码，请勿粘贴截图\n\n\n#include<stdio.h>\n#define N 20\nint main()\n{\n\n    int a[N]={ 0 }, b[N]={ 0 };\n    int an,bn,c[N+N];\n    int *i, *j,*k;\n    scanf(\"%d\",&an);   //输入数组a元素个数\n    for(i=a;i<a+an;i++)\n    {\n        scanf(\"%d\",i);\n    }\n    scanf(\"%d\",&bn);   //输入数组b元素个数\n    for(j=b;j<b+bn;j++)\n    {\n        scanf(\"%d\",j);\n    }\n    for(i=a,j=b,k=c;i<a+an,j<b+bn,k<c+an+bn;k++)\n    {\n        if(*i>*j)\n        {\n            *k=*j;\n            j++;\n        }\n        else\n        {\n            *k=*i;\n            i++;\n        }\n    }\n    if(i<a+an && j>=b+bn)\n    {\n        for(i=a+bn,k=c+2*bn;i<a+an,k<c+an+bn;i++,k++)\n        {\n            *k=*i;\n        }\n    }\n    else if(j<b+bn && i>=a+an)\n    {\n        for(j=b+an,k=c+2*an;j<b+bn,k<c+an+bn;j++,k++)\n        {\n            *k=*j;\n        }\n    }\n    for(k=c;k<c+an+bn;k++)\n    {\n        printf(\"%d \",*k);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n\n\n运行结果及报错内容\n测试输入81 5 14 26 48 50 55 6054 26 29 37 78预期结果1 4 5 14 26 26 29 37 48 50 55 60 78实际输出1 4 5 14 26 26 29 37 48 50 55 60 0 \n我的解答思路和尝试过的方法\na和b都有数据时比较，谁小谁放在c里面，然后用判断语句来看谁还有剩余的数据，将他继续放到c里面。大概就是这样。\n我想要达到的结果\n结果就是，三种测试输入，都有数据错误，不知道怎么回事，可能是我现在没看出来，但希望有人来讲解一下。", "Tag": "程序设计"}
{"Answer": "把&去掉，因为你穿入的参数多了一维", "Knowledge_Point": "程序设计", "Question": "请大家指点，c语言中，结构体作为形参传递且结构体中含有二维数组typedef struct\n{\n    u8 z[3][3];\n}Data\nvoid abcd(Data data)\n{\n    data->z[0][0]=3;\n}\n/*********************以上均没报错****************************/\nvoid efgh（Data data）\n{\n    data->z[1][1]=2;\n    abcd（&data）；//出错\n}\n/************************此句报错**************************************/\n..\\HARDWARE\\CROSS\\cross.c(83): error:  #167: argument of type \"\ndata **\" is incompatible with parameter of type \"data *\"\n程序大致就是这样定义的，不知道该怎么改，卡了好久，请大家帮帮忙，谢谢。", "Tag": "程序设计"}
{"Answer": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid swap(char *p1,char *p2){\n    char p[20];   //这边要记得定义一个临时指针\n    strcpy(p,p1);\n    strcpy(p1,p2);\n    strcpy(p2,p);\n}\n\nint main(){\n    char str[6][20];          //自定义的数组数值是我随意定的\n\n    int i=0;\n    int j=0;\n    int len = 6;\n    printf(\"请输入六行：\\n\");\n    for(i=0;i<6;i++)\n    {\n            gets(str[i]);\n    }\n    for (i=0; i<len-1; ++i)\n    {\n        for (j=0; j<len-1-i; ++j)\n        {\n            if (strcmp(str[j],str[j+1])>0)  // >表示升序 <表示降序\n            {\n                swap(str[j],str[j+1]);\n            }\n        }\n    }\n\n    printf(\"Now,the order is:\\n\");\n    for(i=0;i<6;i++)\n    {\n            printf(\"%s\\n\",str[i]);\n    }\n\n    return 0;\n}\n\n\n", "Knowledge_Point": "程序设计", "Question": "C语言名字排序指针输出在主函数中输入6个人的姓名（用二维数组定义），然后调用函数，把这6个人按名称拼音顺序排序，形参要用到指向一维数组的指针变量。然后在主函数中按序输出出来。", "Tag": "程序设计"}
{"Answer": "multiprocessing.freeze_support() 放在入口py文件（你的主程序）的if __name__==\"__main__\":的后面", "Knowledge_Point": "程序设计", "Question": "python多进程程序打包后，运行出现多个窗口，应该如果解决打包前，在pycharm中直接运行，多进程也是一个窗口。打包后（pyinstaller、NSIS都试过），运行时出现多个窗口，增加的窗口数与进程数量一样，程序好像也不运行了。。。\n\n怎么解决程序这个问题？因为必须有GUI来输入多进程操作的文件路径和进程数量，用的是pyqt5。\n\n说明：涉及到部分内容，多线程实现不太方便，所以使用多进程。\n\n主程序：\n\n\nfrom test_tart import Ui_MainWindow\nfrom PyQt5 import QtWidgets\nimport main_test\nimport sys\nimport time\n\nclass mywindow(QtWidgets.QMainWindow, Ui_MainWindow):\n\n    def __init__(self):\n        super(mywindow, self).__init__()\n        self.setupUi(self)\n        self.pushButton.clicked.connect(self.mains)\n\n    def mains(self):\n        path = self.lineEdit.text()\n        num = int(self.lineEdit_4.text())\n        t1 = float(time.time())\n        length = main_test.totest(path, num)\n        t2 = float(time.time())\n        t = str((t2-t1)/length)\n        self.lineEdit_2.setText(t)\n        # print((t2-t1)/length)\n\n\nif __name__==\"__main__\":\n\n    app=QtWidgets.QApplication(sys.argv)\n    myshow=mywindow()\n    myshow.show()\n    sys.exit(app.exec_())\n\n调用程序（多进程实现部分）：\n\n\ndef totest(filepathtt, i):\n# if __name__ == '__main__':\n    multiprocessing.freeze_support()\n    Data_filePath = os.listdir(filepathtt)\n    DfilePath = [filepathtt +'\\\\'+ x for x in Data_filePath]\n    # print(time.time())\n    with ProcessPool(processes= i) as pool:\n        pool.map(test, DfilePath)\n        # print(time.time())\n    return len(Data_filePath)", "Tag": "程序设计"}
{"Answer": "跳出最近的一层swith或者for，while，要跳出指定层用标签来做。\r\n\r\n```\r\n \r\n    lbFor:for(var i=0;i<5;i++)\r\n      lbS1:  switch (i) {\r\n            case 3: break lbFor;\r\n            default:\r\n                switch (i) {\r\n                    case 1: break lbS1;\r\n                    default: alert(i);\r\n                }\r\n                alert(i)//不会输出1\r\n        }\r\n```", "Knowledge_Point": "程序设计", "Question": "javascript中switchi和for循环的break语句放在一起，是跳出哪个语句呢？javascript中switchi和for循环的break语句放在一起，是跳出哪个语句呢？", "Tag": "程序设计"}
{"Answer": "\nYou can tell whether a node has a namespace by checking ->prefix or ->namespaceURI:\nforeach ($doc->getElementsByTagName('link') as $link) {\n    if (strlen($link->prefix)) {\n        continue;\n    }\n    // $link does not have prefix\n}\n\n", "Knowledge_Point": "程序设计", "Question": "只在PHP DOM中选择没有名称空间/前缀的节点？\n\nI'm trying to read some RSS feeds with DOM in PHP like this one:\n\n    <channel>\n        <atom:link href='' rel='self' type='application/rss+xml' />\n        <title>TechStuff</title>\n        <link>http://www.howstuffworks.com</link>\n\n\nTo grab the link (<link></link>) I use this piece of code:\n\n    $doc->getElementsByTagName('link')->item(0);\n\n\nIt works in all other RSS feeds that I have tried. But this one has placed <atom:link> before <link>, which means that it grabs <atom:link> instead.\n\nSo how do I do to only select nodes without a namespace?\n    ", "Tag": "程序设计"}
{"Answer": "Map保存起来  一个手机号对应一个验证码", "Knowledge_Point": "程序设计", "Question": "小程序 手机号+短信验证码登录问题场景：\n            我定义了两个全局静态变量 mobile 和message（短信验证码）\n            多人同时登录\n            发送短信验证码是一个接口 会把验证码和手机号赋值给两个静态变量\n             之后访问登录用这个接口   会验证传过来的手机号 验证码 和静态变量里面的\n            手机号和验证码\n            出现的问题：\n            短信发送成功 但是在登录这个接口中验证手机号的时候 手机号验证不一致\n\n        按理来说 没登录一个人 tomcat会开放不同的线程 （本人对线程没做操作）\n        不会出现上述那个问题\n\n\n\n        求大佬解答下为什么会出现这个问题\n", "Tag": "程序设计"}
{"Answer": "```\r\n     scanf(\"%o\",&a); //8进制读取\r\n    b=a>>4; //右移4位，a是无符号的，左边补0, ---> 2的4次方=16, 所以 相当于 b = a / 16\r\n    c=~(~0<<4); 对0先按位取反, 得 -1，再左移4位,, 低位补0,  得 -16 (111...1110000), 再取反,得 (000...0001111), 即 15\r\n    d=b&c //按位与, 因为 c=15 的二进制只有低4位是1,  也就是把b的二进制只取低4位, 其余位全置0, 相当于 d = b % 16\r\n\t\t所以, 最后的结果相当于 d = a / 16 % 16\r\n\t\tprintf(\"%o\\n%o\\n\",a,d); // 以8进制输出\r\n```", "Knowledge_Point": "程序设计", "Question": "c语言程序，按位取反问题，求帮助#include\nvoid main()\n{\n    unsigned a,b,c,d;\n    scanf(\"%o\",&a);\n    b=a>>4;\n    c=~(~0<<4);\n    d=b&c;\n    printf(\"%o\\n%o\\n\",a,d);\n}\n\n这个结果不懂，求帮忙解决", "Tag": "程序设计"}
{"Answer": "数据存成文本文件，如果不需要数据保存的话直接放在内存里就OK了", "Knowledge_Point": "程序设计", "Question": "用c#编写一个学生信息添加程序，学生信息包括学号，姓名，性别用c#编写一个学生信息添加程序，学生信息包括学号，姓名，性别，有不用数据库做出来的吗，之是一个简单的小程序", "Tag": "程序设计"}
{"Answer": "你创建的是空工程，肯定无法运行，根据你描述你应该是要做一个mfc工程，那么创建个对话框即可。", "Knowledge_Point": "程序设计", "Question": "Opengl小程序 VS2019  fatal error C1107: 未能找到程序集“platform.winmd”: 请使用 /AI 或通过设置 LIBPATH 环境变量指定程序集搜索路径操作系统：WIN10\n\n平台:VS 2019 Community\n\n工程类型：C++空程序\n\n目标程序：Opengl小程序\n\n原博客网址：https://blog.csdn.net/Jennifer_Love_Frank/article/details/85012774\n\n因为博主不予回答指导，故在此进行请教各位大佬们，只要能够在本机上正常运行即可\n这里由于题主是一名小白，在网上查询的水平不足，也没有找到确实能用的解决方法\n麻烦各位大佬，细讲一下（包含不限于：驱动下载啊，文件路径如何设置，项目属性设置，等等很入门等级的问题），感谢大佬们\n如果哪位大佬可以在 自己电脑上 以 上述环境 成功运行的话，请务必私聊指导一下,感谢！\n\n(以下附一些图)(该题所采纳的回答是不对的，请各位注意)（有想法的可以在底底下回复一下，我们私下交流）\n\n", "Tag": "程序设计"}
{"Answer": "楼主可以通过查看依赖库的软件（比如windows depends）把所有依赖的DLL都打包起来\r\n和你的EXE一起拷贝到别的电脑上就能直接跑 了", "Knowledge_Point": "程序设计", "Question": "我用qtcreator（msvc2015）编译的程序发布问题我下载了vs2015 64位的，然后下载了qt5.6（vs下的），我没有打开vs，直接在qtcreator下编写程序，现在发布程序的时候我用windeployqt 能自动加载我所需要的所有qt有关的dll，但是在别的没有vs2015的机器上运行部起来，确实vs2015的运行库，我现在临时解决方法是下载了vc_redist.x64.exe这个vs2015运行库。每次都要先运行下这个exe再运行我发布的那个exe，我想问下有没有vs2015对应的dll我能直接放入我的发布程序中，直接运行我发布的那个exe就可以运行程序。", "Tag": "程序设计"}
{"Answer": "望采纳\ntemplate即模板，class指类别，T是类别的统称，可以使int、char，float，double等等。在PrintArray打印各数时，当参数是a，则T为int，当参数是b，则T为double，当参数是c，则T为char。", "Knowledge_Point": "程序设计", "Question": "在c++中，template<class T>中的T是什么呀？在c++语言中，template中的T是什么东西呀呀！！呀？", "Tag": "程序设计"}
{"Answer": "试试\nfunction (d) {\n            return `<select name=\"aaa\" lay-verify=\"required\">\n                 <option value=\"0\" ${d.taskNature === 0 ? \"selected\":\"\"}>未完成</option>\n                  <option value=\"1\" ${d.taskNature === 1 ? \"selected\":\"\"}>已完成</option>\n                 </select>`;\n        },\n", "Knowledge_Point": "程序设计", "Question": "JS在字符串中怎么使用if语句\nfunction (d) {\n                      return '<select name=\"aaa\" lay-verify=\"required\">\\n' +\n                        ' <option value=\"0\" ${d.taskNature === 0 ? \"selected\":\"\"}>未完成</option>\\n' +\n                        '  <option value=\"1\" ${d.taskNature === 1 ? \"selected\":\"\"}>已完成</option>\\n' +\n                        ' </select>';\n                    }\n                \n\nd.taskNature 这个值是可以获取到的， 怎么在字符串中输出selected字符串，根据d.taskNature 这个值。", "Tag": "程序设计"}
{"Answer": "错误不在这里，要把程序贴全。数据类型不对，先检查 train_dataloader 内容对不对。", "Knowledge_Point": "程序设计", "Question": "python代码报错device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\nfor  batch_idx, batch in enumerate(train_dataloader, 0): #枚举类型\n    x_p,x_c,y=map(lambda x: x.to(device), batch)\n    print(\"*********\")\n    print(\"punchline shape: \",x_p.shape)\n    print(\"context shape: \",x_c.shape)\n    print(\"humor labels: \",y)\n    if batch_idx==5:\n    break\n\n第二行代码报错IndexError: only integers, slices (:), ellipsis (...), numpy.newaxis (None) and integer or boolean arrays are valid indices", "Tag": "程序设计"}
{"Answer": "DABDD✘✘✔", "Knowledge_Point": "程序设计", "Question": "2019-2021C语言考试试题1：以下叙述不正确的是：（  ）\n\nA：一个C源程序可由一个或多个函数构成\n\nB：一个C源程序必须包含一个main函数\n\nC：C程序的基本组成单位是函数\n\nD：在对一个C程序进行编译的过程中，可以发现注释中的拼写错误\n\n2：以下说法正确的是（ ）\n\nA：C源程序经编译和链接后才可直接运行产生结果\n\nB：C源程序经编译后才可直接运行产生结果\n\nC：C源程序经链接后才可直接运行产生结果\n\nD：C源程序可以直接运行产生结果\n\n3：字符常量在内存中存放的是：（  ）\n\nA：BCD码\n\nB：ASCII码\n\nC：内部码\n\nD：十进制码\n\n4：下列程序段执行后，变量X的值是（ ）\n\n     For(x=2;x<10;x+=3)\n\nA:2\n\nB:9\n\nC:10\n\nD;11\n\n5：int a[4]={2,3,5,9};其中a[3]值为（ ）\n\nA：2\n\nB：3\n\nC：5\n\nD：9\n\n6:若有以下数组说明，则数值最小的和最大的元素下标分别是（ ）\n\n       int a[10]={1,2,3,4,5,6,7,8,9,10}\n\nA:1,10\n\nB:0,10\n\nC:1,9\n\nD:0,9\n\n判断：\n\n1：若a为int型变量，则表达式（a=5*5,a*2）,a+6的值为26   （   ）\n\n2：若以下变量均是整型，且num=sum=7;则计算表达式sun=num++,sun++,++num后sun的值为8 （   ）\n\n3：已知 A=6  B=1  C=4  ，表达式A>B&&C>AII!A<B&&!C>B的值是1 （", "Tag": "程序设计"}
{"Answer": "这是正常的啊，注释的那一行本来就是有缩进的。注释只是在前面加上<!--，保留其余部分。取消注释后还可以恢复正常。", "Knowledge_Point": "程序设计", "Question": "webstorm关于注释的疑问  我发现在webstorm中, 在html文件中进行注释的时候, 会出现如下情况:\n\n\n注释前: -\n\n注释后:-\n\n    这样看来, 一点也不对劲, 文字不对齐, 前面还空了这么多, 请问有没有哪位大佬知道怎么解决呀\n", "Tag": "程序设计"}
{"Answer": "\nUse PHP's built-in in_array function:\nif ( in_array($counts, $numbers) ) {echo 'counts equals your numbers';}\n\n", "Knowledge_Point": "程序设计", "Question": "使用||递增和if语句\n\nI'm trying to get the if statement to echo inline styles. However I can only get my conditional to return true on any 1 number, not with an array, a || to separate etc...\n\nCan you please explain how to make the || version and an array of numbers return true in my conditional.\n\n// Works.\n$counts = 0 ;\nforeach ($posts as $post) : setup_postdata($post); $counts++; \n if ($counts == 8) {echo 'counts equals your numbers';}\nendforeach; \n\n// This does nothing.\n$numbers = array(4,8);\n$counts = 0 ;\nforeach ($posts as $post) : setup_postdata($post); $counts++; \n if ($counts == $numbers) {echo 'counts equals your numbers';}\nendforeach; \n\n// Returns true for every iteration.\n$counts = 0 ;\nforeach ($posts as $post) : setup_postdata($post); $counts++; \n if ($counts == 4 || 8) {echo 'counts equals your numbers';}\nendforeach; \n\n    ", "Tag": "程序设计"}
{"Answer": "代码：\n#include<stdio.h>\n\nint main() {\n    float gangpen = 3;\n    float yuanpen = 2;\n    float qianpen = 0.5;\n    \n    for (int i = 1; i < 33; i++) {\n        for (int j = 1; j < 50; j++) {\n            for (int k = 1; k < 200; k++) {\n                if (i * gangpen + j * yuanpen + qianpen * k == 100) {\n                    printf(\"需要钢笔: %d  , \",i);\n                    printf(\"需要圆珠笔: %d , \" , j);\n                    printf(\"需要铅笔: %d\\n\" , k);\n                }\n            }\n        }\n    }\n\n\n    return 0;\n}\n\n结果：这里简单说下for循环吧，我们找到最小值，必须都有一个，所以所有for循环最小值为1，最大值就是比如，铅笔最多只能买100、0.5=200,但是肯定买不了200个所以小于200，其他一样，反正简单写了下，望采纳，谢谢", "Knowledge_Point": "程序设计", "Question": "用C语言编程，设用100元钱买100支笔，其中钢笔每支3元，圆珠笔每支2元，铅笔每支0.5元，问钢笔、圆珠笔和铅笔可以各买多少支（每种笔至少买1支）。用C语言编程，设用100元钱买100支笔，其中钢笔每支3元，圆珠笔每支2元，铅笔每支0.5元，问钢笔、圆珠笔和铅笔可以各买多少支（每种笔至少买1支）。", "Tag": "程序设计"}
{"Answer": "项目经验很重要，这能加深你对你所学的东西，看的书的理解。\r\n\r\n你喜欢web，那好，你就可以多关注这方便的东西。首先是一些J2EE规范，一些servlet，filter等等，然后一些常用的框架的使用，然后就可以研究一些开源框架等等。\r\n\r\n还是要说基础，基础一定要好，不仅会用还要知道为什么，多看看think in java不错，然后是java核心，接着是 effective java 第二版。这些看了你的基础就差不多了，可以选择了解《深入java虚拟机》。。\r\n\r\n然后可以看一些设计模式，这是要知道的，看《重构-改善代码设计》的等还有其他，可以一步步摸索着来。多去一些论坛，看大家都在谈论什么！", "Knowledge_Point": "程序设计", "Question": "再遇学习中的迷茫，请前辈们点播。。记得上次我在JE上提过这样的问题，当时各位前辈们有积极的对我进行了指点和帮助，这么长时间过去了，之间也做了项目，但是却没有停止我学习的脚步，前一段时间一直在看pl/sql编程指南，对着上面的例子，反复学习，推敲，并且亲身去体验，知道了oracle是如此这般的强大，我们知道的还很少，但是，看了之后发现，上面的知识，离我的应用好远好远，基本上用到的为零。当然了，他的强大还远不止这些，再次陷入迷茫，大家都说中国做不出优秀的软件，那是因为许多项目，是在代码的相互copy之间做成的。现在请前辈们指点，接下来的学习之路，我该怎样走下去，苦我不怕，但是，我却没有了方向，这是最可怕的。。", "Tag": "程序设计"}
{"Answer": "你的pdata没有指向你定义的结构体变量，而是指向一个无用的地址，肯定用不了", "Knowledge_Point": "程序设计", "Question": "关于结构体的箭头操作符我的代码是下面这样，但是总会在编译时提醒我：\n使用了未初始化的局部变量”pdata“\n查了下一，这样好像也没有什么错误啊，为什么老是这样提示我的？\n我的编译器是win8.1的VS2013，不知道有影响没？\n如果可以，请顺便给我一个对于结构体的点操作符和箭头操作符解释比较清楚详细的文章的链接。谢谢！\n\nstruct DATA         // 定义一个结构体类型：DATA\n{\n    char key[10];       // 结构体成员：key\n    char name[20];      // 结构体成员：name\n    int age;            // 结构体成员：age\n};\n\nint main()\n{\n    struct DATA data;              // 声明一个结构体变量\n    struct DATA *pdata;            // 声明一个指向结构体的指针  \n\n// 访问数据操作如下：  \ndata.age = 24;          // 结构体变量通过点运算符( . )访问  \npdata->age = 24;        // 指向结构体的指针通过箭头运算符( -> )访问  \nsystem(\"pause\");\nreturn 0;\n\n\n}", "Tag": "程序设计"}
{"Answer": "```\r\nstruct  B **b[4] 表示数组元素是二级指针的指针数组，即b[0]存放的是二级指针变量，那么b[0]的数据类型是struct B **，这点理解很关键！\r\nb[0] 是个二级指针，指向一个一级指针的内存单元，即指向(struct B*)指针类型，而*b[0]是这个一级指针所指向的内存单元的首地址，而这个内存单元是(struct B)结构体类型。不管是一级指针变量还是二级指针变量，指针变量本身也是需要占用存储空间的，只不过它存放的是地址值而已，这点理解也很关键！\r\n```\r\n使用memset初始化的方法如下：\r\n```\r\nstruct Big big;\r\nfor(i=0; i<4; i++){\r\n\t\tbig.b[i] = (struct B**)malloc(sizeof(struct B *)); //动态分配一个一级指针变量内存单元，二级指针指向这个一级指针的内存单元\r\n\t\t*big.b[i] = (struct B *)malloc(sizeof(struct B));\r\n\t\tmemset(*big.b[i], 0, sizeof(struct B));\r\n}\r\n\t\r\n```\r\n要复制数据到单个struct B结构体，使用同样的方法：\r\n\r\n```\r\nstruct B *data = malloc(sizeof(struct B));\r\nfor(i=0; i<4; i++)\r\n\tmemcpy(*big.b[i], data, sizeof(struct B));\r\n```\r\n\r\n我写了一个示例程序如下：\r\n\r\n```\r\n#include \r\n#include \r\n#include \r\n\r\nstruct B{\r\n\tint b;\r\n};\r\n\r\nstruct Big{\r\n\tint other;\r\n\tstruct B **b[4];\r\n};\r\n\r\nint main()\r\n{\r\n\tint i=0;\r\n\tstruct Big big;\r\n\tfor(i=0; i<4; i++){\r\n\t\tbig.b[i] = (struct B**)malloc(sizeof(struct B *)); //动态分配一个一级指针变量内存单元，二级指针指向这个一级指针的内存单元\r\n\t\t*big.b[i] = (struct B *)malloc(sizeof(struct B));\r\n\t\tmemset(*big.b[i], 0, sizeof(struct B));\r\n\t}\r\n\tstruct B *data = malloc(sizeof(struct B));\r\n\tdata->b = 999;\r\n\tfor(i=0; i<4; i++){\r\n\t\tprintf(\"*big.b[%d]=%p, **big.b[%d]=%d\\n\", i, *big.b[i], i, **big.b[i]);\r\n\t\tmemcpy(*big.b[i], data, sizeof(struct B));\r\n\t\tprintf(\"*big.b[%d]=%p, **big.b[%d]=%d\\n\\n\", i, *big.b[i], i, **big.b[i]);\r\n\t}\r\n\t\r\n\tfor(i=0;i<4;i++)\r\n\t{\r\n\t\tfree(*big.b[i]);\r\n\t\tfree(big.b[i]);\r\n\t}\r\n\tfree(data);\r\n\treturn 0;\r\n}\r\n```\r\n运行结果如下：\r\nF:\\c_work>gcc demo.c -std=c99\r\n\r\nF:\\c_work>a.exe\r\n*big.b[0]=0000000000B313F0, **big.b[0]=0\r\n*big.b[0]=0000000000B313F0, **big.b[0]=999\r\n\r\n*big.b[1]=0000000000B31430, **big.b[1]=0\r\n*big.b[1]=0000000000B31430, **big.b[1]=999\r\n\r\n*big.b[2]=0000000000B31470, **big.b[2]=0\r\n*big.b[2]=0000000000B31470, **big.b[2]=999\r\n\r\n*big.b[3]=0000000000B314B0, **big.b[3]=0\r\n*big.b[3]=0000000000B314B0, **big.b[3]=999\r\n从运行结果来看，赋值是正确的呀", "Knowledge_Point": "程序设计", "Question": "结构体的数据拷贝和清空如图：\n有一个大的结构体指针：struct Big *big;\n里面有四个缓存，每一个缓存都是数组，每一个数组里面都是B的结构体指针。\n我有两个需要；\n1:memset 每个缓存\n2:向每个缓存memcpy单个struct B 的指针数据\n\n不知道有没有可行的方法。\n\n", "Tag": "程序设计"}
{"Answer": "一般长度必须作为形参,传递过程中,数组传递过去退化成了指针,用sizeof求出来的长度是错误的", "Knowledge_Point": "程序设计", "Question": "关于C++冒泡排序的问题，求解决问题遇到的现象和发生背景\n把数组len在函数体内定义，数组不进行冒泡排序把len定义为参数，正常运行\n问题相关代码\n#include<iostream>\nusing namespace std;\nvoid BubbleSort(double* a) {\n\n    int len = sizeof(a) / sizeof(double); //为什么把len放在函数体内冒泡排序就不管用\n\n    for (int i = 0; i < len; i++)\n    {\n        for (int j = 0; j < len - i - 1; j++)\n        {\n            if (a[j] > a[j + 1]) {\n                double t = a[j];\n                a[j] = a[j + 1];\n                a[j + 1] = t;\n            }\n\n        }\n    }\n}\n\nint main(){\n    double a[]{ 10.5,5.5,6.6,0.7,6.3 };\n\n    BubbleSort(a);\n\n\n    for (size_t i = 0; i < sizeof(a) / sizeof(double); i++)\n    {\n        cout << a[i] << endl;\n    }\n    return 0;\n\n}\n\n\n运行结果及报错内容\n\n我的解答思路和尝试过的方法\n#include<iostream>\nusing namespace std;\nvoid BubbleSort(double* a,int len) {\n\n\n\n    for (int i = 0; i < len; i++)\n    {\n        for (int j = 0; j < len - i - 1; j++)\n        {\n            if (a[j] > a[j + 1]) {\n                double t = a[j];\n                a[j] = a[j + 1];\n                a[j + 1] = t;\n            }\n\n        }\n    }\n}\n\nint main(){\n    double a[]{ 10.5,5.5,6.6,0.7,6.3 };\n    int len = sizeof(a) / sizeof(double); //为什么把len放在函数体内冒泡排序就不管用\n\n    BubbleSort(a,len);\n\n\n    for (size_t i = 0; i < sizeof(a) / sizeof(double); i++)\n    {\n        cout << a[i] << endl;\n    }\n    return 0;\n\n}\n\n\n我想要达到的结果", "Tag": "程序设计"}
{"Answer": "a的值是第二次申请的内存地址，第一次的内存并没有被销毁在temp->next中保存", "Knowledge_Point": "程序设计", "Question": "C++的局部变量和空间申请Link* a=(Link*)malloc(sizeof(Link));Link* a=(Link*)malloc(sizeof(Link));这样的话前面的a会不会被后面的a所替代？\nfor(i=2;i<n;i++) //从第二个节点开始创建｛     Link* a=(Link*)malloc(sizeof(Link));     cout<<\"请输入第\"<<i<<\"个节点的数据域的值\";     cin>>a->elem;     a->next=NULL;     temp->next=a;     temp=temp->next;}", "Tag": "程序设计"}
{"Answer": "n = int(input(\">>>\"))\nfor i in range(1, n + 1):\n    print(f\"{str(i)*i:>{n}}\")\n\n", "Knowledge_Point": "程序设计", "Question": "关于#python#的问题：输入一个正整数n，打印出相对应的数字图形输入格式第一次编程\n输入一个正整数n，打印出相对应的数字图形输入格式：正整数n输出样例：        1      22    333  444455555", "Tag": "程序设计"}
{"Answer": "\n# coding:utf-8\n\nx1 = input(\"请输入起始数：\")\nx2 = input(\"请输入结束数：\")\na = int(x1)\nb = int(x2)\n\n# 若a,b均为偶数时均算在内\nsum1 = 0\nfor i in range(a, b+1):\n    if i % 2 == 0:\n        sum1 += i\n        i += 2\n    else:\n        i += 1\n\n# 若a,b均为偶数时，不算a和b\nsum2 = 0\nfor i in range(a+1, b):\n    if i % 2 == 0:\n        sum2 += i\n        i += 2\n    else:\n        i += 1\n\nprint(str(a)+\"到\"+str(b)+\"之间的偶数和(边界是偶数时算着两个边界)是：\"+str(sum1))\nprint(str(a)+\"到\"+str(b)+\"之间的偶数和(边界是偶数时不算两个边界)是：\"+str(sum2))\n ", "Knowledge_Point": "程序设计", "Question": "用Python输入起始和结束的正整数，求其两个正整数之间的偶数和。用Python输入起始和结束的正整数，求其两个正整数之间的偶数和。", "Tag": "程序设计"}
{"Answer": "\ndef prime(m,n):\n    ps = [1,2]\n    for i in range(3,m):\n        for k in range(2,i//2+1):\n            if i%k == 0:\n                break\n        else:\n            ps.append(i)\n    if n > len(ps):\n        raise IndexError(\"超出范围\")\n    else:\n        print(ps,ps[-n])\n\n\n\nprime(100,10)\n", "Knowledge_Point": "程序设计", "Question": "求比一个正整数的第n个素数如何运行得到多个素数中的倒数第n个素数，也就输入一个正整数和一个n，求比该正整数的第n个素数，总体来说，就是如何求所得的素数中的倒数第n个素数", "Tag": "程序设计"}
{"Answer": "#include <stdio.h>main(){    int  i = 0, n, sum = 0;    printf(\"Input a number:\");    scanf(\"%d\", &n);    while (n != 0)    {        if (n > 0)        {            sum = sum + n;            i++;        }        printf(\"Input a number:\");        scanf(\"%d\", &n);    }    printf(\"sum = %d, count = %d\\n\", sum, i);}                      ", "Knowledge_Point": "程序设计", "Question": "输入一些整数，编程计算并输出其中所有正数的和，输入负数时不累加，继续输入下一个数。输入零时表示输输入一些整数，编程计算并输出其中所有正数的和，输入负数时不累加，继续输入下一个数。输入零时表示输入数据结束。", "Tag": "程序设计"}
{"Answer": "#include <stdio.h>\n\nint main(void) { \n    char s[100];\n    int res=0;\n    scanf(\"%s\",s);\n    for(int i=0;s[i]!='\\0';i++){\n        res=res*10+(s[i]-'0');\n    }\n    printf(\"%d\",res);\n    return 0;\n}\n\n", "Knowledge_Point": "程序设计", "Question": "数字字符串转化为整型数输出输入一数字组成的字符串转化为整型数输出。求大佬大佬大佬大佬大佬大佬", "Tag": "程序设计"}
{"Answer": "多组输入可以用数组\r\nint f[MAX]; //max是允许的最大值\r\n...\r\nfor (int i = 0; i < n; i++)\r\n{\r\n你原来代码的f换成 f[i]\r\n}\r\n...\r\nfor (int i = 0; i < n; i++)\r\nprintf(\"%d\",f[i]); //最后输出", "Knowledge_Point": "程序设计", "Question": "请问这道题错在哪里呀= =#include\nint main()\n{ int a,b,n,f,e;\n scanf(\"%d\\n\",&n);\n  for (e=0;e\n  {scanf(\"%d %d\",&a,&b);\n   f=a>b?b:a;\n  for (f;a%f!=0||b%f!=0;f)\n  { f=f-1;\n  };\n  printf(\"%d\",f);\n\n};\n  return 0;\n } \n\n题目是求最大公约数，多组输入。只不过这个是输入一组出来一组，但是OJ里不给过，想问下变量范围如何限定，之前试过几个但是都是failure to execute,还有如何多组输入同时多组输出", "Tag": "程序设计"}
{"Answer": "int a = 123; 等号右侧的123是整形常量，而a是变量另外，scanf(“%d”,&a)的读取过程是，先逐个字符读取，如果是数字字符，就继续读取，直到遇到空格或者回车结束，然后将读取的数字字符转换为整形。读取到其他字符时，返回读取错误。所以，从键盘连续读入的123实际上是3个数字字符。给a赋值时，从缓存中读取这3个数字字符串并转换为整形。", "Knowledge_Point": "程序设计", "Question": "关于scanf输入整形的问题问题遇到的现象和发生背景\n实在是想不懂这道期中考试错题，考试的时候就没想明白下方题目中两个123是啥东西，都有啥区别。\n遇到的现象和发生背景，请写出第一个错误信息\n题目如下：“对于语句int a, scanf(\"%d\", &a); 请问从键盘连续读入的123与语句执行后放置于变量a中的123有区别么？请从数据类型和存储结构角度加以说明。”\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n运行结果及详细报错内容\n只拿了不到一半的分数（可能是友情分）\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n我的答案：1）对于数据类型，连续读入一个int整形，而直接将123放置则为一个int整形，数据类型没有区别；2）对于存储结构，分开输入的三个整数可能地址中，而直接赋值给a则能将123放到同一个存储地址中，因此存储结构不同，有区别\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”\n希望能解释一下到底有没有区别，有啥区别，就从类型和存储两方面回答", "Tag": "程序设计"}
{"Answer": "#include <stdio.h>\nint fun(int *a,int n,int *sum)\n{\n    int i,count = 0;\n    *sum = 0;\n    for(i=0;i<n;i++)\n    {\n        if(a[i]%2==1)\n        {\n            count++;\n            *sum += a[i];\n        }\n    }\n    return count;\n}\nint main()\n{\n    int a[10],i,count,sum=0;\n    for(i=0;i<10;i++)\n        scanf(\"%d\",&a[i]);\n    count = fun(a,10,&sum);\n    printf(\"奇数个数:%d，总和:%d\",count,sum);\n    return 0;\n}\n", "Knowledge_Point": "程序设计", "Question": "C语言问题，编写一函数，实现统计任意指定长度的整形数组中奇数的个数及奇数的和。主程序读入 10 个正整数，使用数组名为参数调用上述函数，并输出统计结果编写一函数，实现统计任意指定长度的整形数组中奇数的个数及奇数的和。主程序读入 10 个正整数，使用数组名为参数调用上述函数，并输出统计结果", "Tag": "程序设计"}
{"Answer": "代码如下有帮助望采纳~\na=input()\nwhile a:\n    print(a[0])\n    a=a[1:]\n    if len(a)>1:\n        a=a[1:]+a[0]\n\n", "Knowledge_Point": "程序设计", "Question": "按序输出被删除的字符题目描述\nEnder得到了一个字符串，但是他非常讨厌字符串，因此他准备把字符串中的字符按以下顺序逐个删除。请按序输出被删除的字符。 对于字符串a1a2…an ，依次执行以下操作： (1) 删除当前字符串的第一个字符。 (2) 执行(1)后，将当前字符串的第一个字符移动到最后。 例如字符串“abcd”进行一次操作后将变成“cdb”。 重复以上操作直到字符串为空，按序输出被删除的字符。\n输入\n一行，一个字符串。\n输出\nN行（N为输入字符串的长度），按序输出被删除的字符。\n输入样例1\nabcd输出样例1\nacbd样例解释\nabcd -> (删除a移动b到字符串最后) cdb -> (删除c移动d到字符串最后) bd -> (删除b) -> d -> (删除d)", "Tag": "程序设计"}
{"Answer": "VS支持一种所谓 C++/CLI 类型的程序，这种程序需要 .NET Framework\r\n\r\n比如，这就是一个C++CLI的程序\r\n```\r\nusing namespace System;\r\nvoid _tmain()\r\n{\r\n　Console::WriteLine(\"Hello World\");\r\n} \r\n```", "Knowledge_Point": "程序设计", "Question": "Visual Studio Code 调试C++要安装.NET框架？下了VSC，调试了C++程序，报错要下载.NET Framework，什么意思？还限制版本version？！", "Tag": "程序设计"}
{"Answer": "第17行第3个%d后面的空格去掉，scanf()函数格式输入中最后一个不要是空格，读不到。要在两个数据中间才能读取到空格", "Knowledge_Point": "程序设计", "Question": "PAT乙级1015，调试的时候发现在输入后，会在scanf（）处卡住，求大神指点\n#include<stdio.h>\n#include<stdlib.h>\nint Comp(const void *p1, const void *p2);\n\ntypedef struct{\n    int id;//准考证号 \n    int de,cai,total;//德分，才分，总分\n    int rank;//考生类别\n}Student;//试一下这个地方能否直接用数组\n\nint main(){\n    Student stu[100000];//最多可能接收100000个考生信息\n    int num, low, high;//分别是考生数目，国家线和院线\n    int num_pass=0;//过国家线人数\n    scanf(\"%d%d%d\", &num, &low, &high);\n    for(int i=0; i<num; ){\n        scanf(\"%d %d %d \", &stu[i].id, &stu[i].de, &stu[i].cai);\n        stu[i].total=stu[i].de+stu[i].cai;//接收考生信息，计算总分\n        //考生分类\n        if(stu[i].de>=high&&stu[i].cai>=high)//德分、才分皆过院线\n            stu[i].rank=1;\n        else if(stu[i].de>=high&&stu[i].cai>=low&&stu[i].cai<high)//德分过院线，但才分没过院线\n            stu[i].rank=2;\n        else if(stu[i].de>=low&&stu[i].de<high&&stu[i].cai>=low&&stu[i].cai<high&&stu[i].de>=stu[i].cai)\n            stu[i].rank=3;//德分都没过院线，但德分大于等于才分\n        else if(stu[i].de>=low&&stu[i].cai>high)//德分没过院线，且才分大于德分 \n        \tstu[i].rank=4;\n        else if(stu[i].de>=low&&stu[i].de<high&&stu[i].cai>=low&&stu[i].cai<high)\n            stu[i].rank=5;//德才都没过院线，且德分小于才分\n        if(stu[i].de>=low&&stu[i].cai>=low)\n            num_pass++;\n        i++; \n    }\n    //对考生排序\n    qsort(stu, num, sizeof(int), Comp);\n    printf(\"%d\\n\", num_pass);\n    for(int i=0; i<num_pass; i++){\n        printf(\"%d %d %d\\n\", stu[i].id, stu[i].de, stu[i].cai);\n    }\n    return 0;\n}\n\nint Comp(const void *p1, const void *p2){\n    Student *a=(Student*)p1;\n\tStudent *b=(Student*)p2;\n    if(a->rank!=b->rank)\n        return a->rank - b->rank;//如果a的rank小于b，则应该a排在前面\n    else if(a->total!=b->total)\n        return b->total - a->total;//如果a的总分小于b，则a应该排在后面\n    else if(a->de!=b->de)\n        return b->de - a->de;//如果a的德分小于b，则a应该排在后面\n    else if(a->id!=b->id)\n        return a->id - b->id;//如果a的准考证号小于b，应该a排在前面\n}\n\n编译通过\n\n调试的时候，会在最后一个测试数据输入完后卡住，可以再输入数据，但程序随后会在scanf（）处卡住\n\n\n\n 此时调试的时候再点下一步就动不了\n\n\n\n\n\n另外pat那边oj的结果\n\n输入样例：\n\n\n14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n\n自己的输出结果： \n\n\n\n\n\n ", "Tag": "程序设计"}
{"Answer": "在main函数里使用try-catch语句，把调用的方法放入try代码块中，catch中处理异常，在最后finally语句块中输出x就好了", "Knowledge_Point": "程序设计", "Question": "Java的抛出异常方法的申明及调用以除法为例，封装一个方法并且将异常抛出，在main方法里调用该方法并对该方法进行异常捕获处理，无论是否发生异常，main方法都将输出“x”的语句。", "Tag": "程序设计"}
{"Answer": "n=50太大了，你这个都是阶乘啊，50的阶乘超出了int型的取值范围，连long long都不够，全部改为double类型吧。", "Knowledge_Point": "程序设计", "Question": "integer division by zero错误，但是我并未找到此错误问题遇到的现象和发生背景\n期间输入过n=5，r=3；n=10，r=20都能运行，但是在输入n=50，r=3时提示出现了此错误\n问题相关代码，请勿粘贴截图\n\n\n\n运行结果及报错内容\ninteger division by zero\n我的解答思路和尝试过的方法\n找可能出现分母是0的情况，但并未找到\n我想要达到的结果\n能够在所有输入的情况下正常运行", "Tag": "程序设计"}
{"Answer": "要让应用程序开机自启动，您需要使用Android的“BroadcastReceiver”和“Service”来实现。Preference则是用于用户可以手动启用或禁用自启动功能的设置选项。下面是一个示例，演示如何使用Preference实现开机自启动的功能：\n1、在您的应用程序的“res/xml”文件夹下创建一个新的preference文件，例如“preferences.xml”。添加一个SwitchPreference：\n<SwitchPreference\n    android:key=\"auto_start\"\n    android:title=\"开机自启动\"\n    android:defaultValue=\"false\"/>\n\n2、在您的应用程序中的“AndroidManifest.xml”文件中添加以下权限；\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n\n3、创建一个名为“BootReceiver”的BroadcastReceiver类，并在其onReceive方法中启动您的Service类。如果用户已经启用了自启动，则自启动服务将在启动后启动。否则，服务将在用户启用自启动后启动。确保在BroadcastReceiver中添加以下代码：\npublic class BootReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) {\n            SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);\n            boolean autoStart = sharedPreferences.getBoolean(\"auto_start\", false);\n            if (autoStart) {\n                Intent serviceIntent = new Intent(context, YourServiceClass.class);\n                context.startService(serviceIntent);\n            }\n        }\n    }\n}\n\n4、在您的应用程序中创建一个名为“YourServiceClass”的服务类，实现应用程序的功能。\n\npublic class YourServiceClass extends Service {\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @Override\n    public void onCreate() {\n        // 初始化您的服务\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // 执行您的服务操作\n        return START_STICKY;\n    }\n\n    @Override\n    public void onDestroy() {\n        // 清理资源\n    }\n}\n\n5、注册BroadcastReceiver和Service类。在您的应用程序中的“AndroidManifest.xml”文件中添加以下代码：\n<application\n    android:icon=\"@drawable/ic_launcher\"\n    android:label=\"@string/app_name\">\n    <activity\n        android:name=\".MainActivity\"\n        android:label=\"@string/app_name\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\"/>\n            <category android:name=\"android.intent.category.LAUNCHER\"/>\n        </intent-filter>\n    </activity>\n    <service android:name=\".YourServiceClass\"/>\n    <receiver android:name=\".BootReceiver\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n        </intent-filter>\n    </receiver>\n</application>\n\n现在，当用户启用了“开机自启动”选项时，您的应用程序将在设备启动后自动启动您的服务。有用的话，给个关注，手抽筋了................................", "Knowledge_Point": "程序设计", "Question": "Android怎么用preference写一个switch开关，让软件开机自启Android怎么用preference写一个switch开关，让软件开机自启", "Tag": "程序设计"}
{"Answer": "#include <stdio.h>\n\ndouble calculate(double a, char op, double b)\n{\n    switch (op)\n    {\n    case '+':\n        return a + b;\n    case '-':\n        return a - b;\n    case '*':\n        return a * b;\n    case '/':\n        return a / b;\n    }\n    return 0;\n}\n\nint main()\n{\n    double a, b, c, r;\n    char op1, op2;\n    scanf(\"%lf%c%lf%c%lf\", &a, &op1, &b, &op2, &c);\n    switch (op1)\n    {\n    case '+':\n    case '-':\n        switch (op2)\n        {\n        case '+':\n        case '-':\n            r = calculate(a, op1, b);\n            r = calculate(r, op2, c);\n            break;\n        case '*':\n        case '/':\n            r = calculate(b, op2, c);\n            r = calculate(a, op1, r);\n            break;\n        }\n        break;\n    case '*':\n    case '/':\n        r = calculate(a, op1, b);\n        r = calculate(r, op2, c);\n        break;\n    }\n    printf(\"%lg%c%lg%c%lg=%lg\", a, op1, b, op2, c, r);\n    return 0;\n}\n", "Knowledge_Point": "程序设计", "Question": "c语言swtich制作计算器，急键盘输入三个整数和两个算术运算组成的表达式，计算结果。 运算符包括：加+,减-乘*,除/\n输入格式:三个整数，两个运算符，组成算数表达式，输入的字符之间没有空格\n输出格式:在表达式的后边输出=计算结果\n输入样例:6+311结尾无空行输出样例:6+311=39结尾无空行", "Tag": "程序设计"}
{"Answer": "\nThe problem is that the doc.New functionality is only parsing for documentation strings, and the comment inside the function is not part of the \"documentation\".\nYou'll want to directly iterate the ast of the files in the package.\npackage main\n\nimport (\n        \"fmt\"\n        \"go/parser\"\n        \"go/token\"\n)\n\n// GetFoo comments I can find easely\nfunc GetFoo() {\n        // Comment I would like to access\n        test := 1\n        fmt.Println(test)\n}\n\nfunc main() {\n        fset := token.NewFileSet() // positions are relative to fset\n        d, err := parser.ParseDir(fset, \"./\", nil, parser.ParseComments)\n        if err != nil {\n                fmt.Println(err)\n                return\n        }\n        for k, f := range d {\n                fmt.Println(\"package\", k)\n                for n, f := range f.Files {\n                        fmt.Printf(\"File name: %q\n\", n)\n                        for i, c := range f.Comments {\n                                fmt.Printf(\"Comment Group %d\n\", i)\n                                for i2, c1 := range c.List {\n                                        fmt.Printf(\"Comment %d: Position: %d, Text: %q\n\", i2, c1.Slash, c1.Text)\n                                }\n                        }\n                }\n\n        }\n}\n\n", "Knowledge_Point": "程序设计", "Question": "在Go中的函数中访问注释\n\nI'm currently working on documentation generator that will parse Go code to produce a custom documentation. I need to access to the comments written inside a function. But I can't retrieve these comments in the AST, neither with the go/doc. Here is an example :\n\npackage main\n\nimport (\n    \"fmt\"\n    \"go/doc\"\n    \"go/parser\"\n    \"go/token\"\n)\n\n// GetFoo comments I can find easely\nfunc GetFoo() {\n    // Comment I would like to access\n    test := 1\n    fmt.Println(test)\n}\n\nfunc main() {\n    fset := token.NewFileSet() // positions are relative to fset\n    d, err := parser.ParseDir(fset, \"./\", nil, parser.ParseComments)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    for k, f := range d {\n        fmt.Println(\"package\", k)\n        p := doc.New(f, \"./\", 2)\n\n        for _, t := range p.Types {\n            fmt.Println(\"type\", t.Name)\n            fmt.Println(\"docs:\", t.Doc)\n        }\n\n        for _, v := range p.Vars {\n            fmt.Println(\"type\", v.Names)\n            fmt.Println(\"docs:\", v.Doc)\n        }\n\n        for _, f := range p.Funcs {\n            fmt.Println(\"type\", f.Name)\n            fmt.Println(\"docs:\", f.Doc)\n        }\n\n        for _, n := range p.Notes {\n            fmt.Println(\"body\", n[0].Body)\n        }\n    }\n}\n\n\nIt's easy to find GetFoo comments I can find easely but not Comment I would like to access\nI have seen this post quite similar question Go parser not detecting Doc comments on struct type but for exported types\n\nIs there any way to do that ? Thank you !\n    ", "Tag": "程序设计"}
{"Answer": "\nAnnotations must be added to docblocks, not just simple comments. \nYou need to start your comment with /** instead of /* (notice double *):\n/**\n * @Route(\"/admin\")\n */\nclass AdminController extends Controller\n{\n    // ...\n}\n\nThis is going to prefix all your AdminController's routes with /admin.\n", "Knowledge_Point": "程序设计", "Question": "Symfony2路由注释在类不工作\n\nSo basically I have a controller of a bundle in which i want to and a route prefix so i use the @Route annotation on the class, i've done this all of the other controllers of my Symfony2 app. However this one does not take the prefix into account so instead of being able to access the page on /admin/users/list i only access it on /list.\n\nHere is the controller :\n\n<?php\n\nnamespace LanPartyOrg\\UserBundle\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Template;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Method;\nuse JMS\\SecurityExtraBundle\\Annotation\\PreAuthorize;\n\n/*\n* @Route(\"/admin\")\n* \n*/\nclass AdminController extends Controller\n {\n    /**\n    * @Route(\"/list\", name=\"users_list\")\n    * @Template(\"LanPartyOrgUserBundle:Admin:List.html.twig\")\n    */\n    public function listAction(){\n        $em = $this->getDoctrine()->getManager();\n        $users = $em->getRepository('LanPartyOrgUserBundle:User')->findAll();\n\n        return array('users'=>$users);\n    }\n}\n\n\nAnd here is my routing.yml :\n\nlan_party_org_user:\n    resource: \"@LanPartyOrgUserBundle/Controller/\"\n    type:     annotation\n    prefix:   /\n\nfos_user_security:\n    resource: \"@FOSUserBundle/Resources/config/routing/security.xml\"\n\nfos_user_profile:\n    resource: \"@FOSUserBundle/Resources/config/routing/profile.xml\"\n    prefix: /profile\n\nfos_user_register:\n    resource: \"@FOSUserBundle/Resources/config/routing/registration.xml\"\n    prefix: /register\n\nfos_user_resetting:\n    resource: \"@FOSUserBundle/Resources/config/routing/resetting.xml\"\n    prefix: /resetting\n\nfos_user_change_password:\n    resource: \"@FOSUserBundle/Resources/config/routing/change_password.xml\"\n    prefix: /profile\n\n\nThanks for any help\n    ", "Tag": "程序设计"}
{"Answer": "\nlen(line) > 0 will be true for the \"# Hello\" line, so it will get added to output.\nCurrently, you are adding lines that either don't start with a # or are not empty. You need to only add lines that satisfy both conditions:\nif !strings.HasPrefix(line, \"#\") && len(line) > 0 {\n    output[line] = true\n}\n\n", "Knowledge_Point": "程序设计", "Question": "解析文件，忽略注释和空白行\n\nAs the title says, I am trying to parse a file but ignore comments (started with #) or blank lines. I have tried to make a system for this, yet it always seems to ignore that it should be ignoring comments and/or blank lines.\n\nlines := strings.Split(d, \"\n\")\nvar output map[string]bool = make(map[string]bool)\n\nfor _, line := range lines {\n    if strings.HasPrefix(line, \"#\") != true {\n        output[line] = true\n    } else if len(line) > 0 {\n        output[line] = true\n    }\n}\n\n\nWhen run (this is part of a function), it outputs the following\n\nThis is the input ('d' variable):\nMinecraft\nZerg Rush\nPokemon\n\n# Hello\n\nThis is the output when printed ('output' variable):\n\nmap[Minecraft:true Zerg Rush:true Pokemon:true :true # Hello:true]\n\n\nMy issue here is that it still keeps the \"\" and \"# Hello\" values, meaning that something failed, something I haven't been able to figure out.\n\nSo, what am I doing wrong that this keeps the improper values?\n    ", "Tag": "程序设计"}
{"Answer": "①处：定义一个有6个元素的单精度浮点数数组（sq应该是sequence的缩写），下标从0开始。这个vb6（含vbs）和其他语言有点区别，vb6中数组项是定义的数字+1个项，下标0 ~ 5，其他语言是定义5个项的数组，下标0 ~ 4.。\n②处：1 to 4（循环四次），可以想象为一个框中有5个数，一次找出一个最小的，是不是找4次就能找完了，还剩一个最大的在框内。所以只需要找4次。③处：j = i + 1 To 5，这个不难理解了吧，最小的已经拍前面，j再从1开始比较没意义了，i所在位置的前面的数肯定是小于i当前位置的数，所以找比i位置还小的数，应该从下一项开始找（j=i+1）\n有帮助或启发麻烦点个采纳【本回答右上角】，谢谢~~", "Knowledge_Point": "程序设计", "Question": "排序算法为什么理解不了?  [例 3-8]数组的排序.  数据排序的算法问题在任何程序设计语言中都作为一种典型的算法来介绍,因此本书不再赘述.程序代码如下:Dim i, j, intMin As IntegerDim strMsg As StringDim sngSq(5), sngT As Single '①'输入原始数据For i = 1 To 5    strMsg = \"请输入第\" & Str(i) & \"个数:\"    sngSq(i) = Val(InputBox(j, \"数据\")) '将输入的数据转换为数值型Next'排序For i = 1 To 4 '②    intMin = i '对第i遍排序,初始假定第i个元素最小    For j = i + 1 To 5 '找出最小的元素序号  '③        If sngSq(j) < sngSq(intMin) Then intMin = j    Next j    '将找出的最小元素与第i个元素交换    sngT = sngSq(i)    sngSq(i) = sngSq(intMin)    sngSq(intMin) = sngTNext i'打印输出For i = 1 To 5    Print sngSq(i) '不换行输出Next i  在Vbxx工程中新建一个名为frmExam_3_8窗体,在窗体的Click事件中输入上述代码.\n①处的英文缩写sngSq换成中文是什么意思,创建的sngSq(5)数组是从索引0开始的还是从索引1开始的?②处的为什么不是For i = 1 To 5而是For i = 1 To 4?③处的j = i + 1又是什么意思,因为i是从1到4?", "Tag": "程序设计"}
{"Answer": "```\r\n char path[1000];\r\nsprintf(path, \"h;|\\visual ... \\\\data\\\\%d\\\\p.txt\", j);\r\nifstream fin(path);\r\n```", "Knowledge_Point": "程序设计", "Question": "c++如何批量读取多个文件夹下的文件并且把它赋值到数组中去？假如我有一列文件夹\n每个文件夹下面有一个txt文本\n现在我想把每个文件夹里面的txt文本内容都放到数组中一一对应相加。\n我的办法是这样的：由于文件夹名字是1 2 3 4 5\n我就用一个循环\n发现这个j并不能代表整数\n有什么其他办法吗", "Tag": "程序设计"}
{"Answer": "入库：转成数组格式后用foreach函数遍历数组\r\nforeach ($arr as $key => $value) {\r\n\t$sql = \"insert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('{$value['ClassName']}','{$value['StuNum']}','{$value['StuName']}','{$value['ClassID']}')\"\r\n}\r\n显示数据\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1501','20152154','学生姓名1','1')\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1501','20152230','学生姓名2','1')\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1501','20152420','学生姓名3','1')\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1501','20152426','学生姓名4','1')\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1502','20152093','学生姓名5','1')\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1502','20152133','学生姓名6','1')\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1502','20152282','学生姓名7','1')\r\ninsert into table(`ClassName`,`StuNum`,`StuName`,`ClassID`)values('Class1502','20152451','学生姓名8','1')\r\n\r\n最后：你的json数据去掉最后的‘，’，才能转化成数组\r\njson数据：\r\n$str = '[{\"ClassName\":\"Class1501\",\"StuNum\":\"20152154\",\"StuName\":\"学生姓名1\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1501\",\"StuNum\":\"20152230\",\"StuName\":\"学生姓名2\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1501\",\"StuNum\":\"20152420\",\"StuName\":\"学生姓名3\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1501\",\"StuNum\":\"20152426\",\"StuName\":\"学生姓名4\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152093\",\"StuName\":\"学生姓名5\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152133\",\"StuName\":\"学生姓名6\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152282\",\"StuName\":\"学生姓名7\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152451\",\"StuName\":\"学生姓名8\",\"ClassID\":\"1\"}]';\r\n$arr = json_decode($str,true);", "Knowledge_Point": "程序设计", "Question": "PHP解析Json时，如何解析保存了对象的数组，我有如下Json字符串\n            $Json=[{\"ClassName\":\"Class1501\",\"StuNum\":\"20152154\",\"StuName\":\"学生姓名1\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1501\",\"StuNum\":\"20152230\",\"StuName\":\"学生姓名2\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1501\",\"StuNum\":\"20152420\",\"StuName\":\"学生姓名3\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1501\",\"StuNum\":\"20152426\",\"StuName\":\"学生姓名4\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152093\",\"StuName\":\"学生姓名5\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152133\",\"StuName\":\"学生姓名6\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152282\",\"StuName\":\"学生姓名7\",\"ClassID\":\"1\"},{\"ClassName\":\"Class1502\",\"StuNum\":\"20152451\",\"StuName\":\"学生姓名8\",\"ClassID\":\"1\"},]\n\n这个json我是在c#端用Litjson打包的，并传到php来处理\n\n在PHP中创建类：\n\nclass ImportStudentData{\n    public $StuNum;\n    public $StuName;\n    public $ClassName;\n    public $ClassID;\n}\n\n如果我这样写\n$Arr=array();\n$Arr=json_decode($json,true);\n\n解析出来的是一个数组，我能正确访问到数组的长度，但是不能访问数组里的元素（我希望这个数组的内容是ImportStudentData对象）\n\n我的目的：\n把这个Json字符串解析到PHP中，并且最后的结果是，把json中每个对象的内容保存到ImportStudentData对象中，并最后存到一个数组里。\n$Arr2={ImportStudentData1,ImportStudentData2, ....}\n\n最后，我可以通过\nImportStudentData1->StuNum\nImportStudentData1->StuName来得到Json中的内容\n\n最终目的：\n我是想把这些玩意，通过php存到数据库中", "Tag": "程序设计"}
{"Answer": "在开源软件领域中，常见的盈利模式一共有7种。下面让我们来逐一列举和分析。\r\n● 盈利模式之一：多种产品线 \r\n如 MySQL 产品就同时推出面向个人和企业的两种版本，即开源版本和专业版本，分别采用不同的授权方式。开源版本完全免费以便更好的推广，而从专业版的许可销售和支持服务获得收入。\r\n● 盈利模式之二：技术服务型 \r\nJBoss就是这种模式的典型代表。JBoss 应用服务器完全免费，而通过提供技术文档、培训、二次开发支持等技术服务而获得收入。\r\n● 盈利模式之三：应用服务托管（ASP）\r\n例如，PHP Live！ 就是一种构架于 PHP、MySQL 之上的开源软件，它可为企业用户提供实时交谈服务。目前已经有数十家公开提供 PHP Live！ 托管服务的应用服务提供商。\r\n● 盈利模式之四：软、硬件一体化 \r\n比如 IBM HP 等服务器供应商巨头，通过捆绑免费的 Linux 操作系统销售硬件服务器。SUN 公司近期将其 Solaris 操作系统开放源码，以确保服务器硬件的销售收入，也是这种模式的体现。\r\n● 盈利模式之五：附属品\r\nO'Reilly集团是销售开源软件附加产品公司的典型案例，他出版了很多优秀的开放源代码软件的参考资料。\r\n● 盈利模式之六：品牌战略、服务至上\r\n康比尔公司的 Compiere ERP & CRM 软件是这种模式的典型案例。\r\n● 盈利模式之七：市场策略", "Knowledge_Point": "程序设计", "Question": "开源软件是如何赚钱的不知道开源软件是如何盈利的，大家都说一下自己的看法。", "Tag": "程序设计"}
{"Answer": "因为当i=3,j=1时，n为10，打印一个换行，然后就break跳出了内层循环，n没有++，仍为10；然后当外层循环开始新一轮循环时，i=4,j=1，进入到内层循环，n=10，n%5还是等于0，加上前面n=10时打印的一个换行，和这次的又一个换行，所以就显示为第三行直接空行了。（可以在第一个if中加个打印语句，观察下i，j，n的值的变化）。如果要不显示第三行的空行，可以在判断打印换行的if加个条件：i!=3即可；如果第一行数字之前的空行也不要，可以再加个条件:n!=0.测试代码如下：\n#include <stdio.h>\n\nint main(void){\n    \n    int i,j,n=0;\n    \n    for(i=1;i<=4;i++){\n        \n        for(j=1;j<=5;j++,n++){\n            \n            if(n%5==0&&i!=3&&n!=0){  // 当i==3，j==1时，n=10,此时会打印一个换行，光标跳转到第三行（以显示第一次显示数字的那行为第一行） \n            //    printf(\"i=%d,j=%d,n=%d\",i,j,n);\n                printf(\"\\n\");\n            }\n            \n // 然后break退出了，n没有++，此时n仍等于10，\n //下次再进入内层循环，i=4,j=1时，前面的if还要打印一个换行 ,此时会光标会跳转到第四行(以显示第一次显示数字的那行为第一行） \n // 所以，因为这两个换行，而显示出第三行空行了\n // 如果要让第三行不空行，可以在上面的if加个条件i!=3 ,如果第一行数字之前的空行也不要，可以再加个条件n!=0    \n            if(i==3&&j==1){\n                break;\n            }\n            \n            printf(\"%d\\t\",i*j);\n        }\n    }\n    \n    return 0;\n} \n\n", "Knowledge_Point": "程序设计", "Question": "C语言中for循环嵌套，内循环遇到break语句结束本次内循环 ，输出会换行吗？C语言中for循环嵌套，内循环遇到break语句结束本次内循环 ，为什么第三行会直接换行呢？求解\n", "Tag": "程序设计"}
{"Answer": "第一个for是一个一个创建空列表的，当第一个for进入循环的时候创建了第一个空列表放入的arr里，arr就成了[[]]，然后进入第二个循环此时在第二个循环里i一直是0直到第二个循环结束，i就会变成i，那么arr[0]里就循环放入0,1,2,3,4,arr里也会多出一个空list，程序的结果应该是这样的[[]],[[0]],[[0,1]]...[[0,1,2,3,4]],[[0,1,2,3,4],[]],[[0,1,2,3,4],[0]],[[0,1,2,3,4],[0,1]]...[[0,1,2,3,4],[0,1,2,3,4]]...[[0,1,2,3,4],[0,1,2,3,4],[0,1,2,3,4],[0,1,2,3,4]]", "Knowledge_Point": "程序设计", "Question": "Python嵌套for循环和二维列表的理解如图\n这个程序怎么理解会好一点呀 感觉一知半解的 第一个range（4）循环i的 是创建了四个表嘛 然后后面j填充进0.1.2.3.4……", "Tag": "程序设计"}
{"Answer": "数组也可以实现链表的，算法题中使用单链表往往是通过数组实现，数组实现的单链表可以通过下标来索引节点，可以直接通过下标找到某个节点的值和下一个节点的，因此数组实现的单链表的最大优点就是快(插入和删除操作都是O(1)的时间复杂度)", "Knowledge_Point": "程序设计", "Question": "如果没有提供指针类型的语言,就无法构造链式结构这句话对吗？我百度都说是对的。我现在觉得不对，不是还有静态链表呢么，它不是用一个结构体数组实现的么。所以到底对不对，问问大佬们。", "Tag": "程序设计"}
{"Answer": "\nYou could make an array with your three variables and then validate them with a foreach loop. Even in the same foreach loop you could make the first validation you have:\nforeach(array($x, $y, $z) as $values) {//---> the $values variable represents each of your '$x, $y, $z' variables in the loop.\n    if (empty($values)) {\n        $_SESSION[\"ErrorMessage\"]=\"You have to fill all the blanks.\";\n        redirect_to(\"addxyz.php\");\n\n    } else if (strlen($values) > 99) {\n        $_SESSION[\"ErrorMessage\"]=\"Very Long  Name for $values\";//---> This will notify the first value that fails the validation.\n        redirect_to(\"addxyz.php\");\n    }\n}\n\nIf more than one value fails the validation (for example $x and $z) and you want to notify them all, you could save the $values value in an array and then show it. Something like this:\n$strlenErrors = array();\nforeach(array($x, $y, $z) as $values) {\n    if (strlen($values) > 99) {\n        $strlenErrors[] = $values;\n    }\n}\n\nif (!empty($strlenErrors)) {\n    $_SESSION[\"ErrorMessage\"]=\"Very Long  Name for: \".implode(\", \", $strlenErrors);//---> This will divide and print the '$strlenErrors' array by commas.\n    redirect_to(\"addxyz.php\");\n}\n\n", "Knowledge_Point": "程序设计", "Question": "如何在PHP中使用if语句中的变量\n\nI am trying to take a value inside of if/else statement and send an error message with \"that variable\" because I don't want any of my inputs to be more than 99 characters. \n\nThis is the code:\n\nif(empty($x) || empty($y) || empty($z)){\n\n$_SESSION[\"ErrorMessage\"]=\"You have to fill all the blanks.\";\nredirect_to(\"addxyz.php\");\n\n\n} elseif(strlen($x)>99 || strlen($y)>99 || strlen($z)>99){\n\n$_SESSION[\"ErrorMessage\"]=\"Very Long  Name for /*variable name will be here*/\";\nredirect_to(\"addxyz.php\");\n\n}  else {/*Rest of the code*/}\n\n\nIn the second part when I use strlen function with variables, I need to select one of it with an array or any other way but not using 3 different if/else statement. \n    What would be the best way ? \n\nThanks in advance.\n    ", "Tag": "程序设计"}
{"Answer": "\nfrom math import log\ndef func():\n    x,y=input().split()\n    try:\n        x,y=float(x),float(y)\n    except:\n        print(\"输入错误\")\n        return\n    # if 3*x-y+1<0:\n    #     print(\"值小于0\")\n    #     return \n    # elif 3*x-y+1==0:\n    #     return -float('inf')\n    # else:\n    #     return log(3*x-y+1)\n    assert 3*x-y+1>0,\"值不大于0\"\n    return log(3*x-y+1)\nprint(func())\n", "Knowledge_Point": "程序设计", "Question": "关于#python#的问题，请各位专家解答！请问打对号怎么写？怎么调用这个函数？什么是断言语句？请大lao指教一下", "Tag": "程序设计"}
{"Answer": "对于api来说，越深的代码越应该抛出异常，让上层调用方进行处理，如果全部在内部catch掉，查找错误是非常费劲的，对于上层而言，应该尽可能在一个地方统一捕获异常进行处理，spring的intercept或者java的代理机制都可以实现全局异常的拦截。", "Knowledge_Point": "程序设计", "Question": "关于代码编写中的异常处理有一个方法, 假设是\n\npublic void add(int a, int b){\n    try{\n        System.out.print(a + b);\n    }catch (Execption e){\n         // 此处做异常处理\n    }\n}\n\n\n然后另一处调用的地方这么写\n\n try{\n     add(1, 3);\n }catch(Execption e){\n     // 异常处理\n }\n\n\n阅读代码的时候看到类似这种代码,就有个疑问,那个add方法,既没有返回值,也没有异常抛出\n那么调用的时候try catch还有什么用呢?", "Tag": "程序设计"}
{"Answer": "你打印出来就知道了，因为sql里的字符串值是'1231'，所以拼接的字符串里''也要有", "Knowledge_Point": "程序设计", "Question": "关于 java jdbc   sql 语句问题如图  values 中的 最后2个字段中的 双引号和加号 有什么用？？为什么要加上。。", "Tag": "程序设计"}
{"Answer": "select 学生编号 from 学生表 a where (select count(*) from 学生选课表 bwhere a.学生编号=b.学生编号) < (select count(*) from 选课表) - 2", "Knowledge_Point": "程序设计", "Question": "小白请教一个sql查询语句有三张表，学生表，选修课表，学生-选修课表，想查询至少未选修A和B两门课程的学生编号，SQL怎么写，各位大大帮忙看看，谢谢。\n\n建表插数据的语句贴上。\n\ncreate table Student\n(\nsid number(8) primary key,\nsname varchar2(16),\nsex number(8),\nage number(8)\n);\n\ncreate table Course\n(\ncid number(8) primary key,\ncname varchar2(16)\n);\n\ncreate table Stu_Course\n(\nsid number(8),\ncid number(8),\nprimary key(sid,cid)\n);\n\ncreate sequence seq_stu\nminvalue 0\nstart with 0\nincrement by 1;\n\ncreate sequence seq_cou\nminvalue 0\nstart with 0\nincrement by 1;\n\ninsert into Student values(seq_stu.nextval,'张三丰',0,24);\ninsert into Student values(seq_stu.nextval,'梅超风',1,25);\ninsert into Student values(seq_stu.nextval,'张无忌',0,23);\ninsert into Student values(seq_stu.nextval,'周芷若',1,22);\ninsert into Student values(seq_stu.nextval,'柳乘风',0,27);\ninsert into Student values(seq_stu.nextval,'黄药师',0,18);\ninsert into Student values(seq_stu.nextval,'周伯通',0,19);\n\ninsert into Course values(seq_cou.nextval,'A');\ninsert into Course values(seq_cou.nextval,'B');\ninsert into Course values(seq_cou.nextval,'C');\ninsert into Course values(seq_cou.nextval,'E');\ninsert into Course values(seq_cou.nextval,'F');\ninsert into Course values(seq_cou.nextval,'G');\ninsert into Course values(seq_cou.nextval,'H');\n\ninsert into Stu_Course values(1,1);\ninsert into Stu_Course values(1,2);\ninsert into Stu_Course values(1,3);\ninsert into Stu_Course values(2,1);\ninsert into Stu_Course values(2,2);\ninsert into Stu_Course values(3,1);\ninsert into Stu_Course values(3,3);\ninsert into Stu_Course values(4,1);\ninsert into Stu_Course values(4,2);\ninsert into Stu_Course values(4,4);\ninsert into Stu_Course values(5,1);\ninsert into Stu_Course values(5,5);\ninsert into Stu_Course values(5,7);\ninsert into Stu_Course values(7,1);", "Tag": "程序设计"}
{"Answer": "```\r\n#include \r\nint main() {\r\nint a[8];\r\nfor (int i = 0; i < 8; i++) scanf(\"%d\", &a[i]);\r\nint max, min;\r\nmax = min = a[0];\r\nfor (int i = 1; i < 8; i++)\r\n{\r\nif (max < a[i]) max = a[i];\r\nif (min > a[i]) min = a[i];\r\n}\r\nprintf(\"%d\", max - min);\r\nreturn 0;\r\n}\r\n```\r\n\r\n# 问题解决的话，请点下采纳", "Knowledge_Point": "程序设计", "Question": "c语言编程为整形数组a[8]输入数值，输出最大值与最小值之差？c语言编程为整形数组a[8]输入数值，输出最大值与最小值之差？求大佬解答！", "Tag": "程序设计"}
{"Answer": "定义变量b必须先进行初始化才能使用，可以在循环语句外使用，但是只能获取for循环结束后的最后一个值。", "Knowledge_Point": "程序设计", "Question": "Java中for循环语句中嵌套一个if语句，if语句体得出的boolean值无法在循环外使用Java中for循环语句中嵌套一个if语句，if语句体得出的boolean值无法在循环外使用。为什么会出现这种情况?自学Java第5天，编写代码的时候出现了这种情况，本以为原代码哪写的不对，就简单的写了下面的代码，发现还是出现这种情况，请大神指教一二。感谢感谢\n", "Tag": "程序设计"}
{"Answer": "nn=0;\r\nfor w=0:1:20\r\n     nn=nn+1;\r\n     if 6<=w&&w<=11 %这个地方要加&&\r\n     k=0\r\n   else\r\n     k=1\r\n     end\r\nend", "Knowledge_Point": "程序设计", "Question": "matlab中for循环内嵌套if语句无法得到正确结果w取0~20的整数，想要令 6<= w <=11时 k=0；其余情况下 k=1.\n但是在具体运行的时候条件句貌似没有执行，得到的结果全部是k=0.\n具体代码如下：\n\nnn=0\nfor w=0:1:20\n    nn=nn+1\n    if 6<= w <=11\n    k=0\nelse\n    k=1\n    end\nend\n请问是哪里错了呢", "Tag": "程序设计"}
{"Answer": "a=a这样的语句没有任何意义。所以显示不生效。", "Knowledge_Point": "程序设计", "Question": "java中的if语句里赋值不生效if（a＞b）{a=a}这里的“a=a”显示不生效是什么原因呢？", "Tag": "程序设计"}
{"Answer": "```\r\n SELECT * INTO NewTable\r\nFROM [Text;HDR=Yes;FMT=Delimited;Database=C:\\Docs].Test.csv\r\n```", "Knowledge_Point": "程序设计", "Question": "用sql语句如何将txt文档导入到access数据库中？？？？？？？？？如何用sql语句如何将txt文档导入到access数据库中？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？", "Tag": "程序设计"}
{"Answer": "sql语句如下，前面是执行时间，求教怎么把查询速度优化至最大。\r\narray(2) {\r\n[0] => string(6) \"4.1184\"\r\n[1] => string(316) \"select a.custid from g_customer_tb a join g_customer_tbdata b on a.custid = b.custid where (b.rq > '2016-01-29 00:00:00 ' and b.rq < '2018-01-27 23:59:59') and a.shopid in (5,7,18,29,47,77,78,86,87,88,196,197,198,199) and( a.size1 = 1 or a.size2 = 1 or a.size3 = 1 ) group by b.custid having count(b.id) = 1\"\r\n}", "Knowledge_Point": "程序设计", "Question": "求大神帮忙改进一下sql语句sql语句如下，前面是执行时间，求教怎么把查询速度优化至最大。\narray(2) {\n  [0] => string(6) \"4.1184\"\n  [1] => string(316) \"select a.custid from g_customer_tb a join g_customer_tbdata b on a.custid = b.custid where (b.rq >  '2016-01-29  00:00:00 ' and b.rq <  '2018-01-27 23:59:59')  and a.shopid in (5,7,18,29,47,77,78,86,87,88,196,197,198,199)  and( a.size1 = 1 or  a.size2 = 1 or  a.size3 = 1 ) group by b.custid  having  count(b.id) = 1\"\n}", "Tag": "程序设计"}
{"Answer": "\nage = int(input(\"输入你的年龄\"))\nif (age >= 18) and (age < 100):\n    print(\"成年\")\nelif (age <=0)or(age>=100):\n    print(\"输入错误\")\nelse:\n    print(\"未成年\")\n\n突然想明白，判断条件缺少了，输入大于100的数，这个数也同样满足第一个条件，第一个条件满足之后，后面的条件不会继续执行，所以得不到想要的答案，粗心问题，条件不全=.=", "Knowledge_Point": "程序设计", "Question": "Python中if语句多条件今天遇到一个问题代码入下：\n\nage = int(input(\"输入你的年龄\"))\nif(age >= 18):\n    print(\"成年\")\nelif(age <=0 or age>=100):\n    print(\"输入错误\")\nelse:\n    print(\"未成年\")\n\n\n我预想的输出结果是:输入0   以及100之后  得到  输入错误输入 0-100之前的数  得到  成年/未成年\n实际输出结果\n输入-1   得到  输入错误输入101  得到  成年其他正常\n因为本人刚学完JAVA  目前在自学python  我按照java的思路，在想是不是or 关键字的问题但是我换成了java中的 || 他会在编译时候就报错，然后我换成了| 得到的结果就是elif部分的代码完全不执行了哪位小伙伴懂这个", "Tag": "程序设计"}
{"Answer": "\nYou can test this easy but you had an extra paren\n<?php\n\nfunction testNest($a, $b, $c, $d){\n    if ($a < $b || ( $a <= $b && $c = $d )) {\n        echo 'foo';\n    } else {\n        echo 'bar';\n    }\n}\n\n\ntestNest(3, 2, 3, 2); //bar\ntestNest(1, 2, 3, 2); //foo\n\nfunction testElif($a, $b, $c, $d){\n    if ($a < $b ){\n        echo 'foo';\n    } elseif ( $a <= $b && $c = $d ) {\n        echo 'foo';\n    } else {\n        echo 'bar';\n    }\n}\n\ntestElif(3, 2, 3, 2); //bar\ntestElif(1, 2, 3, 2); //foo\n\nI'll let you come up with more examples but there really is no need for elseif\n", "Knowledge_Point": "程序设计", "Question": "PHP IF语句 - 关闭多个条件\n\nIt seems inefficient to me to write multiple conditions to do the same action,,, for example\n\nif ( (condition_one || (condition_two && condition_three) )\n{\n    // Do this ...\n}\nelseif ( condition_two && condition_three)\n{\n    // Do same as before ...\n}\nelse\n{\n    // Do that ...\n}\n\n\nWould there be a valid approach to accomplishing this? Where condition_two and condition_three have to be executed together but separately from condition_one...\n\nif ( (condition_one || (condition_two && condition_three) )\n{\n    // Do this ...\n}\nelse\n{\n    // Do that ...\n}\n\n\nIn other words,,, is there some way, that I am unaware of, to do this:\n\nif ( ( $a < $b || ( $a <= $b && $c = $d ) )\n{\n    echo 'foo';\n}\nelse\n{\n    echo 'bar';\n}  \n\n\nRather than this:\n\nif ( ( $a < $b )\n{\n    echo 'foo';\n}\nelseif ( $a <= $b && $c = $d )\n{\n    echo 'foo';\n}\nelse\n{\n    echo 'bar';\n}\n\n    ", "Tag": "程序设计"}
{"Answer": "不能这样连用，因为机器无法这样直接理解，要用逻辑运算符&&连接：你可以这样写   (StudentID>10000000 && StudentID < 99999999)希望对题主有所帮助，可以的话，帮忙点个采纳！", "Knowledge_Point": "程序设计", "Question": "怎么在条件表达式中表达一个数据是八位的？\n为什么这个大于号不能使用呢？（大一刚学java，还不太懂一些语法规则😊）", "Tag": "程序设计"}
{"Answer": "有帮助请采纳你写成 x = x 的话，程序就会分辨不出来哪个 x 是哪个，因为它们名字一样；所以Java有了关键字 this，this.x 就表明这个 x 是这个类本身有的属性，不是外面传进来的。你如果不想用this，又不想程序分辨不清，就把传进来的变量改个名字，比如 x1", "Knowledge_Point": "程序设计", "Question": "java中的将局部变量赋值给成员变量红框圈住的两行代码，不都是将局部变量赋值给成员变量吗？为什么分析最后结果不是-300。这两行代码有什么区别吗？", "Tag": "程序设计"}
{"Answer": "在windows.h中有如下定义：typedef CHAR *NPSTR, *LPSTR, *PSTR;typedef char CHAR;LPSTR类型为 char * 类型，同理可得LPWSTR类型也为指针类型。不同的是，LPWSTR类型为指向以NULL结尾的16位双字节字符数组指针。同类型的指针赋值，因此能够通过编译，但是两个指针的指向方式不同，因此会有警告。WCHAR类型在头文件中被定义为宽字符，属于宽字符类型，与指针类型不同，因此编译器报错。\n望采纳！", "Knowledge_Point": "程序设计", "Question": "给LPWSTR的变量赋LPSTR的类型值，提示错误，但能通过编译？问题遇到的现象和发生背景\n网上找了一段编写windows服务的框架代码，vsCode没有提示语法错误，但编译时报错，我的环境是vsCode+MinGW_10.0，使用g++命令编译。\n问题相关代码\n#include <Windows.h>#include <stdio.h>#define SERVICENAME L\"ServiceDemo\"\nint main(){    WCHAR ServiceName[] = SERVICENAME;    SERVICE_TABLE_ENTRY DispatchTable[2];   DispatchTable[0].lpServiceName = ServiceName;  //此行为问题代码\n}\n运行结果及报错内容\n\n我的解答思路和尝试过的方法\n错误提示说不能将WCHAR转换为LPSTR，我查看了DispatchTable[0].lpServiceName在winsvc.h中定义，它是LPWSTR类型，跟LPSTR没有关系啊？typedef struct _SERVICE_TABLE_ENTRYW {    LPWSTR lpServiceName;    LPSERVICE_MAIN_FUNCTIONW lpServiceProc;} SERVICE_TABLE_ENTRYW,*LPSERVICE_TABLE_ENTRYW;\n我又尝试给DispatchTable[0].lpServiceName赋一个LPSTR的值，LPSTR MyServerName = (LPSTR)\"MyServer\";DispatchTable[0].lpServiceName = MyServerName;结果vsCode提示语法错误：不能将LPSTR类型的值分配到LPWSTR类型的实体，但能够通过编译，并且能够成功运行。\n我想要达到的结果\n这里我就有点不理解了：为什么给LPWSTR的变量赋LPSTR的值，反而能通过编译。明明提示有错误啊？希望能够解下疑。", "Tag": "程序设计"}
{"Answer": "1、数组赋值那里没问题，问题出在打印System.out.print(a[i]+'\\t');这里，print是打印不换行，a[i]+'\\t'是数字加字符会自动将字符转换为ASSIC码对应的值，这里'\\t'对应的是9，所以a[i]+'\\t'是一个加法计算结果是a[i]+9，并不是a[i]+空格。2、要实现a[i]+空格的打印应该是System.out.print(a[i]+\"\\t\");  a[i]+\"\\t\"相当于数字加字符串会自动将数组转换为字符串。3、冒泡排序有点问题，内循环应该是j < n，要不最后一个数不会进行排序。修改之后的代码如下：\n public static void main(String[] args) {\n     Scanner sc = new Scanner(System.in);\n     int n = sc.nextInt();\n     int a[] = new int[n];\n     for (int i = 0; i < n; i++) {\n         a[i] = sc.nextInt();\n     }\n     for (int i = 0; i < n; i++) {\n         System.out.print(a[i]+\"\\t\");\n     }\n     System.out.println();\n     //从小到大排序\n     for (int i = 0; i < n - 1; i++) {\n         for (int j = i; j < n; j++) {\n             if (a[i] > a[i + 1]) {\n                 int A = a[i];\n                 a[i] = a[i + 1];\n                 a[i + 1] = A;\n             }\n         }\n     }\n     for (int i = 0; i < n; i++) {\n         System.out.print(a[i]+\"\\t\");\n     }\n }\n", "Knowledge_Point": "程序设计", "Question": "Java数组赋值不成功问题遇到的现象和发生背景\n冒泡排序算法\n问题相关代码，请勿粘贴截图\nimport java.util.Scanner;\n\npublic class exercise3 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a[] = new int[n];\n        for(int i=0; i<n; i++){\n            a[i] = sc.nextInt();\n        }\n        for(int i=0; i<n; i++){\n            System.out.print(a[i]+'\\t');\n        }\n        //从小到大排序\n        for(int i=0; i<n-1; i++){\n            for(int j=i; j<n-i; j++){\n                if(a[i]>a[i+1]){\n                    int A = a[i];\n                    a[i] = a[i+1];\n                    a[i+1] = A;\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            System.out.print(a[i]+'\\t');\n        }\n    }\n}\n\n运行结果及报错内容\n51 2 3 5 410111214131011121413\n我的解答思路和尝试过的方法\n这里先不讨论算法正确与否，但是数组赋值那里总会复制不成功，\n我想要达到的结果\n得到正确的赋值结果", "Tag": "程序设计"}
{"Answer": "char* a={\"hello\"}为什么不能修改，这个要涉及进程占用的内存分段，大概分为代码区，只读区，全局区，堆区，栈区。\"hello\"作为一个字符串字面值，是被放在只读区，只读顾名思义就是不能修改的。char* a=\"hello\",相当于把hello的地址赋给了a，故而不能对a指向的内容进行修改。char a[]=\"hello\",这样赋值的就是一个字符数组。字符数组a是在栈区里申请的一个空间给a，然后把只读区的\"hello\"进行了一次复制再赋值给a，这样a的指向是能修改的。", "Knowledge_Point": "程序设计", "Question": "c语言中，为什么不能对字符指针变量指向的字符串再赋值？比如说这段：\nchar *a=\"hello\";\na[2]='c'; //就是这个语句为什么不正确啊", "Tag": "程序设计"}
{"Answer": "使用vlookup函数可以实现。\n公式：=IF(COUNTIF($A$1:$A$3,A7)>0,$A$1,IF(COUNTIF($B$1:$B$3,A7)>0,$B$1,IF(COUNTIF($C$1:$C$3,A7)>0,$C$1)))\n ", "Knowledge_Point": "程序设计", "Question": "EXCEL 逻辑函数 IF 多条件判断返回结果如图：\n\n\n\n在“条件”一列输入数字，“结果”一列返回对应的结果，请问各位大神，有没有什么函数可以直接引用指定单元格范围内的数据，不用在函数里面一个个手动输入条件，因为数据实在太多了，A分类之下可能会有上百个条件", "Tag": "程序设计"}
{"Answer": "你的异步在于getMethod()这个函数是异步的，  而最后的那一行代码没有在这个异步函数的回调里面执行。所以会出现执行data.searchResult.push(emptyFields( data.url, maxID)) 这句的时候 maxID其实还没赋值的情况。你把这行代码往上放几行， 放进回调函数里面就好了", "Knowledge_Point": "程序设计", "Question": "vue  if语句存在 异步问题，我click快了（慢点没事），会造成无法得到我需要的 maxID async function addOne (index, row) { // 增加空白行,并改变焦点\n      let maxID\n      let maxID1\n      let maxID2\n      // 计算本页中表格中数据的 最大的ID值\n      // 下面这段if语句存在 异步问题，我click快了（慢点没事），会造成无法得到我需要的 maxID,请问不改变语句顺序的情况下，\n      // 怎么处理这个异步，\n      if (data.searchResult.length >= 1) {\n      maxID1 = Math.max.apply(Math, data.searchResult.map(item => { return item.id })) + 1\n      } else { \n      maxID1 = 1 \n      }\n      // 从后端获取最大id值\n      await getMethod(data.url,).then(res =>{\n        if (res.length >= 1) {\n          maxID2 = Math.max.apply(Math, res.map(item => { return item.id })) + 1\n        } else { \n          maxID2 = 1 \n        }\n        // 比较两个id值，取最大值， 我click快了（慢点没事）\n        if (maxID1 > maxID2 ) { maxID = maxID1 } else { maxID = maxID2 }\n      })\n      \n      // 调用自定义函数 emptyFields()生成空白对象, 并添加到数据\n      data.searchResult.push(emptyFields( data.url, maxID))\n\n", "Tag": "程序设计"}
{"Answer": "这个一般是链表中定义一个结点用到的结构体\r\nstruct node* next的意思就是定义了一个指针叫next,这个next指针指向的元素的类型是struct node *\r\n这个next指针一般是指向链表的下一个结点（如果已经是最后一个结点就为NULL）", "Knowledge_Point": "程序设计", "Question": "Ｃ结构体定义问题　struct　求详解typedef struct node\n{\n  int data;\n  struct node* next;// 这个地方注意结构体变量的定义规则\n} Node, *PNode;\n\nstruct node* next 这句看不懂啊，有没有大神帮忙详解一下。", "Tag": "程序设计"}
{"Answer": "ready没有分配空间，它指向的是内存中的一个未知区域，你直接->试图取出它的成员变量就会出现异常\r\n\r\n```\r\n #include \r\n#include \r\nstruct  PCB_type \r\n{\r\n    int pid ;   \r\n    int state ; \r\n    int cpu_time ;  \r\n};\r\ntypedef struct QNode\r\n{\r\n    struct PCB_type PCB;\r\n    struct QNode * next;\r\n}QNode;\r\ntypedef struct \r\n{\r\n    QNode * front;\r\n    QNode * rear;\r\n}LinkQuene;\r\n\r\nint main()\r\n{\r\n    QNode *Q = (QNode*)malloc(sizeof(QNode));\r\n    LinkQuene *ready = (LinkQuene *)malloc(sizeof(LinkQuene));\r\n    ready->front = ready->rear = Q;         //到这里就无法执行\r\n    Q->PCB.pid = 1;\r\n    printf(\"%d\\n\",ready->front->PCB.pid);\r\n    return 0;\r\n}\r\n```", "Knowledge_Point": "程序设计", "Question": "求解一个指针操作的问题，直接上代码。写了一个队列，结果初始化的时候就遇到问题了，吧程序简化了一下，求问大神\n\n #include <stdio.h>\n#include <stdlib.h>\nstruct  PCB_type \n{\n    int pid ;   \n    int state ; \n    int cpu_time ;  \n};\ntypedef struct QNode\n{\n    struct PCB_type PCB;\n    struct QNode * next;\n}QNode;\ntypedef struct \n{\n    QNode * front;\n    QNode * rear;\n}LinkQuene;\n\nint main()\n{\n    QNode *Q = (QNode*)malloc(sizeof(QNode));\n    LinkQuene *ready;\n    ready->front = ready->rear = Q;         //到这里就无法执行\n    Q->PCB.pid = 1;\n    printf(\"%d\\n\",ready->front->PCB.pid);\n    return 0;\n}\n", "Tag": "程序设计"}
{"Answer": "\nI solved it. It should have been:\n\"elements\"=> $array\n\n", "Knowledge_Point": "通用散列", "Question": "Facebook messenger bot通用模板不起作用\n\n\n\nI am building a Facebook bot using api.ai and I have gotten  to a point where I need to send responses using Facebook generic template. I fetch the list of items to listed from the database and put them in an array and assign to a variable. My problem is that the data is actually returned as shown by Ngrok but it not shown on Facebook as a generic template. Nothing shows. Here is my code.\n\n\n\nwhile($result = mysqli_fetch_assoc($res)){\n                    $array[] = array(\n\n                             \"title\"=> $result['title'],\n                              \"image_url\"=> $result['img_url'],\n                              \"subtitle\"=> \"See all our colors\",\n                                \"buttons\"=>[\n                                      [\n                                        \"type\"=>\"postback\",\n                                        \"title\"=>$result['title'],\n                                        \"payload\"=>$result['payload_id']\n                                      ]\n                                ]\n                    );\n\n                }\n\n            if ($intentName == \"sex\"){\n                    $data =json_encode([\n                    'speech' => \"Hi \".$firstname,\n                    'displayText' => \"test\",\n                    'source' => \"source\",\n                    'data' => [\"facebook\" => [\n                        \"attachment\"=>[\n                        \"type\"=>\"template\",\n                        \"payload\"=>[\n                        \"template_type\"=>\"generic\",\n                        \"elements\"=>[\n                        //One attachment\n                        $array\n                        //First attachment ends\n\n                        ]\n                     ]\n                    ]   ]\n                ]\n\n                ]);\n                    echo $data; \n            }\n\n\n    ", "Tag": "算法分析"}
{"Answer": "\nThe practice I've personally observed in Go (and it's also what's recommended in the effective Go or getting started with Go tutorials) is just to define a NewdbRepo function and use it for all instantation. It's implementation would look something like;\nfunc NewdbRepo(f, b string) *dbRepo {\n    return &dbRepo{ foo:f, bar:b}\n}\n\nYou can't actually define a constructor as you do in most C like languages so you just gotta provide a package scoped method to do construction for you. Also, if you're not using composite literals (the initilization style I use in my NewdbRepo implementation) then you may find that alone concise enough for your needs. \n", "Knowledge_Point": "通用散列", "Question": "Golang结构构造通用性\n\n\n\nI have a struct that two other objects implement. In this case, typeA and B repo's. There's some initialization code, which are represented as ellipses here. The initialization code is completely duplicated between both constructors, and isn't a big deal while I only have two \ndbRepo\n's, but as I create more I will worry a bit more about the bad practice. Is there any way to generalize this with an interface?\n\n\n\ntype dbRepo struct {\n    foo string\n    bar string\n}\n\ntype typeARepo dbRepo\ntype typeBRepo dbRepo\n\nfunc newTypeARepo(foo, bar string) {\n    ...\n}\n\nfunc newTypeBRepo(foo, bar string) {\n    ...\n}\n\n\n    ", "Tag": "算法分析"}
{"Answer": "//仅供参考\r\nimport java.awt.*;\r\nimport javax.swing.*;\r\n\r\nimport java.util.*;\r\n\r\n//定义JTableTest类，继承JFrame\r\npublic class JTableTest extends JFrame\r\n{\r\n\t//创建包含表格数据的向量\r\n\tfinal String windows = \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\";\r\n\tVector vdata=new Vector();\r\n\t{\r\n\t\t//创建表示行数据的子向量\r\n\t\tVector tempv1=new Vector();\r\n\t\tVector tempv2=new Vector();\r\n\t\tVector tempv3=new Vector();\r\n\t\tVector tempv4=new Vector();\r\n\t\tVector[] tempv = {tempv1,tempv2,tempv3,tempv4};\r\n\t\t//创建数据数组\r\n\t\tString[] data1 = {\"1001\",\"怀旧牛仔裤\",\"200.0\",\"120.0\",\"已发货\"};\r\n\t\tString[] data2 = {\"1002\",\"长袖针织衬衫\",\"110.0\",\"85.0\",\"交易完毕\"};\r\n\t\tString[] data3 = {\"1003\",\"波西米亚长裙\",\"300.0\",\"180.0\",\"待发货\"};\r\n\t\tString[] data4 = {\"1004\",\"短装牛仔服\",\"90.0\",\"47.0\",\"等待处理\"};\r\n\t\tString[][] datav = {data1,data2,data3,data4};\r\n\t\tfor(int i=0;i<tempv.length;i++)\r\n\t\t{\r\n\t\t\t//为每一个表示行数据的子向量添加数据\r\n\t\t\tfor(int j=0;j<data1.length;j++)\r\n\t\t\t{\r\n\t\t\t\t//依次将每行的字符串数组添加到表示行数据的子向量中\r\n\t\t\t\ttempv[i].add(datav[i][j]);\r\n\t\t\t}\r\n\t\t\t//添加表示行数据的子向量到包含表格数据的向量中\r\n\t\t\tvdata.add(tempv[i]);\r\n\t\t}\r\n\t}\r\n\t//创建包含表格标题的向量\r\n\tVector vhead=new Vector();\r\n\t{\r\n\t\t//创建表格标题的字符串数组\r\n\t\tString[] dataHead = {\"商品ID\",\"商品名称\",\"商品原价\",\"成交金额\",\"处理情况\"};\r\n\t\tfor(int i=0;i<dataHead.length;i++)\r\n\t\t{\r\n\t\t\t//将标题的字符串添加到包含表格标题的向量中\r\n\t\t\tvhead.add(dataHead[i]);\r\n\t\t}\r\n\t}\r\n\t//创建表格对象\r\n\tJTable table=new JTable(vdata,vhead);\r\n\t//将表格封装进滚动窗格\r\n\tJScrollPane scrollPane=new JScrollPane(table);\r\n\t//构造方法\r\n\tpublic JTableTest()\r\n\t{//设置表格的一些属性\r\n\t\t//设置不绘制表格的垂直线\r\n//\t\ttable.setShowVerticalLines(false);\r\n\t\t//设置指定行行高\r\n\t\ttable.setRowHeight(3,30);\r\n\t\ttry {\r\n\t\t\tUIManager.setLookAndFeel(windows);\r\n\t\t\tSwingUtilities.updateComponentTreeUI(this);//更新控件的外观\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t//设置网格线的颜色为灰色\r\n\t\ttable.setGridColor(Color.gray);\r\n\t\t//将包含表格的滚动窗格添加进窗体\r\n\t\tthis.add(scrollPane);\r\n\t\t//设置窗体的标题、位置、大小、可见性以及关闭动作、\r\n\t\tthis.setTitle(\"购物网站表格\");\r\n\t\tthis.setBounds(200,200,450,150);\r\n\t\tthis.setVisible(true);\r\n\t\tthis.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n\t}\r\n\t\r\n\t//主方法\r\n\tpublic static void main(String[] args)\r\n\t{\r\n\t\t//创建JTableTest窗体对象\r\n\t\tnew JTableTest();\r\n\t}\r\n}", "Knowledge_Point": "通用散列", "Question": "求SWING JTable组件通用写法！！\npublic JScrollPane getJScrollPane(List list,String[] tableHeads){\n\n    Vector cell ;\n    Vector row = new Vector();\n    tableModel = new DefaultTableModel();\n\n    Vector tableHeadName = new Vector();\n    for (int i=0; i();\n     cell.add(\"添加列\");\n     row.add(cell);\n    }\n    tableModel.setDataVector(row, tableHeadName);\n    jTable = new JTable(tableModel);\n    jTable.setRowHeight(20);\n    jTable.setCursor(new Cursor(12));\n    jScrollPane = new JScrollPane(jTable);\n    jScrollPane.setCursor(new Cursor(12));\n    jScrollPane.setBounds(180, 27, 400, 400);\n    return jScrollPane;\n}\n\n\n\n\n要求传入List集合能够自动生成JTable.........麻烦各位了！", "Tag": "算法分析"}
{"Answer": "\nI don't really dislike the idea to use a separate testing library. If you have an interface and you have generic tests for each interface, other people that implement that interface might like to use these tests as well.\nYou could create a package \"package/test\" that contains a function\n// functions needed for each implementation to test it\ntype Tester struct {\n    func New() package.Interface\n    func (*package.Interface) Done()\n    // whatever you need. Leave nil if function does not apply\n}\n\nfunc TestInterface(t *testing.T, tester Tester)\n\nNotice that the signature of TestInterface does not match to what go test expects. Now, for each package package/impl/x you add one file generic_test.go:\npackage x\n\nimport \"testing\"\nimport \"package/test\"\n\n// run generic tests on this particular implementation\nfunc TestInterface(t *testing.T) {\n    test.TestInterface(t,test.Tester{New:New})\n}\n\nWhere New() is the constructor function of your implementation. The advantage with this scheme is that\n\nYour tests are reusable for whoever implements your interface, even from other packages\nIt is immediately obvious that you run the generic test suite\nThe test cases are where the implementation is and not at another, obscure place\nThe code can be adapted easily if one implementation needs special initialization or similar stuff\nIt's go test compatible (big plus!)\n\nOf course, in some cases you need a more complicated TestInterface function, but this is the basic idea.\n", "Knowledge_Point": "通用散列", "Question": "我如何在通用的测试套件中包含多个软件包？\n\n\n\nWhen I'm writing an interface, its often convenient to define my tests in the same package as the interface, and then define multiple packages that implement the interface set, eg.\n\n\n\npackage/\npackage/impl/x <-- Implementation X\npackage/impl/y <-- Implementation Y\n\n\n\n\nIs there an easy way to run the same test suite (in this case, located in package/*_test.go) in the sub packages?\n\n\n\nThe best solution I've come up with so far is to add a test package:\n\n\n\npackage/tests/\n\n\n\n\nWhich implements the test suite, and a test in each of the implementations to run the tests, but this has two downsides:\n\n\n\n1) The tests in package/tests are not in _test.go files, and end up being part of the actual library, documented by godoc, etc.\n\n\n\n2) The tests in package/tests are run by a custom test runner, which has to basically duplicate all the functionality of 'go test' to scan for go tests and run them.\n\n\n\nSeems like a pretty tacky solution.\n\n\n\nIs there is a better way of doing this?\n\n    ", "Tag": "算法分析"}
{"Answer": "\nTo do that you'll have to use a map with values of type interface{} so they can store any type. If you also need the column names you'd have to use rows.Columns() to then extract all the data and types.\nThis will read all columns from a table and store the values in a map as type interface{} with the column names as keys. Based on that you should be able to work out what you need for your use.\nvar myMap = make(map[string]interface{})\nrows, err := db.Query(\"SELECT * FROM myTable\")\ndefer rows.Close()\nif err != nil {\n    log.Fatal(err)\n}\ncolNames, err := rows.Columns()\nif err != nil {\n    log.Fatal(err)\n}\ncols := make([]interface{}, len(colNames))\ncolPtrs := make([]interface{}, len(colNames))\nfor i := 0; i < len(colNames); i++ {\n    colPtrs[i] = &cols[i]\n}\nfor rows.Next() {\n    err = rows.Scan(colPtrs...)\n    if err != nil {\n        log.Fatal(err)\n    }\n    for i, col := range cols {\n        myMap[colNames[i]] = col\n    }\n    // Do something with the map\n    for key, val := range myMap {\n        fmt.Println(\"Key:\", key, \"Value Type:\", reflect.TypeOf(val))\n    }\n}\n\nUsing the reflect package you can then get the Type for each column as needed as demonstrated with the loop at the end. Or you can use a type switch to extract the types.\nThe above is generic and will work with any number of columns and types.\n", "Knowledge_Point": "通用散列", "Question": "将数据库查询返回的数据存储到动态创建的通用Go数据类型中\n\n\n\nInstead of using a \nstruct\n, which is predefined in terms of its number of data fileds, capacity, and types of that fields, having a \nmap\n, which is expandable and can contain several data types as value, will be more advantageous. For example, on database side, changes to column names, column types, or number of columns in a table will not affect the go code related to querying the database, such as go data structure you put the \nrows\n returned form your database query.\n\n\n\nIs there a way in golang sql package or related drivers to know the types of the data, in rows, returned by a database query to define a \nstruct\n with  appropriate number of fields and types?\n\n\n\nIf not how can a \nmap\n be used to accomplish this with column names of returned \nrows\n are \nkeys\n and row fields are \nvalues\n of this \nmap\n?\n\n    ", "Tag": "算法分析"}
{"Answer": "打开终端（terminal），然后pip install xxx 会方便很多，不过需要确认已经激活了你需要的环境，我这里（TF2.1）就是我用anaconda创建的虚拟环境已经激活的状态。", "Knowledge_Point": "通用散列", "Question": "这个情况是什么回事呢，pip的版本是一样的还是出现这个情况\n。请教一下出现这个问题原因，如何解决，请指点迷津，以及在cmd安装和在pycharm环境安装的能通用嘛", "Tag": "算法分析"}
{"Answer": "就你这点描述，只能得出一个结论：注册中心里没有你要调用的服务。", "Knowledge_Point": "通用散列", "Question": "我一直无法理解关于netflix.client.ClientException: Load balancer does not have available server for client:\n这个现象很奇葩\n网上全是一通乱抄,什么原因也不解释,上来就一通加什么配置,搞到最后也出不来,气死我了.\n别在底下回答网上通用的答案了,我试过,没用.", "Tag": "算法分析"}
{"Answer": "\n//c51 中 sbit 不能在函数中传递参数。C51 也没有 bit 指针。\nvoid control(sbit x) //这样肯定是不行的\nvoid control(sbit *x) //这样肯定是不行的\n\n\n//不过可以先做个 IO 的驱动\n比如2个电机，每个电机 2 个 IO \nsbit A0 = P1^0;    //电机0\nsbit B0 = P1^1;    //电机0\nsbit A1 = P1^2;    //电机1\nsbit B1 = P1^3;    //电机1\n\nvoid set_ioa(char moto,bit var)\n{\n    if(moto == 0)\n        A0 = var;\n    if(moto == 1)\n        A1 = var;\n}\n\nvoid set_iob(char moto,bit var)\n{\n    if(moto == 0)\n        B0 = var;\n    if(moto == 1)\n        B1 = var;\n}\n\nvoid control(char moto,char speed)\n{\n    set_ioa(moto,0);\n    set_iob(moto,1);\n}\n\n", "Knowledge_Point": "通用散列", "Question": "同一功能的函数针对不同对象，如何实现啊！\n有4个电机A，B，C，D！\n设定sbit A，B，C，D四个引脚\n想写一个通用的函数，用于调速。\n设定一个形参，调用函数的时候，把想要调速的电机传进来。要怎么弄啊！\n\n\n但是难不成必须写四个函数？", "Tag": "算法分析"}
{"Answer": "99.9999% 的场景下你都不需要用到深拷贝，唯一用到的应该是面试。\n另外，immer.js 了解一下", "Knowledge_Point": "通用散列", "Question": "JavaScript 中深度拷贝使用 JSON.stringify 和 parse 好么?\n我发现js中对象深度复制可以用:JSON.parse(JSON.stringify(obj)),\n这样可以完全复制一个对象,不用担心它的子对象是关联的,不知道这样好不好\n主要是性能可行么\n深拷贝-业界有通用的复制方法么\nES6提供的(3个点)操作符能完全复制一个对象么", "Tag": "算法分析"}
{"Answer": "有个隐藏方法  getLine1Number(int subId)，需要反射调用", "Knowledge_Point": "通用散列", "Question": "Android获取第二张卡手机号码\nAndroid获取第二张卡手机号码\ngetLine1Number()好像只能获取目前上网卡的手机号（好像跟一二卡没啥关系），所以求一个通用的调用方法获取另一个手机号，要求能像getLine1Number()一样直接调用，没有第二张卡时返回null即可，如果有和getLine1Number()一样返回带+86的手机号。", "Tag": "算法分析"}
{"Answer": "你这个是针对sql脚本的,首先,你要针对这种形式写一个接收参数的class.\r\n例:\r\npublic class searchClass{\r\npublic string display{get;set;}//多个参数可以用,形式,例 如:a,b,c,element\r\npublic string table{get;set;}\r\npublic List conditions{get;set;}\r\n//可以加更多参\r\n}\r\n\r\npublic class searchCondition{\r\npublic string  key {get;set;}\r\npublic string value{get;set;}\r\npublic string fn{get;set;}//  >  <  = ...\r\n}\r\n\r\n    public IctionResult Api(searchClass param)\r\n        {\r\n          string sql = \" select \"+param.display+\" from \" + param.param ;\r\n\t\t  if(param.conditions!=null && param.conditions.count()>0)\r\n\t\t  sql+=\" where 1=1 \";\r\n\t\t  \r\nforeach (var item in param.conditions) sql += \" and \" + item.key + item.fn + item.value;\r\nif (o != null) sql += \" order by\" + o;\r\n        }", "Knowledge_Point": "通用散列", "Question": "C# api接口不固定参数get传参\n要写一个C#的api访问接口，get方式传参，需求：参数个数和参数名不固定。例如：\n\n参数是 element，time，class，则后台实现 select element from tab1 where datatime>time and className=class;\n\n如果传参数 element， time，class,order,则后台实现 select element from tab1 where datatime>time and className=class order by order;\n\n还要类似很多这种情况， 怎么写一个通用的方法实现 ", "Tag": "算法分析"}
{"Answer": "自己定义一个转换器接口\r\n\r\n//T类型为转换后的类型，F为转换前的类型\r\ninterface Converter\r\n{\r\nT convert(F from);\r\n}\r\n\r\n//定义一个处理结果map的接口\r\n\r\ninterface Processor\r\n{\r\nvoid processResultMap(Map map,String key,Converter c)\r\n{\r\n//具体就自己实现了\r\n\r\n}\r\n\r\n}", "Knowledge_Point": "通用散列", "Question": "关于ibatis使用resultClass=\"HashMap\"的时间转换问题\n由于经常写报表，所以想写一个通用的ibatis用sql语句的查询，这样带来一个问题：返回值不固定。于是，我想到了使用result=\"java.util.HashMap\"。\n\n  但是由于ibatis连接oracle时候，timestamp类型的值会被转换成一长段不知所云的字符串，所以开发就卡住了。\n\n  望解答：如何在返回值为Hashmap的时候，指定格式化字符串", "Tag": "算法分析"}
{"Answer": "也可以用re模块实现\n\n代码\nimport re\nz = ''' ''' # 您的多行文本。\nprint('\\n'.join(re.findall(r'\\d.\\w+', z)))\n\n效果截屏图片\n\n这个方法不能解析C后的“#”\n\n还可以用列表解析\n\nz = ''' ''' # 您的多行文本\nz = '\\n'.join([i for i in z.split('\\n') if '.' in i])\nprint(f\"\\n用列表解析：\\nstr.split()方法分拆字符串，join()方法拼接\\n{'~'*41}\\n\\n{z}\\n\")\n\n运行效果截图\n\n", "Knowledge_Point": "通用散列", "Question": "怎么检索文字中起始位置带有123的字，并显示出来？\nz = \n'''\n1.php\nphp是呐什么语言\n一种通用开源脚本语\n2.C# \nC语言是一种面向过程的程序设计语言。\n它既有高级语言的特点，\n又具有汇编语言的特点。\n3.JavaScript\nJavaScript是一种基于对象（Object）和事件驱动（Event Driven）并具有相对安全性的客户端脚本语言。\n'''\n\n\n\n# print 打印\n\n\n1\n.php\n\n2\n.C\n# \n\n\n3\n.JavaScript\n", "Tag": "算法分析"}
{"Answer": "可以试试把在页面写个 透明div 遮盖住iframe  想调用iframe里的事件  div上加入其它透明的按钮模拟监听点击", "Knowledge_Point": "通用散列", "Question": "手机web插入iframe腾讯视频滑动屏幕，其它地方点不了了\n你好，\n\n我发文章插入视频，\n\n用腾讯视频iframe的通用代码，\n\n可正常观看，\n\n可是，当我滑动屏幕，手点到iframe视频上往上拖滑后，整个页面其它地方就点不了了，点了没反应，我用手再点一下iframe视频的任何地方，页面其它地方就恢复可以点击了，要是只单独点一下iframe视频不拖滑屏幕，没事，请问怎么解决！谢谢！\n\n\n\n安卓手机没这个问题", "Tag": "算法分析"}
{"Answer": "也可以自己保持层级关系，\r\n比如\r\n根节点id：1\r\n一级节点id：1.1，1.2……\r\n二级节点id：1.1.1，1.1.2，1.2.1……", "Knowledge_Point": "通用散列", "Question": "树型结构在数据库中的存储\n刚刚看到这个帖子[url]\nhttp://www.iteye.com/topic/602979[/url]，想起这也是个常会遇到的问题，个人也是一会觉得这样不错一会又那样好，想向各位有经验的朋友请教一下关于这个问题的一些最佳实践，除了Oracle的自己的start\n with ... connect by...这样的基于数据库特性的。最好还可以提一些通用的方案。\n\n\n\n谢谢各位的分享。 :D ", "Tag": "算法分析"}
{"Answer": "是的，session从来都没有关闭,你需要写代码关闭。最好不要写在过滤器里关闭，这是极差的方法。应该在连接完之后就关闭。", "Knowledge_Point": "通用散列", "Question": "关于getsession()方法的疑问\n最近发现项目中的一个DAO方法中为了支持所有的HQL查询，我们写了一个通用的方法，这个方法是调用getsession方法获得hibernate的 session的。我感觉这个方法是获得hibernate 的session后，可能是要自己关闭session.可是我们的方法中没有关闭session,所以我觉得这个方法有问题。大家看看这段代码。\n\n\n\n \n\n\n\npublic class HQLDao extends HibernateDaoSupport implements IHQLDao{\n    \n    //我觉得这个方法有问题，因为这样查出来的1对多的数据中，所有set集合的延迟加载都好像没有打开一样。所以我怀疑session重来没有关闭。\n    public List executeList(String sql) {\n        \n        List list = getSession().createQuery(sql).list();\n        return list;\n    }\n    \n    \n}\n\n\n\n 给位帮我分析一下。\n\n\n\n \n问题补充\n但是如果这个线程不结束，这个session也就是一直存在，可是这个线程会自己结束吗。如果不会是不是会造成内存泄漏。\n问题补充\n而且我做过测试这个方法如果在一个action中循环调用一定次数之后，程序就无法继续查询估计是session没有关闭造成的，而是用spring的模板就没有这种问题。", "Tag": "算法分析"}
{"Answer": "请求的参数不对，所以返回的是一个静态页面", "Knowledge_Point": "通用散列", "Question": "python post请求获取信息失败\n我的代码如下：\n\n\nimport requests\nimport re\n\n\n#构建头部\n\nhead={\n\"user-Agent\"\n:\n\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36 Edg/98.0.1108.62\"\n\n      }\n\n\n#通用网址\n\nurls1='https://wenshu.court.gov.cn/website/parse/rest.q4w'\n\n\n#参数\n\nparams={'pageId': 'b74c\n0348\nf\n4832\n3e\n098910\n4d60ecc29cb',\n's38': '100',\n'fymc': '北京市高级人民法院',\n'sortFields': 's50:desc',\n'ciphertext': '\n111001\n \n110000\n1 \n110110\n1 \n100101\n1 \n100011\n0 \n101101\n0 \n101001\n1 \n111101\n0 \n110010\n \n100111\n0 \n100111\n0 \n111000\n1 \n100010\n0 \n100100\n0 \n110111\n1 \n101001\n1 \n111100\n1 \n100100\n0 \n111000\n1 \n100010\n0 \n110001\n0 \n110111\n \n110111\n1 \n100010\n0 \n110010\n \n110000\n \n110010\n \n110010\n \n110000\n \n110101\n \n110010\n \n110010\n \n100101\n1 \n101001\n1 \n111101\n0 \n111000\n0 \n111011\n0 \n100111\n0 \n111001\n1 \n101010\n1 \n110010\n1 \n110011\n1 \n100100\n1 \n110111\n \n111010\n0 \n110110\n1 \n110100\n0 \n101010\n1 \n110000\n1 \n100001\n1 \n110001\n \n110111\n0 \n110001\n \n111011\n1 \n111101\n \n111101\n',\n'pageNum': '2',\n'pageSize': '5',\n'queryCondition':'[{\"key\":\"s38\",\"value\":\"100\"}]',\n'cfg': 'com.lawyee.judge.dc.parse.dto.SearchDataDsoDTO@queryDoc',\n'__RequestVerificationToken': 'HIvB9LtxOIGrmoW2dCDLDP6H',\n'wh': '609',\n'ww': '\n1280\n',\n'cs': '0',\n'HifJzoc9': '4.5flpnYI0JS5iuUTSbsfetifYW2ySbwqWOHxC9kgjmQMk71ko7dZyFiriNxGl0M8jfnrAKLcNPAT6CeOWRHM2dP8iZo09JDTHD4tNmyqU6wLPlr6QdcQMoptfvy7ifjzMde_G4JxSbgvyfMVTkjwc1ycq8.p3k4W5kXLiJeq8GhgZbWCOOii2vn7Zv.ZDuoohTeZ3RsCTj_TF29nKE8ZMTi1GRyROa5Z8qHchtvuzH6SWCo_qvxw8EiAqn7Ay6.A2PupcMh9_2RgfrxO3TcJ7HA5CQcwomL.DRI92fL2.nP0EuDZmP4aBJcR1T8ICOJlrstZEouwW8iSEMOHd46Z0c27jnpCifvTvNeeMDxLOSSH2Cop5wKu7rBU_LEC0CdlhO3FdfEHCyXhgohTVDMLCbPkYGyH0owlweyeK1jnrE6BzBu2L4mdB9GjbywoVySWalZ'\n}\n\n\n\n#获取每页文本信息\n\nreq=requests.post(url=urls1,headers=head,data=params)\nreq=req.text\nprint(req)\n\n\n\n\n代码运行后只能返回一个不相关的网页代码，并不能返回我想要的信息。请问该怎么解决呢？\n返回的结果：\n\n\n\n\n我想要的：\n\n", "Tag": "算法分析"}
{"Answer": "select danwei,sum(yilei),sum(erlei),sum(sanlei),sum(silei) from tongji002 group by danwei;", "Knowledge_Point": "通用散列", "Question": "求助：现在需要在oracle中先按照单位分组，然后将单位的各个数值信息进行相加统计，汇总成一行，请大神帮助，谢谢！！！\n数据库：ORACLE 11G\n\n这是我根据工作环境创建的简化的表，实际单位有上百个，需要一个比较通用的方法。\n\n原始数据表结构如下：\n需要达到的效果如下图：\n也就是先根据单位分类，然后将后面四个属性中的数值进行合并相加。\n如果达不到这样的效果也可以在每类单位下面加一行合计。\n测试表建表代码如下：\n\n\n\n-- Create table\ncreate table TONGJI002\n(\n  id     NUMBER,\n  danwei VARCHAR2(100),\n  yilei  NUMBER,\n  erlei  NUMBER,\n  sanlei NUMBER,\n  silei  NUMBER\n)\ntablespace USERS\n  pctfree 10\n  initrans 1\n  maxtrans 255\n  storage\n  (\n    initial 64\n    next 1\n    minextents 1\n    maxextents unlimited\n  );\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (1, '第一中学', 2, 2, 5, 6);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (2, '第一中学', 1, null, 4, null);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (3, '第一中学', null, 3, null, 9);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (4, '第二中学', null, null, 7, 8);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (5, '第二中学', null, 5, null, null);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (6, '第三中学', 3, 3, 4, 8);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (7, '第三中学', 1, null, 5, null);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (8, '第三中学', 1, 6, null, 9);\ninsert into tongji002 (ID, DANWEI, YILEI, ERLEI, SANLEI, SILEI) values (9, '第三中学', null, null, 8, 8);\n\n\n\n\n急需大神帮助，跪谢！！！", "Tag": "算法分析"}
{"Answer": "a = int(input())\nb = input().split(\" \")\nb = list(map(lambda x:int(x),b))\nd = []\ndef sort(a):\n    for j in range(1,len(a)):\n        for i in range(len(a)-1):\n            if a[i] > a[i+1]:\n                a[i], a[i+1] = a[i+1],a[i]\n    return a\nfor i in range(1,len(b)+1):\n    c = sort(b[0:i])\n    d.append(c[len(c)//2] if len(c) %2 == 1 else (c[len(c)//2]+c[len(c)//2-1])/2)\nprint(\"{\",end = \"\")\nfor i in range(len(d)):\n    print(d[i],end = \"\")\n    print(\",\" if i != len(d)-1 else \"\" ,end = \"\")\nprint(\"}\")\n    \n", "Knowledge_Point": "中位数", "Question": "python 中位数几何\nN个整数的中位数是指这N个整数排序后中间的那个数(即小于它和大于它的数的数量相等)，如果个数为奇数，排序后中间的那个数即为中位数，并约定：如果N为偶数，则取排序后正中间的两个数的平均值（取整数）。编写程序，输出给定整数数组的前1个，前2个，……前N个的中位数（以空格分隔）。\n\n\n输入格式:\n第一行是整数的个数N（正整数）、第二行是空格间隔的N个整数。\n\n\n输出格式:\n花括号中的N个整数，以逗号分隔，依次是前一个，前两个，……前N个数的中位数（整数）。\n\n\n输入样例:\n6\n-20 30 -10 10 40 -40\n输出样例:\n{-20,5,-10,0,10,0}\n代码长度限制\n16 KB\n时间限制\n40 ms\n内存限制\n64 MB", "Tag": "算法分析"}
{"Answer": "如果要放在一个函数里面，那么只能定义一个对象，用三个属性来存储三个结果，也可以直接用 Map 。", "Knowledge_Point": "中位数", "Question": "Java语言计算平均数、算术平均数、中位数，三个函数怎么放在一个函数里，同时返回\nJava语言计算平均数、算术平均数、中位数，三个函数怎么放在一个函数里，同时返回", "Tag": "算法分析"}
{"Answer": "def mean(numbers):  #计算平均值\n    s=0.0\n    for n in numbers:\n        num=int(n)\n        s=s+num\n    return s/len(numbers)\n\ndef dev(numbers,mean):  #计算标准差\n    sdev=0\n    for num in numbers:\n        sdev=sdev+(num-mean)**2 \n    return pow(sdev/(len(numbers)-1),0.5) \n\ndef median(numbers):  #计算中位数\n    news_numbers=sorted(numbers)\n    size=len(news_numbers)\n    if size%2==0:\n        med=(news_numbers[size//2-1]+news_numbers[size//2])/2\n    else:\n        med=news_numbers[size//2]\n    return med\n\nnumbers=eval(input(\"请输入数据，并以逗号分隔:\"))\nprint(\"平均值：%.2f,标准差：%.2f,中位数：%.2f\"%(mean(numbers),dev(numbers,mean(numbers)),median(numbers)))\n", "Knowledge_Point": "中位数", "Question": "python求一组数据的标准差和中位数\n如何用python求一组数据的平均数、标准差和中位数，并保留两位小数？\n\n\nnumbers\n=eval(input(\"请输入数据，并以逗号分隔:\"))\n\nsum\n=0\n\ncount\n=0\n\nfor\n i \nin\n numbers:\n    \nsum\n=sum+i\n    \na\n=sum/len(numbers)\n\nprint\n(f\n\"平均值：{a:.2f}\"\n)\n\n\n\n\n接下来如何写？", "Tag": "算法分析"}
{"Answer": "排序有问题，改成：\nfor(j=0;j<6;j++)\nfor(i=0;i<6-j;i++)\n{\n    if(c[i]<c[i+1])\n    {\n        d=c[i];\n        c[i]=c[i+1];\n        c[i+1]=d;\n    }\n\n}\n\n", "Knowledge_Point": "中位数", "Question": "求两个数组的中位数，为什么输入完数后，运行不了\n#include\nint main()\n{\n    int a[5],b[2],c[7];\n    int i,j,d;\n    for(i=0;i<=4;i++)\n    scanf(\"%d\",&a[i]);\n    for(i=0;i<=1;i++)\n    scanf(\"%d\",&b[i]);\n     for(i=0;i=4;i++)\n     {\n         c[i]=a[i];\n\n\n }\n c[\n5\n]=b[\n0\n],c[\n6\n]=b[\n1\n];\n for(j=\n0\n;j<\n6\n;j++)\n for(i=j+\n1\n;i<=\n6\n;i++)\n {\n     if(c[j]<c[i])\n     {\n         d=c[i];\n         c[i]=c[j];\n         c[j]=d;\n     }\n     \n }\n d=c[\n3\n];\n printf(\n\"中位数为%d\\n\"\n,d);\n return \n0\n;\n\n\n\n}", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\n\nint main() {\n    int a, b, c, d;\n    scanf(\"%d\", &a);\n    b = a / 100 % 10;\n    c = a / 10 % 10;\n    d = a % 10;\n    printf(\"%d %d %d\\n\", b, c, d);\n} \n", "Knowledge_Point": "中位数", "Question": "c语言  输出一个自然数的百位十位和个位上的各个数字\n输出一个自然数的百位十位和个位上的各个数字\n内存限制：    65536 KB\n时间限制：    1000 ms\n问题描述：    输入一个自然数，输出这个整数的百位、十位和个位上的数字。\n\n\n例1：\n输入： 8\n输出： 0 0 8\n\n\n例2：\n输入： 26\n输出： 0 2 6\n\n\n例3：\n输入： 347\n输出： 3 4 7\n\n\n例4：\n输入： 1234\n输出： 2 3 4\n\n\n输入：    一个正整数\n输出：    三个0-9之间的数（空格分隔）\n输入示例：    1234\n输出示例：    2 3 4\n提示：    1、输入的数可能是0-32767之间的任何一个数；\n2、输出必须是三个0-9之间的数，三个数用空格分隔。\n3、输出不能有其它多余的内容；\n\n\n4、本程序的关键在于使用 % 和 / 运算。", "Tag": "算法分析"}
{"Answer": "\nTo get this to work with like you would use something close to below. The % is used as a wildcard to match anything on either side of the query. \nSELECT * FROM codes WHERE code LIKE '%12345%'\n\nOr from your code\n$query = mysqli_query($connect, \"SELECT * FROM codes WHERE code LIKE '%\" . $code . \"'\");\n\nBut direct input into your sql without sanitation is bad practice. Below is a better option, but using PDO would be the best.\n$query = mysqli_query($connect, \"SELECT * FROM codes WHERE code LIKE '%\" . mysqli_real_escape_string($code) . \"'\");\n\nTo check if code is valid you would change your while statement to the following\nif(mysqli_num_rows($query) > 0) {\n    echo \"Code Valid\";\n\n    while($row = mysqli_fetch_array($query)) {\n        /* Output of codes if wanted */\n    }\n} else {\n    echo \"Invalid code\";\n}\n\n", "Knowledge_Point": "中位数", "Question": "在整个表格行中搜索五位数字？\n\n\n\nTo put it simply, I'm trying to search an entire row for a 5 digit number that is parsed in via the URL.\n\n\n\nThis is the code I have so far:\n\n\n\n$code = $_GET['code'];\n$connect = mysqli_connect(\"localhost\", \"root\", \"\", \"test\") or die(\"Could not connect to    database!\");\n\n$query = mysqli_query($connect, \"SELECT * FROM codes\");\n\nwhile($row = mysqli_fetch_array($query))\n{\n    if($code == $row['code'])\n    {\n        echo \"Code valid\";\n        break;\n    }\n    else\n    {\n        echo \"Invalid code\";\n        break;\n    }\n}\n\n\n\n\nThis code partly works, but only outputs \"Code valid!\" when the first value from the database (12345) is parsed in.\n\n\n\nI've seen the mysql LIKE clause mentioned a few times here, but I haven't been able to get it to work so far. I'm still pretty amateur, so apologies if I'm completely missing something.\n\n    ", "Tag": "算法分析"}
{"Answer": "\nAnd when you can't rely on the PHP configuration, don't forget about number_format() which you can use to define how a number is returned, ex:\n// displays 3.14 as 3 and 4.00 as 4    \nprint number_format($price, 0); \n// display 4 as 4.00 and 1234.56 as 1,234.56 aka money style\nprint number_format($int, 2, \".\", \",\"); \n\nPS: and try to avoid using money_format(), as it won't work on Windows and some other boxes\n", "Knowledge_Point": "中位数", "Question": "PHP中输出的默认小数位数\n\n\n\nI do my php work on my dev box at home, where I've got a rudimentary LAMP setup.  When I look at my website on my home box, any numbers I echo are automatically truncated to the least required precision.  Eg 2 is echoed as 2, 2.2000 is echoed as 2.2.\n\n\n\nOn the production box, all the numbers are echoed with at least one unnecessary zero, eg 100 becomes 100.0.  On both boxes, the PHP version is 5.2.5.  Does anyone know offhand if there is a setting I can change which will force PHP to automatically remove any unnecessary zeroes?  I don't want to have to go to every place in my code where I output a number and replace echo with printf or something like that.\n\n\n\nMuchas gracias.\n\n    ", "Tag": "算法分析"}
{"Answer": "32位颜色往往是argb，也就是分成4组（4个字节），每组（每个字节8位）表示一个分量，其中a表示透明度，真正表示颜色red green blue的各自是0~255。\r\n如果没有alpha混合，其实相当24位色。\r\n对于256色，就不同了，那个使用调色板来确定一个颜色，而不是rgb混合。", "Knowledge_Point": "中位数", "Question": "windows程序设计像素相连颜色位数问题\n请问，windows程序设计中，像素相连颜色位数是什么意思？我看书上说的icolors=1<<（iplanes*ibitspixel）,那么如图显示，这里的ibitspixel为32，那么是不是表示可以支持2的31次方数量的颜色？但是书上说颜色只有真彩、髙彩和256色等，而且colorref值是一个32位的无符号长整形，并且前8位是0，实际上也就是用了24位表示颜色，一般也就有1600W种颜色，还有，colorres是啥意思？请知道的告诉下，谢谢了", "Tag": "算法分析"}
{"Answer": "```\r\nunit Unit1;\r\n\r\ninterface\r\n\r\nuses\r\n  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,\r\n  Dialogs, StdCtrls;\r\n\r\ntype\r\n  TForm1 = class(TForm)\r\n    Edit1: TEdit;\r\n    Edit2: TEdit;\r\n    Button2: TButton;\r\n    procedure Button2Click(Sender: TObject);\r\n  private\r\n    { Private declarations }\r\n  public\r\n    { Public declarations }\r\n  end;\r\n\r\nvar\r\n  Form1: TForm1;\r\n\r\nimplementation\r\n\r\n{$R *.dfm}\r\n\r\nFunction GetInt2(S:string):String;\r\nvar\r\n  S1,S2:String;\r\n  i,j:integer;\r\nbegin\r\n  result:='';\r\n  j:=1;\r\n  for i:=0 to length(S) do\r\n  begin\r\n    if (J=2) and ((Ord(S[i])>=48) and (Ord(S[i])<=57)) then\r\n    begin\r\n      S2:=S[i];\r\n      j:=0;\r\n    end;\r\n    if (J=1) and ((Ord(S[i])>=48) and (Ord(S[i])<=57)) then\r\n    begin\r\n      S1:=S[i];\r\n      j:=2;\r\n    end;\r\n  end;\r\n  if J=0 then result:=S1+S2;\r\nend;\r\n\r\nprocedure TForm1.Button2Click(Sender: TObject);\r\nbegin\r\n  edit2.Text:=GetInt2(Edit1.text);\r\nend;\r\n\r\nend.\r\n \r\n```", "Knowledge_Point": "中位数", "Question": "delphi 取出字符串中首两位的数字\ndelphi 取出字符串中首两位的数字 如RB30 与 L15G3 与 LX20G3K0  取出 30 15 20", "Tag": "算法分析"}
{"Answer": "\nfor i in range(1,1000):\n    if i%3==0 and '5' in str(i):\n        print(i)\n ", "Knowledge_Point": "中位数", "Question": "用Python输出1~999中能被3整除,而且至少有一位是5的所有数字\n才学习Python没多久，萌新求求大佬帮帮忙吧，真的感谢了😭", "Tag": "算法分析"}
{"Answer": "用str.len方法来获取长度：\r\n\r\n```\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom pandas import DataFrame,Series\r\nlc = pd.DataFrame(pd.read_csv('LoanStats3a.csv',header=0,dtype=str))\r\ndf = lc[lc[\"ID\"].str.len() == 18]\r\nprint(df)\r\n```\r\nLoanStats3a.csv文件demo为：\r\n\r\n```\r\nID,name,age\r\n320625198811201233,wang,32\r\n120625198811201233,wang1,32\r\n220625198811201233,wang2,32\r\n320625198811201233,wang3,32\r\n420625198811201233,wang4,32\r\n520625198811201233,wang5,32\r\n5206,wang5,32\r\n```\r\n核心筛选语句为：df = lc[lc[\"ID\"].str.len() == 18]，每列必须是字符类型，使用str.len才能进行长度判断。", "Knowledge_Point": "中位数", "Question": "如何用python  pandas按某列中字符长度等于18位的条件 筛选出excel表中所有数据？\n比如，一个excel 表中，有一列是各类证件号，如何用python pandas 方法，按按某列中字符长度等于18位的条件 筛选出excel表中所有数据。这个条件如何写？", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\nint main()\n{\n    FILE *fp;\n    fp = fopen(\"out.txt\", \"w+\");\n    printf(\"输出水仙花数:\\n\");\n    int i, a, b, c;\n    for (i = 100; i <= 999; i++) //整数的取值范围\n    {\n        int a = i % 10;//个位数 \n        int b = (i / 10) % 10;//十位数 \n        int c = i / 100;//百位数 \n\n        if (i == a * a * a + b * b * b + c * c * c){ //各位上的立方和是否与原数n相等\n            printf(\"%d\\t\", i);\n            fprintf(fp, \"%d \", i);\n            }\n    }\n    int fclose ( FILE * stream );\n\n    return 0;\n}\n\n", "Knowledge_Point": "中位数", "Question": "关于#c语言#的问题：最后将其中“水仙花数”输出到当前文件夹中的“outtxt文件\n输入不多于500个大于0的整数到一维数组(当输入的数为0时结束输入)。\n然后降序排序，最后将其中“水仙花数”输出到当前文件夹中的“outtxt文件。\n提示:一个三位数，其各位数字立方和等于该数本身即为“水仙花数”。\n例如:153=13+53+33。\n示例:输入:\n120 153 350 650 370 407 578\n\n\n输出:(存入文件outtxt中的内容)\n407 370 153", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\nint main()\n{\n   long n;\n   int t,m,max;\n   m=0;max=0;\n   scanf(\"%ld\",&n);\n   while(n)\n  {\n     t = n % 10;\n     n = n / 10;\n     if(t > max) max = t; //max保存各位数字的最大值.\n     m++; //m用来统计该数的位数.\n  }\n  printf(\"位数:%d 最大数=%d\\n\",m,max); //m是该数的位数. max是各位数字中的最大值.\n  return 0;\n}\n", "Knowledge_Point": "中位数", "Question": "找出不指定位数的正整数中的最大一位数字并求出该正整数的位数\n找出不指定位数的正整数中的最大一位数字并求出该正整数的位数，这该怎么找啊", "Tag": "算法分析"}
{"Answer": "用平均值的和的平方除以长度不就行了？为什么长度要减一呢？后面的问题也是，如果用长度除2得到的应该是中位数靠前的那一位，如果减一就不在中间位置了不是吗，比如6/2，得到的3，减一的话就是位置2了", "Knowledge_Point": "中位数", "Question": "请教一下python里的两个问题\n问题遇到的现象和发生背景\n\n\n问题：\n1，为什么这里的len要减一呢？\ndef dev(numbers, mean): #计算方差\n    sdev =0.0\n    for num in numbers￼\n        sdev=sdev +(num -mean)**2\n     return pow(sdev/(len(numbers)-1), 0.5）\n\n\n2，为什么计算中位数的时候，取中位数位置要减一？\n￼￼\n￼\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果", "Tag": "算法分析"}
{"Answer": "代码如下，如有帮助，请采纳一下，谢谢。\n\n#include <stdio.h>\n\ndouble fun(double n)\n{\n\tdouble d = n * 100.0;\n\t\n\tint d2 = ((unsigned long )(d * 10)) % 10;\n\tif ( d2 <= 4)\n\t\td = (unsigned long )d / 100.0;\n\telse\n\t\td = ((unsigned long)d + 1)/100.0;\n\treturn d;\n}\n\n\n\nint main()\n{\n\tprintf(\"%f \\n\", fun(1.1115));  \n\tprintf(\"%f \\n\", fun(1.1165));\n\tprintf(\"%.2f \\n\", fun(1.1115));  //.2f可以控制小数点后的位数\n\tprintf(\"%.2f \\n\", fun(1.1165));\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}", "Knowledge_Point": "中位数", "Question": "请编一个函数fun，函数的功能是使实型数保留2位小数，并对第三位进行四舍五入 （规定实型数为正数）。\n大佬大佬看看我，编程题我不会，救救我，求求了，编程有错误", "Tag": "算法分析"}
{"Answer": "select substr(t.code,1,3),sum(times) from table group by substr(t.code,1,3)\r\n\r\n\r\n你的加个点应该是 substr(t.code,1,4)", "Knowledge_Point": "中位数", "Question": "sql 查询同一张表，将一个字段下数值前三位相同的数据统计归为一类？\n比如table表中\n\n字段\n\ncode ，name, times\n\n44.10     dd       5\n\n44.11     da       6\n\n44.21     dc       1\n\n44.22     db       7\n\n\n\n根据code字段下是数值前三位相同的，归为一类。\n\n44.10和44.11归为44.1，并把times相加，即\n\n44.1  11", "Tag": "算法分析"}
{"Answer": "#include <stdio.h>\nvoid Ten2Two(int a)\n{\n   if(a>=2)\n        Ten2Two(a/2);\n    printf(\"%d\",a%2);\n}\nint main()\n{\n      int n,i,a=0,b=0,c,x,y,z;\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n      {\n          scanf(\"%d\",&c);\n          a = a*2+c;\n     }\n    for(i=0;i<n;i++)\n    {\n          scanf(\"%d\",&c);\n          b = b*2+c;\n    }\n    x = a^b;\n    y = a|b;\n    z = a&b;\n    Ten2Two(x);\n    printf(\"\\n\");\n    Ten2Two(y);\n    printf(\"\\n\");\n    Ten2Two(z);\n     printf(\"\\n\");\n    return 0;\n}\n \n\n", "Knowledge_Point": "中位数", "Question": "A 一个简单的位运算，紧急，求援\n题目描述\n有一只蒟蒻在进行位运算，对于两个二进制数x,y，它想要知道x⨁y , x∣y , x&y 分别是多少。\n\n\n注意：本题以及下一题中的 ⨁ 均表示位运算中的异或运算。\n\n\n输入格式\n三行，第一行一个整数n，表示二进制数的位数。\n\n\n第二行和第三行每行n个用空格隔开的数（0 或 1），表示两个二进制数 x,y 的每一位（从高位到低位）。\n\n\n输出格式\n三行，每行一个n位二进制数，分别表示x⨁y , x∣y , x&y 。\n\n\n样例输入\n3\n0 0 1\n1 1 1\n样例输出\n110\n111\n001\n数据范围\nn≤100", "Tag": "算法分析"}
{"Answer": "不知道是不是这个意思\r\n\r\n```\r\n#include   \r\n#include   \r\n#include  \r\n\r\nint holeNum[10] = {\r\n\t1, 0, 0, 0, 1, 0, 1, 7, 2, 1\r\n} ;\r\n\r\nint getHoleNum(char* buff){\r\n\tint res = 0;\r\n\tint len = strlen(buff);\r\n\tfor(int i = 0; i < len; i++){\r\n\t\tres += holeNum[buff[i] - '0'];\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nint main(){\r\n\tint res;\r\n\tint size = 1024;   \r\n    char* buff = (char*)malloc(size);\r\n    \r\n\twhile(true){\r\n\t\tprintf(\"请输入数字:\");\r\n\t\tgets(buff);\r\n\t//\tprintf(\"%s\", buff);\r\n\t\tprintf(\"该数字的洞数共有%d个\\n\", getHoleNum(buff));\t\r\n\t}\r\n\treturn 0;\r\n}\r\n```", "Knowledge_Point": "中位数", "Question": "c语言，打孔问题，求大神指导。\n 题目，s得到一个数，他想知道这个数每一位上的数字的孔数之和，其中，1,2,3,5,7这几个数字是没有孔的，0,4,6,9都只有一个孔，而8有两个孔。\n", "Tag": "算法分析"}
{"Answer": "基本上就是穷举，但是可以加一些基本的推理减少穷举数量，比如可以快速判断dx的尾数一定是a，ax一定小于10，就可以筛除很大一部分数字。然后结果超过四位数了也可以直接排除", "Knowledge_Point": "中位数", "Question": "PTA练习 R7-7 猜数字*\n在下面的算式中，被乘数的 4 位数字 a、b、c、d 各不相同。\n\n\n\n\n显然 a、d都不为0。\n\n\n请编写程序，输入 x，若存在满足条件的算式，则按被乘数由小到大的顺序输出全部答案，否则输出“None”。\n\n\n要求：程序不断输入不同的乘数 x，然后输出对应的结果，直到输入 0 为止。\n输入样例\n\n\n5\n4\n1\n0\n\n\n\n输出样例\n\n\nNone\n\n\n2178\n * \n4\n = \n8712\n\n\nNone\n\n\n\n\n代码长度限制\n16 KB\n时间限制\n400 ms\n内存限制\n64 MB", "Tag": "算法分析"}
{"Answer": "#随机产生10个两位的正整数 存入列表1s中输出1s中的这10个随机数，然后对这10个随机数求平均值然后输出统计高于平均值的数有多少个。\nimport random\nls = []\nsuml = 0\nfor i in range(10):\n    num = random.randint(10,99)\n    suml += num\n    print(num,end=' ')\n    ls.append(num)\navg = suml/10.0\ncount = 0\nfor i in ls:\n    if i > avg:\n        count +=1\nprint(\"平均值：{}\".format(avg))\nprint(\"高于平均值的数有{}个\".format(count))\n\n\n\n", "Knowledge_Point": "中位数", "Question": "一道Python编程问题\n随机产生10个两位的正整数 存入列表1s中输出1s中的这10个随机数，然后对这10个随机数求平均值然后输出统计高于平均值的数有多少个。", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\n\nint main(void) { \n    int x;\n    scanf(\"%d\",&x);\n    int a[1000000];\n    int j=0;\n    while(x){\n        a[j++]=x%2;\n        x/=2;\n    }\n    for(int i=j-1;i>=0;i--){\n        printf(\"%d\",a[i]);\n    }\n    return 0;\n}\n", "Knowledge_Point": "中位数", "Question": "将任意一个十进制转换成二进制数 ，c语言\n将任意一个十进制转换成二进制数 ，并将每位二进制数顺序存放到数组中，然后输出。", "Tag": "算法分析"}
{"Answer": "供参考：\n#include<stdio.h>\n#include<math.h>\nint main()\n{\n    int A,B,C,N;\n    while(1)\n    {\n       printf(\"Input number:\");\n       scanf(\"%d\",&N);\n       if(N < 100 || N >= 1000)\n            continue;\n       else\n            break;\n    }\n    A = N/100; //百位数\n    B = N/10%10;//十位数\n    C = N%10;  //个位数\n    if(A*A*A + B*B*B + C*C*C == N){\n       printf(\"Yes\\n\");\n    }else{\n       printf(\"No\\n\");\n    }\n   \n    return 0;\n}\n\n", "Knowledge_Point": "中位数", "Question": "判断一个数是否为水仙花数\n题要求编写程序，判断一个给定的三位数是否为水仙花数。三位水仙花数，即其个位、十位、百位数字的立方和等于该数本身。\n\n\n输入格式:\n输入在一行中给出一个需要判断的整数 N（100≤N≤999）。\n\n\n输出格式:\n如果N是水仙花数，则在一行中输出Yes，否则输出No。如果N不是三位数，则输出Invalid Value.。", "Tag": "算法分析"}
{"Answer": "当最小值在最后一个位置、最大值在第一个位置的时候，先交换最小值在交换最大值等于没有交换。在for循环之前，p和k需要重置为0代码修改如下：\n#include <stdio.h>\nint main()\n{\n    int a[10];\n    int n,i,max,min,t,p,k,u;\n    scanf(\"%d\",&n);\n    scanf(\"%d\",&a[0]);\n    max=a[0];\n    min=a[0];\n    p = 0;\n    k = 0;\n    for (i=1;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        if(max<a[i])\n        {\n            max=a[i];\n            p=i;\n        }\n        if(min >a[i])\n        {\n            min=a[i];\n            k=i;\n        }\n    }\n    if(p==0 && k==n-1) //最大值在第一个位置，最小值在最后一个位置\n    { //交换一次即可\n        t = a[p];\n        a[p]=a[k];\n        a[k]=t;\n    }else if(p==0) //最大值在第一个位置\n    {\n        //先把最大值放在最后\n        u=a[p];\n        a[p]=a[n-1];\n        a[n-1]=u;\n        //然后在把最小值放在最开始\n        t=a[k];\n        a[k]=a[0];\n        a[0]=t;\n    }else if(k == n-1) //最小值在最后一个位置(这个跟最后的else合并也可以)\n    {\n        //先把最小值放在开头\n        t=a[k];\n        a[k]=a[0];\n        a[0]=t;\n        //然后在把最大值放在末尾\n        u=a[p];\n        a[p]=a[n-1];\n        a[n-1]=u;\n    }else\n    {\n        t=a[k];\n        a[k]=a[0];\n        a[0]=t;\n        u=a[p];\n        a[p]=a[n-1];\n        a[n-1]=u;\n    }\n    \n    for(i=0;i<n;i++)\n        printf(\"%d \",a[i]);\n    return 0;\n}\n\n", "Knowledge_Point": "中位数", "Question": "将数组中最大值与最后一个值交换，最小值与第一个数交换\n哪位大佬帮我看一下这个程序，为什么先让最大值与最后一个数交换就可以实现这个程序目的，而先交换最小值却不可以\n\n\n\n", "Tag": "算法分析"}
{"Answer": "n=int(input('请输入一个正整数:'))\r\nx=list(range(1,n+1,2))\r\nx=str(x)\r\nnum=x.count('3')\r\nprint(num)", "Knowledge_Point": "中位数", "Question": "输入任意一个正整数，从1开始到这个数字的奇数序列里，统计一共出现了多少个3。\n编写函数，实现功能是，输入一个正整数，返回该数中3出现的个数。", "Tag": "算法分析"}
{"Answer": "if(a==5)，不是if(a=5)", "Knowledge_Point": "中位数", "Question": "计算100-110中有几个数的个位十位百位只和为5\n求解，为啥计算最后的结果不对😭😭\na的值为啥总是为5，导致结果错误❌\n\n\nps：想写：100到110中，有几个数的个位十位百位只和为5", "Tag": "算法分析"}
{"Answer": "【若能有所悟，望给个采纳，谢谢】1、enumerate：这个是与for循环配合实用，用于遍历数据对象（列表、元组或字符串均可）2、for i,j enumerate(x)这里的i=指的是数组的下标值，j=指的是下标值对应的值3、T=x[i+1:]意思就是从数组下标i+1开始，取出所有数组值1）比如：[1,2,3,4,5] > [1:] > [2,3,4,5]4、if T==[]:就是已经取完了数组值，退出循环5、x[i]>min(T)意思就是，用1值和min([2,3,4,5])最小的值比较，就是1和2比较如果1>2，则进行值得交换，否则不进行交换，继续下一个循环6、t=x.index(min(T))[3,1,2,4,5] > [x,1,2,4,5]3>1，条件满足，则将3赋值到t变量t=x=[3,1,2,4,5].index(min(T)) > [3,1,2,4,5].index(min([1,2,4,5])) 》[3,1,2,4,5].index(min(1)) 》[3,1,2,4,5].index(1)意思就是1在数组[3,1,2,4,5]中得下标位置是1也就是t=17、x[i],x[t]=x[t],x[i]x[i]=x[t] 》x[0]=x[1]，x[1]=x[0]就是相互交换完成值小的在前面，值大的在后面，就是所谓的升序排序", "Knowledge_Point": "中位数", "Question": "python 随机生成10个数并升序排序 升序排序的那部分代码不太明白 想知道是怎么实现的\n\nimport random\nA=\n[]\n\n\nfor\n \ni\n \nin\n range(\n10\n):\n    A\n.append\n(random\n.randint\n(\n0\n,\n100\n))\n\nprint\n(A)\n\nx=A\n\nfor\n \ni\n,j \nin\n enumerate(x):#从这往下就看不懂了\n    T=x\n[i+1:]\n\n    \nif\n T==\n[]\n:\n        break\n    \nif\n x\n[i]\n>min(T):\n        t=x\n.index\n(min(T))\n        x\n[i]\n,x\n[t]\n=x\n[t]\n,x\n[i]\n\n\nprint\n(A)\n\n\n\n\npython 随机生成10个数并升序排序 升序排序的那部分代码不太明白 想知道是怎么实现的\n谢谢大家！", "Tag": "算法分析"}
{"Answer": "```\r\n 一个俄罗斯方块可以在一个4x4的形状中表示\r\n比如\r\nI型\r\n.xxx\r\n.xxx\r\n.xxx\r\n.xxx\r\nL形\r\n.xxx\r\n.xxx\r\n..xx\r\nxxxx\r\n\r\nT形\r\n...xx\r\nx.xx\r\nx.xx\r\nxxxx\r\nZ形\r\n..xx\r\nx.xx\r\nx..x\r\nxxxx\r\n方块形\r\nxxxx\r\nx..x\r\nx..x\r\nxxxx\r\n等等\r\n\r\n每个点有图像，无图像两个状态可以用0 1表示。\r\n所以可以用一个16位的二进制数表示一个俄罗斯方块的形状。每个二进制位表示一个坐标。\r\n```", "Knowledge_Point": "中位数", "Question": "俄罗斯方块中的进制数\n我是一个菜鸟，我想知道为什么俄罗斯方块游戏中要用一个十六进制数表示一个俄罗斯方块，而且为什么十六进制数可以转换成二进制是数组形式", "Tag": "算法分析"}
{"Answer": "\n\nwhile True:\n    pwd = input(\"输入密码\")\n    if len(pwd) < 6:\n        print(\"密码长度必须大于6， 请重新输入密码\")\n    elif pwd == '123456':\n        break\n    else:\n        print(\"密码错误， 请重新输入密码\")\n\n", "Knowledge_Point": "中位数", "Question": "Python用while true判断一个密码是否为6个字符串的正确密码123456\n编写出来的程序输入正确密码123456之后还是提示密码不正确，不懂是哪里出错了", "Tag": "算法分析"}
{"Answer": "void main()\r\n{\r\n\tint M,N;\r\n\r\n\tint nub;\r\n\r\n\tint tmp1,tmp2 = 0;\r\n\r\n\t//键盘输入M,N的值\r\n\tprintf(\"请输入M,N的值：\\n\");\r\n\tscanf(\"%d%d\" , &M,&N);\r\n\r\n\tfor(tmp1 = M;tmp1 < N;tmp1++)\r\n\t{\r\n\t\tif((tmp1 % 3 == 0) && (tmp1 % 5 == 0))\r\n\t\t{\r\n\t\t\ttmp2++;\r\n\t\t\tprintf(\"%d\\n\" , tmp1);\r\n\t\t}\r\n\t}\r\n\r\n\tprintf(\"%d到%d之间能3和5同时整除的整数个数为：\",M,N);\r\n\tprintf(\"%d\\n\",tmp2);\r\n}\r\n\r\n运行示例：\r\n请输入M,N的值：\r\n3 100\r\n15\r\n30\r\n45\r\n60\r\n75\r\n90\r\n3到100之间能3和5同时整除的整数个数为：6", "Knowledge_Point": "中位数", "Question": "C语言：编程计算[M,N]之间所有能被3和5同时整除的整数个数。其中，0<M<N。？\n编程计算[M,N]之间所有能被3和5同时整除的整数个数。其中，0<M<N。", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>#include<math.h>int main() {  int y[50],i,min;  int qmin(int y[]);  for(i=0;i<50;i++)    y[i]=600*sin(i*0.16);  min=qmin(y);  printf(\"min=%d\",min);  return 0;}int qmin(int y[])  {int min,i,j;   min=y[0];  for(i=0;i<50;i++)   {if(min>y[i])min=y[i];}  return min;}", "Knowledge_Point": "中位数", "Question": "编写函数找出数组中的最小数\n求一维整型数组中的最小元素。要求：主函数定义数组y[50]，y[j]=600\nsin(j\n0.16) (j=0,1,2…49)，调用自定义函数qmin求出最小元素，最后在主函数中输出结果。要求必须使用 for语句实现。\n输入用例\n无\n输出用例\nmin=-598", "Tag": "算法分析"}
{"Answer": "第一幅图上a,b是字符数组。char a[8]=\"0100\";", "Knowledge_Point": "中位数", "Question": "二进制数是在数组中怎么储存的？\n刷力扣时遇到的问题：\n1.这些二进制数在数组中是怎么存放的\n2.根据第一幅图，用C语言怎么写int main()部分，就是怎么写定义a，b", "Tag": "算法分析"}
{"Answer": "import java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\nclass StringTest{\r\n        public static void main(String[] args){\r\n           new StringTest().testRegex();\r\n        }\r\n\tpublic void testRegex(){\r\n\t\tString str=\"1-4级份开始到福建卡的师傅2-8级份开始到5福建卡的师傅9-14级份开始到福建卡的师傅$\";\r\n\t\tString reg = \"(\\\\d+-\\\\d+级)\";\r\n\t\tString[] marches = this.findMarch(str, reg);\r\n                System.out.println(\"Find:\"+marches.length);\r\n\t}\r\n\t\r\n\tprivate String[] findMarch(String str,String reg){\r\n\t\tPattern pattern = Pattern.compile(reg);\r\n\t\tMatcher matcher = pattern.matcher(str);\r\n\t\tList list = new ArrayList();\r\n\t\twhile(matcher.find()){\r\n\t\t\tSystem.out.println(matcher.group(1));\r\n\t\t\tlist.add(matcher.group(1));\r\n\t\t}\r\n\t\tString[] marches = new String[list.size()];\r\n\t\tfor(int i=0; i<list.size(); i++){\r\n\t\t\tmarches[i] = list.get(i);\r\n\t\t}\r\n\t\treturn marches;\r\n\t}\r\n}", "Knowledge_Point": "中位数", "Question": "Java的正则表达式请教\n我现在要实现下面的功能； \n\nString s=\"1-4级份开始到福建卡的师傅2-8级份开始到5福建卡的师傅9-14级份开始到福建卡的师傅$\"; \n\n\n\n提取1-4级，2-8级等等这样的字段，放在一个数组中 \n\neg；string[] ss=.....; \n\n    ss[0]=1-4级; \n\n             ss[1]=2-8级; \n\n             等等 \n\n\n\n用Java语言写，最好用Java自带的正则表达式库； ", "Tag": "算法分析"}
{"Answer": "把int改为bigint，int怎么可能会显示100位呢？int是4个字节，2^32次方最大表示数字4294967295，也就显示10位数，你想表示12位数就得bigint，有8个字节，bigint可以最大表示20位，也只需要bigint(20)即可", "Knowledge_Point": "中位数", "Question": "MySQL在Navicat Premium中的建表数字长度\n我在用Navicat Premium建MySQL数据表的过程中，设计表已经建好，但是当我填表的数据时显示我的数字长度不够，只有九位数字长度，但我需要十二位。\n改了选项自动递增也不行，恳请各位帮我看一下到底是哪里出了问题。\n\n", "Tag": "算法分析"}
{"Answer": "乘以100，强制转int，再除以100或者使用floor函数", "Knowledge_Point": "中位数", "Question": "在C语言中如何得到一个实数并且保留小数点后两位，但不是四舍五入。\n在C语言中如何得到一个实数并且保留小数点后两位，但不是四舍五入。\n比如7.065，要的是7.06而不是7.07.\n试过用%.2f，得到的是7.07", "Tag": "算法分析"}
{"Answer": "System.Diagnostics.Process.Start(\"另一个exe的路径文件名.exe\");", "Knowledge_Point": "树中的独立集", "Question": "wpf应用程序中如何实现点击某个按钮，打开另一个独立的wpf程序\n如题，需要在一个wpf程序中实现点击按钮，打开另一个独立的WPF程序，wpf程序的地址是已知的，且两个程序间不需要关联操作，只需要打开即可。", "Tag": "算法分析"}
{"Answer": "回答还可以的话 ，还请 采纳：在使用独立显卡的情况下，屏幕显示可能会占用一部分显存，但这不会对深度学习的性能造成重大影响，因为独立显卡通常有更多的显存。如果显存不够，可以考虑升级独立显卡或者使用多块独立显卡。", "Knowledge_Point": "树中的独立集", "Question": "Python深度学习的时候屏幕显示线插在独立显卡还是集成显卡好？\nPython深度学习的时候屏幕显示线插在独立显卡还是集成显卡好？插在独立显卡上会不会导致屏幕占用一部分的显存？", "Tag": "算法分析"}
{"Answer": "\nYou need to : \n\nChange your partial file to generate the HTML for only one payroll (fiche).\nUpdate your code\n\nExample\n$mpdf = new mPDF(); \n$mpdf->SetDisplayMode('fullpage'); \n\nforeach ($recuperationFiche as $i => $fiche) {\n\n    if($i) { //If not the first payroll then add a new page\n        $mpdf->AddPage();\n    }\n    $html = $this->view->partial(\n        'fiche/telechargerfiche.phtml', \n        array('fichep' => $fiche)\n    );\n    $mpdf->WriteHTML($html);\n\n}\n\n$mpdf->SetHTMLFooter( \"\" ); \n$mpdf->Output(); \nexit;\n\nHope it helps\n", "Knowledge_Point": "树中的独立集", "Question": "MPDF：多页中的独立信息\n\n\n\nI actually use MPDF in order to show my HTML code on a PDF.\nThe problem that I have a lot of  payroll employees , and I want to make each payroll on a page.\nThis code works well. \n\n\n\n        $html  = $this->view->partial('fiche/telechargerfiche.phtml',\n            array('fichep' => $recuperationFiche));\n\n    $mpdf=new mPDF();\n    foreach ($recuperationFiche as $fiche) {\n\n    $mpdf->SetDisplayMode('fullpage');\n    $mpdf->WriteHTML($html);\n    $mpdf->SetHTMLFooter(\"\") ;\n    $mpdf->Output();\n    exit;\n\n\n\n\nBut the problem is that my payrolls is shown successively in the same page.\nNow I want to make each payroll on an independant page .\nI have to use a foreach , but I don't know where is the error , because it's shown to me the same result :\n\n\n\n        $html  = $this->view->partial('fiche/telechargerfiche.phtml',\n            array('fichep' => $recuperationFiche));\n\n    $mpdf=new mPDF();\n    foreach ($recuperationFiche as $fiche) {\n\n    $mpdf->SetDisplayMode('fullpage');\n    $mpdf->WriteHTML($html);\n    $mpdf->SetHTMLFooter(\"\") ;\n    $mpdf->Output();\n    exit;\n    }\n\n\n    ", "Tag": "算法分析"}
{"Answer": "\nYou can transfer JSON encoded HTML newlines like this:\n$return['message'] = 'First Entry: ' . $_POST['Name1'] . '<br /> '  . 'Second Entry: ' .    $_POST['Name2'] . '<br /> ' . 'Third Entry: ' . $_POST['Name3'];  \necho json_encode($return);\n\nOr convert newlines (\n) into newline tags. \nThe nicer way though would be to leave that kind of processing to the client by e.g. returning an array of messages:\n$return['message'] = array();\n$return['message'][] = 'First Entry: ' . $_POST['Name1'];\n$return['message'][] = 'Second Entry: ' . $_POST['Name2'];\n$return['message'][] = 'Third Entry: ' . $_POST['Name3'];\necho json_encode($return);\n\nAnd leave the processing to the client (maybe the client wants the messages wrapped in a paragraph tag later on):\nfunction(data)\n{\n    $('<div id=\"output2\"></div>').insertAfter($('#agreement-information'));\n    $('#output2').html(data.message.join('<br />')).show(500);\n    $('#ouput2').append(data);  \n}\n\n", "Knowledge_Point": "树中的独立集", "Question": "如何使用jQuery和PHP在单独的行上显示JSON响应\n\n\n\nI am using AJAX to submit a form, and would like to display a summary of the information on the page so that the user can confirm the information before submitting. I am having trouble getting the results to display on multiple lines. Any suggestions on the best way to do this? \n\n\n\nHere is the PHP:\n\n\n\n$return['message'] = 'First Entry: ' . $_POST['Name1'] . ' '  . 'Second Entry: ' .    $_POST['Name2'] . ' ' . 'Third Entry: ' . $_POST['Name3'];  \n\necho json_encode($return);\n\n\n\n\nHere is the jQuery:\n\n\n\n$(\"#mark-form\").validate({\n    submitHandler: function(form) {\n            $(form).ajaxSubmit({                  \n                type: \"POST\",\n                data: {\n                    \"Name1\" : $('#Name1').val(),\n                    \"Name2\" : $('#Name2').val(),\n                    \"Name3\" : $('#Name3').val()\n                       },\n                dataType: 'json',\n                url: './includes/ajaxtest3.php',\n                error: function() {alert(\"Error\");},\n                success: \n                function(data) {\n                    $('').insertAfter($('#agreement-information'));\n                    $('#output2').html(data.message).show(500);\n                    $('#ouput2').append(data);  \n                },       \n  });\n\nreturn false;   \n   },\n        errorPlacement: function(error,element) {\n                        return true;\n                },\n        rules: {\n            \"Name1\": {\n                required: true,\n                }\n        }       \n});\n\n\n    ", "Tag": "算法分析"}
{"Answer": "所谓递归，其实人类是做不到的，因为递归嵌套多了，人就乱了，有点像是盗梦空间里的深层梦境limbo，到那就几乎回不到现实了。\r\n但是计算机不像人类想法那么多，尤其是基于过程的设计，你教我怎么走我就怎么走，不会混乱，但是你得给我定个边界条件，要不我还是回不来。\r\n汉诺塔的确是一个经典的递归问题，而人类做的最伟大的一步在于，把f(n)的问题转化为f(n-1)，推本溯源，总要找到一个origin起始点（也是结束点）。\r\n在这方面，计算机做的比人类强太多。然而，编程的时候，写递归还是挺痛苦的，主要在于边界条件设置要很小心，错了程序就傻傻地一去不复返啦！\r\n至于理解一系列递归问题，先百度，再谷歌，多找几个范例~", "Knowledge_Point": "树中的独立集", "Question": "汉诺塔是怎么思考出来的\n本人菜鸟，看到这个算法的时候觉得好巧妙，但是自己怎么也想不出来啊。。。", "Tag": "算法分析"}
{"Answer": "\nBranches are for organizing different aspects of development on a project.  \nFor example:\nYou have your framework working.  You decide that you want to reorganize the code for a new feature or want to work on a feature that you aren't sure about releasing.  So you create a branch and work on it there.  Meanwhile, you find that your framework has a bug in it.  You are able to go back to the original branch, create the bug fix and release that.  \nYou can have multiple avenues of development going on at the same time keeping them separate until you are ready to do something with them.\nThe use case that you are talking with an app and a framework would be to have seperate repositories for those.  Rather than branching.  \n", "Knowledge_Point": "树中的独立集", "Question": "Git分支帮助/建议\n\n\n\nI think I'm not quite grasping the reason behind branches in Git.\n\n\n\nI'm developing an application which makes use of a framework.\n\n\n\nCould I run two branches one with the app and another branch for the framework? Or should I branch away when I want to update the framework, fix any possible bugs and then merge it back in?\n\n\n\nThanks!\n\n    ", "Tag": "算法分析"}
{"Answer": "\nCreate a javascript either function or add it directly to the submit button.\n<input type='button' value='submit' onClick=\"document.formName.submit()\" >\n\n-- or --\n<a href=\"javascript:document.formName.submit();\">Click Here</a>\n\n", "Knowledge_Point": "树中的独立集", "Question": "独立表单提交按钮\n\n\n\nI've a form and I've a submit button in it.\n\n\n\nWhat I want is to place the submit button outside the  tag (because of design issues) but still want to be able to submit the form when I click on it.\n\n    ", "Tag": "算法分析"}
{"Answer": "加个while循环，然后在choice == 1时候弄个break；，==2时候不做跳出就行了\r\n\r\n```\r\n while（true）\r\n {\r\n\t\t\tif(choice == 1)\r\n\t\t\t{\r\n\t\t\t\t//相关操作\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse if(choice == 2)\r\n\t\t\t{\r\n\t\t\t\t//显示学生信息\r\n\t\t\t}\r\n\t\t\tif(choice == 3)\r\n\t\t\t{\r\n\t\t\t\t//相关操作\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n }\r\n```", "Knowledge_Point": "树中的独立集", "Question": "C语，如何将choice 2 循环独立出来？\n目标是如果choice=2，那么显示学生信息后再一次让用户输入选择并运行所选选项，目前如果第一次是2，这个if中就没有下文了，怎么才能让它正确循环？", "Tag": "算法分析"}
{"Answer": "cloudyzhao所说方案实现简单有效，此处列一个基础的写法，不依赖正则库\r\n    s = \"Abc34g8\"\r\n\t\tresult = 0\r\n\t\ti = 0\r\n\t\twhile  i < len(s):\r\n\t\t    tmp_num = 0\r\n\t\t\t\twhile i < len(i) and s[i] >= '0' and s[i] <= '9':\r\n\t\t\t\t    tmp_num = tmp_num*10 + int(s[i])\r\n\t\t\t\t\t\ti += 1\r\n\t\t\t\ti+= 1\r\n\t\t\t\tresult += tmp_num\r\n\t\tprint(result)", "Knowledge_Point": "树中的独立集", "Question": "Python：字符串中数字求和\n1.输入一个字符串，取出这个字符串中所有的数字并求和。每个数字都是*独立的，*不连续。\n\n现在只知道如何提取字符串中的数字\n\n例：s=‘Abc34g8’\n\n         for I in s：\n\n                I.isdigit()\n\n或者      for I in s\n\n                if I in [1,2,3,4,5,6,7,8,9]\n\n但是如何让提取出来的数字按照要求相加呢？   按照这种方法结果应是：15\n\n 2.输入一个字符串，取出这个字符串中所有的数字并求和。其中相邻的数字是*连续*的的。    按照这种方法结果应是：42\n\n 问如何求和？", "Tag": "算法分析"}
{"Answer": "\nAdd the include header from the wordpress's site.\n<?php\n    define('WP_USE_THEMES', false);\n    require('wp-blog-header.php');\n?>\n\n", "Knowledge_Point": "树中的独立集", "Question": "如何从单独的PHP文件访问当前登录的Wordpress用户？\n\n\n\nI have a simple separate PHP page hosted in the same directory as my Wordpress blog. This page is standalone so it knows nothing of Wordpress, but will of course receive the same cookies since it's on the same host.\n\n\n\nThe question is simple: \nHow do I access the logged in Wordpress user's ID from this standalone page?\n \n\n\n\nI know you can access logged in user data via \nget_currentuserinfo\n, but that assumes you're running within Wordpress. How do I access this info on a PHP page that isn't delivered from Wordpress, but is on the same host?\n\n    ", "Tag": "算法分析"}
{"Answer": "你问的是C语言标准库吧？标准库是可以和编译器分开的，甚至不同的编译器还可以使用同一个标准库，但是编译器一般都自带标准库，因为没有标准库，你连基本的输入输出都很难实现。", "Knowledge_Point": "树中的独立集", "Question": "C语言中的头文件到底存放在哪?\nC语言中的头文件有的人说存在于编译器中.我想知道头文件是编译器的一部分呢？还是互不相干.独立存在?", "Tag": "算法分析"}
{"Answer": "作为未入行的阶段，还是以找工作为前提，不建议前期做大量的学习，这样会消耗时间和耐心，三大件掌握之后，搞清楚ajax，会使用Vue，就可以准备面试题，面试，找到一份工作之后，再查缺补漏，可以根据业务需要作为学习导向，也可以按照兴趣，学学node或者一些桌面端，移动端的拓展，nginx之类的服务器配置，了解mysql，mongoDB", "Knowledge_Point": "树中的独立集", "Question": "前端按照实际工作的标准，需要达到什么样的水平，包括技术栈\n有兴趣的可以互相沟通了解一下哦！希望能够帮助到正在学习前端的朋友们", "Tag": "算法分析"}
{"Answer": "\nThe $size parameter of the array_chunk function is actually the number of items in each chunk, not the number of chunks. In order to get three, you should first calculate the number of items in each chunk by dividing the size of the array by 3 and then using that count, rounded up, in the array_chunk function. And when you iterate over the array, you need a nested loop to output each list item of each column.\nLike this:\n<?php\n\n$ar_list = array(\"<li>Item 1</li>\",\"<li>Item 2</li>\",\"<li>Item 3</li>\",\"<li>Item 4</li>\",\"<li>Item 5</li>\");\n$rows = ceil(count($ar_list) / 3);\n$lists  = array_chunk($ar_list, $rows);\n\nforeach ( $lists as $column) {\n    echo '<ul>';\n    foreach ($column as $item) {\n        echo $item;\n    }\n    echo '</ul>';\n}\n\n", "Knowledge_Point": "树中的独立集", "Question": "PHP将数组拆分为3个独立的UL和列\n\n\n\nI am having trouble working out the logic for what I need to achieve \n\n\n\nOn the web page I have a dynamically generated array from a set of results. The array count can be any number. For example on one page there could be 11 items whereas on another 211.\n\n\n\nWhat I need is to split this into 3 columns and 3 UL's. \n\n\n\nLets say the array holds 23 items, The desired output would be: \n\n\n\n    \n\nItem 1\nItem 2\nItem 3\nItem 4\nItem 5\nItem 6\nItem 7\nItem 8\n\n\n\n\nItem 9\nItem 10\nItem 11\nItem 12\nItem 13\nItem 14\nItem 15\nItem 16\n\n\n\n\nItem 17\nItem 18\nItem 19\nItem 20\nItem 21\nItem 22\nItem 23\n\n\n\n\n\n\nWhere the items are in order, and they are split as equally as possible. If there is an odd number, that is fine as the last column will be less as shown above.\n\n\n\nI have tried using the array_chunk()\n\n\n\n$ar_list = array(\"Item 1\",\"Item 2\",\"Item 3\",\"Item 4\",\"Item 5\");\n$lists = array_chunk($ar_list, 3);\n\n\n\nforeach ($lists as $list) {\n  echo '';\n  echo $list;\n  echo '';\n}\n\n\n\n\nHowever, this returns: \n\n\n\n\n  \nArray\n\n  \n  \nArray\n\n  \n  \nArray\n\n  \n  \nArray\n\n  \n  \nArray\n\n\n\n\n\nCan someone please help me get the contents of: $ar_list to output like the desired effect?\n\n\n\nThank you in advance\n\n    ", "Tag": "算法分析"}
{"Answer": "你好同学，给你编了一个专属函数ecdf2：\nfunction [X, Y, CDF] = ecdf2(x,y,nx,ny,xminmax,yminmax)\n% x：x的值\n% y：y的值\n% nx：x方向划分段数\n% ny：y方向划分段数\n% xminmax = [xmin, xmax]\n% yminmax = [ymin, ymax]\nnum = length(x);\nif(num~=length(y))\n   error('输入的x和y长度必须相等') \nend\nif(nargin>6) % 如果变量个数大于6个，太多了\n    error('太多输入变量')\nelseif(nargin<2) % 如果变量个数小于2个，太少了\n    error('输入变量数目不足!!')\nend\nif(nargin==6) % 如果变量个数等于6个，赋值给ymin和ymax\n    ymin = yminmax(1);\n    ymax = yminmax(2);\nend\nif(nargin>=5)% 如果变量个数大于等于5个，赋值给xmin和xmax\n    xmin = xminmax(1);\n    xmax = xminmax(2);\nend\nif(nargin<=4)% 如果变量个数小于等于4个，自定义xmin和xmax\n    xmin = min(x);\n    xmax = max(x)+eps;\n    ymin = min(y);\n    ymax = max(y)+eps;\nend\nif(nargin<=3)% 如果变量个数小于等于3个，自定义y方向划分段数ny\n    ny = 30;\nend\nif(nargin==2)% 如果变量个数等于2个，自定义x方向划分段数nx\n    nx = 30;\nend\nxg = linspace(xmin, xmax, nx);%x方向的点\nyg = linspace(ymin, ymax, ny);%y方向的点\n[X,Y] = meshgrid(xg, yg);%形成网格\n[I,J] = meshgrid(1:nx, 1:ny);%下标网格\nCDF = arrayfun(@(i,j)sum(x<X(i,j)&y<Y(i,j))/num,I,J);%形成经验分布\nend\n\n然后调用就行：\nclc;clear\nnum = 1000000;\nx = randn(num,1);% 为了说明弄了两个正态分布搞联合，实际数据会更好\ny = randn(num,1);\n[X, Y, CDF] = ecdf2(x,y);% ,50,50,[-3, 3],[-3, 3]\nsurf(X,Y,CDF)\n\n可以看到效果杠杠的：\n", "Knowledge_Point": "树中的独立集", "Question": "matlab中，有一组二维数据，如何绘制三维的联合经验分布函数图\n如果是一维数据X，就能直接用[f,x] = ecdf(X)来绘制经验分布函数图，但如果是二维的数据数据[X,Y]，要如何绘制二维数据的三维联合经验分布函数图。最开始我是直接分别算ecdf 得到两个f和x，y。结果的x，y做X轴Y轴的值，两个f相乘做Z轴。代码如下，绘制的图比较相近。\n但是我问了下导师，我这种求法前提是X和Y是相互独立的。我的数据[X Y]中的X和Y不是独立的，不能简单地分别用ecdf来求然后概率相乘。想问下大神们，一组二维数据，要如何绘制三维的联合经验分布函数图\n\n\nZ\n=xlsread('Linton3.xlsx')\n\nX\n=Z(:,1);\n\nY\n=Z(:,2);\n[f1,x] = ecdf(X);\n[f2,y] = ecdf(Y);\n[XX,YY]=meshgrid(x,y);\n[ff1,ff2]=meshgrid(f1,f2);\n\nZZ\n=ff1.*ff2\nsurf(XX,YY,ZZ,\n'EdgeColor'\n,\n'none'\n);\n\n\n", "Tag": "算法分析"}
{"Answer": "收银机一般来说安装的也是windows操作系统，也有用android的（早期有dos/wince的，现在应该都淘汰了）\r\n所以可以安装一个你编写的软件，看它本地的数据库的格式，一般也没有加密，读取然后同步出来即可。", "Knowledge_Point": "树中的独立集", "Question": "关于在收银机上获取数据的问题。\n需求及场景:\n\n在各种收银机上收款,想在另一个系统中记录收银数据(支付方式:支付宝/微信/银联 ;收款金额 等)\n\n问题:\n\n这种问题要怎么解决呀,收银机是独立的,在不对接或者更改收银机系统的情况下怎么能解决这个问题呀.\n\n\n\n感谢各位大佬了!!!", "Tag": "算法分析"}
{"Answer": "使用事件：在界面软件中用 CreateEvent 创建一个命名事件，然后用Winexec或者ShellExecuteEx打开接收软件。在接收软件中用 OpenEvent （传入 CreateEvent 创建的事件名称）打开在界面软件中已经创建了的事件。接收完成后，设置该事件信号，界面软件即可知道已经完成接收。", "Knowledge_Point": "树中的独立集", "Question": "vc6.0如何在工程内调用另一个工程\n就是说我有两个独立的工程，一个是系统界面软件，一个是接收数据的软件。我想要在系统界面中点击一个按钮打开接收数据的软件，并且在接收完成后再系统界面上显示下载完成。看到网上虽然可以在系统界面软件按钮处用Winexec或者ShellExecuteEx打开接收软件进行接收，但是不知道接收软件要怎么在下载完成后给系统界面一个返回值，用来执行显示下载完成，要在系统界面显示下载完成。\n\n还有一个办法就是合并，不过不知道具体怎么操作，是把Source Files，Header Files，Resource Files的文件都添加到界面软件代码中吗？我是新手，还请多多指教。", "Tag": "算法分析"}
{"Answer": "public class Student {\n    private String name;\n    private int age;\n    private boolean isMale;\n    private int score;\n    public Student(String name,int age,boolean isMale,int score){\n        this.name=name;\n        this.age=age;\n        this.isMale=isMale;\n        this.score=score;\n    }\n    public void show(){\n        System.out.println(name+\",\"+age+\",\"+(isMale?\"女\":\"男\")+\",\"+score);\n    }\n}\n", "Knowledge_Point": "树中的独立集", "Question": "【问题描述】定义一个学生类Student\n【问题描述】定义一个学生类Student，其中包括4个成员变量：姓名name，年龄age，性别isMale，成绩score；一个带4个参数的构造方法用来创建学生对象，一个实例方法show()用来将学生的姓名、年龄、性别和成绩独立地显示在一个行中（每个信息之间用英文状态的逗号隔开，输完成绩后要求换行，输出样例：李明，15岁，女，100 分）。再定义一个演示类Test，在其中输入10个学生的信息，并将创建的学生对象保存到数组stu中，然后遍历数组，找到成绩最高和最低的学生，调用show方法将他们的信息显示出来。\n\n\n【输入形式】10个学生的姓名、年龄、性别和成绩\n\n\n【输出形式】成绩最高和最低的学生信息（如有并列的，只输出下标较小的那个学生的信息），注意：其中冒号为中文状态，逗号为英文状态\n\n\n【样例输入】\n\n\nFANG  15  false   98\nLEE    14  true    84\nWANG    15  true    90\nSUN  15  false   86\nQIAN  16  false   76\nLI  15  false   100\nGU  14  true    86.5\nXU  15  true    60\nLIANG  15  true    99\nAN  14  true    80\n【样例输出】\n\n\nMAX:LI,15,FEMALE,100.0\nMIN:XU,15,MALE,60.0", "Tag": "算法分析"}
{"Answer": "进程是一种特殊的线程。进程的资源是独享的，线程则共享所属进程的资源。", "Knowledge_Point": "树中的独立集", "Question": "Java编程进程和线程的区别？\n进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。\n线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。\n一个程序至少一个进程，一个进程至少一个线程。", "Tag": "算法分析"}
{"Answer": "一个项目里程序只认一个main()函数，这是程序运行的起点", "Knowledge_Point": "树中的独立集", "Question": "为什么codeblocks同一个项目里一直运行上一个程序，无法运行第二个\n为什么codeblocks同一个项目里一直运行上一个程序，无法运行第二个，怎么独立运行多个程序", "Tag": "算法分析"}
{"Answer": "你参考一下吧。\r\n\r\n```\r\n HWND hFig1 = ::FindWindow(NULL,“对话框1名称”);\r\n HWND hFig2 = ::FindWindow(NULL,“对话框2名称”);\r\n \r\n \tRECT Rect1; // 获取位置和大小\r\n\tCWnd *pArea1 = (CWnd*)FromHandle(hFig1);\r\n\tpArea1->GetWindowRect(&Rect1); \r\n\tlong Width = Rect1.right - Rect1.left;\r\n\tlong Height = Rect1.bottom - Rect1.top;\r\n::SetWindowPos(hFig,NULL,1,1,Width-3,Height+25,SWP_NOZORDER | SWP_NOACTIVATE);\r\n \r\n```", "Knowledge_Point": "树中的独立集", "Question": "MFC中对话框如何用函数实现可以调整位置？\n有两个对话框，都在主窗口的右下角想要的效果是两个对话框不重叠，一个在另一个的上面显示，但是我做出来都重叠了！！想问一下如何调整对话框位置并用函数实现调整？菜鸟在这谢谢了如图", "Tag": "算法分析"}
{"Answer": "AutoJsPro，它好像是通过Android手机的无障碍服务实现的，不过有些页面和app，可能无法通过无障碍服务获取页面UI元素控件，但是可以去尝试，毕竟有js，也很方便编写代码。\n可以脱离电脑的APP:Action BlocksAutomateAutomateItIFTTTMacroDroidTaskerMany individual appsSmart home appsOEM features like BixbyYour Android settings\n希望采纳", "Knowledge_Point": "树中的独立集", "Question": "手机自动化脚本框架有哪些?\n目前主流, 可以脱离电脑在手机上独立自动运行的脚本框架有哪些?\nAutoJsPro怎么样?\n谢谢!", "Tag": "算法分析"}
{"Answer": "明确的说, 是不行的, 它的GPU加速本质上底层用的CUDA, 而CUDA必须基于NVIDIA 显卡/GPU, 目前你的Mac上应该没有NVIDIA显卡", "Knowledge_Point": "树中的独立集", "Question": "macOS 可以使用Numba实现GPU加速运算吗？\nmacOS 可以使用Numba实现GPU加速运算吗？希望做机器学习或者深度学习的时候可以用上mac的独立gpu。", "Tag": "算法分析"}
{"Answer": "html\r\n\r\n```\r\n \n\n\n\r\n```\r\n\r\n\r\njs\r\n\r\n```\r\n $(\"#div1\").mouseenter(function(e){\r\n    \t\t\t$(\"#div2\").slideDown(500);\r\n    \t\t\t$(\"#div1\").mouseleave(function(e){\r\n    \t\t\t\tvar array = new Array();\r\n    \t\t\t\tarray.push($(\"#div1\")[0]);\r\n    \t\t\t\tarray.push($(\"#div2\")[0]);\r\n    \t\t\t\tvar flag = checkIn(e,array)\r\n    \t\t\t\tif (!flag) {\r\n    \t\t\t\t\t$(\"#div2\").slideUp(500);\r\n    \t\t\t\t}\r\n    \t\t\t});\r\n    \t\t\t$(\"#div2\").mouseenter(function(e){\r\n    \t\t\t\t$(\"#div2\").mouseleave(function(e){\r\n    \t\t\t\t\tvar array = new Array();\r\n    \t\t\t\t\tarray.push($(\"#div1\")[0]);\r\n    \t\t\t\t\tarray.push($(\"#div2\")[0]);\r\n    \t\t\t\t\tvar flag = checkIn(e,array)\r\n    \t\t\t\t\tif (!flag) {\r\n    \t\t\t\t\t\t$(\"#div2\").slideUp(500);\r\n    \t\t\t\t\t}\r\n    \t\t\t\t});\r\n    \t\t\t});\r\n    \t\t});\r\n            function checkIn(e,objs){\r\n            \ttry {\r\n            \t\tconsole.log(objs.length);\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\talert(1);\r\n\t\t\t\t}\r\n            \t\r\n            \tvar x = e.clientX;\r\n            \tvar y = e.clientY;\r\n            \tfor (i = 0; i < objs.length; i++) {\r\n            \t\tvar obj = objs[i];\r\n            \t\tif (x > obj.offsetLeft && x < (obj.offsetLeft + obj.clientWidth) && y > obj.offsetTop && y < (obj.offsetTop + obj.clientHeight)) {\r\n            \t\t\treturn true;\r\n            \t\t} else {\r\n            \t\t}\r\n            \t}\r\n            \treturn false;\r\n            }\r\n```\r\n\r\n初始化隐藏效果我没写，你自己加上就好", "Knowledge_Point": "树中的独立集", "Question": "利用JS和CSS如何实现div1和具有滑动出场效果的div2互联？\n\n\n\n要实现的效果：\n\n初始化，div2不显示，只显示div1。鼠标进入div1，那么div2显示（出现效果为下拉动画jQuery中表现为（$(\"#div2\").slideDown(500）；如果鼠标从div1进入div2，div2保持不变。如果鼠标离开div1并且不进入div2，div2消失（最好有缓慢消失效果）。如果鼠标从div2进入div1，div2不变（div2不产生任何变化）；如果鼠标从div2离开并且不进入div1，div2消失（最好有缓慢消失效果（$(\"#div2\").slideUp(500)））\n\n\n\ndiv1 和div2 是相互独立的，\n\n\n\n原本想问的就是这个问题，上一个问题没有把关键点（具有动画效果）说清楚，给大家造成不便请谅解。", "Tag": "算法分析"}
{"Answer": "我建议使用这种\n#include<stdio.h>\n#include<math.h>\ninline bool check(int x){\n    if(x<2)return false;\n    int end=sqrt(x);\n    for(int i=2;i<=end;++i)if(x%i==0)return false;\n    return true;\n}\nint n,ans=0;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)if(check(i))++ans;\n    printf(\"%d\",ans);\n}\n\n一个数n一定可以被分解为两个实数的乘积。所以实际上只需要检查根号n以内的数是不是它的因数就可以了。因为若一个大于根号n的数是n的因数的话，那么那个数一定要和一个小于根号n的数相乘得到n，所以证明完毕，OK", "Knowledge_Point": "树中的独立集", "Question": "救命啊，程序超时了，可是想不出别的方法了\n素数知多少？\nTime Limit: 1000MS        Memory Limit: 65536K\nTotal Submissions: 1232        Accepted: 330\nDescription\n\n\n在给定区间[1,n]中有多少个素数？\n\n\nInput\n\n\n每行一个整数n(1<=n<=1000000)\n\n\nOutput\n\n\n[1,n]之间素数的个数，独立一行\n\n\nSample Input\n\n\n1013\n100\nSample Output\n\n\n170\n25\n\n\n\n\n#\ninclude\n\n\n\nint\n arr[\n1000000\n] = { \n0\n };\n\nint\n \nmain\n()\n\n\n{\n    \n    \nint\n n;\n    \nwhile\n (\nscanf\n(\n\"%d\"\n, &n))\n    {\n        \nfor\n (\nint\n i = \n2\n; i <= n; i++)\n        {\n            \nif\n (arr[i]==\n0\n)\n            {\n                \nfor\n (\nint\n j = i+i; j <= n; j+=i)\n                {\n                    arr[j] = \n1\n;\n                }\n            }\n        }\n        \nint\n cot = \n0\n;\n        \nfor\n (\nint\n i = \n2\n; i <= n; i++)\n        {\n            \nif\n (arr[i] == \n0\n)\n            {\n                cot++;\n            }\n        }\n        \nprintf\n(\n\"%d\\n\"\n, cot);\n    }    \n    \nreturn\n \n0\n;\n}\n", "Tag": "算法分析"}
{"Answer": "//显示数据函数修改如下，其余函数全部不用修改。\nvoid Display()\n{\nuchar y=0;//动态数码管位引脚接P10/P11\nif(count>99)count=0;\nP0=P1=0;P1=wei_code[0];seg7_static_display(count%10);while(++y);\nP0=P1=0;P1=wei_code[1];seg7_static_display(count/10);while(++y);\n}\n\n", "Knowledge_Point": "树中的独立集", "Question": "单片机外部中断实验（写程序）\n51单片机的P3.2和P3.3引脚为外部中断信号输入端口，将独立按键K8大端连接外中断0引脚(P3.2),另一端接地（电路板上已经连接好了)。K8模拟外部脉冲的产生（按键存在抖动的缺点,编程的时候可以忽略)。编写程序,利用外部中断实现对K8按键的计数,并在数码管上显示（两位数码管（左边两位）动态显示，计数范围0～99）", "Tag": "算法分析"}
{"Answer": "可以使用Docker，或者给虚拟机拍摄一个快照，需要的时候还原就可以。有帮助请采纳，还有不懂的可以继续追问~", "Knowledge_Point": "树中的独立集", "Question": "做实验时，配置新的环境之后，能否回退到配置环境之前重新进行配置？\n做实验时，配置新的环境之后，能否回退到配置环境之前重新进行配置？\n\n\n使用环境Linux，往往在做实验之前，需要配置环境，例如运行实验给定的一个shell的脚本文件，会下各种软件或进行各种配置，会影响原来的配置。当我想回退到配置环境之前是不太可能了，我也不太清楚它到底做了那些更改。有没有在linux平台上可以独立出一个新的环境，在这上面进行配置，不影响原来的环境，当想回退到配置环境之前，只需要删掉或重新建一个环境即可。", "Tag": "算法分析"}
{"Answer": "#include <iostream>\nusing namespace std;\nint main()\n{\n    cout<<setw(5)<<\"*\";\n    for(int i=1;i<=9;i++)\n        cout<<setw(5)<<i;\n    cout<<endl;\n    for(int i=1;i<=50;i++)\n        cout<<'-';\n    cout<<endl;\n    for(int i=1;i<=9;i++)\n    {\n        cout<<setw(5)<<i;\n        for(int j=1;j<i;j++)\n            cout<<setw(5)<<\" \";\n        for(int j=i;j<=9;j++)\n            cout<<setw(5)<<i*j;\n        cout<<endl;\n    }\n    return 0;\n}\n\n", "Knowledge_Point": "乘法", "Question": "c++九九乘法表右上三角表示\n", "Tag": "算法分析"}
{"Answer": "是的，嵌套的for循环就是这样运作for i in range(1,10)：    for j in range(1,i+1):\ni从1开始到10,i等于1时，j从1跑到2i等于2时，j从1跑到3以此类推\n望采纳哈", "Knowledge_Point": "乘法", "Question": "九九乘法表是外层循环一次，内层循环一轮吗\nfor  i  in  range(1,10)：\n        for   j  in  range(1,i+1):\n                 print(f\"{j}\n{i}={j\ni}\",end=\" \")\n         print()", "Tag": "算法分析"}
{"Answer": "供参考：\n#include<stdio.h>\nint main()\n{\n    int i,j;\n    scanf(\"%d\",&i);\n    for(j=i;j<=9;j++)\n        printf(\"%c%dx%d=%d\",i==j?'\\r':' ',i,j,i*j);\n    \n    return 0;\n}\n\n", "Knowledge_Point": "乘法", "Question": "问一下C语言中怎么连续乘\n怎么编一串代码，可以输入一个个位数，输出他那一列的九九乘法表。例如输入7，得到7×7＝49，7×8=56，7×9=63。", "Tag": "算法分析"}
{"Answer": "n不输入的话永远等于0的\nint main\n{\n    int n,x,y,sum=0;\n    printf(\"输入第一个整数:\");\n    scanf(\"%d\",&x);\n    printf(\"输入第二个整数:\");\n    scanf(\"%d\",&y);\n    printf(\"输入操作：(0:+,1:-)\");\n    scanf(\"%d\",&n);\n    switch(n)\n    {\n        case 0:\n            sum=x+y;\n            break;\n        case 1:\n            xum=x-y;\n            break:\n        default:\n            printf(\"操作输入错误！\\n\");\n            return 1;\n            break;\n    }\n    printf(\"计算结果为：%d\\n\",sum);\n    return 0;\n}\n", "Knowledge_Point": "乘法", "Question": "输入两个整数，然后用0，1两个数代表加减法，但不知道哪里错了\n", "Tag": "算法分析"}
{"Answer": "\n#include <stdio.h>\nint main() {\n\tint i,j;\n\tfor(i=1; i<=9; i++) {\n\t\tfor(j=1; j<=i; j++)\n\t\t\tprintf(\"%d*%d=%d\\t\",j,i,j*i);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\n代码如上，万望采纳。", "Knowledge_Point": "乘法", "Question": "c++的九九乘法，新手求解，不懂\n输出后的九九乘法表是个直角三角形，体现出九九乘法表", "Tag": "算法分析"}
{"Answer": "要用换行符的哦", "Knowledge_Point": "乘法", "Question": "九九乘法表运行结果不一样\n我运行的九九乘法表结果是横条的\n124369这种的，代码我和别人的都是一样的，为什么不是梯形的，换行后是竖着的\n1\n2\n4\n3\n6\n9", "Tag": "算法分析"}
{"Answer": "你贴上来的代码是混乱的，你参考一下代码改一下吧，有用记得采纳\nfor i in range(1, 10):\n    for j in range(1, 1 + i):\n        print(f\"{j}*{i}={i * j:<2}\", end=' ')\n    print()\n\n", "Knowledge_Point": "乘法", "Question": "python乘法表问题报错求解\nlist1=[\"{}\n{}={:<2}\".format(i,j,i\nj)+(\"\"if i!=j else \"\\n\")]\n       for i in range(1,10) for j in range(1,i+1)\nfor item in list1:\n    print(item,end=\"\")\n我想打印一个99乘法表，但是第二行报错了，请问原因是什么，怎么改", "Tag": "算法分析"}
{"Answer": "pow函数的返回值是浮点型，不能用%d输出。你定义的a是int型，a=pow(3,i)会将浮点型转换为整型", "Knowledge_Point": "乘法", "Question": "打印3的乘法表怎么不对\n题目要求是打印一个3的乘法表，怎么像我注释那样做不对呢，必须得另外用个量来存储结果输出才对。", "Tag": "算法分析"}
{"Answer": "你看看对不对\n#include<stdio.h>\n//乘积最大值\nvoid sort(int t[],int n)\n{\n    int j=0;\n    while(j<n)\n    {\n        if(t[j]<t[j-1]&&j!=0)\n        {\n            int tem=t[j];\n            t[j]=t[j-1];\n            t[j-1]=tem;\n            j--;\n        }\n        else\n        {\n            j++;\n        }\n    }\n}\nint main()\n{\n    int j,k,h;\n    int t[5];\n    for(j=0;j<5;j++)\n    {\n        scanf(\"%d\",&t[j]);\n    }\n    sort(t,5);\n    \n    int max1=t[4]*100+t[1]*10+t[0];\n    int max2=t[3]*10+t[2];\n    \n    printf(\"%d  %d   \",max1,max2);\n\n    printf(\"乘积最大值：%d\\n\",max1*max2);\n    return 0;\n}\n", "Knowledge_Point": "乘法", "Question": "c语言求乘积最大值。。\n题目是这样的，任意输入五个数（可以相同），五个数里面分成两组数，组成一个三位数乘以一个两位数，每个数只能取一遍，求乘积最大值。", "Tag": "算法分析"}
{"Answer": "估计你最后多了个换行。试试判断最后一行的时候，不要println(\"\");if(i!=1)  System.out.println(\"\");", "Knowledge_Point": "乘法", "Question": "输出倒九九乘法口诀表\n我想知道我哪里错了，为什么提交上去说\n  格式错误\n\n\n\n\n\n", "Tag": "算法分析"}
{"Answer": "#include<stdio.h>\nint main()\n{\n    int n,i,j;\n    while(scanf(\"%d\",&n)!=EOF)\n    {\n        for(i=1;i<=n;i++)\n        {\n            for(j=1;j<=i;j++)\n            {\n                printf(\"%d*%d=%-4d\",j,i,i*j);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n", "Knowledge_Point": "乘法", "Question": "【C语言】输出乘法口诀表\n还记得以前小学时的九九乘法口诀吧。现在要求你编写程序打印出乘法口诀。 不过现在的乘法口诀表跟以前稍微有点区别，我告诉你一个数字n( 1 <= n <= 9),你要给我打出相应的nn乘法口诀表。\n输入：多个测试数据。每个测试数据一行，输入整数n.\n输出：输出nn乘法口诀表。 每个乘法口诀表中的任何一个乘式占6列，不足6列的在后面补空格。同一行2个乘式之间有一个空格。 两个乘法口诀表之间有一个空行。注意乘法口诀中每一行最后没有空格，如4\n4=16和5\n5=25后面都没有空格的。\nSample Input\n1\n2\n3\nSample Output\n 1*1=1\n\n\n 1\n1=1\n 1\n2=2  2*2=4\n\n\n 1\n1=1\n 1\n2=2  2\n2=4\n 1\n3=3  2\n3=6  3\n3=9\n 1\n4=4  2\n4=8  3\n4=12 4\n4=16\n 1\n5=5  2\n5=10 3\n5=15 4\n5=20 5\n5=25\n 1\n6=6  2\n6=12 3\n6=18 4\n6=24 5\n6=30 6*6=36", "Tag": "算法分析"}
{"Answer": "第一题\npublic static void main(String[] args) {\n        int i, j;\n        for (i = 1; i <= 9; i++) {\n            for (j = 1; j <= i; j++) {\n                if (i == 2) continue;\n                if (i == 4) continue;\n                if (i == 6) continue;\n                System.out.print(j + \"*\" + i + \"=\" + j * i);\n                if (i == j) break;\n                System.out.print(\"  \");\n            }\n            System.out.println(\"\");\n        }\n\n    }\n\n", "Knowledge_Point": "乘法", "Question": "循环结构的三道题……急！\n运用循环结构！！\n1.写九九乘法表 跳过第2，4，6行！\n2.用while循环写出99乘法表\n3.将数值5050依次减1到100之间的奇数，并输出结果。", "Tag": "算法分析"}
{"Answer": "print(1<<int(input()))\n\n用位操作去移有帮助望采纳\n", "Knowledge_Point": "乘法", "Question": "求2的n次方，算法题\n运行程序时，输入一个正整数 n（其中 1 ≤ n ≤ 50），运行后输出 2 的 n 次方。\n\n\n要求：\n①只允许编写一行代码；\n②不允许使用任何循环结构、乘法、乘方符号和与乘法、乘方相关的函数。\n运行内存 ≤ 600 KB，时间 < 100 ms。\n\n\n样例输入：\n\n\n5\n\n\n\n样例输出：\n\n\n32\n", "Tag": "算法分析"}
{"Answer": "\nwith open('lfy.txt',mode='w',encoding='utf-8') as a:\n  \n    \n    def abc(a, *args):\n        n, m = args\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                print(\"%2d x%2d = %-2d\" % (j, i, i * j), end='', file=a)\n            print('', file=a)\n    abc(a, 9, 9)\n", "Knowledge_Point": "乘法", "Question": "不会写了能看看为什么不能写入文件里面吗？\n使用python，在一个命名为lfy.txt文本文档写入n m乘法表。\n1.创建函数名为abc的函数；\n2.n m乘法表，封装在abc的函数里；\n3.调用abc函数，例如abc（9,9）就能完成九九乘法表绘制\nwith open('lfy.txt',mode='w',encoding='utf-8') as a:\n    def abc(*args):\n        for i in range(1, 10):\n            for j in range(1, i + 1):\n                print(\"%dx%d=%-2d\" % (j, i, i * j), end='')\n            print('')\nprint(a == abc())", "Tag": "算法分析"}
{"Answer": "利用两层for循环来实现\n#include <stdio.h>\nint main() {\n    int i,j;\n    for(i=1;i<=9;i++){\n        for(j=1;j<=9;j++){\n            if(j<i)\n                //打印八个空格，去掉空格就是左上三角形 \n                printf(\"        \");\n            else\n                printf(\"%d*%d=%2d  \",i,j,i*j);\n        }\n\n        printf(\"\\n\");  \n    }\n\n    return 0;\n}\n", "Knowledge_Point": "乘法", "Question": "C语言，求解使用for循环\n用c语言for循环输出99乘法表，如下图的输出格式，该怎么解决。", "Tag": "算法分析"}
{"Answer": "第7行后面的分号删掉！！！", "Knowledge_Point": "乘法", "Question": "这个双层循环的外循环为什么不执行呢\n打印一个九九乘法表，输入数字N，然后打印1\n1到N\nN，例如：\n输入2\n输出：1\n1\n             1\n2 2*2", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n#include<math.h>\n/*\n* 实现一个简易计算器，书写四个函数（add加法函数、subtract减法函数、multiply乘法函数、\ndivide除法函数），\n分别实现求两数＋，一，×，/的结果，在主两数中进行调用。\n*/\nint add(int a,int b) {\n    return a + b;\n}\nint subtract(int a, int b) {\n    return a - b;\n}\nint multiply(int a, int b) {\n    return a * b;\n}\nfloat divide(int a, int b) {\n    return a / b;\n}\nint main()\n{\n    int a, b;\n    char s;\n    scanf(\"%d%c%d\",&a,&s,&b);\n    if (s=='+')\n    {\n        printf(\"%d\", add(a, b));\n    }\n    if (s == '-')\n    {\n        printf(\"%d\", subtract(a, b));\n    }\n    if (s == '*')\n    {\n        printf(\"%d\", multiply(a, b));\n    }\n    if (s == '//')\n    {\n        printf(\"%d\", divide(a, b));\n    }\n    return 0;\n}\n", "Knowledge_Point": "乘法", "Question": "c语言实现一个简易计算器\n实现一个简易计算器，书写四个函数（add加法函数、subtract减法函数、multiply乘法函数、divide除法函数），分别实现求两数＋，一，×，/的结果，在主两数中进行调用。", "Tag": "算法分析"}
{"Answer": "# 问题解决的话，请点下`采纳`\r\n```\r\n#include \r\n\r\nint main()\r\n{\r\n\tfloat x,y,z;\r\n\tchar ch;\r\n\twhile(1)\r\n\t{\r\n\t\tprintf(\"输入你的选项\\n\");\r\n\t\tprintf(\"a.加 b.减\\nc.乘 d.除\\nq.退出\\n\");\r\n\t\tscanf(\" %c\",&ch);\r\n\t\tif(ch!='a'&&ch!='b'&&ch!='c'&&ch!='d'&&ch!='q')\r\n\t\t{\r\n\t\t\tprintf(\"输入选项无效重新输入\\n\");\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (ch == 'q') break;\r\n\t\tprintf(\"输入第一个数：\");\r\n\t\twhile((scanf(\"%f\",&x))==0)\r\n\t\t{\r\n\t\t\tprintf(\"这个不是数，重新输入\\n\");\r\n\t\t} \r\n\t\tprintf(\"输入第二个数：\");\r\n\t\twhile (1)\r\n\t\t{\r\n\t\t\tif (scanf(\"%f\",&y)==0)\r\n\t\t\t\tprintf(\"这个不是数，重新输入\\n\");\r\n\t\t\telse if(y==0)\r\n\t\t\t{\r\n\t\t\t\tprintf(\"0不能作为除数请重新输入\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\tcase 'a':\r\n\t\t\tz=x+y;\r\n\t\t\tbreak;\r\n\t\tcase 'b':\r\n\t\t\tz=x-y;\r\n\t\t\tbreak;\r\n\t\tcase 'c':\r\n\t\t\tz=x*y;\r\n\t\t\tbreak;\r\n\t\tcase 'd':\r\n\t\t\tz=x/y;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tprintf(\"\\n结果是%.2f\\n\",z);\r\n\t}\r\n\treturn 0;\r\n}\r\n```", "Knowledge_Point": "乘法", "Question": "C Primer Plus 8.8练习题 编写一个菜单，提供加减乘除的选项进行计算\n编写一个程序，显示提供加法、减法、乘法的菜单，该程序只接受菜单提供的选项,程序提示用户输入两个数字。要求是输入q退出，输入数字时有误要求重新输入，除数为零的时候报错并要求重新输入。\n\n我的程序在正常运算时没问题，输入q退出和除数为0时程序有问题。可能是那个循环和if有问题但是不知道具体问题在哪里。\n\n我只是个自学一个月小白求大佬带带我！！！\n\n#include\n\nint main()\n\n    {\n\n        float x,y,z;\n\n        char ch;\n\n        while(ch!='q')\n\n        {\n\n            printf(\"输入你的选项\\n\");\n\n            printf(\"a.加      b.减\\nc.乘      d.除\\nq.退出\\n\");\n\n            scanf(\" %c\",&ch);\n\n            if(ch!='a'&&ch!='b'&&ch!='c'&&ch!='d'&&ch!='q')\n\n            {\n\n                printf(\"输入选项无效重新输入\\n\");\n\n                    continue;\n\n            }\n\n            printf(\"输入第一个数：\");\n\n            while((scanf(\" %f\",&x))==0)\n\n            {\n\n                printf(\"这个不是数，重新输入\\n\");\n\n            } \n\n            printf(\"输入第二个数：\");\n\n            while ((scanf(\" %f\",&y))==0)\n\n            {\n\n                printf(\"这个不是数，重新输入\\n\");\n\n                if(ch=='d'&&y==0)\n\n                {\n\n                    printf(\"0不能作为除数请重新输入\");\n\n                    continue;\n\n                }\n\n            }\n\n            switch(ch)\n\n            {\n\n                case 'a':\n\n                    z=x+y;\n\n                    break;\n\n                case 'b':\n\n                    z=x-y;\n\n                    break;\n\n                case 'c':\n\n                    z=x*y;\n\n                    break;\n\n                case 'd':\n\n                    z=x/y;\n\n                    break;\n\n                case 'q':\n\n                    break;\n\n            }\n\n            printf(\"\\n结果是%.2f\\n\",z);\n\n            if(ch=='q')\n\n            break;\n\n        }\n\n        return 0;\n\n    }", "Tag": "算法分析"}
{"Answer": "在每行式子输出前的增加输出空白间距，以输出不断递减数量的制表符来实现即可。修改如下：\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main(void){\n    \n    for(int i=1;i<=9;i++){\n        \n        for(int k=9;k>i;k--){\n            cout<<\"\\t\";\n        }\n        \n        for(int j=1;j<=i;j++){\n            cout<<i<<\"*\"<<j<<\"=\"<<left<<setw(4)<<i*j;\n        }\n        \n        cout<<endl;\n    }\n} \n\n\n", "Knowledge_Point": "乘法", "Question": "如何使下列代码输出为右上三角\n\n\n使用的是2010版本\n目的是输出乘法表，但需要右对齐\n如题，如何解决？", "Tag": "算法分析"}
{"Answer": "print()放在外层循环中，内层循环中print的间隔改成3\nfor i in range(1,10):\n    print(' '*7*(i-1),end='')\n    for j in range(i,10):\n        print(\"{}*{}={:<3}\".format(i,j,i*j),end='')\n    print()\n", "Knowledge_Point": "乘法", "Question": "python九九乘法表\n现在我写出来的代码如下\n但是要写成这种 怎么才可以把它变成格式为这种排序的呢？", "Tag": "算法分析"}
{"Answer": "\n#include<stdio.h>\n#include<stdlib.h>\n#define MAX_VERTEX_NUM 100\ntypedef struct ArcNode{\n\tint adjvex;//该边的另一个顶点的位置 \n\tstruct ArcNode *nextarc; //指向下一条边 \n}ArcNode;\ntypedef struct VNode{\n\tint data;//顶点的值 \n\tArcNode *firstarc;//指向第一条依附该顶点的边的指针 \n}VNode,AdjList[MAX_VERTEX_NUM];\ntypedef struct{\n\tAdjList vertices;//顶点数组 \n\tint vexnum,arcnum;\n}ALGraph;\nint LocateVex(ALGraph G,int v){//定位函数 \n\tfor(int i=0;i<G.vexnum;i++){\n\t\tif(v==G.vertices[i].data)return i;\n\t} \n}\nvoid CreateUDG(ALGraph &G){\n\tArcNode *p,*q;\n\tint i,j,k,v1,v2;\n\tprintf(\"分别输入顶点个数和边的数目：\\n\");\n\tscanf(\"%d%d\",&G.vexnum,&G.arcnum);\n\tprintf(\"分别输入各个顶点值：\\n\");\n\tfor(i=0;i<G.vexnum;i++){\n\tscanf(\"%d\",&G.vertices[i].data);\n\tG.vertices[i].firstarc=NULL;//初始化 \n\t} \n\tprintf(\"分别输入各条边的两个顶点：\\n\");\n\tfor(k=0;k<G.arcnum;k++){\n\t\tscanf(\"%d%d\",&v1,&v2);\n\t\ti=LocateVex(G,v1);j=LocateVex(G,v2);//定位 \n\t\tp=(ArcNode*)malloc(sizeof(ArcNode));//申请一个结点 \n\t\tp->adjvex=j;p->nextarc=NULL;//赋值 \n\t\tp->nextarc=G.vertices[i].firstarc;//连接结点 \n\t\tG.vertices[i].firstarc=p;//连接结点 \n\t\tq=(ArcNode*)malloc(sizeof(ArcNode));\n\t\tq->adjvex=i;q->nextarc=NULL;\n\t\tq->nextarc=G.vertices[j].firstarc;\n\t\tG.vertices[j].firstarc=q;\n\t}\n}\nvoid PrintUDG(ALGraph G){//输出邻接表 \n    int i,j;\n\tfor(i=0;i<G.vexnum;i++){\n\t\tprintf(\"%d:\",i);\n\t\tArcNode *p;\n\t\tp=G.vertices[i].firstarc;\n\t\twhile(p!=NULL){\n\t\t\tprintf(\"->%d\",p->adjvex);\n\t\t\tp=p->nextarc;\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\nint main(){\n\tALGraph G;\n\tCreateUDG(G);\n\tPrintUDG(G);\n\treturn 0;\n}\n如果对你有帮助，可以点击我这个回答右上方的【采纳】按钮，给我个采纳吗，谢谢\n ", "Knowledge_Point": "优先队列实现", "Question": "怎样实现无向图的创建算法\n\n\n\n1、编写一个函数让用户输入这张图，用邻接表存储。\n\n2、编写函数实现此图的深度优先搜索遍历。\n\n3、编程实现循环队列，编写初始化、创建、入队、出队等算法。\n\n4、利用循环队列对图实现广度优先搜索遍历。", "Tag": "算法分析"}
{"Answer": "按照要求写模板函数就可以了啊，有什么困难参考：\n#include <iostream>\nusing namespace std;\ntemplate<typename T>\nT sum(T* array,int size=0)\n{\n    T sums = 0;\n    for(int i=0;i<size;i++)\n        sums += array[i];\n    return sums;\n}\nint main()\n{\n    int a[5] = {1,2,3,4,5};\n    double b[5] = {9.1,8.34,4.13,-3.913,0.923};\n\n    int s1 = sum(a,5);\n    double s2 = sum(b,5);\n    cout<<\"整型数组和:\"<<s1<<endl;\n    cout<<\"浮点型数组和:\"<<s2<<endl;\n    return 0;\n}\n\n", "Knowledge_Point": "模运算", "Question": "#C++模板和异常处理代码问题\n根据提示代码设计一个函数模板，能求一维数组中的所有元素的和，并写出调用此函数模板的完整程序，使得函数调用时，可以处理int、double类型的数组。\n运行结果如下：（运算结果因输入值差异，不是唯一）\n\n\n提示代码：\n\n\nT sum(T* \narray\n,\nint\n size=\n0\n)\n......\n\nint\n  array1[]=\n{......}\n;\ndouble array2[]=\n{......}\n;\n\n\n", "Tag": "算法分析"}
{"Answer": "思路是没问题，但是你没有初始化sum，结果就会错。\r\n简单地说就是 int sum=0;\r\n改一下就好", "Knowledge_Point": "模运算", "Question": "Digital Roots 题目大意将输入的正整数的各个数相加\n题目如下\n\nThe digital root of a positive integer is found by summing the digits of the integer. If the resulting value is a single digit then that digit is the digital root. If the resulting value contains two or more digits, those digits are summed and the process is repeated. This is continued as long as necessary to obtain a single digit. \n\nFor example, consider the positive integer 24. Adding the 2 and the 4 yields a value of 6. Since 6 is a single digit, 6 is the digital root of 24. Now consider the positive integer 39. Adding the 3 and the 9 yields 12. Since 12 is not a single digit, the process must be repeated. Adding the 1 and the 2 yeilds 3, a single digit and also the digital root of 39. \n\n\n\n输入 \n\n\n\nThe input file will contain a list of positive integers, one per line. The end of the input will be indicated by an integer value of zero. \n\n\n\n输出 \n\n\n\nFor each integer in the input, output its digital root on a separate line of the output. \n\n\n\n样例输入 \n\n\n\n24 \n\n39 \n\n0 \n\n\n\n样例输出 \n\n\n\n6 \n\n3 \n\n\n\n我的思路是 \n\n1.将sum各位数字加起来，赋值sum\n\n2.判断sum是否是个位数，如果不是，转1\n\n3是个位数，输出结果，运算结束\n\nsum%9的结果和整个数模9的结果相同，用来运算各个书之和。以下是我的代码。思路看起来没问题，但是运行结果和想象的不一样。\n\n\n\n #include \nint main()\n{\n    char ch;\n    while(1){  //计算各位数字的和\n    int sum;\n    while(scanf(\"%c\",&ch) && ch!='\\n'){\n        sum+=ch-'0';\n        }\n    if (sum==0) break;\n    //模9运算求根\n    if(sum%9==0) sum=9;\n    else sum=sum%9;\n    printf(\"%d\\n\",sum);\n    }\n    return 0;\n}\n\n", "Tag": "算法分析"}
{"Answer": "有个简单的办法，提前打开任务管理器翻到GPU那一栏，在训练或者预测数据的时候观察各项指标特别是复制有没有起伏", "Knowledge_Point": "模运算", "Question": "jupyter 中tf 搭建神经网络 如何确定自己的GPU参与了计算？\n采用mnist的数据集练习 神经网络分类问题，搭建完模型后的fit过程如下：\n\n\n%%time\nmodel.fit\n(x_train_reshaped,y_train,\nepochs\n = 10,\nbatch_size\n = 64,\n          \nvalidation_data\n = (x_valid_reshaped,y_valid)\n)\n\n# 这里面一定要用reshaped的数据才行\n\n\n\n\n运算结果如下：\n\n\nEpoch \n1\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n3.0898\n - sparse_categorical_accuracy: \n0.6319\n - val_loss: \n0.7920\n - val_sparse_categorical_accuracy: \n0.7922\n\nEpoch \n2\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.6585\n - sparse_categorical_accuracy: \n0.8172\n - val_loss: \n0.5834\n - val_sparse_categorical_accuracy: \n0.8415\n\nEpoch \n3\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.5044\n - sparse_categorical_accuracy: \n0.8641\n - val_loss: \n0.4774\n - val_sparse_categorical_accuracy: \n0.8803\n\nEpoch \n4\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.4253\n - sparse_categorical_accuracy: \n0.8852\n - val_loss: \n0.3929\n - val_sparse_categorical_accuracy: \n0.8931\n\nEpoch \n5\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.3789\n - sparse_categorical_accuracy: \n0.8986\n - val_loss: \n0.3681\n - val_sparse_categorical_accuracy: \n0.9028\n\nEpoch \n6\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.3455\n - sparse_categorical_accuracy: \n0.9064\n - val_loss: \n0.3584\n - val_sparse_categorical_accuracy: \n0.9103\n\nEpoch \n7\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.3146\n - sparse_categorical_accuracy: \n0.9131\n - val_loss: \n0.3123\n - val_sparse_categorical_accuracy: \n0.9160\n\nEpoch \n8\n/\n10\n\n\n938\n/938 [==============================] - 3s 4ms/\nstep\n - loss: \n0.2925\n - sparse_categorical_accuracy: \n0.9198\n - val_loss: \n0.3075\n - val_sparse_categorical_accuracy: \n0.9169\n\nEpoch \n9\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.2782\n - sparse_categorical_accuracy: \n0.9214\n - val_loss: \n0.3440\n - val_sparse_categorical_accuracy: \n0.9157\n\nEpoch \n10\n/\n10\n\n\n938\n/938 [==============================] - 4s 4ms/\nstep\n - loss: \n0.2652\n - sparse_categorical_accuracy: \n0.9247\n - val_loss: \n0.3154\n - val_sparse_categorical_accuracy: \n0.9147\n\nWall time: \n35.9\n s\n\n\n\n我想问在这个过程中GPU 有没有参与计算？ 如果没有，怎样设置才可以GPU 参与计算，在这之前我也将CUDA 显卡驱动什么的都装好了。\n数据量测试集是 60000\n784 验证集是10000\n784.", "Tag": "算法分析"}
{"Answer": "EIGEN是不是需要初始化，在dllmain里面初始化下还有dll连同EIGEN的那些文件都要拷贝给调用者还有32bit 64bit不能混合", "Knowledge_Point": "模运算", "Question": "DLL动态链接库调用外部库报错\n#问题现状：\n使用Visual studio编辑C++代码，并生成DLL动态链接库发送到模型软件中做外部控制器，此时可以正常使用；\n在C++代码中增加关于EIGEN库的内容，生成DLL送进模型中运算就报错了。\n\n\n#\ninclude\n \n\n \n\n\n#\ninclude\n \n\n \n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n#\ndefine\n NINT(a) ((a) >= 0.0 ? (int)((a)+0.5) : (int)((a)-0.5))\n\n\nextern\n \n\"C\"\n \n//avoid mangled names \n\n{ \nvoid\n __declspec(dllexport) \n__cdecl \nDISCON\n(\nfloat\n* avrSwap, \nint\n* aviFail,\n    \nchar\n* accInfile, \nchar\n* avcOutname, \nchar\n* avcMsg)\n;\n}\n\n//Main DLL routine \n\n\nvoid\n __declspec(dllexport) \n__cdecl \nDISCON\n(\nfloat\n* avrSwap, \nint\n* aviFail, \nchar\n* accInfile, \nchar\n* avcOutname, \nchar\n* avcMsg)\n\n\n{\n    Eigen::MatrixXd M;\n    M << \n0\n, \n0\n,\n         \n0\n, \n0\n;\n    std::cout << M << std::endl;\n    \nreturn\n;\n}\n", "Tag": "算法分析"}
{"Answer": "\nI have solved it like this, but I am not sure that it is a correct way:\ntype Organization struct {\n\n    gorm.Model\n\n    Parent *Organization\n    ParentId int `gorm:\"TYPE:integer REFERENCES organizations\"`\n    Name string `gorm:\"size:30\"`\n    Description string `gorm:\"size:100\"`\n}\n\n", "Knowledge_Point": "递归关系", "Question": "GORM中的一对多递归关系\n\n\n\nI need to have an \nOrganization\n which have relation to parent one. Something like this:\n\n\n\ntype Organization struct {\n\n    gorm.Model\n\n    Parent *Organization `gorm:\"ForeignKey:ParentId\"`\n    Name string `gorm:\"size:30\"`\n    Description string `gorm:\"size:100\"`\n}\n\n\n\n\nI want to have \nParentId\n field which will be referenced to \nid\n field in the same table. But as I see there is no field and relation.\n\n\n\nHow can I fix it ?\n\n    ", "Tag": "算法分析"}
{"Answer": "你生成了一个二维数值Aarray([[10, 11, 12],       [13, 14, 15],       [16, 17, 18]])\nA[[2,1]]：取了A中的第三行和第三行array([[16, 17, 18],       [13, 14, 15]])\nA[[2,1],[1,2]]：取了A中的第三行的第二个元素和第三行第三个元素", "Knowledge_Point": "应对NP完全问题", "Question": "A=np.array输出问题\nA\n=np.array([[\n10\n,\n11\n,\n12\n],[\n13\n,\n14\n,\n15\n],[\n16\n,\n17\n,\n18\n]]),A[[[\n2\n,\n1\n],[\n1\n,\n2\n]]]的输出结果是（）\n\n\n\n\narray([17, 15])\n\n\n为什么？", "Tag": "算法分析"}
{"Answer": "\nI just found out that there is nothing like np.where() in gocv. \nAll I have to do is:\n1. get []byte using Mat.ToBytes()\n2. writing a for loop to check each pixel in []byte and changing it if meet the condition.\n3. get Mat from gocv.NewMatFromBytes()\n", "Knowledge_Point": "应对NP完全问题", "Question": "在gocv中是否有类似python中的np.where（）的类似功能？\n\n\n\nIs there any similar function in Gocv like np.where() in Python? I want to specify some specific pixel values to 0, and others to 255. As follows, in Python I can do:\n\n\n\n        img = cv2.imread(\"test.png\", cv2.IMREAD_GRAYSCALE)\n        img_ = np.where(img == 144 , img*0, np.where(img == 170 , img*0, np.where(img == 178 , img*0, np.where(img == 187 , img*0, 255))))\n\n\n\n\nthe pixel values which are 187, 178, 170, 144 will be set to 0, and others to 255. How can I do this job in Golang with Gocv?\n\n    ", "Tag": "算法分析"}
{"Answer": "\n>>> import numpy as np\n>>> x = np.array([1,2,3,4,5,6])\n>>> r = np.random.choice(np.arange(x.size), 3, replace=False) # 从x中随机无重复地抽取3个数\n>>> r # 这次选中的是0，2，4\narray([0, 2, 4])\n>>> x[r] += 1 # 选中的数字加1\n>>> x\narray([2, 2, 4, 4, 6, 6])\n ", "Knowledge_Point": "应对NP完全问题", "Question": "如何让一个np数组中随机几个数字+1\n比如我现在有[1,2,3,4,5,6]这个数组，\n\n\n\n如何将该数组中随机n个数字都+1，\n\n\n\n比如将原有数组变成[2,2,4,4,5,6],\n\n\n\n这里面就随机到了第0第2个数加一了。", "Tag": "算法分析"}
{"Answer": "如有帮助请给个采纳！\n>>> import numpy as np\n>>> np.linspace(1, 9, num=10)\narray([1.        , 1.88888889, 2.77777778, 3.66666667, 4.55555556,\n       5.44444444, 6.33333333, 7.22222222, 8.11111111, 9.        ])\n", "Knowledge_Point": "应对NP完全问题", "Question": "使用np.linspace函数在1-9区间内生成10个包含9的等间隔数，不显示间隔\n使用np.linspace函数在1-9区间内生成10个包含9的等间隔数，不显示间隔", "Tag": "算法分析"}
{"Answer": "A = [7,9,1,5,9,6,1,2,9]\nB = [x for x in A if x!=max(A) and x!=min(A)]\nprint(B)\n#或者：\nC = [x for x in A if x not in [max(A),min(A)]]\nprint(C)\n", "Knowledge_Point": "应对NP完全问题", "Question": "如何删除列表中的最大值和最小值\n想要删除D列表中的最大值和最小值  尝试了np.remove和np.delete(D,argmax())都报错了", "Tag": "算法分析"}
{"Answer": "该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下：np.arange 函数用于生成一个等差数列，左闭右开区间，即终点值通常不会被包含在内。但是由于浮点数的精度问题，有时候会出现终点值被包含在内的情况。\n在第一个例子中，使用 np.arange(0.91, 0.93, 0.01) 生成的等差数列应该是 [0.91, 0.92]，但是由于浮点数的精度问题，0.92 这个数可能会被表示成 0.9199999999999999，从而导致 0.93 也被包含在内。这就是为什么 0.93 会被输出的原因。\n在第二个例子中，使用 np.arange(0.91, 0.99, 0.02) 生成的等差数列应该是 [0.91, 0.93, 0.95, 0.97]，这个结果是正确的，因为终点值 0.99 不会被包含在内。\n在第三个例子中，使用 np.arange(0.91, 0.99, 0.01) 生成的等差数列应该是 [0.91, 0.92, 0.93, ..., 0.98]，但是由于浮点数的精度问题，0.98 这个数可能会被表示成 0.9799999999999999，从而导致 0.99 也被包含在内。这就是为什么 0.99 会被输出的原因。\n在第四个例子中，使用 np.arange(99.91, 99.93, 0.01) 生成的等差数列应该是 [99.91, 99.92]，但是由于浮点数的精度问题，99.92 这个数可能会被表示成 99.91999999999999，从而导致 99.93 也被包含在内。这就是为什么 99.93 会被输出的原因。\n为了避免这种精度问题，可以使用 np.linspace 函数代替 np.arange 函数，它可以生成指定数量的等分数列，可以避免出现终点值被包含的问题。例如，可以使用 np.linspace(0.91, 0.93, 3) 生成 [0.91, 0.92, 0.93]，这样可以确保终点值不会被包含在内。\n\n如果以上回答对您有所帮助，点击一下采纳该答案～谢谢", "Knowledge_Point": "应对NP完全问题", "Question": "np.arange输出结果异常\n使用np.arange，终点值应该不被输出，但是如图所示：\n\n\nimport\n numpy as np\n\nM\n = np.arange(\n0\n.\n91\n, \n0\n.\n93\n, \n0\n.\n01\n)\n\nprint\n(M)\n\n\n\n\n\nimport\n numpy as np\n\nM\n = np.arange(\n0\n.\n91\n, \n0\n.\n99\n, \n0\n.\n02\n)\n\nprint\n(M)\n\n\n\n\n\n终点值0.99又没有被输出，很奇怪的问题，不太懂为啥。\n\n\nimport\n numpy as np\n\nM\n = np.arange(\n0\n.\n91\n, \n0\n.\n99\n, \n0\n.\n01\n)\n\nprint\n(M)\n\n\n\n\n\n但是有的组合就是会出现问题:\n\n\nimport\n numpy as np\n\nM\n = np.arange(\n99\n.\n91\n, \n99\n.\n93\n, \n0\n.\n01\n)\n\nprint\n(M)\n\n\n\n99.93又被输出：\n\n\n\n\n感觉很奇怪的问题", "Tag": "算法分析"}
{"Answer": "少了两个右括号\n\n修改如下：\ns = abs(np.sin((ang1-ang2)/180*np.pi)*l*h)+abs(np.cos((ang1-ang2)/180*np.pi)*w*h)\n", "Knowledge_Point": "应对NP完全问题", "Question": "plt.figure() 报错SyntaxError: invalid syntax\n问题遇到的现象和发生背景\n\n\njupyter notebook\n\n\n问题相关代码，请勿粘贴截图\n\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nplt\n.rcParams\n[\n'font.sans-serif'\n]\n=\n[\n'SimHei'\n]\n\nplt\n.rcParams\n[\n'axes.unicode_minus'\n]\n=False\n\n\nl = np\n.linspace\n(\n1\n,\n15\n,\n100\n)\nh = \n10\n\nw = \n10\n\nang1 = \n30\n\nang2 = \n45\n\n\n\ns = abs(np\n.sin\n((ang1-ang2)/\n180\n*np.pi)*l*h+abs(np\n.cos\n((ang1-ang2)/\n180\n*np.pi)*w*h\n\n\nplt\n.figure\n()\nplt\n.xlabel\n(\n\"长度\"\n)\nplt\n.ylabel\n(\n\"面积\"\n)\nplt\n.title\n(\n\"面积\"\n)\nplt\n.ylim\n(\n0\n,\n20\n)\nplt\n.xlim\n(\n0\n,\n20\n)\nplt\n.plot\n(l,s)\nplt\n.show\n()\n\n\n\n\n运行结果及报错内容\n\n\n  \nFile\n \n\"\"\n, \nline\n 16\n    plt.figure()\n    ^\nSyntaxError: invalid \nsyntax\n\n\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n这个该怎么解决", "Tag": "算法分析"}
{"Answer": "要建一个别名字典，然后apply 替换", "Knowledge_Point": "应对NP完全问题", "Question": "dataframe中，怎样实现old列按照new列名字重新命名，然后把结果放在第三列\n以 new 列中的名字为标准，把 old 列中的名字全部替换，然后放在第三列，两列中虽然名字不一样，但其实是同一个物质，如图中标示颜色所示，\n\n\n\n\n代码如下：\n\n\nimport\n  pandas  \nas\n  pd\n\nimport\n  numpy  \nas\n  np\ndf = pd.DataFrame({\n\n'old'\n: [\n'醋酸铵'\n, \n'氨水（5mol/L氨溶液）'\n, \n'甘油'\n, \n'盐酸萘乙二胺'\n, \n'氨水'\n, \n'硫酸铜'\n, \n'钙紫红素'\n, \n'冰醋酸'\n,np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n, np.\nnan\n,np.\nnan\n], \n\n'new'\n: [\n'乙酸铵'\n, \n'十二水合硫酸铝钾'\n, \n'硫酸铵'\n, \n'百里香酚蓝（溴酚蓝）'\n, \n'钙紫红素'\n, \n'间甲酚紫'\n, \n'硫酸钙(无水)'\n,\n'氢氧化氨(氨水)'\n, \n'磷酸氢二钾'\n, \n'盐酸萘乙二胺'\n, \n'乙二胺四乙酸二钠盐，二水'\n, \n'冰醋酸（冰乙酸）'\n,\n'抗坏血酸（维生素C）'\n, \n'氨水（5mol/L氨溶液）'\n, \n'无水硫酸镁'\n, \n'丙三醇(甘油)'\n, \n'四水合，酒石酸钾钠'\n,\n'邻苯二甲酸氢钾'\n, \n'磷酸二氢钾'\n, \n'亚铁氰化钾'\n, \n'硫酸钾'\n, \n'五水合硫酸铜'\n]})\n", "Tag": "算法分析"}
{"Answer": "这么改就行了：\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure()\n'''让下面的都在一个框框里面'''\nax = Axes3D(fig,auto_add_to_figure=False)\nfig.add_axes(ax)\n'''绘制3D空间（坐标轴）'''\nX = np.arange(-4, 4, 0.25)\nY = np.arange(-4, 4, 0.25)\nX, Y = np.meshgrid(X, Y)\n'''把x,y绘制对应到底面的面上去'''\nR = np.sqrt(X ** 2 + Y ** 2 + np.exp(np.pi))\nZ = np.tanh(R)\nax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow'))\n'''绘制3D cmap又一种方法'''\nax.contourf(X, Y, Z, zdir='z', offset=0.99987, cmap='summer')\n'''顺便在某平面画个等高线 zdir是决定从哪个方向压下去'''\nplt.show()\n\n", "Knowledge_Point": "应对NP完全问题", "Question": "matplotlib 3D绘图一个警告 请问怎么解决？\n代码内容\n\n\n\n\nimport\n matplotlib.pyplot \nas\n plt\n\nimport\n numpy \nas\n np\n\nfrom\n mpl_toolkits.mplot3d \nimport\n Axes3D\n\n\nfig = plt.figure()\n\n'''让下面的都在一个框框里面'''\n\nax = Axes3D(fig)\n\n\n'''绘制3D空间（坐标轴）'''\n\nX = np.arange(-\n4\n,\n4\n,\n0.25\n)\nY = np.arange(-\n4\n,\n4\n,\n0.25\n)\nX,Y = np.meshgrid(X,Y)\n\n'''把x,y绘制对应到底面的面上去'''\n\nR = np.sqrt(X**\n2\n + Y**\n2\n + np.exp(np.pi))\n\nZ = np.tanh(R)\n\nax.plot_surface(X,Y,Z,rstride=\n1\n,cstride=\n1\n,cmap=plt.get_cmap(\n'rainbow'\n))\n\n'''绘制3D cmap又一种方法'''\n\nax.contourf(X,Y,Z,zdir=\n'z'\n,offset=\n0.99987\n,cmap=\n'summer'\n)\n\n'''顺便在某平面画个等高线 zdir是决定从哪个方向压下去'''\n\n\nplt.show()\n\n\n\n图顺利出来，警告内容：\n\n\n\n\nMatplotlibDeprecationWarning: Axes3D(fig) adding itself to the figure is deprecated since 3.4. Pass the keyword argument auto_add_to_figure=False and use fig.add_axes(ax) to suppress this warning. The default value of auto_add_to_figure will change to False in mpl3.5 and True values will no longer work in 3.6.  This is consistent with other Axes classes.\n  ax = Axes3D(fig)\n\n\n\n\n如何解决警告的内容？", "Tag": "算法分析"}
{"Answer": "我改写了一下，效果一样速度应该可以快100倍吧\n\n    def __init_params(self, grayFrame):\n        for k in range(self.__defaultNbSamples):\n            c = np.random.randint(-1,2,size=(self.__Height,self.__Width))\n            self.__samples[k] = np.maximum(grayFrame + c, 0)\n", "Knowledge_Point": "应对NP完全问题", "Question": "Python运行vibe算法过慢\n现在在做毕设，有一部分要用到前景目标提取，我打算用VIBE算法来做，但是同样的算法，Python运行时初始化都要20-50s，我朋友用matlab基本就是1s内最多1s多一点就能完成初始化，虽然Python运行慢，但是也不至于慢这么多吧，而且理论上vibe算法的运行速度应该是比较快的，大佬们看一下是不是写的代码的问题。。。\n\n\n\ndef initial_background(I_gray, N):\n    t1 = cv2.getTickCount()\n    I_pad = np.pad(I_gray, 1, 'symmetric')#对称填充\n    height = I_pad.shape[0]\n    width = I_pad.shape[1]\n    samples = np.zeros((height, width, N))\n    t2 = cv2.getTickCount()\n    time = (t2 - t1) * 1000 / cv2.getTickFrequency()\n    print(time)\n    for i in range(1, height - 1):\n        for j in range(1, width - 1):\n            for n in range(N):\n                x, y = 0, 0\n                while (x == 0 and y == 0):\n                    x = np.random.randint(-1, 1)\n                    y = np.random.randint(-1, 1)\n                ri = i + x\n                rj = j + y\n                samples[i, j, n] = I_pad[ri, rj]\n    t3 = cv2.getTickCount()\n    time2 = (t3 - t1) * 1000 / cv2.getTickFrequency()\n    print(time2)\n    samples = samples[1:height - 1, 1:width - 1]\n    return samples\n\n\n\n\n上面是Python的初始化部分代码，大佬们帮忙看看这部分代码有哪些可以优化的。matlab代码我看不懂，也不知道该发哪个，第一次在CSDN上问问题，不知道会不会有人回答。。。", "Tag": "算法分析"}
{"Answer": "int是什么鬼？改成__init__，不然你都没有初始化model，导致你的model就是空的", "Knowledge_Point": "应对NP完全问题", "Question": "实现pytorch时出现空参数问题\n\n\nimport\n torch\n\nimport\n torch.nn \nas\n nn\n\nimport\n numpy \nas\n np\n\n\nx_train\n = [i for i \nin\n range(\n10\n)]\n\nx_train\n = np.array(x_train, dtype=np.float32)\n\nx_train\n.reshape(-\n1\n, \n1\n)\n\ny_train\n = [\n2\n * i + \n1\n for i \nin\n range(\n10\n)]\n\ny_train\n = np.array(y_train, dtype=np.float32)\n\ny_train\n.reshape(-\n1\n, \n1\n)\n\n\n\n\nclass\n \nMyModule\n(\nnn\n.\nModule\n):\n    def __int__(\nself\n, \ninput_dim\n, \noutput_dim\n):\n        super(\nMyModule\n, \nself\n).__int__()\n        self.linear = nn.\nLinear\n(1, 1)\n\n    def forward(\nself\n, \nx\n):\n        return self.linear(\nx\n)\n\n\n# 定义网络结果，损失函数，优化器\nif torch.cuda.is_available():\n    model = \nMyModule\n().cuda()\nelse:\n    model = \nMyModule\n()\nlea = 0.0001\noptimizer = torch.optim.\nSGD\n(\nmodel\n.\nparameters\n(), lr=lea)\ncriterion = nn.\nMSELoss\n()\nepochs = 10\nfor epoch in range(\nepochs\n):\n    optimizer.zero_grad()\n    if torch.cuda.is_available():\n        inputs = torch.from_numpy(\nx_train\n).cuda()\n        labels = torch.from_numpy(\ny_train\n).cuda()\n    else:\n        inputs = torch.from_numpy(\nx_train\n)\n        labels = torch.from_numpy(\ny_train\n)\n    outs = model(\nx_train\n)\n    loss = criterion(\nlabels\n, \ny_train\n)\n    loss.backward()\n    optimizer.step()\n    print('\nepoch\n {}\\\ntloss\n {}'.\nformat\n(\nepoch\n, \nloss\n))\n\n\n\n\n\n\npytorch版本   1.12.1+cu116\n代码如上，优化器那行报错了，如下。\nValueError: optimizer got an empty parameter list", "Tag": "算法分析"}
{"Answer": "使用where函数进行条件判断，代码这样写：\nimport numpy as np\na = np.array([[1,2,3],[4,5,6],[7,8,9]])\nb = np.array([[1,2,3],[4,5,6],[7,8,9]])\nc = np.array([[1,0,6],[8,0,0],[0,2,5]])\nd=np.where(c==0,a+b,a)\nprint(d)\n\n\n运行结果：\n[[ 1  4  3]\n [ 4 10 12]\n [14  8  9]]\n\n\n如有帮助 ，请点采纳 。", "Knowledge_Point": "应对NP完全问题", "Question": "关于python numpy ndarray 遍历太慢的问题\n假设有三个矩阵，如下\n\n\na\n = np.array([[\n1\n,\n2\n,\n3\n],[\n4\n,\n5\n,\n6\n],[\n7\n,\n8\n,\n9\n]])\n\nb\n = np.array([[\n1\n,\n2\n,\n3\n],[\n4\n,\n5\n,\n6\n],[\n7\n,\n8\n,\n9\n]])\n\nc\n = np.array([[\n1\n,\n0\n,\n6\n],[\n8\n,\n0\n,\n0\n],[\n0\n,\n2\n,\n5\n]])\n\n\n\n想通过判断c矩阵相应位置的值，来决定a相应位置的值是否与b相应位置的值相加，直接想到的做法是遍历，如下：\n\n\nfor\n \ni\n \nin\n range(\n3\n):\n    \nfor\n j \nin\n range(\n3\n):\n        \nif\n c\n[i]\n[j]\n==\n0\n:\n            \na\n[i]\n[j]\n = \na\n[i]\n[j]\n + \nb\n[i]\n[j]\n\n\n\n\n但当a,b,c都很大时运算相当慢，有没有这种运算的矢量写法来提升效率？不用for循环", "Tag": "算法分析"}
{"Answer": "python中按数字切片的时候, 是包含前面不包含后面. 类似于数学中的  [1:4)", "Knowledge_Point": "应对NP完全问题", "Question": "关于numpy切片的问题的疑惑\n我在学习numpy切片的时候碰到一个疑惑\n\n\n\n\n\nimport numpy as np\na = np.array([[11, 12, 13, 14, 15],\n              [16, 17, 18, 19, 20],\n              [21, 22, 23, 24, 25],\n              [26, 27, 28 ,29, 30],\n              [31, 32, 33, 34, 35]])\nprint(a[0, 1:4])\n\n\n\n结果为什么是\n\n\n\n\n\n[12 13 14]\n\n\n\n而不是\n\n\n\n\n\n[12 13 14 15]\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "fread(&pname, sizeof(pname), 1, np);你这个结构最后有个next指针，与文本的行信息不一致啊建议修改：char buf[200];fgets(buf,200,np);sscanf(buf,\"%s %d %s %s %s %d %d %d %s %s\",pname.name,&pname->age,pname.sex,pname.tele,.....);", "Knowledge_Point": "应对NP完全问题", "Question": "从文件里读取数据调试发现字符串中的字符无效\n//我定义的链表\ntypedef struct stuffsystem\n{\n    char name[name1];\n    int age;\n    char sex[sex1];\n    char tele[tele1];\n    char sectionname[name1];\n    int latawork;//迟到早退的数量\n    int workextra;//加班的数量\n    int achieve;//个人创收\n    char addr[addr1];\n    char educ[educ1];\n    struct stuffsystem* next;\n}linklist;\n\n\n//相关函数\nint judgename(char name[name1])\n{\n    int input = 0;\n    FILE* np;\n    linklist pname;\n    if ((np = fopen(\"stuff.txt\", \"r\")) == NULL)\n    {\n        printf(\"警告！员工信息数据库丢失，请尽快找回\\n\");\n        exit(0);\n    }\n    fread(&pname, sizeof(pname), 1, np);\n    while (!feof(np))\n    {\n        if (!strcmp(pname.name, name))\n        {\n            input = 0;\n            fclose(np);\n            return input;\n        }\n        fread(&pname, sizeof(pname), 1, np);\n    }\n    fclose(np);\n    return input;\n}\n\n\n//调试截图\n\n\n\n\n//被读取的文件\n\n\n\n\n想知道问题出在哪里呀", "Tag": "算法分析"}
{"Answer": "axis=-1，其实也就等于axis=2。因为这是个三维矩阵，所以axis可能的取值为0,1,2，所以最后一个就是2。你可以自己试试看两个取值结果是否相同。望采纳哦！！！", "Knowledge_Point": "应对NP完全问题", "Question": "numpy基础问题数组拼接\ntimes=np.concatenate((time0,time1),-1)\n这个是数组拼接，那么-1是按行还是列拼接啊？我没有查到", "Tag": "算法分析"}
{"Answer": "comment表示注释，解析时不把它当成真正的数据，也就是把那行忽略掉\r\n\r\napi里面的解释：\r\n```\r\n comments : str, optional\r\n        The character used to indicate the start of a comment.\r\n        All the characters occurring on a line after a comment are discarded\r\n```\r\n\r\n如果data:开头的是数据，就该把comments设为None（如有注释行，就该是注释行标记符）\r\n要么在读取文本前把前面的data处理掉，要么在得到数组后把第一个元素(data:编程了nan，表示非数字)去掉", "Knowledge_Point": "应对NP完全问题", "Question": "关于numpy中的genfromtxt方法的参数设定问题？\n请教一下，现在我想把一个utf-8编码的txt文件导入为一个numpy数组，txt文件内容如下：\n\n\n\n导入数据如下：\n\ndata:1,10,100,1000,10000,100000,1000000,10000000\n\ndata:1,2,4,8,16,32,64,128\n\n请找出数据的递增规则\n\n\n\n我写的代码如下：\n\n\n\na=np.genfromtxt('data.txt',delimiter=',',comments='data:',skip_header=1,skip_footer=1,encoding='utf-8')\na\n\n\n\n\n输出结果是：array([], dtype=float64) 看上去应该是一个空数组，我尝试把中间两条数据记录前面的data：去掉即可正常读取数据，推测是comments参数设置的问题，可否指导一下应该怎么修改啊？", "Tag": "算法分析"}
{"Answer": "我大概猜到了，因为精度很小的时候，在靠近0的地方类似于无穷小，然后1/无穷小就得到了无穷大。\n然后接着y轴为了显示出无穷大的数据，就被无限地拉伸，然后图像看起来就是错误的了。\ny轴的刻度值验证了我的这一猜想。\n\n应该可以用设置xy等比例或者设置值域的方法来解决。", "Knowledge_Point": "应对NP完全问题", "Question": "Matplotlib为什么无法绘制高精度的反比例函数？\n我用Python的matplotlib库绘制了反比例函数，当x步长很小时，得出的图像是错误的，请问这是为什么？\n\n\n\n代码：\n\n\n\n步长为0.001（错误图像）\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(-10, 10, 0.001)\ny = 1/x\nplt.plot(x, y)\nplt.show()\n\n\n\n\n\n\n步长为0.5（正确图像）：\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.arange(-10, 10, 0.5)\ny = 1/x\nplt.plot(x, y)\nplt.show()\n\n\n\n\n\n\n\n\n \n\n", "Tag": "算法分析"}
{"Answer": "请看👉 ：推荐系统之LFM算法详解", "Knowledge_Point": "应对NP完全问题", "Question": "LFM（隐语义模型）算法的实现\n做推荐系统的，下面是部分数据集\n\n\ndtype=[(\n'userId'\n,np.int32),(\n'movieId'\n,np.int32),(\n'rating'\n,np.float32)]\ndataset=pd.read_csv(DATA_PATH,usecols=\nrange\n(\n3\n),dtype=dtype) \n# 读取csv文件\n\nusers_ratings=dataset.groupby(\n'userId'\n).agg([\nlist\n])\nitems_ratings=dataset.groupby(\n'movieId'\n).agg([\nlist\n])\n\n# User-LF  10 代表 隐含因子个数是10个\n\nP = \ndict\n(\nzip\n(users_ratings.index,np.random.rand(\nlen\n(users_ratings),\n10\n).astype(np.float32)\n        ))\n\n# Item-LF\n\nQ = \ndict\n(\nzip\n(items_ratings.index,np.random.rand(\nlen\n(items_ratings),\n10\n).astype(np.float32)\n        ))\n\n\n# 梯度下降优化损失函数\n\n\nfor\n i \nin\n \nrange\n(\n15\n):\n        \nprint\n(\n'*'\n * \n10\n, i)\n        \nfor\n uid, iid, real_rating \nin\n dataset.itertuples(index=\nFalse\n):\n                \n# 遍历 用户 物品的评分数据 通过用户的id 到用户矩阵中获取用户向量\n\n                v_puk = P[uid]\n                \n# 通过物品的uid 到物品矩阵里获取物品向量\n\n                v_qik = Q[iid]\n                \n# 计算损失\n\n                error = real_rating - np.dot(v_puk, v_qik)\n                \n# 0.02学习率 0.01正则化系数\n\n                v_puk += \n0.02\n * (error * v_qik - \n0.01\n * v_puk)\n                v_qik += \n0.02\n * (error * v_puk - \n0.01\n * v_qik)\n\n                P[uid] = v_puk\n                Q[iid] = v_qik\n\n\n\nv_puk += 0.02 * (error * v_qik - 0.01 * v_puk)  主要是这个向量的更新我不明白，为啥这么更新的", "Tag": "算法分析"}
{"Answer": "你只是赋值,没显示呀\r\nplt.show()看看", "Knowledge_Point": "应对NP完全问题", "Question": "用vscope编写python程序，运行后无结果显示？\nimport numpy as np\n\nimport matplotlib.pyplot as plt \n\nt = np.arange(0, 4, 0.1)\n\nplt.plot(t,t,t,t+2,t,t**2)\n\n\n\nnumpy包和matplotlib都安装到最新版本。\n", "Tag": "算法分析"}
{"Answer": "该回答内容部分引用GPT，GPT_Pro更好的解决问题\nimport numpy as np \n#二维数组，用来存储7个区间的范围\nintervals = [[133445, 3344647621]] \n\n# 选出四个不重复的区间\nselected_intervals = np.random.choice(intervals, size=4, replace=False) \n\n# 在这四个区间里随机抽取一个数\nrandom_number = np.random.choice(selected_intervals) \n\nprint(\"随机选取的数字是：\", random_number) \n\n上面的代码实现了从7个区间中随机抽取4个不重复的区间，然后再从这4个区间中随机抽取一个数的功能。具体步骤如下：\n首先，我们使用numpy中的np.random.choice函数，从7个区间中随机抽取4个不重复的区间；然后，我们再使用numpy中的np.random.choice函数，从这4个区间中随机抽取一个数；最后，将结果打印出来。如果回答有帮助，望采纳。", "Knowledge_Point": "应对NP完全问题", "Question": "Python；挑战性；随机数\n先用一个二维数组来存储区间范围[[1\n33145], [33146\n47621],]（一共7个区间）\n然后 np.random.choice(n, size=4, replace=False)选出四个不重复的区间\n最后再这四个区间里np.random.choice直接取一个数\n\n\n这种代码具体怎么写呢，研究一晚上老是报错", "Tag": "算法分析"}
{"Answer": ".name取他的列名。觉得有帮助还请点采纳哦", "Knowledge_Point": "应对NP完全问题", "Question": "DataFrame中的name属性值\na = pd.DataFrame(np.arange(12).reshape(3,4),index=list(\"abc\"),columns=list(\"vxyz\"))\na = a.apply(lambda m:np.square(m) if m.name == \"x\" else m)\nprint(a)\n\n\nm.name是什么意思，DataFrame中的name属性值是什么？", "Tag": "算法分析"}
{"Answer": "后面不是有个 ->吗，它定义了返回类型，你可以点进去看看，不过直接看下面return的是什么就行。对象.属性 这就已经得到一个返回值了，如果结果是如int类型这样的数字123，那肯定123()不行，但这里返回的是_LocIndexer处理实例化后的对象，那它后面是能加括号的。 希望能帮助到你，谢谢。", "Knowledge_Point": "应对NP完全问题", "Question": "pandas里面loc方法是属性方法有@property装饰器，但是为什么df.loc()系统不报  \" is not callable\"的错？\n代码如下;\n\n\nimport\n pandas \nas\n pd\n\nimport\n numpy \nas\n np\ndata = {\n'name'\n: [\n'Joe'\n, \n'Mike'\n, \n'Jack'\n, \n'Rose'\n, \n'David'\n, \n'Marry'\n, \n'Wansi'\n, \n'Sidy'\n, \n'Jason'\n, \n'Even'\n],\n        \n'age'\n: [\n25\n, \n32\n, \n18\n, np.\nnan\n, \n15\n, \n20\n, \n41\n, np.\nnan\n, \n37\n, \n32\n],\n        \n'gender'\n: [\n1\n, \n0\n, \n1\n, \n1\n, \n0\n, \n1\n, \n0\n, \n0\n, \n1\n, \n0\n],\n        \n'isMarried'\n: [\n'yes'\n, \n'yes'\n, \n'no'\n, \n'yes'\n, \n'no'\n, \n'no'\n, \n'no'\n, \n'yes'\n, \n'no'\n, \n'no'\n]}\n\nlabels = [\n'name'\n, \n'age'\n, \n'c'\n, \n'd'\n, \n'e'\n, \n'f'\n, \n'g'\n, \n'h'\n, \n'i'\n, \n'j'\n]\ndf = pd.DataFrame(data, \nindex\n=labels)\ndf.loc()\n\n\n\n按住CTRL鼠标点击loc，定位到loc函数，发现loc是属性方法，带有\n@property装饰器如图所示：\n\n\n\n\n问题：\n既然loc是属性方法，那代码中 \ndf.loc()\n应该报错 如“”\n* is not callable“才对吧？为什么系统不会报错？", "Tag": "算法分析"}
{"Answer": "请在你的python里执行以下代码之后再进行后续计算：\n\nimport os\nos.system('pip install numpy')\n", "Knowledge_Point": "应对NP完全问题", "Question": "pathon import 模块名\n\n\n\n\n刚刚\n学到这里的时候不大清楚是该提前创建np吗\n感觉这块不对后面from import 也是错的", "Tag": "算法分析"}
{"Answer": ".el-cascader-node 元素生成后移除aria-owns属性\n在options加载完成后添加代码：\nthis.$nextTick(() => {\n     // 添加这段代码\n      const $el = document.querySelectorAll('.el-cascader-panel .el-cascader-node[aria-owns]');\n      Array.from($el).map((item) => item.removeAttribute('aria-owns'));\n});\n\n", "Knowledge_Point": "搜索问题", "Question": "elmentui el-cascader 级联选择器，搜索次数过多导致界面卡死\nel-cascader控件不断进行搜索，选择，删除，大概10多次后，界面卡死崩溃", "Tag": "算法分析"}
{"Answer": "PUT /test_analyzer\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"test_analyzer\": {\n          \"tokenizer\": \"ik_max_word\",\n          \"char_filter\": \"patten_char_filter\",\n          \"filter\": \"stop_filter\"\n        }\n      },\n      \"char_filter\": {\n          \"patten_char_filter\": {\n          \"type\" : \"pattern_replace\",\n          \"pattern\" : \"-\",\n          \"replacement\" : \" \"\n        }\n      },\n      \"filter\": {\n        \"stop_filter\": {\n          \"type\"      : \"stop\",\n          \"stopwords\" : [\"t\"]\n        }\n      }\n    }\n  }\n}\n \n \nGET /test_analyzer/_analyze\n{\n  \"analyzer\": \"test_analyzer\", \n  \"text\": \"Special Feature Note for T972-SE.pdf\"\n}\n", "Knowledge_Point": "搜索问题", "Question": "IK 分词，当英文与数字 混合搜索时，遇到 Elasticsearch 分词问题 。\n一、遇到问题的现象描述\n1.1 英文和特殊字符连在一起的的分词，比如 Special Feature Note for T972-SE.pdf\n1.2 使用 ik_smart 会直接分词为 t972-se.pdf\n1.3 使用 ik_max_word 会分词为：\n\n\n\n\n\n\n二、希望达到的效果\n2.1 要求分词为 t972 和 se，且不分词成单独 t\n2.2 使用的 ik 的自定义字典， 将 - 作为单词， 只对 ik_max_word 起作用，对 ik_smart 无效\n2.3 要求不能 搜 t 搜出来结果\n\n\n三、我尝试的解决办法\n3.1  我还使用了 字符过滤器 char_filter\n3.2  处理了特殊字符，使用的自定义分词器为 my_analyzer，也有分出单个字符\n3.3  T972-SE.pdf 把这个当做分隔符，横杠，也试过。\n3.4  标准分词器不能对中文分词，也不支持大小写，所以只能用IK。\n\n\n\n\n四、操作环境、软件版本\n4.1 IK 与 ES，都是6.4.3\n4.2 操作系统使用 Linux\n\n\n五、麻烦看看，如何收费\n5.1 我认可知识付费。\n5.2 可以根据标准，提供收费方式。", "Tag": "算法分析"}
{"Answer": "建议你看下这篇博客👉 ：vue---el-select下拉框实现全选功能", "Knowledge_Point": "搜索问题", "Question": "vue3 el-select搜索文本全选问题\nvue3中，el-select选择框，启用远程搜索，但是搜索结果没有回车事件执行的快，我想在回车事件里面全选输入的文本，这样等加载完成后无匹配可以直接再次输入，不需要清空操作\n代码如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n效果希望如下：\n\n\nwindows操作环境\n软件：VSCode\n语言：vue3+ts+element-plus\n\n\n希望各位看到的时候，顺手给个回复哦", "Tag": "算法分析"}
{"Answer": "访问频率别太快，加个延时试试。。。如果偶尔成功，偶尔出问题的话，那试试retry", "Knowledge_Point": "搜索问题", "Question": "python 爬虫 登录知乎后搜索 某些文章 遇到的问题\n像是这样\n\n\n", "Tag": "算法分析"}
{"Answer": "\nI think array_unique is slower than in_array but it makes sense if you want to search the array more than one time or if you want to save memory.\nAnother option is to use array_flip (which will also drop duplicate keys) and then use isset or array_key_exists since they are way faster than in_array, personally I would go this way.\n", "Knowledge_Point": "搜索问题", "Question": "PHP性能问题：更快地将重复项留在将要搜索的数组中或执行array_unique？\n\n\n\nI have code that adds values to an array. The array is later searched in another part of my code. The values that are added to the array are not necessarily unique, so it's possible to end up with duplicate values in the array being searched. Technically speaking, even with the duplicates present in the array being searched, my code works fine and I'll be able to find the value. I just want to know if the value is in the array being searched, and don't care if it's in the array 1 time or 10,000 times.\n\n\n\nMy question is whether it's preferred (for performance and/or style reasons) to do array_unique() on my array being searched before I do the search.\n\n\n\nSo for example, suppose I want to search an array like this:\n\n\n\n$searchMe = Array(\"dog\", \"cat\", \"mouse\", \"dog\", \"dog\", \"dog\");\n\n\n\n\nNote that \"dog\" is present 4 times. If I want to search for the value \"dog\", in that array, it will work fine and I will be able to tell that it's present. As mentioned above, I don't care how many times it's present, I just want to know if it's present at all.\n\n\n\nSo should I do this first before searching and then search against the de-duped array?\n\n\n\n$searchMe_cleaned = array_unique($searchMe);\n\n\n\n\nI.e., will that be faster than just searching the array with the duplicates?\n\n\n\nPlease keep in mind that although in this example the array being searched just has a few elements, the real array being searched could have hundreds or thousands of elements.\n\n\n\nThanks!\n\n    ", "Tag": "算法分析"}
{"Answer": "==和=的区别。if (target =nums[mid])应该用双等号，否则一定是True。最开始int mid = left + (right - left) / 2;这一句等于1，然后直接就返回了。这也就是为什么你的程序会返回1", "Knowledge_Point": "搜索问题", "Question": "搜索插入位置，有一个问题\nclass Solution\n{\npublic:\n    int searchInsert(vector\n& nums, int target)\n    {\n        int ans;\n        int n = nums.size();\n        int left = 0;\n        int right = n - 1;\n        while (left <= right)\n        {\n            int mid = left + (right - left) / 2;\n            if (target =nums[mid])\n            {\n                return mid;\n            }\n            if (target <=nums[mid])\n            {\n                right = mid - 1;\n            }\n            else\n            {\n                left = mid + 1;\n            }\n        }\n        return 0;\n    }\n};\n\n\n我知道我写的有问题，我想知道为什么这个测试用例，会输出为1，我认为无论如何他输出的都是2，来个大佬给我讲讲为什么会输出为1，我觉得极其不科学\n输出用例1，3，5，6\n力扣原题，可以去力扣编译器上试试\n我怀疑人生了，c++", "Tag": "算法分析"}
{"Answer": "from collections import defaultdict\r\ndef CellIndexDict(cells,cell_list):\r\n\t\tallcellindexDict=defaultdict(list)\r\n    for i,v in enumerate(cell_list)：\r\n\t\t\t\tallcellindexDict[v].append(i)\r\n    return  allcellindexDict       ##如果想做一个key值检查，本行可以改为 return ｛key：allcellindexDict[key] for key in cells｝", "Knowledge_Point": "搜索问题", "Question": "python 提升匹配效率的问题\n用列表1（set集合） 匹配 列表2内元素（有重复元素），然后将列表1内每个元素对应列表2的索引集合组合成字典，但我发现一但·行数达到几十万条时后，匹配效率太低，匹配次数为len（列表1）*len（列表2）.，，请问下有各位老大没有什么好的方法提升效率，或者有没有其他实现方法，怎么实现或者修改？。下面举个栗子：\n\n\n\ndef CellIndexDict(cells,cell_list):\n    \"\"\"根据cells列表内的清单，匹配出cell_list列表内所在的索引，制成字典｛cell:[indexhub]｝\n    \"\"\"\n    allcellindexDict={}\n    for c in cells:\n        indexlist=[i+1 for i,v in enumerate(cell_list) if v==c]\n        allcellindexDict[c]=indexlist#单个小区索引集合\n    return allcellindexDict\n\ncells=[\"a\",\"aa\",\"aaa\",\"b\",\"bb\",\"bbb\",\"c\",\"cc\",\"ccc\"]\ncell_lists=[\"a\",\"aa\",\"aaa\",\"b\",\"bb\",\"bbb\",\"c\",\"cc\",\"ccc\"]*1000000\n\n", "Tag": "算法分析"}
{"Answer": "a href=\"javascript:void(0);\" onclick=\"函数\"\r\n//javascript:void(0)，执行空链接，避免链接直接暴露在状态栏", "Knowledge_Point": "搜索问题", "Question": "请教一个JSP href和onclick的问题\n我以前的链接，是写在href中的，现在我不想用超链接了，想用按钮实现，请问按钮中\n\nonclick应该怎么写呀？我直接复制进去发现不行\n\n这是我的代码:\n\n\n\n添加商品\n高级搜索\n\n\n\n\n现在我想用按钮实现\n\n\n\n \n\n\n\n\n就拿“添加商品”功能来说吧，这个onclick应该怎么写呀？涉及到c标签和servlet。\n\n 我的项目名叫goods", "Tag": "算法分析"}
{"Answer": "你写demo的话，业务简单得一批，哪能感觉得出来，生产上微服务系统基本会注册到注册中心，没有绝对的生产者和消费者，特别是引入网关以后，你所谓的消费者，相对于网关来说，它也变成了生产者", "Knowledge_Point": "搜索问题", "Question": "关于#分布式#的问题：今天学习SpringCloud看视频上的那个人把消费者也注册到了注册中心上，搜索了也没有看到满意的答案\n分布式微服务 有必要将消费者注册到注册中心吗？今天学习SpringCloud看视频上的那个人把消费者也注册到了注册中心上，但是我感觉不用吧，搜索了也没有看到满意的答案。", "Tag": "算法分析"}
{"Answer": "\nYes. It's called a Type switch. It allows you to execute code depending on the actual type of the interface you pass.\nI think the official documentation, with its example, is clear :\n\nA switch can also be used to discover the dynamic type of an interface\n  variable. Such a type switch uses the syntax of a type assertion with\n  the keyword type inside the parentheses. If the switch declares a\n  variable in the expression, the variable will have the corresponding\n  type in each clause. It's also idiomatic to reuse the name in such\n  cases, in effect declaring a new variable with the same name but a\n  different type in each case.\n\nvar t interface{}\nt = functionOfSomeType()\nswitch t := t.(type) {\ndefault:\n    fmt.Printf(\"unexpected type %T\", t)       // %T prints whatever type t has\ncase bool:\n    fmt.Printf(\"boolean %t\n\", t)             // t has type bool\ncase int:\n    fmt.Printf(\"integer %d\n\", t)             // t has type int\ncase *bool:\n    fmt.Printf(\"pointer to boolean %t\n\", *t) // t has type *bool\ncase *int:\n    fmt.Printf(\"pointer to integer %d\n\", *t) // t has type *int\n}\n\nYou should not use that too often in a properly typed program but it's convenient when you need it. An example of use : Suppose you implement a database driver, you may have to do conversions depending on the type of the Go variables. Here's an extract of the go-sql/mysql driver :\n// Scan implements the Scanner interface.\n// The value type must be time.Time or string / []byte (formatted time-string),\n// otherwise Scan fails.\nfunc (nt *NullTime) Scan(value interface{}) (err error) {\n    if value == nil {\n        nt.Time, nt.Valid = time.Time{}, false\n        return\n    }\n\n    switch v := value.(type) {\n    case time.Time:\n        nt.Time, nt.Valid = v, true\n        return\n    case []byte:\n        nt.Time, err = parseDateTime(string(v), time.UTC)\n        nt.Valid = (err == nil)\n        return\n    case string:\n        nt.Time, err = parseDateTime(v, time.UTC)\n        nt.Valid = (err == nil)\n        return\n    }\n\n    nt.Valid = false\n    return fmt.Errorf(\"Can't convert %T to time.Time\", value)\n}\n\n", "Knowledge_Point": "搜索问题", "Question": "在交换机中使用时，关键字类型是什么意思？\n\n\n\nI have seen several instances of this code in golang:\n\n\n\nfunc process(node ast.Node) Foo {\n    switch n := node.(type) {\n        // ... removed for brevity\n    }\n}\n\n\n\n\nast.Node\n is an interface. Is the \nnode.(type)\n snippet code to perform reflection; to find out the actual implementers of the interface ?\n\n    ", "Tag": "算法分析"}
{"Answer": "第二次搜索有触发该函数么，最好debug下看看能不能走到if(select_name != \"\")里面", "Knowledge_Point": "搜索问题", "Question": "第一次selected属性是加上了且选中，第二次搜索这个人虽然加上了但没有选中\n就是这样，我在搜索框里输入了某个人的名字，然后触发下面这个js,第一次selected属性是加上了且选中，第二次搜索这个人虽然加上了但没有选中\n\nfunction selectname(){\n\n        select_name = name1.value;\n\n        select_name2=\"\";\n\n        $(\"#available_columns option:contains(\"+select_name2+\")\").attr(\"selected\", false);\n\n        if(select_name != \"\"){\n\n            $(\"#available_columns option:contains(\"+select_name+\")\").attr(\"selected\", true);\n\n            select_name2=select_name;\n\n        }\n\n    }\n\n\n\n各位大神，请问有什么问题呢？", "Tag": "算法分析"}
{"Answer": "实现setOnFocusChangeListener中的onFocusChange方法，在hasFocus中有一个boolean型参数。当它是false时，光标就会转到另一个控件。\r\n\r\n    EditText txtEdit= (EditText) findViewById(R.id.edittxt);\r\n    \r\n     txtEdit.setOnFocusChangeListener(new OnFocusChangeListener() {          \r\n    \r\n            public void onFocusChange(View v, boolean hasFocus) {\r\n                if(!hasFocus)\r\n                   //do job here owhen Edittext lose focus \r\n            }\r\n        });", "Knowledge_Point": "搜索问题", "Question": "如何知道一个edittext失去焦点\n我需要捕捉一个edittext什么时候失去了焦点。我在用户的问题里搜索，但是没有发现任何答案。我使用以下的focuschangelistener事件：\n\n\n\nOnFocusChangeListener foco = new OnFocusChangeListener() {\n\n    @Override\n    public void onFocusChange(View v, boolean hasFocus) {\n        // TODO Auto-generated method stub\n\n    }\n};\n\n\n\n\n但还是捕捉不到，请求大家给点指点，谢谢！", "Tag": "算法分析"}
{"Answer": "在开头添加import re,你没有导入这个模块。", "Knowledge_Point": "搜索问题", "Question": "Python执行时，re.search报错，求原因及解决方案。\n执行以下代码时，re.search报错。按理说我代码没啥问题，不知道怎么回事。求大神帮助！\n\n\n\nhand=open(\"regex_sum_42.txt\")\nfor line in hand:\n    line=line.rstrip()\n    if re.search(\"Why\",line):\n        print(line)\n\n\n\n\n执行结果：\n\nTraceback (most recent call last):\n\n  File \"task1.py\", line 4, in \n\n    if re.search(\"Why\",line):\n\nNameError: name 're' is not defined", "Tag": "算法分析"}
{"Answer": "不一定要用传统的关系型数据库，可以尝试用NoSQL", "Knowledge_Point": "搜索问题", "Question": "如何用有限的表结构存储海量的对象-属性-值三元组并兼顾搜索效率？\n其中值的类型有多种。下面是我设计的表结构：\n主表：rel_id int, obj_id int, prop_id int, val_type int\n对象描述表：obj_id int, obj_desc string\n属性描述表：prop_id int, prop_desc string\n值是布尔值的表（类型为1）：rel_id int, val_bool boolean\n值是整数的表（类型为2）：rel_id int, val_int int\n值是时间的表（类型为3）：rel_id int, val_dt datetime\n其他类型的值同理。\n其中某个对象具有哪些属性不是定死的，是可以由用户添加的。比如一个属性为长度值是整数 42 的三元组用以下的方式存储：\n主表：1,1,1,2\n属性描述表：1,\"长度\"\n值是整数的表：1,42\n我觉得我的这个方法可以帮助理解我的这个问题，所以就加上了。应该有更好的方法吧？另外不知道我的方法有没有什么致命的缺点。\n我觉得维基数据解决的问题跟我要解决的问题类似，但是维基数据的的表结构我有点看不懂。这个好像就是维基数据的表结构：\nhttps://doc.wikimedia.iwiki.eu.org/Wikibase/master/php/md_docs_topics_storage.html#sql_tables\n 。感觉维基数据把属性存放在 JSON 里了，这样的话搜索效率难道不会很低下吗？", "Tag": "算法分析"}
{"Answer": "使用BaseAdapter, new AlertDialog.Builder(getContext()).setAdapter(),然后把数据list交给listadapter,有数据更新时，使用adapter的notifyDataSetChanged()方法就可以了", "Knowledge_Point": "搜索问题", "Question": "android 单选弹框数据源问题\n我实现了点击按钮搜索蓝牙设备功能，开始是显示在同一界面中的，\n\n但是现在我想要点击按钮弹出单选列表弹框，单选列表中的数据能实时更新，\n\n就是一有蓝牙就显示出来，然后选中一个能进行相应操作，我用安卓系统带的AlertDialog\n\n但是我不知道setSingleChoiceItems（）里数据源该如何绑定好？\n\n我原始列表实现的部分代码见下：\n\n\n\nprivate LinearLayout mPairedLayout;\nprivate ArrayList mPairedDevicesList = new ArrayList();\nmBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\nSet pairedDevices = mBluetoothAdapter.getBondedDevices();\nmPairedDevicesList.clear();\nmPairedLayout.removeAllViews();\nLayoutInflater inflater = LayoutInflater.from(getActivity());\nif (pairedDevices.size() > 0) {\n            for (BluetoothDevice device : pairedDevices) {\n                LinearLayout detail = (LinearLayout) inflater.inflate(R.layout.row_devices, null);\n                ((TextView) detail.findViewById(R.id.device_name)).setText(device.getName());\n                ((TextView) detail.findViewById(R.id.device_details)).setText(device.getAddress());\n                detail.findViewById(R.id.icon).setVisibility(View.GONE);\n                mPairedLayout.addView(detail);\n                detail.setOnClickListener(bluetoothConnect);\n                detail.setTag(device.getAddress());\n                mPairedDevicesList.add(getString(R.string.paired) + device.getName() + \"\\n\" + device.getAddress());\n            }\n\n\n\n\n\n这样就是搜索到的都保存在mPairedDevicesList，只能每次点按钮搜索一次显示出来，不能实时显示，如果中途有新设备发现的话不会继续接着在mPairedLayout中显示；现在我想改成这样：\n\n\n\n //点击搜索按钮弹出设备列表界面\n    private void searchBluetoothDevice1(){\n        new AlertDialog.Builder(getActivity())\n        .setTitle(getString(R.string.btdialog_title))\n        .setNegativeButton(getString(R.string.cancel), null)\n        .setPositiveButton(getString(R.string.connect),  new DialogInterface.OnClickListener() {\n\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                // TODO Auto-generated method stub\n\n            }\n        })\n        .setSingleChoiceItems(new String[] {\"choice1\",\"choice2\",\"choice3\"}, -1, \n                new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        // TODO Auto-generated method stub\n\n                    }\n                })\n        .show();\n\n    }\n\n\n\n\n\n问题是这个setSingleChoiceItems里第一个参数要怎么写好？怎么保证实时更新数据呢", "Tag": "算法分析"}
{"Answer": "hql写是可以写, 也就是用like来匹配这些tag,都匹配上了就OK了, 不过我估计性能不怎么样, 每个tag都得 like '%tag%'一次, 而且还是全部满足.一般的做法就是在数据库中做个全文索引, 也就是传说中的Lucene了, 然后检索出符合的tag, 返回符合的记录(可以从检索的结果中拿到该条记录的id的)", "Knowledge_Point": "搜索问题", "Question": "hibernate的查询问题\n现在很多网站都在使用TAG，请问下，如果要搜出当且仅当所有的TAG都被满足时，才把记录取出来，hql支持这种方法吗？\n\n比如：\n\n\n\n搜索 美食，餐厅\n\n需要的结果是 只有这两个标签的数据才被搜出，多一个少一个都不行，能做到吗？", "Tag": "算法分析"}
{"Answer": "修改sql语句为：\nselect * from user where id = $key or name = $key or idcard = $key\n\n$key是你前端输入的值", "Knowledge_Point": "搜索问题", "Question": "前端数据转后端实现动态SQL功能问题\n您好，我现在使用SSM框架，目前后端使用了Mybatis的动态SQL，现在想实现前端输入任意值(比如select * form user where 要拼接部分)，SQL就会按照任意值拼接到Sql语句中，但是在前端转pojo类的过程中，前端name的值可能是根据id查找，根据name查找，根据idcard查找，这样的话前端name的属性不是固定的，而且还要判断用户输入的值是id还是name还是idcard，这样的话怎么解决能让我实现一个搜索框内输入用户的id或者name或者idcard都可以在这个搜索框内搜索到这个用户的所有相关信息", "Tag": "算法分析"}
{"Answer": "单源即一个出发点到其他各点的距离多源即计算所有出发点到各点的距离两种算法本质上都是计算点到点的最短距离，只是一个一次只能算一个点，一个一次计算全部点，如果前者加上循环就和后者在结果上没有区别了", "Knowledge_Point": "搜索问题", "Question": "图的最短路算法中，单源最短路问题和全源最短路问题，这里的单源和全源是什么意思？\n初学图的最短路，发现书上有提到dijkstra解决单源最短路问题，Floyd解决全源最短路问题，但是书上没有解释这里的单源和全源是什么意思，指的是什么？", "Tag": "算法分析"}
{"Answer": "用findall查找即可匹配所有结果", "Knowledge_Point": "搜索问题", "Question": "如何解决re. compile只匹配一次的问题？\n想做一个简单的文本提取，代码如下：\nimport re\npattern = re.compile(ur'我喜欢吃(.*?)(， | 。)')\nstr = u'我喜欢吃苹果，与此同时我喜欢吃香蕉。'\nprint(pattern.search(str))\n现在这个代码有两个问题，一是在ur之后的引号位置会报错，提示非法字符，但去掉u之后可以正常运行；二是即使正常运行，最后的结果也只有“我喜欢吃苹果，”，并没有对后面一句话进行搜索匹配。\n程序文盲，求大佬解答。", "Tag": "算法分析"}
{"Answer": "google里搜索 site:ask.csdn.net 关键字", "Knowledge_Point": "搜索问题", "Question": "CSDN 如何搜索自己感兴趣的问题回答？\n    想在问答板块来回答问题，但是只能一页一页的翻看问题，不能直接找到自己擅长的领域来回答，请问有没有搜索自己擅长问题的方法？\n", "Tag": "算法分析"}
{"Answer": "[quote]如果在制定的项目中搜索包含person的文件啊[/quote]\r\n\r\n是指文件名包含person还是文件内容包含person呢？\r\n\r\n如果是文件名，不用eclipse，windows本身的搜索功能可以做。\r\n\r\n如果是文件内容，那么:\r\nctrl+h --- File Search Tab --- 在containing text里输入person，搜索就可以了", "Knowledge_Point": "搜索问题", "Question": "请问Eclipse中点击ctrl h打开搜索界面，如果在制定的项目中搜索包含person的文件啊\n经常是搜索整个workspace，找不到如何指定项目", "Tag": "算法分析"}
{"Answer": "首先temp.next = null 的话，那个temp.per.next 是 说明temp的上一个节点指向null 也就删除掉了当前元素。如果在执行下面那行的话，null 哪来的next和 per。对吧temp.next != null 的话下面这行temp.next.per = temp.per 就是 将temp 的下一个节点的\" per \"地址指向当前temp 的上一个节点temp.per这样temp 就彻底删除了。", "Knowledge_Point": "双链表", "Question": "125行，当temp是最后一个节点，左边temp.next是空了，右边指向左边为什么不是空指针的\n", "Tag": "数据结构"}
{"Answer": "\n\n```python\nclass Node:\n    def __init__(self,data):\n        self.data = data\n        self.next = None\n        \ndef createByTail(a):\n    head = Node(-1)\n    tail = head\n    for i in range(len(a)):\n        p = Node(a[i])\n        tail.next = p\n        tail = p\n\n    return head\n\ndef output(head):\n    p = head.next\n    while p!=None:\n        if p!= head.next:\n            print(' ',end='')\n        print(p.data,end='')\n        p = p.next\n    print()\n\ndef reverse(head):\n    p = head.next\n    head.next = None\n    while p != None:\n        q = p\n        p = p.next\n        q.next = head.next\n        head.next = q\n\nif __name__ == '__main__':\n    T = int(input())\n    for t in range(T):\n        a = list(map(int,input().split()))\n        a = a[:len(a)-1]\n        h = createByTail(a)\n        reverse(h)\n        output(h)\n\n\n\n\n```", "Knowledge_Point": "双链表", "Question": "有一个整数单链表L，设计一个算法逆置L中的所有节点。直接把代码给我", "Tag": "数据结构"}
{"Answer": "妥妥的不对，栈只能在栈顶操作，队列在尾部添加元素，首部删除元素，而且栈一端封闭。但是链表可以在任意位置插入，删除数据，只从这个特点来看说法就不对", "Knowledge_Point": "双链表", "Question": "在网上看到有说双向链表从左边看是栈，从右边看是队列，请问这种说法正确吗", "Tag": "数据结构"}
{"Answer": "```\r\nclass Node\r\n{\r\npublic Node prev;\r\npublic T data;\r\npublic Node next;\r\n}\r\nclass DualLinkedList\r\n{\r\npublic Node header;\r\n}\r\n主程序里面用\r\nDualLinkedList> mylist = new DualLinkedList>();\r\n这样，mylist的每个成员也是一个双链表\r\n```", "Knowledge_Point": "双链表", "Question": "怎么在java里写一个用双链表，而且链表里每一个节点还存着双链表，有没有例子呢，我该怎么让才能在最外面的main方法里使用链表里的链表呢？？？\n求大佬们解答", "Tag": "数据结构"}
{"Answer": "你把可以把它理解为牵着狗的一条链子，然后你把中间某个链扣去掉，然后再接回链子。就是你要删掉P点 ，那么P点的前一个节点，指向下一个节点的指针是不是要指向P 点的下一个节点呢\n p的前一个节点q <---  p ---> p的后一个节点b\n就是 p->rlink 指针是指 q节点就是 p->link  指针是指 b节点 \n好啦，现在前后节点都找到了 q b , 我们把它们链接起来\n就是 q->link 原来p的前一个节点的link指针就指向 b 了  这里就是 (p->rlink)->link就是 b->rlink 原来p的后一个节点的rlink指针就指向 p 了  这里就是 (p->link)->rlink \n所以\n设\nq = p->rlink;\nb= p->link;\n\n则链接有：\nq->link = b;\nb->rlink= q;\n\n把关系带入代替q、b\n\n(p->rlink)->link = p->link;\n(p->link)->rlink = p->rlink;\n\n", "Knowledge_Point": "双链表", "Question": "\n2、    在双向链表存储结构中，删除p所指的结点时需修改指针这两个双链表的操作可以画个图吗，总感觉有点不对劲，", "Tag": "数据结构"}
{"Answer": "该回答引用ChatGPT\n#include <stdio.h>\n\n// 删除线性表中所有值为item的数据元素\nint delete_item(int A[], int n, int item){\n    int i = 0, j = 0;\n    while (i < n) {\n        if (A[i] != item) {\n            A[j++] = A[i++];\n        } else {\n            i++;\n        }\n    }\n    return j;\n}\n\nint main() {\n    int n, item;\n    scanf(\"%d\", &n);\n    int A[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    scanf(\"%d\", &item);\n\n    int new_length = delete_item(A, n, item);\n    for (int i = 0; i < new_length; i++) {\n        printf(\"%d \", A[i]);\n    }\n    return 0;\n}\n\n输入样例：\n10\n1 2 3 4 5 6 7 8 9 10\n8\n\n输出样例：\n1 2 3 4 5 6 7 9 10 \n", "Knowledge_Point": "双链表", "Question": "（C语言）（线性表）已知一双向循还链表，从第二个结点至表尾递增有序，（设a1<x<an）。试编写程序，将第一个结点删除并插入表中适当位置，使整个链表递增有序。输入输入长度n：7输入数据：4 1 2 3 6 8 9输出1 2 3 4 6 8 9样例输入511 7 8 9 10样例输出7 8 9 10 11 ", "Tag": "数据结构"}
{"Answer": "你好我去看了下这道题  有下面这段注释 \r\n```\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\n```\r\n第一个问题:需要你返回一个列表 而不是一个数组\r\n \r\n第二个问题:最后一个节点时fast会为null 所以fast无next属性\r\n > 另外老哥你是写Python的吧。。 变量啥的还是声明下比较好", "Knowledge_Point": "双链表", "Question": "题目来源https://leetcode-cn.com/problems/middle-of-the-linked-list\n问题①：按这个思路“将链表输出到数组，数组的话可以按索引找“来写的\n\nvar middleNode = function(head) {\n    let result = [head];\n    for(let i = 0, apple = head; apple != null; i++, apple = apple.next){\n        result[i] = apple.val;\n    }\n    console.log(result);\n    console.log(result.length);\n    console.log (result.slice(Math.floor(result.length/2)));\n    return Array.from(result);\n}\n\n\n\n为什么console能正常显示但是return却不行？\n\n问题②：用快慢双指针\n\nvar middleNode = function(head) {\n    slow = fast = head;\n    while(fast && fast.next != null){ //为什么去掉fast 就会报错？？？\n        // console.log(slow.val +\" \"+fast.val);\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n}\n\n\n去掉fast会报错，但不懂为什么\n测试用例：[1,2,3,4,5,6]\n\n感谢大佬们在百忙中解答我的疑问！！", "Tag": "数据结构"}
{"Answer": "Node* find_middle(Node* head)\n{\n     int count = 0;\n     Node *p = head;\n      if(p == NULL)\n          return p;\n      while(p->next != NULL)\n      {\n          count++;\n          p = p->next;\n      }\n      p = head;\n      count = count/2;\n      while(count > 0)\n      {\n            p = p->next;\n            count--;\n      }\n      return p;\n}\n \n\n", "Knowledge_Point": "单链表", "Question": "#include #include #include \ntypedef struct ListNode {    int num;    struct ListNode *next;}Node;\nNode createlist(); /裁判实现，细节不表/Node find_middle(Node* head);void display(Node *head);/裁判实现，细节不表/\nint main(){    Node  *head,*p;    head = createlist();    p = find_middle(head);    display(p);    return 0;}", "Tag": "数据结构"}
{"Answer": "Elemtype e;你定义的变量e的类型是你自定义的结构体，不能用系统==比较。\n可改成if (p->data.a==e.a)\n或者重载运算符==（c++）\n ", "Knowledge_Point": "单链表", "Question": "\n#include \n#include \n\n#define OK 1\n#define ERROR 0\n\ntypedef struct {\n    int a;\n    //数据域\n} Elemtype;\n\ntypedef struct Lnode {\n    Elemtype data;      //数据域\n    struct Lnode *next; //指针域\n}Lnode;\n\nint main () {\n    Lnode *p;\n    Elemtype e;\n    if (p->data==e)  {          //为什么该判断条件无法通过编译\n        printf (\"OK\");\n    }\n}\n\n为什么if 语句中的判断条件不正确 （只是大致举个例子），就想知道为什么不能用==", "Tag": "数据结构"}
{"Answer": "第一个函数也可以将返回值改为void的。不需要return第二种的一种好处是可以连着写，比如你想删除两个最小的值，那么LinkList L;DeleteMin(DeleteMin(L))而第二种void类型的就不行", "Knowledge_Point": "单链表", "Question": "同样是删除结点的题为什么有的用viod有的就用linklist 需要return L\n\n", "Tag": "数据结构"}
{"Answer": "\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node\n{\n    int num;\n    struct node *next;\n} Node;\n\nvoid print(Node *p)\n{\n    if(p==NULL)return;\n    print(p->next);\n    printf(\"%d \", p->num);    \n}\n\nint main()\n{\n    int n, x;\n    Node *L = (Node *)calloc(1, sizeof(Node));\n    Node *p, *q = L;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x);\n        p = (Node *)calloc(1, sizeof(Node));\n        p->num = x;\n        q->next = p;\n        q = p;\n    }\n\n    print(L->next);\n\n    return 0;\n}\n", "Knowledge_Point": "单链表", "Question": "输入一个整数n，再输入n个整数，按照输入的顺序建立单链表，并遍历所建立的单链表，输出这些数据。输入测试数据有多组，处理到文件尾。每组测试输入一个整数n，再输入n个整数。输出对于每组测试，输出顺序链表中的各结点的数据域的值（数据之间留一个空格）。\n输入5 1 2 3 4 5输出5 4 3 2 1", "Tag": "数据结构"}
{"Answer": "p=head;    //这个表示p跟head指向同一个结点\nhead-＞next=p;    //表示p指向head指向的下一个结点，就是p在head后面，不一样的熬\n", "Knowledge_Point": "单链表", "Question": "\ntypedef struct LinkListNode{\n    int data;\n    struct LinkListNode *next;\n}Node;\n\n\nNode *head,*p,*q;\n    int n=1;\n    \n    head=LinkList_Creat();\n    p=head;\n//    head->next=p;\n\n为什么p=head;正确，而head->next=p;一弹出运行窗口程序就自动结束呢，两者不都是指向的同一块地方的吗？", "Tag": "数据结构"}
{"Answer": "异常处理，输入的参数就是Null的话就要立即返回，否则下一步null->next就会出错了", "Knowledge_Point": "单链表", "Question": "LinkNode * FindRear(LinkNode *f){\n       if(f==NULL) return NULL;\n       else if(f–>link==NULL) return f;\n              else return FindRear(f->link);\n}函数体中第二行代码是递归终止条件，第三行是调用自己简化问题。那么第一行代码if(f==NULL) return NULL;是干啥的？可以去掉吗？", "Tag": "数据结构"}
{"Answer": "while循环中，应该用if  else if  else语句，不是if  if if，如下：\nvoid polyAdd(PolyList LA, PolyList LB, PolyList LC)\n{\n    int sum;\n    LA = LA->next;\n    LB = LB->next;\n    while (LA != NULL && LB != NULL) {\n        if (LA->exp > LB->exp) {\n            LC->next = LA;\n            LC = LA;\n            LA = LA->next;\n        }\n        else if (LA->exp < LB->exp) {\n            LC->next = LB;\n            LC = LB;\n            LB = LB->next;\n        }\n        else {\n            sum = LA->coef + LB->coef;\n            if (sum != 0) {\n                LC->next->coef = sum;\n                LC->next->exp = LA->exp;\n                LC = LC->next;\n                LA = LA->next;\n                LB = LB->next;\n            }\n            else {\n                LA = LA->next;\n                LB = LB->next;\n            }\n        }\n    }\n    if (LA != NULL) {\n        LC->next = LA;\n    }\n    if (LB != NULL) {\n        LC->next = LB;\n    }\n    if (LA == NULL && LB == NULL) {\n        LC->next = NULL;\n    }\n}\n\n", "Knowledge_Point": "单链表", "Question": "问题遇到的现象和发生背景\n现在用带头节点的单链表来存储多项式，链表中的一个节点表示多项式的一项，节点中coef表示多项式的系数，exp表示多项式的次数，例如5x8用一个节点表示时，该节点的coef成员值为5，exp值为8。请设计void polyAdd(PolyList LA, PolyList LB,PolyList LC)函数。参数：LA,LB指向的链表是带头节点的单链表，链表中的每个数据节点表示多项式的一项，数据节点已经按指数从大到小排序。LC指向一个空的带头节点的链表，表示空的多项式。该函数用来对多项式LA和LB相加，结果保存在多项式LC指向的单链表中。请注意，本题有预置代码，只需提交所要求的函数定义代码即可。\n问题相关代码，请勿粘贴截图\nvoid polyAdd(PolyList LA, PolyList LB,PolyList LC){    int sum;    LA=LA->next;    LB=LB->next;    while(LA!=NULL&&LB!=NULL){        if(LA->exp>LB->exp){            LC->next=LA;            LC=LA;            LA=LA->next;        }        if(LA->expexp){            LC->next=LB;            LC=LB;            LB=LB->next;        }        if(LA->exp==LB->exp){            sum=LA->coef+LB->coef;            if(sum!=0){                LC->next->coef=sum;                LC->next->exp=LA->exp;                LC=LC->next;                LA=LA->next;                LB=LB->next;            }            else{                LA=LA->next;                LB=LB->next;            }        }    }    if(LA!=NULL){        LC->next=LA;    }    if(LB!=NULL){        LC->next=LB;    }    if(LA==NULL&&LB==NULL){        LC->next=NULL;    }}\n运行结果及报错内容\nError:Segmentation\n我的解答思路和尝试过的方法\n我想要达到的结果", "Tag": "数据结构"}
{"Answer": "LC和LA都是指针，赋值之后，清空LC就等于清空LA了\r\n\r\n```\r\n     LinkList LC;\r\n    LC = LA; //将LC置为空表，且不额外分配结点空间\r\n    LC->next = NULL;\r\n```", "Knowledge_Point": "单链表", "Question": "题目\n\n合并单链表 LA = （2，2，3），LB = （1，3，3，4）为 LC = （1，2，2，3，3，3，4）。要求是LC利用LA和LB元素的结点空间建表，不能额外申请结点空间。\n\n问题\n\n程序没有语法错误，修改许多次，但输出结果总是链表LB的值。望有人能帮助分析一下输出结果错误的原因。感激不尽。\n\n代码如下\n\n#include\n#include\n\ntypedef struct Node\n{\n    char data;\n    struct Node * next;\n}Node, * LinkList;\n\nvoid InitList(LinkList * L);\nvoid CreateFromTail(LinkList L);\nLinkList MergeLinkList(LinkList LA, LinkList LB);\nvoid output(LinkList L);\n\nint main()\n{\n    LinkList LA, LB, LC;\n\n    InitList(&LA); //初始化单链表LA\n    printf(\"输入链表LA的值: \");\n    CreateFromTail(LA); \n\n    InitList(&LB); //初始化单链表LB\n    printf(\"输入链表LB的值: \");\n    CreateFromTail(LB);\n\n    LC= MergeLinkList(LA, LB); //合并单链表\n    printf(\"合并后链表LC的值为: \");\n    output(LC);\n\n    return 0;\n}\nvoid InitList(LinkList * L) //初始化单链表\n{\n    (* L) = (LinkList)malloc(sizeof(Node));\n    (* L)->next = NULL;\n}\nvoid CreateFromTail(LinkList L) //尾插法建表\n{\n    Node * r, * s;\n    r = L;\n    int flag = 1;\n    char c;\n    while(flag)\n    {\n        c = getchar();\n        if(c != '$')\n        {\n            s = (Node *)malloc(sizeof(Node));\n            s->data = c;\n            r->next = s;\n            r = s;\n        }\n        else\n        {\n            flag = 0;\n            r->next = NULL;\n        }\n    }\n}\nLinkList MergeLinkList(LinkList LA, LinkList LB) //合并链表LA和LB\n{\n    Node * pa, * pb, * r;\n    LinkList LC;\n    LC = LA; //将LC置为空表，且不额外分配结点空间\n    LC->next = NULL;\n    pa = LA->next; //让pa指向链表LA的第一个元素\n    pb = LB->next; //让pb指向链表LB的第一个元素\n    r = LC;\n\n    while(pa != NULL && pb != NULL)\n    {\n        if(pa->data <= pb->data)\n        {\n            r->next = pa;\n            r = pa;\n            pa = pa->next;\n        }\n        else\n        {\n            r->next = pb;\n            r = pb;\n            pb = pb->next;\n        }\n    }\n    if(pa)\n        r->next = pa;\n    else\n        r->next = pb;\n\n    free(LB);\n    return(LC);\n}\nvoid output(LinkList L) //输出链表\n{\n    LinkList p = L->next;\n    while(p != NULL)\n    {\n        printf(\"%c \", p->data);\n        p = p->next;\n    }\n    printf(\"\\n\");\n}\n\n\n运行结果\n\n", "Tag": "数据结构"}
{"Answer": "你的两个for循环条件用的是同一个i哦，第二个for循环退出之后的值是不是刚好达到第一个for循环的条件了呢。是不是也就退出了呢", "Knowledge_Point": "单链表", "Question": "单链表多次插入删除数据的时候为什么我插入的时候只能插一个数据，删除的时候除了都删第一个也只能删一个数据这是插入的部分代码麻烦帮忙看看", "Tag": "数据结构"}
{"Answer": "这里开辟五次是不是每次都会把前一次开辟的内存的地址给覆盖了===当然不会，每次都是新建一个指针空间的，不会覆盖啊。第二处最后Ptail等于Pnew是什么意思===Ptail是当前操作指针，一直在移动，Pnew是新建的节点，每次插入新节点后，当前操作指针就移动指向新加入的节点而且第二处的操作是如何把五个节点连接起来的===Ptail开始指向pHead头指针，产生新节点Pnew后，将Ptail的next指向Pnew，这样就将节点链接了，然后Ptail移动指向Pnew，这样下个循环新加节点时，继续用Ptail的next指向新节点，这样就像链条一样链接起来了，所以叫链表", "Knowledge_Point": "单链表", "Question": "大家好，这是单链表创建的操作。如图有两处地方我不是很明白，第一处使用malloc函数 for循环开辟内存五次并将地址赋值结构体指针Pnew 这里开辟五次是不是每次都会把前一次开辟的内存的地址给覆盖了 第二处最后Ptail等于Pnew是什么意思？而且第二处的操作是如何把五个节点连接起来的？我不是很明白，有人可以给我解释一下吗", "Tag": "数据结构"}
{"Answer": "指针没有赋初始值", "Knowledge_Point": "单链表", "Question": "如图，做单链表的时候，这个LB1报错了，有伙伴知道是为什么吗？", "Tag": "数据结构"}
{"Answer": "main函数中，Linklist InitLink(Lnode * &L);这是函数定义，不是函数调用啊，连函数都没调用，自然不可能进入什麽循环改为InitLink(&L);", "Knowledge_Point": "单链表", "Question": "问题遇到的现象和发生背景\n单链表练习\n问题相关代码，请勿粘贴截图\n#include#include#define maxsize 10\ntypedef struct Lnode{    int data;    struct Lnode* next;} Lnode, * Linklist;\nLinklist InitLink(Linklist &L) {    int n;   //输入数据的数量    int data;   //输入的数据    Lnode* s;    L = (Lnode*)malloc(sizeof(Lnode));    L->next = NULL;    scanf(\"%d\", &n);    scanf(\"%d\", &data);    for (int i = 0; i < n; i++) {        s = (Lnode*)malloc(sizeof(Lnode));        s->data = data;        s->next = L->next;        L->next = s;\n}\n\nreturn L;\n\n};\nint main() {    Lnode L;    Linklist InitLink(Lnode * &L);    return 0;}\n运行结果及报错内容\n没有输入数据，也没有进入循环", "Tag": "数据结构"}
{"Answer": "不考虑运行，仅仅修改编译错误，如下：\r\n\r\n如果运行还有问题，请点我回答左上角的采纳和向上的箭头，重新提问，我继续回答。\r\n\r\n```\r\n#include \r\n#include \r\n\r\n#define MAXSIZE 20\r\n\r\ntypedef int ElemType; \r\n\r\ntypedef struct Node\r\n{\r\n    ElemType data;\r\n    Node* next;\r\n}*LinkList;\r\n\r\nint Deal(LinkList *LA,int n);\r\n\r\nint main()\r\n{\r\n    //建立单链表\r\n    LinkList * LA = NULL;\r\n\t*LA=(LinkList)malloc(sizeof(Node));\r\n    (*LA)->next=NULL;\r\n    Node *r,*s;\r\n    int c;\r\n    r=*LA;\r\n    int flag=1,count=0; \r\n    while(flag)\r\n    {\r\n        printf(\"Please input new node to the LinkList,node must be intatger，input q to quit:\\n\");\r\n        scanf(\"%d\",&c);\r\n        if(c!='q')\r\n        {\r\n            s=(Node*)malloc(sizeof(Node));\r\n            s->data=c;\r\n            r->next=s;\r\n            r=s;\r\n            count++;\r\n        }\r\n        else\r\n        {\r\n            flag=0;\r\n            r->next=NULL;\r\n        }\r\n    } \r\n    Deal(LA,count);\r\n\r\n    //打印新生成的表\r\n    printf(\"New LinkList is：\\n\");\r\n    r=(*LA)->next;\r\n    while(r->next!=NULL)\r\n    {\r\n        printf(\"%5d\",r->data);\r\n    } \r\n    return 0;\r\n}\r\n\r\nint Deal(LinkList *LA,int n)//n为单链表长度，n为偶数 \r\n{\r\n    LinkList *LB,*LC;\r\n    *LB=(LinkList)malloc(sizeof(Node));//建立头结点\r\n    (*LB)->next=NULL;//建立空的单链表LB\r\n    *LC=(LinkList)malloc(sizeof(Node));//建立头结点\r\n    (*LC)->next=NULL;//建立空的单链表LC\r\n    Node *p,*q,*r,*s;\r\n    int i;\r\n    p=(*LA)->next->next;//令指针p指向序号为偶数的元素 \r\n    q=(*LA)->next;//令指针q指向序号为奇数的元素 \r\n    r=*LB;//令指针r指向LB \r\n    s=*LC;//令指针s指向LC \r\n\r\n\r\n    //插入LB的第一个元素 \r\n    (*LB)->next=p;\r\n    q->next=p->next;\r\n    p=p->next->next;\r\n    while(p->next!=NULL&&q->next!=NULL)\r\n    {\r\n        //尾插法 \r\n        s->next=q;\r\n        *LA=q->next;\r\n        q=q->next->next;\r\n        s=s->next; \r\n\r\n        //头插法 \r\n        p->next=(*LB)->next;\r\n        (*LB)->next=p; \r\n        p=p->next->next;\r\n    }\r\n\r\n    //合并LB/LC两表\r\n    if(p->next==NULL)\r\n    {\r\n        p->next=(*LC)->next;\r\n        free(LC);\r\n    }\r\n    return 0;\r\n\r\n\r\n}\r\n\r\n\r\n```", "Knowledge_Point": "单链表", "Question": "\n\n #include \n#include \n\n#define MAXSIZE 20\n\ntypedef int ElemType; \ntypedef struct\n{\n    ElemType data;\n    struct Node* next;\n}Node,*LinkList;\n\nint main()\n{\n    //建立单链表\n    LinkList LA;\n    *LA=(LinkList)malloc(sizeof(Node));\n    *LA->next=NULL;\n    Node *r,*s;\n    int c;\n    r=LA;\n    int flag=1,count=0; \n    while(flag)\n    {\n        printf(\"Please input new node to the LinkList,node must be intatger，input q to quit:\\n\");\n        scanf(\"%d\",&c);\n        if(c!=\"q\")\n        {\n            s=(Node*)malloc(sizeof(Node));\n            s->data=c;\n            r->next=s;\n            r=s;\n            count++;\n        }\n        else\n        {\n            flag=0;\n            r->next=NULL;\n        }\n    } \n    Deal(LA,count);\n\n    //打印新生成的表\n    printf(\"New LinkList is：\\n\");\n    r=LA->next;\n    while(r->next!=NULL)\n    {\n        printf(\"%5d\",r->data);\n    } \n    return 0;\n}\n\nint Deal(LinkList *LA,int n)//n为单链表长度，n为偶数 \n{\n    LinkList LB,LC;\n    *LB=(LinkList)malloc(sizeof(Node));//建立头结点\n    *LB->next=NULL;//建立空的单链表LB\n    *LC=(LinkList)malloc(sizeof(Node));//建立头结点\n    *LC->next=NULL;//建立空的单链表LC\n    Node *p,*q,*r;\n    int i;\n    p=LA->next->next;//令指针p指向序号为偶数的元素 \n    q=LA->next;//令指针q指向序号为奇数的元素 \n    r=LB;//令指针r指向LB \n    s=LC;//令指针s指向LC \n\n\n    //插入LB的第一个元素 \n    LB->next=p;\n    q-next=p-next;\n    p=p->next->next;\n    while(p->next!=NULL&&q->next!=NULL)\n    {\n        //尾插法 \n        s->next=q;\n        LA=q->next;\n        q=q->next->next;\n        s=s->next; \n\n        //头插法 \n        p->next=LB->next;\n        LB->next=p; \n        p=p->next->next;\n    }\n\n    //合并LB/LC两表\n    if(p->next==NULL)\n    {\n        p->next=LC->next;\n        free(LC);\n    }\n    return 0;\n\n\n}\n\n\n程序无法通过编译，麻烦各位大神帮忙看一看那里出问题了", "Tag": "数据结构"}
{"Answer": "直接bfs就行了，毕竟询问次数较少", "Knowledge_Point": "最短路径", "Question": "7-3 幸福小镇的故事！（简单） (25 分)\n\n在一个很远很远的地方，有一个幸福小镇！\n\n幸福小镇的治安很不好，所以生活在镇上很不幸福！\n\n新来的保安队队长小Z决心改变这一切，第一步要解决的是任何两个小镇之间的距离问题！\n\n我们需要解决这个问题的简化版本：\n\n幸福小镇可以划分为N个小小镇，从1到N编号！这些小小镇由N-1条道路连通，我们把每条道路的长度简化为1！只要在每个小小镇增派人手，就可以让小镇的治安情况变得越来越好！（题目保证两个小镇之间的道路只有一条！）\n\n每次小Z会询问你两个小小镇的编号，请你计算出这两个小镇之间的最短路径长度！\n\n输入格式:\n\n第一行包含一个正整数（N<=1000），表示小小镇的个数！\n\n接下来N-1行，每行包含两个1到N之间的整数，表示这两个编号的小小镇之间有一条路！\n\n接下来一行包含一个整数q（q<=100)，表示询问数！\n\n接下来q行，每行包含两个小小镇的编号，请在一行中输出这两个小小镇的最短路径长度！\n\n输出格式:\n\n输出答案即可！\n\n输入样例:\n\n在这里给出一组输入。例如：\n\n\n10\n1 2\n2 3\n1 4\n4 5\n4 6\n3 7\n3 8\n1 9\n9 10\n5\n3 8\n9 3\n1 1\n1 7\n1 9\n\n输出样例:\n\n在这里给出相应的输出。例如：\n\n\n1\n3\n0\n3\n1", "Tag": "数据结构"}
{"Answer": "你可以将画布作为绘图函数的第一个参数，如：\nnx.draw(G, pos, with_labels=True, alpha=0.5, canvas=canvas)\n\n\n或者，可以使用 FigureCanvasTkAgg 将画布绑定到 tkinter 窗口中，例如：\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n\nfig = plt.figure(figsize=(5, 5))\ncanvas = FigureCanvasTkAgg(fig, master=window2)\ncanvas.get_tk_widget().grid(row=8, column=10)\nnx.draw(G, pos, with_labels=True, alpha=0.5, fig=fig)\n\n\n在这种情况下，应该使用 fig 而不是 canvas 作为绘图函数的第一个参数。\n请注意，如果使用 FigureCanvasTkAgg，则需要导入 matplotlib.pyplot 模块，并使用 plt.figure 创建一个新图表。", "Knowledge_Point": "最短路径", "Question": "\ndef main3():\n          canvas = tkinter.Canvas(window2, width=50, height=50)\n          canvas.grid(row=8,column=10)\n\n# 创建一个无向图\n          G = nx.Graph()\n          G.add_edge('A', 'B', weight=1)\n          G.add_edge('A', 'D', weight=7)\n          G.add_edge('B', 'E', weight=4)\n          G.add_edge('D', 'E', weight=3)\n          G.add_edge('F', 'G', weight=4)\n          G.add_edge('F', 'E', weight=5)\n          G.add_edge('G', 'K', weight=9)\n\n# 绘制图像\n          source=nameEntry3.get()\n          target=nameEntry4.get()\n \n          minWPath_v1_v5 = nx.dijkstra_path(G, source, target)  # 顶点 0 到 顶点 3 的最短加权路径\n                \n# 两个指定顶点之间的最短加权路径的长度\n          \n          pos = nx.spring_layout(G)  # 使用 FR 算法排列节点\n          nx.draw(G, pos, with_labels=True, alpha=0.5,on=canvas)\n          labels = nx.get_edge_attributes(G, 'weight')\n          nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)\n          edgeList = []\n          for i in range(len(minWPath_v1_v5)-1):\n                  edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n                  nx.draw_networkx_edges(G, pos, edgelist=edgeList, edge_color='m', width=4,on=canvas)\n\n            \n          \n      \n\n怎么让我画的无向图显示在canvas画布上", "Tag": "数据结构"}
{"Answer": "concat 可以一次性合并多个 dataFrame\nfilenames=os.listdir(path)\ndf_list = []\nfor filename in filenames:\n    df_list.append(pd.read_excel(path + '\\' + filename))\nresult_df = pd.concat(df_list)\n", "Knowledge_Point": "最短路径", "Question": "求助各位，我用的是pycharm教育版，合并三个表，累计行数在四万行左右，以下是我写的代码，运行时间最短的一次也是一百六十多秒，并且运行一次一次比一次久，最后一次将近四百秒了，求帮忙看下代码写的有什么问题，或者可以怎么改，谢谢，好人一生平安\nimport os\nimport pandas as pd\nimport time\nstart=time.time()\npath=r'D:\\我的工作文件夹\\A 可视化\\sales_order'\nempty=pd.DataFrame()\ny=os.listdir(path)\nfor i in y:\n    df=pd.read_excel(path+'\\%s'%i)\n    #连接路径和表名\n    empty=pd.concat([empty,df])\nempty.to_excel(excel_writer = r'D:\\我的工作文件夹\\A 可视化\\sales_order.xlsx',sheet_name='order',index=False)\nend=time.time()\nprint('代码运行时间为:%.2f 秒'%round(end-start,2)) \n\n", "Tag": "数据结构"}
{"Answer": "import java.util.*;\n\npublic class MazeBFS {\n    // 迷宫地图\n    private char[][] maze;\n    // 迷宫大小\n    private int M, N;\n    // 上下左右四个方向\n    private int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    // 记录已访问的位置\n    private boolean[][] visited;\n\n    public MazeBFS(char[][] maze) {\n        this.maze = maze;\n        this.M = maze.length;\n        this.N = maze[0].length;\n        this.visited = new boolean[M][N];\n    }\n\n    // 广度优先搜索\n    public List<int[]> bfs(int start_x, int start_y, int end_x, int end_y) {\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{start_x, start_y});\n        visited[start_x][start_y] = true;\n        while (!queue.isEmpty()) {\n            int[] pos = queue.poll();\n            int x = pos[0], y = pos[1];\n            for (int[] dir : directions) {\n                int nx = x + dir[0], ny = y + dir[1];\n                if (nx >= 0 && nx < M && ny >= 0 && ny < N && maze[nx][ny] == 'O' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    if (nx == end_x && ny == end_y) {\n                        List<int[]> path = new ArrayList<>();\n                        path.add(new int[]{nx, ny});\n                        int cur_x = x, cur_y = y;\n                        while (cur_x != start_x || cur_y != start_y) {\n                            path.add(new int[]{cur_x, cur_y});\n                            for (int[] dir2 : directions) {\n                                int prev_x = cur_x - dir2[0], prev_y = cur_y - dir2[1];\n                                if (prev_x >= 0 && prev_x < M && prev_y >= 0 && prev_y < N && visited[prev_x][prev_y]) {\n                                    cur_x = prev_x;\n                                    cur_y = prev_y;\n                                    break;\n                                }\n                            }\n                        }\n                        path.add(new int[]{start_x, start_y});\n                        Collections.reverse(path);\n                        return path;\n                    }\n                    queue.offer(new int[]{nx, ny});\n                }\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        // 迷宫地图\n        char[][] maze = {\n                {'O', 'O', 'O', 'O', 'O', 'X', 'O', 'O'},\n                {'X', 'O', 'X', 'X', 'O', 'X', 'O', 'X'},\n                {'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'},\n                {'O', 'X', 'X', 'O', 'X', 'X', 'O', 'X'},\n                {'O', 'O', 'O', 'O', 'X', 'O', 'O', 'O'},\n                {'X', 'O', 'X', 'O', 'O', 'O', 'X', 'O'},\n                {'X', 'X', 'O', 'O', 'X', 'O', 'O', 'O'},\n        };\n\n        MazeBFS solution = new MazeBFS(maze);\n        List<int[]> shortestPath= solution.bfs(0, 0, maze.length - 1, maze[0].length - 1);\n        if (shortestPath == null) {\n            System.out.println(\"无法到达终点！\");\n        } else {\n            System.out.println(\"最短路径为：\");\n            for (int[] pos : shortestPath) {\n                System.out.println(pos[0] + \" \" + pos[1]);\n            }\n        }\n    }\n}\n\n测试地图自己换一下", "Knowledge_Point": "最短路径", "Question": "走迷宫(广度优先搜索)\n已知一个MxN的迷宫\n求从(0,0)到(M-1,N-1)的最短路径\n例如迷宫如下：O代表可通行，X代表不可通行\n输出最短路径\n7,7\n6,7\n6,6\n5,6\n5,5\n5,4\n4,4\n3,4\n2,4\n1,4\n1,3\n1,2\n1,1\n1,0\n0,0", "Tag": "数据结构"}
{"Answer": "类似于“有限制条件的动态规划旅行商问题”的方法，我们需要定义一个状态 (S, i, p)，其中S是已访问过的顶点集合（包括取件点和送货点），i是当前所在的顶点，p表示当前手中的包裹来源（取件点集合）。转移方程\n```dp[S, i, p] = min(dp[S, i, p], dp[S-{i}, j, p-{i}] + dist(j, i))\n```j是S中的一个顶点，且满足以下条件：若i是一个送货点，则j必须是与i对应的取件点之一。在递推的过程中，需要保证p始终包含了当前所在的送货点所需的包裹来源初。始化状态和边界条件。dp[S, i, p]初始化为无穷大（表示不可达）。边界条件为：当S只包含一个顶点（即某个取件点）时，dp[S, i, p]为0，其中i表示该取件点。\n最后，遍历所有状态并更新动态规划数组，通过回溯法找到最短路径。送货点数量不会超过250个，可以试试看这个。", "Knowledge_Point": "最短路径", "Question": "我是一个送货员，我想计算出一日工作的最短路程。具体：\n公司有多个取件点，而我每天早上可以随意选从哪一个取件点开始配送每一个配送点要送的包裹都有对应的单个或多个取件点（可能一个送货点有来自取件点A和B甚至更多不同地方的包裹要取），要保证去配送的时候手里有对应的包裹（就是之前去过对应包裹的取件点）可多次去一个送货点每天不用回到初始点，只要回到任意取件点就行包裹不限重量，默认去一个取件点就把所有包裹都带上每日的送货点不会超过250个\n背景：之前做了一个GIS系统，需要加上这个送货员功能，目前可以计算两点之间的最短路线，在这里我用的是C++个人初步搜索：我浏览了网络上的TSP旅行商问题，也大致了解了解法（但不明白原理所以不知道怎么自己修改）。在想是忽略取货问题先找出所有点的最短路径，然后以那个基础上去改进路线比较好，还是这样子算走远了。如果可以的话，那我该怎么优化路径我也不知道。\n想问一下在这个条件下该怎么算会更快，谢谢大家", "Tag": "数据结构"}
{"Answer": "s = input()\ns = tuple(s)\nm = s[0]\nindex = 0\nfor i in range(1, len(s)):\n    if s[i] >= m:\n        m = s[i]\n        index = i\nprint('%c   %d'%(m,index))\n", "Knowledge_Point": "排序", "Question": "输入字符串，排序后输出最大字符及该字符在原字符串中的索引。相同字符的索引取最大值。提示：用元组实现。", "Tag": "数据结构"}
{"Answer": " \npublic void BubbleSort(int[] array)\n        {            int length = array.Length;            for (int i = 0; i < length - 1; i++)\n            {                for (int j = length - 1; j > i; j--)\n                {                    // 对两个元素进行交换\n                    if (array[j] < array[j - 1])\n                    {                        int temp = array[j];\n                        array[j] = array[j - 1];\n                        array[j - 1] = temp;\n                    }\n                }\n            }\n        }\n\n", "Knowledge_Point": "排序", "Question": "任务描述：使用冒泡排序(按升序)对给定的数组排序，并输出每次排序结果以及排序完成后的数组，具体要求如下：接收给定的数据（如：4 88 43 43 98，其中第一个数代表数组长度，其余数代表数组元素；创建数组，使用直接选择排序(按升序)对给定的数组排序，并输出每次排序结果以及排序完成后的数组。\n测试输入：（1） 10（2） 9（3） 1（4） 6（5） 53（6） 54（7） 2（8） 89（9） 54（10） 90（11） 21预期输出：（1）  第1趟排序:[1,6,9,53,2,54,54,89,21,90]（2）  第2次排序:[1,6,9,2,53,54,54,21,89,90]（3）  第3次排序:[1,6,2,9,53,54,21,54,89,90]（4）  第4次排序:[1,2,6,9,53,21,54,54,89,90]（5）  第5次排序:[1,2,6,9,21,53,54,54,89,90]（6）  第6次排序:[1,2,6,9,21,53,54,54,89,90]（7）  第7次排序:[1,2,6,9,21,53,54,54,89,90]（8）  第8次排序:[1,2,6,9,21,53,54,54,89,90]（9）  第9次排序:[1,2,6,9,21,53,54,54,89,90]（10） 排序后的结果为:[1,2,6,9,21,53,54,54,89,90]", "Tag": "数据结构"}
{"Answer": "i 从 0开始，把min设成 i 的意思是，每次循环，找到第（i+1）小的数据，并用min记录下标，然后把这个数放在a[i]位置。过程：当i =0 是，min=0，默认此时的最小值就是a[0]，然后遍历a[1]以后的数据，找到最小的数据，并用min记录其下标，最后，把a[min]放在a[0]的位置。也就是a[0]是数组中的最小值。然后继续循环i=1，min=i=1，默认此时的最小值就是a[1]，因为最小值已经放在a[0]了，所以从a[i+1]开始找剩余数据中的最小值，并用min记录下标，然后把它放在a[1]位置。后面的以此类推所以，每次找最小值的时候，先默认当前位置的值就是该位置的最小值，然后遍历它后面的所有数，找到后面所有数中的最小值，然后把最小值放在当前位置。", "Knowledge_Point": "排序", "Question": "请问下各位前辈，c语言的选择法排序，比如下面这个从小到大排五个数，为什么下标要在开始设成i，然后为什么两个值交换的步骤不是在if语句里面，拜托了！", "Tag": "数据结构"}
{"Answer": "可以尝试带有经纬度查询功能的数据库 ，比如我之前用的就是ElasticSearch的这个功能去实现的，可以根据距离排序分页查询", "Knowledge_Point": "排序", "Question": "1、数据量较大时，如何根据经纬度排序，并做分页？\n2、怎么实现效率最高？\n3、体现形式类似于美团外卖的离您最近。", "Tag": "数据结构"}
{"Answer": "【有帮助请采纳】\n你可以将数据放在一个列表中，然后利用 Python 的内置排序函数 sorted 进行排序，或者用列表类型的方法 sort 进行排序，sorted 函数返回排序后的新列表，而 sort 方法是对原列表直接排序，返回 None\nsorted(seq, key=None, reverse=False)\n\nseq 为待排序的序列，key 为排序的方式，默认为 None，即没有特殊的要求，按从小到大排序，reverse 为是否逆序，默认为 False，若为 True，则从大到小进行排序\nlist.sort(key=None, reverse=False)\n\n与 sorted 函数差不多，这里不再赘述\n你还可以去参考其他的排序算法，不过这里还是建议用内置函数，毕竟它又快又好还稳定\n【有帮助请采纳】", "Knowledge_Point": "排序", "Question": "如何对一些用python算出来的度中心性数据（networkx）按大小进行排序   有无具体代码可以参考 ", "Tag": "数据结构"}
{"Answer": "不稳定排序是说，如果待排序的两个数字一样大，那么，排序完后这两个数字谁在前不一定。不是说不稳定排序会出现不正确的结果。快速排序经过稍微改造，也可以变成稳定排序——只要在排序前记录下原始的元素顺序，并且在比较的时候作为第二条件就可以。\r\njava不是很确定，但是.net中，系统类库提供的快速排序是稳定的。", "Knowledge_Point": "排序", "Question": "既然快速排序是不稳定的，为什么java语言还要使用快速排序？不稳定排序怎么才能正确使用它？", "Tag": "数据结构"}
{"Answer": "你的时间复杂都为O（n2） 你试试qsort", "Knowledge_Point": "排序", "Question": "题目描述\n编一程序用简单选择排序方法对n个整数排序（从大到小）。\n对n个数进行降序排列，简单选择排序的算法思想如下：\n1）首先通过n-1次比较，从n个元素中找出值最大的元素，将它与第一个元素交换。（第一趟排序）。\n2）再通过n-2次比较，从剩余的n-1个元素中找出值次大的元素，将它与第二个元素交换。（第二趟排序）。\n3）重复上述操作，共进行n-1趟排序后，排序结束。\n输入\n先输入整数个数n（n<=100000）\n然后输入n个整数\n输出\n输出排序后的n个整数，整数之间由1个空格隔开。\n样例输入\n102 7 12 23 23 34 45 56 87 98\n样例输出\n98 87 56 45 34 23 23 12 7 2\n提示\n\n本题由实验指导书实验9第3题改编而成。\n\n注意数组元素长度可达100000，也需尽量优化算法以避免超时。\n\n难度系数为6。\n\n我的代码是这样的\n#include\"stdio.h\"\n\nvoid sort(int array[],int n) //排序函数\n{\n int i,j,temp;\n for(i=0; i<n; i++)\n   for(j=i+1; j<n; j++)\n   {\n    if(array[i]<array[j])\n    {\n     //交换\n     temp=array[i];\n     array[i]=array[j];\n     array[j]=temp;\n    }\n   }\n}\n\nint main()  //主函数\n{\nint N;\nscanf(\"%d\",&N);\n int array[N],i;\n    for(i=0; i<N; i++)\n {\n  scanf(\"%d\",&array[i]);\n }\n //调用排序函数\n    sort(array,N);\n //输出排序后的结果\n for(i=0; i<N; i++)\n {\n  printf(\"%d \",array[i]);\n }\n}\n能不能告诉我怎么优化？超时了", "Tag": "数据结构"}
{"Answer": "命令：sort -t: -k3n /etc/passwd如有帮助望采纳。点击我回答右上角【采纳】按钮。", "Knowledge_Point": "排序", "Question": "使用Linux命令，如何将 /etc/passwd 中的内容按 uid 进行排序？", "Tag": "数据结构"}
{"Answer": "\n\n#include <stdio.h>\n\nint main(void) {\n    int a[100];\n    int n = 0;\n    \n    while (scanf(\"%d\", &a[n++]) == 1)\n        ;\n        \n    for (int i = 0; i < n; ++i)\n        for (int j = j + 1; j < n; ++j)\n            if (a[i] < a[j]) {\n                int t = a[i];\n                a[i] = a[j];\n                a[j] =  t;\n            }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%5d\", a[i]);\n    }\n    \n    return 0;\n}\n\n ", "Knowledge_Point": "排序", "Question": "C语言问题：任意输入n个整数(n>0&&n<=100),按降序排序后,将其输出.输入任意的整数代码如下\n\n排序\n题目描述\n任意输入n个整数（n>0&&n<=100）,按降序排序后，将其输出。\n输入任意的整数代码如下\nwhile(scanf(\"%d\",&a[i])==1)\n需要结束输入时，先按回车，再按ctrl+z ,再回车 就会退出。\n\n输入描述\n任意输入n个整数（n>0&&n<=100）\n\n输出描述\n降序输出，每个整数占5位宽\n\n输入样例\n3 43 5 7\n\n输出样例\n43 7 5 3", "Tag": "数据结构"}
{"Answer": "修改处见注释，供参考：\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nbool cmp(int x,int y){\n    int sum=0,num=0,tmp_x=x,tmp_y=y;//修改\n    while(x){ //while(x<=0){        //修改\n        sum+=x%10;\n        x/=10;\n    }\n    while(y){ //while(y<=0){        //修改\n        num+=y%10;\n        y/=10;\n    }\n    if(sum == num)    //修改 if(sum>num)return 0;\n        return tmp_x < tmp_y;       //修改\n    else             //修改  else if(sum<num)return 1;\n        return sum < num;\n                     //return x>y;\n}\nint main(){\n    int a[1001];\n    int n;cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    sort(a+1,a+n+1,cmp);\n    for(int i=1;i<=n;i++){\n        cout<<a[i]<<\" \";\n    }\n    return 0;\n}\n\n", "Knowledge_Point": "排序", "Question": "我们有 N个正整数，均小于 10000。现在需要将这些正整数按照该正整数每一位数字相加的和从小到大排序，即该正整数的每一位数字相加的和越小排位越靠前。如果各位相加和相等，则按照正整数的值从小到大排序。输入格式输入有 2 行第一行为一个整数 NN，0 < N < 101；第二行为用空格隔开的 N个正整数，均小于 10000。输出格式输出有 1 行，为按照题目要求排序后的 N 个正整数，用空格隔开。样例输入420 12 1 11输出1 11 20 12想请问一下能改一改下面这个程序吗\n#include \n#include \nusing namespace std;\nbool cmp(int x,int y){\n    int sum=0,num=0;\n    while(x<=0){\n        sum+=x%10;\n        x/=10;\n    }\n    while(y<=0){\n        num+=y%10;\n        y/=10;\n    }\n    if(sum>num)return 0;\n    else if(sum>n;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    sort(a+1,a+n+1,cmp);\n    for(int i=1;i<=n;i++){\n        cout<<a[i]<<\" \";\n    }\n}\n\n", "Tag": "数据结构"}
{"Answer": "```\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class ArrayDemo {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tInteger[] aArray = new Integer[] { 0, 1, 5, 8 };\r\n\r\n\t\t// 第一步获取D数组\r\n\t\tSystem.out.println(\"根据A计算得到的数组D:\");\r\n\t\tInteger[] dArray = getDArray(aArray);\r\n\r\n\t\tfor (int i = 0; i < dArray.length; i++) {\r\n\t\t\tSystem.out.println(dArray[i]);\r\n\t\t}\r\n\t\t// 第二步根据D数组反求A数组\r\n\t\tSystem.out.println(\"反求得到的数组A:\");\r\n\t\tInteger[] _aArray = getAArray(dArray);\r\n\t\tfor (int i = 0; i < _aArray.length; i++) {\r\n\t\t\tSystem.out.println(_aArray[i]);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 构造与D相对应的某一个数列A，注意A不是唯一的\r\n\t * \r\n\t * @param dArray\r\n\t * @return\r\n\t */\r\n\tprivate static Integer[] getAArray(Integer[] dArray) {\r\n\t\tint dLen = dArray.length;\r\n\t\tint aLen = getALen(dLen);\r\n\t\tif (aLen == 0) {\r\n\t\t\tSystem.err.println(\"计算A的数组出错，请确认传入的D数组有效。\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 因为A1必须为0，可以直接确定A1，并设置A最后一个值为D的最后一个值，保证了最大值。同时A2=A1+D1,A3=A2+D2,依次类推，认为D是有序数组，遍历D数组得到中间A的所有数据\r\n\t\tInteger[] aArray = new Integer[aLen];\r\n\t\taArray[0] = 0;\r\n\t\taArray[aLen - 1] = dArray[dLen - 1];\r\n\t\tfor (int i = 1; i < aLen - 1; i++) {\r\n\t\t\taArray[i] = aArray[i - 1] + dArray[i];\r\n\t\t}\r\n\t\treturn aArray;\r\n\t}\r\n\r\n\t/**\r\n\t * 根据传入的D数组的长度求出A数组的长度来，就是解一元二次方程n*n-n=2*dLen,n代表A数组的长度\r\n\t * \r\n\t * @param dLen\r\n\t * @return\r\n\t */\r\n\tprivate static int getALen(int dLen) {\r\n\t\tfor (int n = 2; n <= 2 * dLen; n++) {\r\n\t\t\tif (n * n - n - 2 * dLen == 0) {\r\n\t\t\t\treturn n;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * 令aArray为一个由N个已特殊排序数组成的数列：A1，A2，…，AN，其中A1=0。令D为N（N-1）/2个数（定义为Dij=Ai-Aj(i>j\r\n\t * )组成的数列。例如，A=0，1，5，8，那么D=1，3，4，5，7，8\r\n\t * \r\n\t * @param aArray\r\n\t * @return\r\n\t */\r\n\tprivate static Integer[] getDArray(Integer[] aArray) {\r\n\t\tint aLen = aArray.length;\r\n\t\tint dLen = aLen * (aLen - 1) / 2;\r\n\t\tList tempList = new ArrayList();\r\n\t\tfor (int i = 0; i < aArray.length; i++) {\r\n\t\t\tfor (int j = i + 1; j < aArray.length; j++) {\r\n\t\t\t\tif (tempList.size() == dLen) {\r\n\t\t\t\t\ti = aLen;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttempList.add(aArray[j] - aArray[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tInteger[] dArray = tempList.toArray(new Integer[0]);\r\n\t\tArrays.sort(dArray);\r\n\t\treturn dArray;\r\n\t}\r\n}\r\n\r\n```", "Knowledge_Point": "排序", "Question": "令A为一个由N个已特殊排序数组成的数列：A1，A2，…，AN，其中A1=0。令B为N（N-1）/2个数（定义为Dij=Ai-Aj(i>j)）组成的数列。例如，A=0，1，5，8，那么D=1，3，4，5，7，8。请完成：\na）    编写程序，根据A构造D；\nb）    编写程序，构造与D相对应的某一个数列A，注意A不是唯一的", "Tag": "数据结构"}
{"Answer": "public static void main(String[] args) {  \r\n          \r\n        //不指定排序器  \r\n        TreeMap treeMap1 = new TreeMap();  \r\n        treeMap1.put(\"2\", \"1\");  \r\n        treeMap1.put(\"b\", \"1\");  \r\n        treeMap1.put(\"1\", \"1\");  \r\n        treeMap1.put(\"a\", \"1\");  \r\n        System.out.println(\"treeMap1=\"+treeMap1);  \r\n  \r\n        //指定排序器  \r\n        TreeMap treeMap2 = new TreeMap(new Comparator(){  \r\n  \r\n            /* \r\n             * int compare(Object o1, Object o2) 返回一个基本类型的整型， \r\n             * 返回负数表示：o1 小于o2， \r\n             * 返回0 表示：o1和o2相等， \r\n             * 返回正数表示：o1大于o2。 \r\n             */  \r\n            public int compare(String o1, String o2) {  \r\n              \r\n                //指定排序器按照降序排列  \r\n                return o2.compareTo(o1);  \r\n            }     \r\n        });  \r\n        treeMap2.put(\"2\", \"1\");  \r\n        treeMap2.put(\"b\", \"1\");  \r\n        treeMap2.put(\"1\", \"1\");  \r\n        treeMap2.put(\"a\", \"1\");  \r\n        System.out.println(\"treeMap2=\"+treeMap2);  \r\n    }", "Knowledge_Point": "排序", "Question": "用TreeMap实现排序,要求实现comparetor接口,重写compare(T o1,T o2)方法", "Tag": "数据结构"}
{"Answer": "    public static void main(String[] args) {\n        int n = 6;\n        Scanner sc = new Scanner(System.in);\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n", "Knowledge_Point": "排序", "Question": "java 在键盘输入6个整数，将这6个整数按从小到大的顺序排序。", "Tag": "数据结构"}
{"Answer": "当maxi=i时(即在第7行的for循环中未找到比r[i]更大的元素)，待排序列中的最大元素是r[i]，但是经过第20行的交换，r[i]现在是r[mini]，所以需要进行maxi==i的判断来保证交换到n-i+1位置上的是最大元素而不是已完成交换的最小元素。", "Knowledge_Point": "排序", "Question": "第13行的if（maxi == i）进行的操作看不懂，是为了什么情况而写的呀！！求解答", "Tag": "数据结构"}
{"Answer": "\nIt looks like the main issue here is that the \"custom_meta\" value is a quoted JSON string instead of a nested object, which means it cannot be unmarshaled into an object with the (presumably) desired \"part_num\" integer.\nIdeally you could fix the source of this data so that it emits a JSON object instead of a quoted JSON string; however, if that is not feasible, then you could do the following.\n\nHave the \"Custom_meta\" type implement json.Umarshaler by first unquoting the source string and then unmarshaling as usual.\nSort \"Maininfo.Meta\" by the nested \"Custom_meta.Part\" field separately or as part of a custom unmarshaler for that type.\n\nFor example (Go Playground):\ntype MainInfo struct {\n  Id        string     `json:\"id\"`\n  MetaInfos []MetaInfo `json:\"meta\"`\n}\n\ntype MetaInfo struct {\n  Filename    string     `json:\"filename\"`\n  Custom      CustomMeta `json:\"custom_meta\"`\n  Size        int        `json:\"size\"`\n  ContentHash string     `json:\"content_hash\"`\n}\n\ntype CustomMeta struct {\n  PartNum int `json:\"part_num\"`\n}\n\nfunc (cm *CustomMeta) UnmarshalJSON(bs []byte) error {\n  // Unquote the source string so we can unmarshal it.\n  unquoted, err := strconv.Unquote(string(bs))\n  if err != nil {\n    return err\n  }\n\n  // Create an aliased type so we can use the default unmarshaler.\n  type CustomMeta2 CustomMeta\n  var cm2 CustomMeta2\n\n  // Unmarshal the unquoted string and assign to the original object.\n  if err := json.Unmarshal([]byte(unquoted), &cm2); err != nil {\n    return err\n  }\n  *cm = CustomMeta(cm2)\n  return nil\n}\n\nThen you can sort after parsing like so:\nvar doc MainInfo\nerr := json.Unmarshal([]byte(jsonstr), &doc)\nif err != nil {\n  panic(err)\n}\nsort.Slice(doc.MetaInfos, func(i, j int) bool {\n  p1 := doc.MetaInfos[i].Custom.PartNum\n  p2 := doc.MetaInfos[j].Custom.PartNum\n  return p1 < p2\n})\n\nOf course, you could also perform the sorting as part of a custom UnmarshalJSON method for the \"MainInfo\" type.\n", "Knowledge_Point": "排序", "Question": "\n\nTrying to parse the json and sorting based on one of the values of struct.\nI want to sort the json based on the custom_meta's part_num, how we can do that. The code is as follows:\n\ntype Maininfo struct {\n    Id   string     `json:\"id\"`\n    Meta []Metainfo `json:\"meta\"`\n}\n\n\ntype Metainfo struct {\n    Filename     string `json:\"filename\"`\n    Custom_meta  string `json:\"custom_meta\"`\n    Size         int    `json:\"size\"`\n    Content_hash string `json:\"content_hash\"`\n}\n\ntype Custom_meta struct {\n    Part_num string `json:\"part_num\"`\n    Part     int\n}\n\nfunc getMeta(body []byte) (*Maininfo, error) {\n    var s = new(Maininfo)\n    err := json.Unmarshal(body, &s)\n    if err != nil {\n        fmt.Println(\"whoops:\", err)\n    }\n    return s, err\n}\n\n\nfunc getMetainfo(body []byte) (*Metainfo, error) {\n    var s = new(Metainfo)\n    err := json.Unmarshal(body, &s)\n    if err != nil {\n        fmt.Println(\"error\", err)\n    }\n    return s, err\n}\n\ntype AxisSorter []Metainfo\n\nfunc (a AxisSorter) Len() int           { return len(a) }\nfunc (a AxisSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a AxisSorter) Less(i, j int) bool { return a[i].Custom_meta < a[j].Custom_meta }\n\n\ntype NameSorter []Metainfo\n\nfunc (a NameSorter) Len() int           { return len(a) }\nfunc (a NameSorter) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a NameSorter) Less(i, j int) bool { return a[i].Custom_meta < a[j].Custom_meta }\n\nfunc main() {\ns, err := getMeta([]byte(body))\n    fmt.Println(\"Main stuff\", s)\n\n    var metaInfo []Metainfo\n    metaInfo = s.Meta\n}\n    var customMeta CustomMeta\n\n    sort.Sort(AxisSorter(metaInfo))\n    fmt.Println(\"metaInfo sorted \", metaInfo)\n\n    sort.Sort(NameSorter(metaInfo))\n    fmt.Println(\"metaInfo sorted 2 \", metaInfo)\n\n    sort.Slice(metaInfo, func(i, j int) bool {\n        fmt.Println(\"meta \", metaInfo[i].Custom_meta)\n        return metaInfo[i].Custom_meta < metaInfo[j].Custom_meta\n      })\n\n}\n\n\nI am not able to sort the code based on the part_num, how can we do that, since info is not a separate object it is a string. How we can parse string and sort it based on the int value. \n    ", "Tag": "数据结构"}
{"Answer": "逐一排查：1、后端数据的排序是否正确；2、前端接收的数据排序是否和后端传的一致；3、前端展示数据的过程中有没有对数据进行更改。", "Knowledge_Point": "排序", "Question": "在数据后台排版正确调用到HTML页面上就出现了顺序乱了，这，不知道什么原因出现这种，在后面排好序，调用完出现乱序\n\n\n所有的都加   desc  排过序了", "Tag": "数据结构"}
{"Answer": "//以这个为准\r\n\tfor(int i=0;ilist.get(j)){\r\n\t\t\t\t\t\t\tmin=j;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint minValue=list.get(min);//记录最小值\r\n\t\t\t\t\t//当前元素和最小值交换位置\r\n\t\t\tlist.set(min,list.get(i));\r\n\t\t\tlist.set(i,minValue);\r\n\t}", "Knowledge_Point": "排序", "Question": "ArrayList list = new ArrayList( );\n然后添加几个元素，进行排序。要求不能用collections工具类。我之前用了数组里面的冒泡排序，可是无论怎么排，都没有效果，求大神指教。", "Tag": "数据结构"}
{"Answer": "\n int arr [] ={4,1,7,2,9,3,5,8,6};\n        //冒泡排序由大到小\n        for (int i = 0; i < arr.length-1; i++）{\n            for (int j = 0; j < arr.length-1 ; j++) {\n                if (arr[j]<arr[j+1]){\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n\n        //取得最大值\n        int temp = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if(arr[i]>temp){\n                temp = arr[i];\n            }\n        }\n        System.out.println(temp);\n\n", "Knowledge_Point": "排序", "Question": "nt[] array=new int[]{4，1，7，2，9，3，5，8，6}怎么给他从大到小排序并且取最大值和最小值并且用冒泡排序来解决，新手尽量给个翻译", "Tag": "数据结构"}
{"Answer": "曾经jquery写的：\r\n\r\n$(function(){\r\n\r\n    $(\"table[id='cjxmTable'] tr:gt(0)\").each(function(index){\r\n       var id = index+1;\r\n       $(this).find(\"td\").eq(0).text(id);\r\n    })\r\n      \r\n});", "Knowledge_Point": "排序", "Question": "正常是这样的，一个表格，例如： \n\n\n\n序号\n名称\n时间\n\n\n1\nAA\n2011-1-1\n\n\n2\nBB\n2011-1-2\n\n\n3\nCC\n2011-1-3\n\n当我点击时间列排序的时候，\n\n \n\n\n\n序号\n名称\n时间\n\n\n2\nCC\n2011-1-3\n\n\n3\nBB\n2011-1-2\n\n\n1\nAA\n2011-1-1\n\n序号列也就跟着变了，怎么才能让序号列保持不变，一直是正常的排序，请指教", "Tag": "数据结构"}
{"Answer": "\nYou don't need to sort the array. Just search the src from the \"Array to order\" and add the id in the original array.\n$originalArray = [\n    [\n        'src' => '2GK2VWE-ax--0'\n    ],\n    [\n        'src' => '13KXEXyJaM9-0'\n    ],\n    [\n        'src' => '138XELryjM9-0'\n    ]\n];\n\n$sortedArray = [\n    [\n        'src' => '13KXEXyJaM9-0',\n        'id' => 123468\n    ],\n    [\n        'src' => '138XELryjM9-0',\n        'id' => 15784239\n    ],\n    [\n        'src' => '2GK2VWE-ax--0',\n        'id' => 12558456\n    ]\n];\n\n$src = array_column($originalArray, 'src');\nforeach ($sortedArray as $data) {\n    if (false !== $key = array_search($data['src'], $src)) {\n        $originalArray[$key]['id'] = $data['id'];\n    }\n}\n\nvar_dump($originalArray);\n\nOutput:\narray(3) {\n  [0]=>\n  array(2) {\n    [\"src\"]=>\n    string(13) \"2GK2VWE-ax--0\"\n    [\"id\"]=>\n    int(12558456)\n  }\n  [1]=>\n  array(2) {\n    [\"src\"]=>\n    string(13) \"13KXEXyJaM9-0\"\n    [\"id\"]=>\n    int(123468)\n  }\n  [2]=>\n  array(2) {\n    [\"src\"]=>\n    string(13) \"138XELryjM9-0\"\n    [\"id\"]=>\n    int(15784239)\n  }\n}\n\n", "Knowledge_Point": "排序", "Question": "\n\nI am currently trying to order an array based on the value of another array. The values are unique. I seen examples of how to order an array based on the keys of another array but I cant seem to find one that specifically orders an array by the value of another array. Both arrays have the same values. One array has an additional key id. How could I achieve that? \n\nArray to follow order:\n\nArray\n(\n[0] => Array\n    (\n        [src] => 2GK2VWE-ax--0\n    )\n\n[1] => Array\n    (\n        [src] => 13KXEXyJaM9-0\n    )\n\n[2] => Array\n    (\n        [src] => 138XELryjM9-0\n    )\n)   \n\n\nArray to order:\n\nArray\n(\n[0] => Array\n    (\n        [src] => 13KXEXyJaM9-0\n        [id] => 123468\n    )\n[1] => Array\n    (\n        [src] => 138XELryjM9-0\n        [id] => 15784239\n    )\n\n[2] => Array\n    (\n        [src] => 2GK2VWE-ax--0\n        [id] => 12558456\n    )\n)\n\n\nDesired order:\n\nArray\n(\n    [0] => Array\n    (\n        [src] => 2GK2VWE-ax--0\n        [id] => 12558456\n    )\n\n[1] => Array\n    (\n        [src] => 13KXEXyJaM9-0\n        [id] => 123468\n    )\n\n[2] => Array\n    (\n        [src] => 138XELryjM9-0\n        [id] => 15784239\n    )\n)\n\n    ", "Tag": "数据结构"}
{"Answer": "一个简单的实现：\n#include <stdio.h>\n#include <string.h>\n#define MAXSTUDENTS 5\n#define NAMELENGTH 20\nint main(){\n    \n    int j,i;\n    char  temp[NAMELENGTH] ;\n    char  a [MAXSTUDENTS][NAMELENGTH] ; //存储一个小组的学生名字 ，默认小组最多不超过5人，每个人名字不超过20个字符 ,可以自己定义 \n//    printf(\"1\\n\");\n    \n    printf(\"请输入小组每个人的姓名：\\n\");\n    for(i=0;i<MAXSTUDENTS;i++){\n        scanf(\"%s\",a[i]); \n    } \n//    printf(\"输入信息为：\\n\");\n//    for(i=0;i<MAXSTUDENTS;i++){\n//        printf(\"%s\\n\",a[i]); \n//    } \n    for(j=0;j<MAXSTUDENTS-1;j++){  //遍历姓名字符串数组 \n        \n        //printf(\"2\\n\");\n        for(i=j+1;i<MAXSTUDENTS;i++){   //逐个将当前数组i位置的名字和后面的每个位置的名字进行比较，按ASCII码大小从小到大排列 \n            //printf(\"3\\n\");\n            if(strcmp(a[i],a[j])<0){  //如果当前i为主的姓名字符串比i位置后面的字符串第一个字母ASCII码小 ，则交换这个字符串 \n            //    printf(\"i=%d,j=%d,a[%d]=%s,a[%d]=%s\\n\",i,j,i,a[i],j,a[j]);\n                strcpy(temp,a[j]);\n                strcpy(a[j],a[i]);\n                strcpy(a[i],temp);\n            //    printf(\"after change,i=%d,j=%d,a[%d]=%s,a[%d]=%s\\n\",i,j,i,a[i],j,a[j]);\n//                temp = a[i];\n//                a[i] = a[j];\n//                a[j] = temp; \n            }\n        }\n    }\n    \n    printf(\"排序后的结果为：\\n\");\n    for(i=0;i<MAXSTUDENTS;i++){\n        printf(\"%s\\n\",a[i]);\n    }\n    \n    return 0;\n} \n\n", "Knowledge_Point": "排序", "Question": "编写一个程序，将你一个小组的所有姓名存储到一个二维数组中，对名称进行排序并按顺序输出。", "Tag": "数据结构"}
{"Answer": "C语言中关于排序问题（一冒泡排序）c语言冒泡排序，指针，数组C语言经典算法：冒泡排序----------------------biu~biu~biu~~~在下问答机器人小D，这是我依靠自己的聪明才智给出的答案，如果不正确，你来咬我啊！", "Knowledge_Point": "排序", "Question": "#include\n#include\n\nint main(){\n      void sort(char *name[],int n);\n      char * alphabet[ ]={\"Follow me\",\"BASIC\",\"Great Wall\",\"FORTRAN\",\"Computer design\"};\n      int n = 5;\n      sort(alphabet,n);\n      for(int i=0;i<5;i++)\n        printf(\"%s\\n\",alphabet[i]);\n      return 0;\n   }\n\nvoid sort(char *name[],int n){\n      int i=0,j=0;\n      char *temp;\n      for(;i<=4;i++){\n        for(;j<=n-j-1;j++){\n            if(strcmp(name[j],name[j+1])>0){\n                    temp = name[j];\n                    name[j] = name[j+1];\n                    name[j+1] = temp;\n            }\n        }\n      }\n    }\n\n    代码如上，想要通过ASCII码来比较alphabet中的字符串，并按照英文字母的顺序输出。函数SORT重用的冒泡排序，但输出的结果里只有第一位和第二位正确调换了位置，不知道问题出在哪里？请指教！万分感谢！！！\n", "Tag": "数据结构"}
{"Answer": "\nCompare method\nEither you implement a compare-method for your object:\n- (NSComparisonResult)compare:(Person *)otherObject {\n    return [self.birthDate compare:otherObject.birthDate];\n}\n\nNSArray *sortedArray = [drinkDetails sortedArrayUsingSelector:@selector(compare:)];\n\nNSSortDescriptor (better)\nor usually even better:\nNSSortDescriptor *sortDescriptor;\nsortDescriptor = [[NSSortDescriptor alloc] initWithKey:@\"birthDate\"\n                                           ascending:YES];\nNSArray *sortedArray = [drinkDetails sortedArrayUsingDescriptors:@[sortDescriptor]];\n\nYou can easily sort by multiple keys by adding more than one to the array. Using custom comparator-methods is possible as well. Have a look at the documentation.\nBlocks (shiny!)\nThere's also the possibility of sorting with a block since Mac OS X 10.6 and iOS 4:\nNSArray *sortedArray;\nsortedArray = [drinkDetails sortedArrayUsingComparator:^NSComparisonResult(id a, id b) {\n    NSDate *first = [(Person*)a birthDate];\n    NSDate *second = [(Person*)b birthDate];\n    return [first compare:second];\n}];\n\nPerformance\nThe -compare: and block-based methods will be quite a bit faster, in general, than using NSSortDescriptor as the latter relies on KVC.  The primary advantage of the NSSortDescriptor method is that it provides a way to define your sort order using data, rather than code, which makes it easy to e.g. set things up so users can sort an NSTableView by clicking on the header row.\n", "Knowledge_Point": "排序", "Question": "\n\nWhat I want to do seems pretty simple, but I can't find any answers on the web. I have an NSMutableArray of objects, and let's say they are 'Person' objects. I want to sort the NSMutableArray by Person.birthDate which is an NSDate.\n\nI think it has something to do with this method:\n\nNSArray *sortedArray = [drinkDetails sortedArrayUsingSelector:@selector(???)];\n\n\nIn Java I would make my object implement Comparable, or use Collections.sort with an inline custom comparator...how on earth do you do this in Objective-C?\n    \n\n转载于:https://stackoverflow.com/questions/805547/how-do-i-sort-an-nsmutablearray-with-custom-objects-in-it", "Tag": "数据结构"}
{"Answer": "不是问过了么〉。。。。。。\n#include  <iostream>\nusing namespace std;\ntypedef struct _sqlist\n{\n    int data[1000];\n    int length;\n}sqlist;\n \nvoid create(sqlist *s,int m,int n)\n{\n    int i=0;\n    printf(\"请输入%d个递增数:\\n\",m);\n    for(i=0;i<m;i++)\n        scanf(\"%d\",&s->data[i]);\n    printf(\"请输入%d个递增数:\\n\",n);\n    for(i=0;i<n;i++)\n        scanf(\"%d\",&s->data[i+m]);\n    s->length = m+n;\n}\n \nvoid sorts(sqlist *s,int m,int n)\n{\n    int i,j,k,t;\n    for(i=m;i<s->length;i++)\n    {\n        t = s->data[i];\n        for(j=0;j<i;j++)\n        {\n            if(s->data[j] >= s->data[i])\n            {\n                for(k=i;k>j;k--)\n                    s->data[k] = s->data[k-1];\n                s->data[j] = t;\n                break;\n            }\n        }\n    }\n}\n \nvoid print(sqlist *s)\n{\n    int i=0;\n    for(i=0;i<s->length;i++)\n        printf(\"%d \",s->data[i]);\n}\n \nint main()\n{\n    sqlist s;\n    int m,n;\n    printf(\"请输入两个递增序列的数量:\\n\");\n    scanf(\"%d%d\",&m,&n);\n    create(&s,m,n);\n    sorts(&s,m,n);\n    print(&s);\n    return 0;\n}\n \n\n", "Knowledge_Point": "线性表", "Question": "有一个存放整数的长度为m+n的线性表L，其前m个元素单调递增，后n个元素也单调递增。设计一个算法，使得整个线性表的元素单调递增。要求：使用链式存储实现。", "Tag": "数据结构"}
{"Answer": "\nList Delete( List L, ElementType minD, ElementType maxD )\n{\n    \n    int i,j=0,k = L->Last;\n     for(i = 0;i<=k;i++)\n    {\n        if(L->Data[i]<=minD||L->Data[i]>=maxD)\n        {\n            L->Data[j++] =  L->Data[i];\n        }\n        else L->Last--;\n     }\n    return L;\n    \n}\n\n", "Knowledge_Point": "线性表", "Question": "给定一个顺序存储的线性表，请设计一个函数删除所有值大于min而且小于max的元素。删除后表中剩余元素保持顺序存储，并且相对位置不能改变。函数接口定义：List Delete( List L, ElementType minD, ElementType maxD );其中List结构定义如下：typedef int Position;typedef struct LNode *List;struct LNode{ElementType Data[MAXSIZE]; /ElementType 可以用C中基本数据类型，比如：int等/\nPosition Last; /* 保存线性表中最后一个元素的位置 */};L是用户传入的一个线性表，其中ElementType元素可以通过>、==、<进行比较；minD和maxD分别为待删除元素的值域的下、上界。函数Delete应将Data[]中所有值大于minD而且小于maxD的元素删除，同时保证表中剩余元素保持顺序存储，并且相对位置不变，最后返回删除后的表。\n程序样例：\n#include \n#define MAXSIZE 20\ntypedef int ElementType;\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode {\nElementType Data[MAXSIZE];\n\nPosition Last; /* 保存线性表中最后一个元素的位置 */\n\n};\nList ReadInput(List L); /* 此函数实现线性表的输入。元素从下标0开始存储 */\nvoid PrintList( List L ); /* 此函数实现线性表的输出*/\nList Delete( List L, ElementType minD, ElementType maxD );\nint main()\n{\nList L;\n\nElementType minD, maxD;\n\nint i;\n\nL = ReadInput();\n\nscanf(\"%d %d\", &minD, &maxD);\n\nL = Delete( L, minD, maxD );\n\nPrintList( L );\n\nreturn 0;\n\n}  \nList ReadInput()   /* 此函数创建线性表并实现线性表的输入。返回线性表的地址。元素从下标0开始存储 */\n{\n}\nvoid PrintList( List L )/* 此函数实现线性表的输出*/\n{\n}\nList Delete( List L, ElementType minD, ElementType maxD )\n{\n}", "Tag": "数据结构"}
{"Answer": "```\r\n #include \r\n\r\nvoid swp(int& a, int& b)\r\n{\r\n    int c = a;\r\n    a = b;\r\n    b = c;\r\n}\r\n\r\nint main()\r\n{\r\n    int z = 0, i = 0;\r\n    int data[] = {2,-1,0,5,-3,8,-2,-9,0,8};\r\n    for (i = 0; i < 10; i++)\r\n    {\r\n        if (data[i] < 0)\r\n        {\r\n            swp(data[i], data[z]);\r\n            z++;\r\n        }\r\n    }\r\n    for (i = 0; i < 10; i++) printf(\"%d \", data[i]);\r\n}\r\n```\r\n\r\n-1 -3 -2 -9 2 8 0 5 0 8", "Knowledge_Point": "线性表", "Question": "若一个线性表L采用顺序存储结构存储，其中所有元素为整数，设计一个算法，将所有小于0的元素面前，要求算法的时间复杂度为O（n）,空间复杂度为O（l）", "Tag": "数据结构"}
{"Answer": "你好，顺序存储结构查找第k个元素，是直接由起始地址+偏移量(元素大小*k)得到的，所以是O(1)；链式存储由于不是顺序存储的，元素地址不是连续的，需要一个一个往后找k次，所以是O(k）。", "Knowledge_Point": "线性表", "Question": "对于线性表，在顺序存储结构和链式存储结构中查找第k个元素，其时间复杂性分别是多少？\n\n\n\tA.\n\n\t都是O(1)\n\t\n\tB.\n\n\t都是O(k)\n\t\n\tC.\n\n\tO(1)和O(k)\n\t\n\tD.\n\n\tO(k)和O(1)\n\t", "Tag": "数据结构"}
{"Answer": "先得定义线性表结构。\n#include <iostream>\nusing namespace std;\n#define MAXSIZE 1000\ntypedef struct _sqlist\n{\n    int data[MAXSIZE];\n    int len;\n}sqlist;\n\nvoid InitList(sqlist *sq)\n{\n    sq->len = 0;\n    memset(sq->data,0,MAXSIZE);\n}\n\nvoid PutseqList(sqlist *sq)\n{\n    cout<<\"请输入顺序表需要添加的元素数量:\";\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        cout<<\"请输入第\"<<i+1<<\"个元素：\";\n        cin>>sq->data[sq->len++];\n    }\n}\n\nvoid OutputseqList(sqlist *sq)\n{\n    for(int i=0;i<sq->len;i++)\n        cout<<sq->data[i]<<\" \";\n}\n\nint main()\n{\n    sqlist sq;\n    InitList(&sq);\n    PutseqList(&sq);\n    OutputseqList(&sq);\n    return 0;\n}\n\n", "Knowledge_Point": "线性表", "Question": "2.编写函数InitList()用来初始化一个空的线性表，编写函数PutseqList()用来输入一个线性表，编写函数OutputseqList()用来输出线性表。", "Tag": "数据结构"}
{"Answer": "参考GPT和自己 的思路，在代码中，读取输入字符的语句使用了scanf(\"%c\",&L->data[i])，但是输入时输入的字符带有回车符（\\n），回车符也被读取到了字符数组中，导致读入字符的数目少于期望值。因此，输出时表中的元素都为空。\n为解决这个问题，可以在读取字符前添加一个空格。\n下面是BuildList函数修改后的代码：\nvoid BuildList(SeqList *L)\n{\n    int i;\n    printf(\"ÈôÄãÊäÈëµÄÊý¾ÝÎª'0'Ê±£¬Ôò½áÊøÊäÈë\\n\");\n    for(i=0;i<100;i++)\n    {\n        printf(\"ÊäÈëÊý¾Ý:\");\n        scanf(\" %c\",&L->data[i]); // 在这里添加了一个空格\n        if(L->data[i]=='0')\n            break;\n        L->last++;\n    }\n    if(i==99)\n        printf(\"ÎÞ·¨¼ÌÐø´´½¨£¡\\n\");\n    printf(\"*************´´½¨³É¹¦£¡*************\\n\");\n}\n\n希望能帮你解决问题，还请采纳！！！", "Knowledge_Point": "线性表", "Question": "\n线性表顺序存储这样写，运行结果为什么显示表元素会是空的，代码哪里有问题", "Tag": "数据结构"}
{"Answer": "\n#include <stdio.h>\nconst int n = 8;\nint main() {\n\tint a[n];\n\tint i = 0;\n\tfor (; i < n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t}\n\tprintf(\"正序存放：\\n\");\n\tfor (i = 0; i < n; ++i) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tprintf(\"\\n倒序存放\\n\");\n\tfor (i = n - 1; i >= 0; --i){\n\t\tprintf(\"%d \", a[i]);\n\t}\n\treturn 0;\n}\n以上是代码。其实不用去实际存放，直接从开头到结尾，再从结尾返回到开头这样输出一下就行了，空间复杂度是O（1）。如果存放的话空间复杂度就是O（n）了。\n哪里不懂私信我。", "Knowledge_Point": "线性表", "Question": "从键盘输入长度为8的整型数组的值，然后将其按逆序存放，将逆序前和逆序后的数组输出。\n\n \n\n \n\n ", "Tag": "数据结构"}
{"Answer": "1 2 4 8 9 5 10 11 3 6 7", "Knowledge_Point": "线性表", "Question": "已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列", "Tag": "数据结构"}
{"Answer": "创建一个空的哈希表，用于存储单循环链表中已经出现过的结点值。从链表的头结点开始遍历链表。如果当前结点的值已经在哈希表中出现过，则删除当前结点。如果当前结点的值没有在哈希表中出现过，则将当前结点的值插入到哈希表中。继续遍历下一个结点，直到遍历完整个链表。\nstruct Node {\n    int val;\n    struct Node *next;\n};\n\nvoid remove_duplicate(struct Node *head) {\n    unordered_set<int> hash;\n    struct Node *curr = head, *prev = NULL;\n    while (curr != head || prev == NULL) {\n        if (hash.count(curr->val)) {\n            prev->next = curr->next;\n            free(curr);\n        } else {\n            hash.insert(curr->val);\n            prev = curr;\n        }\n        curr = prev->next;\n    }\n}\n", "Knowledge_Point": "线性表", "Question": "如何用C语言实现在单循环链表上实现删除所有重复的结点，已完成的代码如下：\n// 单链表，定义结构体\n#include \n#include\ntypedef struct lian_biao{\n    int data; \n    struct lian_biao* p_data; \n}L;\n\n// 建立单循环链表\nL* creat_list(){\n    L* head=(L*)malloc(sizeof(L));\n    L *rear=head,*p=NULL;\n    int input=0;\n    printf(\"依次输入,以0结束\\n输入第1个元素的值:\");\n    scanf(\"%d\",&input);\n    while(0 != input){\n        p=(L*)malloc(sizeof(L));\n        p->data=input;\n        rear->p_data=p;\n        rear=p;\n        scanf(\"%d\",&input);\n    }\n    rear->p_data=head;\n    return head;\n}\n\n求详细解答 谢谢", "Tag": "数据结构"}
{"Answer": "#include \r\n\r\nusing namespace std;   //加上这句\r\n\r\ntemplate < class Elem >\r\nclass AList : public list\r\n\r\n或者\r\n\r\n#include \r\ntemplate < class Elem >\r\nclass AList : public std::list   //改成这样", "Knowledge_Point": "线性表", "Question": "看《数据结构与算法分析》，用书上的代码创建线性表的顺序表。\n可是编译出现错误，求解答。\nAList.h\n\n #include \ntemplate < class Elem >\nclass AList : public List\n{\nprivate:\n    int maxSize;\n    int listSize;\n    int fence;\n    Elem* listArray;\npublic:\n    AList(int size=DefaultListSize)\n    {\n        maxSize = size;\n        listSize = fence = 0;\n        listArrary = new Elem[maxSize];\n    }\n    ~AList(void)\n    {\n        delete [] listArrary;\n    }\n    void clear()\n    {\n        delete [] listArrary;\n        listArrary = fence = 0;\n        listArrary = new Elem[maxSize];\n    }\n    bool insert(const Elem&);\n    bool append(const Elem&);\n    bool remove(Elem&);\n    void setStart()\n    {\n        fence = 0;\n    }\n    void setEnd()\n    {\n        fence = listSize;\n    }\n    void prev()\n    {\n        if(fence != 0)\n            fence--;\n    }\n    void next()\n    {\n        if(fence <= listSize)\n            fence++;\n    }\n    int liftLength() const\n    {\n        return fence;\n    }\n    int right() const\n    {\n        return listSize - fence;\n    }\n    bool setPos(int Pos)\n    {\n        if((Pos >= 0) && (Pos <= listSize))\n            fence = pos;\n        return (pos >= 0) && (pos <= listSize)\n    }\n    bool getValue(Elem& it) const\n    {\n        if(rightLength() == 0)\n            return false;\n        else\n        {\n            it = listArrary[fence];\n            return true;\n        }\n    }\n    void print() const\n    {\n        int temp = 0;\n        cout<<\"< \";\n        while(temp < fence)\n            cout<\\n\"\n    }\n};\n\n\n\nAList.cpp\n\n #include \"AList.h\"\ntemplate \nbool AList::insert(const Elem& item)\n{\n    if(listSize == maxSize)\n        return false;\n    for(int i=listSize;i>fence;i++)\n        listArrary[i] = listArrary[i-1];\n    listArrary[fence] = item;\n    listSize++;\n    return true;\n}\ntemplate \nbool AList::append(const Elem& item)\n{\n    if(listSize == maxSize)\n        return false;\n    listArrary[listSize++] = item;\n    return true;\n}\ntemplate \nbool AList::remove(Elem& it)\n{\n    if(rightLength() == 0)\n        return false;\n    it = listArrary[fence];\n    for(int i=fence;i < listSize-1;i++)\n        listArrary[i] = listArrary[i+1];\n    listSize--;\n    return true;\n}\n\n\n\n编译错误为：alist.h(4): error C2143: 语法错误 : 缺少“,”(在“<”的前面)", "Tag": "数据结构"}
{"Answer": "\n#include <string.h>\n#include <stdio.h>\n\ntypedef struct _node\n{\n    char *data;\n    int length;\n} Node;\n\nint main()\n{\n    Node head = {0};\n    head.data = (char *)malloc(100 * sizeof(char));\n    int i = 0;\n    char ch;\n    while (i < 100 && (ch = getchar()) != '\\n')\n    {\n        if (ch == ' ')\n            continue;\n        head.data[i++] = ch;\n    }\n    head.length = i;\n\n    for (i = 0; i < head.length - 1; i++)\n    {\n        for (int j = i + 1; j < head.length; j++)\n        {\n            if (head.data[i] == head.data[j])\n            {\n                memcpy(&head.data[j], &head.data[j + 1], head.length - j);\n                head.length--;\n                i--;\n            }\n        }\n    }\n    char *p = (char *)malloc(head.length * sizeof(char));\n    memcpy(p, head.data, head.length);\n    free(head.data);\n    head.data = p;\n\n    for (i = 0; i < head.length; i++)\n    {\n        printf(\"%c \", head.data[i]);\n    }\n\n    return 0;\n}\n", "Knowledge_Point": "线性表", "Question": "\n我用循环输入没有输出，刚刚开始学，希望可以解答一下，求指教😊😊非常感谢", "Tag": "数据结构"}
{"Answer": "参考GPT和自己的思路：是的，如果是采用不带头结点双向链表存储的线性表，在删除一个元素时需要修改指针4次。但是如果采用带头结点的双向链表存储，在删除一个元素时只需要修改指针2次。因为头结点的存在，可以避免对头节点的特判，从而减少了指针的修改次数。", "Knowledge_Point": "线性表", "Question": " 采用带头结点双向链表存储的线性表，在删除一个元素时，需要修改指针（） 次。A.1 B.2 C.3 D.4.标准答案：B是不是这个不带头结点，删除一个元素就需要修改指针四次啊", "Tag": "数据结构"}
{"Answer": "#define MaxSize 100000\n#include<stdio.h>\n#include<stdlib.h>\n \ntypedef int ElemType;\ntypedef struct{\n    ElemType data[MaxSize];\n    int length;\n}List;\n \nvoid InitList(List &l){\n    l.length=0;\n}\nvoid swap(int *a,int *b) \n{\n    int t=*a;*a=*b;*b=t;\n}\nint InsElem(List &l,ElemType x,int i){\n    int j;\n    if(i<1||i>l.length+1)\n        return 0;\n    for(j=l.length;j>i;j--)\n        l.data[j]=l.data[j-1];\n    l.data[i-1]=x;\n    l.length++;\n    return 1;\n}\nvoid DispList(List l){\n    int i;\n    for(i=0;i<l.length;i++)\n        printf(\"%d \",l.data[i]);\n    printf(\"\\n\");\n}\nvoid move(List &l){\n    int i=0,j=l.length-1;\n    /*while (l.data[i]>=0,i++,l.data[j]<0,j--)\n    if (i<l.length)\n    {\n    swap(&l.data[i],&l.data[j]);\n    } */\n    for(i=0;i<l.length-1;i++)\n    for(j=0;j<l.length-1-i;j++)\n    if(l.data[j]>l.data[j+1]) swap(&l.data[j],&l.data[j+1]);\n}\n \nint main(){\n    int i;\n    ElemType e;\n    List l;\n    InitList(l);\n    InsElem(l,-1,1);\n    InsElem(l,9,2);\n    InsElem(l,-2,3);\n    InsElem(l,0,4);\n    InsElem(l,5,5);\n    InsElem(l,-3,6); \n    printf(\"线性表：\");DispList(l);\n    move(l);\n    printf(\"线性表：\");DispList(l);\n}\n", "Knowledge_Point": "线性表", "Question": "假设一个顺序表中所有元素为整数，设计一个算法，使其中小于零的元素移动到所有大于等于零的前面大家帮看看哪里出错了，第一次写，谢谢各位了\n\n#define MaxSize 100000\n#include\n#include\n\ntypedef int ElemType;\ntypedef struct{\n    ElemType data[MaxSize];\n    int length;\n}List;\n\nvoid InitList(List &l){\n    l.length=0;\n}\nint InsElem(List &l,ElemType x,int i){\n    int j;\n    if(i<1||i>l.length+1)\n        return 0;\n    for(j=l.length;j>i;j--)\n        l.data[j]=l.data[j-1];\n    l.data[i-1]=x;\n    l.length++;\n    return 1;\n}\nvoid DispList(List l){\n    int i;\n    for(i=0;i=0,i++,l.data[j]<0,j--);\n    if (i<j)\n        swap(l.data[i],l.data[j]);\n    \n}\n\nint main(){\n    int i;\n    ElemType e;\n    List l;\n    InitList(l);\n    InsElem(l,-1,1);\n    InsElem(l,9,2);\n    InsElem(l,-2,3);\n    InsElem(l,0,4);\n    InsElem(l,5,5);\n    InsElem(l,-3,6); \n    printf(\"线性表：\");DispList(l);\n    move(l);\n    printf(\"线性表：\");DispList(l);\n}\n\n", "Tag": "数据结构"}
{"Answer": "就是这个struct里面有一个指针,指向下一个node的地址你可以通过这个指针找到链表的下一个节点", "Knowledge_Point": "线性表", "Question": "typedef int ElemType;/线性表的单链表存储结构/typedef struct Node{    ElemType data;    struct Node *next;}Node;typedef struct Node *LinkList;//定义LinkList", "Tag": "数据结构"}
{"Answer": "你定义的是date可是你用的时候是data\nelemtype date[maxsize];修改为elemtype data[maxsize];\n如有帮助，请采纳。", "Knowledge_Point": "线性表", "Question": "\n#include\n#include\n#define maxsize 10\ntypedef int elemtype;\n\n\ntypedef struct \n{\n\telemtype date[maxsize];\n\tint length;\n}sqlist;\n\n\nvoid createlist(sqlist *&l,int a[],int n)\n{\n\tint i=0,k=0;\n\tl=(sqlist *)malloc(sizeof(sqlist));\n\twhile(idata[k]=a[i];\n\t\tk++;i++;\n\t}\n\tl->length=k;\n}\n\n\nvoid main()\n{\n\tsqlist *h;\n\tint n=5;\n\tint a[]={1,3,1,4,2};\n\tcreatelist(h,a,n);\n}\n\n\nD:\\编程\\线性表\\线性表.cpp(20) : error C2039: 'data' : is not a member of 'sqlist'\n        D:\\编程\\线性表\\线性表.cpp(8) : see declaration of 'sqlist'\n执行 cl.exe 时出错.\n\n线性表.obj - 1 error(s), 0 warning(s)\n\n请指出错误及改正，谢谢\n ", "Tag": "数据结构"}
{"Answer": "是否要求哨兵节点？\n#include <stdio.h>\n#include <string.h>\ntypedef struct _Node\n{\n    char word[30];\n    int count;\n    struct _Node * next;\n}Node;\n\nvoid AddNode(Node *head,char *word)\n{\n    Node *p = head;\n    while(p->next != NULL)\n    {\n        if(strcmp(p->next->word,word) == 0)\n        {\n            p->next->count++;\n            return;\n        }\n        p = p->next;\n    }\n    Node *q = (Node*)malloc(sizeof(Node));\n    q->next= NULL;\n    p->next= q;\n    q->count = 1;\n    strcpy(q->word,word);\n}\n\nint main()\n{\n    Node head;\n    head.next = NULL;\n    head.count = 0;\n    //\n    int n;\n    printf(\"输入单词数量:\");\n    scanf(\"%d\",&n);\n    char word[30] = {0};\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%s\",word);\n        AddNode(&head,word);\n    }\n    Node *p = head.next;\n    Node *q = p;\n    while(p != NULL)\n    {\n        if(p->count > q->count)\n            q = p;\n        p = p->next;\n    }\n    printf(\"出现次数最多单词为：%s\\n\",q->word);\n    return 0;\n}\n\n", "Knowledge_Point": "线性表", "Question": "线性表的应用实验目的：掌握线性表的基本结构和操作方法，培养学生灵活使用表解决实际问题的能力。实验内容： 键盘输入英语单词的个数n及n个单词，编写程序，建立一个单向链表，实现： （1）如果单词重复出现，则只在链表上保留一个。（2）除满足（1）的要求外。链表结点还应有一个计数域，记录该单词重复出现的次数，然后输出出现次数最多的前k(k<=n，需键盘输入)个单词。注：次数并列的情况考虑、不考虑均可。提示：本题链表结点的数据域存放英文单词，可用字符数组表示，单词重复出现时，链表中只保留一个，单词是否相等的判断使用strcmp函数，结点中增设计数域，统计单词重复出现的次数。", "Tag": "数据结构"}
{"Answer": "typedef int ElemType,所有的int都用ElemType代替，要修改为float直接把头文件中的typedef int ElemType，改成typedef float ElemType", "Knowledge_Point": "线性表", "Question": "如果基础实验中的线性表的数据元素不是int型，而是float类型，则需要把程序中所有int全部改为float?是否有其它快捷的解决方案？（提示：一个工程可以有多个头文件）", "Tag": "数据结构"}
{"Answer": "你意思链表数据就是一个整型呗？\nvoid remove(Linklist head,int x,int y)\n{\n      Linklist p = head->next;\n      Linklist q = head;\n      while(p != NULL)\n      {\n            if(p->data >x && p->data <y)\n            {\n                  q->next = p->next;\n                  free(p);\n                  p = q->next;\n            }\n            else\n            {\n                q = p;\n                p = p->next;\n            }\n      }\n}\n\n", "Knowledge_Point": "线性表", "Question": "已知线性表中的元素的值递增有序排列，并以单链表作存储结构。试写一个算法（函数），删除表中所有大于x且小于y（x<y）的元素（若表中存在这样的元素）同时释放被删除结点空间。对上一题，用顺序表如何实现？", "Tag": "数据结构"}
{"Answer": "如果用二维数组表示邻接矩阵，那么显然需要结点个数，也就是数组的大小。\r\n而边的条数，不是必须的，一般来说，用于2个方面：\r\n（1）从键盘输入边的时候，循环几次，完成输入\r\n（2）无需遍历，可以给出有多少边", "Knowledge_Point": "线性表", "Question": "邻接矩阵法写图存储结构，需要设置结点和线条个数，那么设置这个有什么用呢？\n我清楚链表线性表设置这个有效数值个数，是为了等长度为0的时候，释放掉，防止占用资源。\n但是图的话，至少要有个结点，我感觉设置结点和线条个数没有意义，请反驳我", "Tag": "数据结构"}
{"Answer": "函数调用是值传递，当调用Create 函数时，其实时复制了一份Line数据到形参L，这样实参里的值不会改变。\r\nvoid Creat(Line L, int len)\r\n\r\n参考：\r\n\r\n```\r\n#include \r\n#define Size 10 //定义数组的大小\r\ntypedef struct line\r\n{\r\n\r\n    int data[Size];\r\n    int Length;            //当前数组中数据的个数\r\n\r\n}Line;\r\n\r\nvoid Creat(Line * L, int len){ //第一个形参为线性表，第二个形参为要输入数据的个数\r\n\tfor(int i=0;idata[i]=i;\r\n\t}\r\n\treturn;\r\n}\r\nvoid Print(Line L, int len){ //输出数据\r\n\tfor(int i=0;i<len;i++)\r\n\t{\r\n\t\tprintf(\"Line [%d]=%d\\n\", i, L.data[i]);\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n    Line lin;\r\n    Creat(&lin, 5);\r\n    Print(lin, 5);\r\n\r\n    getchar();\r\n    getchar();\r\n    return 0;\r\n}\r\n\r\n```", "Knowledge_Point": "线性表", "Question": "#include \n#define Size 10       //定义数组的大小\ntypedef struct line\n\n{\n\nint data[Size];\nint Length;            //当前数组中数据的个数\n\n\n}Line;\n\nvoid Creat(Line L, int len);     //第一个形参为线性表，第二个形参为要输入数据的个数\n\nvoid Print(Line L, int len);     //输出数据\n\nint main()\n\n{\n\nLine lin;\nCreat(lin, 5);\nPrint(lin, 5);\n\ngetchar();\ngetchar();\nreturn 0;\n\n\n}", "Tag": "数据结构"}
{"Answer": "#define 后面的分号去掉，标准写法是没有分号，但有某些编译器能够忽略这种错误，如果教材是这么写的，说明写这本书的人也就会写写书吧", "Knowledge_Point": "线性表", "Question": "#include\n#include\nusing namespace std;\n#define listinitsize 10;\n#define listincrement 10;\n#define error 0;\n#define ok 1;\n#define overflow -1;\ntypedef int status;\n前面这段代码我可能会有影响所以我就把它粘上了\ntypedef struct{\n    int *elem;\n    int length;\n    int listsize;\n} sqlist;//创建结构体\nstatus initlistsq(sqlist &l)//用c++初始话线性表\n{\n    l.elem =(int *)malloc(listinitsize*sizeof(int));//问题行\n    if(!l.elem)return -1;。。。。。\nerror: expected primary-expression before \"int\"（此为c free编译错误报告）\n老师说是有什么标识打错，但跟书上对了没错。初学者谢谢了", "Tag": "数据结构"}
{"Answer": "修改处见注释，供参考：\n#include <stdio.h>\n#include <stdlib.h>\ntypedef struct node//单链表\n{\n    int date;\n    struct node* next;\n}node;\ntypedef struct node* linklist;\nvoid createlist(linklist& L)//尾插法创建单链表 linklist*& L 修改\n{\n    linklist p, r;\n    int n, i, e;\n    scanf(\"%d\", &n);\n    L = (linklist)malloc(sizeof(node));//L为整个线性表 修改\n    //*L = (linklist)malloc(sizeof(node)); 修改\n    r = L;//r为指向尾部的节点 修改\n    for (i = 0; i < n; i++)  //修改\n    {\n        p = (node*)malloc(sizeof(node));//生成新节点\n        scanf(\"%d\", &e);\n        p->date = e;\n        r->next = p;\n        r = p;\n    }\n    r->next = NULL;\n}\nvoid sertlist(linklist& L)//插入数据  linklist*& L 修改\n{\n    int i, j, e;\n    scanf(\"%d\", &i);\n    scanf(\"%d\", &e);\n    linklist p, s;\n    p = L;//指向链表头结点 p = *L; 修改\n    j = 0;//修改 j = 1; \n    while (p && j < i)\n    {\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i) { //修改\n        printf(\"error\\n\");\n        return;        //修改\n    }\n    s = (linklist)malloc(sizeof(node));\n    s->date = e;\n    s->next = p->next;\n    p->next = s;\n}\nvoid showlist(linklist L) //linklist* L 修改\n{\n    linklist p;\n    p = L->next;    //p = *L;  修改\n    while (p)\n    {\n        printf(\"%d \", p->date);\n        p = p->next;\n    }\n}\nint main()\n{\n    linklist L;   //linklist* L; 修改\n    createlist(L);\n    sertlist(L);\n    showlist(L);\n    return 0;\n}\n\n\n", "Knowledge_Point": "线性表", "Question": "#include#includetypedef struct node//单链表{    int date;    struct node *next;}node;typedef struct node *linklist;void createlist(linklist *&L)//尾插法创建单链表{    linklist p,r;    int n,i,e;    scanf(\"%d\",&n);    *L=(linklist)malloc(sizeof(node));//L为整个线性表    r=*L;//r为指向尾部的节点    for(i=0;idate=e;        r->next=p;        r=p;    }    r->next=NULL;}void sertlist(linklist *&L)//插入数据{    int i,j,e;    scanf(\"%d\",&i);    scanf(\"%d\",&e);    linklist p,s;    p=*L;//指向链表头结点    j=1;    while(p&&jnext;        j++;    }    if(!p||j>i)        printf(\"error\\n\");    s=(linklist)malloc(sizeof(node));    s->date=e;    s->next=p->next;    p->next=s;}void showlist(linklist *L){    linklist p;    p=*L;    while(p)    {        printf(\"%d \",p->date);        p=p->next;    }}int main(){    linklist *L;    createlist(L);    sertlist(L);    showlist(L);    return 0;}", "Tag": "数据结构"}
{"Answer": "void UnioList(SqList *LA,SqList *LB,SqList *&LC) 函数算法有错误，循环因子错误，还有表 L 未初始化等，修改处见注释，供参考：\n#include <stdio.h>\n#include <stdlib.h>\n#define MaxSize 100\n \ntypedef int ElemType;\ntypedef struct\n{\n    int data[MaxSize];\n    int length;\n}SqList;\n \n//初始化线性表\nvoid InitList(SqList *&L)\n{\n    L->length=0;\n}\n \n//创建顺序表\nvoid CreatList(SqList *L)\n{\n    int n, len, i;\n    printf(\"输入顺序表的长度:\");\n    scanf(\"%d\", &len);\n    L->length = len;\n    printf(\"输入顺序表的元素:\");\n    for (i=0;i<len;i++)\n    {\n        scanf(\"%d\",&n);\n        L->data[i]=n;\n    }\n} \n \n//3、顺序表LA和顺序表LB中的元素值无序，求出LA和LB的并集，结果存储在顺序表LC中。\nvoid UnioList(SqList *LA,SqList *LB,SqList *&LC)\n{\n    int i,j,k,flg;   //修改\n    for(k=0;k<LA->length;k++){\n        LC->data[LC->length]=LA->data[k];\n        LC->length++;\n    }\n    for(i=0;i<LB->length;i++){\n        for(j=0,flg=0;j<LA->length;j++){//for(j=0,flg=0;i<LA->length;j++) i<LA->length; i错误\n            if(LB->data[i]==LA->data[j]){//if(LB->data[i]!=LA->data[j])\n               flg = 1;                  //算法修改\n               break;                    //修改\n            }\n        }\n        if(!flg){                        //修改\n            LC->data[LC->length]=LB->data[i];\n            LC->length++;\n        }\n    }\n}\n \n//输出顺序表\nvoid OutList(SqList* L)\n{\n    int i;\n    for (i=0;i<L->length;i++)\n        printf(\"%d \",L->data[i]);\n    printf(\"\\n\\n\");\n} \n \nint main()\n{\n    SqList L1,L2,LA,LB,L;\n    SqList* LC=&L;\n    InitList(LC); //初始化顺序表 L 修改\n    ElemType x;\n    printf(\"顺序表LA:\\n\");\n    CreatList(&LA);\n    printf(\"顺序表LB:\\n\");\n    CreatList(&LB);\n    printf(\"-------顺序表LA和顺序表LB中的元素值无序，求出LA和LB的并集，结果存储在顺序表LC中-------\\n\");\n    UnioList(&LA,&LB,LC);\n    printf(\"LA和LB的并集：\");\n    OutList(LC);\n\n    return 0;\n}\n\n", "Knowledge_Point": "线性表", "Question": "为什么没有输出结果\n#include \n#include \n#define MaxSize 100\n\ntypedef int ElemType;\ntypedef struct\n{\n    int data[MaxSize];\n    int length;\n}SqList;\n\n//初始化线性表\nvoid InitList(SqList *&L)\n{\n    L->length=0;\n}\n\n//创建顺序表\nvoid CreatList(SqList *L)\n{\n    int n, len, i;\n    printf(\"输入顺序表的长度:\");\n    scanf(\"%d\", &len);\n    L->length = len;\n    printf(\"输入顺序表的元素:\");\n    for (i=0;idata[i]=n;\n    }\n} \n\n//3、顺序表LA和顺序表LB中的元素值无序，求出LA和LB的并集，结果存储在顺序表LC中。\nvoid UnioList(SqList *LA,SqList *LB,SqList *&LC)\n{\n    int i,j,k;\n    for(k=0;klength;k++){\n        LC->data[LC->length]=LA->data[k];\n        LC->length++;\n    }\n    for(i=0;ilength;i++){\n        for(j=0;ilength;j++){\n            if(LB->data[i]!=LA->data[j]){\n                LC->data[LC->length]=LB->data[i];\n                LC->length++;\n            }\n        }\n    }\n}\n\n//输出顺序表\nvoid OutList(SqList* L)\n{\n    int i;\n    for (i=0;ilength;i++)\n        printf(\"%d \",L->data[i]);\n    printf(\"\\n\\n\");\n} \n\nint main()\n{\n    SqList L1,L2,LA,LB,L;\n    SqList* LC=&L\n    ElemType x;\n    printf(\"顺序表LA:\\n\");\n    CreatList(&LA);\n    printf(\"顺序表LB:\\n\");\n    CreatList(&LB);\n    printf(\"-------顺序表LA和顺序表LB中的元素值无序，求出LA和LB的并集，结果存储在顺序表LC中-------\\n\");\n    UnioList(&LA,&LB,LC);\n    printf(\"LA和LB的并集：\"); \n    OutList(LC);\n    return 0;\n}\n\n", "Tag": "数据结构"}
{"Answer": "```\r\nfind(a,x,s):\r\n    if (x == s or a == null):\r\n        return s\r\n    if (a.data > x):\r\n        a = a.left\r\n    else:\r\n        a = a.right\r\n    return find(x,x,s)\r\n```", "Knowledge_Point": "查找树", "Question": "Python\n大概要求如下：\n写一个尾递归方法 find(a,x,s)，返回二叉查找树a中，大于x的最小key\n如果找不到key，那么就返回s，s是累加器", "Tag": "数据结构"}
{"Answer": "简单来说有两个思路\r\n\r\n（1）使用后序遍历的方法。也就是说对于一个节点，先找它的左子节点，再找右子节点，最后找它本身。（深度优先）\r\n（2）使用线形表来存储二叉树。二叉树是可以直接用线形表表达的。（广度优先）", "Knowledge_Point": "查找树", "Question": "用递归遍历二叉树很简单，但是现在的问题是，能不能不用递归去遍历呢？用C#或者Java给出代码更好。", "Tag": "数据结构"}
{"Answer": "select * from 地区表名 a1left join  地区表名 a2 on a1.pid = a2.idleft join  地区表名 a3 on a3.pid = a1.idwhere name='石家庄'", "Knowledge_Point": "查找树", "Question": "比如说省市县      是id  和 pid 类型的\n我现在查石家庄      怎么通过石家庄查到   石家庄是哪个省的市   石家庄下面有哪些县   石家庄 所处分支的全部分支", "Tag": "数据结构"}
{"Answer": "更好的办法就是把这个node.id不定义成一个panel而是定一成一个panel的config\r\n\r\n这其实是Ext的延时渲染\r\n把类似这样的内容\r\nnode.id = [b]new Ext.Panel([/b]{\r\n  title : \"abc\",\r\n  ...\r\n}[b])[/b]\r\n\r\n改成类似这样\r\n\r\nnode.id = {\r\n  [u]xtype : \"panel\",[/u]\r\n  title : \"abc\",\r\n  ...\r\n}\r\n\r\n如果只想加个panel或container，这里的xtype可以省略，如果加别的组件，也可以使用相应的xtype\r\n\r\n主要看粗体和下划线标注的地方 看他们的区别", "Knowledge_Point": "查找树", "Question": "我的一个页面，左边是个树形菜单，中间是Tabpanel，当点击左边某个叶子结点时，就在右边打开一个tab，\n我是根据id来查找的，目前的情况是第一次打开没问题，但当我关掉某个再打开时，就会提示comp is undefinded,\n请高手支招，[code=\"js\"]var tree = new Ext.tree.TreePanel({\n                loader : treeLoader,\n                enableDD : true,\n                rootVisible : false,\n                border : false,\n                root : rootNode,//采用AsycTreeNode\n                listeners : {\n                    click : function(node, event) {\n                        if (node && node.id == 'logout') {\n                            Ext.Msg.alert(\"安全退出\", 'Logout!');\n                        } else if (node && node.isLeaf()) {\n\n                        addTab(node);\n                    }\n                }\n            }\n        });\nfunction addTab(node) {\n    var tab = Ext.getCmp('view').findById('mainTab');\n    alert(tab.findById(node.id));\n    if (!tab.getComponent(node.id)) {\n        tab.add(node.id);\n        tab.setActiveTab(node.id);\n    } else {\n        tab.setActiveTab(node.id);\n    }\n}[/code]\n", "Tag": "数据结构"}
{"Answer": "#include<stdio.h>\nstruct job{\n    int job_number;\n    int priority;\n};\njob priority_queue[100];\nint length=0;   //队列中的作业个数 全局变量\nint allnumber=1;    //作业号，依次递增，赋给增加的作业\n\nint remove(){\n    if(length==0){\n        printf(\"There is no job!\\n\");\n        return 0;\n    }\n    int maxpriority=9999;\n    int number=9999;\n    int sign=0;\n    //遍历一次队列，找到最高优先级的作业\n    for(int i=0;i<length;i++){\n        if(priority_queue[i].priority<maxpriority){\n            maxpriority = priority_queue[i].priority;\n            number = priority_queue[i].job_number;\n            sign = i;\n        }\n        else if(priority_queue[i].priority==maxpriority)\n            if(priority_queue[i].job_number<number){\n                maxpriority = priority_queue[i].priority;\n                number = priority_queue[i].job_number;\n                sign = i;\n            }\n    }\n    printf(\"%d %d\\n\",priority_queue[sign].job_number,priority_queue[sign].priority);\n\n    //找到了作业，删除它\n    //从后往前依次覆盖\n    for(int i=sign;i<length-1;i++)\n        priority_queue[i] = priority_queue[i+1];\n    //作业个数减一\n    length--;\n    printf(\"Remove succeeds!\\n\");\n    return 1;\n}\nint add(){ //控制台输入一个优先级，系统自动赋予作业号\n    printf(\"Please input the priority: \");\n    int p;  scanf(\"%d\",&p);\n    //构成一个作业：作业号，优先级  并且加在队列最后\n    priority_queue[length] = {allnumber++,p};\n    //作业个数加一\n    length++;\n    printf(\"%d %d\\n\",priority_queue[length-1].job_number,priority_queue[length-1].priority);\n    printf(\"Add succeeds!\\n\");\n    return 1;\n}\nint list(){\n    printf(\"List:\\n\");\n    //一个for循环遍历整个数组\n    for(int i=0;i<length;i++)\n        printf(\"%d %d\\n\",priority_queue[i].job_number,priority_queue[i].priority);\n    printf(\"Over!\\n\");\n    return 1;\n}\n\nint menu(){\n    printf(\"Please input your operation:\");\n    char operation;\n    scanf(\"%s\",&operation);\n    switch (operation) {\n        case 'R':remove();break;\n        case 'A':add();break;\n        case 'L':list();break;\n        case '0':return 0;\n        default: printf(\"Illegal input.\\n\");\n    }\n    menu();\n}\nint main(){\n    menu();\n    return 1;\n}\n\n\n\n直接复制粘贴就能运行。\n使用数组存储作业。每次出队时，先找到优先级最高的作业，然后删除它。", "Knowledge_Point": "优先级队列", "Question": "需要用c语言编程，加点注释。\n假设进入计算机系统的作业（job）被赋予一个作业号（job number）和一个从0～9之中的优先级（priority），0表示最大优先级，9表示最小优先级。等待被作业执行的作业的作业号被保存在一个优先级队列（priority queue）中。编写一个程序，使用优先级队列来存放作业，并允许用户选择一下菜单操作：R（删除remove）、A（增加add）和L（列举list）。对于R，读出当前优先级最高的作业号并把它从优先级队列中删除，如果当前优先级最高的作业有多个，则把作业号小的作业从优先队列中删除；对于A，读入作业号和优先级，然后按上述规则把它加入到优先级队列中；对于L，则列出队列中的所有作业号及其优先级。作业号可用一个整数表示，可在作业进入系统时由系统赋予。设计适当的数据元素类型，用无序顺序表实现优先队列并写出验证代码验证各个操作，完成上述计算机系统的作业调度的演示方案。新来的作业插入到表尾。假定作业号可以反映作业被加入的先后次序，因此和作业优先级一起可以唯一识别一个作业。", "Tag": "数据结构"}
{"Answer": "最大线程数10需要调整的话  将10 改为5 就不会超了", "Knowledge_Point": "队列", "Question": "我看的帖子都说核心线程数创建满了，任务会进入等待队列，核心线程数5，任务队列5加一块够放10个任务的呀难道正在被线程执行的任务也在任务队列吗？\n\n public static void main(String[] args) {\n        //ThreadPoolExecutor创建线程池,省略线程工厂和拒绝策略，仅设定核心线程数5，最大线程数10，闲置时间5，单位秒，任务队列为有界队列5\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 5,\n                TimeUnit.SECONDS, new ArrayBlockingQueue(5));\n\n        for(int i=0,size=10;i{\n                System.out.println(\"线程：\"+Thread.currentThread().getName()+\"正在运行\");\n            });\n        }\n        threadPoolExecutor.shutdown();\n    }\n\n为什么线程会创建到7呢，求解", "Tag": "数据结构"}
{"Answer": "这个init是不对的， 如果返回一个形参 begin和end的值会乱掉的，只是值拷贝。 要malloc返回一个地址queue army = init(); 这句话运行后会产生一个先的变量，地址是改了的。先把这个改了试试\nqueue init(void) {\n    queue temp;\n    temp.current = 0;//现在的元素个数是0\n    temp.begin = temp.store;//两个指针都指向 数组\n    temp.end = temp.store;\n \n    return temp;\n\nmain函数这样改了一下输出好像对了\nint main(void) {\n    //queue army = init();//初始化一个链表\n    queue army;\n    army.current = 0;//现在的元素个数是0\n    army.begin = army.store;//两个指针都指向 数组\n    army.end = army.store;\n\n    push(&army);//此后几行是调试 ，结构发现错误了\n    push(&army);\n    push(&army);\n    pop(&army);\n    show(army);\n\n    return 0;\n}\n\n", "Knowledge_Point": "队列", "Question": "//环形队列\n// 不知道 哪里不对 了\n#include \n#include \n#include \n#define max 10\ntypedef struct Queue {\n    int current;\n    int store[max];\n    int* begin, * end;\n}queue;\nqueue init(void);//初始化\nvoid push(queue*);//入队列\nvoid pop(queue*);//出队列\nvoid show(queue);//遍历队列元素\nint main(void) {\n    queue army = init();//初始化一个链表\n    push(&army);//此后几行是调试 ，结构发现错误了\n    push(&army);\n    push(&army);\n    pop(&army);\n    show(army);\n \n    return 0;\n}\nqueue init(void) {\n    queue temp;\n    temp.current = 0;//现在的元素个数是0\n    temp.begin = temp.store;//两个指针都指向 数组\n    temp.end = temp.store;\n \n    return temp;\n}\nvoid push(queue* temp) {\n    if (temp->current == max) {//数据存放满\n        puts(\"队列已满，无法入队列\");\n        exit(-1);\n    }\n    puts(\"请输入要入队列的数据\");\n    int income;\n    scanf_s(\"%d\", &income);\n    *(temp->end)++ = income;// 在 end 位置写入 数据，然后end指针后移一位 \n    printf(\"%d已入队列\\n\", *(temp->end - 1));\n    temp->current++; //队列数据 +1\n    if (temp->end == &(temp->store[max])) {//如果越界\n        temp->end = &(temp->store[0]);//指向开头位置\n    }\n}\nvoid pop(queue* temp) {\n    if (temp->current == 0) {\n        puts(\"队列为空，无法出队列\");\n        exit(-1);\n    }\n    printf(\"%d已出队列\", *(temp->begin)++);//begin指针读取数字， 然后 后移一位 \n    temp->current--;\n    if (temp->begin == &(temp->store[max])) {//如果越界\n        temp->begin = &(temp->store[0]);//指向开头位置\n    }\n}\nvoid show(queue temp) {\n    printf(\"temp.current is %d\\n\", temp.current);\n    while(temp.current != 0) {\n        if (temp.begin != temp.store) {\n            printf(\"--%d--\", *(temp.begin));\n            temp.begin++;\n        }\n        temp.current--;\n    }\n}\n\n", "Tag": "数据结构"}
{"Answer": "顺序队  数组的元素最少为1,因为要空出来一个，即定义的buf[max] max的初值最少为1 空的情况下也是front=0,rear=max-1=0,两个数的值相等，插入后会更新max的值，如:插入一个后max值为2，所以队满队空的条件还是成立的，也就是说rear对应的元素是个空值", "Knowledge_Point": "队列", "Question": "题目：\n己知循环队列存储在一维数组A[O…n-1］中，且队列非空时front和rear分别指向队头元素和队尾元索。若初始时队列为空，且要求第1个进入队列的元素存储在A[0］处，则初始时front和rear的值分别为：0，n-1\n\n我的疑问是：如果按照这样操作，在入队第一个数据后，rear=front=0，那么此时的判断队列为空的条件就不应该照搬按照一般教科书上写的if(rear==front)来判定了吧？如果按照题目要求操作，队空判定条件应该改为什么呢？我觉得（rear+1）%maxsize=front无法区分队空和队满了，是不是应该引入tag标识符了？", "Tag": "数据结构"}
{"Answer": "只是输出队列的时候循环越界了，写成这样试试。\r\n\r\n\r\n```\r\nwhile (q.front->next != NULL)\r\n{\r\n\t\tDequeue(&q,&e);\r\n\t\tcout << e << \" \";\r\n}\r\n```", "Knowledge_Point": "队列", "Question": "//实现一个队列，任意输入一串字符，以999为结束标志，然后打出队列中的数据\n//定义队列\ntypedef struct QNode\n{\n    int data;\n    QNode *next;\n}QNode,*QueuePtr;\ntypedef struct\n{\n    QueuePtr front;\n    QueuePtr rear;\n}LinkQuede;\n//初始化一个链队\nvoid initQueue(LinkQuede *p)\n{\n    p->front = p->rear = new QNode;\n    if (!p->front) exit(0);\n    p->front->next = NULL;\n}\n//入队\nvoid Enqueue(LinkQuede *p,int e)\n{\n    QueuePtr q;\n    q = new QNode;\n    if (!q) exit(0);\n    q->next = NULL;\n    q->data = e;\n    p->rear->next = q;\n    p->rear = q;\n}\n//出队\nvoid Dequeue(LinkQuede *p,int*e)\n{\n    if (p->front == p->rear) exit(0);\n    QueuePtr q = new QNode;\n    if (!q)exit(0);\n    q = p->front->next;\n    *e = q->data;\n    p->front->next = q->next;\n    delete q;\n}//销毁队列\nvoid destryQueue(LinkQuede *p)\n{\n    while (p->front)\n    {\n        p->rear = p->front->next;\n        delete(p->front);\n        p->front = p->rear;\n    }\n}//测试程序\nint main()\n{\n    int e;\n    LinkQuede q;\n    initQueue(&q);\n    cout << \"请输入一个队列：\" << endl;\n    cin >> e;\n    while (e != 999)\n    {\n        Enqueue(&q,e);\n        cin >> e;\n    }\n    cout << \"打印队列元素：\" << endl;\n    while (q.front != q.rear)\n    {\n        Dequeue(&q,&e);\n        cout << e << \" \";\n    }\n    cout << endl;\n    destryQueue(&q);\n    if (q.front == q.rear)\n        cout << \"ok\" << endl;\n    system(\"pause\");\n    return 0;\n}", "Tag": "数据结构"}
{"Answer": "```\r\n System.out.println(\"元素\"+stack.pop()+\"出栈\");\r\n这句话本身会让栈顶出栈\r\n换成\r\nSystem.out.println(\"元素\"+stack.peek()+\"出栈\");\r\n```", "Knowledge_Point": "队列", "Question": "看到一个题，是说用栈实现队列的效果，我想的是用两个栈，栈1输出到栈2，再输出，大家帮我看一下，这个程序的最后输出怎么是［b,1］，输入的3哪去了？\nimport java.util.Enumeration;\nimport java.util.Stack;\n\npublic class mockFIFO {\n\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    Stack stack = new Stack<>();\n    Stack stack2 = new Stack<>();\n    System.out.println(\"1,b,3.3,先让这三个元素入栈\");\n    stack.push(new Integer(1));\n    stack.push(\"b\");\n    stack.push(new Integer(3));\n    String s= new String(\"b\");\n    System.out.println(\"1的位置\"+stack2.search(1));\n    System.out.println(\"b的位置\"+stack2.search(\"b\"));    \n    System.out.println(\"3位置\"+stack2.search(3));\n\n\n//      System.out.println(\"1,b,3.3 三个元素出栈\");\n        System.out.println(\"元素\"+stack.pop()+\"出栈\");\n        printStack(stack,stack2);  //显示栈中的所有元素\n        System.out.println(\"元素\"+stack.pop()+\"出栈\");\n        printStack(stack,stack2);  //显示栈中的所有元素\n        System.out.println(\"元素\"+stack.pop()+\"出栈\");\n        printStack(stack,stack2);  //显示栈中的所有元素\n        printStack(stack,stack2);\n\n}\n\nprivate static void printStack(Stack stack ,Stack stack2) {\n    // TODO Auto-generated method stub\n    if(stack2.size()<=0){\n        while (!stack.isEmpty()){\n        for(int i=0; i<stack.size();i++){\n            stack2.push(stack.pop());\n        }\n        }\n        System.out.println(\"栈1到栈2\");\n        System.out.println(\"栈1元素：：\"+stack);\n        System.out.println(\"栈2元素：：\"+stack2);\n    }\nif(stack.size()==0){\n    System.out.println(\"栈1空了\");\n}\nif(stack2.size()==0){\n    System.out.println(\"栈2空了\");\n}\n    }\n    ｝\n\n\n\n    ／／以下是输出\n    1,b,3.3,先让这三个元素入栈\n\n\n1的位置-1\nb的位置-1\n3位置-1\n元素3出栈\n栈1到栈2\n栈1元素：：[]\n栈2元素：：[b, 1]\n栈1空了\n\n    谢谢大家！！！\n", "Tag": "数据结构"}
{"Answer": "那是因为你的程序主线程直接结束了，而你的sum还没有计算完，所以没有来得及打印。", "Knowledge_Point": "队列", "Question": "代码：\n                static int flag = 1;\n        static int data[] = {1,2,3,4,5,6,7,8,9,10};\n        int length = sizeof(data)/sizeof(data[0]);\n\n    dispatch_queue_t queue = dispatch_queue_create(\"StudyBlocks\",DISPATCH_QUEUE_SERIAL);\n    dispatch_async(queue, ^(void){\n        int sum = 0;\n\n        for (int i = 0; i < length; i++)\n            sum += data[i];\n        NSLog(@\"saf\");\n        flag = 0;\n        NSLog(@\">>Sum:%d\",sum);\n\n    });\n\n    NSLog(@\"flag = %d\", flag);\n\n\n问题1：我运行之后发现打印只有两段话\nblock中后面求到的和sum没有打印出来，这是为什么？；\n问题2：为什么我把后面NSLog(@\"flag = %d\", flag);这段话注释掉，我的程序就运行不了了？\n懂得人能解释下不？", "Tag": "数据结构"}
{"Answer": "p1执行的时候，由于resolve中的是Promise对象,加入微任务队列的是p3，p2执行的时候加入是function A。然后执行p3，将function B加入队列，所以B在A前面。", "Knowledge_Point": "队列", "Question": "首先，我们知道每个Promise对象在创建时都会进入微任务队列，而且队列是先进先出的一种数据结构，这就说明了Promise的执行顺序是可以预测的，先进去的比后进去的执行得早。那么，请看下面的代码和我做的预测：\nvar p3 = new Promise(function (resolve, reject) {\n  resolve(\"B\")\n})\n\nvar p1 = new Promise(function (resolve, reject) {\n  resolve(p3)\n})//这里p1依赖了p3\n\n var p2 = new Promise(function (resolve, reject) {\n  resolve(\"A\")\n})\np1.then(function B(v){\n  console.log(v);\n})\np2.then(function A(v){\n  console.log(v);\n})\n\n\n如上所示，p1应该比p2先进入微任务队列，那么我预测应该先执行p1在执行p2，那为什么先输出A后输出B呢？", "Tag": "数据结构"}
{"Answer": "在 FreeRTOS 中传递结构体指针的正确方法是，先使用 pvPortMalloc 分配内存空间，然后复制该结构体的数据到这块内存中，最后将该内存地址作为消息队列的内容发送。如果每次发送的都是同一个地址的话，就会导致数据被覆盖。如果您希望通过FreeRTOS的队列传递结构体指针，并且确保在队列中的数据不会被覆盖，您需要进行一些改变。\n建议您在传递结构体指针时，每次传递一个独立的结构体副本，而不是同一个结构体。\n您可以这样改变：\nUART_Data_t *pData = (UART_Data_t *)pvMalloc(sizeof(UART_Data_t));\npData->maxLen = n;\npData->len = m;\npData->curbuf = (uint8_t *)pvMalloc(n);\nmemcpy(pData->curbuf, curbuf, m);\nxQueueSend(uartDataQueue, &pData, portMAX_DELAY);\n\n这样每次发送的结构体指针都是独立的副本，不会受到上一次数据的影响", "Knowledge_Point": "队列", "Question": "问题遇到的现象和发生背景\n我想通过消息队列传递该结构体，curbuf 是通过pvMalloc\ntypedef struct\n{\n    uint16_t maxLen; //当前数组 数据的最大长度\n    uint16_t len;     //当前数组已接收数据的长度\n    uint8_t *curbuf; //当前数组\n} UART_Data_t;\n\n但是传递指针一直是同一个地址，也就是说我Send多次结构体   curbuf的值一直是同一个，就会导致数据被覆盖\n代码\nvoid USART2_IRQHandler(void)\n{\n    static uint16_t RevLen = 0;\n    static BaseType_t xHigherPriorityTaskWoken = pdFALSE;\n    uint8_t res;\n    if (USART_GetIntStatus(USART2, USART_INT_IDLEF) != RESET)\n    {\n        /* Read data len from the receive data register */\n        RevLen = BT_UART_RECV_BUF_LMT - DMA_GetCurrDataCounter(USART_BLE_Rx_DMA_Channel);\n        if ((RevLen > 0) && (BLE_UART_Rx.curbuf[0] == BLE_ACK_HEAD_FIRST) && (BLE_UART_Rx.curbuf[2] != sendData))\n        {\n            BLE_UART_Rx.len = RevLen;\n            if(pdPASS == xQueueSendToBackFromISR(xQueue_BLERecv, (void *)&BLE_UART_Rx, &xHigherPriorityTaskWoken)) //把数据放到队列当中\n            {\n            }else{\n              YJ_LOG_WARNING(\"Ble uart Queue is full \\r\\n\");\n            }\n            \n        }\n        DMA_EnableChannel(USART_BLE_Rx_DMA_Channel, DISABLE);\n        DMA_SetCurrDataCounter(USART_BLE_Rx_DMA_Channel, BLE_UART_Rx.maxLen);\n        DMA_EnableChannel(USART_BLE_Rx_DMA_Channel, ENABLE);\n        \n        res = USART_BLE->STS;\n        res = USART_BLE->DAT;\n    }\n}\n\n\n我是在中断里面存数据，另外的地方读取  如何保证该指针相互独立", "Tag": "数据结构"}
{"Answer": "\n\n\nHow would it process next event?\n\n\nBeside iteration over basic data structures, range in GoLang can also iterate over values received from a channel. Range iterates over each element as it's received from queue and ends only when the channel is closed. \nThe next iteration will happen when the channel (msgs) will receive a value\nmsgs <- message\n\n\n\nAfter some playing around with this code I found that it could stuck on log.Printf line and wouldn't process events anymore. What can be a reason?\n\n\nConsidering that there is a blocking channel forever and we have a range that iterates over the msgs channel there are 2 possible actions that are expected:\nEither \n\nsend message through the msgs channel\nmsgs <- message\n\nor\n\nsend value to forever so it unblocks the process \nforever <- false \n\nIt seems like the solution is designed to wait and asynchronously process messages through a channel.\n", "Knowledge_Point": "队列", "Question": "\n\nI am reading RabbitMQ tutorial and seeing following code:\n\nforever := make(chan bool)\n\ngo func() {\n  for d := range msgs {\n    log.Printf(\"Received a message: %s\", d.Body)\n  }\n}()\n\nlog.Printf(\" [*] Waiting for messages. To exit press CTRL+C\")\n<-forever\n\n\nWhat I am interested in is for d := range msgs. How does this for loop handle events? eg. At the app start I have only one message in msgs queue buffer. \n\nQuestions:\n\n\nHow would it process next event? \nAfter some playing around with this code I found that it could stuck on log.Printf line and wouldn't process events anymore. What can be a reason?  \n\n", "Tag": "数据结构"}
{"Answer": "\nTaskQueue Tasks have a Delay time.Duration as well as ETA time.Time fields which can be used to create and delay tasks. I believe you can reuse the top example but set one of the fields before calling taskqueue.Add(c, t, \"\")\n", "Knowledge_Point": "队列", "Question": "\n\nI want to create batches of queue items and execute after every 10 second, due to some limitation of third party API using inside code (Third party API have 1000 API call per minute).\n\nBut i don't know how do i achieve the given requirement in App Engine with taskqueue. \n\nOr \n\nIt is possible to create batches with taskqueue push?\n    ", "Tag": "数据结构"}
{"Answer": "供参考：\n#include <stdio.h>\n#include <stdlib.h>\ntypedef int QDataType;\ntypedef struct QueueNode\n{\n    struct QueueNode* next;\n    QDataType data;\n}QNode;\ntypedef struct Queue\n{\n    QNode* head; //队头指针\n    QNode* tail; //队尾指针\n}Queue;\n\nvoid QueueInit(Queue** pQ) //队列初始化\n{\n    (*pQ) = (Queue*)malloc(sizeof(Queue));\n    (*pQ)->head = (*pQ)->tail = NULL;\n}\nvoid QueuePush(Queue* pQ, QDataType x) //入队 （尾插）\n{\n    QNode* newnode = (QNode*)malloc(sizeof(QNode));\n    newnode->data = x;\n    newnode->next = NULL;\n    if (pQ->tail == NULL)\n        pQ->head = pQ->tail = newnode;\n    else{\n        pQ->tail->next = newnode;\n        pQ->tail = newnode;\n    }\n}\nvoid QueuePop(Queue* pQ)\n{\n\n    if (!pQ->head){         //队空\n        printf(\"invalid\\n\");\n        return;\n    }\n    printf(\"%d\\n\",pQ->head->data);//输出出队元素\n    if (pQ->head->next == NULL)    //1.只剩一个结点\n    {\n        free(pQ->head);\n        pQ->head = pQ->tail = NULL;\n    }\n    else                       //2.多个结点\n    {\n        QNode* next = pQ->head->next;\n        free(pQ->head);\n        pQ->head = next;\n    }\n}  \nint main()\n{\n    QDataType i,n,flag,x;\n    Queue *Q;\n    QueueInit(&Q);\n    scanf(\"%d\", &n);\n    while(n--){\n        scanf(\"%d\",&flag);\n        if (flag == 1){\n            scanf(\"%d\", &x);\n            QueuePush(Q, x);\n        }\n        else if (flag == 0){\n            QueuePop(Q);\n        }\n    }\n    return 0;\n}\n\n", "Knowledge_Point": "队列", "Question": "给定一个初始为空的队列和一系列入队、出队操作，请编写程序输出每次出队的元素。队列的元素值均为整数。输入格式:输入第1行为1个正整数n，表示操作个数；接下来n行，每行表示一个操作，格式为1 d或0。1 d表示将整数d入队，0表示出队。n不超过20000。输出格式:按顺序输出每次出队的元素，每个元素一行。若某出队操作不合法（如在队列空时出队），则对该操作输出invalid。输入样例:71 11 20001 30输出样例:12invalid3我的代码\n#include \n#include \ntypedef struct QNode *PtrToQNode;\nstruct QNode{\n    int *Data;\n    int f;\n    int r;\n    int Max;\n};\ntypedef PtrToQNode Queue;\nQueue CreatQueue(int Max);\nvoid AddQ(Queue Q,int X);\nvoid DeleteQ(Queue Q);\nint main(void){\n    int i,n,flag,X;\n    Queue Q=(Queue)malloc(sizeof(struct QNode));\n    Queue CreatQueue();\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        //Q->Data=(int *)malloc(Max*sizeof(int));\n        scanf(\"%d \",&flag);\n        if(flag==1){\n           scanf(\"%d\",&X); \n            AddQ(Q,X);\n        }else if(flag==0){\n            DeleteQ(Q);\n        }\n        if(Q->f==Q->r){\n            printf(\"invalid\");\n        }else{\n            printf(\"%d\\n\",X);\n        }\n    }\n}\nQueue CreatQueue(int Max){\n    Queue Q=(Queue)malloc(sizeof(struct QNode));\n    Q->Data=(int *)malloc(Max*sizeof(int));\n    Q->f=Q->r=NULL;\n    Q->Max=Max;\n    return Q;\n}\nvoid AddQ(Queue Q,int X){\n    if((Q->r+1)%Q->Max==Q->f){\n        printf(\"队列满\");\n    }else{\n        Q->r=(Q->r+1)%Q->Max;\n        Q->Data[Q->r]=X;\n    }\n}\nvoid DeleteQ(Queue Q){\n    if(Q->r==Q->f){\n        printf(\"invalid\");\n    }else{\n        Q->f=(Q->f+1)%Q->Max;\n    }\n}\n\n对队列不太熟悉，希望有人能帮忙揪揪错，如果可以的请具体说说错误的地方，具体要怎么改呢？咳，希望可以讲的简单易懂一点（＾ω＾）", "Tag": "数据结构"}
{"Answer": "52行改为if (q->head == NULL)", "Knowledge_Point": "队列", "Question": "\ntypedef int quint;\ntypedef struct qnode{\n    quint data;\n    struct qnode* next;\n}qnode;\n\ntypedef struct qu {\n    qnode * head;\n    qnode* tail;\n}qu;\n\nvoid intqu(qu *q) {\n    if(q == NULL)\n    {\n        exit(-1);\n    }\n    \n        q->head = NULL;\n        q->tail = NULL;\n    \n}\n\nvoid pushqu(qu* q, quint x) {\n    qnode* newnode = (qnode*)malloc(sizeof(qnode)); \n    if (newnode == NULL) {\n        printf(\"内存分配不成功！\\n\");\n    }\n    else {\n        newnode->data = x;\n        newnode->next = NULL;\n    }\n        if (q->head == NULL) {\n            q->head = q->tail = newnode;\n        }\n        else {\n            q->tail->next = newnode;\n            q->tail = newnode;\n        }\n    }\n\n\nvoid popqu(qu* q) {\n    if (q->head == NULL) {\n        printf(\"删除失败，队列空\");\n    }\n    else {\n        qnode* tem = q->head->next;\n        q->head = NULL;\n        free(q->head);\n        q->head = tem;\n        if (q->head = NULL)\n        {\n            q->tail = NULL;\n        }\n    }\n}\n\nquint QueueFront(qu* qu)\n{\n    if (qu == NULL)\n        return 0;\n    else\n    return qu->head->data;\n};\nquint QueueBack(qu* qu)\n{\n    if (qu == NULL)\n        return 0;\n    else\n    return qu->tail->data;\n};\nint main() {\n    qu q;\n    intqu(&q);\n    pushqu(&q, 1);\n    pushqu(&q, 2);\n    popqu(&q);//这里报错，说引发了异常: 读取访问权限冲突。q.head 是 nullptr。\n    printf(\"%d\", q.head->data);\n    return 0;\n    \n}\n", "Tag": "数据结构"}
{"Answer": "```\r\npublic T dequeue() {\r\n\r\n    if (isEmpty()) {\r\n        throw new NoSuchElementException(\"the list is empty, cannot be taken data\");\r\n    }\r\n    else if (size()==1) { // when list just only has one elements\r\n\t\tT temp = head; //加上\r\n        head = null;\r\n\t\t\t\treturn temp; //加上\r\n    } else {\r\n\t\tT temp = head; //加上\r\n        head = head.next;\r\n\t\t\t\treturn temp; //加上\r\n    }\r\n    size--;\r\n\r\n\r\n    return null;\r\n}\r\n```\r\n这个方法，无论队列是否为空都返回了null，看我的更改\r\n\r\n# 问题解决的话，请点下`采纳`", "Knowledge_Point": "队列", "Question": "import java.util.NoSuchElementException;\n\npublic class ListQueue implements MyQueue {\n\nprivate class Node {\n\n    T item; \n    Node next; \n\n\n    public Node(T item) {\n        this.item=item;\n\n    }\n}\n\nprivate Node head = null;\nprivate Node tail = null; // root node\nprivate int size = 0;\n\n\npublic boolean isEmpty() {\n\n\n    return size == 0;\n}\n\n\npublic int size() {\n\n\n    return size;\n}\n\n\npublic void enqueue(T item) {\n\n    Node temptail = new Node(item);\n    if (isEmpty()) {\n        tail = temptail;\n    } else {\n        tail.next = temptail;\n\n    }\n\n\n    size++;\n\n}\n\n/**\n * dequeue: remove and return the head of the queue\n * \n * @return the deleted value\n * @throws NoSuchElementException if queue is empty\n */\npublic T dequeue() {\n\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"the list is empty, cannot be taken data\");\n    }\n    else if (size()==1) { // when list just only has one elements\n        head = null;\n    } else {\n        head = head.next;\n    }\n    size--;\n\n\n    return null;\n}\n\n/**\n * peek: view the head of queue without removing it.\n * \n * @return Null if queue is empty\n */\npublic T peek() {\n    // if array is empty, cannot view its head\n    if (isEmpty()) {\n        return null;\n    }\n    return head.item;\n}\n\n\n}\n\npublic class Driver{\n\npublic static void main(String[] args) {\n\n    MyQueue q;\n\n    boolean useList = true;  // make it false if you want to array implementation\n\n    if (useList)\n        q = new ListQueue();\n    else\n        q = new ArrayQueue();\n\n    for(int i = 0; i < 1000; i++)  // add a large number of items onto the queue\n    {\n        q.enqueue(i);  \n    }\n\n    System.out.println(\"now, dequeue items!\");\n    while(!q.isEmpty())  \n    {\n        System.out.print(q.dequeue() + \" \");  \n    }\n    System.out.println(\"end of dequeueing\");    \n\n\n\n}\n\n\n}\n\n//运行程序以后错误是now, dequeue items!\nException in thread \"main\" java.lang.NullPointerException\n    at yao.as1.ListQueue.dequeue(ListQueue.java:73)\n    at yao.as1.Driver.main(Driver.java:24)\n\n还请给点思路\n", "Tag": "数据结构"}
{"Answer": "h_list=[('张三',173),('李四',179),('王五',160),('赵六',167),('李阳',171),('张清',176),('谢军',180),('陈静',177)]\n\nprint(len(h_list))\n\nprint(sum(_[1] for _ in h_list) / len(h_list))\n\nh_list.append(('李明', 164))\nprint(h_list)\n\nh_list.insert(0, ('王东', 175))\nprint(h_list)\n\nprint([(j[0],i) for i,j in enumerate(h_list) if j[1] == 180])\n\nres = sorted(h_list, key=lambda x: x[1])\nprint(res)\n\n", "Knowledge_Point": "队列", "Question": "题目：某校大一新生正在进行军训，已知某一队列中成员的姓名和身高。表示如下：\nh_list=[('张三',173),(李四',179),('王五',160),('赵六',167),('李阳',171),('张清',176),('谢军',180),('陈静',177)]\n使用python中组合数据类型相关方法或函数求解以下问题：\n（1）计算队列目前的成员个数；\n（2）计算该队列中成员的平均身高；\n（3）该队列现将加入一人，姓名：李明，身高：164，现将其添加至该队列最后端，请返回出更新后的身高列表h_list；\n（4）该队列现将加入一人，姓名：王东，身高：175，现将其添加至该队列最前端，请返回更新后的身高列表h_list；\n（5）返回该队列中身高为180的成员姓名及所在位置。\n（6）根据身高从小到大的顺序对以上列表进行排序，返回最终的排序结果。（选做）\n2.提交要求：把以上代码和运行效果图上传到答题框，注意写清楚题干。", "Tag": "数据结构"}
{"Answer": "一般做法是将网络数据接收和数据处理拆开，网络处理部分只关注编解码，将解码之后的数据投递到message queue中，然后在搞一个项目消费消息队列中的数据", "Knowledge_Point": "队列", "Question": "用到消息中间件的话，是不是只用消费的模块，但是这样要怎么把数据先存到消息队列里呢。还是我自己拿到数据后，自己当producer把数据再放到消息队列，然后再按顺序消费。", "Tag": "数据结构"}
{"Answer": "线程池起码没有办法解决以下问题：\r\n（1）跨进程，跨机器，不能跨机器和进程，只能单机，没有什么实用性。\r\n（2）队列容错和恢复，停机怎么办，程序崩溃怎么办。\r\n（3）比较容易死锁，很难调试，而且隔离性差。\r\n\r\n所以要用消息队列。当然，你说你就是一个职业学校的课程作业，那就用线程池好了。", "Knowledge_Point": "队列", "Question": "假设有1000个任务需要处理，第一种方法：将这1000任务加到阻塞队列中，用一个分发线程去将这些任务分发到下面10个子队列中，然后每个子队列有一个线程去消费这些任务。第二种方法：直接新建个线程池，每一个任务都new 一个线程去处理，再把这新建的线程放到线程池中，依靠线程池的机制去等待排队。这两种得到的效果是不是一样的，比如花费的时间，内存之类的，总感觉第二种方式虽然鲁莽，但实际上确实简单可行，第一种方式感觉稍许复杂，但是最后达到的效果和第二种是一样的呀，请教一下这两种有什么优点和缺点。", "Tag": "数据结构"}
{"Answer": "deque(['hello', 'yootk'])\n>>> info_deque.append(\"小李\")\n>>> info_deque\ndeque(['hello', 'yootk', '小李'])\n>>> info_deque.appendleft(\"老渡头\")\n>>> info_deque\ndeque(['老渡头', 'hello', 'yootk', '小李'])\n>>> info_deque.pop()\n'小李'\n>>> info_deque\ndeque(['老渡头', 'hello', 'yootk'])\n>>> info_deque.popleft()\n'老渡头'\n>>> info_deque\ndeque(['hello', 'yootk'])\n\n.popleft()从左边弹出即前面的先出，.pop()从右边弹出即后面的先出", "Knowledge_Point": "队列", "Question": "问题遇到的现象和发生背景\n在学习python的deque双端队列时，在使用collections.deque方法中的append和popleft时不能理解其描述。\n问题相关代码，请勿粘贴截图\n# coding : UTF-8\nfrom collections import deque\ndef main():\n    info_deque = deque((\"hello\",\"yootk\"))\n    info_deque.append(\"小李\")\n    info_deque.appendleft(\"老渡头\")\n    print(\"队列数据：%s，队列长度：%s\"%(info_deque,len(info_deque)))\n    print(\"从前段弹出数据：%s,从后端弹出数据：%s\"%(info_deque.pop(),info_deque.popleft()))\nif __name__ == \"__main__\":\n    main()\n\n运行结果及报错内容\n队列数据：deque(['老渡头', 'hello', 'yootk', '小李'])，队列长度：4从前段弹出数据：小李,从后端弹出数据：老渡头\n我的解答思路和尝试过的方法\n我想要达到的结果\n为什么后端弹出的不是小李，前段弹出的不是老渡头？", "Tag": "数据结构"}
{"Answer": "Probably the two most common self balancing tree algorithms are Red-Black trees and AVL trees. To balance the tree after an insertion/update both algorithms use the notion of rotations where the nodes of the tree are rotated to perform the re-balancing.\r\n\r\nWhile in both algorithms the insert/delete operations are O(log n), in the case of Red-Black tree re-balancing rotation is an O(1) operation while with AVL this is a O(log n) operation, making the Red-Black tree more efficient in this aspect of the re-balancing stage and one of the possible reasons that it is more commonly used.\r\n\r\nRed-Black trees are used in most collection libraries, including the offerings from Java and Microsoft .NET Framework.", "Knowledge_Point": "树", "Question": "C++中的STL标准库map为什么是用红黑树，而不是用其它的平衡二叉搜索树", "Tag": "数据结构"}
{"Answer": "广度，先遍历子节点，再遍历子节点的子节点\r\n12345678\r\n深度，先访问一个节点，往下直到找不到，返回上一个，继续\r\n12485367", "Knowledge_Point": "树", "Question": "\n\n原图如上，怎么画他的广度优先，深度优先生成树呢？ 具体画法是什么？", "Tag": "数据结构"}
{"Answer": "在遍历这里重复绑定了，简单的方法：  if (item.Header==((TreeViewItem)treeView.SelectedItem).Header)\r\n                                                              MessageBox.Show(c);判定一下即可。", "Knowledge_Point": "树", "Question": "c# wpf递归遍历文件夹,并将文件夹的树形结构装入treeviewitem节点，触发Selected事件的问题\n\nList list1 = new List(); //该集合存储文件路径\n        //递归遍历指定的目录,并将目录的树形结构装入treeviewitem节点\n        public void BindTreeView2(string path, TreeViewItem tree1)\n        {\n            DirectoryInfo di = new DirectoryInfo(path);\n            DirectoryInfo[] dirs = di.GetDirectories();\n            foreach (DirectoryInfo i in dirs)\n            { //将递归遍历得到的文件夹路径与treeviewitem节点进行对应,并动态创建treeviewitem的Selected事件(选中事件),触发Selected事件,将该目录下得到的所有文件夹和文件路径添加到list1集合,若在文件夹之下遍历到子文件夹则创建子节点与子文件夹对应\n\n                            TreeViewItem ziDt = new TreeViewItem();  \n            ziDt.Header = i.Name;\n            tree1.Items.Add(ziDt);\n\n            ziDt.Selected += new RoutedEventHandler(delegate (object shabi, RoutedEventArgs r)\n            {  //选中节点，通过 MessageBox.Show打印 节点对应文件夹下的所有文件夹和文件路径\n                list1.Clear(); //清空之前选中节点所取得的所有路径\n                string c = null;\n                string[] directory1 = Directory.GetDirectories(i.FullName);\n                foreach (string a in directory1)  //将目录下的文件夹路径加到list1\n                {\n                    list1.Add(a);\n                }\n\n                string[] file1 = Directory.GetFiles(i.FullName);\n                foreach (string a in file1)      //将目录下的文件路径加到list1\n                {\n                    list1.Add(a);\n                }\n                foreach (string a in list1)\n                {\n                    c = c + \"\\r\\n\" + a;\n                }\n                MessageBox.Show(c); \n\n            });\n            BindTreeView2(i.FullName, ziDt); \n        }\n\n\n}\n\n\n\n\n\n我只想要将被选中的节点所对应的文件夹下的文件和目录路径添加到list集合中，然后输出到对话框，我已经不知道怎么解决了，求大神高手帮助", "Tag": "数据结构"}
{"Answer": "\n<a-tree :load-data=\"onLoadData\" :tree-data=\"treeData\" />\n\n\ndata() {\n    return {\n      treeData: [\n        { title: 'Expand to load', key: '0', value: '公司' },\n        { title: 'Expand to load', key: '1', value: '公司' },\n      ],\n}\n\n\n\n  methods: {\n    async onLoadData(treeNode) {\n      const { value, key } = treeNode.dataRef\n      // dataRef数据结构\n      // dataRef: {\n      // children: (2) [{…}, {…}]\n      // key: \"1\"\n      // title: \"Expand to load\"\n      // value: \"公司\"}\n      // 根据value 值去请求接口\n      switch (value) {\n        case '子公司':\n          treeNode.dataRef.children = await this.getNextCompany(key)\n          break\n      }\n      this.treeData = [...this.treeData]\n    },\n    // 获取公司接口请求定义，async axios, 获取公司接口在页面加载时就请求， 并赋值给 treeData\n    async getCompany() {\n      // return json数组，数据格式， title, key, value: 根据value 区分是哪一级的数据\n      // [\n      //   { title: 'Expand to load', key: '0', value: '公司' },\n      //   { title: 'Expand to load', key: '1', value: '公司' },\n      // ]\n    },\n    // 获取分公司,根据公司id获取子公司\n    async getNextCompany(id) {\n      // return json数组，数据格式， title, key, value: 根据value 区分是哪一级的数据\n      // [\n      //   { title: 'Expand to load', key: '0', value: '子公司' },\n      //   { title: 'Expand to load', key: '1', value: '子公司' },\n      // ]\n    },\n    // 获取部门,根据子公司id获取部门\n    async getDepartMent(id) {\n      // return json数组，数据格式， title, key, value: 根据value 区分是哪一级的数据\n      // [\n      //   { title: 'Expand to load', key: '0', value: '部门' },\n      //   { title: 'Expand to load', key: '1', value: '部门' },\n      // ]\n    },\n    // 获取职务,根据部门id获取职务\n    async getJob(id) {\n      // return json数组，数据格式， title, key, value: 根据value 区分是哪一级的数据\n      // [\n      //   { title: 'Expand to load', key: '0', value: '职务' },\n      //   { title: 'Expand to load', key: '1', value: '职务' },\n      // ]\n    },\n    // 获取员工,根据职务id获取员工\n    async getUser(id) {\n      // return json数组，数据格式， title, key, value: 根据value 区分是哪一级的数据,最后一级设置是叶子节点\n      // [\n      //   { title: 'Expand to load', key: '0', value: '员工', isLeaf:true },\n      //   { title: 'Expand to load', key: '1', value: '员工', isLeaf:true },\n      // ]\n    },\n  },\n ", "Knowledge_Point": "树", "Question": "类似下方的结构，分公司、部门、职务、人员都在不同的表里面，返回的接口是4个接口，要怎么实现这种树形，大佬们帮帮忙，看了官方文档有个异步加载的，点击某个分公司把参数发送给后端搜索出分公司下方有什么部门，试了一下，不会用\n\n\n\n", "Tag": "数据结构"}
{"Answer": "顺序表的问题在于，它只能存储固定大小的数据，如果这个固定大小太小，那么大一些的存不下。如果太大，造成很多存储单元的浪费。\r\n链表没有这个问题。\r\n本质上说，孩子表示法存储树，采用顺序表，也是一种特殊的链表，只是存储的不是指针，而是下标。", "Knowledge_Point": "树", "Question": "孩子表示法存储树，采用顺序表和链表表示的差别是？\n孩子表示法存储树，采用顺序表和链表表示的差别是？\n孩子表示法存储树，采用顺序表和链表表示的差别是？", "Tag": "数据结构"}
{"Answer": "具体可以参考AsyncTreeNode.js的源码：关注其expand方法。\r\n\r\nexpand : function(deep, anim, callback){\r\n        if(this.loading){ // if an async load is already running, waiting til it's done\r\n            var timer;\r\n            var f = function(){\r\n                if(!this.loading){ // done loading\r\n                    clearInterval(timer);\r\n                    this.expand(deep, anim, callback);\r\n                }\r\n            }.createDelegate(this);\r\n            timer = setInterval(f, 200);\r\n            return;\r\n        }\r\n        if(!this.loaded){\r\n            if(this.fireEvent(\"beforeload\", this) === false){\r\n                return;\r\n            }\r\n            this.loading = true;\r\n            this.ui.beforeLoad(this);\r\n\r\n            [b]var loader = this.loader || this.attributes.loader || this.getOwnerTree().getLoader();[/b]\r\n            if(loader){\r\n                loader.load(this, this.loadComplete.createDelegate(this, [deep, anim, callback]));\r\n                return;\r\n            }\r\n        }\r\n        Ext.tree.AsyncTreeNode.superclass.expand.call(this, deep, anim, callback);\r\n    },", "Knowledge_Point": "树", "Question": "请问一下 EXT 的树节点,能不能把 ROOT 下面的 A,B 节点作为普通树节点 ,C 节点作为异步的树节点呢 ?\nGoogle 了一下,N多的都是从 ROOT 就是 AnyscTreeNode .", "Tag": "数据结构"}
{"Answer": "这个element-ui肯定做不到的，应为你的子对象都没有，它怎么可能获取的到呢。所以要自己获取，获取方法就是：拿你获取到的对象去在原始数据中查找它的所有子对象。", "Knowledge_Point": "树", "Question": "\n在没有展开时 通过@check-change=\"handleCheckChange\"勾选时 只返回父级 对象 在展开后勾选\n\n 会返回所有子级对象 有没有什么方法就是 没有展开时 勾选父级就能返回所有子级对象", "Tag": "数据结构"}
{"Answer": "这个属于数据的序列化和反序列化问题。在这里是对树的序列化和反序列化。\r\n最简单的方式莫过于在内存里以完全二叉树的空间存储哈夫曼树，然后文件里直接写入这块内存就好了。", "Knowledge_Point": "树", "Question": "大佬们，哈夫曼编码的问题，编码完毕后，下次不初始化，怎么从文件中读出哈夫曼树？怎么打印哈夫曼树？", "Tag": "数据结构"}
{"Answer": "\npublic class Solution {\n    public boolean VerifySquenceOfBST(int [] sequence) {\n        if(sequence.length==0)\n            return false;\n        if(sequence.length==1)\n            return true;\n        return ju(sequence, 0, sequence.length-1);\n        \n    }\n    \n    public boolean ju(int[] a,int star,int root){\n        if(star>=root)\n            return true;\n        int i = root;\n        //从后面开始找\n        while(i>star&&a[i-1]>a[root])\n            i--;//找到比根小的坐标\n        //从前面开始找 star到i-1应该比根小\n        for(int j = star;j<i-1;j++)\n            if(a[j]>a[root])\n                return false;;\n        return ju(a,star,i-1)&&ju(a, i, root-1);\n    }\n}\n", "Knowledge_Point": "树", "Question": "输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。\n数据范围： 节点数量 0 \\le n \\le 10000≤n≤1000 ，节点上的值满足 1 \\le val \\le 10^{5}1≤val≤105  ，保证节点上的值各不相同要求：空间复杂度 O(n)O(n) ，时间时间复杂度 O(n^2)O(n2 )提示：1.二叉搜索树是指父亲节点大于左child节点，但是小于右child节点。2.该题我们约定空树不是二叉搜索树3.后序遍历是指按照 “左子树-右子树-根节点” 的顺序遍历\n", "Tag": "数据结构"}
{"Answer": "4层for循环，性能其实是O(n)的。n是原始数据的总行数。因为最里层的println执行的次数刚好是总的行数，另外三个println各自总的执行次数都小于这个数。", "Knowledge_Point": "树", "Question": "如下，是数据库查询的数据：\n\n \n\n\n\n\n43, 科技, 53, 计算机, 35, 数据库,233, oracle\n43, 科技, 53, 计算机, 35, 数据库,234, mysql\n43, 科技, 53, 计算机, 35, 数据库,47, mssql\n43, 科技, 53, 计算机, 35, 数据库,48, access\n43, 科技, 53, 计算机, 35, 数据库,238, mongodb\n43, 科技, 53, 计算机, 35, 数据库,278, Cassandra\n43, 科技, 76, 工程, 182, 电力工程,276, 电力系统\n43, 科技, 76, 工程, 183, 软件工程,277,软件产品线工程\n43, 科技, 76, 工程, 247, 土木工程,340,土木工程测量\n42, 教育, 42, 语言文字, 73, 语言学,103, 粤语新手快速上口\n42, 教育, 42, 语言文字, 73, 语言学,205, 文字侦探\n42, 教育, 42, 语言文字, 74, 汉语,104, 说文解字\n\n如何把上面的数据转换为以下的树结构：\n\n \n\n\n\n\n书\n--科技\n  --计算机\n         --数据库\n             --oracle\n             --mysql\n             --mssql\n             --access\n             --mongodb      \n             --Cassandra\n  --工程\n    --电力工程\n         --电力系统\n    --软件工程\n         --软件产品线工程\n    --土木工程  \n         --土木工程测量   \n--教育\n  --语言文字\n        --语言学\n        --粤语新手快速上口\n        --文字侦探\n            \n        --汉语    \n            --说文解字\n\n 问题补充iminto 写道你这数据有问题吧，不完整 是的，只是前面几条。看应该可以看出规律。", "Tag": "数据结构"}
{"Answer": "\nIf you're going to have arbitrary depth, then it might be worth it to create a default struct that can be nested:\ntype area struct {\n    Name string\n    //Any other area info\n    Sections []*area\n}\n\nSlices of pointers aren't initialized when creating a new struct object, so it's a valid construct.  Declare a.Sections = new([]*area) and append area pointers to it.  You will have len(a.Sections) or a for range loop for use in the tree traversal.  \nParsing and traversal would be coded recursively, so you would need a type identifier if you treat different areas in different ways.\n", "Knowledge_Point": "树", "Question": "\n\nI am evaluating Go to replace Node.js infrastructure and I am not sure how to create a structure to represent a N-ary tree.\n\nIn JavaScript, I parse a file to build up a hierarchy of geographic locations of arbitrary depth. Here is an example:\n\n{\n  'country1': {\n    'area1': {\n      'town1': {}, \n      'town2': {}\n    },\n    'area2': {\n      'town3': {}\n    }\n  }\n}\n\n\nTowns could expand into specific roads and so on. The hierarchy doesn't have a fixed depth.\n\nHow can I create an equivalent structure in Go?\n    ", "Tag": "数据结构"}
{"Answer": "第一张图里调研结果分两种情况：良好（45%）或不容乐观（55%）。当调研结果是良好的时候建大厂，结果是不容乐观的时候建小厂，整体EMV最高，所以才这样计算：0.45x106400+0.55x2400=49200然后和不做市场调研的结果相比：大工厂：10000小工厂：40000很显然，市场调研，并根据调研结果选择建大厂还是小厂，综合的EMV更高。", "Knowledge_Point": "树", "Question": "第一张图  计算做市场调研的emv是取大的而第二张图是加起来 为什么呢\n", "Tag": "数据结构"}
{"Answer": "graph.refresh()", "Knowledge_Point": "树", "Question": "在使用antv G6  的脑图树的时候  我想点击相关节点后去发请求 获取这个节点下的数据 然后再去添加到源数据去  如果进行这样的操作  能不能保持原来的图不变 只渲染 新加的数据 那一部分    也就是我点击展开节点的时候 我不想用render方法去重新渲染这个整个图  ", "Tag": "数据结构"}
{"Answer": "把Menu对象和MenuItem对象分别定义,然后再组装成菜单,在右键单击事件中判断隐藏不同的MenuItme对象,调用某一个菜单节点的hide();方法达到隐藏效果\r\n\r\n\r\n另外建议你看api创建Action对象也就是菜单的节点对象,也是分别创建,Action对象应该是菜单节点对象的父类,不要隐藏某个菜单,而是让某个菜单项不可用disabled();这样是最好的解决办法.", "Knowledge_Point": "树", "Question": "我的web应用中有一个extjs做的树形菜单。我如何为每个树节点定制各自的右键菜单呢？如图那样。我在第一层树显示部门名称时只显示 （新增部门，编辑部门，删除部门，新增组别），第二层显示组别名称时右键菜单只显示（新增组别，编辑组别，删除组别，新增职务）这个几个右键菜单，在第三层显示职务时只显示（新增职务，编辑职务，删除职务）这几个右键菜单。这样应该如何做呢？ \n我的代码如下：\n[code=\"java\"]\n    var selected;\n    var loader=new Ext.tree.TreeLoader({\n        dataUrl:'baseUrl();?>/department/tree',\n        uiProviders:{'col': Ext.tree.ColumnNodeUI}\n    });\n    var tree = new Ext.tree.ColumnTree({\n        rootVisible:false,autoScroll:true,bodyStyle:'padding-left:5px;',\n        title: '部門管理(提示:在列表上面點擊右鍵可以操作部門,組別和職務資料)',renderTo: 'tree',\n        columns:[{\n            header:'名稱',\n            width:330,\n            dataIndex:'name'\n        },{\n            header:'編號',\n            width:100,\n            dataIndex:'number'\n        },{\n            header:'负责人',\n            width:300,\n            dataIndex:'header'\n        }],\n        loader:loader,\n        root: new Ext.tree.AsyncTreeNode({\n            id: '-100',icon:'baseUrl();?>/html/images/house.png',\n            text: '部門管理'\n        })\n    });\n\ntree.on(\"contextmenu\", function(node, e){\n    e.preventDefault();\n    node.select();\n    selected=new Ext.tree.TreeNode({ id:node.id});\n    contextmenu.showAt(e.getXY());\n},this);       \nvar contextmenu = new Ext.menu.Menu({\n    id: 'theContextMenu',\n    items: [\n        {xtype:\"button\",text:\"新增部門\",iconCls:\"add\",pressed:true,handler:addNewDepartment},\n        {xtype:\"button\",text:\"編輯部門\",iconCls:\"edit\",pressed:true,handler:editDepartment},\n        {xtype:\"button\",text:\"刪除部門\",iconCls:\"delete\",pressed:true,handler:deleteDepartment},\n        {xtype:\"button\",text:\"新增組別\",iconCls:\"add\",pressed:true,handler:addGroup},\n        {xtype:\"button\",text:\"編輯組別\",iconCls:\"edit\",pressed:true,handler:editGroup},\n        {xtype:\"button\",text:\"刪除組別\",iconCls:\"delete\",pressed:true,handler:deleteGroup},\n        {xtype:\"button\",text:\"新增職務\",iconCls:\"add\",pressed:true,handler:addDuty},\n        {xtype:\"button\",text:\"編輯職務\",iconCls:\"edit\",pressed:true,handler:editDuty},\n        {xtype:\"button\",text:\"刪除職務\",iconCls:\"delete\",pressed:true,handler:deleteDuty}\n    ]\n});\n\n\n[/code]", "Tag": "数据结构"}
{"Answer": "就是你i.value的值是空，不能使用split函数", "Knowledge_Point": "树", "Question": "我今天尝试openpyxl的时候报错'NoneType' object has no attribute 'split',百度搜索了一下看不懂,可以帮忙解释一下么?\n#---------------------------------------------------------------\nform openpyxl import load_workbook\nwb = load_workbook(\"C:\\\\MJP\\\\6_CODE\\\\a.xlsx\")\nsheet1 = wb.active\nb = []\nsepp = 1\nfor i in sheet1[\"e\"]\n    list = i.value.split('/')\n    for k in range(1,len(list1)+1):\n        valuea = sheet1.cell(row=i.row,column=3).value\n        valueb = list1[k-1]\n        print(sepp,valuea,sep='\\t')\n    sepp+=1\n#---------------------------------------------------------------\n\n\n", "Tag": "数据结构"}
{"Answer": "完全二叉树最大8层第7层节点数为 2^(7-1)=64，其中有10个叶子节点，则非叶子节点为54要求节点总数的最大值，则第8层节点数为54*2=108节点总数=2^7-1+108=127+108=235", "Knowledge_Point": "树", "Question": "已知某完全二叉树的第7层有10个叶结点，请求出该完全二叉树的结点总数的最大值。", "Tag": "数据结构"}
{"Answer": "你x_train和y_train的变量定义在那里呢？你都没有定义这个变量，你就使用它，当然报错了。\n你这是那里复制的代码啊", "Knowledge_Point": "树", "Question": "from sklearn.neighbors import KNeighborsClassifier\nclf = KNeighborsClassifier()\nclf.fit(x_train,y_train)\nTraceback (most recent call last):\n  File \"\", line 1, in \n    clf.fit(x_train,y_train)\nNameError: name 'x_train' is not defined\n\n出现错误后我尝试过重新安装sklearn模块，可是还没有解决", "Tag": "数据结构"}
{"Answer": "\nYou return the result inside the loops : the functions end after the first iteration.\nIt should be :\nfunction createSubCat($array, $curParent){\n        $html = '';\n        foreach ($array as $categoryId => $category) {\n\n            if ($curParent == $category['parent_id']) {\n                $html .= '<li id=\"' . $categoryId . '\" ><a href=\"#\">' . $category['name'] .'</a></li>';\n            }\n        }    \n        return $html;       \n    }\n\n    function createTree($array, $curParent) {\n        $html = '';\n        foreach ($array as $categoryId => $category) {\n            if ($curParent == $category['parent_id']) {\n                $html .= '\n                <li class=\"dropdown\">\n                    <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">' . $category['name'] .' <b class=\"caret\"></b></a>\n                    <ul class=\"dropdown-menu\">\n                ';\n                $html .=  createSubCat($array, $categoryId);\n                $html .=  '\n                    </ul>\n                </li>    \n                ';           \n            }                \n        }\n        return $html;\n    }\n\n", "Knowledge_Point": "B树", "Question": "\n\nI am trying to setup a navigation menu, but i am not getting back the Subcats.\nI think its in the .= but i am not sure.\n\nIn the createTree i call the create SubCat.\n\nI think I'll look over it.\n\nTip?\n\nThmx!\n\nid  name           description  parent_id   \n1   electronics    desc         0\n2   cloth          kleding      0   \n3   washing mach   desc was     1 \n4   dryer          desc droger  1   \n5   pants          desc broek   2   \n\n    $arrayMenu = array();\n\n    foreach( $navigation as $row ){\n        $arrayMenu[$row['id']] = array(\"parent_id\" => $row['parent_id'], \"name\" => $row['name']);\n    }\n\n    function createSubCat($array, $curParent){\n        $html = '';\n        foreach ($array as $categoryId => $category) {\n\n            if ($curParent == $category['parent_id']) {\n                $html .= '' . $category['name'] .'';\n            }\n            return $html;  \n        }          \n    }\n\n    function createTree($array, $curParent) {\n        $html = '';\n        foreach ($array as $categoryId => $category) {\n            if ($curParent == $category['parent_id']) {\n                $html .= '\n                \n' . $category['name'] .' \n\n                ';\n                $html .=  createSubCat($array, $categoryId);\n                $html .=  '\n                    \n    \n                ';           \n            }                \n            return $html;\n        }\n    }\n    $arrayss = createTree($arrayMenu, 0);\n    print_r($arrayss);\n\n\nout put:\n\n                \nElectronics\n\n\n\n", "Tag": "数据结构"}
{"Answer": "要么你重新设计一下你的表结构\r\n\r\ndept表\r\ndeptid deptname  parentId(父部门) hasSubDept(是否有子部门)\r\n\r\n然后每次可以根据一个部门ID来获取他的父部门和子部门", "Knowledge_Point": "B树", "Question": "我有 user表\n\nuserid  username  password  deptid\n\ndept表\n\n\ndeptid deptname  parentId(父部门) \n\n现在有要 查询出所有的 部门 --(子部门)  用js 树现实;;\n\n现在的问题是我不知道 怎么区分 等级部门 和 子部门  和  子子部门;\n\n--比如   dept\n  deptid deptname  parentId\n\n1      顶层      0\n   2      次层      1\n   3      次次层    2\n\n4       2层      1\n\njs  树\n\n顶层 \n      ---- 次层\n           --------次次层\n      -----2层\n\n效果就是以上   现在怎么select  顶层 和次 层的查询  都不知道\n\n有会的  帮帮把\n\n[b]问题补充：[/b]\n几层是未知的...\n[b]问题补充：[/b]\n给个具体的  例子 和演示把....谢谢了..", "Tag": "数据结构"}
{"Answer": "定义两个新栈，将当前栈所有元素pop后push到第一个新栈，然后第一个新栈再重复同样的操作，全部元素push到第二个新栈；然后再重复相同的操作，全部元素push到当前栈，这样元素顺序就逆置了", "Knowledge_Point": "栈", "Question": "仅使用顺序栈的操作函数InitStack(SqStack &s),DestroyStack(SqStack &S),Push(SqStack &s,SElemType e),Pop(SqStack &s,SElemType &e)以及StackEmpty(SqStack s)来编写算法：reverse(SqStack &s)， 以实现将顺序栈s中的内容逆置。", "Tag": "数据结构"}
{"Answer": "a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nstack = []  # 栈，append对应从尾部入栈，pop对应从尾部出栈\nfor i in a:\n    stack.append(i)\na = []\nwhile stack:\n    a.append(stack.pop())\nprint(a)\n", "Knowledge_Point": "栈", "Question": "求大佬们设计一个算法利用一个栈将一个循环队列中的所有元素逆置，队头变队尾，队尾变队头。", "Tag": "数据结构"}
{"Answer": "线性表前插是在表头插入(链表顺序和插入顺序相反)  后插在表尾插入(链表顺序和插入顺序相同)满足不同需求，而栈和队列是操作受限的线性表 栈只能在栈尾部插入删除 队列只能在尾部插入 头部删除，是他们性质决定的", "Knowledge_Point": "栈", "Question": "为什么线性表的链表有前插法和后插法，而栈和队列的链式存储没有前插法和后插法呢？大佬们帮忙解答一下！谢谢谢谢", "Tag": "数据结构"}
{"Answer": "\nfor(i=1;i<=n;i++){\n        cout << \"输入栈的第\" << i << \"个元素\" << endl;\n        ++s.top;//这里你为何要++??\n        cin >> newdate.id >> newdate.name;\n        Push(s,newdate);\n\n", "Knowledge_Point": "栈", "Question": "这是我的代码：\n\n#include\nusing namespace std;\n\n#define MAXSIZE 100\ntypedef struct{\n    int id;\n    char name[10];\n}SElemtype;\n\ntypedef struct{\n    SElemtype *base;\n    SElemtype *top;\n    int stacksize;\n}Sqstack;\n\nvoid InitStack(Sqstack &S);\nvoid Push(Sqstack &S,SElemtype e);\nvoid Pop(Sqstack &S,SElemtype &e);\nSElemtype Gettop(Sqstack S);\nint StackEmpty(Sqstack &S);\n\n\nint main(){\n    Sqstack s;\n    SElemtype newdate;\n    cout << \"构造一个空栈\" << endl;\n    InitStack(s);\n    int i,n;\n    cout << \"请输入栈的长度：\" << endl;\n    cin >> n;\n    for(i=1;i<=n;i++){\n        cout << \"输入栈的第\" << i << \"个元素\" << endl;\n        ++s.top;\n        cin >> newdate.id >> newdate.name;\n        Push(s,newdate);\n    }    \n    cout << \"请输出栈顶元素：\"<< endl;    \n    Gettop(s);\n    cout << newdate.id << \" \" << newdate.name << endl;\n    cout << \"请输出元素：\" << endl;\n    while (!StackEmpty(s))\n    {\n        Pop(s, newdate);\n        cout << newdate.id << \" \" << newdate.name << endl;    \n    }\n    return 0;\n}\n//顺序栈的初始化 \nvoid InitStack(Sqstack &S){\n    S.base=new SElemtype[MAXSIZE];//为顺序栈的动态分配数组空间 \n    if(!S.base)//存储分配失败 \n    exit(1);\n    S.top=S.base;//top初始为base，空栈 \n    S.stacksize=MAXSIZE;//stacksize置为栈的最大容量MAXSIZE \n}\n//顺序栈的入栈\nvoid Push(Sqstack &S,SElemtype e){\n    if(S.top-S.base==S.stacksize)//栈满 \n    exit(1);\n    *S.top++=e;\n} \n//顺序栈的出栈 \nvoid Pop(Sqstack &S,SElemtype &e){    \n    \n    if(S.top==S.base)//栈空 \n    exit(1);\n    e=*--S.top;//栈顶指针减1，将栈顶元素赋值给e \n}\n//顺序栈获取栈顶元素\nSElemtype Gettop(Sqstack S){\n    if(S.top != S.base)\n    return *(S.top-1);\n} \nint StackEmpty(Sqstack &S)  //判断栈是否为空\n{\n    if (S.top == S.base)\n        return 1;\n    else\n        return 0;\n    \n}\n\n\n\n关于顺序栈的出栈问题，为什么输出的结果不对啊？", "Tag": "数据结构"}
{"Answer": "1、堆和栈是两种数据结构，只能在一端对数据项进行插入和删除。\n2、在单片机应用中，堆栈是个特殊的存储区，主要是暂时存放数据和地址。\n3、堆，队列优先，先进先出。\n4、栈，先进后出。\n堆和栈的比较：\n1、栈(stack)与堆(heap)都是java用来在内存中存放数据的地方。\n2、java自动管理栈堆，程序员不需要理会(与C++不同)。\n3、栈，存储速度比堆快，仅次于CPU中的寄存器。缺点是，大小和生命周期是确定的缺少灵活性。\n4、栈数据在多线程或者多个栈之间是不可以共享的\n5、栈内部的多个值相等的变量是可以指向同一个地址的。\n6、堆的优势可以动态地分布内存的大小，生命周期也是动态的。\n7、java垃圾收集器会自动的收走不在使用的堆数据。\n8、堆的缺点是，要在运行时动态分配内存，存取速度较慢。", "Knowledge_Point": "栈", "Question": "什么是堆？什么是栈？\n这俩者有什么区别吗？\n希望可以通俗易懂。多谢各位大佬。", "Tag": "数据结构"}
{"Answer": "栈中存放基本数据类型（或者叫内置类型）以及引用类型（或者叫对象句柄），而堆中存放对象数据。\r\nString 比较特殊，在栈中查找有没有存放值为\"1234\"的地址，如果没有，则开辟一个存放字面值为\"1234\"的地址，接着创建一个新的String类的对象o str为引用在栈上", "Knowledge_Point": "栈", "Question": "Public static void changeStr(String str){\n        str=\"welcome\";\n    }\n    Public static void main(String[] args) {\n\n    String str=\"1234\";\n    changeStr(str);\n    System.out.println(str);\n}\n\n\n以这个体为例谁能给我解释一下关于 “堆”，“栈”的详细情况！谢谢", "Tag": "数据结构"}
{"Answer": "int n,f;SeqStack *S;\r\n->\r\nint n,f;SeqStack *S = (SeqStack *)malloc(sizeof(SeqStack));", "Knowledge_Point": "栈", "Question": " # include\n# include\n# define Max_Size 50\ntypedef struct{//typedef是小写开头! \n//注意此处的top是整形指针 \n    int data[Max_Size];\n    int top;\n}SeqStack,*PSeqStack;\n\n\nvoid Init_SeqStack(PSeqStack S)\n{\n    S->top=-1;//哪里错了？求解释！ \n}\n\n\nint Full_SeqStack(PSeqStack S)\n{\n    if(S->top==Max_Size-1) return 1;\n    else return 0;\n}\n\n\nint Empty_SeqStack(PSeqStack S)\n{\n    if(S->top==-1) return 1;\n    else return 0;\n}\n\n\nvoid Push_SeqStack(PSeqStack S,int n)\n{\n    if(Full_SeqStack(S)==1) exit(0);\n\n    else\n    {S->top=++S->top;//及时先加一个空间 \n     S->data[S->top]=n;}//栈也有data域！ \n}\n\n\nvoid Pop_SeqStack(PSeqStack S,int n)//*n也是指针 \n{   \n    if(Empty_SeqStack(S)==1) printf(\"UnderFlow\\n\");\n\n    else\n     {n=S->data[S->top];\n      S->top=--S->top;}//及时退一个空间 \n}\n\n\nint fact(int n,int f,PSeqStack S)//调用函数为什么不对?求解释！ \n{   \n    Init_SeqStack(S);\n    while(n!=0)\n    {\n    Push_SeqStack(S,n);\n    n=n-1;\n    }\n\n    f=1;\n\n    while(Empty_SeqStack(S)!=1)\n    {\n     Pop_SeqStack(S,n);\n     f=f*n;\n    }\n    return f;\n}\n\n\nint main()\n{   \n    int n,f;SeqStack *S;\n    printf(\"input n:\\n\");\n    scanf(\"%d\",&n);\n    printf(\"%d\\n\",fact(n,f,S));\n\n    getch();\n}\n\n\n", "Tag": "数据结构"}
{"Answer": "这题有一个隐含的意思就是:输入和输出是可以交错进行的,所以对于前三个答案,考虑他们入栈的时间都是不会有问题的,而对于D选项,由于最先输出的是4,说明这时候1,2,3都在栈内,未输出,因此根据先后顺序,1在栈底,不可能比2先输出", "Knowledge_Point": "栈", "Question": "设栈的输入序列是1，2，3，4，则下列不可能的输出序列是（）\nA. 1,2,4,3  B. 2,1,3,4  C. 1,4,3,2  D. 4,3,1,2\n答案是D，没理解，麻烦大神们为我解惑。", "Tag": "数据结构"}
{"Answer": "那按你的思路，初始的第一个栈空间不就没有存数据嘛，你先top++，再a[top]=data，a[0] 不就没塞数据嘛。正确的是如下：第一个元素入栈，初始栈顶指针top=0，a[top]=data，top++；第二个元素入栈，栈顶指针top=1，a[top]=data，top++；以此类推。。。\n", "Knowledge_Point": "栈", "Question": "不是元素入栈操作，是先将栈顶指针top加1，然后再将元素放在栈顶位置吗", "Tag": "数据结构"}
{"Answer": "\n#include<iostream>\n#include<malloc.h>\nusing namespace std;\ntypedef int QElementType;\ntypedef struct Node* NodePtr;\ntypedef struct SNode* Stack; //栈 \n\nstruct Node{       //链队列结点的结构体 \n    QElementType data;\n    NodePtr next;\n};\nstruct QNode{//链队列的头结点 \n    struct Node* front;//队头指针，指向第一个元素 \n    struct Node* rear;//队尾指针，指向最后一个元素的下一个位置 \n};\n\nstruct SNode{\n    QElementType data;\n    struct SNode *next;\n}; \n\nvoid InitQueue(QNode &Q){\n    //构造一个空队列\n    Q.front=Q.rear= (NodePtr)malloc(sizeof(struct Node));\n    if(!Q.front) cout<<\"分配空间失败！\";\n    Q.front->next=NULL; \n}\n\nvoid EnQueue(QNode &Q,QElementType e){//Q是头结点指针 \n    //插入元素e为Q的新的队尾元素\n    NodePtr p=(NodePtr)malloc(sizeof(struct Node));\n    if(!p) cout<<\"分配空间失败！\"; \n    p->data=e; \n    p->next=NULL;\n    Q.rear->next=p;\n    Q.rear=p;}\n    \nQElementType DeQueue(QNode &Q){//出队列 \n    QElementType e;\n    if(Q.front==Q.rear) return 0;\n    NodePtr p=(NodePtr)malloc(sizeof(struct Node));\n    p=Q.front->next;\n    e=p->data; \n    Q.front->next=p->next;\n    if(Q.rear==p) Q.rear=Q.front;\n    free(p);\n    return e;\n}\n\n//链栈 \nvoid Push(QElementType e,Stack S){//入栈\n    Stack p=(Stack)malloc(sizeof(struct SNode));\n    p->data=e;\n    p->next=S->next;\n    S->next=p;\n}\nQElementType Pop(Stack S){//出栈\n    if(S){\n        QElementType e;\n        Stack p=(Stack)malloc(sizeof(struct SNode));\n        p=S->next ;\n        e=p->data;\n        S->next=p->next;\n        free(p);\n        return e;\n    } \n    \n} \nint main(){\n    int n; \n    cin>>n;\n    QElementType e,item1,item2;\n    QNode Q;\n    InitQueue(Q);\n    Stack S;\n    S=(Stack)malloc(sizeof(struct SNode));\n    S->next=NULL;\n\n    for(int i=0;i<n;i++){\n        cin>>e;\n        EnQueue(Q,e);\n    }\n    for(int i=0;i<n;i++){\n        item1=DeQueue(Q);\n        Push(item1,S);\n    }\n    for(int i=0;i<n;i++){\n        item2=Pop(S);\n        cout<<item2<<\" \";\n    }\n}\n    \n    \n\n", "Knowledge_Point": "栈", "Question": "已知q是一个非空顺序队列，s是一个顺序栈，请设计一个算法，实现将队列q中所有元素逆置", "Tag": "数据结构"}
{"Answer": "默认，栈大小比堆大小，小很多", "Knowledge_Point": "栈", "Question": "\npublic class A {\n    A a=new A();\n \n    public static void main(String[] args) {\n        A a1 = new A();\n    }\n}\n\n为什么不是堆益处，而是stackoverflow", "Tag": "数据结构"}
{"Answer": "会判断的，因为if跟while是并列语句，所以while结束后一定会执行if语句\n只是如果弹空了，说明左右括号不匹配，就输出no match如果没空，剩下左括号，就是匹配了", "Knowledge_Point": "栈", "Question": "当执行循环时，假如把栈里的元素全弹出了，那后面的if语句还会再去判断栈空吗？", "Tag": "数据结构"}
{"Answer": "因为删除尾节点指针指向的节点后，还得将尾节点指针指向被删除节点前面那个节点。而要找到前面那个节点的地址，需要O(n)", "Knowledge_Point": "栈", "Question": "为什么带有尾节点的链表删除最后一个元素的时间复杂度是o(n)", "Tag": "数据结构"}
{"Answer": "T2CA内部用_alloca在栈上申请内存，所以你传递这么大的字符串进去，肯定得栈溢出。建议模仿T2CA的左发，自己调用WideCharToMultiBytes。_", "Knowledge_Point": "栈", "Question": "所做工作如图所示，原本直接用T2CA()转的，结果报栈溢出，所以我就想分段来处理了，结果第一次T2CA()没问题，结果第二次又报栈溢出了。。。(字符串长度大概90多万)，求帮忙", "Tag": "数据结构"}
{"Answer": "供参考：\n#include <stdio.h>\n#include <stdlib.h>\n//#include <stdbool.h>\ntypedef char DataType;\ntypedef struct Node{\n    DataType ele;\n    struct Node *link;\n}StackNode;\nvoid initStack(StackNode *S){\n    S->link = NULL;   //S=NULL;\n}\nbool pushStack(StackNode *S,DataType data){\n   StackNode *p  =(StackNode*)malloc(sizeof(StackNode));\n   if(p==NULL){\n      printf(\"创建节点失败\\n\");\n      return false;\n                       //exit(1);\n   }\n   p->ele=data;\n   p->link = S->link;  //p->link = S;\n   S->link = p;        //S=p;\n   return true;\n}\nbool isEmpty(StackNode *S){\n    if(S->link == NULL){  //if(S==NULL)\n        return true;\n    }else{\n        return false;\n    }\n}\nbool pop(StackNode *S,DataType *x){\n    if(isEmpty(S)){\n        return false;\n    }\n    StackNode *p=S->link; //*p=S;\n    *x=p->ele;\n    S->link=p->link;     //S=p->link;\n    free(p);             //修改\n    return true;\n}\nint main()\n{\n    StackNode S;\n    char x;\n    initStack(&S);   //初始化栈\n    //压栈\n    pushStack(&S,'a');\n    pushStack(&S,'b');\n    pushStack(&S,'c');\n    pushStack(&S,'d');\n\n    //弹栈\n    if (pop(&S,&x))\n        printf(\"%c\",x);\n    else\n        printf(\"\\nisEmpty\");\n\n    if (pop(&S,&x))\n        printf(\"%c\",x);\n    else\n        printf(\"\\nisEmpty\");\n\n    if (pop(&S,&x))\n        printf(\"%c\",x);\n    else\n        printf(\"\\nisEmpty\");\n\n    if (pop(&S,&x))\n        printf(\"%c\",x);\n    else\n        printf(\"\\nisEmpty\");\n\n    if (pop(&S,&x))\n        printf(\"%c\",x);\n    else\n        printf(\"\\nisEmpty\");\n\n    if (pop(&S,&x))\n        printf(\"%c\",x);\n    else\n        printf(\"\\nisEmpty\");\n\n    //printf(\"%c\",S.ele);\n    return 0;\n}\n\n", "Knowledge_Point": "栈", "Question": "问题遇到的现象和发生背景\n链式栈无法进行压栈和出栈\n用代码块功能插入代码，请勿粘贴截图\n#include \n#include \n#include \ntypedef char DataType;\ntypedef struct Node{\n    DataType ele;\n    struct Node *link;\n}StackNode;\nvoid initStack(StackNode *S){\n    S=NULL;\n\n\n}\nbool pushStack(StackNode *S,DataType data){\n   StackNode *p  =(StackNode*)malloc(sizeof(StackNode));\n   if(p==NULL){\n    printf(\"创建节点失败\\n\");\n    return false;\n    exit(1);\n   }\n   p->ele=data;\n   p->link=S;\n   S=p;\n   return true;\n\n\n\n\n\n}\nbool isEmpty(StackNode *S){\n    if(S==NULL){\n        return true;\n    }else{\n        return false;\n    }\n\n\n}\nbool pop(StackNode *S,DataType *x){\n    if(isEmpty(S)){\n        return false;\n    }\n    StackNode *p=S;\n    *x=p->ele;\n    S=p->link;\n    return true;\n\n\n}\n\nint main()\n{\n\n    StackNode S;\n    char x;\n    pushStack(&S,'o');\n\n    printf(\"%c\",S.ele);\n\n    return 0;\n}\n\n\n\n运行结果及报错内容\n", "Tag": "数据结构"}
{"Answer": "\nI believe you're right, though I'm unsure of the relationship between \"virtual\" and \"resident\" memory it's possible there's some overlap.  \nSome things to consider: you're running 100,000 it appears, not 10,000.\nThe stack itself might contain things like the strings used for the printfs, method parameters, etc.  \nAs of go 1.2 the default stack size (per go routine) is 8KB  which may explain some of it.\nAs of go 1.3 it also uses an exponentially increasing stack size, but I doubt that's the problem you're running into.\n", "Knowledge_Point": "栈", "Question": "\n\nI know go routine can have a few blocking actions,  wonder if a goroutine can call a user-defined blocking function like a regular function.  A user-defined blocking function has a few steps like, step1, step2.  \n\nIn another word, I would like to find out whether we can have nested blocking calls in a go routine. \n\nUPDATE:\n\nOriginal intention was to find the stack size used by goroutine, especially with nested blocking calls. Sorry for the confusion.  Thanks to the answer and comments, I created the following function that has 10,000 goroutines,  it took 782MB of virtual memory 416MB of Resident memory on my Ubuntu desktop.  It evens out to be 78KB of memory for each go routine stack.  Is this a correct statement?\n\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc f(a int) {\n    x := f1(a);\n    f2(x);\n}\nfunc f1(a int) int {\n    r := step(\"1a\", a);\n    r = step(\"1b\", r);\n    return 1000 * a;\n}\nfunc f2(a int) {\n    r := step(\"2a\", a);\n    r = step(\"2b\", r);\n}\nfunc step(a string, b int) int{\n    fmt.Printf(\"%s %d\n\", a, b);\n    time.Sleep(1000 * time.Second)\n    return 10 * b;\n}\n\nfunc main() {\n    for i := 0; i < 100000; i++ {\n        go f(i);\n    }\n    //go f(20);\n    time.Sleep(1000 * time.Second)\n}\n\n    ", "Tag": "数据结构"}
{"Answer": "\nThe only modification possible to the defer stack is to \"pop\" onto it.\nHaving said that, you could make a defer optional with a variable to early-exit from the deferred function.  Example:\nfunc foo() {\n    var skipDefer bool\n    defer func() {\n        if skipDefer {\n            return\n        }\n        // Do body of defer\n    }()\n    // Do stuff\n    if someConditionIsTrue {\n        skipDefer = true\n    }\n    defer func() {\n        // Do this one unconditionally\n    }\n    // Do other stuff\n}\n\nYou could also manage a list of functions to be executed manually, if you really want to:\nfunc foo() {\n    var deferreds []func()\n    defer func() {\n        for _, f := range deferreds {\n            f()\n        }\n    }()\n    // Add to and arrange `deferreds` to your heart's content\n\n}\n\n", "Knowledge_Point": "栈", "Question": "\n\nIs there any way to change the defer stack? For example, adding a call to the bottom of the defer stack, or removing the last defer placed?\n    ", "Tag": "数据结构"}
{"Answer": "放在了虚拟机栈，属于虚拟机栈的局部变量表里面的对象引用", "Knowledge_Point": "栈", "Question": "请问这个acct引用是放在栈吗，还是放在了堆\n\n看了尚硅谷的视频的这个图不是很理解\n图上显示说随对象一起放在了堆里，然后acct再通过类型指针引用堆里的Account对象；", "Tag": "数据结构"}
{"Answer": "import random\n\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def clear(self):\n        del self.items[:]\n\n    def isempty(self):\n        return self.size() == 0\n\n    def size(self):\n        return len(self.items)\n\n    def top(self):\n        return self.items[self.size()-1]\n\n\nif __name__ == '__main__':\n    stack=Stack()\n    print(\"You will enter 5 employees\")\n    for i in range(1,6):\n        print(f\"Enter the {i} Employee\")\n        name=input()\n        number=random.randint(10000,99999)\n        print(f\"The employee number of the above employee is {number}\")\n        stack.push([name,number])\n    print(\"If in case there will be a laid off\")\n    while not stack.isempty():\n        name,number=stack.pop()\n        print(f\"{name} Lativia with employee number of {number} will be the first to go\")\n\n# John\n# Jessica\n# Jomari\n# Sanaya\n#Lativia\n\n", "Knowledge_Point": "栈", "Question": "说明:根据以下要求创建python程序\n一个strack1·该程序将提示您输入5名员工2 对于每个员工,您将生成一组随机的员工编号3 如果公司决定解雇员工,你要拿出一份计划,它将遵循“后进先出”原则4 您必须将堆栈用作代码的一部分\n", "Tag": "数据结构"}
{"Answer": "对，写反了。正确的入栈操作是：top++; data[top]=x;", "Knowledge_Point": "栈", "Question": "问题遇到的现象和发生背景\n这个写反了吧，入栈是先移动栈顶指针后放入元素，\n遇到的现象和发生背景，请写出第一个错误信息\n用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%\n运行结果及详细报错内容\n我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%\n我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "Tag": "数据结构"}
{"Answer": "#include<stdio.h>\n#include<stdlib.h>\n#define maxvector 150\nstruct stack\n{\n    int data[maxvector];\n    int top;\n};\nvoid init(struct stack *L)\n{\n    memset(L->data,0,sizeof(L->data));\n    L->top=0;\n}\nint pop(struct stack *L)\n{\n    if(L->top<=0) return -1;\n    else return L->data[--L->top];\n}\nvoid push(struct stack *L,int num)\n{\n    if(L->top<maxvector-1)\n        L->data[L->top++]=num;\n    else\n        printf(\"error\");\n}\nint gettop(struct stack L)\n{\n    if(L.top<=0) return -1;\n    else return L.data[L.top-1];\n}\nvoid conversion(int n)\n{\n    struct stack L;\n    init(&L);\n    while(n>0)\n    {\n        push(&L,n%8);\n        n/=8;\n    }\n    while(L.top)\n    {\n        printf(\"%d\",gettop(L));\n        pop(&L);\n    }\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    conversion(n);\n    return 0;\n}\n", "Knowledge_Point": "栈", "Question": "#define _CRT_SECURE_NO_WARNINGS#define _CRT_SECURE_NO_DEPRECATE#pragma warning(disable:4996)；#include#include #define ok 1#define error 0#define overflow -2#define stackmaxsize 100typedef int selemtype;typedef struct{    selemtype* base;    selemtype* top;    int tacksize;}stack; char initstack(stack &s){    s.base = (selemtype*)malloc(stackmaxsize * sizeof(selemtype));    if (s.base)        exit(overflow);    s.base = s.top;    s.tacksize = stackmaxsize;    return ok;}char push(stack& s, selemtype e){    if (s.top - s.base >= s.tacksize)        return error;    *s.top = e;    s.top++;    return ok;}char pop(stack &s, selemtype e){    if (s.base == s.top)        return error;    e = *s.top;    s.top--;}\nvoid conversion(stack &s, int n){    int e;    if (n > 0)    {        while (n)        {            push(s, n %8);            n = n / 8;        }\n}\nwhile (s.top != s.base)\n{\n    pop(s,n);\n    printf(\"%d\", n);\n}\n\n}\nint main(){    int n;    stack s;    initstack(s);    scanf(\"%d\", &n);    conversion(s, n);\n}", "Tag": "数据结构"}
{"Answer": "void rotate(int* nums, int size, int k)调试下，size传进来是多少", "Knowledge_Point": "栈", "Question": "\n#include\nvoid rotate(int* nums, int size, int k);\nint main() {\n\n    int nums[101]; int k = 3;\n    int n = 0; scanf(\"%d\", &n);\n    printf(\"需要输入%d个数组元素\\n\",n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &nums[i]);\n\n    rotate(nums, n, k);\n    printf(\"\\n旋转后数组为:\\n\");\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", nums[i]);\n    return 0;\n}\nvoid rotate(int* nums, int size, int k)\n{\n    k %= size;\n    int* arr = (int*)malloc(sizeof(int) *size);\n    int count = 0;\n    for (int i = size - k; i < size; i++)\n    {\n        arr[count] = nums[i];//先把需要颠倒的先拷贝到新数组\n        count++;\n    }\n    for (int j = 0; j <size-k; j++)\n    {\n        arr[count] = nums[j];//把后需要颠倒的拷贝到新数组\n        count++;\n    }\n    for (int k = 0; k < size; k++)\n    {\n        nums[k] = arr[k];\n    }\n}\n\n虽程序能正常运行并且得到正确结果，但怎么解决怎么溢出的警告！各位看如何解决！", "Tag": "数据结构"}
{"Answer": "在C++中，当一个对象被销毁时，会自动调用其析构函数。因此，当使用delete运算符删除一个对象时，其析构函数也会被自动调用。没看到图当一个对象生命周期结束时，其析构函数会被自动调用，还有一种情况就是当在程序执行过程中抛出异常时，系统会自动调用所有在异常抛出点之前创建的对象的析构函数。当创建子类对象时，会先调用父类的构造函数，再调用子类的构造函数。这是因为子类继承了父类的成员函数和部分属性，子类对象的构造需要先初始化继承自父类的部分属性和成员函数，才能初始化自己新增的属性。\n不知道我说明白了没有", "Knowledge_Point": "栈", "Question": "第一个问题 delete 一个对象会调用其析构函数吗？第二个问题如图所示，他说不会调用子类的析构函数，但是如果子类的属性是在栈区 不会自动调用子类的析构函数吗？第三个问题，析构函数的调用时机是什么？第四个问题，为什么父类没有属性，子类有属性，在创建子类对象时，会调用父类构造函数？求解答，谢谢", "Tag": "数据结构"}
{"Answer": "switch里的break只是跳出了switch语句，没有跳出while语句，把\nmenu();\nprintf(\"要进行的操作：\\n\");\nscanf_s(\"%d\", &choice);\n\n这两行代码放进while里就行了", "Knowledge_Point": "二叉树", "Question": "为什么我写的二叉树代码，会一直要输入元素，无法终止？救命，有哪位大能能帮我看看到底是哪错了！下面是我的全部代码：\n#include\n#include\ntypedef char ElemType;\nvoid menu()\n{\n    printf(\"     二叉树\\n\");\n    printf(\"1.建立二叉树\\n\");\n    printf(\"2.先序遍历二叉树\\n\");\n    printf(\"3.中序遍历二叉树\\n\");\n    printf(\"4.后序遍历二叉树\\n\");\n    printf(\"0.退出\\n\");\n}\ntypedef struct BiTNode\n{\n    ElemType data;\n    struct BiTNode* lchild, * rchild;\n}BiTNode, * BiTree;\nvoid InitBiTree(BiTree& T)\n{\n    T = new BiTNode;\n    T->lchild = T->rchild = NULL;\n}\nbool CreateBiTree(BiTree T)\n{\n    char c;\n    scanf_s(\"%c\", &c);\n    if (c == '#')\n    {\n        T = NULL;\n        return true;\n    }\n    T = new BiTNode;\n    T->data = c;\n    CreateBiTree(T->lchild);\n    CreateBiTree(T->rchild);\n    return true;\n}\nvoid PreOrder(BiTree T)\n{\n    if (T == NULL)\n        return;\n    printf(\"%c \", T->data);\n    PreOrder(T->lchild);\n    PreOrder(T->rchild);\n}\nvoid InOrder(BiTree T)\n{\n    if (T == NULL)\n        return;\n    InOrder(T->lchild);\n    printf(\"%c \", T->data);\n    InOrder(T->rchild);\n}\nvoid PostOrder(BiTree T)\n{\n    if (T == NULL)\n        return;\n    PostOrder(T->lchild);\n    PostOrder(T->rchild);\n    printf(\"%c \", T->data);\n}\nint main()\n{\n    int choice;\n    BiTree T;\n    InitBiTree(T);\n    menu();\n    printf(\"要进行的操作：\\n\");\n    scanf_s(\"%d\", &choice);\n    while (1)\n    {\n        switch (choice)\n        {\n        case 1:\n            printf(\"请输入二叉树节点元素(无元素用#代替)：\\n\");\n            CreateBiTree(T);\n            break;\n        case 2:\n            PreOrder(T);\n            break;\n        case 3:\n            InOrder(T);\n            break;\n        case 4:\n            PostOrder(T);\n            break;\n        default:\n            printf(\"你的输入有误，请重新输入：\\n\");\n        }\n    }\n    return 0;\n}\n\n", "Tag": "数据结构"}
{"Answer": "选择D，只有头节点和最后一个节点有空域。其余的节点都存了它的后驱或者子节点。\r\n\r\n`如果问题得到解决，请点我回答左上角的采纳，谢谢`", "Knowledge_Point": "二叉树", "Question": "一棵非空的二叉树在中序线索化后，其中值为空的链域的个数是\nA 不确定 B.0  C.1  D.2", "Tag": "数据结构"}
{"Answer": "这段代码似乎在检查T是否符合二叉树数组\r\n构造一个数组，很明显不符合二叉树\r\n1 \r\n2          2\r\n3    3    3    null \r\n4 4 4 4 4 4 4 4\r\nnull那个元素为空，最后两个4很明显不符合条件", "Knowledge_Point": "二叉树", "Question": "顺序存储是根据数组来完成的\n\n/* 按层序次序输入二叉树中结点的值(字符型或整型), 构造顺序存储的二叉树T */\nStatus CreateBiTree(SqBiTree T)\n{ \n    int i=0;\n    printf(\"请按层序输入结点的值(整型)，0表示空结点，输999结束。结点数≤%d:\\n\",MAX_TREE_SIZE);\n    while(i<10)\n    {\n        T[i]=i+1;\n\n        if(i!=0&&T[(i+1)/2-1]==Nil&&T[i]!=Nil) /* 此结点(不空)无双亲且不是根 */\n        {\n            printf(\"出现无双亲的非根结点%d\\n\",T[i]);\n            exit(ERROR);\n        }\n        i++;\n    }\n    while(i<MAX_TREE_SIZE)\n    {\n        T[i]=Nil; /* 将空赋值给T的后面的结点 */\n        i++;\n    }\n\n    return OK;\n}\n\n\n里面这个if判断，明明是不可能出现这种错误的，我觉得有必要判断吗？\n        if(i!=0&&T[(i+1)/2-1]==Nil&&T[i]!=Nil) /* 此结点(不空)无双亲且不是根 */\n        {\n            printf(\"出现无双亲的非根结点%d\\n\",T[i]);\n            exit(ERROR);\n        }\n        有大佬可以解释一下吗？？感激不尽...", "Tag": "数据结构"}
{"Answer": "刚好也在学习二叉树：\nclass BTree:\n \n    def __init__(self, data=None, lchild=None, rchild=None):\n        self.data = data\n        self.left = lchild\n        self.right = rchild\n \n    def __repr__(self):\n        if not (self.left or self.right): return f'{self.data}'\n        return f'[{self.left if self.left else \"-\"}<{self.data}>{self.right if self.right else \"-\"}]'\n \n    def preOrder(self):\n        '''前序遍历'''\n        if not self: return []\n        return [self.data]+BTree.preOrder(self.left)+BTree.preOrder(self.right)\n \n    def inOrder(self):\n        '''中序遍历'''\n        if not self: return []\n        return BTree.inOrder(self.left)+[self.data]+BTree.inOrder(self.right)\n \n    def postOrder(self):\n        '''后序遍历'''\n        if not self: return []\n        return BTree.postOrder(self.left)+BTree.postOrder(self.right)+[self.data]\n\n    def Leaves(self):\n        '''遍历出所有叶子'''\n        if not self:\n            return []\n        elif not self.left and not self.right:\n            return [self.data]\n        return BTree.Leaves(self.left)+BTree.Leaves(self.right)\n\n \n    def levelOrder(self):\n        '''层序遍历'''\n        que = __import__('queue').Queue()\n        que.put(self)\n        res = []\n        while not que.empty() :\n            n = que.get()\n            res.append(n.data)\n            if n.left is not None :\n                que.put(n.left)\n            if n.right is not None :\n                que.put(n.right)\n        return res\n \n    def Height(self):\n        if not self: return 0\n        lH = BTree.Height(self.left)\n        rH = BTree.Height(self.right)\n        return max(lH,rH)+1\n\n\nexp = BTree('+')\nexp.left  = BTree('*')\nexp.right = BTree('/')\n \nexp.left.left   = BTree(1)\nexp.left.right  = BTree(2)\nexp.right.left  = BTree(3)\nexp.right.right = BTree('-')\n\nexp.right.right.left  = BTree(5)\nexp.right.right.right = BTree(6)\n\nprint(exp)\nprint(exp.Leaves())\n\n'''输出：\n[[1<*>2]<+>[3</>[5<->6]]]\n[1, 2, 3, 5, 6]\n'''\n", "Knowledge_Point": "二叉树", "Question": "假设二叉树中每个结点值为单个字符，采用二叉链存储结构存储（ BTree 类），设计一个算法，按从左到右的次序输出一棵二叉树bt中的所有叶子结点", "Tag": "数据结构"}
{"Answer": "```\r\n 最简单的，先开一个很大的数组（确保肯定够）tnode * arr[100000]，再定义一个全局的变量  int currindex\r\nprintf(\"%s %d\\n\",p->word,p->count);\r\n->\r\narr[currindex++] = p;\r\n```", "Knowledge_Point": "二叉树", "Question": "C语言 如何将二叉树中序遍历的结果存入一个数组，我的代码这段是用递归写的，但不知道如何将值传到数组中？\n\n void treeprint(struct tnode *p)\n{\n    if(p!=NULL){\n        treeprint(p->left);\n        printf(\"%s %d\\n\",p->word,p->count);\n        treeprint(p->right);\n    }\n}\n\n\n我的想法是将每个p->word （指的是单词）存入二维字符型数组中\n将每个p->count（指的是单词的个数）存入整型数组中，但不知道如何将值传到数组中？", "Tag": "数据结构"}
{"Answer": "这句话是对的，前序遍历的定义就是：先访问根节点，再访问根节点的左右子树。伪代码如下：\n\nPreorder-Tree-Walk(x)\nif x != NULL\nprint x.value // 输出根节点的值\nPreorder-Tree-Walk(x.left) // 访问左子树\nPreorder-Tree-Walk(x.right)// 访问右子树", "Knowledge_Point": "二叉树", "Question": "在先序遍历二叉树的序列中,任何结点的子树的所有结点都是直接跟在该结点之后？为什么？", "Tag": "数据结构"}
{"Answer": "后序遍历就是先左子树，然后右子树，最后根，在每个子树上也是基于这个规则。而且是满二叉树，是比较简单的。\n有帮助请采纳~", "Knowledge_Point": "二叉树", "Question": "满二叉树结点数据后序遍历结果是ABCDEFG：请画出该满二叉树并标出每个结点的数据", "Tag": "数据结构"}
{"Answer": "你学java 基本都用不到。\r\n\r\njava 的几个集合类型。底层实现，就用到了树算法。", "Knowledge_Point": "二叉树", "Question": "这几天看了红黑树=平衡二叉树，知道了是怎么回事，但是不清楚在什么样的情况下用它？\n比如在什么场合下，用到红黑树，而不是数组或者双向链表等。\n\n谢谢！", "Tag": "数据结构"}
{"Answer": "           D\n         A\n            C\n         B     E\n           G\n", "Knowledge_Point": "二叉树", "Question": "中序遍历 ABGCED后序遍历  GBECAD", "Tag": "数据结构"}
{"Answer": "你把树存对，然后用深搜  找节点不就能完成需求了吗。", "Knowledge_Point": "二叉树", "Question": "问题描述：求二叉树根结点到r结点之间的路径\nDescription：假设二叉树采用二叉链表方式存储，root指向根结点，r所指结点为任一给定的结点。请编程，求出从根结点到结点r之间的路径。Input输入有若干种情况，每种情况二行，第一行是一个按顺序存储的二叉树。如果结点处空用半角的‘.’代替。第二行是一个要查找的结点r。Output每个案例输出一行，输出从根结点到结点r之间的路径。\n\n\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Scanner cin = new Scanner(System.in);\n        while (cin.hasNext()) {\n            String str = cin.next();\n            // 根据顺序存储的二叉树创建连式存储的二叉树\n            BinaryTree tree = new BinaryTree(str);\n            \n\n        }\n\n    }\n\n\n}\n\nclass BinaryNode {\n    // 数据\n    T data;\n    // 左孩子\n    BinaryNode left;\n    // 右孩子\n    BinaryNode right;\n\n    public BinaryNode(T data, BinaryNode left, BinaryNode right) {\n        super();\n        this.data = data;\n        this.left = left;\n        this.right = right;\n    }\n\n    public BinaryNode() {\n        super();\n    }\n\n    // 根据节点的内容创建节点\n    public BinaryNode(T data) {\n        this(data, null, null);\n    }\n\n    // 判断节点是否为叶子节点\n    public boolean isLeaf() {\n        return left == null && right == null;\n    }\n\n    // 遍历节点\n    @Override\n    public String toString() {\n        return data.toString();\n    }\n\n}\n\nclass BinaryTree {\n\n    BinaryNode root;\n\n    public BinaryTree(BinaryNode root) {\n        super();\n        this.root = root;\n    }\n\n    // 1 空树\n    public BinaryTree() {\n        super();\n        root = null;\n    }\n\n    public BinaryTree(String str) {\n        super();\n        root = createTree(str, 0);\n    }\n\n    // 2 判空\n    public boolean isEmpty() {\n        return root == null;\n    }\n\n    public void levelOrder() {\n\n        this.levelOrder(root);\n    }\n\n    // 层次遍历\n    public void levelOrder(BinaryNode p) {\n        Queue> q = new LinkedList>();\n        q.add(p);\n\n        while (!q.isEmpty()) {\n            BinaryNode t = q.poll();\n            System.out.print(t.data.toString());\n            if (t.left != null) {\n                q.add(t.left);\n\n            }\n            if (t.right != null) {\n                q.add(t.right);\n            }\n\n        }\n\n    }\n\n    //\n    public BinaryNode createTree(String str, int i) {\n\n        BinaryNode p = null;\n\n        if (i < str.length() && str.charAt(i) != '.') {\n            // 创建根节点\n            p = new BinaryNode(str.charAt(i));\n            p.left = createTree(str, 2 * i + 1);\n            p.right = createTree(str, 2 * i + 2);\n\n        }\n\n        return p;\n\n    }\n\n}\n", "Tag": "数据结构"}
{"Answer": "由后续遍历尾部为E可知，顶节点为E所以从中序遍历中以E分割后可知，E的左侧节点为ABCD，右侧为FG将此带入后序遍历又可知，E的左侧节点为A（因为后序遍历中ABCD四个节点A排最后）再将此带入中序遍历，可知A左侧无节点，右侧为BCD同理，C为A的右节点，B为C的左节点，D为C的右节点，G为E的右节点，F为G的左节点先序遍历为：EACBDGF\n", "Knowledge_Point": "二叉树", "Question": "已知一棵二叉树的中序遍历为ABCDEFG，后序遍历为BDCAFGE，试画出此二叉树并写出它的先序遍历。  这画的对不对啊", "Tag": "数据结构"}
{"Answer": "if (bitree.RootNode == NULL) return;\r\n大概就是这个意思，如果二叉树根节点都是空的，就直接返回。", "Knowledge_Point": "二叉树", "Question": "什么叫做   若二叉树为空   则空操作返回   能不能解释一下是什么意思？？？？", "Tag": "数据结构"}
{"Answer": "思路一：递归\\n这道题用递归来解的话非常简单，我们把二叉树的根节点记为 root，如果我们想判断一颗二叉树是否存在路径和 sum，那么只需判断其左子树或者右子树是否存在路径和 sum-root.val。代码如下：\npublic boolean hasPathSum(TreeNode root, int sum)\n {    if (root == null)     return false;    int val = root.val;   \n if (root.left == null && root.right == null && val == sum)      \n return true;   \n return hasPathSum(root.left, sum - val) || hasPathSum(root.right, sum - val);}\n\n\n思路二：迭代——用栈代替递归利用栈先入后出的特点，我们可以对思路一中的递归代码进行改造，代码如下：\npublic boolean hasPathSum_iteration(TreeNode root, int sum){\n    if (root == null)\n        return false;\n    Stack<TreeNode> stack = new Stack<>();\n    Stack<Integer> path = new Stack<>();\n\n    TreeNode t = root;\n    Integer val = root.val;\n    stack.push(t);\n    path.push(val);\n    while (!stack.isEmpty()){\n        t = stack.pop();\n        val = path.pop();\n        if (t.left == null && t.right == null && sum == val){ //到达了叶子结点，且路径总和正好等于sum\n            return true;\n        }\n        if (t.left != null){\n            stack.push(t.left);\n            path.push(val + t.left.val);\n        }\n        if (t.right != null){\n            stack.push(t.right);\n            path.push(val + t.right.val);\n        }\n    }\n    return false;\n}\n\n", "Knowledge_Point": "二叉树", "Question": "给定二叉树和求和，确定树是否具有根到叶路径，使得沿路径的所有值相加等于给定的总和。", "Tag": "数据结构"}
{"Answer": "首先，理解是：题主是想将以数据的个数先对比，其次数据存入数组之后的数据一一对比，但是有两个问题：1：存左子树或右子树数据函数的数组，运用的下标i是临时变量，所以递归之后值会返回去，没有根据数据存储区间++下去（每次递归回去会原来的值）2：对于空指针没有规范化\n\n代码改正：\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int calculation(struct TreeNode* t, int* a, int& i)//将i改为引用，使得每一层递归都一个保存\n    {\n        //将NULL时规范化，防止图示情况\n        if (t == NULL)\n        {\n            a[i++] = 0;\n            return i;\n        }\n        a[i++] = t->val;\n        calculation(t->left, a, i);\n        return calculation(t->right, a, i);\n    }\n\n    int calcu(struct TreeNode* t, int* a, int& i)//将i改为引用，使得每一层递归都一个保存\n    {\n        //将NULL时规范化，防止图示情况\n        if (t == NULL)\n        {\n            a[i++] = 0;\n            return i;\n        }\n        a[i++] = t->val;\n        calcu(t->right, a, i);\n        return calcu(t->left, a, i);\n    }\n\n    bool isSymmetric(struct TreeNode* root) {\n        if (!root->left && !root->right)\n            return true;\n        if (!root->left || !root->right)\n            return false;\n        int a1[1000] = { 0 }, a2[1000] = { 0 };\n        int count1 = 0, count2 = 0;\n        //引用必须要变量，所以定义两个\n        int i1 = 0, i2 = 0;\n        count1 = calculation(root->left, a1, i1);\n        count2 = calcu(root->right, a2, i2);\n        if (count1 != count2)\n            return false;\n        for (int i = 0; i < count1; i++)\n        {\n            if (a1[i] != a2[i])\n                return false;\n        }\n        return true;\n    }\n};\n\n", "Knowledge_Point": "二叉树", "Question": "请问自己写的代码错在哪里\n题目：\n\nC语言我的代码：\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nint calculation(struct TreeNode* t, int* a,int i)\n{\n    if(t==NULL)\n        return i;\n    a[i++]=t->val;\n    calculation(t->left,a,i);\n    return calculation(t->right,a,i);\n}\n\nint calcu(struct TreeNode* t, int* a,int i)\n{\n    if(t==NULL)\n        return i;\n    a[i++]=t->val;\n    calcu(t->right,a,i);\n    return calcu(t->left,a,i);\n}\n\nbool isSymmetric(struct TreeNode* root){\n    if(!root->left&&!root->right)\n        return true;\n    if(!root->left||!root->right)\n        return false;\n    int a1[1000]={0}, a2[1000]={0};\n    int count1=0, count2=0;\n    count1=calculation(root->left,a1,0);\n    count2=calcu(root->right,a2,0);\n    if(count1!=count2)\n        return false;\n    for(int i=0; i<count1; i++)\n    {\n        if(a1[i]!=a2[i])\n            return false;\n    }\n    return true;\n}\n\n", "Tag": "数据结构"}
{"Answer": "1.构建二叉树，通过parent判断是否为根节点；\r\n2.判断是否是二叉搜索树；\r\n3.求树高；\r\n```C++\r\n#include \r\n#include \r\n\r\nusing namespace std;\r\n\r\nstruct TreeNode\r\n{\r\n\tTreeNode* left;\r\n\tTreeNode* right;\r\n\tTreeNode* paraent;\r\n\tint _val;\r\n\tTreeNode(int val)\r\n\t\t:_val(val), left(NULL), right(NULL), paraent(NULL){}\r\n};\r\n\r\n// 判断root是否是搜索二叉树\r\n// 中序遍历时，前一个遍历的节点肯定小于当前遍历的节点\r\nTreeNode* pre = NULL;\r\nbool issearchTree(TreeNode* root)\r\n{\r\n\tif (root == NULL)\treturn true;\r\n\t\r\n\tbool left = issearchTree(root->left);\r\n\tif (pre != NULL && pre->_val > root->_val)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tpre = root;\r\n\tbool right = issearchTree(root->right);\r\n\r\n\treturn left && right;\r\n}\r\n\r\n// 求二叉树的高度\r\nint getHeight(TreeNode* root)\r\n{\r\n\tif (root == NULL)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tint left = getHeight(root->left);\r\n\tint right = getHeight(root->right);\r\n\treturn ((left > right)? left : right) + 1;\r\n}\r\n\r\nint main()\r\n{\r\n\tint n = 0;\r\n\t\r\n\tcin >> n;\r\n\tvector vec(n + 1);\r\n\tfor (int i = 1; i <= n; i++)\r\n\t{\r\n\t\tTreeNode* node = new TreeNode(i);\r\n\t\tvec[i] = node;\r\n\t}\r\n\r\n\t// 通过输入建树\r\n\tfor (int i = 1; i <= n; i++)\r\n\t{\r\n\t\tint l, o, r;\r\n\t\tcin >> l >> o >> r;\r\n\t\tif (l != -1)\r\n\t\t{\r\n\t\t\tvec[o]->left = vec[l];\r\n\t\t\tvec[l]->paraent = vec[o];\r\n\t\t}\r\n\t\tif (r != -1)\r\n\t\t{\r\n\t\t\tvec[o]->right = vec[r];\r\n\t\t\tvec[r]->paraent = vec[o];\r\n\t\t}\r\n\t}\r\n\r\n\t// 遍历查找根节点\r\n\tTreeNode* root = NULL;\r\n\tfor (int i = 1; i <= n; i++)\r\n\t{\r\n\t\tif (vec[i]->paraent == NULL)\r\n\t\t{\r\n\t\t\troot = vec[i];\r\n\t\t}\r\n\t}\r\n\r\n\tif (issearchTree(root) == true)\r\n\t{\r\n\t\tcout << getHeight(root) << endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout << -1 << endl;\r\n\t}\r\n\treturn 0;\r\n}\r\n```", "Knowledge_Point": "二叉树", "Question": "d 是一个公认的美丽校园。一天，fd 来了一群地鼠,编号为 1 到 n，他们希望 在这里定居。现在先由第一只地鼠往下打一个单位的距离，并且在那里安家。对 于每一个已经安家的地鼠，如果他左下或右下没有邻居，那还没安家的地鼠就可 以在他的左下或者右下安家。地鼠们已经建完所有的窝了，他们评价这些窝合格 的标准是它们能不能形成一棵二叉搜索树。现在需要你帮助他们评估一下他们的 窝挖的是否合格。\n\n★数据输入\n\n第 1 行一个整数 n，表示地鼠总共 n 只。接下来一共 n 行，每一行三个数：l,o,r，其中 l 表示编号为 o 的地鼠的左邻居的编号，r 表示的是编号为 o 的右邻居的编号，如果没有左 邻居或右邻居，则 l 或 r 为-1。1<=n<=10000。\n\n★数据输出\n\n输出一行，如果如果他们的窝合格，则输出安居在最深的窝的地鼠离地面的距离，如果不合格，则输出-1。\n\n输入示例\n5\n-1 1 -1\n1 2 3\n-1 3 -1\n2 4 5\n-1 5 -1\n输出示例\n3", "Tag": "数据结构"}
{"Answer": "这是因为力扣的答题格式，系统都是以类的方法返回值来判断是否通过，并不打印出来，所以自己运行的话在控制台看不到。", "Knowledge_Point": "二叉树", "Question": "在csdn上找了一些博主代码，运行出来都是空白，什么意思？我想要输入数据来验证结果咋搞？附上我的问题截图。\n", "Tag": "数据结构"}
{"Answer": "你用指针作为参数，在函数内是没法实现外部传入指针地址的修改的。改为指针的指针吧\nvoid creat(bitree *T)\n{\nchar x;\nx=getchar();\nif(x=='#')\n{\n(*T)=NULL;\n}\nelse\n{\n(*T)=(bitnode *)malloc(sizeof(bitnode));\n(*T)->data=x;\n(*T)->lchild=NULL;\n(*T)->rchild=NULL;\ncreat(&(T->lchild));\ncreat(&(T->rchild));\n}\n}\n\n", "Knowledge_Point": "二叉树", "Question": "#include#include#define max 10typedef struct bitnode{    char data;    struct bitnode *lchild,*rchild;}bitnode,*bitree;\nvoid creat(bitree T){    char x;    x=getchar();    if(x=='#')    {        T=NULL;    }    else    {        T=(bitnode *)malloc(sizeof(bitnode));        T->data=x;        T->lchild=NULL;        T->rchild=NULL;        creat(T->lchild);        creat(T->rchild);    }}void preorder(bitree T){    if(T!=NULL)    {        printf(\"%c\\n\",T->data);        preorder(T->lchild);        preorder(T->rchild);    }}\nint main(){    bitree T=NULL;    creat(T);    preorder(T);}", "Tag": "数据结构"}
{"Answer": " 第70行push(s,p);种p是BiTree类型，你应该传参的是p.data\n\n ", "Knowledge_Point": "二叉树", "Question": "源代码 及错误如下\n\n\n#include\n#include\ntypedef int TElemType ;\n#define ERROR 0;\n#define STACK_INIT_SIZE 100\n#define STACKINCREMENT 10\n#define OK 1\n#define Status int\n//定义栈 \ntypedef struct {\nint *base;\nint *top;\nint stacksize;\n}SqStack;\n//二叉链表存储表示 \ntypedef struct BiTNode{\n\tint data;\n\tstruct BiTNode *lchild,*rchild;//左右孩子指针 \n}BiTNode,*BiTree;\n//构造空栈\nint initstack (SqStack &s){\ns.base=(int *)malloc(STACK_INIT_SIZE*sizeof(int));\nif(!s.base)\nexit(0);\ns.top=s.base;\ns.stacksize=STACK_INIT_SIZE;\nreturn 0;}\n//判断是否为空\nStatus StackEmpty(SqStack S){\n    if(S.top==S.base) return 1;\n    return 0;}\n//先序遍历创建二叉树 \nBiTree creatbitree(){\n\tBiTree T;\n\tTElemType ch;\n\tscanf(\"%c\",&ch);\n\tif(ch=='#') T=NULL;//#代表空格字符 \n\telse{\n\t\tT=(BiTNode*)malloc(sizeof(BiTNode));\n\t\tT->data=ch;//生成根结点 \n\t\tT->lchild=creatbitree();//生成左子树 \n\t\tT->rchild=creatbitree();//生成右子树 \n\t}\n\treturn T; \t}\n//入栈 \nStatus push(SqStack &s, int &e) \n{\nif((s.top-s.base)>=s.stacksize){\ns.base=(int*)realloc(s.base,(s.stacksize+STACKINCREMENT)*sizeof(int));\n\t\t  if(!(s.base))\n\t\t exit(1);\n\t\ts.top=s.base+s.stacksize;\n\t\ts.stacksize+=STACKINCREMENT;\n\t   }\n\t   *s.top++=e;\n\t   return 0; }\n//出栈 \nStatus pop(SqStack &s,int &e){\n\t  if(s.top==s.base)\n\t  return 1;\n\t  e=*--s.top;\n\t  return 0;}\n//中序非递归遍历的\nStatus inorder(BiTree T,Status (*visit)(TElemType)){\n\tSqStack s;\n\tinitstack(s);\n\tBiTree p=T;\n\twhile(p||!StackEmpty(s)){\n\tif(p){\n\t\tpush(s,p);\n\t\tp=p->lchild;}\n\telse{\n\t\tpop(s,p);\n\t\tif(!visit(p->data)) return 0;\n\t\tp=p->rchild;}}\nreturn OK;} \nStatus PrintElement(TElemType e){\n    printf(\"%d\",e);                             \n    return 0;}\nint main(){\n\tBiTree T;\n\tprintf(\"请按照先序遍历输入二叉树(#代表空子树)：\\n\");\n\tT=creatbitree();\n\tprintf(\"二叉树创建成功！\\n\"); \n\tprintf(\"\\n中序非递归遍历:\\n\");\n\tinorder(T,PrintElement);\n\treturn 0;}\n\n", "Tag": "数据结构"}
{"Answer": "scanf_s在读取字符的时候需要传入一个和参数有关的大小值，避免引用到不存在的元素.写成下面这样就行\n\nscanf_s(\"%c %d %d\", &op, 1, &x, &y);", "Knowledge_Point": "并查集", "Question": "题目描述\n一共有n个数，编号是1~n，最开始每个数各自在一个集合中。\n\n现在要进行m个操作，操作共有两种：\n\n“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；\n“Q a b”，询问编号为a和b的两个数是否在同\n\n一个集合中；\n输入格式\n第一行输入整数n和m。\n\n接下来m行，每行包含一个操作指令，指令为“M a b”或“Q a b”中的一种。\n\n输出格式\n对于每个询问指令”Q a b”，都要输出一个结果，如果a和b在同一集合内，则输出“Yes”，否则输出“No”。\n\n每个结果占一行。\n\n数据范围\n1≤n,m≤105\n\n代码如下\n\n\n​\n#include \n#include \n\nint find(int x);\nvoid match(int x, int y);\nvoid question(int x, int y);\nint pre[5];\nint main()\n{\n\t\n\tint i;\n\tint n = 5;\n\tint m = 5;\n\tint x, y;\n\tfor (i = 1; i <= n; i++) {\n\t\tpre[i] = i;\n\t}\n\twhile (m--) {\n\t\tchar op;\n\t\tscanf_s(\"%c %d %d\", &op, &x, &y);\n\t\tif (op == 'M') {\n\t\t\tmatch(x, y);\n\t\t}\n\t\tif (op == 'Q') {\n\t\t\tquestion(x, y);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint find(int x)\n{\n\tif (pre[x] != x) {\n\t\tint t = find(pre[x]);\n\t\tpre[x] = t;\n\t}\n\treturn pre[x];\n}\n\nvoid match(int x, int y)\n{\n\tif (pre[x] != y) {\n\t\tpre[x] = y;\n\t}\n}\n\nvoid question(int x, int y)\n{\n\tint fx = find(x);\n\tint fy = find(y);\n\tif (fx == fy) {\n\t\tprintf(\"Yes\");\n\t}\n\telse {\n\t\tprintf(\"No\");\n\t}\n}\n\n​\n\n问题如下\n\n请问各位大佬，这里为什么出现访问异常了？", "Tag": "数据结构"}
{"Answer": "如果用元素而不用指针，可能会因为内存拷贝导致链表失效。就是说，放入链表的元素可能只是你原本要放进链表的元素的一个复制品，他们的值相同，但是在内存中的位置不同。用指针就不会存在这个问题，哪怕是复制，复制的还是地址，指向的还是同一个元素。如有帮助，请采纳一下。\n链表的结构参考下图：\n\n看的代码的话先找个单向链表例子看。", "Knowledge_Point": "并查集", "Question": "我们可以直接类似并查集一样 这个元素存了下一个元素的信息 并标个号\n\n还有 链表的头指针 头结点这么区分 各位大佬可以写个码打个注释可以吗 今天下午整个人懵了\n\n ", "Tag": "数据结构"}
{"Answer": "作为属性,分页应该不行.\r\n\r\n排序可以:  @OrderBy", "Knowledge_Point": "并查集", "Question": "\n \n 在Hibernate中通过关联映射, 例如OneToMany等取得一个实体的属性结果集时有没有办法对结果进行排序或者分页. 直接通过HQL或者SQL可以直接利用HQL\\SQL进行排序分页等操作, 但是如果这类关联映射不支持这些操作那么关联映射的作用感觉也不是很大了. 例如一个User实体有一个Set属性, 即一个用户有N多操作日志,OneToMany的, 那么如果通过User.getLogs()取得的结果集将是全部查询···\n", "Tag": "数据结构"}
{"Answer": "链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\r\n散列表(Hash table,也叫哈希表),是根据关键码值(Key value)而直接进行访问的数据结构。\r\n数组是一种物理存储单元上连续、顺序的存储结构，可以通过下标访问数组元素。\r\n\r\n最好\r\n百度一下。", "Knowledge_Point": "散列表", "Question": "链表与散列表和数组的区别？", "Tag": "数据结构"}
{"Answer": "模板特化了解下，类似重载。写两份，任意类型返回0。int类型返回传入参数", "Knowledge_Point": "散列表", "Question": "想完成这样一个 功能\n\ntemplate\nint func(const K& k){\n    if(typeid(k) == typeid(int)){\n        return k;\n    }\n\n    return 0;\n\n    // 如果传进来是 int 则返回 它本身  ，其他类型 都返回0；\n}\n\n\nint main(){\n    func(\"ddd\");\n}\n\n就会报错\ncannot convert 'const std::__cxx11::basic_string' to 'int' in return\n\n怎么解决", "Tag": "数据结构"}
{"Answer": "这两个都是正确的，以二叉树为例，dfs的思想是沿着一个子树一直找，找不到了就回溯，再换个子树继续找。当左右子树都找完了，就回到上一层，再在上一层换个子树。没有规定，先找哪个子树。所以上面两个答案都是对的", "Knowledge_Point": "图", "Question": "①和② 两个深度优先遍历的顺序 都是正确 DFS吗？这块内容突然混乱了。还是说遇到岔路口时候必须走长的那条？", "Tag": "数据结构"}
{"Answer": "```\r\n #include  \r\nusing namespace std;\r\nint add(int x,int y){\r\n\treturn x+y;\r\n}\r\nint sub(int x,int y){\r\n\treturn x-y;\r\n}\r\nint mul(int x,int y){\r\n\treturn x*y;\r\n}\r\nint div(int x,int y){\r\n\treturn x/y;\r\n}\r\nint main(){\r\n\tint (*pf[4])(int, int) = { add, sub, mul, div };\r\n\twhile(true){\r\n\t\tcout<<\"0. add\"<>opeNum;\r\n\t\tif(opeNum==4){\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tcout<<\"Input 2 operand :\";\r\n\t\tint a,b;\r\n\t\tcin>>a>>b;\r\n\t\tcout<<\"Result = \"<<pf[opeNum](a,b)<<endl;\r\n\t}\r\n\t\r\n\r\n}\r\n```", "Knowledge_Point": "图", "Question": "实现计算器的加法、减法、乘法和除法。使用一个命令行参数为您的选择，和2个数字。你使用下面的数组来赋值操作符函数。\n\nint add(int x, int y);\nint sub(int x, int y);\nint mul(int x, int y);\nint div(int x, int y);\nint (*pf[4])(int, int) = { add, sub, mul, div };\n\n\n\n数据结构：函数指针数组\n输入：选择运营商的数量（1，2，3，或4），\n操作数的2个整数\n输出：操作结果", "Tag": "数据结构"}
{"Answer": "```c\r\nList initList(){\r\n    List L;\r\n    L = (List)malloc(sizeof(struct LNode));\r\n    L->last = -1;\r\n    printf(\"初始化成功\\n\");\r\n    return 1;\r\n}\r\n```\r\n这个定义错了\r\n你的返回值是1  ，1  怎么是List类型呢\r\n另外如果你使用这个返回值List作为初始化的顺序表，那么在main函数中使用的时候，使用方法错了哦\r\n```c\r\nvoid main(){\r\n    List L;\r\n   ** initList(L);\r\n**    createList(L);****\r\n}\r\n```\r\n改成这个\r\nList L = initList()", "Knowledge_Point": "图", "Question": "如下代码所示：\n\n #include \n#include \n#define MAXSIZE 100\n\ntypedef int Position;\ntypedef struct LNode *List;\nstruct LNode{\n    int Data[MAXSIZE];\n    Position last;\n};\n\nList initList(){\n    List L;\n    L = (List)malloc(sizeof(struct LNode));\n    L->last = -1;\n    printf(\"初始化成功\\n\");\n    return 1;\n}\n\nList createList(List L){\n    int n,i=1;\n    printf(\"请输入创建表的元素个数：\");\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        printf(\"\\n请输入第%d个元素：\",i);\n        scanf(\"%d\",&L->Data[i]);\n    }\n    for(i=1;i<=n;i++){\n        printf(\"创建的表为：\\n\");\n        printf(\"%d\",L->Data[i]);\n    }\n}\n\nvoid main(){\n    List L;\n    initList(L);\n    createList(L);\n}\n\n\n在VC++ 6.0每次运行，一输入数据，就提示关闭程序。\n小白刚刚弄数据结构，请大家帮忙看看哪里有问题，谢谢！", "Tag": "数据结构"}
{"Answer": "1、最大传输单元（Maximum Transmission Unit，MTU）。 以太网帧中的数据长度规定最小46 字节，最大1500 字节，MTU 指数据帧中有效载荷的最大长度，不包括帧首部的长度。\n\n分片结构示意图：2、子网地址：168.12.24.0/21；子网地址占5为，主机占11位；可用主机数量2046个（256*80-2）", "Knowledge_Point": "图", "Question": "（1）一个IP数据报长为2000字节，报头长32字节，现要在MTU为764字节的物理网络中传输，如何分片？画出各片结构示意图。（2）某主机IP地址为168.12.27.5，子网掩码为255.255.248.0，求①子网地址（用点分十进制表示）；②子网地址和主机地址各占多少位？③主机所在网络最多能容纳的主机数为多少（设子网地址和主机地址的全0、全1均不用）？\n如题，期末题目不会做，挂过一次科了，求大佬救命~~~~！！！！给大佬磕头了！！", "Tag": "数据结构"}
{"Answer": "用id就可以 书架ID  图书ID 关联书架\n主表书架  书架ID 存放图书类型 书架大小 等等\n子表图书 图书ID 书架ID  图书的各类属性 价格 图书名称 等\n图书的名称虽然一样。但是你给他身份证ID了，就唯一了呀。\n你的书籍信息表应该没把书分开来。直接写了数量对不对？那这样肯定分不出书来。再建一张子表，来存每一本书。", "Knowledge_Point": "图", "Question": "大神们帮帮忙，现在有两个表，书籍信息表和书架表，想将这两个表关联起来，书籍信息表里面有书架编号的字段，同一本书在书籍信息表中只有一条数据，但是有可能书的数量比较多，会放在书架编号不同的两个或多个书架上，我需要怎么设计才能将这两个表关联起来，求助！", "Tag": "数据结构"}
{"Answer": "修改如下： \n\n#include <iostream>\n#include <cstring>//将一些隐藏变量编入命名空间,修正一些C++编译器认为Bug的代码\nusing namespace std;\nconst int M = 50;//定义最大数据存储数量为1000\n//图书信息的结构体\ntypedef struct {\n\tchar no[13]; //13位书号\n\tchar name[20]; //书名\n\tdouble price; //价格\n}Book;\n//定义数据结构——链表，由于图书信息经常需要查找，在顺序表和链表中，链表更适合存储经常需要查找的数据\ntypedef struct LNode {\n\tBook data; //数据域\n\tstruct LNode* next; //指针域\n}LNode, * LinkList;\nLNode* first; //定义链表头结点\n//逐个显示图书表中所有图书的相关信息\nvoid bookOut() {\n\tcout << \"管理系统中全部图书信息如下：\" << endl;\n\tLNode* p = first->next;\n\twhile (p != NULL) {\n\t\tcout << p->data.no << \" \" << p->data.name << \" \" << p->data.price << endl;\n\t\tp = p->next;\n\t}\n}\nint main() {\n\tBook book[M];//定义图书存储空间\n\tint count = 0, n;\n\tbool tag = true;\n\twhile (tag) {\n\t\tcout << \"请输入初始书本数量（0~50）：\" << endl;\n\t\tcin >> n;//初始书本数量\n\t\tif (n >= 0 && n <= M) {\n\t\t\twhile (count < n) {\n\t\t\t\tcout << \"请输入书号，书名和价格(中间以空格符隔开)\" << endl;\n\t\t\t\tcin >> book[count].no;\n\t\t\t\tcin >> book[count].name;\n\t\t\t\tcin >> book[count].price;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ttag = false;\n\t\t}\n\t\telse { cout << \"输入不正确\" << endl; }\n\t}\n\t//构造后接方式单链表\n\tfirst = new LNode();\n\tfirst->next = NULL;\n\tLNode* r = first, * s;\n\tfor (int i = 0; i < n; i++)   //此处 M 改为 n 有几本初始化基本，不要一下初始化完全。\n    { //r为尾指针    \n\t\ts = new LNode();\n\t\ts->data = book[i];\n\t\tr->next = s;\n\t\tr = s;\n\t}\n\tr->next = NULL;\n\tbookOut();\n\n    //此时退出申请的空间还未释放，最好去delete掉\n\treturn 0;\n}\n ", "Knowledge_Point": "图", "Question": "\n#include \n#include //将一些隐藏变量编入命名空间,修正一些C++编译器认为Bug的代码\nusing namespace std;\n\nconst int M = 50;//定义最大数据存储数量为1000\n\n//图书信息的结构体\ntypedef struct {\n\tchar no[13]; //13位书号\n\tchar name[20]; //书名\n\tdouble price; //价格\n}Book;\n\n//定义数据结构——链表，由于图书信息经常需要查找，在顺序表和链表中，链表更适合存储经常需要查找的数据\ntypedef struct LNode {\n\tBook data; //数据域\n\tstruct LNode* next; //指针域\n}LNode, * LinkList;\n\nLNode* first; //定义链表头结点\n\n//逐个显示图书表中所有图书的相关信息\nvoid bookOut() {\n\tcout << \"管理系统中全部图书信息如下：\" << endl;\n\tLNode* p = first->next;\n\twhile (p) {\n\t\tcout << p->data.no << \" \" << p->data.name << \" \" << p->data.price << endl;\n\t    p = p->next;\n\t}\n}\nint main() {\n\tBook book[M];//定义图书存储空间\n\tint count = 0, n;\n\tbool tag = true;\n\twhile (tag) {\n\t\tcout << \"请输入初始书本数量（0~50）：\" << endl;\n\t\tcin >> n;//初始书本数量\n\t\tif (n >= 0 && n <= M) {\n\t\t\twhile (count < n) {\n\t\t\t\tcout << \"请输入书号，书名和价格(中间以空格符隔开)\" << endl;\n\t\t\t\tcin >> book[count].no;\n\t\t\t\tcin >> book[count].name;\n\t\t\t\tcin >> book[count].price;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ttag = false;\n\t\t}\n\t\telse { cout << \"输入不正确\" << endl; }\n\t}\n\t//构造后接方式单链表\n\tfirst = new LNode();\n\tfirst->next = NULL;\n\tLNode* r = first, * s;\n\tfor (int i = 0; i < M; i++) { //r为尾指针\n\t\ts = new LNode();\n\t\ts->data = book[i];\n\t\t//s->next = NULL;\n\t\tr->next = s;\n\t\tr = s;\n\t}\n\tr->next = NULL;\n\tbookOut();\n}", "Tag": "数据结构"}
{"Answer": "import java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport org.json.JSONArray;\r\nimport org.json.JSONObject;\r\n\r\npublic class ChinaCity {\r\n\r\n\t/**\r\n\t * 读取文件内容\r\n\t * @param filePath 文件路径\r\n\t * @return 文件字符串信息\r\n\t */\r\n\tpublic static String readFile(String filePath) {\r\n\r\n\t\tFile file = new File(filePath);\r\n\t\tif (!file.exists()) {\r\n\t\t\tSystem.out.println(\"文件不存在\");\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t//文件读取\r\n\t\tBufferedReader br = null;\r\n\t\tStringBuilder sb = null;\r\n\t\ttry {\r\n\t\t\tbr = new BufferedReader(new FileReader(file));\r\n\t\t\tsb = new StringBuilder();\r\n\t\t\tString line = \"\";\r\n\t\t\twhile ((line = br.readLine()) != null) {\r\n\t\t\t\tsb.append(line);\r\n\t\t\t}\r\n\t\t} catch (FileNotFoundException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\tif (br != null) {\r\n\t\t\t\t\tbr.close();\r\n\t\t\t\t}\r\n\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\te.printStackTrace();\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sb != null ? sb.toString() : null;\r\n\t}\r\n\t/**\r\n\t * 解析Json数据\r\n\t * @param strJson\r\n\t */\r\n\tpublic static List parseJson(String strJson){\r\n\t\tList cities = new ArrayList();\r\n\t\tJSONArray jsonArray = new JSONArray(strJson);\r\n\t\tfor (int i = 0; i < jsonArray.length(); i++) {\r\n\t\t\tJSONObject json = jsonArray.getJSONObject(i);\r\n\t\t\tString cityName = json.getString(\"name\");\r\n\t\t\tcities.add(new City(cityName, parseJsonToCity(json.getJSONArray(\"city\"))));\r\n\t\t}\r\n\t\treturn cities;\r\n\t}\r\n\t\r\n\t/**\r\n\t * 解析城市\r\n\t * @param jsonArray\r\n\t * @return\r\n\t */\r\n\tpublic static List parseJsonToCity(JSONArray jsonArray){\r\n\t\tList nextCities = new ArrayList();\r\n\t\tfor (int i = 0; i < jsonArray.length(); i++) {\r\n\t\t\tJSONObject json = jsonArray.getJSONObject(i);\r\n\t\t\tString cityName = json.getString(\"name\");\r\n\t\t\tnextCities.add(new City(cityName,ParseJsonToArea(json.getJSONArray(\"area\"))));\r\n\t\t}\r\n\t\treturn nextCities;\r\n\t}\r\n\t/**\r\n\t * 解析地区\r\n\t * @param jsonArray\r\n\t * @return\r\n\t */\r\n\tpublic static List ParseJsonToArea(JSONArray jsonArray){\r\n\t\tList areas = new ArrayList();\r\n\t\tfor (int i = 0; i < jsonArray.length(); i++) {\r\n\t\t\tareas.add(new City(jsonArray.getString(i), null));\r\n\t\t}\r\n\t\treturn areas;\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tString filePath = \"C:\\\\Users\\\\Liheng\\\\Desktop\\\\ChinaCity.txt\";\r\n\t\tString json = readFile(filePath);\r\n\t\tList cities = parseJson(json);\r\n\t\tfor (City city : cities) {\r\n\t\t\tcity.print();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n这个是读取并解析出来的数据，存入数据库，应该不难，想想很容易就不上代码了。\r\n\r\n\r\n\r\n解析出来的部分结果：\r\n北京:\r\n\t北京:\r\n\t东城区\r\n\t西城区\r\n\t崇文区\r\n\t宣武区\r\n\t朝阳区\r\n\t丰台区\r\n\t石景山区\r\n\t海淀区\r\n\t门头沟区\r\n\t房山区\r\n\t通州区\r\n\t顺义区\r\n\t昌平区\r\n\t大兴区\r\n\t平谷区\r\n\t怀柔区\r\n\t密云县\r\n\t延庆县\r\n\r\n\r\n天津:\r\n\t天津:\r\n\t和平区\r\n\t河东区\r\n\t河西区\r\n\t南开区\r\n\t河北区\r\n\t红桥区\r\n\t塘沽区\r\n\t汉沽区\r\n\t大港区\r\n\t东丽区\r\n\t西青区\r\n\t津南区\r\n\t北辰区\r\n\t武清区\r\n\t宝坻区\r\n\t宁河县\r\n\t静海县\r\n\t蓟  县", "Knowledge_Point": "图", "Question": "java 如何把硬盘里面的中国省市区的json文件，解析出来，并存入到mysql数据库中的对应省市区三张表里面，希望哪位大神可以代码实现一下，给我看看，网上复制的地址就算了，看不明白（要包括电脑文件读取写法，和数据库的存储）\n\n数据来源：http://blog.sina.com.cn/s/blog_95153c710102viow.html\n\n", "Tag": "数据结构"}
{"Answer": "编、章、节这些没有父类id吗？？像现在这样只有label和target吗？那我怎么区分谁是谁的children", "Knowledge_Point": "图", "Question": "最近有一个需求，将这样子的没有层级关系的平铺的目录，要处理成树状结构的数据，如下图：平铺目录：需要处理成的目录：\n目前的数据结构是这样子：   \n let dataArr = [\n      { label: \"第一编\", target: \"anchor_zhang0\" },\n      { label: \"第一分编\", target: \"anchor_zhang1\" },\n      { label: \"第一章\", target: \"anchor_zhang2\" },\n      { label: \"第一节\", target: \"anchor_jie0\" },\n      { label: \"第二节\", target: \"anchor_jie2\" },\n      { label: \"第二分编\", target: \"anchor_zhang3\" },\n      { label: \"第二编\", target: \"anchor_zhang4\" },\n      ...\n    ];\n\n目录的顺序是编、分编、章、节，但每个文章不一定都有这些目录，比如说可以是只有章、节，或者编、章、节，等等情况，但是节上一层肯定是章，分编上一层肯定是编，困惑很久都没能解决，有大l佬指点一下思路吗，十分感谢", "Tag": "数据结构"}
{"Answer": "A -> C -> D -> B -> NULL\r\nB -> A -> D -> E -> NULL\r\nC -> A -> F -> NULL\r\nD -> A -> B -> G -> F -> NULL\r\nE -> B -> G -> NULL\r\nF -> C -> D -> G -> NULL\r\nG -> F -> D -> E -> NULL", "Knowledge_Point": "图", "Question": "\n题目见附件，请大神，帮忙解答下，多谢\n\n这个是我画的，到底对不对啊，能帮忙看看不：", "Tag": "数据结构"}
{"Answer": "数值型,浮点型做散点图都可以, 给你提供几段代码, 分别是用matplotlib、seaborn和pandas-bokeh作图,  你参考下, 看哪个和你的数据结构相似,  你可以修改下:\n如果是一下子出很多图(多子图的显示), 需要进一步修改.\nmatplotlib\n\nimport numpy as np\nimport pandas as pd\nimport faker  # 生成模拟数据\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')  # 不提示警告\n\nplt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签\nplt.rcParams['axes.unicode_minus']=False #用来正常显示负号\nf = faker.Faker(locale='zh-CN')\n\n# 创建数据\ndata = pd.DataFrame()\nfor i in range(500):\n    datai = pd.DataFrame({'姓名':f.name(),\n                          '销售数量':f.random_int(),\n                          '金额':f.random_int(),\n                          '利润':f.random_int(),},\n                         index=[i])      # 必须有\n    data = data.append(datai)\ndata.head()\n\n#方法一\nplt.scatter(x=data['销售数量'][:200],y=data['金额'][:200],s=data['利润'][:200]/100,c='red',alpha=0.5)\nplt.scatter(x=data['销售数量'][200:],y=data['金额'][200:],s=data['利润'][200:]/100,c='blue',alpha=0.5)\nplt.xlabel('销售数量')\nplt.ylabel('销售金额')\n\n方法二:\ndata.plot.scatter(x='销售数量',y='金额',c='利润')\n\nseaborn\n\nimport seaborn as sns\nsns.set()\n\n# 读取数据\nplanets = pd.read_csv('C:/Users/yyz/Desktop/python数据分析基础/data/seaborn-data-master/planets.csv')\nplanets.head()\n\n# 创建图表\nsns.scatterplot(x=\"distance\", # x轴\n                y=\"orbital_period\",# y轴\n                hue=\"year\",   # 颜色分类\n                size=\"mass\",   # 大小分类\n                palette='Spectral_r', # 调色盘\n                sizes=(10, 200),      # 大小区间\n                data=planets)\n\npandas-bokeh\n\n# 导入工具包\nimport pandas_bokeh\nimport numpy as np\nimport pandas as pd\n\n# 作图数据\ndf = pd.read_csv('C:/Users/yyz/Desktop/pandas-bokeh/data/iris.csv')\ndf.columns = ['花萼长度','花萼宽度','花瓣长度','花瓣宽度','物种']\ndf['物种'].replace(['setosa','versicolor','virginica'],['山鸢尾','杂色鸢尾','维吉尼亚鸢尾'],inplace=True)\ndf.head()\n\n# 修改其中的一个数值,为了查看散点大小\ndf.loc[13, \"花萼长度\"] = 15\n\n#散点图\np_scatter = df.plot_bokeh.scatter(\n    x=\"花瓣长度\",\n    y=\"花萼宽度\",\n    size=\"花萼长度\",# 大小\n    category=\"物种\",  # 作为分类的字段列\n    title=\"鸢尾花卉数据集可视化\")  \n\n ", "Knowledge_Point": "图", "Question": "如题，有多个变量的数据，想要在一张图上看它们各自的分布情况，有大佬可以指导一下应该怎么做吗？\n\n我的数据结构是这样的，不同组织的不同基因都有一个score。\n\n \n\nGeneID                               Adrenal.gland    Cerebellum     Brain      Fetal.brain Fetal.liver\n\nENSG00000000419   \n\nENSG00000000457\n\nENSG00000000460\n\nENSG00000000938    \n\nENSG00000000971    ", "Tag": "数据结构"}
{"Answer": "df = pd.read_csv('pd.csv', usecols=['stat'])\nprint(df)\ni = 0\nfor d in df['stat']:\n    print(eval(d)['view'])\n    df['stat'][i] = eval(d)['view']\n    i += 1\nprint(df)\ndf.to_csv('view.csv', index=False)\n", "Knowledge_Point": "图", "Question": "如题,源代码为；df = pd.read_csv('每周必看，清洗后.csv', usecols=['stat'])print(df)for d in df['stat']:    print(eval(d)['view'])print(df)的结果如图： print(eval(d)['view'])的结果如图二现在想把 print(eval(d)['view'])的结果导出至csv中，应该怎么做？\n", "Tag": "数据结构"}
{"Answer": "multi是指针类型\r\n比如 声明一个指针对象可以2种方式\r\n1. node *p1 = new  node\r\n2.  multi  p2 = new node\r\n\r\np1 和  p2均为对象指针", "Knowledge_Point": "图", "Question": "\n\n之前学的都是c++版的数据结构，今天接触c语言数据结构，就是那个typedef后面那个\n\n*multi是什么意思？是类似于typedef node *multi,但是声明multi类型的是什么类型；\n\n\n\n刚开始接触c语言，还望大神指教", "Tag": "数据结构"}
{"Answer": "mysql的sql语句select * from user  where username = 'zeng'，这是查询一条数据，但他其实还是会转成select id，username,userPWD,tel,mail,name fromfrom user  where username = 'zeng',也就是说你只想要一个字段的话可以写成select name fromfrom user  where username = 'zeng'。", "Knowledge_Point": "图", "Question": "\n\n这是我的table结构，一共6列，主键是id，table名是user，现在想通过查找username来获取指定username的name值，并存入session中，用SELECT * FROM user where 语句可以获取一行值，如果我只要取name列的值，代码应该怎么写呢？比如我想取username为zeng的用户的name值，应当怎么写？\n之前遇到个问题卡了很久，提问求个例子之后大家都只说个大概思路，无奈只好把问题拆分开来问，希望这次能得到较为详细的解答……", "Tag": "数据结构"}
{"Answer": "一个人搞确实有难度，建议和老师同学多交流，参加一些相关的比赛，积累经验", "Knowledge_Point": "图", "Question": "目前学完了c，数据结构与算法学到了图的最小生成树，力扣也刷了五六十道题了，听说做项目提升快，但现在还没见过项目，也不知道咋找项目，有大佬能指导下吗😂", "Tag": "数据结构"}
{"Answer": "INNER JOIN 改为left join 就行了", "Knowledge_Point": "图", "Question": "假设我有两个表，table_neo 和table_two\n\ntable_neo结构\n\n\n\ntable_neo的数据\n\ntable_two的结构\n\ntable_two的数据\n\n\n\n我的查询语句是这样写的\n\nSELECT\n    table_one.username \nFROM\n    table_one\n    INNER JOIN table_two ON table_one.id=table_two.table_one_id\nWHERE\n    table_one.lastname LIKE \"%张%\"\n    OR table_one.nickname LIKE \"%张%\"\n    OR table_one.username LIKE \"%张%\"\n    OR table_two.lastname LIKE \"%张%\"\n    OR  table_two.nickname LIKE \"%张%\"\n    OR  table_two.username LIKE \"%张%\"\n\n\n这样查出来是空的  原因是因为table_two里面没有与table_neo相关联的数据\n我想要的效果是  table_two里面的数据如果有的话就匹配  如果没有的话就忽略，把table_neo里面匹配到的数据查出来\n\n这种效果是否能实现  如果能实现又如何用sqlalchemy来写", "Tag": "数据结构"}
{"Answer": "a  b  c  d  e  f  \n\na  0  1  1  0  1  0b  1  0  0  0  1  0c  1  0  0  0  0  1d  1  1  0  1  0  0e  1  1  0  1  0  0f   0  0  1  1  0  0abedfc (A)", "Knowledge_Point": "图", "Question": "设连通图G中的边集E={(a，b)，(a，e)，(a，c)，(b，e)，(e，d)，(d，f)，(f，c)}，则从顶点a出发可以得到一种深度优先遍历的顶点序列为（ ）。(A) abedfc(B) acfebd(C) aebdfc(D) aedfcb为什么A不对？？为什么选B？？", "Tag": "数据结构"}
{"Answer": "\n-- 带双引号 “123”    select json_extract(字段名,'$.id')\nselect json_extract('{\\\"aa\\\":\\\"self\\\",\\\"id\\\":\\\"123\\\"}','$.id') id; \n-- 不带双引号 123    select SUBSTRING(字段名,'$.id'),2,LENGTH(字段名,'$.id'))-2)\nselect SUBSTRING(json_extract('{\\\"aa\\\":\\\"self\\\",\\\"id\\\":\\\"123\\\"}','$.id'),2,LENGTH(json_extract('{\\\"aa\\\":\\\"self\\\",\\\"id\\\":\\\"123\\\"}','$.id'))-2) id;\n", "Knowledge_Point": "图", "Question": "要截取的数字不一定都是5位数，如图两个/\"需要的数据\"/里的内容，用SUBSTRING截取不行！\n", "Tag": "数据结构"}
{"Answer": "遍历即可实现\n\n#include<stdio.h>\nint main()\n{\n    int i,j,a[5][7]={1,2,3,4,5,6,7,\n    1,2,3,4,5,6,7,\n    1,2,3,4,5,6,7,\n    1,2,3,4,5,-2,7,\n    1,2,3,4,5,6,7};\n    for(i=0;i<5;i++){\n        for(j=0;j<7;j++){\n            if(a[i][j]<0)\n                printf(\"%d\\n\",a[i][j]);\n                printf(\"下标是\");\n                printf(\"%d %d\",i,j);\n                break;\n        }\n    }\n\n    return 0;\n}\n\n ", "Knowledge_Point": "查找", "Question": "编写程序，在5行7列的二维数组中查找第一次出现的负数。", "Tag": "数据结构"}
{"Answer": "改动处见注释，供参考：\n#include<stdio.h>\n#define N 11     //修改\nstruct book{\n    char name[80];\n    double price;\n};\nint main()\n{\n    int i,n,j;\n    double max,min;\n    char a,b;\n    struct book s[N]; //s[10] 修改\n    printf(\"Input n:\");\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)\n    {\n        printf(\"Input the name,price of the %d book:\",i+1);\n        scanf(\" %s%lf\",s[i].name,&s[i].price);\n    }\n    max=s[0].price,min=s[0].price;\n                       //a=s[0].name,b=s[0].name;修改\n    for(i=0;i<n;i++)\n    {\n        if(max < s[i].price)\n                      //a=s[i].name; 修改\n            max=s[i].price;\n                      //}\n                      //   for(j=0;j<n;j++)\n                      //   {\n        if(min > s[i].price)\n                      //b=s[j].name;\n            min=s[i].price;\n    }\n    for (i=0;i<n;i++)\n    {\n        if (s[i].price == max)\n            printf(\"The book with the max price:%s,%.1f\\n\",s[i].name,s[i].price);\n            //printf(\"The book with the max price:%s,%.1f\\n\",a,max);修改\n        if (s[i].price == min)\n            printf(\"The book with the min price:%s,%.1f\\n\",s[i].name,s[i].price);\n            //printf(\"The book with the min price:%s,%.1f\\n\",b,min);修改\n    }\n    return 0;\n}\n\n", "Knowledge_Point": "查找", "Question": "#include\nstruct book{\nchar name[80];\ndouble price;\n};\nint main()\n{\n    int i,n,j;\n    double max,min;\n    char a,b;\n    struct book s[10];\n    printf(\"Input n:\");\n    scanf(\"%d\",&n);\n    for(i=0;is[j].price)\n            b=s[j].name;\n           min=s[j].price;\n       }\n       printf(\"The book with the max price:%s,%.1f\\n\",a,max);\n       printf(\"The book with the min price:%s,%.1f\\n\",b,min);\n    return 0;\n}\n\n为什么无法输出结果", "Tag": "数据结构"}
{"Answer": "\nvar a = \"s f g gghdf fhs\"\nundefined\nlet indexs = []\nundefined\nlet count = 0\nundefined\nfor (let i = 0; i < a.length-1; i++) {\n    if(a[i]=== \" \"){\n        indexs.push(i)\n        count += 1\n    }\n}\n\nundefined\nindexs\n(4) [1, 3, 5, 11]\ncount\n4\n", "Knowledge_Point": "查找", "Question": "例如下面的字符串，想要查找空格分别在什么位置，并且出现过几次，有什么方法吗，具体一点\n\nvar a = \"s f g gghdf fhs\"\n", "Tag": "数据结构"}
{"Answer": "如果我的回答对你有帮助，请点击采纳按钮，谢谢\n思路：​首先我们输入 n 和 k 并且运用二分找到合适的尺寸，而l 必须要足够小，r 必须要足够的大。题中写道数组中的数最大不会超过 100000000 ，所以我们设 100000001 就可以了。\n现在就走到了判断的环节，我们如何判断 mid 是太小还是太大呢？我们需要编写一个新函数 -- f。\n在函数 f 中，我们依次要判断 a 中的每一个数并计算出能切出多少个 mid ，还要用一个变量 ans 储存他们，如果 ans 分的分数比 k 多或者正好等于，返回真。如果是小于 k ，返回假。\n当 f 返回的是真的时候，我们就要试试还能不能把 mid 调大一点，就要\nl = mid;如果返回的是假，我们就加的太大了，就要把 midmid 调小一点，就要\nr = mid;一直到结束，输出 l 就可以了。\n完整代码区：​    \n #include <bits/stdc++.h>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <string>\n#include <cstdio>\n#include <iomanip>\n#include <cstring>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nlong long n, k;\nlong long a[1000005];\n\nbool f(long long x) {\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) {\n        ans += a[i] / x;\n    }\n    return ans >= k;\n}\n\nint main() {\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    \n    long long l = 0, r = 100000001;\n    long long mid;\n    \n    while (l + 1 < r) {\n        mid = (l + r) / 2;\n        if (f(mid)) l = mid;\n        else r = mid;\n    }\n    cout << l << endl;\n    return 0;\n} \n\n", "Knowledge_Point": "查找", "Question": "二分查找判断是否合法设置的bool函数，请问定义int类型的数字有什么用啊？谢谢!", "Tag": "数据结构"}
{"Answer": "题目要求：首先输入一个正整数n(n<=100000)可你定义的数组是：int a[100] = { 0 };只有100个啊，改成int a[100000] = { 0 };", "Knowledge_Point": "查找", "Question": "在有序序列中查找某一元素x。\n输入 \n首先输入一个正整数n(n<=100000)，表示该序列有n个整数，然后按从小到大的顺序输入n个整数；\n接着是一个正整数m，表示有m次查找；\n最后是m个整数，表示m个要查找的整数x。\n输出 \n对于每一个次查找，有一行输出。若序列中存在要查找的元素x，则输出元素x在序列中的序号（序号从0开始）；若序列中不存在要查找的元素x，则输出\"Not found!\"。\n样例输入 Copy \n51 3 5 7 911-112345678910\n样例输出 Copy \nNot found!0Not found!1Not found!2Not found!3Not found!4Not found!\n\n#include //二分搜索 \n\nint main(void) {\n    int n, m, x, i;\n    int a[100] = { 0 };\n    int low, high, mid;\n    int flag = 0;\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    scanf(\"%d\", &m);\n\n    while (m--) {\n        flag = 0;\n        scanf(\"%d\", &x);\n\n        low = 0;\n        high = n - 1;\n        mid = (low + high) / 2;\n\n        while (low<=high) {\n            if (x == a[mid]) {\n                flag = 1;\n                break;\n            }\n            else if (x < a[mid]) {\n                high = mid - 1;\n                mid = (low + high) / 2;\n            }\n            else if (x > a[mid]) {\n                low = mid + 1;\n                mid = (low + high) / 2;\n            }\n        }\n\n        if (flag == 1)\n            printf(\"%d\\n\", mid);\n        else {\n            printf(\"Not found!\\n\");\n        }\n    }\n\n    return 0;\n}\n\n提交oj平台显示运行错误求解", "Tag": "数据结构"}
{"Answer": "#include<iostream>\nusing namespace std;\n//自己完成二分查找的递归和非递归算法\n//非递归二分查找算法\nint twoFind1(int A[], int len, int K)\n{\n    int low = 0, high = len - 1,middle;\n    if (low > high) return -2;\n    while (low <= high)//包含等于的情况\n    {\n        middle = (low + high) / 2;\n        if (K == A[middle]) return middle;\n        else if (K > A[middle]) low = middle + 1;\n        else high = middle - 1;\n    }\n    return -1;\n}\nint twoFind2(int A[], int len, int K)\n{\n    int low = 0, high = len - 1,middle;\n    if (low > high) return -2;\n    while (low < high)//不含等于的情况，并在最后做判断\n    {\n        middle = (low + high) / 2;\n        if (K == A[middle]) return middle;\n        else if (K > A[middle]) low = middle + 1;\n        else high = middle - 1;\n    }\n    if (low == high && A[low] == K) return low;\n    return -1;\n}\n//递归二分查找算法\nint twoFind3(int A[], int k, int low, int high)\n{\n    int middle=0;\n    if (low > high) return -1;\n    middle = (low + high) / 2;\n    if (low==high && A[middle] == k) return middle;\n    if (low < high) {\n        if (A[middle] < k)      return  twoFind3(A, k, middle + 1, high);\n        else  if(A[middle]==k)  return middle;\n        else                    return  twoFind3(A, k, 0, middle - 1);\n    }\n    return -1;\n}\nvoid Init_A(int *A,int n)\n{\n    int value = 0;\n    cout << \"请用户输入10个数据：\" << endl;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> value;\n        A[i] = value;\n    }\n}\nint main()\n{\n    int k = 0,m=0,l=0;\n    int * A = new int[10];\n    Init_A(A,10);\n    int len = 10;\n    cout << \"非递归测试1：\" << endl;\n    cout << \"要查找的元素值为：\"; cin >> k;\n    cout << \"所查找元素在数组中的位置为第：\" << twoFind1(A, len,k) + 1 << \"个\" << endl;\n    cout << \"非递归测试2：\" << endl;\n    cout << \"要查找的元素值为：\"; cin >> l;\n    cout << \"所查找元素在数组中的位置为第：\" << twoFind2(A, len,l) + 1 << \"个\" << endl;\n    cout << \"递归算法测试：\" << endl;\n    cout << \"要查找的元素值为：\"; cin >> m;\n    cout << \"所查找元素在数组中的位置为第：\" << twoFind3(A, m, 0, len - 1) + 1 << \"个\" << endl;\n}\n\n源码依法，可自行测试数据", "Knowledge_Point": "查找", "Question": "接收用户输入的10个数，完成如下操作：（1）接收用户输入的1个数，运用二分查找法查找该数是否在数据序列中；（2）要求编写二分查找的递归算法和非递归算法，并分别进行测试。", "Tag": "数据结构"}
{"Answer": "\n#include \"stdio.h\"\n\n#define MAXLEN 80\n\nint main( )\n\n{\n\nint count,i,k,flag,sub;\n\nchar cc,ch,oldch,str[MAXLEN];\n\noldch=' ';\n\ncc=getchar(); //读一个字符\n\ngetchar(); //读回车符\n\nwhile((ch=getchar())!='#'||oldch!='#')\n\n{\n\nk=0;\n\nwhile(ch!='#'&& k< MAXLEN-1) //读一个字符串\n\n{\n\nstr[k++]=ch;\n\nch=getchar();\n\n}\n\noldch='#';\n\nstr[k]='\\0';\n\n//请在两条星线之间填入相应的代码, 在字符串str中查找cc中包含的字符位置。\n\n/********************************************************************/\n\ni=0;flag=0;\nwhile(str[i]!='\\0'){\n\nif(str[i]==cc){\n\nsub=i;\n\nflag=1;\n\n}\n\ni++;\n\n}\n\n/********************************************************************/ if(flag) printf(\"%d\\n\",sub);\n\nelse printf(\"Not Found\\n\");\n\n}\n\n}\n", "Knowledge_Point": "查找", "Question": "输入一个字符并回车，再连续输入一批以 * 结束的字符串(字符串的长度不超过80)，遇 ** 则全部输入结束。在每个字符串中查找该字符，如果找到，则输出该字符在字符串中所对应的最大下标(下标从0开始)；否则输出“Not Found”。\n例：括号内是说明输入：m (输入一个字符)moonprogramming1234** (输入3个字符串\"moon\",\"programming\",\"1234\")输出：0 (m在\"moon\"中对应的最大下标是0)7 (m在\"programming\"中对应的最大下标是7)Not Found (\"1234\"中没有m)", "Tag": "数据结构"}
{"Answer": "你好，代码供参考\nfor c = 1:1000\nfor b = 2:c\nfor a = 2:c\nif(a^2+b^2==c^2 && a+b+c==1000)\ndisp([a,b,c])\nend\nend\nend\nend\n\n结果：\n   375   200   425\n   200   375   425\n\n有帮助望采纳呢", "Knowledge_Point": "查找", "Question": "毕达格拉斯三元组是指三个自然数满足a^2+b^2=c^2，已知仅存在一个三元组满足a+b+c=1000的条件，请编写一个MATLAB程序查找a,b和c的值。", "Tag": "数据结构"}
{"Answer": "\n\n二分查找法针对的是有序数组或者有序序列而言的折半查找法。你先给自己的数组排好序，再调用方法查询。\n", "Knowledge_Point": "查找", "Question": " \n\n\nimport java.util.Arrays;\npublic class ArrayUtilTest {\n\tpublic static void main(String[] args) {\n\t\tint[] arr = new int[] {1,2,5,6,7,9,4,0,8,3};\n\t\tint index = Arrays.binarySearch(arr, 0);\n        if(index >= 0) {\n\t\t\tSystem.out.println(\"找到了，索引位置为：\" + index);\n\t\t}else {\n\t\t\tSystem.out.println(\"未找到！\");\n\t\t}\n    }\n}\n\n\n\n打印结果是“未找到！”，求大神帮助", "Tag": "数据结构"}
{"Answer": "一旦执行了return语句，函数立即结束执行并返回。因此返回n之后就不再返回-1，若是没有返回n则最后返回-1", "Knowledge_Point": "查找", "Question": "int linearsearch(const int array[],int key,int size)\n{\n    int n;\n    for(n=0;n<100;n++)\n    {\n        if(array[n]==key)\n        {\n            return n;\n        }\n    }\n    return -1;\n}\n\n这个函数返回给主函数的值是不是总是-1？？   还是返回n后就不在返回-1", "Tag": "数据结构"}
{"Answer": "```\r\n$(\"#myTable tr:odd\")\r\n\r\n```", "Knowledge_Point": "查找", "Question": "这是一道笔试题，求解，本人对于jQuery的东西懂得比较少，请懂的大神赐教\njQuery 中查找id=\"myTable\"的table的所有偶数行，语法为？", "Tag": "数据结构"}
{"Answer": "l/2+r/2不能这么写的原因是小数位会发生错误不如l=1 r=3 l/2+r/2=0+1=1 但是正常应该是2，所以不能这么写而l+(l-r)/2永远都先做减法，避免了溢出的可能", "Knowledge_Point": "查找", "Question": "\n在二分查询中，确定mid的时候，因为在图一中（l+r）/2 容易导致溢出，所以改成了图二的表达式。为什么不可以写成l/2+r/2呢，l和r都除了2再相加，应该也不会造成数据溢出呀有人可以指点一下嘛", "Tag": "数据结构"}
{"Answer": "\nYou just need to add:\nif ($v['variant'] == $array)\n\ninside your if statement to compare the variant array with the one passed as an argument. \nfunction get_letter($letter, $array)\n{\n     foreach($this->content as $k => $v)\n     {\n          if(array_key_exists($letter, $v))\n          {\n               if ($v['variant'] == $array)\n                   return $k;\n          }\n     }\n\n     return false;\n}\n\n", "Knowledge_Point": "查找", "Question": "\n\nFollowing up this question, I have a further problem - I have two same sub keys, but they have different combination of array in their variant key, for instance,\n\nArray\n(\n    [1] => Array\n        (\n            [b] => Array\n                (\n                    [quantity_request] => 1\n                    [time_created] => 1339688613\n                    [variant] => Array\n                        (\n                         [0] => x\n                         [1] => y\n                        )\n\n                )\n\n        )\n\n    [2] => Array\n        (\n            [b] => Array\n                (\n                    [quantity_request] => 1\n                    [time_created] => 1339688631\n                    [variant] => Array\n                        (\n                         [0] => x\n                         [1] => z\n                        )\n\n                )\n\n        )\n\n    [3] => Array\n        (\n            [c] => Array\n                (\n                    [quantity_request] => 1\n                    [time_created] => 1339688959\n                    [variant] => Array\n                        (\n                        )\n\n                )\n\n        )\n\n)\n\n\nso, how can I find the match of this item,\n\n    [b] => Array\n                        (\n                            [quantity_request] => 1\n                            [time_created] => 1339688631\n                            [variant] => Array\n                                (\n                                 [0] => x\n                                 [1] => z\n                                )\n\n                        )\n\n    function get_letter($letter,$array)\n        {\n            foreach($this->content as $k => $v)\n            {\n                if(array_key_exists($letter, $v))\n                {\n                    return $k;\n\n                }\n            }\n            return false;\n\n        }\n\nlist($key,$different) = get_letter('b',array(\"x\",\"z\")); // return 1\n\n\nI want the result like this if there is a match,\n\n2\n\n\nAny ideas?\n    ", "Tag": "数据结构"}
{"Answer": "\nimport re\n\ntxt ='''\n<td class=\"abcde:0:no_22\" style=\"white;\"><center>需要提取的内容1</center>\n<td class=\"abcde:1:no_22\" style=\"white;\"><center>需要提取的内容2</center>\n<td class=\"abcde:2:no_22\" style=\"white;\"><center>需要提取的内容3</center>\n'''\nres = re.findall(r':no_22\" style=\"white;\"><center>(.*?)</center>',txt)\nprint(res)\n\n输出结果\n['需要提取的内容1', '需要提取的内容2', '需要提取的内容3']", "Knowledge_Point": "查找", "Question": "需查找的内容：\n\n需要提取的内容1\n需要提取的内容2\n需要提取的内容3\n\n\n#使用这条匹配返回结果为空​​​​​\n'''no_222\" style=\"white;\">(.*)'''\n\n#使用这条匹配能正常查到匹配条件的内容\n'''no_222\" style=\"white;\">'''\n \n#使用这条匹配返回结果就为空了​​​​​\n'''no_222\" style=\"white;\"><'''", "Tag": "数据结构"}
{"Answer": "\nThe function below will recursively walk through a directory and return the paths to all files whose name matches the given pattern:\nfunc WalkMatch(root, pattern string) ([]string, error) {\n    var matches []string\n    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n        if info.IsDir() {\n            return nil\n        }\n        if matched, err := filepath.Match(pattern, filepath.Base(path)); err != nil {\n            return err\n        } else if matched {\n            matches = append(matches, path)\n        }\n        return nil\n    })\n    if err != nil {\n        return nil, err\n    }\n    return matches, nil\n}\n\nUsage:\nfiles, err := WalkMatch(\"/root/\", \"*.md\")\n\n", "Knowledge_Point": "查找", "Question": "\n\nI have a directory structure that looks like this:\n\n/root\n  /folder_1\n    file_name_1.md\n  /folder_2\n    file_name_2.md\n  /folder_3\n    file_name_3.md\n  /folder_4\n    /sub_folder_1\n      file_name_4_1.md\n    file_name_4.md\n\n\nIs there a glob function that I could use to get an array containing the file path of the .md files?\n\nFor example:\n\n[\n  \"/root/folder_1/file_name_1.md\",\n  \"/root/folder_2/file_name_2.md\",\n  \"/root/folder_3/file_name_3.md\",\n  \"/root/folder_4/sub_folder_1/file_name_4_1.md\",\n  \"/root/folder_4/file_name_4.md\"\n]\n\n\nThanks.\n    ", "Tag": "数据结构"}
{"Answer": "Shader.Find(ShaderName)；\r\n名字就是你Shader的名字。如果资源加载不到，那建议放在Resource里，或者在Editor -> Project Settings -> Graphics -> Always Included Shaders 中添加该shader", "Knowledge_Point": "查找", "Question": "导入了一个插件，它用了一个废弃的方法，第二行是废弃的\n\nstring tmpStr=\"Shader \\\"Hidden/tmp_shdr\\\"{SubShader{Pass{}}}\";\nMaterial a = new Material(tmpStr);\n\n\n在只知道这个 tmpStr 的情况下有办法找到 material吗？这行字符串是什么意思？我在project里搜索关键字都没有找到\n\n我知道可以使用Shader.Find(\"???\") //但是名字是什么呢?\n", "Tag": "数据结构"}
{"Answer": "如果不是有序的，那么比较绝对值，找到最小的。\r\n```\r\n#include \r\n\r\nint main()\r\n{\r\n\tint min = (1 << 31) - 1;\r\n\tint idx = 0;\r\n\tint arr[] = {915,941,960,976,992,1015,1034,1050,1073,1089,1115,1131,1150,1166,1182,1208,1227};\r\n\tint n = 1000;\r\n\tfor (int i = 0; i < sizeof(arr) / sizeof(int); i++)\r\n\t{\r\n\t\tint diff = arr[i] - n;\r\n\t\tif (diff < 0) diff = -diff;\r\n\t\tif (diff < min)\r\n\t\t{\r\n\t\t\tmin = diff;\r\n\t\t\tidx = i;\r\n\t\t}\r\n\t}\r\n\tprintf(\"最接近的是%d 下标是%d\", arr[idx], idx);\r\n   \treturn 0;\r\n}\r\n```\r\n最接近的是992 下标是4", "Knowledge_Point": "查找", "Question": "举例如下：一个数组{915,941,960,976,992,1015,1034,1050,1073,1089,1115,1131,1150,1166,1182,1208,1227};目标值假设是1000，我自己之前用插值算法公式mid = start + (end - start) * ( (key-a[start])/(a[end]-a[start]) )可以快速查找出中间位置，算出大概接近的元素，输出下标，但是我的实际需求数组不一定都是这么有序或者单调的，为保证更准确，我想将目标值一个一个去比对，然后找出数组中最接近的元素，输出数组下标，求老师们帮忙指导一下，求代码和注释", "Tag": "数据结构"}
{"Answer": "\nThere are many ways, but one of them could be to use strpos:\n$mystring = 'This Question is about php strings';\n\n$wordsToFind = array('php','strings','Question');\n\nforeach ($wordsToFind as $word)\n    if (strpos($mystring, $word)) {\n        echo $word.' has been found'; echo \"\n\";\n    }\n\nYou can try it out here\n", "Knowledge_Point": "查找", "Question": "\n\ni am writing a blog script .\n\ni want to find tags from the article .. \n\nwhat is the best way to find tags from the body string in php\n\nExample :\nif an article body contains this string\n\n'This Question is about php strings'\n\nso the script should get php string and Question as tag .\n    ", "Tag": "数据结构"}
{"Answer": "#include <stdio.h>\n\nint main()\n{\n    int n, x, i, a[20];\n    int flag = 0; // 设定表示是否找到要查找的数字的标志\n\n    scanf(\"%d %d\", &n, &x);\n    for(i=0; i<n; i++)\n        scanf(\"%d\", &a[i]);\n\n    for(i=0; i<n; i++)\n    {\n        if(a[i] == x) // 找到了要查找的数字\n        {\n            printf(\"%d\", i);\n            flag = 1;\n            break;\n        }\n    }\n\n    if(flag == 0)\n        printf(\"Not Found\");\n\n    return 0;\n}\n\n", "Knowledge_Point": "查找", "Question": "输入格式：输入在第一行中给出两个正整数N（≤20）和X，第二行给出N个整数。数字均不超过长整型，其间以空格分隔。输出格式：在一行中输出X的位置，或者“Not Found”。", "Tag": "数据结构"}
{"Answer": "该回答引用GPT:使用od或hexdump查找某个字符串在文件中的准确位置，可以使用以下命令：\nod -t x1 -N <字符串长度> -A n <文件名> | grep -b -o <字符串>\n\n其中，-t x1表示以16进制显示，-N表示显示字符串长度，-A n表示以字符串的形式显示，grep -b -o表示输出字符串在文件中的位置。如还有疑问，可留言帮助解决。", "Knowledge_Point": "查找", "Question": "ubuntu中如何使用命令od或hexdump查找某个字符串在文件中的准确位置", "Tag": "数据结构"}
{"Answer": "\nWith the following snippet you have a general idea how to do it:\nforeach ($people as $i => $person)\n{\n    if (array_key_exists('name', $person) && $person['name'] == 'Waldo')\n        echo('Waldo found at ' . $i);\n}\n\nThen you can make the previous snippet as a general use function like:\nfunction SearchArray($array, $searchIndex, $searchValue)\n{\n    if (!is_array($array) || $searchIndex == '')\n        return false;\n\n    foreach ($array as $k => $v)\n    {\n        if (is_array($v) && array_key_exists($searchIndex, $v) && $v[$searchIndex] == $searchValue)\n            return $k;\n    }\n\n    return false;\n}\n\nAnd use it like this:\n$foundIndex = SearchArray($people, 'name', 'Waldo'); //Search by name\n$foundIndex = SearchArray($people, 'age', 89); //Search by age\n\nBut watch out as the function can return 0 and false which both evaluates to false (use something like if ($foundIndex !== false) or if ($foundIndex === false)).\n", "Knowledge_Point": "查找", "Question": "\n\nI'm sure there is an easy way to do this, but I can't think of it right now. Is there an array function or something that lets me search through an array and find the item that has a certain property value? For example:\n\n$people = array(\n  array(\n    'name' => 'Alice',\n    'age' => 25,\n  ),\n  array(\n    'name' => 'Waldo',\n    'age' => 89,\n  ),\n  array(\n    'name' => 'Bob',\n    'age' => 27,\n  ),\n);\n\n\nHow can I find and get Waldo?\n    ", "Tag": "数据结构"}
{"Answer": "参考下这个,.自己修改下\n#-*- coding:utf-8 -*-\nimport json\n\nclass System():\n    def __init__(self):\n        self.data = []\n        self.load()\n        while True:\n            s = self.menu()\n            if s==\"1\":\n                self.inquire()\n            elif s==\"2\":\n                self.add()\n            elif s==\"3\":\n                self.delete()\n            elif s==\"4\":\n                self.revise()\n            elif s==\"5\":\n                self.save()\n                break\n\n    def load(self):\n        try:\n            with open(\"data.txt\",\"r\") as f:\n                d = f.read()\n                self.data = json.loads(d)\n        except Exception:\n            self.data = []\n\n    def save(self):\n        with open(\"data.txt\",\"w\") as f:\n            f.write(json.dumps(self.data))\n\n    def menu(self):\n        print(\"********** 学生信息管理 *************\")\n        print(\"\\t1.查询\")\n        print(\"\\t2.添加\")\n        print(\"\\t3.删除\")\n        print(\"\\t4.修改\")\n        print(\"\\t5.保存并退出\")\n        print(\"***********************************\")\n        return input(\"请输入1-5选择功能并按回车：\")\n\n    def inputDsta(self):\n        return {\n            \"学号\": input(\"输入学号:\"),\n            \"姓名\": input(\"输入姓名:\"),\n            \"性别\": input(\"输入性别:\"),\n            \"年龄\": input(\"输入年龄:\"),\n            \"电话\": input(\"输入电话:\")\n        }\n\n    def inputID(self,t):\n        while True:\n            try:\n                i = int(input(t))-1\n                if 0 <= i < len(self.data):\n                    return i\n                else:\n                    print(\"输入id超出范围，请重新输入。\")\n            except ValueError:\n                print(\"输入错误，请重新输入。\")\n\n    def inquire(self):\n        print(\"id\\t学号\\t姓名\\t性别\\t年龄\\t电话\")\n        for i,d in enumerate(self.data):\n            print(f\"{i+1}\\t{d['学号']}\\t{d['姓名']}\\t{d['性别']}\\t{d['年龄']}\\t{d['电话']}\")\n\n    def add(self):\n        self.data.append(self.inputDsta())\n\n    def delete(self):\n        i = self.inputID(\"请输入要删除信息的id:\")\n        del self.data[i]\n        print(f\"id为{i+1}的信息已删除\")\n\n    def revise(self):\n        i = self.inputID(\"请输入要修改信息的id:\")\n        self.data[i] = self.inputDsta()\n\nsys = System()\n", "Knowledge_Point": "查找", "Question": "1.实现一个基于面向对象思想的、具有添加、查看、删除、修改、查找、保存数据功能的通讯录程序。2.联系人信息包括姓名、性别、手机号。3.设计一个Friend类，该类中包括__init__( )、welcome( )、add_friend( )、show_friend( )、del_friend( )、modify_friend( )、find_friend( )、save_to_file( )、recover_data( )共9个方法。4.数据保存到文件“backup.data”中，程序运行时自动从文件恢复数据，若没有数据则捕获异常，新建一个空白文件。", "Tag": "数据结构"}
{"Answer": "\nstrpos returns the position of the occurrence in the string starting with 0 or false otherwise. Using just a boolean conversion like in the following is a common mistake:\n$str1 = \"mod 1 + mode 2 + comp 1 + toto\";\nif (strpos($str, \"mod 1\")) {\n    // found\n}\n\nBecause in this case strpos will return 0. But 0 converted to Boolean is false:\nvar_dump((bool) 0 === false);  // bool(true)\n\nSo you need to use a strict comparison:\n$str1 = \"mod 1 + mode 2 + comp 1 + toto\";\nif (strpos($str, \"mod 1\") !== false) {\n    // found\n}\n\nThis is also what the documentation advises:\n\nWarning This function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.\n\n", "Knowledge_Point": "查找", "Question": "\n\nI have a string like this: $str1 = \"mod 1 + mode 2 + comp 1 + toto\".\n\nI would like to test if mod 1 is in $str1. I used strpos but this function doesn't help.\n    ", "Tag": "数据结构"}
{"Answer": "\nIf explode() is banned, dare I suggest using regular expressions?\n$string = preg_replace('/\nxyz.*/', '', $string);\n\nThis will match a line beginning with xyz and delete up to the next line break.\n", "Knowledge_Point": "查找", "Question": "\n\nI need help with working with one String using PHP.\n\nString Example:\n\nThis is line\nthis is second line\nthis is third line\nxyz next line\nthis is fifth line\n\n\nHow to delete line starts with \"xyz\" without using string function explode() with comparing beginning of each row? \n\nAll I need is to find \"xyz\" and delete this row to end. I hope that exist simpler solution like explode with comparing each row.\n    ", "Tag": "数据结构"}
{"Answer": "你的二分查找不能用字符串直接和整型计算，你需要用int将字符串转变一下，另外数组名要紧跟索引。", "Knowledge_Point": "查找", "Question": "折半查找： 1个列表里存储了20个子列表，各子列表内存储了学生的学号及姓名两个元素，两个元素都是字符串类型。现已知该20个学生子列表已按学号递增排好序。请设计一个程序，使用折半查找算法通过最少次数的比较找到指定学号学生，如果没有，报告未找到。\n", "Tag": "数据结构"}
{"Answer": "普里姆算法是选顶点\r\n假设从A点出发构造最小生成树，距离A点最近的是D点，连接AD；然后距离A、D最近的是B点，连接BD；然后距离A、D、B最近的是C点，连接BC；\r\n然后距离A、D、B、C最近的是F点，连接CF；然后距离A、D、B、C、F最近的是G，连接FG；然后距离A、D、B、C、F、G点最近的是E点，连接GE；\r\n然后距离A、D、B、C、F、G、E点最近的是H点，连接EH。\r\n最小生成树为ADBCFGEH\r\n克鲁斯卡尔算法是选边\r\n边权为2最小，连接BC，EG；然后边权为3最小，连接EH；然后边权为4最小，连接CF，AD；然后边权为5最小，连接BD，FG。\r\n最小生成树为ADBCFGEH", "Knowledge_Point": "最小生成树", "Question": "用普里姆算法或克鲁斯卡尔算法求下面无向带权图的最小生成树", "Tag": "数据结构"}
{"Answer": "prim算法\ndef findTree(G:dict):\n    start = list(G.keys())[0]\n    choice = [(start, i, j) for i, j in G[start].items()]\n    choice.sort(key=lambda x:x[2])\n    tree = list()\n    seen = {start}\n    while choice:\n        node = choice.pop(0)\n        if node[1] not in seen:\n            seen.add(node[1])\n            line = sorted([node[0],node[1]])\n            line.append(node[2])\n            tree.append(line)\n            for i, j in G[node[1]].items():\n                choice.append((node[1],i,j))\n            choice.sort(key=lambda x:x[2])\n    return tree\n\nif __name__ == \"__main__\":\n    graph = {\n    \"a\":{\"b\":10, \"c\":8, \"f\":5},\n    \"b\":{\"a\":10, \"d\":9, \"f\":7},\n    \"c\":{\"a\":8, \"e\":10, \"f\":17},\n    \"d\":{\"b\":9, \"e\":11, \"f\":12, \"g\":4},\n    \"e\":{\"c\":10, \"d\":11, \"f\":3, \"g\":16},\n    \"f\":{\"a\":5, \"b\":7, \"c\":17, \"d\":12, \"e\":3},\n    \"g\":{\"d\":4, \"e\":16}\n    }\n    lines = set()\n    for node, value in graph.items():\n        for i, j in value.items():\n            temp = sorted([node,i])\n            temp.append(j)\n            lines.add(tuple(temp))\n    print(lines)\n    tree = findTree(graph)\n    print(tree)\n", "Knowledge_Point": "最小生成树", "Question": "已知带权无向图（如下所示），求最小生成树。Program2用图要求输出：(1)所有的边及权值，如：（‘a’,’b’,10）…(2)最小生成树所包含的边，如：（’a’,‘c’,‘weight’:8）…\n", "Tag": "数据结构"}
{"Answer": "def mctFromLeafValues( arr):\n    res = 0\n    while len(arr) > 1:\n        min_val = min(arr)\n        idx = arr.index(min_val)\n        if idx > 0 and idx < len(arr) - 1: #有左有右\n            left_val, right_val = arr[idx - 1], arr[idx + 1]\n        elif idx == len(arr) - 1: #有左没右\n            left_val, right_val = arr[idx - 1], 16 #为什么是16？因为最大只有15\n        elif idx == 0: #有右没左\n            left_val, right_val = 16, arr[idx + 1]\n            \n        res += min(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) #把当前最小值删掉，已经用完了\n    return res\narr = [5,1,4]\nprint(mctFromLeafValues(arr))\n", "Knowledge_Point": "最小生成树", "Question": "用python语言实现最小代价生成树问题，利用分支限界算法python", "Tag": "数据结构"}
{"Answer": "\n插入操作是一个比较复杂的过程，具体步骤如下:\n我们假定要插入的值为k。\n如果当前树为空，则直接插入根。\n如果当前节点的权值等于k则增加当前节点的大小并更新节点和父亲的信息，将当前节点进行splay操作。\n否则按照二叉查找树的性质向下找，找到空节点就插入即可，当然在最后还要进行一次splay操作。\n[3]\n\n", "Knowledge_Point": "伸展树", "Question": "什么是伸展树的操作的插入(insert)", "Tag": "数据结构"}
{"Answer": "\n比较操作的次数介于\n  \n    \n      \n        (\n        n\n        log\n        ⁡\n        n\n        )\n        \n          /\n        \n        2\n      \n    \n    {\\displaystyle (n\\log n)/2}\n  \n和\n  \n    \n      \n        n\n        log\n        ⁡\n        n\n        −\n        n\n        +\n        1\n      \n    \n    {\\displaystyle n\\log n-n+1}\n  \n。\n赋值操作的次数是\n  \n    \n      \n        (\n        2\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle (2n\\log n)}\n  \n。归并算法的空间复杂度为：\n  \n    \n      \n        Θ\n        (\n        n\n        )\n      \n    \n    {\\displaystyle \\Theta (n)}\n  \n\n\n", "Knowledge_Point": "归并排序", "Question": "什么是归并排序的算法复杂度", "Tag": "数据结构"}
